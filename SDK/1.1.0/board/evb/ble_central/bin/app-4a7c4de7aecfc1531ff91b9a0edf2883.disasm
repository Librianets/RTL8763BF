
========================================================================

** ELF Header Information

    File Name: E:\work\project\P1871\source_2\BEE2-SDK-v1.1.0-git\ble\board\evb\ble_central\Objects\app.axf

    Machine class: ELFCLASS32 (32-bit)
    Data encoding: ELFDATA2LSB (Little endian)
    Header version: EV_CURRENT (Current version)
    Operating System ABI: none
    ABI Version: 0
    File Type: ET_EXEC (Executable) (2)
    Machine: EM_ARM (ARM)

    Image Entry point: 0x0080e409
    Flags: EF_ARM_HASENTRY (0x05000002)

    ARM ELF revision: 5 (ABI version 2)

    Conforms to Base float procedure-call standard

    Built with
    Component: ARM Compiler 5.06 update 1 (build 61) Tool: armasm [4d35a5]
    Component: ARM Compiler 5.06 update 1 (build 61) Tool: armlink [4d35a8]

    Header size: 52 bytes (0x34)
    Program header entry size: 32 bytes (0x20)
    Section header entry size: 40 bytes (0x28)

    Program header entries: 2
    Section header entries: 23

    Program header offset: 422424 (0x00067218)
    Section header offset: 422488 (0x00067258)

    Section header string table index: 22

========================================================================

** Program header #0 (PT_LOAD) [PF_X + PF_W + PF_R + PF_ARM_ENTRY]
    Size : 28380 bytes (27044 bytes in file)
    Virtual address: 0x0080e000 (Alignment 4)


====================================

** Program header #1 (PT_LOAD) [PF_R]
    Size : 10112 bytes
    Virtual address: 0x08800000 (Alignment 4)


========================================================================

** Section #1 'app.bin' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 1024 bytes (alignment 4)
    Address: 0x0080e000

    0x80e000:   05 00 01 01 93 27 00 00 00 01 00 00 6d 67 de f1    .....'......mg..
    0x80e010:   3e 33 e8 11 b1 02 4d 2d f4 0c de 01 00 e4 80 00    >3....M-........
    0x80e020:   00 e4 80 00 00 00 00 00 00 e0 80 00 00 00 00 00    ................
    0x80e030:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e040:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e050:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e060:   01 20 00 00 a8 ac 83 2a 73 64 6b 23 23 23 23 23    . .....*sdk#####
    0x80e070:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e080:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e090:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e100:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e110:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e120:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e130:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e140:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e150:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e160:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e170:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e180:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e190:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1d0:   00 00 00 00 00 00 00 00 01 d1 85 0e 80 bf 20 00    .............. .
    0x80e1e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e200:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e210:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e220:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e230:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e240:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e250:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e260:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e270:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e280:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e290:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2e0:   ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................
    0x80e2f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e300:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e310:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e320:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e330:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e340:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e350:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e360:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e370:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e380:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e390:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3f0:   ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................


** Section #2 'FLASH_START_ADDR' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 8 bytes (alignment 4)
    Address: 0x0080e400

    $t
    RESET
    $v0
    Reset_Handler
;;; ..\\..\\..\\src\\mcu\\rtl876x\\arm\\startup_rtl8762c.s
;;;96                     IMPORT SystemInit
;;;96                     LDR    R0, =SystemInit
        0x0080e400:    4800        .H      LDR      r0,[pc,#0] ; [0x80e404] = 0x80e55f
;;;97                     BX     R0
        0x0080e402:    4700        .G      BX       r0
    $d
        0x0080e404:    0080e55f    _...    DCD    8447327

** Section #3 'FLASH_TEXT' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 884 bytes (alignment 4)
    Address: 0x0080e408

    $t
    !!!main
    __main
        0x0080e408:    f3af8000    ....    NOP.W    
        0x0080e40c:    f5f9f3f8    ....    BL       __rt_entry ; 0x207c00
    .app.flash.text
    ram_init
;;;369    {
        0x0080e410:    b510        ..      PUSH     {r4,lr}
;;;370        //copy data on ro
;;;371        extern char Image$$RAM_DATA_ON$$RO$$Base[];
;;;372        extern char Load$$RAM_DATA_ON$$RO$$Base[];
;;;373        extern unsigned int Image$$RAM_DATA_ON$$RO$$Length;
;;;374    
;;;375        memcpy(Image$$RAM_DATA_ON$$RO$$Base,
        0x0080e412:    4a7c        |J      LDR      r2,[pc,#496] ; [0x80e604] = 0x5324
        0x0080e414:    497c        |I      LDR      r1,[pc,#496] ; [0x80e608] = 0x80e870
        0x0080e416:    487d        }H      LDR      r0,[pc,#500] ; [0x80e60c] = 0x207c00
        0x0080e418:    f44bf53f    K.?.    BL       __aeabi_memcpy ; 0x59e9a
;;;376               Load$$RAM_DATA_ON$$RO$$Base,
;;;377               (unsigned int)&Image$$RAM_DATA_ON$$RO$$Length);
;;;378    
;;;379        //copy data on rw
;;;380        extern char Image$$RAM_DATA_ON$$RW$$Base[];
;;;381        extern char Load$$RAM_DATA_ON$$RW$$Base[];
;;;382        extern unsigned int Image$$RAM_DATA_ON$$RW$$Length;
;;;383    
;;;384        memcpy(Image$$RAM_DATA_ON$$RW$$Base,
        0x0080e41c:    4a7c        |J      LDR      r2,[pc,#496] ; [0x80e610] = 0x74
        0x0080e41e:    497d        }I      LDR      r1,[pc,#500] ; [0x80e614] = 0x813b94
        0x0080e420:    487d        }H      LDR      r0,[pc,#500] ; [0x80e618] = 0x20cf24
        0x0080e422:    f44bf53a    K.:.    BL       __aeabi_memcpy ; 0x59e9a
;;;385               Load$$RAM_DATA_ON$$RW$$Base,
;;;386               (unsigned int)&Image$$RAM_DATA_ON$$RW$$Length);
;;;387    
;;;388        //clear data on zi
;;;389        extern char Image$$RAM_DATA_ON$$ZI$$Base[];
;;;390        extern unsigned int Image$$RAM_DATA_ON$$ZI$$Length;
;;;391    
;;;392        memset(Image$$RAM_DATA_ON$$ZI$$Base,
        0x0080e426:    497d        }I      LDR      r1,[pc,#500] ; [0x80e61c] = 0x538
        0x0080e428:    487d        }H      LDR      r0,[pc,#500] ; [0x80e620] = 0x20cf98
        0x0080e42a:    f44bf5f7    K...    BL       __aeabi_memclr ; 0x5a01c
;;;393               0,
;;;394               (unsigned int)&Image$$RAM_DATA_ON$$ZI$$Length);
;;;395    
;;;396        //copy cache ro
;;;397        extern char Image$$CACHE_DATA_ON$$RO$$Base[];
;;;398        extern char Load$$CACHE_DATA_ON$$RO$$Base[];
;;;399        extern unsigned int Image$$CACHE_DATA_ON$$RO$$Length;
;;;400    
;;;401        memcpy(Image$$CACHE_DATA_ON$$RO$$Base,
        0x0080e42e:    4a7d        }J      LDR      r2,[pc,#500] ; [0x80e624] = 0xcdc
        0x0080e430:    497d        }I      LDR      r1,[pc,#500] ; [0x80e628] = 0x813cc8
        0x0080e432:    487e        ~H      LDR      r0,[pc,#504] ; [0x80e62c] = 0x21c000
        0x0080e434:    f44bf531    K.1.    BL       __aeabi_memcpy ; 0x59e9a
;;;402               Load$$CACHE_DATA_ON$$RO$$Base,
;;;403               (unsigned int)&Image$$CACHE_DATA_ON$$RO$$Length);
;;;404    
;;;405        //copy share cache ram rw
;;;406        extern char Image$$CACHE_DATA_ON$$RW$$Base[];
;;;407        extern char Load$$CACHE_DATA_ON$$RW$$Base[];
;;;408        extern unsigned int Image$$CACHE_DATA_ON$$RW$$Length;
;;;409    
;;;410        memcpy(Image$$CACHE_DATA_ON$$RW$$Base,
        0x0080e438:    4a7d        }J      LDR      r2,[pc,#500] ; [0x80e630] = 0
        0x0080e43a:    497e        ~I      LDR      r1,[pc,#504] ; [0x80e634] = 0x8149a4
        0x0080e43c:    487e        ~H      LDR      r0,[pc,#504] ; [0x80e638] = 0x21ccdc
        0x0080e43e:    f44bf52c    K.,.    BL       __aeabi_memcpy ; 0x59e9a
;;;411               Load$$CACHE_DATA_ON$$RW$$Base,
;;;412               (unsigned int)&Image$$CACHE_DATA_ON$$RW$$Length);
;;;413    
;;;414        //clear share cache ram zi
;;;415        extern char Image$$CACHE_DATA_ON$$ZI$$Base[];
;;;416        extern unsigned int Image$$CACHE_DATA_ON$$ZI$$Length;
;;;417    
;;;418        memset(Image$$CACHE_DATA_ON$$ZI$$Base,
        0x0080e442:    e8bd4010    ...@    POP      {r4,lr}
        0x0080e446:    497d        }I      LDR      r1,[pc,#500] ; [0x80e63c] = 0
        0x0080e448:    487d        }H      LDR      r0,[pc,#500] ; [0x80e640] = 0x21ccdc
        0x0080e44a:    f44bb5e7    K...    B        __aeabi_memclr ; 0x5a01c
    random_seed_init
;;;419               0,
;;;420               (unsigned int)&Image$$CACHE_DATA_ON$$ZI$$Length);
;;;421    }
;;;422    
;;;423    uint32_t random_seed_value;
;;;424    
;;;425    APP_FLASH_TEXT_SECTION
;;;426    void random_seed_init(void)
;;;427    {
        0x0080e44e:    b57f        ..      PUSH     {r0-r6,lr}
;;;428        uint16_t crc16;
;;;429        uint8_t buf[DATA_SIZE_FOR_RANDOM_SEED];
;;;430        uint8_t *sour_addr = (uint8_t *)(OTP->appDataAddr + OTP->appDataSize + OTP->heapDataONSize);
        0x0080e450:    f44f1000    O...    MOV      r0,#0x200000
        0x0080e454:    e9f012e0    ....    LDRD     r1,r2,[r0,#0x380]!
        0x0080e458:    4411        .D      ADD      r1,r1,r2
        0x0080e45a:    6880        .h      LDR      r0,[r0,#8]
        0x0080e45c:    2210        ."      MOVS     r2,#0x10
        0x0080e45e:    180d        ..      ADDS     r5,r1,r0
;;;431    
;;;432        memcpy(buf, sour_addr, DATA_SIZE_FOR_RANDOM_SEED);
        0x0080e460:    4629        )F      MOV      r1,r5
        0x0080e462:    4668        hF      MOV      r0,sp
        0x0080e464:    f44bf519    K...    BL       __aeabi_memcpy ; 0x59e9a
;;;433        crc16 = btxfcs(0, buf, DATA_SIZE_FOR_RANDOM_SEED);
        0x0080e468:    2210        ."      MOVS     r2,#0x10
        0x0080e46a:    4669        iF      MOV      r1,sp
        0x0080e46c:    2000        .       MOVS     r0,#0
        0x0080e46e:    f7f8dfb1    ....    BL       btxfcs ; 0x73d4
;;;434    
;;;435        random_seed_value = (crc16 << 16) | (*(volatile uint32_t *)(0x4005817C) & 0xFFFF);
        0x0080e472:    4974        tI      LDR      r1,[pc,#464] ; [0x80e644] = 0x40058000
        0x0080e474:    f8d1117c    ..|.    LDR      r1,[r1,#0x17c]
        0x0080e478:    4e73        sN      LDR      r6,[pc,#460] ; [0x80e648] = 0x20cf98
        0x0080e47a:    f360411f    `..A    BFI      r1,r0,#16,#16
;;;436    
;;;437        random_seed_value *= platform_random(0xFFFFFFFF);
        0x0080e47e:    f04f30ff    O..0    MOV      r0,#0xffffffff
        0x0080e482:    60f1        .`      STR      r1,[r6,#0xc]
        0x0080e484:    f7f9d995    ....    BL       platform_random ; 0x77b2
        0x0080e488:    68f1        .h      LDR      r1,[r6,#0xc]
        0x0080e48a:    4348        HC      MULS     r0,r1,r0
;;;438    
;;;439        srand(random_seed_value);
        0x0080e48c:    60f0        .`      STR      r0,[r6,#0xc]
        0x0080e48e:    f60ef0e9    ....    BL       srand ; 0x21c664
;;;440    
;;;441        for (int i = 0; i < (DATA_SIZE_FOR_RANDOM_SEED / 4); ++i)
        0x0080e492:    2400        .$      MOVS     r4,#0
        0x0080e494:    f60df5c2    ....    BL       rand ; 0x21c01c
        0x0080e498:    f8450024    E.$.    STR      r0,[r5,r4,LSL #2]
        0x0080e49c:    1c64        d.      ADDS     r4,r4,#1
        0x0080e49e:    2c04        .,      CMP      r4,#4
        0x0080e4a0:    dbf8        ..      BLT      0x80e494 ; random_seed_init + 70
;;;442        {
;;;443            *(uint32_t *)(sour_addr + i * 4) = rand();
;;;444        }
;;;445    
;;;446        random_seed_value = rand();
        0x0080e4a2:    f60df5bb    ....    BL       rand ; 0x21c01c
        0x0080e4a6:    60f0        .`      STR      r0,[r6,#0xc]
;;;447    }
        0x0080e4a8:    bd7f        ..      POP      {r0-r6,pc}
    print_reset_reason
;;;448    
;;;449    APP_FLASH_TEXT_SECTION
;;;450    void SystemInit(void)
;;;451    {
;;;452        //hci mode check and bypass app
;;;453        if (check_hci_mode_flag())
;;;454        {
;;;455            return;
;;;456        }
;;;457    
;;;458        //init pre_main and main functions
;;;459        extern void pre_main(void);
;;;460        app_pre_main = (APP_MAIN_FUNC)pre_main;
;;;461        app_main = (APP_MAIN_FUNC)common_main;
;;;462    
;;;463        /******** update otp here**********/
;;;464        //ram config
;;;465        OTP->appDataSize = APP_GLOBAL_SIZE;
;;;466        OTP->heapDataONSize = HEAP_DATA_ON_SIZE - DATA_SIZE_FOR_RANDOM_SEED;
;;;467    
;;;468        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;469    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;470        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
;;;471    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;472        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;473    #else
;;;474        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;475    #endif
;;;476    
;;;477        //sw timer config
;;;478    #ifdef TIMER_MAX_NUMBER
;;;479        //define TIMER_MAX_NUMBER in otp_config.h
;;;480        OTP->timerMaxNumber = TIMER_MAX_NUMBER;
;;;481    #endif
;;;482    
;;;483        //flash config
;;;484        /*config enable flash block proect depending on flash layout and flash id*/
;;;485    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;486        OTP->bp_enable = 1;
;;;487    #else
;;;488        OTP->bp_enable = 0;
;;;489    #endif
;;;490        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
;;;491    
;;;492    
;;;493        //os config
;;;494        /*config enable check task stack overflow*/
;;;495    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;496        OTP->checkForStackOverflow = 1;
;;;497    #else
;;;498        OTP->checkForStackOverflow = 0;
;;;499    #endif
;;;500    
;;;501    
;;;502        //platform config
;;;503        /*config enable platform assert*/
;;;504    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;505        OTP->enableASSERT = 1;
;;;506    #else
;;;507        OTP->enableASSERT = 0;
;;;508    #endif
;;;509    
;;;510        /*Print all log in log buffer before entering DLPS */
;;;511    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;512        OTP->printAllLogBeforeEnterDLPS = 1;
;;;513    #else
;;;514        OTP->printAllLogBeforeEnterDLPS = 0;
;;;515    #endif
;;;516    
;;;517        /*config enable log or not*/
;;;518    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;519        OTP->logDisable = 0;
;;;520    #else
;;;521        OTP->logDisable = 1;
;;;522    #endif
;;;523    
;;;524        /*config enable swd pinmux*/
;;;525    #if (SWD_PINMUX_ENABLE == 1)
;;;526        OTP->SWD_ENABLE = 1;
;;;527    #else
;;;528        OTP->SWD_ENABLE = 0;
;;;529    #endif
;;;530    
;;;531        /*config enable watch dog in rom*/
;;;532    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;533        OTP->wdgEnableInRom = 1;
;;;534    #else
;;;535        OTP->wdgEnableInRom = 0;
;;;536    #endif
;;;537    
;;;538        /*config watch dog mode in rom, defualt reset all*/
;;;539        OTP->wdgMode = ROM_WATCH_DOG_MODE;
;;;540    
;;;541        /*use os tick as log timestamp instead of TIM7*/
;;;542        OTP->log_timestamp_src = LOG_TIMESTAMP_OS;
;;;543    
;;;544    
;;;545        //app config
;;;546        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
;;;547        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
;;;548        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
;;;549        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
;;;550    
;;;551    #if ROM_OTA_LINKLOSS_RST
;;;552        OTP->ota_link_loss_reset = 1;
;;;553    #endif
;;;554        /*config bt stack parameters in rom*/
;;;555    #ifdef BT_STACK_CONFIG_ENABLE
;;;556        bt_stack_config_init();
;;;557    #endif
;;;558    
;;;559    //add more otp config here
;;;560    }
;;;561    
;;;562    //Note: call print_reset_reason() before ram_init();
;;;563    APP_FLASH_TEXT_SECTION
;;;564    void print_reset_reason(void)
;;;565    {
        0x0080e4aa:    b570        p.      PUSH     {r4-r6,lr}
;;;566        if (check_reset_ram.check_reset_ram_pattern != RESET_RAM_PATTERN)
        0x0080e4ac:    4d67        gM      LDR      r5,[pc,#412] ; [0x80e64c] = 0x20cf24
        0x0080e4ae:    4968        hI      LDR      r1,[pc,#416] ; [0x80e650] = 0x72657400
        0x0080e4b0:    4c68        hL      LDR      r4,[pc,#416] ; [0x80e654] = 0x21100302
        0x0080e4b2:    6828        (h      LDR      r0,[r5,#0]
;;; ..\..\..\inc\peripheral\rtl876x_wdg.h
;;;135        return (T_SW_RESET_REASON)flash_ioctl(flash_ioctl_get_aon_record_reset_reason, 0, 0);
        0x0080e4b4:    f04f0200    O...    MOV      r2,#0
        0x0080e4b8:    ebb12f00    .../    CMP      r1,r0,LSL #8
        0x0080e4bc:    d005        ..      BEQ      0x80e4ca ; print_reset_reason + 32
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c
;;;568            BOOT_PRINT_INFO0("RESET Reason: HW or OTA");
        0x0080e4be:    4620         F      MOV      r0,r4
        0x0080e4c0:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0080e4c4:    4964        dI      LDR      r1,[pc,#400] ; [0x80e658] = 0x8800000
        0x0080e4c6:    f7f99aca    ....    B        log_buffer ; 0x7a5e
;;; ..\..\..\inc\peripheral\rtl876x_wdg.h
;;;135        return (T_SW_RESET_REASON)flash_ioctl(flash_ioctl_get_aon_record_reset_reason, 0, 0);
        0x0080e4ca:    2100        .!      MOVS     r1,#0
        0x0080e4cc:    f2450006    E...    MOV      r0,#0x5006
        0x0080e4d0:    f7fdddcf    ....    BL       flash_ioctl ; 0xc072
        0x0080e4d4:    f01003ff    ....    ANDS     r3,r0,#0xff
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c
;;;574            if (sw_reset_type != (T_SW_RESET_REASON)0)
        0x0080e4d8:    d003        ..      BEQ      0x80e4e2 ; print_reset_reason + 56
;;;575            {
;;;576                BOOT_PRINT_INFO1("RESET Reason: SW(reset except aon), TYPE 0x%x", sw_reset_type);
        0x0080e4da:    495f        _I      LDR      r1,[pc,#380] ; [0x80e658] = 0x8800000
        0x0080e4dc:    2201        ."      MOVS     r2,#1
        0x0080e4de:    311c        .1      ADDS     r1,r1,#0x1c
        0x0080e4e0:    e004        ..      B        0x80e4ec ; print_reset_reason + 66
;;;577            }
;;;578            else //reset all will clear aon register
;;;579            {
;;;580                BOOT_PRINT_INFO1("RESET Reason: SW(reset all), TYPE 0x%x", check_reset_ram.check_reset_ram_type);
        0x0080e4e2:    6828        (h      LDR      r0,[r5,#0]
        0x0080e4e4:    495c        \I      LDR      r1,[pc,#368] ; [0x80e658] = 0x8800000
        0x0080e4e6:    0e03        ..      LSRS     r3,r0,#24
        0x0080e4e8:    2201        ."      MOVS     r2,#1
        0x0080e4ea:    3150        P1      ADDS     r1,r1,#0x50
        0x0080e4ec:    4620         F      MOV      r0,r4
        0x0080e4ee:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0080e4f2:    f7f99ab4    ....    B        log_buffer ; 0x7a5e
    pre_main
;;;581            }
;;;582        }
;;;583    }
;;;584    
;;;585    APP_FLASH_TEXT_SECTION
;;;586    void pre_main(void)
;;;587    {
        0x0080e4f6:    b538        8.      PUSH     {r3-r5,lr}
;;;588        __disable_irq();
        0x0080e4f8:    b672        r.      CPSID    i
;;;589    
;;;590        print_reset_reason();  //Note: call this function before ram_init();
        0x0080e4fa:    f7ffffd6    ....    BL       print_reset_reason ; 0x80e4aa
;;;591    
;;;592        ram_init();
        0x0080e4fe:    f7ffff87    ....    BL       ram_init ; 0x80e410
;;;593    
;;;594        random_seed_init();
        0x0080e502:    f7ffffa4    ....    BL       random_seed_init ; 0x80e44e
;;;595    
;;;596        load_overlay(OVERLAY_SCENARIO_BOOT_ONCE);
        0x0080e506:    2000        .       MOVS     r0,#0
        0x0080e508:    f60df766    ..f.    BL       load_overlay ; 0x21c3d8
;;;597    
;;;598        //reset NVIC of DMA channel used in image decryption
;;;599        NVIC_DisableIRQ(GDMA0_Channel2_IRQn);
        0x0080e50c:    2016        .       MOVS     r0,#0x16
        0x0080e50e:    f60df60f    ....    BL       NVIC_DisableIRQ ; 0x21c130
;;;600        NVIC_DisableIRQ(GDMA0_Channel3_IRQn);
        0x0080e512:    2017        .       MOVS     r0,#0x17
        0x0080e514:    f60df60c    ....    BL       NVIC_DisableIRQ ; 0x21c130
;;;601    
;;;602        setlocale(LC_ALL, "C");
        0x0080e518:    a150        P.      ADR      r1,{pc}+0x144 ; 0x80e65c
        0x0080e51a:    201f        .       MOVS     r0,#0x1f
        0x0080e51c:    f44bf46a    K.j.    BL       setlocale ; 0x59df4
;;;603    
;;;604        BOOT_PRINT_ERROR2("SDK Ver: %s, Build Time: %s",
        0x0080e520:    f04f5505    O..U    MOV      r5,#0x21400000
        0x0080e524:    a14e        N.      ADR      r1,{pc}+0x13c ; 0x80e660
        0x0080e526:    4628        (F      MOV      r0,r5
        0x0080e528:    f7f9dc9f    ....    BL       trace_string ; 0x7e6a
        0x0080e52c:    4604        .F      MOV      r4,r0
        0x0080e52e:    a153        S.      ADR      r1,{pc}+0x14e ; 0x80e67c
        0x0080e530:    4628        (F      MOV      r0,r5
        0x0080e532:    f7f9dc9a    ....    BL       trace_string ; 0x7e6a
        0x0080e536:    4603        .F      MOV      r3,r0
        0x0080e538:    4947        GI      LDR      r1,[pc,#284] ; [0x80e658] = 0x8800000
        0x0080e53a:    4846        FH      LDR      r0,[pc,#280] ; [0x80e654] = 0x21100302
        0x0080e53c:    2202        ."      MOVS     r2,#2
        0x0080e53e:    317c        |1      ADDS     r1,r1,#0x7c
        0x0080e540:    1e80        ..      SUBS     r0,r0,#2
        0x0080e542:    9400        ..      STR      r4,[sp,#0]
        0x0080e544:    f7f9da8b    ....    BL       log_buffer ; 0x7a5e
;;;605                          TRACE_STRING(VERSION_BUILD_STR),
;;;606                          TRACE_STRING(BUILDING_TIME));
;;;607    
;;;608        AppUpdateVectorTable();
        0x0080e548:    f5fef7c2    ....    BL       AppUpdateVectorTable ; 0x20d4d0
;;;609    
;;;610    #if (DEBUG_WATCHPOINT_ENABLE == 1)
;;;611        debug_monitor_enable();
;;;612    #endif
;;;613    
;;;614        if (app_pre_main_cb)
        0x0080e54c:    484d        MH      LDR      r0,[pc,#308] ; [0x80e684] = 0x20cfa0
        0x0080e54e:    6800        .h      LDR      r0,[r0,#0]
        0x0080e550:    2800        .(      CMP      r0,#0
        0x0080e552:    d003        ..      BEQ      0x80e55c ; pre_main + 102
;;;615        {
;;;616            app_pre_main_cb();
        0x0080e554:    b001        ..      ADD      sp,sp,#4
        0x0080e556:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x0080e55a:    4700        .G      BX       r0
;;;617        }
;;;618    
;;;619        return;
;;;620    }
        0x0080e55c:    bd38        8.      POP      {r3-r5,pc}
    SystemInit
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (451)
        0x0080e55e:    b510        ..      PUSH     {r4,lr}
;;;452        //hci mode check and bypass app
;;;453        if (check_hci_mode_flag())
        0x0080e560:    f7fed8fe    ....    BL       check_hci_mode_flag ; 0xc760
        0x0080e564:    2800        .(      CMP      r0,#0
        0x0080e566:    d14c        L.      BNE      0x80e602 ; SystemInit + 164
;;;454        {
;;;455            return;
;;;456        }
;;;457    
;;;458        //init pre_main and main functions
;;;459        extern void pre_main(void);
;;;460        app_pre_main = (APP_MAIN_FUNC)pre_main;
        0x0080e568:    f2af0075    ..u.    ADR      r0,{pc}-0x71 ; 0x80e4f7
        0x0080e56c:    4946        FI      LDR      r1,[pc,#280] ; [0x80e688] = 0x200c38
;;;461        app_main = (APP_MAIN_FUNC)common_main;
        0x0080e56e:    6008        .`      STR      r0,[r1,#0]
        0x0080e570:    4947        GI      LDR      r1,[pc,#284] ; [0x80e690] = 0x200c3c
        0x0080e572:    4846        FH      LDR      r0,[pc,#280] ; [0x80e68c] = 0x21c051
;;;462    
;;;463        /******** update otp here**********/
;;;464        //ram config
;;;465        OTP->appDataSize = APP_GLOBAL_SIZE;
        0x0080e574:    6008        .`      STR      r0,[r1,#0]
        0x0080e576:    f44f1000    O...    MOV      r0,#0x200000
        0x0080e57a:    f44f410c    O..A    MOV      r1,#0x8c00
;;;466        OTP->heapDataONSize = HEAP_DATA_ON_SIZE - DATA_SIZE_FOR_RANDOM_SEED;
        0x0080e57e:    f8c01384    ....    STR      r1,[r0,#0x384]
        0x0080e582:    f24771f0    G..q    MOV      r1,#0x77f0
;;;467    
;;;468        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;469    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;470        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
        0x0080e586:    f8c01388    ....    STR      r1,[r0,#0x388]
        0x0080e58a:    4942        BI      LDR      r1,[pc,#264] ; [0x80e694] = 0xa2aa0003
;;;471    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;472        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;473    #else
;;;474        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;475    #endif
;;;476    
;;;477        //sw timer config
;;;478    #ifdef TIMER_MAX_NUMBER
;;;479        //define TIMER_MAX_NUMBER in otp_config.h
;;;480        OTP->timerMaxNumber = TIMER_MAX_NUMBER;
;;;481    #endif
;;;482    
;;;483        //flash config
;;;484        /*config enable flash block proect depending on flash layout and flash id*/
;;;485    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;486        OTP->bp_enable = 1;
        0x0080e58c:    f8c013cc    ....    STR      r1,[r0,#0x3cc]
        0x0080e590:    f890134d    ..M.    LDRB     r1,[r0,#0x34d]
        0x0080e594:    f0410108    A...    ORR      r1,r1,#8
        0x0080e598:    f880134d    ..M.    STRB     r1,[r0,#0x34d]
;;;487    #else
;;;488        OTP->bp_enable = 0;
;;;489    #endif
;;;490        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
        0x0080e59c:    2106        .!      MOVS     r1,#6
        0x0080e59e:    f880134f    ..O.    STRB     r1,[r0,#0x34f]
;;;491    
;;;492    
;;;493        //os config
;;;494        /*config enable check task stack overflow*/
;;;495    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;496        OTP->checkForStackOverflow = 1;
        0x0080e5a2:    f8901378    ..x.    LDRB     r1,[r0,#0x378]
;;;497    #else
;;;498        OTP->checkForStackOverflow = 0;
;;;499    #endif
;;;500    
;;;501    
;;;502        //platform config
;;;503        /*config enable platform assert*/
;;;504    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;505        OTP->enableASSERT = 1;
;;;506    #else
;;;507        OTP->enableASSERT = 0;
;;;508    #endif
;;;509    
;;;510        /*Print all log in log buffer before entering DLPS */
;;;511    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;512        OTP->printAllLogBeforeEnterDLPS = 1;
        0x0080e5a6:    f0410126    A.&.    ORR      r1,r1,#0x26
        0x0080e5aa:    f8801378    ..x.    STRB     r1,[r0,#0x378]
;;;513    #else
;;;514        OTP->printAllLogBeforeEnterDLPS = 0;
;;;515    #endif
;;;516    
;;;517        /*config enable log or not*/
;;;518    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;519        OTP->logDisable = 0;
        0x0080e5ae:    f890139a    ....    LDRB     r1,[r0,#0x39a]
        0x0080e5b2:    f0210101    !...    BIC      r1,r1,#1
        0x0080e5b6:    f880139a    ....    STRB     r1,[r0,#0x39a]
;;;520    #else
;;;521        OTP->logDisable = 1;
;;;522    #endif
;;;523    
;;;524        /*config enable swd pinmux*/
;;;525    #if (SWD_PINMUX_ENABLE == 1)
;;;526        OTP->SWD_ENABLE = 1;
        0x0080e5ba:    f8901334    ..4.    LDRB     r1,[r0,#0x334]
        0x0080e5be:    f0410101    A...    ORR      r1,r1,#1
        0x0080e5c2:    f8801334    ..4.    STRB     r1,[r0,#0x334]
;;;527    #else
;;;528        OTP->SWD_ENABLE = 0;
;;;529    #endif
;;;530    
;;;531        /*config enable watch dog in rom*/
;;;532    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;533        OTP->wdgEnableInRom = 1;
;;;534    #else
;;;535        OTP->wdgEnableInRom = 0;
        0x0080e5c6:    f890137a    ..z.    LDRB     r1,[r0,#0x37a]
        0x0080e5ca:    f0210110    !...    BIC      r1,r1,#0x10
;;;536    #endif
;;;537    
;;;538        /*config watch dog mode in rom, defualt reset all*/
;;;539        OTP->wdgMode = ROM_WATCH_DOG_MODE;
        0x0080e5ce:    f04101c0    A...    ORR      r1,r1,#0xc0
        0x0080e5d2:    f880137a    ..z.    STRB     r1,[r0,#0x37a]
;;;540    
;;;541        /*use os tick as log timestamp instead of TIM7*/
;;;542        OTP->log_timestamp_src = LOG_TIMESTAMP_OS;
        0x0080e5d6:    f89013c3    ....    LDRB     r1,[r0,#0x3c3]
        0x0080e5da:    f02101c0    !...    BIC      r1,r1,#0xc0
        0x0080e5de:    f88013c3    ....    STRB     r1,[r0,#0x3c3]
;;;543    
;;;544    
;;;545        //app config
;;;546        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
        0x0080e5e2:    21f0        .!      MOVS     r1,#0xf0
        0x0080e5e4:    f8801320    .. .    STRB     r1,[r0,#0x320]
;;;547        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
        0x0080e5e8:    213c        <!      MOVS     r1,#0x3c
        0x0080e5ea:    f8801321    ..!.    STRB     r1,[r0,#0x321]
;;;548        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
        0x0080e5ee:    21c8        .!      MOVS     r1,#0xc8
        0x0080e5f0:    f8801322    ..".    STRB     r1,[r0,#0x322]
;;;549        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
        0x0080e5f4:    21ff        .!      MOVS     r1,#0xff
        0x0080e5f6:    f8801323    ..#.    STRB     r1,[r0,#0x323]
;;;550    
;;;551    #if ROM_OTA_LINKLOSS_RST
;;;552        OTP->ota_link_loss_reset = 1;
;;;553    #endif
;;;554        /*config bt stack parameters in rom*/
;;;555    #ifdef BT_STACK_CONFIG_ENABLE
;;;556        bt_stack_config_init();
        0x0080e5fa:    e8bd4010    ...@    POP      {r4,lr}
        0x0080e5fe:    f000b84b    ..K.    B.W      bt_stack_config_init ; 0x80e698
;;;557    #endif
;;;558    
;;;559    //add more otp config here
;;;560    }
        0x0080e602:    bd10        ..      POP      {r4,pc}
    $d
        0x0080e604:    00005324    $S..    DCD    21284
        0x0080e608:    0080e870    p...    DCD    8448112
        0x0080e60c:    00207c00    .| .    DCD    2128896
        0x0080e610:    00000074    t...    DCD    116
        0x0080e614:    00813b94    .;..    DCD    8469396
        0x0080e618:    0020cf24    $. .    DCD    2150180
        0x0080e61c:    00000538    8...    DCD    1336
        0x0080e620:    0020cf98    .. .    DCD    2150296
        0x0080e624:    00000cdc    ....    DCD    3292
        0x0080e628:    00813cc8    .<..    DCD    8469704
        0x0080e62c:    0021c000    ..!.    DCD    2211840
        0x0080e630:    00000000    ....    DCD    0
        0x0080e634:    008149a4    .I..    DCD    8472996
        0x0080e638:    0021ccdc    ..!.    DCD    2215132
        0x0080e63c:    00000000    ....    DCD    0
        0x0080e640:    0021ccdc    ..!.    DCD    2215132
        0x0080e644:    40058000    ...@    DCD    1074102272
        0x0080e648:    0020cf98    .. .    DCD    2150296
        0x0080e64c:    0020cf24    $. .    DCD    2150180
        0x0080e650:    72657400    .ter    DCD    1919251456
        0x0080e654:    21100302    ...!    DCD    554697474
        0x0080e658:    08800000    ....    DCD    142606336
        0x0080e65c:    00000043    C...    DCD    67
        0x0080e660:    20697246    Fri     DCD    543781446
        0x0080e664:    20706553    Sep     DCD    544236883
        0x0080e668:    31203132    21 1    DCD    824193330
        0x0080e66c:    31303a33    3:01    DCD    825244211
        0x0080e670:    2037313a    :17     DCD    540487994
        0x0080e674:    38313032    2018    DCD    942747698
        0x0080e678:    00000000    ....    DCD    0
        0x0080e67c:    2e302e31    1.0.    DCD    774909489
        0x0080e680:    00302e32    2.0.    DCD    3157554
        0x0080e684:    0020cfa0    .. .    DCD    2150304
        0x0080e688:    00200c38    8. .    DCD    2100280
        0x0080e68c:    0021c051    Q.!.    DCD    2211921
        0x0080e690:    00200c3c    <. .    DCD    2100284
        0x0080e694:    a2aa0003    ....    DCD    2729050115
    $t
    .app.flash.text
    bt_stack_config_init
;;; ..\..\..\src\sample\ble_central\main.c
;;;64         gap_config_max_le_paired_device(APP_MAX_LINKS);
        0x0080e698:    2004        .       MOVS     r0,#4
        0x0080e69a:    f000b854    ..T.    B.W      gap_config_max_le_paired_device ; 0x80e746
        0x0080e69e:    0000        ..      MOVS     r0,r0
    .app.flash.text
    gap_config_bt_bd_addr
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (32)
        0x0080e6a0:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e6a4:    7802        .x      LDRB     r2,[r0,#0]
        0x0080e6a6:    f8812197    ...!    STRB     r2,[r1,#0x197]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (33)
        0x0080e6aa:    7842        Bx      LDRB     r2,[r0,#1]
        0x0080e6ac:    f8812198    ...!    STRB     r2,[r1,#0x198]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (34)
        0x0080e6b0:    7882        .x      LDRB     r2,[r0,#2]
        0x0080e6b2:    f8812199    ...!    STRB     r2,[r1,#0x199]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (35)
        0x0080e6b6:    78c2        .x      LDRB     r2,[r0,#3]
        0x0080e6b8:    f881219a    ...!    STRB     r2,[r1,#0x19a]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (36)
        0x0080e6bc:    7902        .y      LDRB     r2,[r0,#4]
        0x0080e6be:    f881219b    ...!    STRB     r2,[r1,#0x19b]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (37)
        0x0080e6c2:    7940        @y      LDRB     r0,[r0,#5]
        0x0080e6c4:    f881019c    ....    STRB     r0,[r1,#0x19c]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (38)
        0x0080e6c8:    4770        pG      BX       lr
    gap_config_ae_parameter
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (42)
        0x0080e6ca:    482a        *H      LDR      r0,[pc,#168] ; [0x80e774] = 0x200236
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (43)
        0x0080e6cc:    492a        *I      LDR      r1,[pc,#168] ; [0x80e778] = 0x10420c6
        0x0080e6ce:    6001        .`      STR      r1,[r0,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (44)
        0x0080e6d0:    4770        pG      BX       lr
    gap_config_cccd_not_check
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (49)
        0x0080e6d2:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e6d6:    f8d12314    ...#    LDR      r2,[r1,#0x314]
        0x0080e6da:    f3600241    `.A.    BFI      r2,r0,#1,#1
        0x0080e6de:    f8c12314    ...#    STR      r2,[r1,#0x314]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (61)
        0x0080e6e2:    4770        pG      BX       lr
    gap_config_le_min_rem_sca
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (67)
        0x0080e6e4:    f44f1300    O...    MOV      r3,#0x200000
        0x0080e6e8:    f8b322dc    ..."    LDRH     r2,[r3,#0x2dc]
        0x0080e6ec:    f3602208    `.."    BFI      r2,r0,#8,#1
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (68)
        0x0080e6f0:    f361224b    a.K"    BFI      r2,r1,#9,#3
        0x0080e6f4:    f8a322dc    ..."    STRH     r2,[r3,#0x2dc]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (69)
        0x0080e6f8:    4770        pG      BX       lr
    gap_config_bte_pool_size
        0x0080e6fa:    280a        .(      CMP      r0,#0xa
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (72)
        0x0080e6fc:    d902        ..      BLS      0x80e704 ; gap_config_bte_pool_size + 10
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (73)
        0x0080e6fe:    f44f5020    O. P    MOV      r0,#0x2800
        0x0080e702:    e000        ..      B        0x80e706 ; gap_config_bte_pool_size + 12
        0x0080e704:    0280        ..      LSLS     r0,r0,#10
        0x0080e706:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e70a:    f8c102e8    ....    STR      r0,[r1,#0x2e8]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (74)
        0x0080e70e:    4770        pG      BX       lr
    gap_config_bt_report_buf_num
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (78)
        0x0080e710:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e714:    f88102f1    ....    STRB     r0,[r1,#0x2f1]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (79)
        0x0080e718:    4770        pG      BX       lr
    gap_config_ccc_bits_count
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (84)
        0x0080e71a:    f44f1200    O...    MOV      r2,#0x200000
        0x0080e71e:    f8820310    ....    STRB     r0,[r2,#0x310]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (85)
        0x0080e722:    f8821325    ..%.    STRB     r1,[r2,#0x325]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (86)
        0x0080e726:    4770        pG      BX       lr
    gap_config_max_attribute_table_count
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (91)
        0x0080e728:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e72c:    f8810311    ....    STRB     r0,[r1,#0x311]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (92)
        0x0080e730:    4770        pG      BX       lr
    gap_config_max_mtu_size
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (96)
        0x0080e732:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e736:    f8a10312    ....    STRH     r0,[r1,#0x312]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (97)
        0x0080e73a:    4770        pG      BX       lr
    gap_config_le_key_storage_flag
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (101)
        0x0080e73c:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e740:    f8a10326    ..&.    STRH     r0,[r1,#0x326]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (102)
        0x0080e744:    4770        pG      BX       lr
    gap_config_max_le_paired_device
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (106)
        0x0080e746:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e74a:    f881032f    ../.    STRB     r0,[r1,#0x32f]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (107)
        0x0080e74e:    4770        pG      BX       lr
    gap_config_bqb_en
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (132)
        0x0080e750:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e754:    f8b122dc    ..."    LDRH     r2,[r1,#0x2dc]
        0x0080e758:    f3600241    `.A.    BFI      r2,r0,#1,#1
        0x0080e75c:    f8a122dc    ..."    STRH     r2,[r1,#0x2dc]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (133)
        0x0080e760:    4770        pG      BX       lr
    gap_config_l2c_param
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (138)
        0x0080e762:    f44f1300    O...    MOV      r3,#0x200000
        0x0080e766:    f88302fd    ....    STRB     r0,[r3,#0x2fd]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (139)
        0x0080e76a:    f883130e    ....    STRB     r1,[r3,#0x30e]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (140)
        0x0080e76e:    f883232e    ...#    STRB     r2,[r3,#0x32e]
;;; ..\..\..\src\app\gap_lib\extension\gap_config.c (141)
        0x0080e772:    4770        pG      BX       lr
    $d
        0x0080e774:    00200236    6. .    DCD    2097718
        0x0080e778:    010420c6    . ..    DCD    17047750

** Section #4 'RAM_VECTOR_TABLE' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 244 bytes (alignment 4)
    Address: 0x00200000

    0x200000:   00 38 20 00 01 e4 80 00 39 7d 20 00 39 7d 20 00    .8 .....9} .9} .
    0x200010:   39 7d 20 00 39 7d 20 00 39 7d 20 00 00 00 00 00    9} .9} .9} .....
    0x200020:   00 00 00 00 00 00 00 00 00 00 00 00 39 7d 20 00    ............9} .
    0x200030:   39 7d 20 00 00 00 00 00 39 7d 20 00 39 7d 20 00    9} .....9} .9} .
    0x200040:   39 7d 20 00 39 7d 20 00 39 7d 20 00 39 7d 20 00    9} .9} .9} .9} .
    0x200050:   39 7d 20 00 39 7d 20 00 39 7d 20 00 39 7d 20 00    9} .9} .9} .9} .
    0x200060:   39 7d 20 00 39 7d 20 00 39 7d 20 00 39 7d 20 00    9} .9} .9} .9} .
    0x200070:   cf ac 20 00 39 7d 20 00 39 7d 20 00 39 7d 20 00    .. .9} .9} .9} .
    0x200080:   39 7d 20 00 39 7d 20 00 39 7d 20 00 39 7d 20 00    9} .9} .9} .9} .
    0x200090:   39 7d 20 00 39 7d 20 00 39 7d 20 00 39 7d 20 00    9} .9} .9} .9} .
    0x2000a0:   39 7d 20 00 39 7d 20 00 15 7c 20 00 61 7c 20 00    9} .9} ..| .a| .
    0x2000b0:   39 7d 20 00 ad 7c 20 00 f1 7c 20 00 39 7d 20 00    9} ..| ..| .9} .
    0x2000c0:   39 7d 20 00 39 7d 20 00 39 7d 20 00 39 7d 20 00    9} .9} .9} .9} .
    0x2000d0:   39 7d 20 00 39 7d 20 00 39 7d 20 00 39 7d 20 00    9} .9} .9} .9} .
    0x2000e0:   39 7d 20 00 39 7d 20 00 39 7d 20 00 39 7d 20 00    9} .9} .9} .9} .
    0x2000f0:   39 7d 20 00                                        9} .

    __Vectors_End

** Section #5 'RAM_DATA_ON' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 21284 bytes (alignment 4)
    Address: 0x00207c00

    $t
    .ARM.Collect$$rtentry$$00000000
    .ARM.Collect$$rtentry$$00000002
    .ARM.Collect$$rtentry$$00000004
    __rt_entry
    __rt_entry_presh_1
    __rt_entry_sh
        0x00207c00:    f000f8a2    ....    BL       __user_setup_stackheap ; 0x207d48
        0x00207c04:    4611        .F      MOV      r1,r2
    .ARM.Collect$$rtentry$$00000009
    .ARM.Collect$$rtentry$$0000000A
    __rt_entry_li
    __rt_entry_postsh_1
        0x00207c06:    f014fa03    ....    BL       __rt_lib_init ; 0x21c010
    .ARM.Collect$$rtentry$$0000000C
    .ARM.Collect$$rtentry$$0000000D
    __rt_entry_main
    __rt_entry_postli_1
        0x00207c0a:    f002ff2e    ....    BL       main ; 0x20aa6a
        0x00207c0e:    f653f909    S...    BL       exit ; 0x5ae24
        0x00207c12:    0000        ..      MOVS     r0,r0
    .ram.dataon.data
    GPIO_Group3_Handler
;;;691        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207c14:    4847        GH      LDR      r0,[pc,#284] ; [0x207d34] = 0x40001000
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (690)
        0x00207c16:    b510        ..      PUSH     {r4,lr}
        0x00207c18:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207c1a:    0720         .      LSLS     r0,r4,#28
        0x00207c1c:    d501        ..      BPL      0x207c22 ; GPIO_Group3_Handler + 14
;;;691        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;692    
;;;693        //Check exact IRQ function
;;;694        if (GPIOIrqStatus & BIT3)
;;;695        {
;;;696            GPIO3_Handler();
        0x00207c1e:    f000f88b    ....    BL       ADC_Handler ; 0x207d38
;;;697        }
;;;698        if (GPIOIrqStatus & BIT7)
        0x00207c22:    0620         .      LSLS     r0,r4,#24
        0x00207c24:    d501        ..      BPL      0x207c2a ; GPIO_Group3_Handler + 22
;;;699        {
;;;700            GPIO7_Handler();
        0x00207c26:    f000f887    ....    BL       ADC_Handler ; 0x207d38
;;;701        }
;;;702        if (GPIOIrqStatus & BIT11)
        0x00207c2a:    0520         .      LSLS     r0,r4,#20
        0x00207c2c:    d501        ..      BPL      0x207c32 ; GPIO_Group3_Handler + 30
;;;703        {
;;;704            GPIO11_Handler();
        0x00207c2e:    f000f883    ....    BL       ADC_Handler ; 0x207d38
;;;705        }
;;;706        if (GPIOIrqStatus & BIT15)
        0x00207c32:    0420         .      LSLS     r0,r4,#16
        0x00207c34:    d501        ..      BPL      0x207c3a ; GPIO_Group3_Handler + 38
;;;707        {
;;;708            GPIO15_Handler();
        0x00207c36:    f000f87f    ....    BL       ADC_Handler ; 0x207d38
;;;709        }
;;;710        if (GPIOIrqStatus & BIT19)
        0x00207c3a:    0320         .      LSLS     r0,r4,#12
        0x00207c3c:    d501        ..      BPL      0x207c42 ; GPIO_Group3_Handler + 46
;;;711        {
;;;712            GPIO19_Handler();
        0x00207c3e:    f000f87b    ..{.    BL       ADC_Handler ; 0x207d38
;;;713        }
;;;714        if (GPIOIrqStatus & BIT23)
        0x00207c42:    0220         .      LSLS     r0,r4,#8
        0x00207c44:    d501        ..      BPL      0x207c4a ; GPIO_Group3_Handler + 54
;;;715        {
;;;716            GPIO23_Handler();
        0x00207c46:    f000f877    ..w.    BL       ADC_Handler ; 0x207d38
;;;717        }
;;;718        if (GPIOIrqStatus & BIT27)
        0x00207c4a:    0120         .      LSLS     r0,r4,#4
        0x00207c4c:    d501        ..      BPL      0x207c52 ; GPIO_Group3_Handler + 62
;;;719        {
;;;720            GPIO27_Handler();
        0x00207c4e:    f000f873    ..s.    BL       ADC_Handler ; 0x207d38
;;;721        }
;;;722        if (GPIOIrqStatus & BIT31)
        0x00207c52:    2c00        .,      CMP      r4,#0
        0x00207c54:    da03        ..      BGE      0x207c5e ; GPIO_Group3_Handler + 74
;;;723        {
;;;724            GPIO31_Handler();
        0x00207c56:    e8bd4010    ...@    POP      {r4,lr}
        0x00207c5a:    f000b86d    ..m.    B.W      ADC_Handler ; 0x207d38
;;;725        }
;;;726    }
        0x00207c5e:    bd10        ..      POP      {r4,pc}
    GPIO_Group2_Handler
;;;727    /**
;;;728     * @brief  GPIO Group2 Handler
;;;729     * @param  none
;;;730     * @return none
;;;731      */
;;;732    DATA_RAM_FUNCTION void GPIO_Group2_Handler(void)
;;;733    {
;;;734        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207c60:    4834        4H      LDR      r0,[pc,#208] ; [0x207d34] = 0x40001000
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (733)
        0x00207c62:    b510        ..      PUSH     {r4,lr}
        0x00207c64:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207c66:    0760        `.      LSLS     r0,r4,#29
        0x00207c68:    d501        ..      BPL      0x207c6e ; GPIO_Group2_Handler + 14
;;;734        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;735    
;;;736        //Check exact IRQ function
;;;737        if (GPIOIrqStatus & BIT2)
;;;738        {
;;;739            GPIO2_Handler();
        0x00207c6a:    f000f865    ..e.    BL       ADC_Handler ; 0x207d38
;;;740        }
;;;741        if (GPIOIrqStatus & BIT6)
        0x00207c6e:    0660        `.      LSLS     r0,r4,#25
        0x00207c70:    d501        ..      BPL      0x207c76 ; GPIO_Group2_Handler + 22
;;;742        {
;;;743            GPIO6_Handler();
        0x00207c72:    f000f861    ..a.    BL       ADC_Handler ; 0x207d38
;;;744        }
;;;745        if (GPIOIrqStatus & BIT10)
        0x00207c76:    0560        `.      LSLS     r0,r4,#21
        0x00207c78:    d501        ..      BPL      0x207c7e ; GPIO_Group2_Handler + 30
;;;746        {
;;;747            GPIO10_Handler();
        0x00207c7a:    f000f85d    ..].    BL       ADC_Handler ; 0x207d38
;;;748        }
;;;749        if (GPIOIrqStatus & BIT14)
        0x00207c7e:    0460        `.      LSLS     r0,r4,#17
        0x00207c80:    d501        ..      BPL      0x207c86 ; GPIO_Group2_Handler + 38
;;;750        {
;;;751            GPIO14_Handler();
        0x00207c82:    f000f859    ..Y.    BL       ADC_Handler ; 0x207d38
;;;752        }
;;;753        if (GPIOIrqStatus & BIT18)
        0x00207c86:    0360        `.      LSLS     r0,r4,#13
        0x00207c88:    d501        ..      BPL      0x207c8e ; GPIO_Group2_Handler + 46
;;;754        {
;;;755            GPIO18_Handler();
        0x00207c8a:    f000f855    ..U.    BL       ADC_Handler ; 0x207d38
;;;756        }
;;;757        if (GPIOIrqStatus & BIT22)
        0x00207c8e:    0260        `.      LSLS     r0,r4,#9
        0x00207c90:    d501        ..      BPL      0x207c96 ; GPIO_Group2_Handler + 54
;;;758        {
;;;759            GPIO22_Handler();
        0x00207c92:    f000f851    ..Q.    BL       ADC_Handler ; 0x207d38
;;;760        }
;;;761        if (GPIOIrqStatus & BIT26)
        0x00207c96:    0160        `.      LSLS     r0,r4,#5
        0x00207c98:    d501        ..      BPL      0x207c9e ; GPIO_Group2_Handler + 62
;;;762        {
;;;763            GPIO26_Handler();
        0x00207c9a:    f000f84d    ..M.    BL       ADC_Handler ; 0x207d38
;;;764        }
;;;765        if (GPIOIrqStatus & BIT30)
        0x00207c9e:    0060        `.      LSLS     r0,r4,#1
        0x00207ca0:    d503        ..      BPL      0x207caa ; GPIO_Group2_Handler + 74
;;;766        {
;;;767            GPIO30_Handler();
        0x00207ca2:    e8bd4010    ...@    POP      {r4,lr}
        0x00207ca6:    f000b847    ..G.    B.W      ADC_Handler ; 0x207d38
;;;768        }
;;;769    }
        0x00207caa:    bd10        ..      POP      {r4,pc}
    GPIO_Group1_Handler
;;;770    /**
;;;771     * @brief  GPIO Group1 Handler
;;;772     * @param  none
;;;773     * @return none
;;;774      */
;;;775    DATA_RAM_FUNCTION void GPIO_Group1_Handler(void)
;;;776    {
;;;777        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207cac:    4821        !H      LDR      r0,[pc,#132] ; [0x207d34] = 0x40001000
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (776)
        0x00207cae:    b510        ..      PUSH     {r4,lr}
        0x00207cb0:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207cb2:    07a0        ..      LSLS     r0,r4,#30
        0x00207cb4:    d501        ..      BPL      0x207cba ; GPIO_Group1_Handler + 14
;;;777        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;778    
;;;779        //Check exact IRQ function
;;;780        if (GPIOIrqStatus & BIT1)
;;;781        {
;;;782            GPIO1_Handler();
        0x00207cb6:    f000f83f    ..?.    BL       ADC_Handler ; 0x207d38
;;;783        }
;;;784        if (GPIOIrqStatus & BIT9)
        0x00207cba:    05a0        ..      LSLS     r0,r4,#22
        0x00207cbc:    d501        ..      BPL      0x207cc2 ; GPIO_Group1_Handler + 22
;;;785        {
;;;786            GPIO9_Handler();
        0x00207cbe:    f000f83b    ..;.    BL       ADC_Handler ; 0x207d38
;;;787        }
;;;788        if (GPIOIrqStatus & BIT13)
        0x00207cc2:    04a0        ..      LSLS     r0,r4,#18
        0x00207cc4:    d501        ..      BPL      0x207cca ; GPIO_Group1_Handler + 30
;;;789        {
;;;790            GPIO13_Handler();
        0x00207cc6:    f000f837    ..7.    BL       ADC_Handler ; 0x207d38
;;;791        }
;;;792        if (GPIOIrqStatus & BIT17)
        0x00207cca:    03a0        ..      LSLS     r0,r4,#14
        0x00207ccc:    d501        ..      BPL      0x207cd2 ; GPIO_Group1_Handler + 38
;;;793        {
;;;794            GPIO17_Handler();
        0x00207cce:    f000f833    ..3.    BL       ADC_Handler ; 0x207d38
;;;795        }
;;;796        if (GPIOIrqStatus & BIT21)
        0x00207cd2:    02a0        ..      LSLS     r0,r4,#10
        0x00207cd4:    d501        ..      BPL      0x207cda ; GPIO_Group1_Handler + 46
;;;797        {
;;;798            GPIO21_Handler();
        0x00207cd6:    f000f82f    ../.    BL       ADC_Handler ; 0x207d38
;;;799        }
;;;800        if (GPIOIrqStatus & BIT25)
        0x00207cda:    01a0        ..      LSLS     r0,r4,#6
        0x00207cdc:    d501        ..      BPL      0x207ce2 ; GPIO_Group1_Handler + 54
;;;801        {
;;;802            GPIO25_Handler();
        0x00207cde:    f000f82b    ..+.    BL       ADC_Handler ; 0x207d38
;;;803        }
;;;804        if (GPIOIrqStatus & BIT29)
        0x00207ce2:    00a0        ..      LSLS     r0,r4,#2
        0x00207ce4:    d503        ..      BPL      0x207cee ; GPIO_Group1_Handler + 66
;;;805        {
;;;806            GPIO29_Handler();
        0x00207ce6:    e8bd4010    ...@    POP      {r4,lr}
        0x00207cea:    f000b825    ..%.    B.W      ADC_Handler ; 0x207d38
;;;807        }
;;;808    }
        0x00207cee:    bd10        ..      POP      {r4,pc}
    GPIO_Group0_Handler
;;;809    /**
;;;810     * @brief  GPIO Group0 Handler
;;;811     * @param  none
;;;812     * @return none
;;;813      */
;;;814    DATA_RAM_FUNCTION void GPIO_Group0_Handler(void)
;;;815    {
;;;816        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207cf0:    4810        .H      LDR      r0,[pc,#64] ; [0x207d34] = 0x40001000
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (815)
        0x00207cf2:    b510        ..      PUSH     {r4,lr}
        0x00207cf4:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207cf6:    07e0        ..      LSLS     r0,r4,#31
        0x00207cf8:    d001        ..      BEQ      0x207cfe ; GPIO_Group0_Handler + 14
;;;816        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;817    
;;;818        //Check exact IRQ function
;;;819        if (GPIOIrqStatus & BIT0)
;;;820        {
;;;821            GPIO0_Handler();
        0x00207cfa:    f000f81d    ....    BL       ADC_Handler ; 0x207d38
;;;822        }
;;;823        if (GPIOIrqStatus & BIT8)
        0x00207cfe:    05e0        ..      LSLS     r0,r4,#23
        0x00207d00:    d501        ..      BPL      0x207d06 ; GPIO_Group0_Handler + 22
;;;824        {
;;;825            GPIO8_Handler();
        0x00207d02:    f000f819    ....    BL       ADC_Handler ; 0x207d38
;;;826        }
;;;827        if (GPIOIrqStatus & BIT12)
        0x00207d06:    04e0        ..      LSLS     r0,r4,#19
        0x00207d08:    d501        ..      BPL      0x207d0e ; GPIO_Group0_Handler + 30
;;;828        {
;;;829            GPIO12_Handler();
        0x00207d0a:    f000f815    ....    BL       ADC_Handler ; 0x207d38
;;;830        }
;;;831        if (GPIOIrqStatus & BIT16)
        0x00207d0e:    03e0        ..      LSLS     r0,r4,#15
        0x00207d10:    d501        ..      BPL      0x207d16 ; GPIO_Group0_Handler + 38
;;;832        {
;;;833            GPIO16_Handler();
        0x00207d12:    f000f811    ....    BL       ADC_Handler ; 0x207d38
;;;834        }
;;;835        if (GPIOIrqStatus & BIT20)
        0x00207d16:    02e0        ..      LSLS     r0,r4,#11
        0x00207d18:    d501        ..      BPL      0x207d1e ; GPIO_Group0_Handler + 46
;;;836        {
;;;837            GPIO20_Handler();
        0x00207d1a:    f000f80d    ....    BL       ADC_Handler ; 0x207d38
;;;838        }
;;;839        if (GPIOIrqStatus & BIT24)
        0x00207d1e:    01e0        ..      LSLS     r0,r4,#7
        0x00207d20:    d501        ..      BPL      0x207d26 ; GPIO_Group0_Handler + 54
;;;840        {
;;;841            GPIO24_Handler();
        0x00207d22:    f000f809    ....    BL       ADC_Handler ; 0x207d38
;;;842        }
;;;843        if (GPIOIrqStatus & BIT28)
        0x00207d26:    00e0        ..      LSLS     r0,r4,#3
        0x00207d28:    d503        ..      BPL      0x207d32 ; GPIO_Group0_Handler + 66
;;;844        {
;;;845            GPIO28_Handler();
        0x00207d2a:    e8bd4010    ...@    POP      {r4,lr}
        0x00207d2e:    f000b803    ....    B.W      ADC_Handler ; 0x207d38
;;;846        }
;;;847    }
        0x00207d32:    bd10        ..      POP      {r4,pc}
    $d
        0x00207d34:    40001000    ...@    DCD    1073745920
    $t
    .text
    $v0
    ADC_Handler
    BTMAC_Handler
    BusFault_Handler
    DebugMon_Handler
    Default_Handler
    GDMA0_Channel0_Handler
    GDMA0_Channel1_Handler
    GDMA0_Channel2_Handler
    GDMA0_Channel3_Handler
    GDMA0_Channel4_Handler
    GDMA0_Channel5_Handler
    GPIO0_Handler
    GPIO10_Handler
    GPIO11_Handler
    GPIO12_Handler
    GPIO13_Handler
    GPIO14_Handler
    GPIO15_Handler
    GPIO16_Handler
    GPIO17_Handler
    GPIO18_Handler
    GPIO19_Handler
    GPIO1_Handler
    GPIO20_Handler
    GPIO21_Handler
    GPIO22_Handler
    GPIO23_Handler
    GPIO24_Handler
    GPIO25_Handler
    GPIO26_Handler
    GPIO27_Handler
    GPIO28_Handler
    GPIO29_Handler
    GPIO2_Handler
    GPIO30_Handler
    GPIO31_Handler
    GPIO3_Handler
    GPIO4_Handler
    GPIO5_Handler
    GPIO6_Handler
    GPIO7_Handler
    GPIO8_Handler
    GPIO9_Handler
    HardFault_Handler
    I2C0_Handler
    I2C1_Handler
    I2S0_RX_Handler
    I2S0_TX_Handler
    I2S1_RX_Handler
    I2S1_TX_Handler
    IR_Handler
    Keyscan_Handler
    LCD_Handler
    LPCOMP_Handler
    MemManage_Handler
    NMI_Handler
    PTA_Mailbox_Handler
    PendSV_Handler
    Peripheral_Handler
    Qdecode_Handler
    RTC_Handler
    SPI0_Handler
    SPI1_Handler
    SPI2W_Handler
    SPI_Flash_Handler
    SVC_Handler
    SysTick_Handler
    System_Handler
    Timer2_Handler
    Timer3_Handler
    Timer4_7_Handler
    Timer4_Handler
    Timer5_Handler
    Timer6_Handler
    Timer7_Handler
    UART1_Handler
    UART2_Handler
    UsageFault_Handler
    WDG_Handler
;;; ..\\..\\..\\src\\mcu\\rtl876x\\arm\\startup_rtl8762c.s
;;;276                    LDR    R0, =0x20000000
        0x00207d38:    f04f5000    O..P    MOV      r0,#0x20000000
;;;277                    LDR    R1, =DEFAULT_HANDLER_TXT
        0x00207d3c:    4910        .I      LDR      r1,[pc,#64] ; [0x207d80] = 0x207d4a
;;;278                    MRS    R2, IPSR
        0x00207d3e:    f3ef8205    ....    MRS      r2,IPSR
;;;279                    LDR    R3, =log_direct
        0x00207d42:    4b10        .K      LDR      r3,[pc,#64] ; [0x207d84] = 0x79b1
;;;280                    BLX    R3
        0x00207d44:    4798        .G      BLX      r3
;;;281                    B      .
        0x00207d46:    e7fe        ..      B        0x207d46 ; ADC_Handler + 14
    __user_setup_stackheap
;;;282    
;;;283                    ENDP
;;;284    
;;;285    
;;;286    ; User Initial Stack
;;;287                    EXPORT  __user_setup_stackheap
;;;288    __user_setup_stackheap PROC
;;;289                    BX      LR
        0x00207d48:    4770        pG      BX       lr
    $d
    DEFAULT_HANDLER_TXT
        0x00207d4a:    7245        Er      DCW    29253
        0x00207d4c:    21726f72    ror!    DCD    561147762
        0x00207d50:    656c5020     Ple    DCD    1701597216
        0x00207d54:    20657361    ase     DCD    543519585
        0x00207d58:    6c706d69    impl    DCD    1819307369
        0x00207d5c:    6e656d65    emen    DCD    1852140901
        0x00207d60:    6f792074    t yo    DCD    1870209140
        0x00207d64:    49207275    ur I    DCD    1226863221
        0x00207d68:    48205253    SR H    DCD    1210077779
        0x00207d6c:    6c646e61    andl    DCD    1818521185
        0x00207d70:    66207265    er f    DCD    1713402469
        0x00207d74:    4920726f    or I    DCD    1226863215
        0x00207d78:    25205152    RQ %    DCD    622874962
        0x00207d7c:    000a2164    d!..    DCD    663908
        0x00207d80:    00207d4a    J} .    DCD    2129226
        0x00207d84:    000079b1    .y..    DCD    31153
    $t
    .text
    RCC_PeriphClockCmd
;;; .\..\..\..\src\mcu\peripheral\rtl876x_rcc.c
;;;66     {
        0x00207d88:    b5f0        ..      PUSH     {r4-r7,lr}
        0x00207d8a:    f44f7790    O..w    MOV      r7,#0x120
        0x00207d8e:    067b        {.      LSLS     r3,r7,#25
;;;67         /* Check the parameters */
;;;68         assert_param(IS_APB_PERIPH(APBPeriph));
;;;69         assert_param(IS_APB_PERIPH_CLOCK(APBPeriph_Clock));
;;;70         assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;71     
;;;72         uint32_t apbRegOff = ((APBPeriph & (0x03 << 26)) >> 26);
        0x00207d90:    f3c06681    ...f    UBFX     r6,r0,#26,#2
;;;73         uint32_t clkRegOff = ((APBPeriph_Clock & (0x03 << 29)) >> 29);
        0x00207d94:    f3c17541    ..Au    UBFX     r5,r1,#29,#2
        0x00207d98:    f44f7ea0    O..~    MOV      lr,#0x140
        0x00207d9c:    ea400401    @...    ORR      r4,r0,r1
;;;74     
;;;75         /*Open clock gating first*/
;;;76         if (NewState == ENABLE)
        0x00207da0:    2a01        .*      CMP      r2,#1
        0x00207da2:    d006        ..      BEQ      0x207db2 ; RCC_PeriphClockCmd + 42
        0x00207da4:    42b9        .B      CMP      r1,r7
        0x00207da6:    d06c        l.      BEQ      0x207e82 ; RCC_PeriphClockCmd + 250
        0x00207da8:    4571        qE      CMP      r1,lr
        0x00207daa:    d06a        j.      BEQ      0x207e82 ; RCC_PeriphClockCmd + 250
        0x00207dac:    2910        .)      CMP      r1,#0x10
        0x00207dae:    d068        h.      BEQ      0x207e82 ; RCC_PeriphClockCmd + 250
        0x00207db0:    e049        I.      B        0x207e46 ; RCC_PeriphClockCmd + 190
;;;77         {
;;;78             if (APBPeriph_Clock == APBPeriph_KEYSCAN_CLOCK)
        0x00207db2:    f1a14cc0    ...L    SUB      r12,r1,#0x60000000
        0x00207db6:    f1bc0c40    ..@.    SUBS     r12,r12,#0x40
        0x00207dba:    d016        ..      BEQ      0x207dea ; RCC_PeriphClockCmd + 98
        0x00207dbc:    f1b14fc2    ...O    CMP      r1,#0x61000000
        0x00207dc0:    d01e        ..      BEQ      0x207e00 ; RCC_PeriphClockCmd + 120
        0x00207dc2:    f11c0c30    ..0.    ADDS     r12,r12,#0x30
        0x00207dc6:    d003        ..      BEQ      0x207dd0 ; RCC_PeriphClockCmd + 72
        0x00207dc8:    f8dfc2f0    ....    LDR      r12,[pc,#752] ; [0x2080bc] = 0x60010000
        0x00207dcc:    4561        aE      CMP      r1,r12
        0x00207dce:    d124        $.      BNE      0x207e1a ; RCC_PeriphClockCmd + 146
        0x00207dd0:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x00207dd4:    f04c6c80    L..l    ORR      r12,r12,#0x4000000
        0x00207dd8:    f8c3c20c    ....    STR      r12,[r3,#0x20c]
        0x00207ddc:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x00207de0:    f04c6c00    L..l    ORR      r12,r12,#0x8000000
        0x00207de4:    f8c3c20c    ....    STR      r12,[r3,#0x20c]
        0x00207de8:    e027        '.      B        0x207e3a ; RCC_PeriphClockCmd + 178
;;;79             {
;;;80                 /*Open 5M clock source*/
;;;81                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
        0x00207dea:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x00207dee:    f04c6c80    L..l    ORR      r12,r12,#0x4000000
        0x00207df2:    f8c3c20c    ....    STR      r12,[r3,#0x20c]
;;;82                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
        0x00207df6:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x00207dfa:    f04c5c00    L..\    ORR      r12,r12,#0x20000000
        0x00207dfe:    e7f1        ..      B        0x207de4 ; RCC_PeriphClockCmd + 92
;;;83             }
;;;84             else if (APBPeriph_Clock == APBPeriph_ADC_CLOCK)
;;;85             {
;;;86                 /*Open 10M clock source*/
;;;87                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
        0x00207e00:    f8d3420c    ...B    LDR      r4,[r3,#0x20c]
        0x00207e04:    f0446480    D..d    ORR      r4,r4,#0x4000000
        0x00207e08:    f8c3420c    ...B    STR      r4,[r3,#0x20c]
;;;88                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
        0x00207e0c:    f8d3420c    ...B    LDR      r4,[r3,#0x20c]
        0x00207e10:    f0445480    D..T    ORR      r4,r4,#0x10000000
        0x00207e14:    f8c3420c    ...B    STR      r4,[r3,#0x20c]
        0x00207e18:    e015        ..      B        0x207e46 ; RCC_PeriphClockCmd + 190
;;;89             }
;;;90             else if ((APBPeriph_Clock == APBPeriph_QDEC_CLOCK) || (APBPeriph_Clock == APBPeriph_SPI2W_CLOCK))
;;;91             {
;;;92                 /*Open 20M clock source*/
;;;93                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;94                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;95             }
;;;96             else if (APBPeriph_Clock == APBPeriph_TIMER_CLOCK)
        0x00207e1a:    f8dfc2a4    ....    LDR      r12,[pc,#676] ; [0x2080c0] = 0x20004000
        0x00207e1e:    4561        aE      CMP      r1,r12
        0x00207e20:    d10b        ..      BNE      0x207e3a ; RCC_PeriphClockCmd + 178
;;;97             {
;;;98                 /* Enable TIM0~1 fixed 40M */
;;;99                 CLK_SOURCE_REG_2 |= BIT9;
        0x00207e22:    f8d3c360    ..`.    LDR      r12,[r3,#0x360]
        0x00207e26:    f44c7c00    L..|    ORR      r12,r12,#0x200
        0x00207e2a:    f8c3c360    ..`.    STR      r12,[r3,#0x360]
;;;100                /* enable TIM2~7 ICG*/
;;;101                CLK_SOURCE_REG_0 |= BIT4;
        0x00207e2e:    f8d3c348    ..H.    LDR      r12,[r3,#0x348]
        0x00207e32:    f04c0c10    L...    ORR      r12,r12,#0x10
        0x00207e36:    f8c3c348    ..H.    STR      r12,[r3,#0x348]
;;;102            }
;;;103        }
;;;104    
;;;105        /* Special register handle */
;;;106        if (NewState == ENABLE)
;;;107        {
;;;108            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
        0x00207e3a:    42b9        .B      CMP      r1,r7
        0x00207e3c:    d01d        ..      BEQ      0x207e7a ; RCC_PeriphClockCmd + 242
        0x00207e3e:    4571        qE      CMP      r1,lr
        0x00207e40:    d01b        ..      BEQ      0x207e7a ; RCC_PeriphClockCmd + 242
;;;109                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
        0x00207e42:    2910        .)      CMP      r1,#0x10
        0x00207e44:    d019        ..      BEQ      0x207e7a ; RCC_PeriphClockCmd + 242
;;;110            {
;;;111                SYSBLKCTRL->u_220 |= APBPeriph | APBPeriph_Clock;
;;;112                return;
;;;113            }
;;;114        }
;;;115        else
;;;116        {
;;;117            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
;;;118                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
;;;119            {
;;;120                SYSBLKCTRL->u_220 &= ~(APBPeriph | APBPeriph_Clock);
;;;121                return;
;;;122            }
;;;123        }
;;;124    
;;;125        /* clear flag */
;;;126        APBPeriph &= (~(0x03 << 26));
        0x00207e46:    f0206340     .@c    BIC      r3,r0,#0xc000000
;;;127        APBPeriph_Clock &= (~(0x03 << 29));
        0x00207e4a:    f02140c0    !..@    BIC      r0,r1,#0x60000000
        0x00207e4e:    ea4f0186    O...    LSL      r1,r6,#2
        0x00207e52:    f1014180    ...A    ADD      r1,r1,#0x40000000
;;;128    
;;;129        if (NewState == ENABLE)
        0x00207e56:    2a01        .*      CMP      r2,#1
        0x00207e58:    f8d12210    ..."    LDR      r2,[r1,#0x210]
        0x00207e5c:    d017        ..      BEQ      0x207e8e ; RCC_PeriphClockCmd + 262
;;;130        {
;;;131            //enable peripheral
;;;132            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) |= APBPeriph;
;;;133            //enable peripheral clock
;;;134            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= APBPeriph_Clock;
;;;135            //enable peripheral clock in sleep mode
;;;136            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= (APBPeriph_Clock << 1);
;;;137        }
;;;138        else
;;;139        {
;;;140            //disable peripheral
;;;141            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) &= (~APBPeriph);
        0x00207e5e:    439a        .C      BICS     r2,r2,r3
;;;142            //disable peripheral clock
;;;143            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~APBPeriph_Clock);
        0x00207e60:    f8c12210    ..."    STR      r2,[r1,#0x210]
        0x00207e64:    00a9        ..      LSLS     r1,r5,#2
        0x00207e66:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x00207e6a:    f8d1222c    ..,"    LDR      r2,[r1,#0x22c]
        0x00207e6e:    4382        .C      BICS     r2,r2,r0
;;;144            //disable peripheral clock in sleep mode
;;;145            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~(APBPeriph_Clock << 1));
        0x00207e70:    ea220040    ".@.    BIC      r0,r2,r0,LSL #1
        0x00207e74:    f8c1022c    ..,.    STR      r0,[r1,#0x22c]
;;;146        }
;;;147    
;;;148        return;
;;;149    }
        0x00207e78:    bdf0        ..      POP      {r4-r7,pc}
        0x00207e7a:    f8d30220    .. .    LDR      r0,[r3,#0x220]
        0x00207e7e:    4320         C      ORRS     r0,r0,r4
        0x00207e80:    e002        ..      B        0x207e88 ; RCC_PeriphClockCmd + 256
        0x00207e82:    f8d30220    .. .    LDR      r0,[r3,#0x220]
        0x00207e86:    43a0        .C      BICS     r0,r0,r4
        0x00207e88:    f8c30220    .. .    STR      r0,[r3,#0x220]
        0x00207e8c:    bdf0        ..      POP      {r4-r7,pc}
        0x00207e8e:    431a        .C      ORRS     r2,r2,r3
        0x00207e90:    f8c12210    ..."    STR      r2,[r1,#0x210]
        0x00207e94:    00a9        ..      LSLS     r1,r5,#2
        0x00207e96:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x00207e9a:    f8d1222c    ..,"    LDR      r2,[r1,#0x22c]
        0x00207e9e:    4302        .C      ORRS     r2,r2,r0
        0x00207ea0:    ea420040    B.@.    ORR      r0,r2,r0,LSL #1
        0x00207ea4:    e7e6        ..      B        0x207e74 ; RCC_PeriphClockCmd + 236
    RCC_SPIClkDivConfig
        0x00207ea6:    4b87        .K      LDR      r3,[pc,#540] ; [0x2080c4] = 0x40013000
        0x00207ea8:    f04f4280    O..B    MOV      r2,#0x40000000
        0x00207eac:    4298        .B      CMP      r0,r3
;;;150    
;;;151    /**
;;;152      * @brief  SPI clock divider config.
;;;153      * @param  SPIx: where x can be 0 or 1 to select the SPI peripheral.
;;;154      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;155      *      this parameter can be one of the following values:
;;;156      *     @arg SPI_CLOCK_DIV_1
;;;157      *     @arg SPI_CLOCK_DIV_2
;;;158      *     @arg SPI_CLOCK_DIV_4
;;;159      *     @arg SPI_CLOCK_DIV_8
;;;160      * @retval None
;;;161      */
;;;162    void RCC_SPIClkDivConfig(SPI_TypeDef *SPIx, uint16_t ClockDiv)
;;;163    {
        0x00207eae:    d116        ..      BNE      0x207ede ; RCC_SPIClkDivConfig + 56
;;;164        assert_param(IS_SPI_DIV(ClockDiv));
;;;165    
;;;166        /* Config I2C clock divider */
;;;167        if (SPIx == SPI0)
;;;168        {
;;;169            /* disable clock first */
;;;170            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_SPI0_EN_Msk;
        0x00207eb0:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x00207eb4:    f4203080     ..0    BIC      r0,r0,#0x10000
        0x00207eb8:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;171            //platform_delay_us(1);
;;;172    
;;;173            CLK_SOURCE_REG_1 &= ~(0x03 << 19);
        0x00207ebc:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00207ec0:    f42010c0     ...    BIC      r0,r0,#0x180000
        0x00207ec4:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;174            CLK_SOURCE_REG_1 |= (ClockDiv << 19);
        0x00207ec8:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00207ecc:    ea4040c1    @..@    ORR      r0,r0,r1,LSL #19
        0x00207ed0:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;175    
;;;176            //platform_delay_us(1);
;;;177            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_SPI0_EN_Msk;
        0x00207ed4:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x00207ed8:    f4403080    @..0    ORR      r0,r0,#0x10000
        0x00207edc:    e018        ..      B        0x207f10 ; RCC_SPIClkDivConfig + 106
;;;178        }
;;;179        else if (SPIx == SPI1)
        0x00207ede:    4b7a        zK      LDR      r3,[pc,#488] ; [0x2080c8] = 0x40013400
        0x00207ee0:    4298        .B      CMP      r0,r3
        0x00207ee2:    d117        ..      BNE      0x207f14 ; RCC_SPIClkDivConfig + 110
;;;180        {
;;;181            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_SPI1_EN_Msk;
        0x00207ee4:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x00207ee8:    f4202080     ..     BIC      r0,r0,#0x40000
        0x00207eec:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;182            //platform_delay_us(1);
;;;183    
;;;184            CLK_SOURCE_REG_1 &= ~(0x03 << 21);
        0x00207ef0:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00207ef4:    f42000c0     ...    BIC      r0,r0,#0x600000
        0x00207ef8:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;185            CLK_SOURCE_REG_1 |= (ClockDiv << 21);
        0x00207efc:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00207f00:    ea405041    @.AP    ORR      r0,r0,r1,LSL #21
        0x00207f04:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;186    
;;;187            //platform_delay_us(1);
;;;188            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_SPI1_EN_Msk;
        0x00207f08:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x00207f0c:    f4402080    @..     ORR      r0,r0,#0x40000
        0x00207f10:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;189        }
;;;190        return;
;;;191    }
        0x00207f14:    4770        pG      BX       lr
    RCC_I2CClkDivConfig
        0x00207f16:    4b6d        mK      LDR      r3,[pc,#436] ; [0x2080cc] = 0x40015000
        0x00207f18:    049a        ..      LSLS     r2,r3,#18
        0x00207f1a:    4298        .B      CMP      r0,r3
;;;192    
;;;193    /**
;;;194      * @brief  I2C clock divider config.
;;;195      * @param  I2Cx: where x can be 0 or 1 to select the I2C peripheral.
;;;196      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;197      *      this parameter can be one of the following values:
;;;198      *     @arg I2C_CLOCK_DIV_1
;;;199      *     @arg I2C_CLOCK_DIV_2
;;;200      *     @arg I2C_CLOCK_DIV_4
;;;201      *     @arg I2C_CLOCK_DIV_8
;;;202      * @retval None
;;;203      */
;;;204    void RCC_I2CClkDivConfig(I2C_TypeDef *I2Cx, uint16_t ClockDiv)
;;;205    {
        0x00207f1c:    d116        ..      BNE      0x207f4c ; RCC_I2CClkDivConfig + 54
;;;206        assert_param(IS_I2C_DIV(ClockDiv));
;;;207    
;;;208        /* Config I2C clock divider */
;;;209        if (I2Cx == I2C0)
;;;210        {
;;;211            /* disable clock first */
;;;212            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 &= ~SYSBLK_ACTCK_I2C0_EN_Msk;
        0x00207f1e:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x00207f22:    f0200001     ...    BIC      r0,r0,#1
        0x00207f26:    f8c20238    ..8.    STR      r0,[r2,#0x238]
;;;213            //platform_delay_us(1);
;;;214    
;;;215            CLK_SOURCE_REG_1 &= ~(0x03 << 15);
        0x00207f2a:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00207f2e:    f42030c0     ..0    BIC      r0,r0,#0x18000
        0x00207f32:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;216            CLK_SOURCE_REG_1 |= (ClockDiv << 15);
        0x00207f36:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00207f3a:    ea4030c1    @..0    ORR      r0,r0,r1,LSL #15
        0x00207f3e:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;217    
;;;218            //platform_delay_us(1);
;;;219            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= SYSBLK_ACTCK_I2C0_EN_Msk;
        0x00207f42:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x00207f46:    f0400001    @...    ORR      r0,r0,#1
        0x00207f4a:    e018        ..      B        0x207f7e ; RCC_I2CClkDivConfig + 104
;;;220        }
;;;221        else if (I2Cx == I2C1)
        0x00207f4c:    4b60        `K      LDR      r3,[pc,#384] ; [0x2080d0] = 0x40015400
        0x00207f4e:    4298        .B      CMP      r0,r3
        0x00207f50:    d117        ..      BNE      0x207f82 ; RCC_I2CClkDivConfig + 108
;;;222        {
;;;223            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 &= ~SYSBLK_ACTCK_I2C1_EN_Msk;
        0x00207f52:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x00207f56:    f0200004     ...    BIC      r0,r0,#4
        0x00207f5a:    f8c20238    ..8.    STR      r0,[r2,#0x238]
;;;224            //platform_delay_us(1);
;;;225    
;;;226            CLK_SOURCE_REG_1 &= ~(0x03 << 17);
        0x00207f5e:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00207f62:    f42020c0     ..     BIC      r0,r0,#0x60000
        0x00207f66:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;227            CLK_SOURCE_REG_1 |= (ClockDiv << 17);
        0x00207f6a:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00207f6e:    ea404041    @.A@    ORR      r0,r0,r1,LSL #17
        0x00207f72:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;228    
;;;229            //platform_delay_us(1);
;;;230            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= SYSBLK_ACTCK_I2C1_EN_Msk;
        0x00207f76:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x00207f7a:    f0400004    @...    ORR      r0,r0,#4
        0x00207f7e:    f8c20238    ..8.    STR      r0,[r2,#0x238]
;;;231        }
;;;232    
;;;233        return;
;;;234    }
        0x00207f82:    4770        pG      BX       lr
    RCC_UARTClkDivConfig
;;;235    
;;;236    /**
;;;237      * @brief  UART clock divider config.
;;;238      * @param  UARTx: selected UART peripheral.
;;;239      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;240      *      this parameter can be one of the following values:
;;;241      *     @arg UART_CLOCK_DIV_1
;;;242      *     @arg UART_CLOCK_DIV_2
;;;243      *     @arg UART_CLOCK_DIV_4
;;;244      *     @arg UART_CLOCK_DIV_16
;;;245      * @retval None
;;;246      */
;;;247    void RCC_UARTClkDivConfig(UART_TypeDef *UARTx, uint16_t ClockDiv)
;;;248    {
;;;249        assert_param(IS_UART_DIV(ClockDiv));
;;;250    
;;;251        /* Config UART clock divider */
;;;252        if (UARTx == UART)
        0x00207f84:    4b53        SK      LDR      r3,[pc,#332] ; [0x2080d4] = 0x40012000
        0x00207f86:    045a        Z.      LSLS     r2,r3,#17
        0x00207f88:    4298        .B      CMP      r0,r3
;;; .\..\..\..\src\mcu\peripheral\rtl876x_rcc.c (248)
        0x00207f8a:    d118        ..      BNE      0x207fbe ; RCC_UARTClkDivConfig + 58
;;;249        assert_param(IS_UART_DIV(ClockDiv));
;;;250    
;;;251        /* Config UART clock divider */
;;;252        if (UARTx == UART)
;;;253        {
;;;254            /* disable clock first */
;;;255            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_UART0DATA_EN_Msk;
        0x00207f8c:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x00207f90:    f0200001     ...    BIC      r0,r0,#1
        0x00207f94:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;256            //platform_delay_us(1);
;;;257    
;;;258            CLK_SOURCE_REG_1 &= ~(0x03 << 9);
        0x00207f98:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00207f9c:    f42060c0     ..`    BIC      r0,r0,#0x600
        0x00207fa0:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;259            CLK_SOURCE_REG_1 |= (ClockDiv << 9);
        0x00207fa4:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00207fa8:    ea402041    @.A     ORR      r0,r0,r1,LSL #9
        0x00207fac:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;260    
;;;261            //platform_delay_us(1);
;;;262            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_UART0DATA_EN_Msk;
        0x00207fb0:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x00207fb4:    f0400001    @...    ORR      r0,r0,#1
        0x00207fb8:    f8c20234    ..4.    STR      r0,[r2,#0x234]
        0x00207fbc:    4770        pG      BX       lr
;;;263        }
;;;264        else if (UARTx == UART1)
        0x00207fbe:    4b46        FK      LDR      r3,[pc,#280] ; [0x2080d8] = 0x40011000
        0x00207fc0:    4298        .B      CMP      r0,r3
        0x00207fc2:    d1fb        ..      BNE      0x207fbc ; RCC_UARTClkDivConfig + 56
;;;265        {
;;;266            SYSBLKCTRL->u_230.CLK_CTRL &= ~SYSBLK_ACTCK_LOGUART_EN_Msk;
        0x00207fc4:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x00207fc8:    f4205080     ..P    BIC      r0,r0,#0x1000
        0x00207fcc:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;267            //platform_delay_us(1);
;;;268    
;;;269            CLK_SOURCE_REG_1 &= ~(0x03 << 11);
        0x00207fd0:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00207fd4:    f42050c0     ..P    BIC      r0,r0,#0x1800
        0x00207fd8:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;270            CLK_SOURCE_REG_1 |= (ClockDiv << 11);
        0x00207fdc:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00207fe0:    ea4020c1    @..     ORR      r0,r0,r1,LSL #11
        0x00207fe4:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;271    
;;;272            //platform_delay_us(1);
;;;273            SYSBLKCTRL->u_230.CLK_CTRL |= SYSBLK_ACTCK_LOGUART_EN_Msk;
        0x00207fe8:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x00207fec:    f4405080    @..P    ORR      r0,r0,#0x1000
        0x00207ff0:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;274        }
;;;275    
;;;276        return;
;;;277    }
        0x00207ff4:    4770        pG      BX       lr
    RCC_PeriClockConfig
;;;278    
;;;279    /**
;;;280      * @brief  Enables or disables the APB peripheral clock.
;;;281      * @param  APBPeriph_Clock: specifies the APB peripheral clock config.
;;;282      *      this parameter can be one of the following values(must be the same with APBPeriph):
;;;283      *     @arg APBPeriph_TIMER_CLOCK
;;;284      *     @arg APBPeriph_GDMA_CLOCK
;;;285      *     @arg APBPeriph_SPI2W_CLOCK
;;;286      *     @arg APBPeriph_KEYSCAN_CLOCK
;;;287      *     @arg APBPeriph_QDEC_CLOCK
;;;288      *     @arg APBPeriph_I2C1_CLOCK
;;;289      *     @arg APBPeriph_I2C0_CLOCK
;;;290      *     @arg APBPeriph_IR_CLOCK
;;;291      *     @arg APBPeriph_SPI1_CLOCK
;;;292      *     @arg APBPeriph_SPI0_CLOCK
;;;293      *     @arg APBPeriph_UART0_CLOCK
;;;294      *     @arg APBPeriph_UART1_CLOCK
;;;295      *     @arg APBPeriph_UART2_CLOCK
;;;296      *     @arg APBPeriph_GPIO_CLOCK
;;;297      *     @arg APBPeriph_ADC_CLOCK
;;;298      *     @arg APBPeriph_I2S0_CLOCK
;;;299      *     @arg APBPeriph_I2S1_CLOCK
;;;300      *     @arg APBPeriph_CODEC_CLOCK
;;;301      * @param  NewState: new state of the specified peripheral clock.
;;;302      *   This parameter can be: ENABLE or DISABLE.
;;;303      * @retval None
;;;304      */
;;;305    void RCC_PeriClockConfig(uint32_t APBPeriph_Clock, FunctionalState NewState)
;;;306    {
        0x00207ff6:    b530        0.      PUSH     {r4,r5,lr}
        0x00207ff8:    f44f74a0    O..t    MOV      r4,#0x140
        0x00207ffc:    0623        #.      LSLS     r3,r4,#24
        0x00207ffe:    f3c07241    ..Ar    UBFX     r2,r0,#29,#2
        0x00208002:    f44f7590    O..u    MOV      r5,#0x120
        0x00208006:    2901        .)      CMP      r1,#1
        0x00208008:    d006        ..      BEQ      0x208018 ; RCC_PeriClockConfig + 34
        0x0020800a:    42a8        .B      CMP      r0,r5
        0x0020800c:    d01e        ..      BEQ      0x20804c ; RCC_PeriClockConfig + 86
        0x0020800e:    42a0        .B      CMP      r0,r4
        0x00208010:    d01c        ..      BEQ      0x20804c ; RCC_PeriClockConfig + 86
        0x00208012:    2810        .(      CMP      r0,#0x10
        0x00208014:    d01a        ..      BEQ      0x20804c ; RCC_PeriClockConfig + 86
        0x00208016:    e005        ..      B        0x208024 ; RCC_PeriClockConfig + 46
;;;307        /* Check the parameters */
;;;308        assert_param(IS_APB_PERIPH_CLOCK(APBPeriph_Clock));
;;;309        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;310    
;;;311        uint32_t clkRegOff = ((APBPeriph_Clock & (0x03 << 29)) >> 29);
;;;312    
;;;313        /* Special register handle */
;;;314        if (NewState == ENABLE)
;;;315        {
;;;316            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
        0x00208018:    42a8        .B      CMP      r0,r5
        0x0020801a:    d013        ..      BEQ      0x208044 ; RCC_PeriClockConfig + 78
        0x0020801c:    42a0        .B      CMP      r0,r4
        0x0020801e:    d011        ..      BEQ      0x208044 ; RCC_PeriClockConfig + 78
;;;317                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
        0x00208020:    2810        .(      CMP      r0,#0x10
        0x00208022:    d00f        ..      BEQ      0x208044 ; RCC_PeriClockConfig + 78
        0x00208024:    2901        .)      CMP      r1,#1
        0x00208026:    ea4f0182    O...    LSL      r1,r2,#2
        0x0020802a:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x0020802e:    f02040c0     ..@    BIC      r0,r0,#0x60000000
        0x00208032:    f8d1222c    ..,"    LDR      r2,[r1,#0x22c]
        0x00208036:    d00f        ..      BEQ      0x208058 ; RCC_PeriClockConfig + 98
        0x00208038:    4382        .C      BICS     r2,r2,r0
        0x0020803a:    ea220040    ".@.    BIC      r0,r2,r0,LSL #1
        0x0020803e:    f8c1022c    ..,.    STR      r0,[r1,#0x22c]
        0x00208042:    bd30        0.      POP      {r4,r5,pc}
;;;318            {
;;;319                SYSBLKCTRL->u_220 |= APBPeriph_Clock;
        0x00208044:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x00208048:    4301        .C      ORRS     r1,r1,r0
;;;320                return;
        0x0020804a:    e002        ..      B        0x208052 ; RCC_PeriClockConfig + 92
;;;321            }
;;;322        }
;;;323        else
;;;324        {
;;;325            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
;;;326                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
;;;327            {
;;;328                SYSBLKCTRL->u_220 &= ~(APBPeriph_Clock);
        0x0020804c:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x00208050:    4381        .C      BICS     r1,r1,r0
        0x00208052:    f8c31220    .. .    STR      r1,[r3,#0x220]
        0x00208056:    bd30        0.      POP      {r4,r5,pc}
;;;329                return;
;;;330            }
;;;331        }
;;;332    
;;;333        APBPeriph_Clock &= (~(0x03 << 29));
;;;334    
;;;335        if (NewState == ENABLE)
;;;336        {
;;;337            //enable peripheral clock
;;;338            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= APBPeriph_Clock;
        0x00208058:    4302        .C      ORRS     r2,r2,r0
;;;339            //enable peripheral clock in sleep mode
;;;340            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= (APBPeriph_Clock << 1);
        0x0020805a:    ea420040    B.@.    ORR      r0,r2,r0,LSL #1
        0x0020805e:    e7ee        ..      B        0x20803e ; RCC_PeriClockConfig + 72
    RCC_PeriFunctionConfig
;;;341        }
;;;342        else
;;;343        {
;;;344            //disable peripheral clock
;;;345            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~APBPeriph_Clock);
;;;346            //disable peripheral clock in sleep mode
;;;347            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~(APBPeriph_Clock << 1));
;;;348        }
;;;349    
;;;350        return;
;;;351    }
;;;352    
;;;353    /**
;;;354      * @brief  Enables or disables the APB peripheral clock.
;;;355      * @param  APBPeriph: specifies the APB peripheral to gates its clock.
;;;356      *      this parameter can be one of the following values:
;;;357      *     @arg APBPeriph_TIMER
;;;358      *     @arg APBPeriph_GDMA
;;;359      *     @arg APBPeriph_LCD
;;;360      *     @arg APBPeriph_SPI2W
;;;361      *     @arg APBPeriph_KEYSCAN
;;;362      *     @arg APBPeriph_QDEC
;;;363      *     @arg APBPeriph_I2C1
;;;364      *     @arg APBPeriph_I2C0
;;;365      *     @arg APBPeriph_IR
;;;366      *     @arg APBPeriph_SPI1
;;;367      *     @arg APBPeriph_SPI0
;;;368      *     @arg APBPeriph_UART0
;;;369      *     @arg APBPeriph_UART1
;;;370      *     @arg APBPeriph_UART2
;;;371      *     @arg APBPeriph_GPIO
;;;372      *     @arg APBPeriph_ADC
;;;373      *     @arg APBPeriph_I2S0
;;;374      *     @arg APBPeriph_I2S1
;;;375      *     @arg APBPeriph_CODEC
;;;376      * @param  NewState: new state of the specified peripheral clock.
;;;377      *   This parameter can be: ENABLE or DISABLE.
;;;378      * @retval None
;;;379      */
;;;380    void RCC_PeriFunctionConfig(uint32_t APBPeriph, FunctionalState NewState)
;;;381    {
;;;382        /* Check the parameters */
;;;383        assert_param(IS_APB_PERIPH(APBPeriph));
;;;384        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;385    
;;;386        uint32_t apbRegOff = ((APBPeriph & (0x03 << 26)) >> 26);
        0x00208060:    f3c06281    ...b    UBFX     r2,r0,#26,#2
        0x00208064:    f04f4380    O..C    MOV      r3,#0x40000000
        0x00208068:    2901        .)      CMP      r1,#1
;;; .\..\..\..\src\mcu\peripheral\rtl876x_rcc.c (381)
        0x0020806a:    d006        ..      BEQ      0x20807a ; RCC_PeriFunctionConfig + 26
        0x0020806c:    2802        .(      CMP      r0,#2
        0x0020806e:    d01c        ..      BEQ      0x2080aa ; RCC_PeriFunctionConfig + 74
        0x00208070:    2804        .(      CMP      r0,#4
        0x00208072:    d01a        ..      BEQ      0x2080aa ; RCC_PeriFunctionConfig + 74
        0x00208074:    2801        .(      CMP      r0,#1
        0x00208076:    d018        ..      BEQ      0x2080aa ; RCC_PeriFunctionConfig + 74
        0x00208078:    e005        ..      B        0x208086 ; RCC_PeriFunctionConfig + 38
;;;382        /* Check the parameters */
;;;383        assert_param(IS_APB_PERIPH(APBPeriph));
;;;384        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;385    
;;;386        uint32_t apbRegOff = ((APBPeriph & (0x03 << 26)) >> 26);
;;;387    
;;;388        /* Special register handle */
;;;389        if (NewState == ENABLE)
;;;390        {
;;;391            if ((APBPeriph == APBPeriph_I2S0) || ((APBPeriph == APBPeriph_I2S1)) ||
        0x0020807a:    2802        .(      CMP      r0,#2
        0x0020807c:    d011        ..      BEQ      0x2080a2 ; RCC_PeriFunctionConfig + 66
        0x0020807e:    2804        .(      CMP      r0,#4
        0x00208080:    d00f        ..      BEQ      0x2080a2 ; RCC_PeriFunctionConfig + 66
;;;392                (APBPeriph == APBPeriph_CODEC))
        0x00208082:    2801        .(      CMP      r0,#1
        0x00208084:    d00d        ..      BEQ      0x2080a2 ; RCC_PeriFunctionConfig + 66
        0x00208086:    2901        .)      CMP      r1,#1
        0x00208088:    ea4f0182    O...    LSL      r1,r2,#2
        0x0020808c:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x00208090:    f0206040     .@`    BIC      r0,r0,#0xc000000
        0x00208094:    f8d12210    ..."    LDR      r2,[r1,#0x210]
        0x00208098:    d00d        ..      BEQ      0x2080b6 ; RCC_PeriFunctionConfig + 86
        0x0020809a:    4382        .C      BICS     r2,r2,r0
        0x0020809c:    f8c12210    ..."    STR      r2,[r1,#0x210]
        0x002080a0:    4770        pG      BX       lr
;;;393            {
;;;394                SYSBLKCTRL->u_220 |= APBPeriph;
        0x002080a2:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x002080a6:    4301        .C      ORRS     r1,r1,r0
;;;395                return;
        0x002080a8:    e002        ..      B        0x2080b0 ; RCC_PeriFunctionConfig + 80
;;;396            }
;;;397        }
;;;398        else
;;;399        {
;;;400            if ((APBPeriph == APBPeriph_I2S0) || ((APBPeriph == APBPeriph_I2S1)) ||
;;;401                (APBPeriph == APBPeriph_CODEC))
;;;402            {
;;;403                SYSBLKCTRL->u_220 &= ~(APBPeriph);
        0x002080aa:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x002080ae:    4381        .C      BICS     r1,r1,r0
        0x002080b0:    f8c31220    .. .    STR      r1,[r3,#0x220]
        0x002080b4:    4770        pG      BX       lr
;;;404                return;
;;;405            }
;;;406        }
;;;407    
;;;408        /* clear flag */
;;;409        APBPeriph &= (~(0x03 << 26));
;;;410    
;;;411        if (NewState == ENABLE)
;;;412        {
;;;413            //enable peripheral
;;;414            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) |= APBPeriph;
        0x002080b6:    4302        .C      ORRS     r2,r2,r0
        0x002080b8:    e7f0        ..      B        0x20809c ; RCC_PeriFunctionConfig + 60
    $d
        0x002080ba:    0000        ..      DCW    0
        0x002080bc:    60010000    ...`    DCD    1610678272
        0x002080c0:    20004000    .@.     DCD    536887296
        0x002080c4:    40013000    .0.@    DCD    1073819648
        0x002080c8:    40013400    .4.@    DCD    1073820672
        0x002080cc:    40015000    .P.@    DCD    1073827840
        0x002080d0:    40015400    .T.@    DCD    1073828864
        0x002080d4:    40012000    . .@    DCD    1073815552
        0x002080d8:    40011000    ...@    DCD    1073811456
    $t
    .text
    GPIO_DeInit
;;; .\..\..\..\src\mcu\peripheral\rtl876x_gpio.c
;;;33         RCC_PeriphClockCmd(APBPeriph_GPIO, APBPeriph_GPIO_CLOCK, DISABLE);
        0x002080dc:    2200        ."      MOVS     r2,#0
        0x002080de:    f04f5104    O..Q    MOV      r1,#0x21000000
        0x002080e2:    485d        ]H      LDR      r0,[pc,#372] ; [0x208258] = 0xc000100
        0x002080e4:    f7ffbe50    ..P.    B.W      RCC_PeriphClockCmd ; 0x207d88
    GPIO_Init
;;;34     }
;;;35     
;;;36     /**
;;;37       * @brief  Initializes the GPIO peripheral according to the specified
;;;38       *         parameters in the GPIO_InitStruct.
;;;39       * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
;;;40       *         contains the configuration information for the specified GPIO peripheral.
;;;41       * @retval None
;;;42       */
;;;43     void GPIO_Init(GPIO_InitTypeDef *GPIO_InitStruct)
;;;44     {
;;;45         /* Check the parameters */
;;;46         assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;47         assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;48         assert_param(IS_GPIOIT_LEVEL_TYPE(GPIO_InitStruct->GPIO_ITTrigger));
;;;49         assert_param(IS_GPIOIT_POLARITY_TYPE(GPIO_InitStruct->GPIO_ITPolarity));
;;;50         assert_param(IS_GPIOIT_DEBOUNCE_TYPE(GPIO_InitStruct->GPIO_ITDebounce));
;;;51     
;;;52         /* GPIO configure */
;;;53         if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT)
        0x002080e8:    7903        .y      LDRB     r3,[r0,#4]
        0x002080ea:    495c        \I      LDR      r1,[pc,#368] ; [0x20825c] = 0x40001000
        0x002080ec:    2b01        .+      CMP      r3,#1
        0x002080ee:    6802        .h      LDR      r2,[r0,#0]
        0x002080f0:    684b        Kh      LDR      r3,[r1,#4]
;;; .\..\..\..\src\mcu\peripheral\rtl876x_gpio.c (44)
        0x002080f2:    d030        0.      BEQ      0x208156 ; GPIO_Init + 110
;;;45         /* Check the parameters */
;;;46         assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;47         assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;48         assert_param(IS_GPIOIT_LEVEL_TYPE(GPIO_InitStruct->GPIO_ITTrigger));
;;;49         assert_param(IS_GPIOIT_POLARITY_TYPE(GPIO_InitStruct->GPIO_ITPolarity));
;;;50         assert_param(IS_GPIOIT_DEBOUNCE_TYPE(GPIO_InitStruct->GPIO_ITDebounce));
;;;51     
;;;52         /* GPIO configure */
;;;53         if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT)
;;;54         {
;;;55             GPIO->DATADIR |= GPIO_InitStruct->GPIO_Pin;
;;;56     
;;;57             if (GPIO_InitStruct->GPIO_ControlMode == GPIO_SOFTWARE_MODE)
;;;58             {
;;;59                 /* Config GPIO control software mode */
;;;60                 GPIO->DATASRC &= (~GPIO_InitStruct->GPIO_Pin);
;;;61             }
;;;62             else
;;;63             {
;;;64                 /* Config GPIO hardware control mode */
;;;65                 GPIO->DATASRC |= (GPIO_InitStruct->GPIO_Pin);
;;;66             }
;;;67     
;;;68         }
;;;69         else
;;;70         {
;;;71             /*Configure GPIO input mode */
;;;72             GPIO->DATADIR = GPIO->DATADIR & (~GPIO_InitStruct->GPIO_Pin);
        0x002080f4:    4393        .C      BICS     r3,r3,r2
        0x002080f6:    604b        K`      STR      r3,[r1,#4]
;;;73     
;;;74             if (GPIO_InitStruct->GPIO_ITCmd == ENABLE)
        0x002080f8:    7942        By      LDRB     r2,[r0,#5]
        0x002080fa:    2a01        .*      CMP      r2,#1
        0x002080fc:    d12a        *.      BNE      0x208154 ; GPIO_Init + 108
;;;75             {
;;;76     
;;;77                 GPIO->INTMASK = ~GPIO_Pin_All;
        0x002080fe:    2200        ."      MOVS     r2,#0
        0x00208100:    634a        Jc      STR      r2,[r1,#0x34]
;;;78     
;;;79                 /* configure GPIO interrupt trigger type */
;;;80                 if (GPIO_InitStruct->GPIO_ITTrigger == GPIO_INT_Trigger_LEVEL)
        0x00208102:    7982        .y      LDRB     r2,[r0,#6]
        0x00208104:    b38a        ..      CBZ      r2,0x20816a ; GPIO_Init + 130
;;;81                 {
;;;82                     GPIO->INTTYPE = GPIO->INTTYPE & (~GPIO_InitStruct->GPIO_Pin);
;;;83     
;;;84                     /* Level-sensitive synchronization enable register */
;;;85                     GPIO->LSSYNC |= GPIO_InitStruct->GPIO_Pin;
;;;86                 }
;;;87                 else if (GPIO_InitStruct->GPIO_ITTrigger == GPIO_INT_Trigger_EDGE)
        0x00208106:    2a01        .*      CMP      r2,#1
        0x00208108:    d03d        =.      BEQ      0x208186 ; GPIO_Init + 158
;;;88                 {
;;;89                     GPIO->INTTYPE = (GPIO->INTTYPE & (~GPIO_InitStruct->GPIO_Pin))
;;;90                                     | GPIO_InitStruct->GPIO_Pin;
;;;91                 }
;;;92                 else
;;;93                 {
;;;94                     GPIO->INTBOTHEDGE |= GPIO_InitStruct->GPIO_Pin;
        0x0020810a:    6e8a        .n      LDR      r2,[r1,#0x68]
        0x0020810c:    6803        .h      LDR      r3,[r0,#0]
        0x0020810e:    431a        .C      ORRS     r2,r2,r3
        0x00208110:    668a        .f      STR      r2,[r1,#0x68]
;;;95                 }
;;;96     
;;;97                 /* configure Interrupt polarity register */
;;;98                 if (GPIO_InitStruct->GPIO_ITPolarity == GPIO_INT_POLARITY_ACTIVE_LOW)
        0x00208112:    79c2        .y      LDRB     r2,[r0,#7]
        0x00208114:    b352        R.      CBZ      r2,0x20816c ; GPIO_Init + 132
;;;99                 {
;;;100                    GPIO->INTPOLARITY = GPIO->INTPOLARITY & (~GPIO_InitStruct->GPIO_Pin);
;;;101                }
;;;102                else
;;;103                {
;;;104                    GPIO->INTPOLARITY = (GPIO->INTPOLARITY & (~GPIO_InitStruct->GPIO_Pin))
        0x00208116:    6bcb        .k      LDR      r3,[r1,#0x3c]
        0x00208118:    6802        .h      LDR      r2,[r0,#0]
        0x0020811a:    4393        .C      BICS     r3,r3,r2
        0x0020811c:    4313        .C      ORRS     r3,r3,r2
        0x0020811e:    63cb        .c      STR      r3,[r1,#0x3c]
;;;105                                        | GPIO_InitStruct->GPIO_Pin;
;;;106                }
;;;107                /* Configure Debounce enable register */
;;;108                if (GPIO_InitStruct->GPIO_ITDebounce == GPIO_INT_DEBOUNCE_DISABLE)
        0x00208120:    7a02        .z      LDRB     r2,[r0,#8]
        0x00208122:    b37a        z.      CBZ      r2,0x208184 ; GPIO_Init + 156
;;;109                {
;;;110                    GPIO->DEBOUNCE = GPIO->DEBOUNCE & (~GPIO_InitStruct->GPIO_Pin);
;;;111                }
;;;112                else
;;;113                {
;;;114                    GPIO->DEBOUNCE = (GPIO->DEBOUNCE & (~GPIO_InitStruct->GPIO_Pin))
        0x00208124:    6c8b        .l      LDR      r3,[r1,#0x48]
        0x00208126:    6802        .h      LDR      r2,[r0,#0]
        0x00208128:    4393        .C      BICS     r3,r3,r2
        0x0020812a:    4313        .C      ORRS     r3,r3,r2
        0x0020812c:    648b        .d      STR      r3,[r1,#0x48]
;;;115                                     | GPIO_InitStruct->GPIO_Pin;
;;;116    
;;;117    #ifdef _IS_ASIC_
;;;118                    /* Config debounce time , default debounce DIV is 14*/
;;;119                    GPIO_DBCLK_DIV = (((0xd) << 8) | (1 << 12));
;;;120                    GPIO_DBCLK_DIV |= ((((GPIO_InitStruct->GPIO_DebounceTime) * (GPIO_CLOCK_SOURCE_KHZ) >>
;;;121                                         (14)) - 1) & 0xff);
;;;122    #else
;;;123                    /* Config debounce time , default debounce DIV is 13*/
;;;124                    GPIO_DBCLK_DIV = (((0x3) << 10) | (1 << 12));
        0x0020812e:    f04f4180    O..A    MOV      r1,#0x40000000
        0x00208132:    f44f52e0    O..R    MOV      r2,#0x1c00
        0x00208136:    f8c12344    ..D#    STR      r2,[r1,#0x344]
;;;125                    GPIO_DBCLK_DIV |= ((((GPIO_InitStruct->GPIO_DebounceTime) * (GPIO_CLOCK_SOURCE_KHZ) >>
        0x0020813a:    f8d12344    ..D#    LDR      r2,[r1,#0x344]
        0x0020813e:    68c0        .h      LDR      r0,[r0,#0xc]
        0x00208140:    f6446320    D. c    MOV      r3,#0x4e20
        0x00208144:    4358        XC      MULS     r0,r3,r0
        0x00208146:    23ff        .#      MOVS     r3,#0xff
        0x00208148:    eb033050    ..P0    ADD      r0,r3,r0,LSR #13
        0x0020814c:    b2c0        ..      UXTB     r0,r0
        0x0020814e:    4302        .C      ORRS     r2,r2,r0
        0x00208150:    f8c12344    ..D#    STR      r2,[r1,#0x344]
;;;126                                         (13)) - 1) & 0xff);
;;;127    #endif
;;;128                }
;;;129    
;;;130                /* Configure Interrupt enable register */
;;;131                //GPIO->INTEN |= GPIO_InitStruct->GPIO_Pin;
;;;132            }
;;;133        }
;;;134    }
        0x00208154:    4770        pG      BX       lr
        0x00208156:    4313        .C      ORRS     r3,r3,r2
        0x00208158:    604b        K`      STR      r3,[r1,#4]
        0x0020815a:    7a42        Bz      LDRB     r2,[r0,#9]
        0x0020815c:    2a00        .*      CMP      r2,#0
        0x0020815e:    688a        .h      LDR      r2,[r1,#8]
        0x00208160:    6800        .h      LDR      r0,[r0,#0]
        0x00208162:    d004        ..      BEQ      0x20816e ; GPIO_Init + 134
        0x00208164:    4302        .C      ORRS     r2,r2,r0
        0x00208166:    608a        .`      STR      r2,[r1,#8]
        0x00208168:    4770        pG      BX       lr
        0x0020816a:    e002        ..      B        0x208172 ; GPIO_Init + 138
        0x0020816c:    e011        ..      B        0x208192 ; GPIO_Init + 170
        0x0020816e:    4382        .C      BICS     r2,r2,r0
        0x00208170:    e7f9        ..      B        0x208166 ; GPIO_Init + 126
        0x00208172:    6b8a        .k      LDR      r2,[r1,#0x38]
        0x00208174:    6803        .h      LDR      r3,[r0,#0]
        0x00208176:    439a        .C      BICS     r2,r2,r3
        0x00208178:    638a        .c      STR      r2,[r1,#0x38]
        0x0020817a:    6e0a        .n      LDR      r2,[r1,#0x60]
        0x0020817c:    6803        .h      LDR      r3,[r0,#0]
        0x0020817e:    431a        .C      ORRS     r2,r2,r3
        0x00208180:    660a        .f      STR      r2,[r1,#0x60]
        0x00208182:    e7c6        ..      B        0x208112 ; GPIO_Init + 42
        0x00208184:    e00a        ..      B        0x20819c ; GPIO_Init + 180
        0x00208186:    6b8b        .k      LDR      r3,[r1,#0x38]
        0x00208188:    6802        .h      LDR      r2,[r0,#0]
        0x0020818a:    4393        .C      BICS     r3,r3,r2
        0x0020818c:    4313        .C      ORRS     r3,r3,r2
        0x0020818e:    638b        .c      STR      r3,[r1,#0x38]
        0x00208190:    e7bf        ..      B        0x208112 ; GPIO_Init + 42
        0x00208192:    6bca        .k      LDR      r2,[r1,#0x3c]
        0x00208194:    6803        .h      LDR      r3,[r0,#0]
        0x00208196:    439a        .C      BICS     r2,r2,r3
        0x00208198:    63ca        .c      STR      r2,[r1,#0x3c]
        0x0020819a:    e7c1        ..      B        0x208120 ; GPIO_Init + 56
        0x0020819c:    6c8a        .l      LDR      r2,[r1,#0x48]
        0x0020819e:    6800        .h      LDR      r0,[r0,#0]
        0x002081a0:    4382        .C      BICS     r2,r2,r0
        0x002081a2:    648a        .d      STR      r2,[r1,#0x48]
        0x002081a4:    e7e0        ..      B        0x208168 ; GPIO_Init + 128
    GPIO_StructInit
;;;135    
;;;136    /**
;;;137      * @brief    Fills each GPIO_InitStruct member with its default value.
;;;138      * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will
;;;139      *    be initialized.
;;;140      * @retval None
;;;141      */
;;;142    void GPIO_StructInit(GPIO_InitTypeDef *GPIO_InitStruct)
;;;143    {
;;;144        /* Reset GPIO init structure parameters values */
;;;145        GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
        0x002081a6:    f04f31ff    O..1    MOV      r1,#0xffffffff
;;;146        GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
        0x002081aa:    6001        .`      STR      r1,[r0,#0]
        0x002081ac:    2100        .!      MOVS     r1,#0
        0x002081ae:    7101        .q      STRB     r1,[r0,#4]
;;;147        GPIO_InitStruct->GPIO_ITCmd = DISABLE;
        0x002081b0:    7141        Aq      STRB     r1,[r0,#5]
;;;148        GPIO_InitStruct->GPIO_ITTrigger = GPIO_INT_Trigger_LEVEL;
        0x002081b2:    7181        .q      STRB     r1,[r0,#6]
;;;149        GPIO_InitStruct->GPIO_ITPolarity = GPIO_INT_POLARITY_ACTIVE_LOW;
        0x002081b4:    71c1        .q      STRB     r1,[r0,#7]
;;;150        GPIO_InitStruct->GPIO_ITDebounce = GPIO_INT_DEBOUNCE_DISABLE;
        0x002081b6:    7201        .r      STRB     r1,[r0,#8]
;;;151        GPIO_InitStruct->GPIO_ControlMode = GPIO_SOFTWARE_MODE;
        0x002081b8:    7241        Ar      STRB     r1,[r0,#9]
;;;152        GPIO_InitStruct->GPIO_DebounceTime = 20;                 /* ms , can be 1~64 ms */
        0x002081ba:    2114        .!      MOVS     r1,#0x14
        0x002081bc:    60c1        .`      STR      r1,[r0,#0xc]
;;;153    }
        0x002081be:    e7d3        ..      B        0x208168 ; GPIO_Init + 128
    GPIO_INTConfig
;;;154    
;;;155    /**
;;;156      * @brief enable the specified GPIO interrupt.
;;;157      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;158      * @retval None
;;;159      */
;;;160    void GPIO_INTConfig(uint32_t GPIO_Pin, FunctionalState NewState)
;;;161    {
;;;162        /* Check the parameters */
;;;163        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;164        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;165    
;;;166        if (NewState != DISABLE)
;;;167        {
;;;168            /* Enable the selected GPIO pin interrupts */
;;;169            GPIO->INTEN |= GPIO_Pin;
        0x002081c0:    4a26        &J      LDR      r2,[pc,#152] ; [0x20825c] = 0x40001000
        0x002081c2:    2900        .)      CMP      r1,#0
        0x002081c4:    6b11        .k      LDR      r1,[r2,#0x30]
;;; .\..\..\..\src\mcu\peripheral\rtl876x_gpio.c (161)
        0x002081c6:    d001        ..      BEQ      0x2081cc ; GPIO_INTConfig + 12
;;;162        /* Check the parameters */
;;;163        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;164        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;165    
;;;166        if (NewState != DISABLE)
;;;167        {
;;;168            /* Enable the selected GPIO pin interrupts */
;;;169            GPIO->INTEN |= GPIO_Pin;
        0x002081c8:    4301        .C      ORRS     r1,r1,r0
        0x002081ca:    e000        ..      B        0x2081ce ; GPIO_INTConfig + 14
        0x002081cc:    4381        .C      BICS     r1,r1,r0
        0x002081ce:    6311        .c      STR      r1,[r2,#0x30]
;;;170        }
;;;171        else
;;;172        {
;;;173            /* Disable the selected GPIO pin interrupts */
;;;174            GPIO->INTEN &= ~GPIO_Pin;
;;;175        }
;;;176    }
        0x002081d0:    e7ca        ..      B        0x208168 ; GPIO_Init + 128
    GPIO_ClearINTPendingBit
;;;177    
;;;178    /**
;;;179      * @brief clear the specified GPIO interrupt.
;;;180      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;181      * @retval None
;;;182      */
;;;183    void GPIO_ClearINTPendingBit(uint32_t GPIO_Pin)
;;;184    {
;;;185        /* Check the parameters */
;;;186        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;187    
;;;188        GPIO->INTCLR = GPIO_Pin;
        0x002081d2:    4922        "I      LDR      r1,[pc,#136] ; [0x20825c] = 0x40001000
        0x002081d4:    64c8        .d      STR      r0,[r1,#0x4c]
;;;189    }
        0x002081d6:    e7c7        ..      B        0x208168 ; GPIO_Init + 128
    GPIO_MaskINTConfig
;;;190    
;;;191    /**
;;;192      * @brief mask the specified GPIO interrupt.
;;;193      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;194      * @retval None
;;;195      */
;;;196    void GPIO_MaskINTConfig(uint32_t GPIO_Pin, FunctionalState NewState)
;;;197    {
;;;198        /* Check the parameters */
;;;199        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;200        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;201    
;;;202        if (NewState != DISABLE)
;;;203        {
;;;204            GPIO->INTMASK |= GPIO_Pin;
        0x002081d8:    4a20         J      LDR      r2,[pc,#128] ; [0x20825c] = 0x40001000
        0x002081da:    2900        .)      CMP      r1,#0
        0x002081dc:    6b51        Qk      LDR      r1,[r2,#0x34]
;;; .\..\..\..\src\mcu\peripheral\rtl876x_gpio.c (197)
        0x002081de:    d001        ..      BEQ      0x2081e4 ; GPIO_MaskINTConfig + 12
;;;198        /* Check the parameters */
;;;199        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;200        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;201    
;;;202        if (NewState != DISABLE)
;;;203        {
;;;204            GPIO->INTMASK |= GPIO_Pin;
        0x002081e0:    4301        .C      ORRS     r1,r1,r0
        0x002081e2:    e000        ..      B        0x2081e6 ; GPIO_MaskINTConfig + 14
        0x002081e4:    4381        .C      BICS     r1,r1,r0
        0x002081e6:    6351        Qc      STR      r1,[r2,#0x34]
;;;205        }
;;;206        else
;;;207        {
;;;208            GPIO->INTMASK &= ~(GPIO_Pin);
;;;209        }
;;;210    }
        0x002081e8:    e7be        ..      B        0x208168 ; GPIO_Init + 128
    GPIO_GetPin
        0x002081ea:    2101        .!      MOVS     r1,#1
        0x002081ec:    281e        .(      CMP      r0,#0x1e
;;;211    
;;;212    /**
;;;213      * @brief get the specified GPIO pin.
;;;214      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;215      * @retval  GPIO pin for GPIO initialization.
;;;216      */
;;;217    uint32_t GPIO_GetPin(uint8_t Pin_num)
;;;218    {
        0x002081ee:    d90e        ..      BLS      0x20820e ; GPIO_GetPin + 36
;;;219        /* Check the parameters */
;;;220        assert_param(IS_PIN_NUM(Pin_num));
;;;221    
;;;222        if (Pin_num <= P3_6)
;;;223        {
;;;224            return  BIT(Pin_num);
;;;225        }
;;;226        else if ((Pin_num <= P4_3) && (Pin_num >= P4_0))
        0x002081f0:    f1a00220    .. .    SUB      r2,r0,#0x20
        0x002081f4:    2a03        .*      CMP      r2,#3
        0x002081f6:    d801        ..      BHI      0x2081fc ; GPIO_GetPin + 18
        0x002081f8:    1f00        ..      SUBS     r0,r0,#4
;;;227        {
;;;228            return BIT(Pin_num - 4);
        0x002081fa:    e008        ..      B        0x20820e ; GPIO_GetPin + 36
;;;229        }
;;;230        else if ((Pin_num == H_0) || (Pin_num == H_1) || (Pin_num == H_2))
        0x002081fc:    2824        $(      CMP      r0,#0x24
        0x002081fe:    d005        ..      BEQ      0x20820c ; GPIO_GetPin + 34
        0x00208200:    2825        %(      CMP      r0,#0x25
        0x00208202:    d003        ..      BEQ      0x20820c ; GPIO_GetPin + 34
        0x00208204:    2826        &(      CMP      r0,#0x26
        0x00208206:    d001        ..      BEQ      0x20820c ; GPIO_GetPin + 34
        0x00208208:    20ff        .       MOVS     r0,#0xff
        0x0020820a:    e7ad        ..      B        0x208168 ; GPIO_Init + 128
        0x0020820c:    380b        .8      SUBS     r0,r0,#0xb
;;;231        {
;;;232            return BIT(Pin_num - 11);
        0x0020820e:    fa01f000    ....    LSL      r0,r1,r0
;;;233        }
;;;234    
;;;235        return 0xFF;
;;;236    }
        0x00208212:    e7a9        ..      B        0x208168 ; GPIO_Init + 128
    GPIO_GetNum
;;;237    
;;;238    /**
;;;239      * @brief get the specified GPIO pin number.
;;;240      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;241      * @retval  GPIO pin number.
;;;242      */
;;;243    uint8_t GPIO_GetNum(uint8_t Pin_num)
;;;244    {
;;;245        /* Check the parameters */
;;;246        assert_param(IS_PIN_NUM(Pin_num));
;;;247    
;;;248        if (Pin_num <= P3_6)
        0x00208214:    281e        .(      CMP      r0,#0x1e
;;; .\..\..\..\src\mcu\peripheral\rtl876x_gpio.c (244)
        0x00208216:    d9a7        ..      BLS      0x208168 ; GPIO_Init + 128
;;;245        /* Check the parameters */
;;;246        assert_param(IS_PIN_NUM(Pin_num));
;;;247    
;;;248        if (Pin_num <= P3_6)
;;;249        {
;;;250            return (Pin_num);
;;;251        }
;;;252        else if ((Pin_num <= P4_3) && (Pin_num >= P4_0))
        0x00208218:    f1a00120    .. .    SUB      r1,r0,#0x20
        0x0020821c:    2903        .)      CMP      r1,#3
        0x0020821e:    d801        ..      BHI      0x208224 ; GPIO_GetNum + 16
        0x00208220:    1f00        ..      SUBS     r0,r0,#4
;;;253        {
;;;254            return (Pin_num - 4);
        0x00208222:    e008        ..      B        0x208236 ; GPIO_GetNum + 34
;;;255        }
;;;256        else if ((Pin_num == H_0) || (Pin_num == H_1) || (Pin_num == H_2))
        0x00208224:    2824        $(      CMP      r0,#0x24
        0x00208226:    d005        ..      BEQ      0x208234 ; GPIO_GetNum + 32
        0x00208228:    2825        %(      CMP      r0,#0x25
        0x0020822a:    d003        ..      BEQ      0x208234 ; GPIO_GetNum + 32
        0x0020822c:    2826        &(      CMP      r0,#0x26
        0x0020822e:    d001        ..      BEQ      0x208234 ; GPIO_GetNum + 32
        0x00208230:    20ff        .       MOVS     r0,#0xff
        0x00208232:    e799        ..      B        0x208168 ; GPIO_Init + 128
        0x00208234:    380b        .8      SUBS     r0,r0,#0xb
;;;257        {
;;;258            return (Pin_num - 11);
        0x00208236:    b2c0        ..      UXTB     r0,r0
;;;259        }
;;;260    
;;;261        return 0xFF;
;;;262    }
        0x00208238:    e796        ..      B        0x208168 ; GPIO_Init + 128
    GPIO_DBClkCmd
        0x0020823a:    f04f4180    O..A    MOV      r1,#0x40000000
        0x0020823e:    2800        .(      CMP      r0,#0
        0x00208240:    f8d10344    ..D.    LDR      r0,[r1,#0x344]
;;;263    
;;;264    /**
;;;265      * @brief get the specified GPIO pin number.
;;;266      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;267      * @retval  GPIO pin number.
;;;268      */
;;;269    void GPIO_DBClkCmd(FunctionalState NewState)
;;;270    {
        0x00208244:    d002        ..      BEQ      0x20824c ; GPIO_DBClkCmd + 18
;;;271        if (NewState != DISABLE)
;;;272        {
;;;273            GPIO_DBCLK_DIV |= BIT12;
        0x00208246:    f4405080    @..P    ORR      r0,r0,#0x1000
        0x0020824a:    e001        ..      B        0x208250 ; GPIO_DBClkCmd + 22
        0x0020824c:    f4205080     ..P    BIC      r0,r0,#0x1000
        0x00208250:    f8c10344    ..D.    STR      r0,[r1,#0x344]
;;;274        }
;;;275        else
;;;276        {
;;;277            GPIO_DBCLK_DIV &= ~BIT12;
;;;278        }
;;;279    }
        0x00208254:    e788        ..      B        0x208168 ; GPIO_Init + 128
    $d
        0x00208256:    0000        ..      DCW    0
        0x00208258:    0c000100    ....    DCD    201326848
        0x0020825c:    40001000    ...@    DCD    1073745920
    $t
    .text
    simp_ble_client_start_discovery
;;; .\..\..\..\src\ble\profile\client\simple_ble_client.c
;;;45     {
        0x00208260:    b510        ..      PUSH     {r4,lr}
        0x00208262:    4604        .F      MOV      r4,r0
;;;46         PROFILE_PRINT_INFO0("simp_ble_client_start_discovery");
        0x00208264:    2200        ."      MOVS     r2,#0
        0x00208266:    49f9        .I      LDR      r1,[pc,#996] ; [0x20864c] = 0x88000e8
        0x00208268:    48f9        .H      LDR      r0,[pc,#996] ; [0x208650] = 0x21103302
        0x0020826a:    f5fffbf8    ....    BL       log_buffer ; 0x7a5e
;;;47         if (conn_id >= simp_link_num)
        0x0020826e:    48f9        .H      LDR      r0,[pc,#996] ; [0x208654] = 0x20cfa8
        0x00208270:    7801        .x      LDRB     r1,[r0,#0]
        0x00208272:    428c        .B      CMP      r4,r1
        0x00208274:    d308        ..      BCC      0x208288 ; simp_ble_client_start_discovery + 40
;;;48         {
;;;49             PROFILE_PRINT_ERROR1("simp_ble_client_start_discovery: failed invalid conn_id %d", conn_id);
        0x00208276:    49f5        .I      LDR      r1,[pc,#980] ; [0x20864c] = 0x88000e8
        0x00208278:    48f5        .H      LDR      r0,[pc,#980] ; [0x208650] = 0x21103302
        0x0020827a:    4623        #F      MOV      r3,r4
        0x0020827c:    2201        ."      MOVS     r2,#1
        0x0020827e:    3124        $1      ADDS     r1,r1,#0x24
        0x00208280:    1e80        ..      SUBS     r0,r0,#2
        0x00208282:    f5fffbec    ....    BL       log_buffer ; 0x7a5e
;;;50             return false;
        0x00208286:    e00d        ..      B        0x2082a4 ; simp_ble_client_start_discovery + 68
;;;51         }
;;;52         /* First clear handle cache. */
;;;53         //memset(&simp_table[conn_id], 0, sizeof(T_SIMP_LINK));
;;;54         simp_table[conn_id].disc_state = DISC_SIMP_START;
        0x00208288:    6880        .h      LDR      r0,[r0,#8]
        0x0020828a:    eb0402c4    ....    ADD      r2,r4,r4,LSL #3
        0x0020828e:    2101        .!      MOVS     r1,#1
        0x00208290:    f8001012    ....    STRB     r1,[r0,r2,LSL #1]
;;;55         if (client_by_uuid_srv_discovery(conn_id, simp_client,
        0x00208294:    48f0        .H      LDR      r0,[pc,#960] ; [0x208658] = 0x20cf28
        0x00208296:    f64f72e0    O..r    MOV      r2,#0xffe0
        0x0020829a:    7801        .x      LDRB     r1,[r0,#0]
        0x0020829c:    4620         F      MOV      r0,r4
        0x0020829e:    f646f943    F.C.    BL       client_by_uuid_srv_discovery ; 0x4e528
        0x002082a2:    b108        ..      CBZ      r0,0x2082a8 ; simp_ble_client_start_discovery + 72
        0x002082a4:    2000        .       MOVS     r0,#0
        0x002082a6:    bd10        ..      POP      {r4,pc}
;;;56                                          GATT_UUID_SIMPLE_PROFILE) == GAP_CAUSE_SUCCESS)
;;;57         {
;;;58             return true;
        0x002082a8:    2001        .       MOVS     r0,#1
;;;59         }
;;;60         return false;
;;;61     }
        0x002082aa:    bd10        ..      POP      {r4,pc}
    simp_ble_client_read_by_handle
;;;62     
;;;63     /**
;;;64       * @brief  Used by application, to read data from server by using handles.
;;;65       * @param[in]  conn_id connection ID.
;;;66       * @param[in]  read_type one of characteristic that has the readable property.
;;;67       * @retval true send request to upper stack success.
;;;68       * @retval false send request to upper stack failed.
;;;69       */
;;;70     bool simp_ble_client_read_by_handle(uint8_t conn_id, T_SIMP_READ_TYPE read_type)
;;;71     {
        0x002082ac:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x002082b0:    4ae8        .J      LDR      r2,[pc,#928] ; [0x208654] = 0x20cfa8
;;; .\..\..\..\src\ble\profile\client\simple_ble_client.c (71)
        0x002082b2:    4606        .F      MOV      r6,r0
        0x002082b4:    2400        .$      MOVS     r4,#0
        0x002082b6:    7810        .x      LDRB     r0,[r2,#0]
        0x002082b8:    4286        .B      CMP      r6,r0
        0x002082ba:    d306        ..      BCC      0x2082ca ; simp_ble_client_read_by_handle + 30
;;;72         bool hdl_valid = false;
;;;73         uint16_t  handle;
;;;74         if (conn_id >= simp_link_num)
;;;75         {
;;;76             PROFILE_PRINT_ERROR1("simp_ble_client_read_by_handle: failed invalid conn_id %d", conn_id);
        0x002082bc:    49e3        .I      LDR      r1,[pc,#908] ; [0x20864c] = 0x88000e8
        0x002082be:    48e4        .H      LDR      r0,[pc,#912] ; [0x208650] = 0x21103302
        0x002082c0:    2201        ."      MOVS     r2,#1
        0x002082c2:    3164        d1      ADDS     r1,r1,#0x64
        0x002082c4:    4633        3F      MOV      r3,r6
        0x002082c6:    1e80        ..      SUBS     r0,r0,#2
        0x002082c8:    e00b        ..      B        0x2082e2 ; simp_ble_client_read_by_handle + 54
        0x002082ca:    48e4        .H      LDR      r0,[pc,#912] ; [0x20865c] = 0x21103002
        0x002082cc:    eb0603c6    ....    ADD      r3,r6,r6,LSL #3
        0x002082d0:    b151        Q.      CBZ      r1,0x2082e8 ; simp_ble_client_read_by_handle + 60
        0x002082d2:    2901        .)      CMP      r1,#1
        0x002082d4:    d00d        ..      BEQ      0x2082f2 ; simp_ble_client_read_by_handle + 70
        0x002082d6:    2902        .)      CMP      r1,#2
        0x002082d8:    d010        ..      BEQ      0x2082fc ; simp_ble_client_read_by_handle + 80
        0x002082da:    460b        .F      MOV      r3,r1
        0x002082dc:    49db        .I      LDR      r1,[pc,#876] ; [0x20864c] = 0x88000e8
        0x002082de:    2201        ."      MOVS     r2,#1
        0x002082e0:    31a4        .1      ADDS     r1,r1,#0xa4
        0x002082e2:    f5fffbbc    ....    BL       log_buffer ; 0x7a5e
        0x002082e6:    e02c        ,.      B        0x208342 ; simp_ble_client_read_by_handle + 150
;;;77             return false;
;;;78         }
;;;79     
;;;80         switch (read_type)
;;;81         {
;;;82         case SIMP_READ_V1_READ:
;;;83             if (simp_table[conn_id].hdl_cache[HDL_SIMBLE_V1_READ])
        0x002082e8:    6892        .h      LDR      r2,[r2,#8]
        0x002082ea:    eb020243    ..C.    ADD      r2,r2,r3,LSL #1
        0x002082ee:    88d2        ..      LDRH     r2,[r2,#6]
        0x002082f0:    e008        ..      B        0x208304 ; simp_ble_client_read_by_handle + 88
;;;84             {
;;;85                 handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_V1_READ];
;;;86                 hdl_valid = true;
;;;87             }
;;;88             break;
;;;89         case SIMP_READ_V3_NOTIFY_CCCD:
;;;90             if (simp_table[conn_id].hdl_cache[HDL_SIMBLE_V3_NOTIFY_CCCD])
        0x002082f2:    6892        .h      LDR      r2,[r2,#8]
        0x002082f4:    eb020243    ..C.    ADD      r2,r2,r3,LSL #1
        0x002082f8:    8992        ..      LDRH     r2,[r2,#0xc]
        0x002082fa:    e003        ..      B        0x208304 ; simp_ble_client_read_by_handle + 88
;;;91             {
;;;92                 handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_V3_NOTIFY_CCCD];
;;;93                 hdl_valid = true;
;;;94             }
;;;95             break;
;;;96         case SIMP_READ_V4_INDICATE_CCCD:
;;;97             if (simp_table[conn_id].hdl_cache[HDL_SIMBLE_V4_INDICATE_CCCD])
        0x002082fc:    6892        .h      LDR      r2,[r2,#8]
        0x002082fe:    eb020243    ..C.    ADD      r2,r2,r3,LSL #1
        0x00208302:    8a12        ..      LDRH     r2,[r2,#0x10]
        0x00208304:    b10a        ..      CBZ      r2,0x20830a ; simp_ble_client_read_by_handle + 94
;;;98             {
;;;99                 handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_V4_INDICATE_CCCD];
        0x00208306:    4615        .F      MOV      r5,r2
;;;100                hdl_valid = true;
        0x00208308:    2401        .$      MOVS     r4,#1
;;;101            }
;;;102            break;
;;;103    
;;;104        default:
;;;105    		APP_PRINT_INFO1("vsop----read_by_handle------return=%d",read_type); 		
;;;106            return false;
;;;107        }
;;;108    	APP_PRINT_INFO1("vsop----read_by_handle------read_type=%d",read_type); 
        0x0020830a:    460b        .F      MOV      r3,r1
        0x0020830c:    49cf        .I      LDR      r1,[pc,#828] ; [0x20864c] = 0x88000e8
        0x0020830e:    2201        ."      MOVS     r2,#1
        0x00208310:    31d0        .1      ADDS     r1,r1,#0xd0
        0x00208312:    4607        .F      MOV      r7,r0
        0x00208314:    f5fffba3    ....    BL       log_buffer ; 0x7a5e
;;;109    
;;;110        if (hdl_valid)
        0x00208318:    b16c        l.      CBZ      r4,0x208336 ; simp_ble_client_read_by_handle + 138
;;;111        {
;;;112        	APP_PRINT_INFO1("vsop----read_by_handle------hdl_valid=%d",hdl_valid); 
        0x0020831a:    49cc        .I      LDR      r1,[pc,#816] ; [0x20864c] = 0x88000e8
        0x0020831c:    4623        #F      MOV      r3,r4
        0x0020831e:    2201        ."      MOVS     r2,#1
        0x00208320:    31fc        .1      ADDS     r1,r1,#0xfc
        0x00208322:    4638        8F      MOV      r0,r7
        0x00208324:    f5fffb9b    ....    BL       log_buffer ; 0x7a5e
;;;113            if (client_attr_read(conn_id, simp_client, handle) == GAP_CAUSE_SUCCESS)
        0x00208328:    48cb        .H      LDR      r0,[pc,#812] ; [0x208658] = 0x20cf28
        0x0020832a:    462a        *F      MOV      r2,r5
        0x0020832c:    7801        .x      LDRB     r1,[r0,#0]
        0x0020832e:    4630        0F      MOV      r0,r6
        0x00208330:    f646f9bf    F...    BL       client_attr_read ; 0x4e6b2
        0x00208334:    b140        @.      CBZ      r0,0x208348 ; simp_ble_client_read_by_handle + 156
        0x00208336:    48c9        .H      LDR      r0,[pc,#804] ; [0x20865c] = 0x21103002
        0x00208338:    2200        ."      MOVS     r2,#0
        0x0020833a:    49c9        .I      LDR      r1,[pc,#804] ; [0x208660] = 0x880023c
        0x0020833c:    1e40        @.      SUBS     r0,r0,#1
        0x0020833e:    f5fffb8e    ....    BL       log_buffer ; 0x7a5e
        0x00208342:    2000        .       MOVS     r0,#0
        0x00208344:    e8bd81f0    ....    POP      {r4-r8,pc}
;;;114            {
;;;115               	APP_PRINT_INFO1("vsop----read_by_handle------okkkkk=%d",hdl_valid); 
        0x00208348:    49c5        .I      LDR      r1,[pc,#788] ; [0x208660] = 0x880023c
        0x0020834a:    4623        #F      MOV      r3,r4
        0x0020834c:    2201        ."      MOVS     r2,#1
        0x0020834e:    392c        ,9      SUBS     r1,r1,#0x2c
        0x00208350:    4638        8F      MOV      r0,r7
        0x00208352:    f5fffb84    ....    BL       log_buffer ; 0x7a5e
;;;116                return true;
        0x00208356:    2001        .       MOVS     r0,#1
;;;117            }
;;;118        }
;;;119    
;;;120        APP_PRINT_WARN0("simp_ble_client_read_by_handle: Request fail! Please check!");
;;;121        return false;
;;;122    }
        0x00208358:    e7f4        ..      B        0x208344 ; simp_ble_client_read_by_handle + 152
    simp_ble_client_read_by_uuid
;;;123    
;;;124    /**
;;;125      * @brief  Used by application, to read data from server by using UUIDs.
;;;126      * @param[in]  conn_id connection ID.
;;;127      * @param[in]  read_type one of characteristic that has the readable property.
;;;128      * @retval true send request to upper stack success.
;;;129      * @retval false send request to upper stack failed.
;;;130      */
;;;131    bool simp_ble_client_read_by_uuid(uint8_t conn_id, T_SIMP_READ_TYPE read_type)
;;;132    {
        0x0020835a:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x0020835e:    4fbd        .O      LDR      r7,[pc,#756] ; [0x208654] = 0x20cfa8
        0x00208360:    4606        .F      MOV      r6,r0
        0x00208362:    460d        .F      MOV      r5,r1
        0x00208364:    7838        8x      LDRB     r0,[r7,#0]
        0x00208366:    4286        .B      CMP      r6,r0
        0x00208368:    d308        ..      BCC      0x20837c ; simp_ble_client_read_by_uuid + 34
;;;133        uint16_t start_handle;
;;;134        uint16_t end_handle;
;;;135        uint16_t  uuid16;
;;;136        if (conn_id >= simp_link_num)
;;;137        {
;;;138            PROFILE_PRINT_ERROR1("simp_ble_client_read_by_uuid: failed invalid conn_id %d", conn_id);
        0x0020836a:    49bd        .I      LDR      r1,[pc,#756] ; [0x208660] = 0x880023c
        0x0020836c:    48b8        .H      LDR      r0,[pc,#736] ; [0x208650] = 0x21103302
        0x0020836e:    4633        3F      MOV      r3,r6
        0x00208370:    2201        ."      MOVS     r2,#1
        0x00208372:    3140        @1      ADDS     r1,r1,#0x40
        0x00208374:    1e80        ..      SUBS     r0,r0,#2
        0x00208376:    f5fffb72    ..r.    BL       log_buffer ; 0x7a5e
;;;139            return false;
        0x0020837a:    e036        6.      B        0x2083ea ; simp_ble_client_read_by_uuid + 144
;;;140        }
;;;141    	APP_PRINT_INFO1("vsop----read_by_uuid------read_type=%d",read_type); 
        0x0020837c:    460b        .F      MOV      r3,r1
        0x0020837e:    49b8        .I      LDR      r1,[pc,#736] ; [0x208660] = 0x880023c
        0x00208380:    f8df82d8    ....    LDR      r8,[pc,#728] ; [0x20865c] = 0x21103002
        0x00208384:    2201        ."      MOVS     r2,#1
        0x00208386:    317c        |1      ADDS     r1,r1,#0x7c
        0x00208388:    4640        @F      MOV      r0,r8
        0x0020838a:    f5fffb68    ..h.    BL       log_buffer ; 0x7a5e
        0x0020838e:    eb0600c6    ....    ADD      r0,r6,r6,LSL #3
;;;142    
;;;143        switch (read_type)
        0x00208392:    b135        5.      CBZ      r5,0x2083a2 ; simp_ble_client_read_by_uuid + 72
        0x00208394:    f6421402    B...    MOV      r4,#0x2902
        0x00208398:    2d01        .-      CMP      r5,#1
        0x0020839a:    d00a        ..      BEQ      0x2083b2 ; simp_ble_client_read_by_uuid + 88
        0x0020839c:    2d02        .-      CMP      r5,#2
        0x0020839e:    d124        $.      BNE      0x2083ea ; simp_ble_client_read_by_uuid + 144
        0x002083a0:    e013        ..      B        0x2083ca ; simp_ble_client_read_by_uuid + 112
;;;144        {
;;;145        case SIMP_READ_V1_READ:
;;;146            start_handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_SRV_START];
        0x002083a2:    68b9        .h      LDR      r1,[r7,#8]
        0x002083a4:    f64f74e5    O..t    MOV      r4,#0xffe5
        0x002083a8:    eb010040    ..@.    ADD      r0,r1,r0,LSL #1
        0x002083ac:    8847        G.      LDRH     r7,[r0,#2]
;;;147            end_handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_SRV_END];
        0x002083ae:    8885        ..      LDRH     r5,[r0,#4]
;;;148            uuid16 = GATT_UUID_CHAR_SIMPLE_V1_READ;
;;;149            break;
        0x002083b0:    e010        ..      B        0x2083d4 ; simp_ble_client_read_by_uuid + 122
;;;150        case SIMP_READ_V3_NOTIFY_CCCD:
;;;151            start_handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_V3_NOTIFY];
        0x002083b2:    68b9        .h      LDR      r1,[r7,#8]
        0x002083b4:    2200        ."      MOVS     r2,#0
        0x002083b6:    eb010040    ..@.    ADD      r0,r1,r0,LSL #1
        0x002083ba:    49a9        .I      LDR      r1,[pc,#676] ; [0x208660] = 0x880023c
        0x002083bc:    8947        G.      LDRH     r7,[r0,#0xa]
;;;152            end_handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_V4_INDICATE];
        0x002083be:    89c5        ..      LDRH     r5,[r0,#0xe]
;;;153            uuid16 = GATT_UUID_CHAR_CLIENT_CONFIG;
;;;154       		APP_PRINT_INFO0("vsop----read_by_uuid------ SIMP_READ_V3_NOTIFY_CCCD");		 
        0x002083c0:    31a8        .1      ADDS     r1,r1,#0xa8
        0x002083c2:    4640        @F      MOV      r0,r8
        0x002083c4:    f5fffb4b    ..K.    BL       log_buffer ; 0x7a5e
;;;155            break;
        0x002083c8:    e004        ..      B        0x2083d4 ; simp_ble_client_read_by_uuid + 122
;;;156        case SIMP_READ_V4_INDICATE_CCCD:
;;;157            start_handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_V4_INDICATE];
        0x002083ca:    68b9        .h      LDR      r1,[r7,#8]
        0x002083cc:    eb010040    ..@.    ADD      r0,r1,r0,LSL #1
        0x002083d0:    89c7        ..      LDRH     r7,[r0,#0xe]
;;;158            end_handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_SRV_END];
        0x002083d2:    8885        ..      LDRH     r5,[r0,#4]
;;;159            uuid16 = GATT_UUID_CHAR_CLIENT_CONFIG;
;;;160            break;
;;;161        default:
;;;162            return false;
;;;163        }
;;;164    
;;;165        if (client_attr_read_using_uuid(conn_id, simp_client, start_handle, end_handle,
        0x002083d4:    2000        .       MOVS     r0,#0
        0x002083d6:    e9cd4000    ...@    STRD     r4,r0,[sp,#0]
        0x002083da:    489f        .H      LDR      r0,[pc,#636] ; [0x208658] = 0x20cf28
        0x002083dc:    462b        +F      MOV      r3,r5
        0x002083de:    463a        :F      MOV      r2,r7
        0x002083e0:    7801        .x      LDRB     r1,[r0,#0]
        0x002083e2:    4630        0F      MOV      r0,r6
        0x002083e4:    f646f992    F...    BL       client_attr_read_using_uuid ; 0x4e70c
        0x002083e8:    b110        ..      CBZ      r0,0x2083f0 ; simp_ble_client_read_by_uuid + 150
        0x002083ea:    2000        .       MOVS     r0,#0
        0x002083ec:    e8bd81fc    ....    POP      {r2-r8,pc}
;;;166                                        uuid16, NULL) == GAP_CAUSE_SUCCESS)
;;;167        {
;;;168            return true;
        0x002083f0:    2001        .       MOVS     r0,#1
;;;169        }
;;;170        return false;
;;;171    }
        0x002083f2:    e7fb        ..      B        0x2083ec ; simp_ble_client_read_by_uuid + 146
    simp_ble_client_set_v3_notify
;;;172    
;;;173    /**
;;;174      * @brief  Used by application, to enable or disable the notification of peer server's V3 Notify Characteristic.
;;;175      * @param[in]  conn_id connection ID.
;;;176      * @param[in]  notify 0--disable the notification, 1--enable the notification.
;;;177      * @retval true send request to upper stack success.
;;;178      * @retval false send request to upper stack failed.
;;;179      */
;;;180    bool simp_ble_client_set_v3_notify(uint8_t conn_id, bool notify)
;;;181    {
        0x002083f4:    b5fe        ..      PUSH     {r1-r7,lr}
        0x002083f6:    4f97        .O      LDR      r7,[pc,#604] ; [0x208654] = 0x20cfa8
;;; .\..\..\..\src\ble\profile\client\simple_ble_client.c (181)
        0x002083f8:    4604        .F      MOV      r4,r0
        0x002083fa:    460e        .F      MOV      r6,r1
        0x002083fc:    7838        8x      LDRB     r0,[r7,#0]
        0x002083fe:    4284        .B      CMP      r4,r0
        0x00208400:    d308        ..      BCC      0x208414 ; simp_ble_client_set_v3_notify + 32
;;;182    #if 0
;;;183        if (conn_id >= simp_link_num)
;;;184        {
;;;185            PROFILE_PRINT_ERROR1("simp_ble_client_set_v3_notify: failed invalid conn_id %d", conn_id);
;;;186            return false;
;;;187        }
;;;188    	APP_PRINT_INFO0("vsop----simp_ble_client_set_v3_notify enter");	
;;;189    
;;;190        if (simp_table[conn_id].hdl_cache[HDL_SIMBLE_V3_NOTIFY_CCCD])
;;;191        {
;;;192            uint16_t handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_V3_NOTIFY_CCCD];
;;;193            uint16_t length = sizeof(uint16_t);
;;;194            uint16_t cccd_bits = notify ? 1 : 0;
;;;195            if (client_attr_write(conn_id, simp_client, GATT_WRITE_TYPE_REQ, handle,
;;;196                                  length, (uint8_t *)&cccd_bits) == GAP_CAUSE_SUCCESS)
;;;197            {
;;;198            	APP_PRINT_INFO0("vsop----simp_ble_client_set_v3_notify enter---write fail");	
;;;199                return true;
;;;200            }
;;;201        }
;;;202    
;;;203        APP_PRINT_WARN0("simp_ble_client_set_v3_notify: Request fail! Please check!");
;;;204        return false;
;;;205    #else
;;;206    	if (conn_id >= simp_link_num)
;;;207    	{
;;;208    		PROFILE_PRINT_ERROR1("simp_ble_client_set_v3_notify: failed invalid conn_id %d", conn_id);
        0x00208402:    4997        .I      LDR      r1,[pc,#604] ; [0x208660] = 0x880023c
        0x00208404:    4892        .H      LDR      r0,[pc,#584] ; [0x208650] = 0x21103302
        0x00208406:    4623        #F      MOV      r3,r4
        0x00208408:    2201        ."      MOVS     r2,#1
        0x0020840a:    31e0        .1      ADDS     r1,r1,#0xe0
        0x0020840c:    1e80        ..      SUBS     r0,r0,#2
        0x0020840e:    f5fffb26    ..&.    BL       log_buffer ; 0x7a5e
;;;209    		return false;
        0x00208412:    e024        $.      B        0x20845e ; simp_ble_client_set_v3_notify + 106
;;;210    	}
;;;211    	APP_PRINT_INFO1("vsop----simp_ble_client_set_v3_notify =	0x%02X",simp_table[conn_id].hdl_cache[HDL_SIMBLE_V4_INDICATE_CCCD]);	
        0x00208414:    68b8        .h      LDR      r0,[r7,#8]
        0x00208416:    eb0405c4    ....    ADD      r5,r4,r4,LSL #3
        0x0020841a:    eb000045    ..E.    ADD      r0,r0,r5,LSL #1
        0x0020841e:    2201        ."      MOVS     r2,#1
        0x00208420:    8a03        ..      LDRH     r3,[r0,#0x10]
        0x00208422:    4990        .I      LDR      r1,[pc,#576] ; [0x208664] = 0x8800358
        0x00208424:    488d        .H      LDR      r0,[pc,#564] ; [0x20865c] = 0x21103002
        0x00208426:    f5fffb1a    ....    BL       log_buffer ; 0x7a5e
;;;212    
;;;213    	if (simp_table[conn_id].hdl_cache[HDL_SIMBLE_V4_INDICATE_CCCD])
        0x0020842a:    68b8        .h      LDR      r0,[r7,#8]
        0x0020842c:    eb000045    ..E.    ADD      r0,r0,r5,LSL #1
        0x00208430:    8a01        ..      LDRH     r1,[r0,#0x10]
        0x00208432:    b169        i.      CBZ      r1,0x208450 ; simp_ble_client_set_v3_notify + 92
;;;214    	{
;;;215    		uint16_t handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_V4_INDICATE_CCCD]; 
        0x00208434:    b28b        ..      UXTH     r3,r1
;;;216    		uint16_t length = sizeof(uint16_t);
        0x00208436:    2002        .       MOVS     r0,#2
        0x00208438:    a902        ..      ADD      r1,sp,#8
        0x0020843a:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0020843e:    4886        .H      LDR      r0,[pc,#536] ; [0x208658] = 0x20cf28
;;;217    		uint16_t cccd_bits = notify ? 1 : 0; 
        0x00208440:    f8ad6008    ...`    STRH     r6,[sp,#8]
;;;218    		if (client_attr_write(conn_id, simp_client, GATT_WRITE_TYPE_REQ, handle,
        0x00208444:    2201        ."      MOVS     r2,#1
        0x00208446:    7801        .x      LDRB     r1,[r0,#0]
        0x00208448:    4620         F      MOV      r0,r4
        0x0020844a:    f646fa29    F.).    BL       client_attr_write ; 0x4e8a0
        0x0020844e:    b140        @.      CBZ      r0,0x208462 ; simp_ble_client_set_v3_notify + 110
;;;219    							  length, (uint8_t *)&cccd_bits) == GAP_CAUSE_SUCCESS)
;;;220    		{
;;;221    			return true;
;;;222    		}
;;;223    	}
;;;224    
;;;225    	APP_PRINT_WARN0("simp_ble_client_set_v3_notify: Request fail! Please check!");
        0x00208450:    4984        .I      LDR      r1,[pc,#528] ; [0x208664] = 0x8800358
        0x00208452:    4882        .H      LDR      r0,[pc,#520] ; [0x20865c] = 0x21103002
        0x00208454:    2200        ."      MOVS     r2,#0
        0x00208456:    3134        41      ADDS     r1,r1,#0x34
        0x00208458:    1e40        @.      SUBS     r0,r0,#1
        0x0020845a:    f5fffb00    ....    BL       log_buffer ; 0x7a5e
;;;226    	return false;
        0x0020845e:    2000        .       MOVS     r0,#0
;;;227    
;;;228    #endif
;;;229    }
        0x00208460:    bdfe        ..      POP      {r1-r7,pc}
        0x00208462:    2001        .       MOVS     r0,#1
        0x00208464:    bdfe        ..      POP      {r1-r7,pc}
    simp_ble_client_set_v4_ind
;;;230    
;;;231    /**
;;;232      * @brief  Used by application, to enable or disable the indication of peer server's V4 Indicate Characteristic.
;;;233      * @param[in]  conn_id connection ID.
;;;234      * @param[in]  ind 0--disable the indication, 1--enable the indication.
;;;235      * @retval true send request to upper stack success.
;;;236      * @retval false send request to upper stack failed.
;;;237      */
;;;238    bool simp_ble_client_set_v4_ind(uint8_t conn_id, bool ind)
;;;239    {
        0x00208466:    b5fe        ..      PUSH     {r1-r7,lr}
        0x00208468:    4f7a        zO      LDR      r7,[pc,#488] ; [0x208654] = 0x20cfa8
        0x0020846a:    4604        .F      MOV      r4,r0
        0x0020846c:    460e        .F      MOV      r6,r1
        0x0020846e:    7838        8x      LDRB     r0,[r7,#0]
        0x00208470:    4284        .B      CMP      r4,r0
        0x00208472:    d308        ..      BCC      0x208486 ; simp_ble_client_set_v4_ind + 32
;;;240        if (conn_id >= simp_link_num)
;;;241        {
;;;242            PROFILE_PRINT_ERROR1("simp_ble_client_set_v4_ind: failed invalid conn_id %d", conn_id);
        0x00208474:    497b        {I      LDR      r1,[pc,#492] ; [0x208664] = 0x8800358
        0x00208476:    4876        vH      LDR      r0,[pc,#472] ; [0x208650] = 0x21103302
        0x00208478:    4623        #F      MOV      r3,r4
        0x0020847a:    2201        ."      MOVS     r2,#1
        0x0020847c:    3174        t1      ADDS     r1,r1,#0x74
        0x0020847e:    1e80        ..      SUBS     r0,r0,#2
        0x00208480:    f5fffaed    ....    BL       log_buffer ; 0x7a5e
;;;243            return false;
        0x00208484:    e029        ).      B        0x2084da ; simp_ble_client_set_v4_ind + 116
;;;244        }
;;;245    	APP_PRINT_INFO1("vsop----HDL_SIMBLE_V4_INDICATE_CCCD =  0x%02X",simp_table[conn_id].hdl_cache[HDL_SIMBLE_V4_INDICATE_CCCD]);	
        0x00208486:    68b8        .h      LDR      r0,[r7,#8]
        0x00208488:    eb0405c4    ....    ADD      r5,r4,r4,LSL #3
        0x0020848c:    eb000045    ..E.    ADD      r0,r0,r5,LSL #1
        0x00208490:    4974        tI      LDR      r1,[pc,#464] ; [0x208664] = 0x8800358
        0x00208492:    8a03        ..      LDRH     r3,[r0,#0x10]
        0x00208494:    2201        ."      MOVS     r2,#1
        0x00208496:    31b0        .1      ADDS     r1,r1,#0xb0
        0x00208498:    4870        pH      LDR      r0,[pc,#448] ; [0x20865c] = 0x21103002
        0x0020849a:    f5fffae0    ....    BL       log_buffer ; 0x7a5e
;;;246    
;;;247        if (simp_table[conn_id].hdl_cache[HDL_SIMBLE_V4_INDICATE_CCCD])
        0x0020849e:    68b8        .h      LDR      r0,[r7,#8]
        0x002084a0:    eb000045    ..E.    ADD      r0,r0,r5,LSL #1
        0x002084a4:    8a01        ..      LDRH     r1,[r0,#0x10]
        0x002084a6:    b189        ..      CBZ      r1,0x2084cc ; simp_ble_client_set_v4_ind + 102
;;;248        {
;;;249            uint16_t handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_V4_INDICATE_CCCD]; 
        0x002084a8:    b28b        ..      UXTH     r3,r1
;;;250            uint16_t length = sizeof(uint16_t);
        0x002084aa:    2102        .!      MOVS     r1,#2
;;;251            uint16_t cccd_bits = ind ? 2 : 0;
        0x002084ac:    b10e        ..      CBZ      r6,0x2084b2 ; simp_ble_client_set_v4_ind + 76
        0x002084ae:    2002        .       MOVS     r0,#2
        0x002084b0:    e000        ..      B        0x2084b4 ; simp_ble_client_set_v4_ind + 78
        0x002084b2:    2000        .       MOVS     r0,#0
        0x002084b4:    f8ad0008    ....    STRH     r0,[sp,#8]
;;;252            if (client_attr_write(conn_id, simp_client, GATT_WRITE_TYPE_REQ, handle,
        0x002084b8:    a802        ..      ADD      r0,sp,#8
        0x002084ba:    e9cd1000    ....    STRD     r1,r0,[sp,#0]
        0x002084be:    4866        fH      LDR      r0,[pc,#408] ; [0x208658] = 0x20cf28
        0x002084c0:    2201        ."      MOVS     r2,#1
        0x002084c2:    7801        .x      LDRB     r1,[r0,#0]
        0x002084c4:    4620         F      MOV      r0,r4
        0x002084c6:    f646f9eb    F...    BL       client_attr_write ; 0x4e8a0
        0x002084ca:    b140        @.      CBZ      r0,0x2084de ; simp_ble_client_set_v4_ind + 120
;;;253                                  length, (uint8_t *)&cccd_bits) == GAP_CAUSE_SUCCESS)
;;;254            {
;;;255                return true;
;;;256            }
;;;257        }
;;;258    
;;;259        APP_PRINT_WARN0("simp_ble_client_set_v4_ind: Request fail! Please check!");
        0x002084cc:    4965        eI      LDR      r1,[pc,#404] ; [0x208664] = 0x8800358
        0x002084ce:    4863        cH      LDR      r0,[pc,#396] ; [0x20865c] = 0x21103002
        0x002084d0:    2200        ."      MOVS     r2,#0
        0x002084d2:    31e4        .1      ADDS     r1,r1,#0xe4
        0x002084d4:    1e40        @.      SUBS     r0,r0,#1
        0x002084d6:    f5fffac2    ....    BL       log_buffer ; 0x7a5e
;;;260        return false;
        0x002084da:    2000        .       MOVS     r0,#0
;;;261    }
        0x002084dc:    bdfe        ..      POP      {r1-r7,pc}
        0x002084de:    2001        .       MOVS     r0,#1
        0x002084e0:    bdfe        ..      POP      {r1-r7,pc}
    simp_ble_client_write_v2_char
;;;262    
;;;263    /**
;;;264      * @brief  Used by application, to write data of V2 write Characteristic.
;;;265      * @param[in]  conn_id connection ID.
;;;266      * @param[in]  length  write data length
;;;267      * @param[in]  p_value point the value to write
;;;268      * @param[in]  type    write type.
;;;269      * @retval true send request to upper stack success.
;;;270      * @retval false send request to upper stack failed.
;;;271      */
;;;272    bool simp_ble_client_write_v2_char(uint8_t conn_id, uint16_t length, uint8_t *p_value,
;;;273                                       T_GATT_WRITE_TYPE type)
;;;274    {
        0x002084e2:    b57c        |.      PUSH     {r2-r6,lr}
        0x002084e4:    4615        .F      MOV      r5,r2
        0x002084e6:    4a5b        [J      LDR      r2,[pc,#364] ; [0x208654] = 0x20cfa8
        0x002084e8:    461c        .F      MOV      r4,r3
        0x002084ea:    7813        .x      LDRB     r3,[r2,#0]
        0x002084ec:    4298        .B      CMP      r0,r3
        0x002084ee:    d307        ..      BCC      0x208500 ; simp_ble_client_write_v2_char + 30
;;;275        if (conn_id >= simp_link_num)
;;;276        {
;;;277            PROFILE_PRINT_ERROR1("simp_ble_client_write_v2_char: failed invalid conn_id %d", conn_id);
        0x002084f0:    4603        .F      MOV      r3,r0
        0x002084f2:    4857        WH      LDR      r0,[pc,#348] ; [0x208650] = 0x21103302
        0x002084f4:    2201        ."      MOVS     r2,#1
        0x002084f6:    495c        \I      LDR      r1,[pc,#368] ; [0x208668] = 0x8800478
        0x002084f8:    1e80        ..      SUBS     r0,r0,#2
        0x002084fa:    f5fffab0    ....    BL       log_buffer ; 0x7a5e
;;;278            return false;
        0x002084fe:    e015        ..      B        0x20852c ; simp_ble_client_write_v2_char + 74
;;;279        }
;;;280        if (simp_table[conn_id].hdl_cache[HDL_SIMBLE_V2_WRITE])
        0x00208500:    6892        .h      LDR      r2,[r2,#8]
        0x00208502:    eb0003c0    ....    ADD      r3,r0,r0,LSL #3
        0x00208506:    eb020243    ..C.    ADD      r2,r2,r3,LSL #1
        0x0020850a:    8913        ..      LDRH     r3,[r2,#8]
        0x0020850c:    b13b        ;.      CBZ      r3,0x20851e ; simp_ble_client_write_v2_char + 60
;;;281        {
;;;282            uint16_t handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_V2_WRITE];
;;;283            if (client_attr_write(conn_id, simp_client, type, handle,
        0x0020850e:    e9cd1500    ....    STRD     r1,r5,[sp,#0]
        0x00208512:    4951        QI      LDR      r1,[pc,#324] ; [0x208658] = 0x20cf28
        0x00208514:    4622        "F      MOV      r2,r4
        0x00208516:    7809        .x      LDRB     r1,[r1,#0]
        0x00208518:    f646f9c2    F...    BL       client_attr_write ; 0x4e8a0
        0x0020851c:    b140        @.      CBZ      r0,0x208530 ; simp_ble_client_write_v2_char + 78
;;;284                                  length, p_value) == GAP_CAUSE_SUCCESS)
;;;285            {
;;;286                return true;
;;;287            }
;;;288        }
;;;289    
;;;290        APP_PRINT_WARN0("simp_ble_client_write_v2_char: Request fail! Please check!");
        0x0020851e:    4952        RI      LDR      r1,[pc,#328] ; [0x208668] = 0x8800478
        0x00208520:    484e        NH      LDR      r0,[pc,#312] ; [0x20865c] = 0x21103002
        0x00208522:    2200        ."      MOVS     r2,#0
        0x00208524:    313c        <1      ADDS     r1,r1,#0x3c
        0x00208526:    1e40        @.      SUBS     r0,r0,#1
        0x00208528:    f5fffa99    ....    BL       log_buffer ; 0x7a5e
;;;291        return false;
        0x0020852c:    2000        .       MOVS     r0,#0
;;;292    }
        0x0020852e:    bd7c        |.      POP      {r2-r6,pc}
        0x00208530:    2001        .       MOVS     r0,#1
        0x00208532:    bd7c        |.      POP      {r2-r6,pc}
    simp_ble_client_get_hdl_cache
;;;293    
;;;294    /**
;;;295      * @brief  Used by application, to get handle cache.
;;;296      * @param[in]  conn_id connection ID.
;;;297      * @param[in]  p_hdl_cache pointer of the handle cache table
;;;298      * @param[in]  len the length of handle cache table
;;;299      * @retval true success.
;;;300      * @retval false failed.
;;;301      */
;;;302    bool simp_ble_client_get_hdl_cache(uint8_t conn_id, uint16_t *p_hdl_cache, uint8_t len)
;;;303    {
        0x00208534:    b570        p.      PUSH     {r4-r6,lr}
        0x00208536:    460e        .F      MOV      r6,r1
;;;304        if (conn_id >= simp_link_num)
        0x00208538:    4946        FI      LDR      r1,[pc,#280] ; [0x208654] = 0x20cfa8
        0x0020853a:    4d45        EM      LDR      r5,[pc,#276] ; [0x208650] = 0x21103302
        0x0020853c:    780b        .x      LDRB     r3,[r1,#0]
        0x0020853e:    1ead        ..      SUBS     r5,r5,#2
        0x00208540:    4298        .B      CMP      r0,r3
        0x00208542:    d304        ..      BCC      0x20854e ; simp_ble_client_get_hdl_cache + 26
;;;305        {
;;;306            PROFILE_PRINT_ERROR1("simp_ble_client_get_hdl_cache: failed invalid conn_id %d", conn_id);
        0x00208544:    4948        HI      LDR      r1,[pc,#288] ; [0x208668] = 0x8800478
        0x00208546:    2201        ."      MOVS     r2,#1
        0x00208548:    4603        .F      MOV      r3,r0
        0x0020854a:    317c        |1      ADDS     r1,r1,#0x7c
;;;307            return false;
        0x0020854c:    e011        ..      B        0x208572 ; simp_ble_client_get_hdl_cache + 62
;;;308        }
;;;309        if (simp_table[conn_id].disc_state != DISC_SIMP_DONE)
        0x0020854e:    688b        .h      LDR      r3,[r1,#8]
        0x00208550:    eb0000c0    ....    ADD      r0,r0,r0,LSL #3
        0x00208554:    f8134010    ...@    LDRB     r4,[r3,r0,LSL #1]
        0x00208558:    2c02        .,      CMP      r4,#2
        0x0020855a:    d004        ..      BEQ      0x208566 ; simp_ble_client_get_hdl_cache + 50
        0x0020855c:    4942        BI      LDR      r1,[pc,#264] ; [0x208668] = 0x8800478
        0x0020855e:    2201        ."      MOVS     r2,#1
        0x00208560:    4623        #F      MOV      r3,r4
;;;310        {
;;;311            PROFILE_PRINT_ERROR1("simp_ble_client_get_hdl_cache: failed invalid state %d",
        0x00208562:    31b8        .1      ADDS     r1,r1,#0xb8
;;;312                                 simp_table[conn_id].disc_state);
;;;313            return false;
        0x00208564:    e005        ..      B        0x208572 ; simp_ble_client_get_hdl_cache + 62
;;;314        }
;;;315        if (len != sizeof(uint16_t) * HDL_SIMBLE_CACHE_LEN)
        0x00208566:    2a10        .*      CMP      r2,#0x10
        0x00208568:    d008        ..      BEQ      0x20857c ; simp_ble_client_get_hdl_cache + 72
;;;316        {
;;;317            PROFILE_PRINT_ERROR1("simp_ble_client_get_hdl_cache: failed invalid len %d", len);
        0x0020856a:    4613        .F      MOV      r3,r2
        0x0020856c:    493e        >I      LDR      r1,[pc,#248] ; [0x208668] = 0x8800478
        0x0020856e:    2201        ."      MOVS     r2,#1
        0x00208570:    31f4        .1      ADDS     r1,r1,#0xf4
        0x00208572:    4628        (F      MOV      r0,r5
        0x00208574:    f5fffa73    ..s.    BL       log_buffer ; 0x7a5e
;;;318            return false;
        0x00208578:    2000        .       MOVS     r0,#0
        0x0020857a:    bd70        p.      POP      {r4-r6,pc}
;;;319        }
;;;320        memcpy(p_hdl_cache, simp_table[conn_id].hdl_cache, len);
        0x0020857c:    eb030140    ..@.    ADD      r1,r3,r0,LSL #1
        0x00208580:    4630        0F      MOV      r0,r6
        0x00208582:    1c89        ..      ADDS     r1,r1,#2
        0x00208584:    f651fc89    Q...    BL       __aeabi_memcpy ; 0x59e9a
;;;321        return true;
        0x00208588:    2001        .       MOVS     r0,#1
;;;322    }
        0x0020858a:    bd70        p.      POP      {r4-r6,pc}
    simp_ble_client_set_hdl_cache
;;;323    
;;;324    /**
;;;325      * @brief  Used by application, to set handle cache.
;;;326      * @param[in]  conn_id connection ID.
;;;327      * @param[in]  p_hdl_cache pointer of the handle cache table
;;;328      * @param[in]  len the length of handle cache table
;;;329      * @retval true success.
;;;330      * @retval false failed.
;;;331      */
;;;332    bool simp_ble_client_set_hdl_cache(uint8_t conn_id, uint16_t *p_hdl_cache, uint8_t len)
;;;333    {
        0x0020858c:    b570        p.      PUSH     {r4-r6,lr}
;;;334        if (conn_id >= simp_link_num)
        0x0020858e:    4d31        1M      LDR      r5,[pc,#196] ; [0x208654] = 0x20cfa8
        0x00208590:    4e2f        /N      LDR      r6,[pc,#188] ; [0x208650] = 0x21103302
        0x00208592:    782b        +x      LDRB     r3,[r5,#0]
        0x00208594:    1eb6        ..      SUBS     r6,r6,#2
        0x00208596:    4298        .B      CMP      r0,r3
        0x00208598:    d303        ..      BCC      0x2085a2 ; simp_ble_client_set_hdl_cache + 22
;;;335        {
;;;336            PROFILE_PRINT_ERROR1("simp_ble_client_set_hdl_cache: failed invalid conn_id %d", conn_id);
        0x0020859a:    4603        .F      MOV      r3,r0
        0x0020859c:    2201        ."      MOVS     r2,#1
        0x0020859e:    4933        3I      LDR      r1,[pc,#204] ; [0x20866c] = 0x88005a4
;;;337            return false;
        0x002085a0:    e00f        ..      B        0x2085c2 ; simp_ble_client_set_hdl_cache + 54
;;;338        }
;;;339        if (simp_table[conn_id].disc_state != DISC_SIMP_IDLE)
        0x002085a2:    eb0004c0    ....    ADD      r4,r0,r0,LSL #3
        0x002085a6:    68a8        .h      LDR      r0,[r5,#8]
        0x002085a8:    f8103014    ...0    LDRB     r3,[r0,r4,LSL #1]
        0x002085ac:    b11b        ..      CBZ      r3,0x2085b6 ; simp_ble_client_set_hdl_cache + 42
;;;340        {
;;;341            PROFILE_PRINT_ERROR1("simp_ble_client_set_hdl_cache: failed invalid state %d",
        0x002085ae:    492f        /I      LDR      r1,[pc,#188] ; [0x20866c] = 0x88005a4
        0x002085b0:    2201        ."      MOVS     r2,#1
        0x002085b2:    313c        <1      ADDS     r1,r1,#0x3c
;;;342                                 simp_table[conn_id].disc_state);
;;;343            return false;
        0x002085b4:    e005        ..      B        0x2085c2 ; simp_ble_client_set_hdl_cache + 54
;;;344        }
;;;345        if (len != sizeof(uint16_t) * HDL_SIMBLE_CACHE_LEN)
        0x002085b6:    2a10        .*      CMP      r2,#0x10
        0x002085b8:    d008        ..      BEQ      0x2085cc ; simp_ble_client_set_hdl_cache + 64
;;;346        {
;;;347            PROFILE_PRINT_ERROR1("simp_ble_client_set_hdl_cache: failed invalid len %d", len);
        0x002085ba:    4613        .F      MOV      r3,r2
        0x002085bc:    492b        +I      LDR      r1,[pc,#172] ; [0x20866c] = 0x88005a4
        0x002085be:    2201        ."      MOVS     r2,#1
        0x002085c0:    3178        x1      ADDS     r1,r1,#0x78
        0x002085c2:    4630        0F      MOV      r0,r6
        0x002085c4:    f5fffa4b    ..K.    BL       log_buffer ; 0x7a5e
;;;348            return false;
        0x002085c8:    2000        .       MOVS     r0,#0
        0x002085ca:    bd70        p.      POP      {r4-r6,pc}
;;;349        }
;;;350        memcpy(simp_table[conn_id].hdl_cache, p_hdl_cache, len);
        0x002085cc:    eb000044    ..D.    ADD      r0,r0,r4,LSL #1
        0x002085d0:    1c80        ..      ADDS     r0,r0,#2
        0x002085d2:    f651fc62    Q.b.    BL       __aeabi_memcpy ; 0x59e9a
;;;351        simp_table[conn_id].disc_state = DISC_SIMP_DONE;
        0x002085d6:    68a9        .h      LDR      r1,[r5,#8]
        0x002085d8:    2002        .       MOVS     r0,#2
        0x002085da:    f8010014    ....    STRB     r0,[r1,r4,LSL #1]
;;;352        return true;
        0x002085de:    2001        .       MOVS     r0,#1
;;;353    }
        0x002085e0:    bd70        p.      POP      {r4-r6,pc}
    simp_ble_client_discover_state_cb
;;;354    
;;;355    static bool simp_ble_client_start_char_discovery(uint8_t conn_id)
;;;356    {
;;;357        uint16_t start_handle;
;;;358        uint16_t end_handle;
;;;359    
;;;360        APP_PRINT_INFO0("simp_ble_client_start_simp_char_discovery");
;;;361        start_handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_SRV_START];
;;;362        end_handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_SRV_END];
;;;363        if (client_all_char_discovery(conn_id, simp_client, start_handle,
;;;364                                      end_handle) == GAP_CAUSE_SUCCESS)
;;;365        {
;;;366            return true;
;;;367        }
;;;368        return false;
;;;369    }
;;;370    
;;;371    static bool simp_ble_client_start_char_descriptor_discovery(uint8_t conn_id)
;;;372    {
;;;373        uint16_t start_handle;
;;;374        uint16_t end_handle;
;;;375    
;;;376        PROFILE_PRINT_INFO0("simp_ble_client_start_char_descriptor_discovery");
;;;377        start_handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_V3_NOTIFY];
;;;378        end_handle = simp_table[conn_id].hdl_cache[HDL_SIMBLE_SRV_END];
;;;379        if (client_all_char_descriptor_discovery(conn_id, simp_client, start_handle,
;;;380                                                 end_handle) == GAP_CAUSE_SUCCESS)
;;;381        {
;;;382            return true;
;;;383        }
;;;384        return false;
;;;385    }
;;;386    static void simp_ble_client_discover_state_cb(uint8_t conn_id,  T_DISCOVERY_STATE discovery_state)
;;;387    {
        0x002085e2:    e92d47f0    -..G    PUSH     {r4-r10,lr}
        0x002085e6:    b086        ..      SUB      sp,sp,#0x18
        0x002085e8:    4606        .F      MOV      r6,r0
        0x002085ea:    2000        .       MOVS     r0,#0
        0x002085ec:    f8dfa06c    ..l.    LDR      r10,[pc,#108] ; [0x20865c] = 0x21103002
        0x002085f0:    4688        .F      MOV      r8,r1
;;;388        bool cb_flag = false;
;;;389        T_SIMP_CLIENT_CB_DATA cb_data;
;;;390        cb_data.cb_type = SIMP_CLIENT_CB_TYPE_DISC_STATE;
        0x002085f2:    f88d0000    ....    STRB     r0,[sp,#0]
;;;391    
;;;392        APP_PRINT_INFO1("simp_ble_client_discover_state_cb: discovery_state %d", discovery_state);
        0x002085f6:    460b        .F      MOV      r3,r1
        0x002085f8:    2201        ."      MOVS     r2,#1
        0x002085fa:    491d        .I      LDR      r1,[pc,#116] ; [0x208670] = 0x88006b8
        0x002085fc:    4650        PF      MOV      r0,r10
        0x002085fe:    f5fffa2e    ....    BL       log_buffer ; 0x7a5e
;;;393        if (simp_table[conn_id].disc_state == DISC_SIMP_START)
        0x00208602:    4f14        .O      LDR      r7,[pc,#80] ; [0x208654] = 0x20cfa8
        0x00208604:    eb0604c6    ....    ADD      r4,r6,r6,LSL #3
        0x00208608:    68b8        .h      LDR      r0,[r7,#8]
        0x0020860a:    f8101014    ....    LDRB     r1,[r0,r4,LSL #1]
        0x0020860e:    2901        .)      CMP      r1,#1
        0x00208610:    d118        ..      BNE      0x208644 ; simp_ble_client_discover_state_cb + 98
;;;394        {
;;;395            uint16_t *hdl_cache;
;;;396            hdl_cache = simp_table[conn_id].hdl_cache;
        0x00208612:    eb000144    ..D.    ADD      r1,r0,r4,LSL #1
        0x00208616:    2503        .%      MOVS     r5,#3
        0x00208618:    f8df903c    ..<.    LDR      r9,[pc,#60] ; [0x208658] = 0x20cf28
        0x0020861c:    1c89        ..      ADDS     r1,r1,#2
        0x0020861e:    f1b80f02    ....    CMP      r8,#2
        0x00208622:    d027        '.      BEQ      0x208674 ; simp_ble_client_discover_state_cb + 146
        0x00208624:    f1b80f06    ....    CMP      r8,#6
        0x00208628:    d03a        :.      BEQ      0x2086a0 ; simp_ble_client_discover_state_cb + 190
        0x0020862a:    f1b80f0a    ....    CMP      r8,#0xa
        0x0020862e:    d04c        L.      BEQ      0x2086ca ; simp_ble_client_discover_state_cb + 232
        0x00208630:    f1b80f0b    ....    CMP      r8,#0xb
        0x00208634:    d04d        M.      BEQ      0x2086d2 ; simp_ble_client_discover_state_cb + 240
        0x00208636:    490e        .I      LDR      r1,[pc,#56] ; [0x208670] = 0x88006b8
        0x00208638:    2200        ."      MOVS     r2,#0
        0x0020863a:    313c        <1      ADDS     r1,r1,#0x3c
        0x0020863c:    f1aa0002    ....    SUB      r0,r10,#2
        0x00208640:    f5fffa0d    ....    BL       log_buffer ; 0x7a5e
        0x00208644:    b006        ..      ADD      sp,sp,#0x18
        0x00208646:    e8bd87f0    ....    POP      {r4-r10,pc}
    $d
        0x0020864a:    0000        ..      DCW    0
        0x0020864c:    088000e8    ....    DCD    142606568
        0x00208650:    21103302    .3.!    DCD    554709762
        0x00208654:    0020cfa8    .. .    DCD    2150312
        0x00208658:    0020cf28    (. .    DCD    2150184
        0x0020865c:    21103002    .0.!    DCD    554708994
        0x00208660:    0880023c    <...    DCD    142606908
        0x00208664:    08800358    X...    DCD    142607192
        0x00208668:    08800478    x...    DCD    142607480
        0x0020866c:    088005a4    ....    DCD    142607780
        0x00208670:    088006b8    ....    DCD    142608056
    $t
;;;397    
;;;398            switch (discovery_state)
;;;399            {
;;;400            case DISC_STATE_SRV_DONE:
;;;401                /* Indicate that service handle found. Start discover characteristic. */
;;;402                if ((hdl_cache[HDL_SIMBLE_SRV_START] != 0)
        0x00208674:    880a        ..      LDRH     r2,[r1,#0]
        0x00208676:    b90a        ..      CBNZ     r2,0x20867c ; simp_ble_client_discover_state_cb + 154
;;;403                    || (hdl_cache[HDL_SIMBLE_SRV_END] != 0))
        0x00208678:    8849        I.      LDRH     r1,[r1,#2]
        0x0020867a:    b351        Q.      CBZ      r1,0x2086d2 ; simp_ble_client_discover_state_cb + 240
        0x0020867c:    2200        ."      MOVS     r2,#0
        0x0020867e:    49f6        .I      LDR      r1,[pc,#984] ; [0x208a58] = 0x8800654
        0x00208680:    4650        PF      MOV      r0,r10
        0x00208682:    f5fff9ec    ....    BL       log_buffer ; 0x7a5e
        0x00208686:    68b8        .h      LDR      r0,[r7,#8]
        0x00208688:    f8991000    ....    LDRB     r1,[r9,#0]
        0x0020868c:    eb000044    ..D.    ADD      r0,r0,r4,LSL #1
        0x00208690:    8842        B.      LDRH     r2,[r0,#2]
        0x00208692:    8883        ..      LDRH     r3,[r0,#4]
        0x00208694:    4630        0F      MOV      r0,r6
        0x00208696:    f645ff92    E...    BL       client_all_char_discovery ; 0x4e5be
        0x0020869a:    e013        ..      B        0x2086c4 ; simp_ble_client_discover_state_cb + 226
;;;404                {
;;;405                    if (simp_ble_client_start_char_discovery(conn_id) == false)
;;;406                    {
;;;407                        simp_table[conn_id].disc_state = DISC_SIMP_FAILED;
;;;408                        cb_flag = true;
        0x0020869c:    68b8        .h      LDR      r0,[r7,#8]
        0x0020869e:    e018        ..      B        0x2086d2 ; simp_ble_client_discover_state_cb + 240
;;;409                    }
;;;410                }
;;;411                /* No Simple BLE service handle found. Discover procedure complete. */
;;;412                else
;;;413                {
;;;414                    simp_table[conn_id].disc_state = DISC_SIMP_FAILED;
;;;415                    cb_flag = true;
;;;416                }
;;;417                break;
;;;418            case DISC_STATE_CHAR_DONE:
;;;419                if (hdl_cache[HDL_SIMBLE_V3_NOTIFY] != 0)
        0x002086a0:    8909        ..      LDRH     r1,[r1,#8]
        0x002086a2:    b1b1        ..      CBZ      r1,0x2086d2 ; simp_ble_client_discover_state_cb + 240
        0x002086a4:    49ec        .I      LDR      r1,[pc,#944] ; [0x208a58] = 0x8800654
        0x002086a6:    2200        ."      MOVS     r2,#0
        0x002086a8:    3130        01      ADDS     r1,r1,#0x30
        0x002086aa:    48ec        .H      LDR      r0,[pc,#944] ; [0x208a5c] = 0x21103302
        0x002086ac:    f5fff9d7    ....    BL       log_buffer ; 0x7a5e
        0x002086b0:    68b8        .h      LDR      r0,[r7,#8]
        0x002086b2:    f8991000    ....    LDRB     r1,[r9,#0]
        0x002086b6:    eb000044    ..D.    ADD      r0,r0,r4,LSL #1
        0x002086ba:    8942        B.      LDRH     r2,[r0,#0xa]
        0x002086bc:    8883        ..      LDRH     r3,[r0,#4]
        0x002086be:    4630        0F      MOV      r0,r6
        0x002086c0:    f645ffe0    E...    BL       client_all_char_descriptor_discovery ; 0x4e684
        0x002086c4:    2800        .(      CMP      r0,#0
        0x002086c6:    d0bd        ..      BEQ      0x208644 ; simp_ble_client_discover_state_cb + 98
        0x002086c8:    e7e8        ..      B        0x20869c ; simp_ble_client_discover_state_cb + 186
;;;420                {
;;;421                    if (simp_ble_client_start_char_descriptor_discovery(conn_id) == false)
;;;422                    {
;;;423                        simp_table[conn_id].disc_state = DISC_SIMP_FAILED;
;;;424                        cb_flag = true;
;;;425                    }
;;;426                }
;;;427                else
;;;428                {
;;;429                    simp_table[conn_id].disc_state = DISC_SIMP_FAILED;
;;;430                    cb_flag = true;
;;;431                }
;;;432                break;
;;;433            case DISC_STATE_CHAR_DESCRIPTOR_DONE:
;;;434                simp_table[conn_id].disc_state = DISC_SIMP_DONE;
        0x002086ca:    2102        .!      MOVS     r1,#2
        0x002086cc:    f8001014    ....    STRB     r1,[r0,r4,LSL #1]
;;;435                cb_flag = true;
;;;436                break;
        0x002086d0:    e001        ..      B        0x2086d6 ; simp_ble_client_discover_state_cb + 244
;;;437            case DISC_STATE_FAILED:
;;;438                simp_table[conn_id].disc_state = DISC_SIMP_FAILED;
        0x002086d2:    f8005014    ...P    STRB     r5,[r0,r4,LSL #1]
;;;439                cb_flag = true;
;;;440                break;
;;;441            default:
;;;442                APP_PRINT_ERROR0("simp_handle_discover_state: Invalid Discovery State!");
;;;443                break;
;;;444            }
;;;445        }
;;;446    
;;;447        /* Send discover state to application if needed. */
;;;448        if (cb_flag && simp_client_cb)
        0x002086d6:    687b        {h      LDR      r3,[r7,#4]
        0x002086d8:    2b00        .+      CMP      r3,#0
        0x002086da:    d0b3        ..      BEQ      0x208644 ; simp_ble_client_discover_state_cb + 98
;;;449        {
;;;450            cb_data.cb_content.disc_state = simp_table[conn_id].disc_state;
        0x002086dc:    68b8        .h      LDR      r0,[r7,#8]
        0x002086de:    466a        jF      MOV      r2,sp
        0x002086e0:    4631        1F      MOV      r1,r6
        0x002086e2:    f8100014    ....    LDRB     r0,[r0,r4,LSL #1]
        0x002086e6:    f88d0004    ....    STRB     r0,[sp,#4]
;;;451            (*simp_client_cb)(simp_client, conn_id, &cb_data);
        0x002086ea:    f8990000    ....    LDRB     r0,[r9,#0]
        0x002086ee:    4798        .G      BLX      r3
;;;452        }
;;;453        return;
;;;454    }
        0x002086f0:    e7a8        ..      B        0x208644 ; simp_ble_client_discover_state_cb + 98
    simp_ble_client_discover_result_cb
;;;455    
;;;456    /**
;;;457      * @brief  Called by profile client layer, when discover result fetched.
;;;458      * @param  conn_id: connection ID.
;;;459      * @param  result_type: indicate which type of value discovered in service discovery procedure.
;;;460      * @param  result_data: value discovered.
;;;461      * @retval None
;;;462      */
;;;463    static void simp_ble_client_discover_result_cb(uint8_t conn_id,
;;;464                                                   T_DISCOVERY_RESULT_TYPE result_type,
;;;465                                                   T_DISCOVERY_RESULT_DATA result_data)
;;;466    {
        0x002086f2:    b5f8        ..      PUSH     {r3-r7,lr}
        0x002086f4:    4604        .F      MOV      r4,r0
        0x002086f6:    460e        .F      MOV      r6,r1
        0x002086f8:    8890        ..      LDRH     r0,[r2,#4]
        0x002086fa:    460b        .F      MOV      r3,r1
        0x002086fc:    49d6        .I      LDR      r1,[pc,#856] ; [0x208a58] = 0x8800654
        0x002086fe:    4fd8        .O      LDR      r7,[pc,#864] ; [0x208a60] = 0x21103002
        0x00208700:    4615        .F      MOV      r5,r2
;;;467        APP_PRINT_INFO2("simp_ble_client_discover_result_cb: result_type %d , 0x%02X", result_type,result_data.p_char_uuid16_disc_data->value_handle);
        0x00208702:    9000        ..      STR      r0,[sp,#0]
        0x00208704:    2202        ."      MOVS     r2,#2
        0x00208706:    31d8        .1      ADDS     r1,r1,#0xd8
        0x00208708:    4638        8F      MOV      r0,r7
        0x0020870a:    f5fff9a8    ....    BL       log_buffer ; 0x7a5e
;;;468        if (simp_table[conn_id].disc_state == DISC_SIMP_START)
        0x0020870e:    49d5        .I      LDR      r1,[pc,#852] ; [0x208a64] = 0x20cfa8
        0x00208710:    eb0400c4    ....    ADD      r0,r4,r4,LSL #3
        0x00208714:    6889        .h      LDR      r1,[r1,#8]
        0x00208716:    f8112010    ...     LDRB     r2,[r1,r0,LSL #1]
        0x0020871a:    2a01        .*      CMP      r2,#1
        0x0020871c:    d11b        ..      BNE      0x208756 ; simp_ble_client_discover_result_cb + 100
;;;469        {
;;;470            uint16_t handle;
;;;471            uint16_t *hdl_cache;
;;;472            hdl_cache = simp_table[conn_id].hdl_cache;
        0x0020871e:    eb010440    ..@.    ADD      r4,r1,r0,LSL #1
;;;473    		APP_PRINT_INFO2("vsop simp_ble_client_discover_result_cb: result_type %d , 0x%02X", result_type,result_data.p_char_uuid16_disc_data->value_handle);
        0x00208722:    88a8        ..      LDRH     r0,[r5,#4]
        0x00208724:    9000        ..      STR      r0,[sp,#0]
        0x00208726:    4633        3F      MOV      r3,r6
        0x00208728:    2202        ."      MOVS     r2,#2
        0x0020872a:    49cf        .I      LDR      r1,[pc,#828] ; [0x208a68] = 0x880076c
        0x0020872c:    4638        8F      MOV      r0,r7
        0x0020872e:    1ca4        ..      ADDS     r4,r4,#2
        0x00208730:    f5fff995    ....    BL       log_buffer ; 0x7a5e
;;;474    
;;;475            switch (result_type)
        0x00208734:    2e02        ..      CMP      r6,#2
        0x00208736:    d00a        ..      BEQ      0x20874e ; simp_ble_client_discover_result_cb + 92
        0x00208738:    2e03        ..      CMP      r6,#3
        0x0020873a:    d00d        ..      BEQ      0x208758 ; simp_ble_client_discover_result_cb + 102
        0x0020873c:    2e05        ..      CMP      r6,#5
        0x0020873e:    d034        4.      BEQ      0x2087aa ; simp_ble_client_discover_result_cb + 184
        0x00208740:    2200        ."      MOVS     r2,#0
        0x00208742:    1eb8        ..      SUBS     r0,r7,#2
        0x00208744:    e8bd40f8    ...@    POP      {r3-r7,lr}
        0x00208748:    49c8        .I      LDR      r1,[pc,#800] ; [0x208a6c] = 0x8800928
        0x0020874a:    f5ffb988    ....    B        log_buffer ; 0x7a5e
;;;476            {
;;;477            case DISC_RESULT_SRV_DATA:
;;;478                hdl_cache[HDL_SIMBLE_SRV_START] = result_data.p_srv_disc_data->att_handle;
        0x0020874e:    8828        (.      LDRH     r0,[r5,#0]
        0x00208750:    8020         .      STRH     r0,[r4,#0]
;;;479                hdl_cache[HDL_SIMBLE_SRV_END] = result_data.p_srv_disc_data->end_group_handle;
        0x00208752:    8868        h.      LDRH     r0,[r5,#2]
        0x00208754:    8060        `.      STRH     r0,[r4,#2]
        0x00208756:    bdf8        ..      POP      {r3-r7,pc}
        0x00208758:    49c3        .I      LDR      r1,[pc,#780] ; [0x208a68] = 0x880076c
;;;480                break;
;;;481    
;;;482            case DISC_RESULT_CHAR_UUID16:
;;;483                handle = result_data.p_char_uuid16_disc_data->value_handle;
        0x0020875a:    88ae        ..      LDRH     r6,[r5,#4]
;;;484    			APP_PRINT_INFO1("vsop result_data DISC_RESULT_CHAR_UUID16: 0x%02X", result_data.p_char_uuid16_disc_data->uuid16);
        0x0020875c:    88eb        ..      LDRH     r3,[r5,#6]
        0x0020875e:    2201        ."      MOVS     r2,#1
        0x00208760:    3144        D1      ADDS     r1,r1,#0x44
        0x00208762:    4638        8F      MOV      r0,r7
        0x00208764:    f5fff97b    ..{.    BL       log_buffer ; 0x7a5e
;;;485                switch (result_data.p_char_uuid16_disc_data->uuid16)
        0x00208768:    88e8        ..      LDRH     r0,[r5,#6]
        0x0020876a:    301c        .0      ADDS     r0,r0,#0x1c
        0x0020876c:    f5b03080    ...0    SUBS     r0,r0,#0x10000
        0x00208770:    d009        ..      BEQ      0x208786 ; simp_ble_client_discover_result_cb + 148
        0x00208772:    2801        .(      CMP      r0,#1
        0x00208774:    d005        ..      BEQ      0x208782 ; simp_ble_client_discover_result_cb + 144
        0x00208776:    2803        .(      CMP      r0,#3
        0x00208778:    d00e        ..      BEQ      0x208798 ; simp_ble_client_discover_result_cb + 166
        0x0020877a:    2805        .(      CMP      r0,#5
        0x0020877c:    d1eb        ..      BNE      0x208756 ; simp_ble_client_discover_result_cb + 100
        0x0020877e:    80e6        ..      STRH     r6,[r4,#6]
        0x00208780:    bdf8        ..      POP      {r3-r7,pc}
;;;486                {      
;;;487                case GATT_UUID_CHAR_SIMPLE_V1_READ:
;;;488                    hdl_cache[HDL_SIMBLE_V1_READ] = handle;
        0x00208782:    80a6        ..      STRH     r6,[r4,#4]
        0x00208784:    bdf8        ..      POP      {r3-r7,pc}
;;;489                    break;
;;;490    
;;;491                case GATT_UUID_CHAR_SIMPLE_V2_WRITE:
;;;492                    hdl_cache[HDL_SIMBLE_V2_WRITE] = handle;
;;;493                    break;
;;;494    
;;;495                case GATT_UUID_CHAR_SIMPLE_V3_NOTIFY:
;;;496    				APP_PRINT_INFO1("vsop+++++++++++++GATT_UUID_CHAR_SIMPLE_V3_NOTIFY, handle=%d",handle);
        0x00208786:    49b8        .I      LDR      r1,[pc,#736] ; [0x208a68] = 0x880076c
        0x00208788:    4633        3F      MOV      r3,r6
        0x0020878a:    2201        ."      MOVS     r2,#1
        0x0020878c:    3178        x1      ADDS     r1,r1,#0x78
        0x0020878e:    4638        8F      MOV      r0,r7
        0x00208790:    f5fff965    ..e.    BL       log_buffer ; 0x7a5e
;;;497                    hdl_cache[HDL_SIMBLE_V3_NOTIFY] = handle;
        0x00208794:    8126        &.      STRH     r6,[r4,#8]
        0x00208796:    bdf8        ..      POP      {r3-r7,pc}
;;;498                    break;
;;;499    
;;;500                case GATT_UUID_CHAR_SIMPLE_V4_INDICATE:
;;;501    				APP_PRINT_INFO1("vsop+++++++++++++GATT_UUID_CHAR_SIMPLE_V4_INDICATE, handle=%d",handle);
        0x00208798:    49b3        .I      LDR      r1,[pc,#716] ; [0x208a68] = 0x880076c
        0x0020879a:    4633        3F      MOV      r3,r6
        0x0020879c:    2201        ."      MOVS     r2,#1
        0x0020879e:    31b8        .1      ADDS     r1,r1,#0xb8
        0x002087a0:    4638        8F      MOV      r0,r7
        0x002087a2:    f5fff95c    ..\.    BL       log_buffer ; 0x7a5e
;;;502                    hdl_cache[HDL_SIMBLE_V4_INDICATE] = handle;
        0x002087a6:    81a6        ..      STRH     r6,[r4,#0xc]
        0x002087a8:    bdf8        ..      POP      {r3-r7,pc}
;;;503                    break;
;;;504    
;;;505                default:
;;;506                    /* have no intrest on this handle. */
;;;507                    break;
;;;508                }
;;;509    
;;;510                break;
;;;511    
;;;512            case DISC_RESULT_CHAR_DESC_UUID16:
;;;513                /* When use client_all_char_descriptor_discovery. */
;;;514    			APP_PRINT_INFO1("vsop 1 DISC_RESULT_CHAR_DESC_UUID16: uuid16 , 0x%02X", result_data.p_char_desc_uuid16_disc_data->uuid16);
        0x002087aa:    49b0        .I      LDR      r1,[pc,#704] ; [0x208a6c] = 0x8800928
        0x002087ac:    886b        k.      LDRH     r3,[r5,#2]
        0x002087ae:    2201        ."      MOVS     r2,#1
        0x002087b0:    39c0        .9      SUBS     r1,r1,#0xc0
        0x002087b2:    4638        8F      MOV      r0,r7
        0x002087b4:    f5fff953    ..S.    BL       log_buffer ; 0x7a5e
;;;515                if (result_data.p_char_desc_uuid16_disc_data->uuid16 == GATT_UUID_CHAR_CLIENT_CONFIG)
        0x002087b8:    8868        h.      LDRH     r0,[r5,#2]
        0x002087ba:    f5a05124    ..$Q    SUB      r1,r0,#0x2900
        0x002087be:    3902        .9      SUBS     r1,#2
        0x002087c0:    d1f2        ..      BNE      0x2087a8 ; simp_ble_client_discover_result_cb + 182
;;;516                {
;;;517                    handle = result_data.p_char_desc_uuid16_disc_data->handle;
        0x002087c2:    882d        -.      LDRH     r5,[r5,#0]
;;;518    				APP_PRINT_INFO1("vsop 2 DISC_RESULT_CHAR_DESC_UUID16: handle , 0x%02X",handle);
        0x002087c4:    49a9        .I      LDR      r1,[pc,#676] ; [0x208a6c] = 0x8800928
        0x002087c6:    462b        +F      MOV      r3,r5
        0x002087c8:    2201        ."      MOVS     r2,#1
        0x002087ca:    3988        .9      SUBS     r1,r1,#0x88
        0x002087cc:    4638        8F      MOV      r0,r7
        0x002087ce:    f5fff946    ..F.    BL       log_buffer ; 0x7a5e
;;;519    				
;;;520                    if ((handle > hdl_cache[HDL_SIMBLE_V3_NOTIFY])
        0x002087d2:    8920         .      LDRH     r0,[r4,#8]
        0x002087d4:    42a8        .B      CMP      r0,r5
        0x002087d6:    d20b        ..      BCS      0x2087f0 ; simp_ble_client_discover_result_cb + 254
;;;521                        && (handle < hdl_cache[HDL_SIMBLE_V4_INDICATE]))
        0x002087d8:    89a0        ..      LDRH     r0,[r4,#0xc]
        0x002087da:    42a8        .B      CMP      r0,r5
        0x002087dc:    d908        ..      BLS      0x2087f0 ; simp_ble_client_discover_result_cb + 254
;;;522                    {
;;;523                    	APP_PRINT_INFO1("vsopxxxxxxxxxxxxxxxxx1, handle=%d",handle);
        0x002087de:    49a3        .I      LDR      r1,[pc,#652] ; [0x208a6c] = 0x8800928
        0x002087e0:    462b        +F      MOV      r3,r5
        0x002087e2:    2201        ."      MOVS     r2,#1
        0x002087e4:    3950        P9      SUBS     r1,r1,#0x50
        0x002087e6:    4638        8F      MOV      r0,r7
        0x002087e8:    f5fff939    ..9.    BL       log_buffer ; 0x7a5e
;;;524                        hdl_cache[HDL_SIMBLE_V3_NOTIFY_CCCD] = handle;
        0x002087ec:    8165        e.      STRH     r5,[r4,#0xa]
        0x002087ee:    bdf8        ..      POP      {r3-r7,pc}
;;;525                    }
;;;526                    else if ((handle > hdl_cache[HDL_SIMBLE_V4_INDICATE]) &&
        0x002087f0:    89a0        ..      LDRH     r0,[r4,#0xc]
        0x002087f2:    42a8        .B      CMP      r0,r5
        0x002087f4:    d2fb        ..      BCS      0x2087ee ; simp_ble_client_discover_result_cb + 252
;;;527                             (hdl_cache[HDL_SIMBLE_V4_INDICATE_CCCD] == 0))
        0x002087f6:    89e0        ..      LDRH     r0,[r4,#0xe]
        0x002087f8:    2800        .(      CMP      r0,#0
        0x002087fa:    d1f8        ..      BNE      0x2087ee ; simp_ble_client_discover_result_cb + 252
;;;528                    {
;;;529                    
;;;530    					APP_PRINT_INFO1("vsopxxxxxxxxxxxxxxxxx2, handle=%d",handle);
        0x002087fc:    499b        .I      LDR      r1,[pc,#620] ; [0x208a6c] = 0x8800928
        0x002087fe:    462b        +F      MOV      r3,r5
        0x00208800:    2201        ."      MOVS     r2,#1
        0x00208802:    3928        (9      SUBS     r1,r1,#0x28
        0x00208804:    4638        8F      MOV      r0,r7
        0x00208806:    f5fff92a    ..*.    BL       log_buffer ; 0x7a5e
;;;531                        hdl_cache[HDL_SIMBLE_V4_INDICATE_CCCD] = handle;
        0x0020880a:    81e5        ..      STRH     r5,[r4,#0xe]
;;;532                    }
;;;533                }
;;;534                break;
;;;535    
;;;536            default:
;;;537                APP_PRINT_ERROR0("simp_handle_discover_result: Invalid Discovery Result Type!");
;;;538                break;
;;;539            }
;;;540        }
;;;541    
;;;542        return;
;;;543    }
        0x0020880c:    bdf8        ..      POP      {r3-r7,pc}
    simp_ble_client_read_result_cb
;;;544    
;;;545    static void simp_ble_client_read_result_cb(uint8_t conn_id,  uint16_t cause,
;;;546                                               uint16_t handle, uint16_t value_size, uint8_t *p_value)
;;;547    {
        0x0020880e:    e92d4fff    -..O    PUSH     {r0-r11,lr}
        0x00208812:    b087        ..      SUB      sp,sp,#0x1c
        0x00208814:    f8dfb24c    ..L.    LDR      r11,[pc,#588] ; [0x208a64] = 0x20cfa8
        0x00208818:    9807        ..      LDR      r0,[sp,#0x1c]
        0x0020881a:    460c        .F      MOV      r4,r1
        0x0020881c:    eb0001c0    ....    ADD      r1,r0,r0,LSL #3
        0x00208820:    f8db0008    ....    LDR      r0,[r11,#8]
        0x00208824:    4698        .F      MOV      r8,r3
        0x00208826:    eb000641    ..A.    ADD      r6,r0,r1,LSL #1
        0x0020882a:    4990        .I      LDR      r1,[pc,#576] ; [0x208a6c] = 0x8800928
        0x0020882c:    4617        .F      MOV      r7,r2
;;;548        T_SIMP_CLIENT_CB_DATA cb_data;
;;;549        uint16_t *hdl_cache;
;;;550        hdl_cache = simp_table[conn_id].hdl_cache;
        0x0020882e:    9d14        ..      LDR      r5,[sp,#0x50]
;;;551    
;;;552        cb_data.cb_type = SIMP_CLIENT_CB_TYPE_READ_RESULT;
        0x00208830:    f04f0901    O...    MOV      r9,#1
        0x00208834:    4613        .F      MOV      r3,r2
        0x00208836:    f88d9004    ....    STRB     r9,[sp,#4]
;;;553    
;;;554        APP_PRINT_INFO2("simp_ble_client_read_result_cb: handle 0x%x, cause 0x%x", handle, cause);
        0x0020883a:    2202        ."      MOVS     r2,#2
        0x0020883c:    3140        @1      ADDS     r1,r1,#0x40
        0x0020883e:    4888        .H      LDR      r0,[pc,#544] ; [0x208a60] = 0x21103002
        0x00208840:    1cb6        ..      ADDS     r6,r6,#2
        0x00208842:    9400        ..      STR      r4,[sp,#0]
        0x00208844:    f5fff90b    ....    BL       log_buffer ; 0x7a5e
;;;555        cb_data.cb_content.read_result.cause = cause;
        0x00208848:    f8ad4014    ...@    STRH     r4,[sp,#0x14]
;;;556    
;;;557        if (handle == hdl_cache[HDL_SIMBLE_V1_READ])
        0x0020884c:    88b0        ..      LDRH     r0,[r6,#4]
        0x0020884e:    f04f0a00    O...    MOV      r10,#0
        0x00208852:    42b8        .B      CMP      r0,r7
        0x00208854:    d10a        ..      BNE      0x20886c ; simp_ble_client_read_result_cb + 94
;;;558        {
;;;559            cb_data.cb_content.read_result.type = SIMP_READ_V1_READ;
        0x00208856:    4650        PF      MOV      r0,r10
        0x00208858:    f88da008    ....    STRB     r10,[sp,#8]
;;;560            if (cause == GAP_SUCCESS)
        0x0020885c:    b114        ..      CBZ      r4,0x208864 ; simp_ble_client_read_result_cb + 86
        0x0020885e:    f8ad000c    ....    STRH     r0,[sp,#0xc]
        0x00208862:    e04b        K.      B        0x2088fc ; simp_ble_client_read_result_cb + 238
;;;561            {
;;;562                cb_data.cb_content.read_result.data.v1_read.p_value = p_value;
;;;563                cb_data.cb_content.read_result.data.v1_read.value_size = value_size;
        0x00208864:    9504        ..      STR      r5,[sp,#0x10]
        0x00208866:    f8ad800c    ....    STRH     r8,[sp,#0xc]
        0x0020886a:    e047        G.      B        0x2088fc ; simp_ble_client_read_result_cb + 238
;;;564            }
;;;565            else
;;;566            {
;;;567                cb_data.cb_content.read_result.data.v1_read.value_size = 0;
;;;568            }
;;;569        }
;;;570        else if (handle == hdl_cache[HDL_SIMBLE_V3_NOTIFY_CCCD])
        0x0020886c:    8970        p.      LDRH     r0,[r6,#0xa]
        0x0020886e:    42b8        .B      CMP      r0,r7
        0x00208870:    d115        ..      BNE      0x20889e ; simp_ble_client_read_result_cb + 144
;;;571        {
;;;572            cb_data.cb_content.read_result.type = SIMP_READ_V3_NOTIFY_CCCD;
        0x00208872:    4649        IF      MOV      r1,r9
        0x00208874:    f88d9008    ....    STRB     r9,[sp,#8]
;;;573            if (cause == GAP_SUCCESS)
        0x00208878:    bbec        ..      CBNZ     r4,0x2088f6 ; simp_ble_client_read_result_cb + 232
;;;574            {
;;;575                uint16_t ccc_bit;
;;;576                if (value_size != 2)
        0x0020887a:    4640        @F      MOV      r0,r8
        0x0020887c:    f1b80f02    ....    CMP      r8,#2
        0x00208880:    d004        ..      BEQ      0x20888c ; simp_ble_client_read_result_cb + 126
;;;577                {
;;;578                    PROFILE_PRINT_ERROR1("simp_ble_client_read_result_cb: invalid cccd len %d", value_size);
        0x00208882:    497a        zI      LDR      r1,[pc,#488] ; [0x208a6c] = 0x8800928
        0x00208884:    2201        ."      MOVS     r2,#1
        0x00208886:    4603        .F      MOV      r3,r0
        0x00208888:    317c        |1      ADDS     r1,r1,#0x7c
;;;579                    return;
        0x0020888a:    e01e        ..      B        0x2088ca ; simp_ble_client_read_result_cb + 188
;;;580                }
;;;581                LE_ARRAY_TO_UINT16(ccc_bit, p_value);
        0x0020888c:    7828        (x      LDRB     r0,[r5,#0]
        0x0020888e:    786a        jx      LDRB     r2,[r5,#1]
        0x00208890:    eb002002    ...     ADD      r0,r0,r2,LSL #8
;;;582    
;;;583                if (ccc_bit & GATT_CLIENT_CHAR_CONFIG_NOTIFY)
        0x00208894:    07c0        ..      LSLS     r0,r0,#31
        0x00208896:    d02f        /.      BEQ      0x2088f8 ; simp_ble_client_read_result_cb + 234
;;;584                {
;;;585                    cb_data.cb_content.read_result.data.v3_notify_cccd = true;
        0x00208898:    f88d100c    ....    STRB     r1,[sp,#0xc]
        0x0020889c:    e02e        ..      B        0x2088fc ; simp_ble_client_read_result_cb + 238
;;;586                }
;;;587                else
;;;588                {
;;;589                    cb_data.cb_content.read_result.data.v3_notify_cccd = false;
;;;590                }
;;;591            }
;;;592        }
;;;593        else if (handle == hdl_cache[HDL_SIMBLE_V4_INDICATE_CCCD])
        0x0020889e:    89f0        ..      LDRH     r0,[r6,#0xe]
        0x002088a0:    42b8        .B      CMP      r0,r7
        0x002088a2:    d116        ..      BNE      0x2088d2 ; simp_ble_client_read_result_cb + 196
;;;594        {
;;;595            cb_data.cb_content.read_result.type = SIMP_READ_V4_INDICATE_CCCD;
        0x002088a4:    2002        .       MOVS     r0,#2
        0x002088a6:    4971        qI      LDR      r1,[pc,#452] ; [0x208a6c] = 0x8800928
        0x002088a8:    4e6d        mN      LDR      r6,[pc,#436] ; [0x208a60] = 0x21103002
        0x002088aa:    f88d0008    ....    STRB     r0,[sp,#8]
;;;596    			APP_PRINT_INFO0("vsop------- indicate _cccd 1");		
        0x002088ae:    2200        ."      MOVS     r2,#0
        0x002088b0:    31b4        .1      ADDS     r1,r1,#0xb4
        0x002088b2:    4630        0F      MOV      r0,r6
        0x002088b4:    f5fff8d3    ....    BL       log_buffer ; 0x7a5e
;;;597            if (cause == GAP_SUCCESS)
        0x002088b8:    b9ec        ..      CBNZ     r4,0x2088f6 ; simp_ble_client_read_result_cb + 232
;;;598            {
;;;599                uint16_t ccc_bit;
;;;600                if (value_size != 2)
        0x002088ba:    4640        @F      MOV      r0,r8
        0x002088bc:    f1b80f02    ....    CMP      r8,#2
        0x002088c0:    d00a        ..      BEQ      0x2088d8 ; simp_ble_client_read_result_cb + 202
;;;601                {
;;;602                    PROFILE_PRINT_ERROR1("simp_ble_client_read_result_cb: invalid cccd len %d", value_size);
        0x002088c2:    496a        jI      LDR      r1,[pc,#424] ; [0x208a6c] = 0x8800928
        0x002088c4:    2201        ."      MOVS     r2,#1
        0x002088c6:    4603        .F      MOV      r3,r0
        0x002088c8:    31d4        .1      ADDS     r1,r1,#0xd4
        0x002088ca:    4864        dH      LDR      r0,[pc,#400] ; [0x208a5c] = 0x21103302
        0x002088cc:    1e80        ..      SUBS     r0,r0,#2
        0x002088ce:    f5fff8c6    ....    BL       log_buffer ; 0x7a5e
        0x002088d2:    b00b        ..      ADD      sp,sp,#0x2c
        0x002088d4:    e8bd8ff0    ....    POP      {r4-r11,pc}
;;;603                    return;
;;;604                }
;;;605                LE_ARRAY_TO_UINT16(ccc_bit, p_value);
        0x002088d8:    7828        (x      LDRB     r0,[r5,#0]
        0x002088da:    7869        ix      LDRB     r1,[r5,#1]
        0x002088dc:    2201        ."      MOVS     r2,#1
        0x002088de:    eb002001    ...     ADD      r0,r0,r1,LSL #8
        0x002088e2:    b284        ..      UXTH     r4,r0
;;;606    			APP_PRINT_INFO1("vsop------- indicate _cccd =  %d",ccc_bit);
        0x002088e4:    4623        #F      MOV      r3,r4
        0x002088e6:    4962        bI      LDR      r1,[pc,#392] ; [0x208a70] = 0x8800a34
        0x002088e8:    4630        0F      MOV      r0,r6
        0x002088ea:    f5fff8b8    ....    BL       log_buffer ; 0x7a5e
;;;607    
;;;608                if (ccc_bit & GATT_CLIENT_CHAR_CONFIG_INDICATE)
        0x002088ee:    07a0        ..      LSLS     r0,r4,#30
        0x002088f0:    d502        ..      BPL      0x2088f8 ; simp_ble_client_read_result_cb + 234
;;;609                {
;;;610                    cb_data.cb_content.read_result.data.v4_indicate_cccd = true;
        0x002088f2:    f88d900c    ....    STRB     r9,[sp,#0xc]
        0x002088f6:    e001        ..      B        0x2088fc ; simp_ble_client_read_result_cb + 238
;;;611                }
;;;612                else
;;;613                {
;;;614                   cb_data.cb_content.read_result.data.v4_indicate_cccd = false;
        0x002088f8:    f88da00c    ....    STRB     r10,[sp,#0xc]
;;;615                }
;;;616            }
;;;617        }
;;;618        else
;;;619        {
;;;620            return;
;;;621        }
;;;622        /* Inform application the read result. */
;;;623        if (simp_client_cb)
        0x002088fc:    f8db3004    ...0    LDR      r3,[r11,#4]
        0x00208900:    2b00        .+      CMP      r3,#0
        0x00208902:    d0e6        ..      BEQ      0x2088d2 ; simp_ble_client_read_result_cb + 196
;;;624        {
;;;625            (*simp_client_cb)(simp_client, conn_id, &cb_data);
        0x00208904:    485b        [H      LDR      r0,[pc,#364] ; [0x208a74] = 0x20cf28
        0x00208906:    aa01        ..      ADD      r2,sp,#4
        0x00208908:    9907        ..      LDR      r1,[sp,#0x1c]
        0x0020890a:    7800        .x      LDRB     r0,[r0,#0]
        0x0020890c:    4798        .G      BLX      r3
;;;626        }
;;;627    
;;;628        return;
;;;629    }
        0x0020890e:    e7e0        ..      B        0x2088d2 ; simp_ble_client_read_result_cb + 196
    simp_ble_client_write_result_cb
;;;630    
;;;631    static void simp_ble_client_write_result_cb(uint8_t conn_id, T_GATT_WRITE_TYPE type,
;;;632                                                uint16_t handle, uint16_t cause,
;;;633                                                uint8_t credits)
;;;634    {
        0x00208910:    e92d43f0    -..C    PUSH     {r4-r9,lr}
        0x00208914:    4f53        SO      LDR      r7,[pc,#332] ; [0x208a64] = 0x20cfa8
;;; .\..\..\..\src\ble\profile\client\simple_ble_client.c (634)
        0x00208916:    4681        .F      MOV      r9,r0
        0x00208918:    b087        ..      SUB      sp,sp,#0x1c
        0x0020891a:    68b9        .h      LDR      r1,[r7,#8]
        0x0020891c:    eb0000c9    ....    ADD      r0,r0,r9,LSL #3
        0x00208920:    eb010440    ..@.    ADD      r4,r1,r0,LSL #1
        0x00208924:    461e        .F      MOV      r6,r3
        0x00208926:    f04f0802    O...    MOV      r8,#2
        0x0020892a:    9300        ..      STR      r3,[sp,#0]
        0x0020892c:    4950        PI      LDR      r1,[pc,#320] ; [0x208a70] = 0x8800a34
        0x0020892e:    4615        .F      MOV      r5,r2
        0x00208930:    4613        .F      MOV      r3,r2
;;;635        T_SIMP_CLIENT_CB_DATA cb_data;
;;;636        uint16_t *hdl_cache;
;;;637        hdl_cache = simp_table[conn_id].hdl_cache;
;;;638        cb_data.cb_type = SIMP_CLIENT_CB_TYPE_WRITE_RESULT;
        0x00208932:    f88d8004    ....    STRB     r8,[sp,#4]
;;;639    
;;;640        PROFILE_PRINT_INFO2("simp_ble_client_write_result_cb: handle 0x%x, cause 0x%x", handle, cause);
        0x00208936:    4642        BF      MOV      r2,r8
        0x00208938:    3124        $1      ADDS     r1,r1,#0x24
        0x0020893a:    4848        HH      LDR      r0,[pc,#288] ; [0x208a5c] = 0x21103302
        0x0020893c:    1ca4        ..      ADDS     r4,r4,#2
        0x0020893e:    f5fff88e    ....    BL       log_buffer ; 0x7a5e
;;;641        cb_data.cb_content.write_result.cause = cause;
        0x00208942:    f8ad600a    ...`    STRH     r6,[sp,#0xa]
;;;642    
;;;643        if (handle == hdl_cache[HDL_SIMBLE_V2_WRITE])
        0x00208946:    88e0        ..      LDRH     r0,[r4,#6]
        0x00208948:    42a8        .B      CMP      r0,r5
        0x0020894a:    d101        ..      BNE      0x208950 ; simp_ble_client_write_result_cb + 64
;;;644        {
;;;645            cb_data.cb_content.write_result.type = SIMP_WRITE_V2_WRITE;
        0x0020894c:    2000        .       MOVS     r0,#0
        0x0020894e:    e003        ..      B        0x208958 ; simp_ble_client_write_result_cb + 72
;;;646        }
;;;647        else if (handle == hdl_cache[HDL_SIMBLE_V3_NOTIFY_CCCD])
        0x00208950:    8960        `.      LDRH     r0,[r4,#0xa]
        0x00208952:    42a8        .B      CMP      r0,r5
        0x00208954:    d103        ..      BNE      0x20895e ; simp_ble_client_write_result_cb + 78
;;;648        {
;;;649            cb_data.cb_content.write_result.type = SIMP_WRITE_V3_NOTIFY_CCCD;
        0x00208956:    2001        .       MOVS     r0,#1
        0x00208958:    f88d0008    ....    STRB     r0,[sp,#8]
        0x0020895c:    e004        ..      B        0x208968 ; simp_ble_client_write_result_cb + 88
;;;650        }
;;;651        else if (handle == hdl_cache[HDL_SIMBLE_V4_INDICATE_CCCD])
        0x0020895e:    89e0        ..      LDRH     r0,[r4,#0xe]
        0x00208960:    42a8        .B      CMP      r0,r5
        0x00208962:    d109        ..      BNE      0x208978 ; simp_ble_client_write_result_cb + 104
;;;652        {
;;;653            cb_data.cb_content.write_result.type = SIMP_WRITE_V4_INDICATE_CCCD;
        0x00208964:    f88d8008    ....    STRB     r8,[sp,#8]
;;;654        }
;;;655        else
;;;656        {
;;;657            return;
;;;658        }
;;;659        /* Inform application the write result. */
;;;660        if (simp_client_cb)
        0x00208968:    687b        {h      LDR      r3,[r7,#4]
        0x0020896a:    2b00        .+      CMP      r3,#0
        0x0020896c:    d004        ..      BEQ      0x208978 ; simp_ble_client_write_result_cb + 104
;;;661        {
;;;662            (*simp_client_cb)(simp_client, conn_id, &cb_data);
        0x0020896e:    4841        AH      LDR      r0,[pc,#260] ; [0x208a74] = 0x20cf28
        0x00208970:    aa01        ..      ADD      r2,sp,#4
        0x00208972:    4649        IF      MOV      r1,r9
        0x00208974:    7800        .x      LDRB     r0,[r0,#0]
        0x00208976:    4798        .G      BLX      r3
;;;663        }
;;;664    
;;;665        return;
;;;666    }
        0x00208978:    b007        ..      ADD      sp,sp,#0x1c
        0x0020897a:    e8bd83f0    ....    POP      {r4-r9,pc}
    simp_ble_client_notif_ind_result_cb
;;;667    
;;;668    static T_APP_RESULT simp_ble_client_notif_ind_result_cb(uint8_t conn_id, bool notify,
;;;669                                                            uint16_t handle,
;;;670                                                            uint16_t value_size, uint8_t *p_value)
;;;671    {
        0x0020897e:    e92d47f0    -..G    PUSH     {r4-r10,lr}
        0x00208982:    4f38        8O      LDR      r7,[pc,#224] ; [0x208a64] = 0x20cfa8
        0x00208984:    4681        .F      MOV      r9,r0
        0x00208986:    b086        ..      SUB      sp,sp,#0x18
        0x00208988:    68b9        .h      LDR      r1,[r7,#8]
        0x0020898a:    eb0000c9    ....    ADD      r0,r0,r9,LSL #3
        0x0020898e:    eb010040    ..@.    ADD      r0,r1,r0,LSL #1
        0x00208992:    2103        .!      MOVS     r1,#3
        0x00208994:    f88d1000    ....    STRB     r1,[sp,#0]
        0x00208998:    8941        A.      LDRH     r1,[r0,#0xa]
        0x0020899a:    4614        .F      MOV      r4,r2
        0x0020899c:    9e0e        ..      LDR      r6,[sp,#0x38]
        0x0020899e:    f8dfa0c0    ....    LDR      r10,[pc,#192] ; [0x208a60] = 0x21103002
        0x002089a2:    1c80        ..      ADDS     r0,r0,#2
        0x002089a4:    461d        .F      MOV      r5,r3
        0x002089a6:    f04f0800    O...    MOV      r8,#0
        0x002089aa:    42a1        .B      CMP      r1,r4
        0x002089ac:    d108        ..      BNE      0x2089c0 ; simp_ble_client_notif_ind_result_cb + 66
;;;672        T_APP_RESULT app_result = APP_RESULT_SUCCESS;
;;;673        T_SIMP_CLIENT_CB_DATA cb_data;
;;;674        uint16_t *hdl_cache;
;;;675        hdl_cache = simp_table[conn_id].hdl_cache;
;;;676    
;;;677        cb_data.cb_type = SIMP_CLIENT_CB_TYPE_NOTIF_IND_RESULT;
;;;678    
;;;679        if (handle == hdl_cache[HDL_SIMBLE_V3_NOTIFY])
;;;680        {
;;;681        	APP_PRINT_INFO1("vsop------------HDL_SIMBLE_V3_NOTIFY %d",handle);
        0x002089ae:    4930        0I      LDR      r1,[pc,#192] ; [0x208a70] = 0x8800a34
        0x002089b0:    4613        .F      MOV      r3,r2
        0x002089b2:    2201        ."      MOVS     r2,#1
        0x002089b4:    3160        `1      ADDS     r1,r1,#0x60
        0x002089b6:    4650        PF      MOV      r0,r10
        0x002089b8:    f5fff851    ..Q.    BL       log_buffer ; 0x7a5e
;;;682            cb_data.cb_content.notif_ind_data.type = SIMP_V3_NOTIFY;
        0x002089bc:    2000        .       MOVS     r0,#0
;;;683            cb_data.cb_content.notif_ind_data.data.value_size = value_size;
;;;684            cb_data.cb_content.notif_ind_data.data.p_value = p_value;
        0x002089be:    e00b        ..      B        0x2089d8 ; simp_ble_client_notif_ind_result_cb + 90
;;;685        }
;;;686        else if (handle == hdl_cache[HDL_SIMBLE_V4_INDICATE])
        0x002089c0:    8980        ..      LDRH     r0,[r0,#0xc]
        0x002089c2:    4613        .F      MOV      r3,r2
        0x002089c4:    42a0        .B      CMP      r0,r4
        0x002089c6:    f04f0201    O...    MOV      r2,#1
        0x002089ca:    d122        ".      BNE      0x208a12 ; simp_ble_client_notif_ind_result_cb + 148
;;;687        {
;;;688        	APP_PRINT_INFO1("vsop------------HDL_SIMBLE_V4_INDICATE %d",handle);
        0x002089cc:    4928        (I      LDR      r1,[pc,#160] ; [0x208a70] = 0x8800a34
        0x002089ce:    4650        PF      MOV      r0,r10
        0x002089d0:    318c        .1      ADDS     r1,r1,#0x8c
        0x002089d2:    f5fff844    ..D.    BL       log_buffer ; 0x7a5e
;;;689            cb_data.cb_content.notif_ind_data.type = SIMP_V4_INDICATE;
        0x002089d6:    2001        .       MOVS     r0,#1
        0x002089d8:    f88d0004    ....    STRB     r0,[sp,#4]
;;;690            cb_data.cb_content.notif_ind_data.data.value_size = value_size;
        0x002089dc:    f8ad5008    ...P    STRH     r5,[sp,#8]
;;;691            cb_data.cb_content.notif_ind_data.data.p_value = p_value;
;;;692        }
;;;693        else
;;;694        {
;;;695        	APP_PRINT_INFO1("vsop------------no handle %d",handle);
;;;696            return app_result;
;;;697        }
;;;698        /* Inform application the notif/ind result. */
;;;699        if (simp_client_cb)
        0x002089e0:    9603        ..      STR      r6,[sp,#0xc]
        0x002089e2:    6878        xh      LDR      r0,[r7,#4]
        0x002089e4:    b168        h.      CBZ      r0,0x208a02 ; simp_ble_client_notif_ind_result_cb + 132
;;;700        {
;;;701        	APP_PRINT_INFO1("vsop------------simp_client_cb %d",handle);
        0x002089e6:    4922        "I      LDR      r1,[pc,#136] ; [0x208a70] = 0x8800a34
        0x002089e8:    4623        #F      MOV      r3,r4
        0x002089ea:    2201        ."      MOVS     r2,#1
        0x002089ec:    31dc        .1      ADDS     r1,r1,#0xdc
        0x002089ee:    4650        PF      MOV      r0,r10
        0x002089f0:    f5fff835    ..5.    BL       log_buffer ; 0x7a5e
;;;702            app_result = (*simp_client_cb)(simp_client, conn_id, &cb_data);
        0x002089f4:    481f        .H      LDR      r0,[pc,#124] ; [0x208a74] = 0x20cf28
        0x002089f6:    687b        {h      LDR      r3,[r7,#4]
        0x002089f8:    466a        jF      MOV      r2,sp
        0x002089fa:    4649        IF      MOV      r1,r9
        0x002089fc:    7800        .x      LDRB     r0,[r0,#0]
        0x002089fe:    4798        .G      BLX      r3
        0x00208a00:    4680        .F      MOV      r8,r0
;;;703        }
;;;704    	APP_PRINT_INFO1("vsop------------return %d",handle);
        0x00208a02:    491d        .I      LDR      r1,[pc,#116] ; [0x208a78] = 0x8800b38
        0x00208a04:    4623        #F      MOV      r3,r4
        0x00208a06:    2201        ."      MOVS     r2,#1
        0x00208a08:    4650        PF      MOV      r0,r10
        0x00208a0a:    f5fff828    ..(.    BL       log_buffer ; 0x7a5e
;;;705    
;;;706        return app_result;
        0x00208a0e:    4640        @F      MOV      r0,r8
;;;707    }
        0x00208a10:    e618        ..      B        0x208644 ; simp_ble_client_discover_state_cb + 98
        0x00208a12:    4919        .I      LDR      r1,[pc,#100] ; [0x208a78] = 0x8800b38
        0x00208a14:    3948        H9      SUBS     r1,r1,#0x48
        0x00208a16:    e7f7        ..      B        0x208a08 ; simp_ble_client_notif_ind_result_cb + 138
    simp_ble_client_disconnect_cb
;;;708    
;;;709    static void simp_ble_client_disconnect_cb(uint8_t conn_id)
;;;710    {
        0x00208a18:    b510        ..      PUSH     {r4,lr}
        0x00208a1a:    4917        .I      LDR      r1,[pc,#92] ; [0x208a78] = 0x8800b38
;;; .\..\..\..\src\ble\profile\client\simple_ble_client.c (710)
        0x00208a1c:    4604        .F      MOV      r4,r0
;;;711        APP_PRINT_INFO0("simp_ble_client_disconnect_cb.");
        0x00208a1e:    2200        ."      MOVS     r2,#0
        0x00208a20:    3120         1      ADDS     r1,r1,#0x20
        0x00208a22:    480f        .H      LDR      r0,[pc,#60] ; [0x208a60] = 0x21103002
        0x00208a24:    f5fff81b    ....    BL       log_buffer ; 0x7a5e
;;;712        if (conn_id >= simp_link_num)
        0x00208a28:    480e        .H      LDR      r0,[pc,#56] ; [0x208a64] = 0x20cfa8
        0x00208a2a:    7801        .x      LDRB     r1,[r0,#0]
        0x00208a2c:    428c        .B      CMP      r4,r1
        0x00208a2e:    d309        ..      BCC      0x208a44 ; simp_ble_client_disconnect_cb + 44
;;;713        {
;;;714            PROFILE_PRINT_ERROR1("simp_ble_client_disconnect_cb: failed invalid conn_id %d", conn_id);
        0x00208a30:    4911        .I      LDR      r1,[pc,#68] ; [0x208a78] = 0x8800b38
        0x00208a32:    4623        #F      MOV      r3,r4
        0x00208a34:    4809        .H      LDR      r0,[pc,#36] ; [0x208a5c] = 0x21103302
        0x00208a36:    2201        ."      MOVS     r2,#1
        0x00208a38:    3144        D1      ADDS     r1,r1,#0x44
        0x00208a3a:    e8bd4010    ...@    POP      {r4,lr}
        0x00208a3e:    1e80        ..      SUBS     r0,r0,#2
        0x00208a40:    f5ffb80d    ....    B        log_buffer ; 0x7a5e
;;;715            return;
;;;716        }
;;;717        memset(&simp_table[conn_id], 0, sizeof(T_SIMP_LINK));
        0x00208a44:    eb0401c4    ....    ADD      r1,r4,r4,LSL #3
        0x00208a48:    6880        .h      LDR      r0,[r0,#8]
        0x00208a4a:    e8bd4010    ...@    POP      {r4,lr}
        0x00208a4e:    eb000041    ..A.    ADD      r0,r0,r1,LSL #1
        0x00208a52:    2112        .!      MOVS     r1,#0x12
        0x00208a54:    f651bae2    Q...    B        __aeabi_memclr ; 0x5a01c
    $d
        0x00208a58:    08800654    T...    DCD    142607956
        0x00208a5c:    21103302    .3.!    DCD    554709762
        0x00208a60:    21103002    .0.!    DCD    554708994
        0x00208a64:    0020cfa8    .. .    DCD    2150312
        0x00208a68:    0880076c    l...    DCD    142608236
        0x00208a6c:    08800928    (...    DCD    142608680
        0x00208a70:    08800a34    4...    DCD    142608948
        0x00208a74:    0020cf28    (. .    DCD    2150184
        0x00208a78:    08800b38    8...    DCD    142609208
    $t
    simp_ble_add_client
;;;718        return;
;;;719    }
;;;720    
;;;721    /**
;;;722     * @brief Simple BLE Client Callbacks.
;;;723    */
;;;724    const T_FUN_CLIENT_CBS simp_ble_client_cbs =
;;;725    {
;;;726        simp_ble_client_discover_state_cb,   //!< Discovery State callback function pointer
;;;727        simp_ble_client_discover_result_cb,  //!< Discovery result callback function pointer
;;;728        simp_ble_client_read_result_cb,      //!< Read response callback function pointer
;;;729        simp_ble_client_write_result_cb,     //!< Write result callback function pointer
;;;730        simp_ble_client_notif_ind_result_cb,  //!< Notify Indicate callback function pointer
;;;731        simp_ble_client_disconnect_cb       //!< Link disconnection callback function pointer
;;;732    };
;;;733    
;;;734    /**
;;;735      * @brief      Add simple ble service client to application.
;;;736      * @param[in]  app_cb pointer of app callback function to handle specific client module data.
;;;737      * @param[in]  link_num initialize link num.
;;;738      * @return Client ID of the specific client module.
;;;739      * @retval 0xff failed.
;;;740      * @retval other success.
;;;741      *
;;;742      * <b>Example usage</b>
;;;743      * \code{.c}
;;;744        void app_le_profile_init(void)
;;;745        {
;;;746            client_init(1);
;;;747            simple_ble_client_id = simp_ble_add_client(app_client_callback, APP_MAX_LINKS);
;;;748        }
;;;749      * \endcode
;;;750      */
;;;751    T_CLIENT_ID simp_ble_add_client(P_FUN_GENERAL_APP_CB app_cb, uint8_t link_num)
;;;752    {
        0x00208a7c:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x00208a80:    4607        .F      MOV      r7,r0
        0x00208a82:    460c        .F      MOV      r4,r1
        0x00208a84:    2904        .)      CMP      r1,#4
;;; .\..\..\..\src\ble\profile\client\simple_ble_client.c (752)
        0x00208a86:    d907        ..      BLS      0x208a98 ; simp_ble_add_client + 28
;;;753        uint16_t size;
;;;754        if (link_num > SIMP_MAX_LINKS)
;;;755        {
;;;756            PROFILE_PRINT_ERROR1("simp_ble_add_client: invalid link_num %d", link_num);
        0x00208a88:    460b        .F      MOV      r3,r1
        0x00208a8a:    2201        ."      MOVS     r2,#1
        0x00208a8c:    4916        .I      LDR      r1,[pc,#88] ; [0x208ae8] = 0x8800bb8
        0x00208a8e:    4817        .H      LDR      r0,[pc,#92] ; [0x208aec] = 0x21103300
        0x00208a90:    f5feffe5    ....    BL       log_buffer ; 0x7a5e
;;;757            return 0xff;
        0x00208a94:    20ff        .       MOVS     r0,#0xff
        0x00208a96:    e455        U.      B        0x208344 ; simp_ble_client_read_by_handle + 152
;;;758        }
;;;759        if (false == client_register_spec_client_cb(&simp_client, &simp_ble_client_cbs))
        0x00208a98:    4915        .I      LDR      r1,[pc,#84] ; [0x208af0] = 0x21c874
        0x00208a9a:    4816        .H      LDR      r0,[pc,#88] ; [0x208af4] = 0x20cf28
        0x00208a9c:    f645fc6a    E.j.    BL       client_register_spec_client_cb ; 0x4e374
        0x00208aa0:    4e14        .N      LDR      r6,[pc,#80] ; [0x208af4] = 0x20cf28
        0x00208aa2:    b1b0        ..      CBZ      r0,0x208ad2 ; simp_ble_add_client + 86
;;;760        {
;;;761            simp_client = CLIENT_PROFILE_GENERAL_ID;
;;;762            APP_PRINT_ERROR0("simp_ble_add_client failed");
;;;763            return simp_client;
;;;764        }
;;;765        APP_PRINT_INFO1("simp_ble_add_client: simp_client %d", simp_client);
        0x00208aa4:    4910        .I      LDR      r1,[pc,#64] ; [0x208ae8] = 0x8800bb8
        0x00208aa6:    7833        3x      LDRB     r3,[r6,#0]
        0x00208aa8:    2201        ."      MOVS     r2,#1
        0x00208aaa:    314c        L1      ADDS     r1,r1,#0x4c
        0x00208aac:    4812        .H      LDR      r0,[pc,#72] ; [0x208af8] = 0x21103002
        0x00208aae:    f5feffd6    ....    BL       log_buffer ; 0x7a5e
;;;766    
;;;767        /* register callback for profile to inform application that some events happened. */
;;;768        simp_client_cb = app_cb;
        0x00208ab2:    4d12        .M      LDR      r5,[pc,#72] ; [0x208afc] = 0x20cfa8
        0x00208ab4:    eb0400c4    ....    ADD      r0,r4,r4,LSL #3
        0x00208ab8:    4a0d        .J      LDR      r2,[pc,#52] ; [0x208af0] = 0x21c874
;;;769        simp_link_num = link_num;
        0x00208aba:    606f        o`      STR      r7,[r5,#4]
        0x00208abc:    0041        A.      LSLS     r1,r0,#1
        0x00208abe:    702c        ,p      STRB     r4,[r5,#0]
;;;770        size = simp_link_num * sizeof(T_SIMP_LINK);
;;;771        simp_table = os_mem_zalloc(RAM_TYPE_DATA_ON, size);
        0x00208ac0:    f2403303    @..3    MOV      r3,#0x303
        0x00208ac4:    3218        .2      ADDS     r2,r2,#0x18
        0x00208ac6:    2000        .       MOVS     r0,#0
        0x00208ac8:    f61df976    ..v.    BL       os_mem_zalloc_intern ; 0x25db8
        0x00208acc:    60a8        .`      STR      r0,[r5,#8]
;;;772    
;;;773        return simp_client;
        0x00208ace:    7830        0x      LDRB     r0,[r6,#0]
;;;774    }
        0x00208ad0:    e438        8.      B        0x208344 ; simp_ble_client_read_by_handle + 152
        0x00208ad2:    20ff        .       MOVS     r0,#0xff
        0x00208ad4:    7030        0p      STRB     r0,[r6,#0]
        0x00208ad6:    4904        .I      LDR      r1,[pc,#16] ; [0x208ae8] = 0x8800bb8
        0x00208ad8:    4807        .H      LDR      r0,[pc,#28] ; [0x208af8] = 0x21103002
        0x00208ada:    2200        ."      MOVS     r2,#0
        0x00208adc:    312c        ,1      ADDS     r1,r1,#0x2c
        0x00208ade:    1e80        ..      SUBS     r0,r0,#2
        0x00208ae0:    f5feffbd    ....    BL       log_buffer ; 0x7a5e
        0x00208ae4:    e7f3        ..      B        0x208ace ; simp_ble_add_client + 82
    $d
        0x00208ae6:    0000        ..      DCW    0
        0x00208ae8:    08800bb8    ....    DCD    142609336
        0x00208aec:    21103300    .3.!    DCD    554709760
        0x00208af0:    0021c874    t.!.    DCD    2214004
        0x00208af4:    0020cf28    (. .    DCD    2150184
        0x00208af8:    21103002    .0.!    DCD    554708994
        0x00208afc:    0020cfa8    .. .    DCD    2150312
    $t
    .text
    bas_start_discovery
;;; .\..\..\..\src\ble\profile\client\bas_client.c
;;;62     {
        0x00208b00:    b570        p.      PUSH     {r4-r6,lr}
        0x00208b02:    4605        .F      MOV      r5,r0
;;;63         PROFILE_PRINT_INFO0("bas_start_discovery");
        0x00208b04:    2200        ."      MOVS     r2,#0
        0x00208b06:    49fe        .I      LDR      r1,[pc,#1016] ; [0x208f00] = 0x8800c2c
        0x00208b08:    48fe        .H      LDR      r0,[pc,#1016] ; [0x208f04] = 0x21103302
        0x00208b0a:    f5feffa8    ....    BL       log_buffer ; 0x7a5e
;;;64         if (conn_id >= bas_link_num)
        0x00208b0e:    48fe        .H      LDR      r0,[pc,#1016] ; [0x208f08] = 0x20cfb4
        0x00208b10:    7801        .x      LDRB     r1,[r0,#0]
        0x00208b12:    428d        .B      CMP      r5,r1
        0x00208b14:    d308        ..      BCC      0x208b28 ; bas_start_discovery + 40
;;;65         {
;;;66             PROFILE_PRINT_ERROR1("bas_start_discovery: failed invalid conn_id %d", conn_id);
        0x00208b16:    49fa        .I      LDR      r1,[pc,#1000] ; [0x208f00] = 0x8800c2c
        0x00208b18:    48fa        .H      LDR      r0,[pc,#1000] ; [0x208f04] = 0x21103302
        0x00208b1a:    462b        +F      MOV      r3,r5
        0x00208b1c:    2201        ."      MOVS     r2,#1
        0x00208b1e:    3118        .1      ADDS     r1,r1,#0x18
        0x00208b20:    1e80        ..      SUBS     r0,r0,#2
        0x00208b22:    f5feff9c    ....    BL       log_buffer ; 0x7a5e
;;;67             return false;
        0x00208b26:    e013        ..      B        0x208b50 ; bas_start_discovery + 80
;;;68         }
;;;69         /* First clear handle cache. */
;;;70         memset(&bas_table[conn_id], 0, sizeof(T_BAS_LINK));
        0x00208b28:    6880        .h      LDR      r0,[r0,#8]
        0x00208b2a:    eb050445    ..E.    ADD      r4,r5,r5,LSL #1
        0x00208b2e:    eb000184    ....    ADD      r1,r0,r4,LSL #2
        0x00208b32:    2200        ."      MOVS     r2,#0
        0x00208b34:    600a        .`      STR      r2,[r1,#0]
        0x00208b36:    604a        J`      STR      r2,[r1,#4]
        0x00208b38:    608a        .`      STR      r2,[r1,#8]
;;;71         bas_table[conn_id].disc_state = DISC_BAS_START;
        0x00208b3a:    2101        .!      MOVS     r1,#1
        0x00208b3c:    f8001024    ..$.    STRB     r1,[r0,r4,LSL #2]
;;;72         if (client_by_uuid_srv_discovery(conn_id, bas_client,
        0x00208b40:    48f2        .H      LDR      r0,[pc,#968] ; [0x208f0c] = 0x20cf29
        0x00208b42:    f641020f    A...    MOV      r2,#0x180f
        0x00208b46:    7801        .x      LDRB     r1,[r0,#0]
        0x00208b48:    4628        (F      MOV      r0,r5
        0x00208b4a:    f645fced    E...    BL       client_by_uuid_srv_discovery ; 0x4e528
        0x00208b4e:    b108        ..      CBZ      r0,0x208b54 ; bas_start_discovery + 84
        0x00208b50:    2000        .       MOVS     r0,#0
        0x00208b52:    bd70        p.      POP      {r4-r6,pc}
;;;73                                          GATT_UUID_BATTERY) == GAP_CAUSE_SUCCESS)
;;;74         {
;;;75             return true;
        0x00208b54:    2001        .       MOVS     r0,#1
;;;76         }
;;;77         return false;
;;;78     }
        0x00208b56:    bd70        p.      POP      {r4-r6,pc}
    bas_read_battery_level
;;;79     
;;;80     /**
;;;81       * @brief  Used by application, to read battery level.
;;;82       * @param[in]  conn_id connection ID.
;;;83       * @retval true send request to upper stack success.
;;;84       * @retval false send request to upper stack failed.
;;;85       *
;;;86       * <b>Example usage</b>
;;;87       * \code{.c}
;;;88         static T_USER_CMD_PARSE_RESULT cmd_basread(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;89         {
;;;90             uint8_t conn_id = p_parse_value->dw_param[0];
;;;91             bool ret = false;
;;;92             ret = bas_read_battery_level(conn_id);
;;;93             ......
;;;94         }
;;;95       * \endcode
;;;96       */
;;;97     bool bas_read_battery_level(uint8_t conn_id)
;;;98     {
        0x00208b58:    b510        ..      PUSH     {r4,lr}
;;;99         if (conn_id >= bas_link_num)
        0x00208b5a:    49eb        .I      LDR      r1,[pc,#940] ; [0x208f08] = 0x20cfb4
        0x00208b5c:    4ce9        .L      LDR      r4,[pc,#932] ; [0x208f04] = 0x21103302
        0x00208b5e:    780a        .x      LDRB     r2,[r1,#0]
        0x00208b60:    1ea4        ..      SUBS     r4,r4,#2
        0x00208b62:    4290        .B      CMP      r0,r2
        0x00208b64:    d307        ..      BCC      0x208b76 ; bas_read_battery_level + 30
;;;100        {
;;;101            PROFILE_PRINT_ERROR1("bas_read_battery_level: failed invalid conn_id %d", conn_id);
        0x00208b66:    49e6        .I      LDR      r1,[pc,#920] ; [0x208f00] = 0x8800c2c
        0x00208b68:    4603        .F      MOV      r3,r0
        0x00208b6a:    2201        ."      MOVS     r2,#1
        0x00208b6c:    314c        L1      ADDS     r1,r1,#0x4c
        0x00208b6e:    4620         F      MOV      r0,r4
        0x00208b70:    f5feff75    ..u.    BL       log_buffer ; 0x7a5e
;;;102            return false;
        0x00208b74:    e011        ..      B        0x208b9a ; bas_read_battery_level + 66
;;;103        }
;;;104        if (bas_table[conn_id].hdl_cache[HDL_BAS_BATTERY_LEVEL])
        0x00208b76:    6889        .h      LDR      r1,[r1,#8]
        0x00208b78:    eb000240    ..@.    ADD      r2,r0,r0,LSL #1
        0x00208b7c:    eb010182    ....    ADD      r1,r1,r2,LSL #2
        0x00208b80:    890a        ..      LDRH     r2,[r1,#8]
        0x00208b82:    b122        ".      CBZ      r2,0x208b8e ; bas_read_battery_level + 54
;;;105        {
;;;106            uint16_t handle = bas_table[conn_id].hdl_cache[HDL_BAS_BATTERY_LEVEL];
;;;107            if (client_attr_read(conn_id, bas_client, handle) == GAP_CAUSE_SUCCESS)
        0x00208b84:    49e1        .I      LDR      r1,[pc,#900] ; [0x208f0c] = 0x20cf29
        0x00208b86:    7809        .x      LDRB     r1,[r1,#0]
        0x00208b88:    f645fd93    E...    BL       client_attr_read ; 0x4e6b2
        0x00208b8c:    b138        8.      CBZ      r0,0x208b9e ; bas_read_battery_level + 70
;;;108            {
;;;109                return true;
;;;110            }
;;;111        }
;;;112        PROFILE_PRINT_ERROR0("bas_read_battery_level: false handle = 0");
        0x00208b8e:    49dc        .I      LDR      r1,[pc,#880] ; [0x208f00] = 0x8800c2c
        0x00208b90:    2200        ."      MOVS     r2,#0
        0x00208b92:    3184        .1      ADDS     r1,r1,#0x84
        0x00208b94:    4620         F      MOV      r0,r4
        0x00208b96:    f5feff62    ..b.    BL       log_buffer ; 0x7a5e
;;;113        return false;
        0x00208b9a:    2000        .       MOVS     r0,#0
;;;114    }
        0x00208b9c:    bd10        ..      POP      {r4,pc}
        0x00208b9e:    2001        .       MOVS     r0,#1
        0x00208ba0:    bd10        ..      POP      {r4,pc}
    bas_set_notify
;;;115    /**
;;;116      * @brief  Used by application, to set the notification flag.
;;;117      * @param[in]  conn_id connection ID.
;;;118      * @param[in]  notify value to enable or disable notify.
;;;119      * @retval true send request to upper stack success.
;;;120      * @retval false send request to upper stack failed.
;;;121      *
;;;122      * <b>Example usage</b>
;;;123      * \code{.c}
;;;124        static T_USER_CMD_PARSE_RESULT cmd_bascccd(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;125        {
;;;126            uint8_t conn_id = p_parse_value->dw_param[0];
;;;127            bool notify = p_parse_value->dw_param[1];
;;;128            bool ret;
;;;129            ret = bas_set_notify(conn_id, notify);
;;;130            ......
;;;131        }
;;;132      * \endcode
;;;133      */
;;;134    bool bas_set_notify(uint8_t conn_id, bool notify)
;;;135    {
        0x00208ba2:    b5fe        ..      PUSH     {r1-r7,lr}
        0x00208ba4:    4ed8        .N      LDR      r6,[pc,#864] ; [0x208f08] = 0x20cfb4
        0x00208ba6:    460c        .F      MOV      r4,r1
        0x00208ba8:    4fd6        .O      LDR      r7,[pc,#856] ; [0x208f04] = 0x21103302
        0x00208baa:    7831        1x      LDRB     r1,[r6,#0]
        0x00208bac:    1ebf        ..      SUBS     r7,r7,#2
        0x00208bae:    4288        .B      CMP      r0,r1
        0x00208bb0:    d307        ..      BCC      0x208bc2 ; bas_set_notify + 32
;;;136        if (conn_id >= bas_link_num)
;;;137        {
;;;138            PROFILE_PRINT_ERROR1("bas_set_notify: failed invalid conn_id %d", conn_id);
        0x00208bb2:    49d3        .I      LDR      r1,[pc,#844] ; [0x208f00] = 0x8800c2c
        0x00208bb4:    4603        .F      MOV      r3,r0
        0x00208bb6:    2201        ."      MOVS     r2,#1
        0x00208bb8:    31b0        .1      ADDS     r1,r1,#0xb0
        0x00208bba:    4638        8F      MOV      r0,r7
        0x00208bbc:    f5feff4f    ..O.    BL       log_buffer ; 0x7a5e
;;;139            return false;
        0x00208bc0:    e019        ..      B        0x208bf6 ; bas_set_notify + 84
;;;140        }
;;;141        if (bas_table[conn_id].hdl_cache[HDL_BAS_BATTERY_LEVEL_CCCD])
        0x00208bc2:    68b1        .h      LDR      r1,[r6,#8]
        0x00208bc4:    eb000540    ..@.    ADD      r5,r0,r0,LSL #1
        0x00208bc8:    eb010185    ....    ADD      r1,r1,r5,LSL #2
        0x00208bcc:    894a        J.      LDRH     r2,[r1,#0xa]
        0x00208bce:    b162        b.      CBZ      r2,0x208bea ; bas_set_notify + 72
;;;142        {
;;;143            uint16_t handle = bas_table[conn_id].hdl_cache[HDL_BAS_BATTERY_LEVEL_CCCD];
        0x00208bd0:    b293        ..      UXTH     r3,r2
;;;144            uint16_t length = sizeof(uint16_t);
        0x00208bd2:    2102        .!      MOVS     r1,#2
        0x00208bd4:    aa02        ..      ADD      r2,sp,#8
        0x00208bd6:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x00208bda:    49cc        .I      LDR      r1,[pc,#816] ; [0x208f0c] = 0x20cf29
;;;145            uint16_t cccd_bits = notify ? 1 : 0;
        0x00208bdc:    f8ad4008    ...@    STRH     r4,[sp,#8]
;;;146            if (client_attr_write(conn_id, bas_client, GATT_WRITE_TYPE_REQ, handle,
        0x00208be0:    2201        ."      MOVS     r2,#1
        0x00208be2:    7809        .x      LDRB     r1,[r1,#0]
        0x00208be4:    f645fe5c    E.\.    BL       client_attr_write ; 0x4e8a0
        0x00208be8:    b138        8.      CBZ      r0,0x208bfa ; bas_set_notify + 88
        0x00208bea:    49c5        .I      LDR      r1,[pc,#788] ; [0x208f00] = 0x8800c2c
        0x00208bec:    2200        ."      MOVS     r2,#0
        0x00208bee:    31e0        .1      ADDS     r1,r1,#0xe0
        0x00208bf0:    4638        8F      MOV      r0,r7
        0x00208bf2:    f5feff34    ..4.    BL       log_buffer ; 0x7a5e
        0x00208bf6:    2000        .       MOVS     r0,#0
        0x00208bf8:    bdfe        ..      POP      {r1-r7,pc}
;;;147                                  length, (uint8_t *)&cccd_bits) == GAP_CAUSE_SUCCESS)
;;;148            {
;;;149                bas_table[conn_id].write_notify_value = notify;
        0x00208bfa:    68b0        .h      LDR      r0,[r6,#8]
        0x00208bfc:    eb000085    ....    ADD      r0,r0,r5,LSL #2
        0x00208c00:    7044        Dp      STRB     r4,[r0,#1]
;;;150                return true;
        0x00208c02:    2001        .       MOVS     r0,#1
;;;151            }
;;;152        }
;;;153        PROFILE_PRINT_ERROR0("bas_set_notify: false handle = 0");
;;;154        return false;
;;;155    }
        0x00208c04:    bdfe        ..      POP      {r1-r7,pc}
    bas_read_notify
;;;156    
;;;157    /**
;;;158      * @brief  Used by application, to read the notification flag.
;;;159      * @param[in]  conn_id connection ID.
;;;160      * @retval true send request to upper stack success.
;;;161      * @retval false send request to upper stack failed.
;;;162      *
;;;163      * <b>Example usage</b>
;;;164      * \code{.c}
;;;165        static T_USER_CMD_PARSE_RESULT cmd_basread(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;166        {
;;;167            uint8_t conn_id = p_parse_value->dw_param[0];
;;;168            bool ret = false;
;;;169            ret = bas_read_notify(conn_id);
;;;170            ......
;;;171        }
;;;172      * \endcode
;;;173      */
;;;174    bool bas_read_notify(uint8_t conn_id)
;;;175    {
        0x00208c06:    b510        ..      PUSH     {r4,lr}
;;;176        if (conn_id >= bas_link_num)
        0x00208c08:    49bf        .I      LDR      r1,[pc,#764] ; [0x208f08] = 0x20cfb4
        0x00208c0a:    4cbe        .L      LDR      r4,[pc,#760] ; [0x208f04] = 0x21103302
        0x00208c0c:    780a        .x      LDRB     r2,[r1,#0]
        0x00208c0e:    1ea4        ..      SUBS     r4,r4,#2
        0x00208c10:    4290        .B      CMP      r0,r2
        0x00208c12:    d306        ..      BCC      0x208c22 ; bas_read_notify + 28
;;;177        {
;;;178            PROFILE_PRINT_ERROR1("bas_read_notify: failed invalid conn_id %d", conn_id);
        0x00208c14:    4603        .F      MOV      r3,r0
        0x00208c16:    2201        ."      MOVS     r2,#1
        0x00208c18:    49bd        .I      LDR      r1,[pc,#756] ; [0x208f10] = 0x8800d30
        0x00208c1a:    4620         F      MOV      r0,r4
        0x00208c1c:    f5feff1f    ....    BL       log_buffer ; 0x7a5e
;;;179            return false;
        0x00208c20:    e011        ..      B        0x208c46 ; bas_read_notify + 64
;;;180        }
;;;181        if (bas_table[conn_id].hdl_cache[HDL_BAS_BATTERY_LEVEL_CCCD])
        0x00208c22:    6889        .h      LDR      r1,[r1,#8]
        0x00208c24:    eb000240    ..@.    ADD      r2,r0,r0,LSL #1
        0x00208c28:    eb010182    ....    ADD      r1,r1,r2,LSL #2
        0x00208c2c:    894a        J.      LDRH     r2,[r1,#0xa]
        0x00208c2e:    b122        ".      CBZ      r2,0x208c3a ; bas_read_notify + 52
;;;182        {
;;;183            uint16_t handle = bas_table[conn_id].hdl_cache[HDL_BAS_BATTERY_LEVEL_CCCD];
;;;184            if (client_attr_read(conn_id, bas_client, handle) == GAP_CAUSE_SUCCESS)
        0x00208c30:    49b6        .I      LDR      r1,[pc,#728] ; [0x208f0c] = 0x20cf29
        0x00208c32:    7809        .x      LDRB     r1,[r1,#0]
        0x00208c34:    f645fd3d    E.=.    BL       client_attr_read ; 0x4e6b2
        0x00208c38:    b138        8.      CBZ      r0,0x208c4a ; bas_read_notify + 68
;;;185            {
;;;186                return true;
;;;187            }
;;;188        }
;;;189        PROFILE_PRINT_ERROR0("bas_read_battery_level: false handle = 0");
        0x00208c3a:    49b5        .I      LDR      r1,[pc,#724] ; [0x208f10] = 0x8800d30
        0x00208c3c:    2200        ."      MOVS     r2,#0
        0x00208c3e:    3130        01      ADDS     r1,r1,#0x30
        0x00208c40:    4620         F      MOV      r0,r4
        0x00208c42:    f5feff0c    ....    BL       log_buffer ; 0x7a5e
;;;190        return false;
        0x00208c46:    2000        .       MOVS     r0,#0
;;;191    }
        0x00208c48:    bd10        ..      POP      {r4,pc}
        0x00208c4a:    2001        .       MOVS     r0,#1
        0x00208c4c:    bd10        ..      POP      {r4,pc}
    bas_get_hdl_cache
;;;192    
;;;193    /**
;;;194      * @brief  Used by application, to get handle cache.
;;;195      * @param[in]  conn_id connection ID.
;;;196      * @param[in]  p_hdl_cache pointer of the handle cache table
;;;197      * @param[in]  len the length of handle cache table
;;;198      * @retval true success.
;;;199      * @retval false failed.
;;;200      *
;;;201      * <b>Example usage</b>
;;;202      * \code{.c}
;;;203        static T_USER_CMD_PARSE_RESULT cmd_bashdl(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;204        {
;;;205            uint8_t conn_id = p_parse_value->dw_param[0];
;;;206            uint16_t hdl_cache[HDL_BAS_CACHE_LEN];
;;;207            bool ret = bas_get_hdl_cache(conn_id, hdl_cache,
;;;208                                         sizeof(uint16_t) * HDL_BAS_CACHE_LEN);
;;;209    
;;;210            ......
;;;211        }
;;;212      * \endcode
;;;213      */
;;;214    bool bas_get_hdl_cache(uint8_t conn_id, uint16_t *p_hdl_cache, uint8_t len)
;;;215    {
        0x00208c4e:    b570        p.      PUSH     {r4-r6,lr}
        0x00208c50:    460e        .F      MOV      r6,r1
;;;216        if (conn_id >= bas_link_num)
        0x00208c52:    49ad        .I      LDR      r1,[pc,#692] ; [0x208f08] = 0x20cfb4
        0x00208c54:    4dab        .M      LDR      r5,[pc,#684] ; [0x208f04] = 0x21103302
        0x00208c56:    780b        .x      LDRB     r3,[r1,#0]
        0x00208c58:    1ead        ..      SUBS     r5,r5,#2
        0x00208c5a:    4298        .B      CMP      r0,r3
        0x00208c5c:    d304        ..      BCC      0x208c68 ; bas_get_hdl_cache + 26
;;;217        {
;;;218            PROFILE_PRINT_ERROR1("bas_get_hdl_cache: failed invalid conn_id %d", conn_id);
        0x00208c5e:    49ac        .I      LDR      r1,[pc,#688] ; [0x208f10] = 0x8800d30
        0x00208c60:    2201        ."      MOVS     r2,#1
        0x00208c62:    4603        .F      MOV      r3,r0
        0x00208c64:    315c        \1      ADDS     r1,r1,#0x5c
;;;219            return false;
        0x00208c66:    e011        ..      B        0x208c8c ; bas_get_hdl_cache + 62
;;;220        }
;;;221        if (bas_table[conn_id].disc_state != DISC_BAS_DONE)
        0x00208c68:    688b        .h      LDR      r3,[r1,#8]
        0x00208c6a:    eb000040    ..@.    ADD      r0,r0,r0,LSL #1
        0x00208c6e:    f8134020    .. @    LDRB     r4,[r3,r0,LSL #2]
        0x00208c72:    2c02        .,      CMP      r4,#2
        0x00208c74:    d004        ..      BEQ      0x208c80 ; bas_get_hdl_cache + 50
        0x00208c76:    49a6        .I      LDR      r1,[pc,#664] ; [0x208f10] = 0x8800d30
        0x00208c78:    2201        ."      MOVS     r2,#1
        0x00208c7a:    4623        #F      MOV      r3,r4
;;;222        {
;;;223            PROFILE_PRINT_ERROR1("bas_get_hdl_cache: failed invalid state %d", bas_table[conn_id].disc_state);
        0x00208c7c:    318c        .1      ADDS     r1,r1,#0x8c
;;;224            return false;
        0x00208c7e:    e005        ..      B        0x208c8c ; bas_get_hdl_cache + 62
;;;225        }
;;;226        if (len != sizeof(uint16_t) * HDL_BAS_CACHE_LEN)
        0x00208c80:    2a08        .*      CMP      r2,#8
        0x00208c82:    d008        ..      BEQ      0x208c96 ; bas_get_hdl_cache + 72
;;;227        {
;;;228            PROFILE_PRINT_ERROR1("bas_get_hdl_cache: failed invalid len %d", len);
        0x00208c84:    4613        .F      MOV      r3,r2
        0x00208c86:    49a2        .I      LDR      r1,[pc,#648] ; [0x208f10] = 0x8800d30
        0x00208c88:    2201        ."      MOVS     r2,#1
        0x00208c8a:    31bc        .1      ADDS     r1,r1,#0xbc
        0x00208c8c:    4628        (F      MOV      r0,r5
        0x00208c8e:    f5fefee6    ....    BL       log_buffer ; 0x7a5e
;;;229            return false;
        0x00208c92:    2000        .       MOVS     r0,#0
        0x00208c94:    bd70        p.      POP      {r4-r6,pc}
;;;230        }
;;;231        memcpy(p_hdl_cache, bas_table[conn_id].hdl_cache, len);
        0x00208c96:    eb030180    ....    ADD      r1,r3,r0,LSL #2
        0x00208c9a:    4630        0F      MOV      r0,r6
        0x00208c9c:    1d09        ..      ADDS     r1,r1,#4
        0x00208c9e:    f651f8fc    Q...    BL       __aeabi_memcpy ; 0x59e9a
;;;232        return true;
        0x00208ca2:    2001        .       MOVS     r0,#1
;;;233    }
        0x00208ca4:    bd70        p.      POP      {r4-r6,pc}
    bas_set_hdl_cache
;;;234    
;;;235    /**
;;;236      * @brief  Used by application, to set handle cache.
;;;237      * @param[in]  conn_id connection ID.
;;;238      * @param[in]  p_hdl_cache pointer of the handle cache table
;;;239      * @param[in]  len the length of handle cache table
;;;240      * @retval true success.
;;;241      * @retval false failed.
;;;242      *
;;;243      * <b>Example usage</b>
;;;244      * \code{.c}
;;;245        void app_discov_services(uint8_t conn_id, bool start)
;;;246        {
;;;247            ......
;;;248            if (app_srvs_table.srv_found_flags & APP_DISCOV_BAS_FLAG)
;;;249            {
;;;250                bas_set_hdl_cache(conn_id, app_srvs_table.bas_hdl_cache, sizeof(uint16_t) * HDL_BAS_CACHE_LEN);
;;;251            }
;;;252            ......
;;;253        }
;;;254      * \endcode
;;;255      */
;;;256    bool bas_set_hdl_cache(uint8_t conn_id, uint16_t *p_hdl_cache, uint8_t len)
;;;257    {
        0x00208ca6:    b570        p.      PUSH     {r4-r6,lr}
;;;258        if (conn_id >= bas_link_num)
        0x00208ca8:    4d97        .M      LDR      r5,[pc,#604] ; [0x208f08] = 0x20cfb4
        0x00208caa:    4e96        .N      LDR      r6,[pc,#600] ; [0x208f04] = 0x21103302
        0x00208cac:    782b        +x      LDRB     r3,[r5,#0]
        0x00208cae:    1eb6        ..      SUBS     r6,r6,#2
        0x00208cb0:    4298        .B      CMP      r0,r3
        0x00208cb2:    d304        ..      BCC      0x208cbe ; bas_set_hdl_cache + 24
;;;259        {
;;;260            PROFILE_PRINT_ERROR1("bas_set_hdl_cache: failed invalid conn_id %d", conn_id);
        0x00208cb4:    4996        .I      LDR      r1,[pc,#600] ; [0x208f10] = 0x8800d30
        0x00208cb6:    2201        ."      MOVS     r2,#1
        0x00208cb8:    4603        .F      MOV      r3,r0
        0x00208cba:    31e8        .1      ADDS     r1,r1,#0xe8
;;;261            return false;
        0x00208cbc:    e00e        ..      B        0x208cdc ; bas_set_hdl_cache + 54
;;;262        }
;;;263        if (bas_table[conn_id].disc_state != DISC_BAS_IDLE)
        0x00208cbe:    eb000440    ..@.    ADD      r4,r0,r0,LSL #1
        0x00208cc2:    68a8        .h      LDR      r0,[r5,#8]
        0x00208cc4:    f8103024    ..$0    LDRB     r3,[r0,r4,LSL #2]
        0x00208cc8:    b113        ..      CBZ      r3,0x208cd0 ; bas_set_hdl_cache + 42
;;;264        {
;;;265            PROFILE_PRINT_ERROR1("bas_set_hdl_cache: failed invalid state %d", bas_table[conn_id].disc_state);
        0x00208cca:    2201        ."      MOVS     r2,#1
        0x00208ccc:    4991        .I      LDR      r1,[pc,#580] ; [0x208f14] = 0x8800e48
;;;266            return false;
        0x00208cce:    e005        ..      B        0x208cdc ; bas_set_hdl_cache + 54
;;;267        }
;;;268        if (len != sizeof(uint16_t) * HDL_BAS_CACHE_LEN)
        0x00208cd0:    2a08        .*      CMP      r2,#8
        0x00208cd2:    d008        ..      BEQ      0x208ce6 ; bas_set_hdl_cache + 64
;;;269        {
;;;270            PROFILE_PRINT_ERROR1("bas_set_hdl_cache: failed invalid len %d", len);
        0x00208cd4:    4613        .F      MOV      r3,r2
        0x00208cd6:    498f        .I      LDR      r1,[pc,#572] ; [0x208f14] = 0x8800e48
        0x00208cd8:    2201        ."      MOVS     r2,#1
        0x00208cda:    3130        01      ADDS     r1,r1,#0x30
        0x00208cdc:    4630        0F      MOV      r0,r6
        0x00208cde:    f5fefebe    ....    BL       log_buffer ; 0x7a5e
;;;271            return false;
        0x00208ce2:    2000        .       MOVS     r0,#0
        0x00208ce4:    bd70        p.      POP      {r4-r6,pc}
;;;272        }
;;;273        memcpy(bas_table[conn_id].hdl_cache, p_hdl_cache, len);
        0x00208ce6:    eb000084    ....    ADD      r0,r0,r4,LSL #2
        0x00208cea:    1d00        ..      ADDS     r0,r0,#4
        0x00208cec:    f651f8d5    Q...    BL       __aeabi_memcpy ; 0x59e9a
;;;274        bas_table[conn_id].disc_state = DISC_BAS_DONE;
        0x00208cf0:    68a9        .h      LDR      r1,[r5,#8]
        0x00208cf2:    2002        .       MOVS     r0,#2
        0x00208cf4:    f8010024    ..$.    STRB     r0,[r1,r4,LSL #2]
;;;275        return true;
        0x00208cf8:    2001        .       MOVS     r0,#1
;;;276    }
        0x00208cfa:    bd70        p.      POP      {r4-r6,pc}
    bas_client_discover_state_cb
;;;277    
;;;278    static bool bas_start_char_discovery(uint8_t conn_id)
;;;279    {
;;;280        uint16_t start_handle;
;;;281        uint16_t end_handle;
;;;282    
;;;283        PROFILE_PRINT_INFO0("bas_start_char_discovery");
;;;284        start_handle = bas_table[conn_id].hdl_cache[HDL_BAS_SRV_START];
;;;285        end_handle = bas_table[conn_id].hdl_cache[HDL_BAS_SRV_END];
;;;286        if (client_all_char_discovery(conn_id, bas_client, start_handle,
;;;287                                      end_handle) == GAP_CAUSE_SUCCESS)
;;;288        {
;;;289            return true;
;;;290        }
;;;291        return false;
;;;292    }
;;;293    
;;;294    static bool bas_start_char_descriptor_discovery(uint8_t conn_id)
;;;295    {
;;;296        uint16_t start_handle;
;;;297        uint16_t end_handle;
;;;298    
;;;299        PROFILE_PRINT_INFO0("bas_start_char_descriptor_discovery");
;;;300        start_handle = bas_table[conn_id].hdl_cache[HDL_BAS_BATTERY_LEVEL];
;;;301        end_handle = bas_table[conn_id].hdl_cache[HDL_BAS_SRV_END];
;;;302        if (client_all_char_descriptor_discovery(conn_id, bas_client, start_handle,
;;;303                                                 end_handle) == GAP_CAUSE_SUCCESS)
;;;304        {
;;;305            return true;
;;;306        }
;;;307        return false;
;;;308    }
;;;309    
;;;310    static void bas_client_discover_state_cb(uint8_t conn_id,  T_DISCOVERY_STATE discovery_state)
;;;311    {
        0x00208cfc:    e92d47fc    -..G    PUSH     {r2-r10,lr}
        0x00208d00:    4605        .F      MOV      r5,r0
        0x00208d02:    4688        .F      MOV      r8,r1
        0x00208d04:    460b        .F      MOV      r3,r1
        0x00208d06:    2000        .       MOVS     r0,#0
        0x00208d08:    4982        .I      LDR      r1,[pc,#520] ; [0x208f14] = 0x8800e48
        0x00208d0a:    f8dfa1f8    ....    LDR      r10,[pc,#504] ; [0x208f04] = 0x21103302
        0x00208d0e:    f88d0000    ....    STRB     r0,[sp,#0]
        0x00208d12:    2201        ."      MOVS     r2,#1
        0x00208d14:    31a0        .1      ADDS     r1,r1,#0xa0
        0x00208d16:    4650        PF      MOV      r0,r10
        0x00208d18:    f5fefea1    ....    BL       log_buffer ; 0x7a5e
        0x00208d1c:    4e7a        zN      LDR      r6,[pc,#488] ; [0x208f08] = 0x20cfb4
        0x00208d1e:    eb050445    ..E.    ADD      r4,r5,r5,LSL #1
        0x00208d22:    68b0        .h      LDR      r0,[r6,#8]
        0x00208d24:    f8101024    ..$.    LDRB     r1,[r0,r4,LSL #2]
        0x00208d28:    2901        .)      CMP      r1,#1
        0x00208d2a:    d116        ..      BNE      0x208d5a ; bas_client_discover_state_cb + 94
        0x00208d2c:    2703        .'      MOVS     r7,#3
        0x00208d2e:    f8df91dc    ....    LDR      r9,[pc,#476] ; [0x208f0c] = 0x20cf29
        0x00208d32:    f1b80f02    ....    CMP      r8,#2
        0x00208d36:    d012        ..      BEQ      0x208d5e ; bas_client_discover_state_cb + 98
        0x00208d38:    2102        .!      MOVS     r1,#2
        0x00208d3a:    f1b80f06    ....    CMP      r8,#6
        0x00208d3e:    d028        (.      BEQ      0x208d92 ; bas_client_discover_state_cb + 150
        0x00208d40:    f1b80f0a    ....    CMP      r8,#0xa
        0x00208d44:    d03e        >.      BEQ      0x208dc4 ; bas_client_discover_state_cb + 200
        0x00208d46:    f1b80f0b    ....    CMP      r8,#0xb
        0x00208d4a:    d01f        ..      BEQ      0x208d8c ; bas_client_discover_state_cb + 144
        0x00208d4c:    4971        qI      LDR      r1,[pc,#452] ; [0x208f14] = 0x8800e48
        0x00208d4e:    2200        ."      MOVS     r2,#0
        0x00208d50:    31d8        .1      ADDS     r1,r1,#0xd8
        0x00208d52:    f1aa0002    ....    SUB      r0,r10,#2
        0x00208d56:    f5fefe82    ....    BL       log_buffer ; 0x7a5e
        0x00208d5a:    e8bd87fc    ....    POP      {r2-r10,pc}
        0x00208d5e:    eb000184    ....    ADD      r1,r0,r4,LSL #2
        0x00208d62:    888a        ..      LDRH     r2,[r1,#4]
        0x00208d64:    b90a        ..      CBNZ     r2,0x208d6a ; bas_client_discover_state_cb + 110
        0x00208d66:    88c9        ..      LDRH     r1,[r1,#6]
        0x00208d68:    b181        ..      CBZ      r1,0x208d8c ; bas_client_discover_state_cb + 144
;;; .\..\..\..\src\ble\profile\client\bas_client.c (283)
        0x00208d6a:    496a        jI      LDR      r1,[pc,#424] ; [0x208f14] = 0x8800e48
        0x00208d6c:    2200        ."      MOVS     r2,#0
        0x00208d6e:    315c        \1      ADDS     r1,r1,#0x5c
        0x00208d70:    4650        PF      MOV      r0,r10
        0x00208d72:    f5fefe74    ..t.    BL       log_buffer ; 0x7a5e
;;;284        start_handle = bas_table[conn_id].hdl_cache[HDL_BAS_SRV_START];
        0x00208d76:    68b0        .h      LDR      r0,[r6,#8]
        0x00208d78:    f8991000    ....    LDRB     r1,[r9,#0]
        0x00208d7c:    eb000084    ....    ADD      r0,r0,r4,LSL #2
        0x00208d80:    8882        ..      LDRH     r2,[r0,#4]
;;;285        end_handle = bas_table[conn_id].hdl_cache[HDL_BAS_SRV_END];
        0x00208d82:    88c3        ..      LDRH     r3,[r0,#6]
;;;286        if (client_all_char_discovery(conn_id, bas_client, start_handle,
        0x00208d84:    4628        (F      MOV      r0,r5
        0x00208d86:    f645fc1a    E...    BL       client_all_char_discovery ; 0x4e5be
        0x00208d8a:    e017        ..      B        0x208dbc ; bas_client_discover_state_cb + 192
        0x00208d8c:    f8007024    ..$p    STRB     r7,[r0,r4,LSL #2]
        0x00208d90:    e01a        ..      B        0x208dc8 ; bas_client_discover_state_cb + 204
        0x00208d92:    eb000284    ....    ADD      r2,r0,r4,LSL #2
        0x00208d96:    7892        .x      LDRB     r2,[r2,#2]
        0x00208d98:    06d2        ..      LSLS     r2,r2,#27
        0x00208d9a:    d513        ..      BPL      0x208dc4 ; bas_client_discover_state_cb + 200
;;;287                                      end_handle) == GAP_CAUSE_SUCCESS)
;;;288        {
;;;289            return true;
;;;290        }
;;;291        return false;
;;;292    }
;;;293    
;;;294    static bool bas_start_char_descriptor_discovery(uint8_t conn_id)
;;;295    {
;;;296        uint16_t start_handle;
;;;297        uint16_t end_handle;
;;;298    
;;;299        PROFILE_PRINT_INFO0("bas_start_char_descriptor_discovery");
        0x00208d9c:    495d        ]I      LDR      r1,[pc,#372] ; [0x208f14] = 0x8800e48
        0x00208d9e:    2200        ."      MOVS     r2,#0
        0x00208da0:    3178        x1      ADDS     r1,r1,#0x78
        0x00208da2:    4650        PF      MOV      r0,r10
        0x00208da4:    f5fefe5b    ..[.    BL       log_buffer ; 0x7a5e
;;;300        start_handle = bas_table[conn_id].hdl_cache[HDL_BAS_BATTERY_LEVEL];
        0x00208da8:    68b0        .h      LDR      r0,[r6,#8]
        0x00208daa:    f8991000    ....    LDRB     r1,[r9,#0]
        0x00208dae:    eb000084    ....    ADD      r0,r0,r4,LSL #2
        0x00208db2:    8902        ..      LDRH     r2,[r0,#8]
;;;301        end_handle = bas_table[conn_id].hdl_cache[HDL_BAS_SRV_END];
        0x00208db4:    88c3        ..      LDRH     r3,[r0,#6]
;;;302        if (client_all_char_descriptor_discovery(conn_id, bas_client, start_handle,
        0x00208db6:    4628        (F      MOV      r0,r5
        0x00208db8:    f645fc64    E.d.    BL       client_all_char_descriptor_discovery ; 0x4e684
        0x00208dbc:    2800        .(      CMP      r0,#0
        0x00208dbe:    d0cc        ..      BEQ      0x208d5a ; bas_client_discover_state_cb + 94
;;;303                                                 end_handle) == GAP_CAUSE_SUCCESS)
;;;304        {
;;;305            return true;
;;;306        }
;;;307        return false;
;;;308    }
;;;309    
;;;310    static void bas_client_discover_state_cb(uint8_t conn_id,  T_DISCOVERY_STATE discovery_state)
;;;311    {
;;;312        bool cb_flag = false;
;;;313        T_BAS_CLIENT_CB_DATA cb_data;
;;;314        cb_data.cb_type = BAS_CLIENT_CB_TYPE_DISC_STATE;
;;;315    
;;;316        PROFILE_PRINT_INFO1("bas_client_discover_state_cb: discovery_state = %d", discovery_state);
;;;317        if (bas_table[conn_id].disc_state == DISC_BAS_START)
;;;318        {
;;;319            switch (discovery_state)
;;;320            {
;;;321            case DISC_STATE_SRV_DONE:
;;;322                /* Indicate that service handle found. Start discover characteristic. */
;;;323                if ((bas_table[conn_id].hdl_cache[HDL_BAS_SRV_START] != 0)
;;;324                    || (bas_table[conn_id].hdl_cache[HDL_BAS_SRV_END] != 0))
;;;325                {
;;;326                    if (bas_start_char_discovery(conn_id) == false)
;;;327                    {
;;;328                        bas_table[conn_id].disc_state = DISC_BAS_FAILED;
;;;329                        cb_flag = true;
;;;330                    }
;;;331                }
;;;332                /* No BAS handle found. Discover procedure complete. */
;;;333                else
;;;334                {
;;;335                    bas_table[conn_id].disc_state = DISC_BAS_FAILED;
;;;336                    cb_flag = true;
;;;337                }
;;;338                break;
;;;339            case DISC_STATE_CHAR_DONE:
;;;340                if (bas_table[conn_id].properties & GATT_CHAR_PROP_NOTIFY)
;;;341                {
;;;342                    //discovery cccd
;;;343                    if (bas_start_char_descriptor_discovery(conn_id) == false)
;;;344                    {
;;;345                        bas_table[conn_id].disc_state = DISC_BAS_FAILED;
;;;346                        cb_flag = true;
        0x00208dc0:    68b0        .h      LDR      r0,[r6,#8]
        0x00208dc2:    e7e3        ..      B        0x208d8c ; bas_client_discover_state_cb + 144
;;;347                    }
;;;348                }
;;;349                else
;;;350                {
;;;351                    bas_table[conn_id].disc_state = DISC_BAS_DONE;
        0x00208dc4:    f8001024    ..$.    STRB     r1,[r0,r4,LSL #2]
;;;352                    cb_flag = true;
;;;353                }
;;;354                break;
;;;355    
;;;356            case DISC_STATE_CHAR_DESCRIPTOR_DONE:
;;;357                bas_table[conn_id].disc_state = DISC_BAS_DONE;
;;;358                cb_flag = true;
;;;359                break;
;;;360    
;;;361            case DISC_STATE_FAILED:
;;;362                bas_table[conn_id].disc_state = DISC_BAS_FAILED;
;;;363                cb_flag = true;
;;;364                break;
;;;365    
;;;366            default:
;;;367                PROFILE_PRINT_ERROR0("Invalid Discovery State!");
;;;368                break;
;;;369            }
;;;370        }
;;;371    
;;;372        /* Send discover state to application if needed. */
;;;373        if (cb_flag && bas_client_cb)
        0x00208dc8:    6873        sh      LDR      r3,[r6,#4]
        0x00208dca:    2b00        .+      CMP      r3,#0
        0x00208dcc:    d0c5        ..      BEQ      0x208d5a ; bas_client_discover_state_cb + 94
;;;374        {
;;;375            cb_data.cb_content.disc_state = bas_table[conn_id].disc_state;
        0x00208dce:    68b0        .h      LDR      r0,[r6,#8]
        0x00208dd0:    466a        jF      MOV      r2,sp
        0x00208dd2:    4629        )F      MOV      r1,r5
        0x00208dd4:    f8100024    ..$.    LDRB     r0,[r0,r4,LSL #2]
        0x00208dd8:    f88d0002    ....    STRB     r0,[sp,#2]
;;;376            (*bas_client_cb)(bas_client, conn_id, &cb_data);
        0x00208ddc:    f8990000    ....    LDRB     r0,[r9,#0]
        0x00208de0:    4798        .G      BLX      r3
;;;377        }
;;;378        return;
;;;379    }
        0x00208de2:    e7ba        ..      B        0x208d5a ; bas_client_discover_state_cb + 94
    bas_client_discover_result_cb
;;;380    
;;;381    
;;;382    static void bas_client_discover_result_cb(uint8_t conn_id,  T_DISCOVERY_RESULT_TYPE result_type,
;;;383                                              T_DISCOVERY_RESULT_DATA result_data)
;;;384    {
        0x00208de4:    b570        p.      PUSH     {r4-r6,lr}
        0x00208de6:    460e        .F      MOV      r6,r1
        0x00208de8:    460b        .F      MOV      r3,r1
        0x00208dea:    494a        JI      LDR      r1,[pc,#296] ; [0x208f14] = 0x8800e48
;;; .\..\..\..\src\ble\profile\client\bas_client.c (384)
        0x00208dec:    4614        .F      MOV      r4,r2
        0x00208dee:    4605        .F      MOV      r5,r0
;;;385        PROFILE_PRINT_INFO1("bas_client_discover_result_cb: result_type = %d", result_type);
        0x00208df0:    2201        ."      MOVS     r2,#1
        0x00208df2:    31f4        .1      ADDS     r1,r1,#0xf4
        0x00208df4:    4843        CH      LDR      r0,[pc,#268] ; [0x208f04] = 0x21103302
        0x00208df6:    f5fefe32    ..2.    BL       log_buffer ; 0x7a5e
;;;386        if (bas_table[conn_id].disc_state == DISC_BAS_START)
        0x00208dfa:    4843        CH      LDR      r0,[pc,#268] ; [0x208f08] = 0x20cfb4
        0x00208dfc:    eb050545    ..E.    ADD      r5,r5,r5,LSL #1
        0x00208e00:    6880        .h      LDR      r0,[r0,#8]
        0x00208e02:    f8101025    ..%.    LDRB     r1,[r0,r5,LSL #2]
        0x00208e06:    2901        .)      CMP      r1,#1
        0x00208e08:    d113        ..      BNE      0x208e32 ; bas_client_discover_result_cb + 78
;;;387        {
;;;388            switch (result_type)
        0x00208e0a:    2e02        ..      CMP      r6,#2
        0x00208e0c:    d00b        ..      BEQ      0x208e26 ; bas_client_discover_result_cb + 66
        0x00208e0e:    2e03        ..      CMP      r6,#3
        0x00208e10:    d010        ..      BEQ      0x208e34 ; bas_client_discover_result_cb + 80
        0x00208e12:    2e05        ..      CMP      r6,#5
        0x00208e14:    d01a        ..      BEQ      0x208e4c ; bas_client_discover_result_cb + 104
        0x00208e16:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00208e1a:    483a        :H      LDR      r0,[pc,#232] ; [0x208f04] = 0x21103302
        0x00208e1c:    2200        ."      MOVS     r2,#0
        0x00208e1e:    493e        >I      LDR      r1,[pc,#248] ; [0x208f18] = 0x8800f70
        0x00208e20:    1e80        ..      SUBS     r0,r0,#2
        0x00208e22:    f5febe1c    ....    B        log_buffer ; 0x7a5e
;;;389            {
;;;390            case DISC_RESULT_SRV_DATA:
;;;391                bas_table[conn_id].hdl_cache[HDL_BAS_SRV_START] =
        0x00208e26:    eb000085    ....    ADD      r0,r0,r5,LSL #2
        0x00208e2a:    8821        !.      LDRH     r1,[r4,#0]
        0x00208e2c:    8081        ..      STRH     r1,[r0,#4]
;;;392                    result_data.p_srv_disc_data->att_handle;
;;;393                bas_table[conn_id].hdl_cache[HDL_BAS_SRV_END] =
        0x00208e2e:    8861        a.      LDRH     r1,[r4,#2]
        0x00208e30:    80c1        ..      STRH     r1,[r0,#6]
        0x00208e32:    bd70        p.      POP      {r4-r6,pc}
        0x00208e34:    88e2        ..      LDRH     r2,[r4,#6]
;;;394                    result_data.p_srv_disc_data->end_group_handle;
;;;395                break;
;;;396    
;;;397            case DISC_RESULT_CHAR_UUID16:
;;;398                {
;;;399                    uint16_t handle;
;;;400                    handle = result_data.p_char_uuid16_disc_data->value_handle;
        0x00208e36:    88a1        ..      LDRH     r1,[r4,#4]
;;;401                    if (result_data.p_char_uuid16_disc_data->uuid16 == GATT_UUID_CHAR_BAS_LEVEL)
        0x00208e38:    f5a25328    ..(S    SUB      r3,r2,#0x2a00
        0x00208e3c:    3b19        .;      SUBS     r3,r3,#0x19
        0x00208e3e:    d1f8        ..      BNE      0x208e32 ; bas_client_discover_result_cb + 78
;;;402                    {
;;;403                        bas_table[conn_id].hdl_cache[HDL_BAS_BATTERY_LEVEL] = handle;
        0x00208e40:    eb000085    ....    ADD      r0,r0,r5,LSL #2
        0x00208e44:    8101        ..      STRH     r1,[r0,#8]
;;;404                        bas_table[conn_id].properties = result_data.p_char_uuid16_disc_data->properties;
        0x00208e46:    8861        a.      LDRH     r1,[r4,#2]
        0x00208e48:    8041        A.      STRH     r1,[r0,#2]
        0x00208e4a:    bd70        p.      POP      {r4-r6,pc}
;;;405                    }
;;;406                }
;;;407                break;
;;;408    
;;;409            case DISC_RESULT_CHAR_DESC_UUID16:
;;;410                if (result_data.p_char_desc_uuid16_disc_data->uuid16 == GATT_UUID_CHAR_CLIENT_CONFIG)
        0x00208e4c:    8861        a.      LDRH     r1,[r4,#2]
        0x00208e4e:    f5a15224    ..$R    SUB      r2,r1,#0x2900
        0x00208e52:    3a02        .:      SUBS     r2,#2
        0x00208e54:    d1f9        ..      BNE      0x208e4a ; bas_client_discover_result_cb + 102
;;;411                {
;;;412                    bas_table[conn_id].hdl_cache[HDL_BAS_BATTERY_LEVEL_CCCD] =
        0x00208e56:    eb000085    ....    ADD      r0,r0,r5,LSL #2
        0x00208e5a:    8821        !.      LDRH     r1,[r4,#0]
        0x00208e5c:    8141        A.      STRH     r1,[r0,#0xa]
;;;413                        result_data.p_char_desc_uuid16_disc_data->handle;
;;;414                }
;;;415                break;
;;;416    
;;;417            default:
;;;418                PROFILE_PRINT_ERROR0("Invalid Discovery Result Type!");
;;;419                break;
;;;420            }
;;;421        }
;;;422    
;;;423        return;
;;;424    }
        0x00208e5e:    bd70        p.      POP      {r4-r6,pc}
    bas_client_write_result_cb
;;;425    
;;;426    static void bas_client_write_result_cb(uint8_t conn_id, T_GATT_WRITE_TYPE type,
;;;427                                           uint16_t handle,
;;;428                                           uint16_t cause,
;;;429                                           uint8_t credits)
;;;430    {
        0x00208e60:    e92d43fe    -..C    PUSH     {r1-r9,lr}
        0x00208e64:    4f28        (O      LDR      r7,[pc,#160] ; [0x208f08] = 0x20cfb4
;;; .\..\..\..\src\ble\profile\client\bas_client.c (430)
        0x00208e66:    4681        .F      MOV      r9,r0
        0x00208e68:    eb000449    ..I.    ADD      r4,r0,r9,LSL #1
        0x00208e6c:    68b8        .h      LDR      r0,[r7,#8]
        0x00208e6e:    461d        .F      MOV      r5,r3
;;;431        T_BAS_CLIENT_CB_DATA cb_data;
;;;432        uint16_t *hdl_cache;
;;;433        hdl_cache = bas_table[conn_id].hdl_cache;
        0x00208e70:    eb000684    ....    ADD      r6,r0,r4,LSL #2
;;;434        cb_data.cb_type = BAS_CLIENT_CB_TYPE_WRITE_RESULT;
        0x00208e74:    2002        .       MOVS     r0,#2
        0x00208e76:    9300        ..      STR      r3,[sp,#0]
        0x00208e78:    4690        .F      MOV      r8,r2
        0x00208e7a:    4613        .F      MOV      r3,r2
        0x00208e7c:    4926        &I      LDR      r1,[pc,#152] ; [0x208f18] = 0x8800f70
        0x00208e7e:    f88d0004    ....    STRB     r0,[sp,#4]
;;;435    
;;;436        PROFILE_PRINT_INFO2("bas_client_write_result_cb: handle 0x%x, cause 0x%x", handle, cause);
        0x00208e82:    4602        .F      MOV      r2,r0
        0x00208e84:    3124        $1      ADDS     r1,r1,#0x24
        0x00208e86:    481f        .H      LDR      r0,[pc,#124] ; [0x208f04] = 0x21103302
        0x00208e88:    f5fefde9    ....    BL       log_buffer ; 0x7a5e
;;;437        cb_data.cb_content.write_result.cause = cause;
        0x00208e8c:    f8ad5008    ...P    STRH     r5,[sp,#8]
;;;438    
;;;439        if (handle == hdl_cache[HDL_BAS_BATTERY_LEVEL_CCCD])
        0x00208e90:    8971        q.      LDRH     r1,[r6,#0xa]
        0x00208e92:    4541        AE      CMP      r1,r8
        0x00208e94:    d111        ..      BNE      0x208eba ; bas_client_write_result_cb + 90
;;;440        {
;;;441            if (bas_table[conn_id].write_notify_value)
        0x00208e96:    68b8        .h      LDR      r0,[r7,#8]
        0x00208e98:    eb000084    ....    ADD      r0,r0,r4,LSL #2
        0x00208e9c:    7840        @x      LDRB     r0,[r0,#1]
        0x00208e9e:    b108        ..      CBZ      r0,0x208ea4 ; bas_client_write_result_cb + 68
;;;442            {
;;;443                cb_data.cb_content.write_result.type = BAS_WRITE_NOTIFY_ENABLE;
        0x00208ea0:    2000        .       MOVS     r0,#0
        0x00208ea2:    e000        ..      B        0x208ea6 ; bas_client_write_result_cb + 70
        0x00208ea4:    2001        .       MOVS     r0,#1
        0x00208ea6:    f88d0006    ....    STRB     r0,[sp,#6]
;;;444            }
;;;445            else
;;;446            {
;;;447                cb_data.cb_content.write_result.type = BAS_WRITE_NOTIFY_DISABLE;
;;;448            }
;;;449        }
;;;450        else
;;;451        {
;;;452            return;
;;;453        }
;;;454    
;;;455        if (bas_client_cb)
        0x00208eaa:    687b        {h      LDR      r3,[r7,#4]
        0x00208eac:    2b00        .+      CMP      r3,#0
        0x00208eae:    d004        ..      BEQ      0x208eba ; bas_client_write_result_cb + 90
;;;456        {
;;;457            (*bas_client_cb)(bas_client, conn_id, &cb_data);
        0x00208eb0:    4816        .H      LDR      r0,[pc,#88] ; [0x208f0c] = 0x20cf29
        0x00208eb2:    aa01        ..      ADD      r2,sp,#4
        0x00208eb4:    4649        IF      MOV      r1,r9
        0x00208eb6:    7800        .x      LDRB     r0,[r0,#0]
        0x00208eb8:    4798        .G      BLX      r3
;;;458        }
;;;459        return;
;;;460    }
        0x00208eba:    e8bd83fe    ....    POP      {r1-r9,pc}
    bas_client_read_result_cb
;;;461    
;;;462    static void bas_client_read_result_cb(uint8_t conn_id,  uint16_t cause,
;;;463                                          uint16_t handle, uint16_t value_size, uint8_t *p_value)
;;;464    {
        0x00208ebe:    e92d4ffe    -..O    PUSH     {r1-r11,lr}
        0x00208ec2:    f8dfa044    ..D.    LDR      r10,[pc,#68] ; [0x208f08] = 0x20cfb4
        0x00208ec6:    460c        .F      MOV      r4,r1
        0x00208ec8:    4683        .F      MOV      r11,r0
        0x00208eca:    eb00014b    ..K.    ADD      r1,r0,r11,LSL #1
        0x00208ece:    f8da0008    ....    LDR      r0,[r10,#8]
        0x00208ed2:    4699        .F      MOV      r9,r3
        0x00208ed4:    eb000581    ....    ADD      r5,r0,r1,LSL #2
        0x00208ed8:    490f        .I      LDR      r1,[pc,#60] ; [0x208f18] = 0x8800f70
        0x00208eda:    4690        .F      MOV      r8,r2
        0x00208edc:    2701        .'      MOVS     r7,#1
        0x00208ede:    4613        .F      MOV      r3,r2
;;;465        T_BAS_CLIENT_CB_DATA cb_data;
;;;466        uint16_t *hdl_cache;
;;;467        hdl_cache = bas_table[conn_id].hdl_cache;
        0x00208ee0:    9e0c        ..      LDR      r6,[sp,#0x30]
;;;468        cb_data.cb_type = BAS_CLIENT_CB_TYPE_READ_RESULT;
        0x00208ee2:    f88d7004    ...p    STRB     r7,[sp,#4]
;;;469    
;;;470        PROFILE_PRINT_INFO2("bas_client_read_result_cb: handle 0x%x, cause 0x%x", handle, cause);
        0x00208ee6:    2202        ."      MOVS     r2,#2
        0x00208ee8:    315c        \1      ADDS     r1,r1,#0x5c
        0x00208eea:    4806        .H      LDR      r0,[pc,#24] ; [0x208f04] = 0x21103302
        0x00208eec:    1d2d        -.      ADDS     r5,r5,#4
        0x00208eee:    9400        ..      STR      r4,[sp,#0]
        0x00208ef0:    f5fefdb5    ....    BL       log_buffer ; 0x7a5e
        0x00208ef4:    4803        .H      LDR      r0,[pc,#12] ; [0x208f04] = 0x21103302
;;;471        cb_data.cb_content.read_result.cause = cause;
        0x00208ef6:    f8ad4008    ...@    STRH     r4,[sp,#8]
;;;472    
;;;473        if (handle == hdl_cache[HDL_BAS_BATTERY_LEVEL_CCCD])
        0x00208efa:    88ea        ..      LDRH     r2,[r5,#6]
        0x00208efc:    1e80        ..      SUBS     r0,r0,#2
        0x00208efe:    e00d        ..      B        0x208f1c ; bas_client_read_result_cb + 94
    $d
        0x00208f00:    08800c2c    ,...    DCD    142609452
        0x00208f04:    21103302    .3.!    DCD    554709762
        0x00208f08:    0020cfb4    .. .    DCD    2150324
        0x00208f0c:    0020cf29    ). .    DCD    2150185
        0x00208f10:    08800d30    0...    DCD    142609712
        0x00208f14:    08800e48    H...    DCD    142609992
        0x00208f18:    08800f70    p...    DCD    142610288
    $t
        0x00208f1c:    4542        BE      CMP      r2,r8
        0x00208f1e:    d117        ..      BNE      0x208f50 ; bas_client_read_result_cb + 146
;;;474        {
;;;475            cb_data.cb_content.read_result.type = BAS_READ_NOTIFY;
        0x00208f20:    2100        .!      MOVS     r1,#0
        0x00208f22:    f88d1006    ....    STRB     r1,[sp,#6]
;;;476            if (cause == GAP_SUCCESS)
        0x00208f26:    bb44        D.      CBNZ     r4,0x208f7a ; bas_client_read_result_cb + 188
;;;477            {
;;;478                uint16_t ccc_bit;
;;;479                if (value_size != 2)
        0x00208f28:    464a        JF      MOV      r2,r9
        0x00208f2a:    f1b90f02    ....    CMP      r9,#2
        0x00208f2e:    d003        ..      BEQ      0x208f38 ; bas_client_read_result_cb + 122
;;;480                {
;;;481                    PROFILE_PRINT_ERROR1("bas_client_read_result_cb: invalid cccd len %d", value_size);
        0x00208f30:    4613        .F      MOV      r3,r2
        0x00208f32:    2201        ."      MOVS     r2,#1
        0x00208f34:    4950        PI      LDR      r1,[pc,#320] ; [0x209078] = 0x8801004
;;;482                    return;
        0x00208f36:    e019        ..      B        0x208f6c ; bas_client_read_result_cb + 174
;;;483                }
;;;484                LE_ARRAY_TO_UINT16(ccc_bit, p_value);
        0x00208f38:    7830        0x      LDRB     r0,[r6,#0]
        0x00208f3a:    7872        rx      LDRB     r2,[r6,#1]
        0x00208f3c:    eb002002    ...     ADD      r0,r0,r2,LSL #8
;;;485    
;;;486                if (ccc_bit & GATT_CLIENT_CHAR_CONFIG_NOTIFY)
        0x00208f40:    07c0        ..      LSLS     r0,r0,#31
        0x00208f42:    d002        ..      BEQ      0x208f4a ; bas_client_read_result_cb + 140
;;;487                {
;;;488                    cb_data.cb_content.read_result.data.notify = true;
        0x00208f44:    f88d7007    ...p    STRB     r7,[sp,#7]
        0x00208f48:    e017        ..      B        0x208f7a ; bas_client_read_result_cb + 188
;;;489                }
;;;490                else
;;;491                {
;;;492                    cb_data.cb_content.read_result.data.notify = false;
        0x00208f4a:    f88d1007    ....    STRB     r1,[sp,#7]
        0x00208f4e:    e014        ..      B        0x208f7a ; bas_client_read_result_cb + 188
;;;493                }
;;;494            }
;;;495        }
;;;496        else if (handle == hdl_cache[HDL_BAS_BATTERY_LEVEL])
        0x00208f50:    88aa        ..      LDRH     r2,[r5,#4]
        0x00208f52:    4542        BE      CMP      r2,r8
        0x00208f54:    d10c        ..      BNE      0x208f70 ; bas_client_read_result_cb + 178
;;;497        {
;;;498            cb_data.cb_content.read_result.type = BAS_READ_BATTERY_LEVEL;
        0x00208f56:    f88d7006    ...p    STRB     r7,[sp,#6]
;;;499            if (cause == GAP_SUCCESS)
        0x00208f5a:    b974        t.      CBNZ     r4,0x208f7a ; bas_client_read_result_cb + 188
;;;500            {
;;;501                if (value_size != 1)
        0x00208f5c:    4649        IF      MOV      r1,r9
        0x00208f5e:    f1b90f01    ....    CMP      r9,#1
        0x00208f62:    d007        ..      BEQ      0x208f74 ; bas_client_read_result_cb + 182
;;;502                {
;;;503                    PROFILE_PRINT_ERROR1("bas_client_read_result_cb: invalid battery value len %d", value_size);
        0x00208f64:    460b        .F      MOV      r3,r1
        0x00208f66:    4944        DI      LDR      r1,[pc,#272] ; [0x209078] = 0x8801004
        0x00208f68:    2201        ."      MOVS     r2,#1
        0x00208f6a:    3134        41      ADDS     r1,r1,#0x34
        0x00208f6c:    f5fefd77    ..w.    BL       log_buffer ; 0x7a5e
        0x00208f70:    e8bd8ffe    ....    POP      {r1-r11,pc}
;;;504                    return;
;;;505                }
;;;506                cb_data.cb_content.read_result.data.battery_level = *p_value;
        0x00208f74:    7830        0x      LDRB     r0,[r6,#0]
        0x00208f76:    f88d0007    ....    STRB     r0,[sp,#7]
;;;507            }
;;;508        }
;;;509        else
;;;510        {
;;;511            return;
;;;512        }
;;;513    
;;;514        if (bas_client_cb)
        0x00208f7a:    f8da3004    ...0    LDR      r3,[r10,#4]
        0x00208f7e:    2b00        .+      CMP      r3,#0
        0x00208f80:    d0f6        ..      BEQ      0x208f70 ; bas_client_read_result_cb + 178
;;;515        {
;;;516            (*bas_client_cb)(bas_client, conn_id, &cb_data);
        0x00208f82:    483e        >H      LDR      r0,[pc,#248] ; [0x20907c] = 0x20cf29
        0x00208f84:    aa01        ..      ADD      r2,sp,#4
        0x00208f86:    4659        YF      MOV      r1,r11
        0x00208f88:    7800        .x      LDRB     r0,[r0,#0]
        0x00208f8a:    4798        .G      BLX      r3
;;;517        }
;;;518        return;
;;;519    }
        0x00208f8c:    e7f0        ..      B        0x208f70 ; bas_client_read_result_cb + 178
    bas_client_notify_ind_cb
;;;520    
;;;521    static T_APP_RESULT bas_client_notify_ind_cb(uint8_t conn_id, bool notify, uint16_t handle,
;;;522                                                 uint16_t value_size, uint8_t *p_value)
;;;523    {
        0x00208f8e:    b57c        |.      PUSH     {r2-r6,lr}
        0x00208f90:    4c3b        ;L      LDR      r4,[pc,#236] ; [0x209080] = 0x20cfb4
        0x00208f92:    4601        .F      MOV      r1,r0
        0x00208f94:    eb010341    ..A.    ADD      r3,r1,r1,LSL #1
        0x00208f98:    68a6        .h      LDR      r6,[r4,#8]
;;;524        T_APP_RESULT app_result = APP_RESULT_SUCCESS;
        0x00208f9a:    2000        .       MOVS     r0,#0
;;;525        T_BAS_CLIENT_CB_DATA cb_data;
;;;526        uint16_t *hdl_cache;
;;;527    
;;;528        hdl_cache = bas_table[conn_id].hdl_cache;
        0x00208f9c:    eb060383    ....    ADD      r3,r6,r3,LSL #2
        0x00208fa0:    2603        .&      MOVS     r6,#3
        0x00208fa2:    f88d6000    ...`    STRB     r6,[sp,#0]
        0x00208fa6:    891b        ..      LDRH     r3,[r3,#8]
        0x00208fa8:    9d06        ..      LDR      r5,[sp,#0x18]
;;;529        cb_data.cb_type = BAS_CLIENT_CB_TYPE_NOTIF_IND_RESULT;
;;;530    
;;;531        if (handle == hdl_cache[HDL_BAS_BATTERY_LEVEL])
        0x00208faa:    4293        .B      CMP      r3,r2
        0x00208fac:    d10a        ..      BNE      0x208fc4 ; bas_client_notify_ind_cb + 54
;;;532        {
;;;533            cb_data.cb_content.notify_data.battery_level = *p_value;
        0x00208fae:    782a        *x      LDRB     r2,[r5,#0]
        0x00208fb0:    f88d2002    ...     STRB     r2,[sp,#2]
        0x00208fb4:    6863        ch      LDR      r3,[r4,#4]
        0x00208fb6:    2b00        .+      CMP      r3,#0
        0x00208fb8:    d003        ..      BEQ      0x208fc2 ; bas_client_notify_ind_cb + 52
        0x00208fba:    4830        0H      LDR      r0,[pc,#192] ; [0x20907c] = 0x20cf29
        0x00208fbc:    466a        jF      MOV      r2,sp
        0x00208fbe:    7800        .x      LDRB     r0,[r0,#0]
        0x00208fc0:    4798        .G      BLX      r3
        0x00208fc2:    bd7c        |.      POP      {r2-r6,pc}
;;;534        }
;;;535        else
;;;536        {
;;;537            return APP_RESULT_SUCCESS;
        0x00208fc4:    2000        .       MOVS     r0,#0
;;;538        }
;;;539    
;;;540        if (bas_client_cb)
;;;541        {
;;;542            app_result = (*bas_client_cb)(bas_client, conn_id, &cb_data);
;;;543        }
;;;544    
;;;545        return app_result;
;;;546    }
        0x00208fc6:    bd7c        |.      POP      {r2-r6,pc}
    bas_client_disc_cb
;;;547    
;;;548    static void bas_client_disc_cb(uint8_t conn_id)
;;;549    {
        0x00208fc8:    b510        ..      PUSH     {r4,lr}
        0x00208fca:    492b        +I      LDR      r1,[pc,#172] ; [0x209078] = 0x8801004
;;; .\..\..\..\src\ble\profile\client\bas_client.c (549)
        0x00208fcc:    4604        .F      MOV      r4,r0
;;;550        PROFILE_PRINT_INFO0("bas_client_disc_cb.");
        0x00208fce:    2200        ."      MOVS     r2,#0
        0x00208fd0:    3170        p1      ADDS     r1,r1,#0x70
        0x00208fd2:    482c        ,H      LDR      r0,[pc,#176] ; [0x209084] = 0x21103302
        0x00208fd4:    f5fefd43    ..C.    BL       log_buffer ; 0x7a5e
;;;551        if (conn_id >= bas_link_num)
        0x00208fd8:    4829        )H      LDR      r0,[pc,#164] ; [0x209080] = 0x20cfb4
        0x00208fda:    7801        .x      LDRB     r1,[r0,#0]
        0x00208fdc:    428c        .B      CMP      r4,r1
        0x00208fde:    d309        ..      BCC      0x208ff4 ; bas_client_disc_cb + 44
;;;552        {
;;;553            PROFILE_PRINT_ERROR1("bas_client_disc_cb: failed invalid conn_id %d", conn_id);
        0x00208fe0:    4925        %I      LDR      r1,[pc,#148] ; [0x209078] = 0x8801004
        0x00208fe2:    4623        #F      MOV      r3,r4
        0x00208fe4:    4827        'H      LDR      r0,[pc,#156] ; [0x209084] = 0x21103302
        0x00208fe6:    2201        ."      MOVS     r2,#1
        0x00208fe8:    3188        .1      ADDS     r1,r1,#0x88
        0x00208fea:    e8bd4010    ...@    POP      {r4,lr}
        0x00208fee:    1e80        ..      SUBS     r0,r0,#2
        0x00208ff0:    f5febd35    ..5.    B        log_buffer ; 0x7a5e
;;;554            return;
;;;555        }
;;;556        memset(&bas_table[conn_id], 0, sizeof(T_BAS_LINK));
        0x00208ff4:    6880        .h      LDR      r0,[r0,#8]
        0x00208ff6:    eb040144    ..D.    ADD      r1,r4,r4,LSL #1
        0x00208ffa:    eb000081    ....    ADD      r0,r0,r1,LSL #2
        0x00208ffe:    2100        .!      MOVS     r1,#0
        0x00209000:    6001        .`      STR      r1,[r0,#0]
        0x00209002:    6041        A`      STR      r1,[r0,#4]
        0x00209004:    6081        .`      STR      r1,[r0,#8]
;;;557        return;
;;;558    }
        0x00209006:    bd10        ..      POP      {r4,pc}
    bas_add_client
;;;559    /**
;;;560     * @brief BAS Client Callbacks.
;;;561    */
;;;562    const T_FUN_CLIENT_CBS bas_client_cbs =
;;;563    {
;;;564        bas_client_discover_state_cb,   //!< Discovery State callback function pointer
;;;565        bas_client_discover_result_cb,  //!< Discovery result callback function pointer
;;;566        bas_client_read_result_cb,      //!< Read response callback function pointer
;;;567        bas_client_write_result_cb,     //!< Write result callback function pointer
;;;568        bas_client_notify_ind_cb,       //!< Notify Indicate callback function pointer
;;;569        bas_client_disc_cb              //!< Link disconnection callback function pointer
;;;570    };
;;;571    
;;;572    /**
;;;573      * @brief      Add bas client to application.
;;;574      * @param[in]  app_cb pointer of app callback function to handle specific client module data.
;;;575      * @param[in]  link_num initialize link num.
;;;576      * @return Client ID of the specific client module.
;;;577      * @retval 0xff failed.
;;;578      * @retval other success.
;;;579      *
;;;580      * <b>Example usage</b>
;;;581      * \code{.c}
;;;582        void app_le_profile_init(void)
;;;583        {
;;;584            client_init(1);
;;;585            bas_client_id = bas_add_client(app_client_callback, APP_MAX_LINKS);
;;;586        }
;;;587      * \endcode
;;;588      */
;;;589    T_CLIENT_ID bas_add_client(P_FUN_GENERAL_APP_CB app_cb, uint8_t link_num)
;;;590    {
        0x00209008:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0020900c:    4d1d        .M      LDR      r5,[pc,#116] ; [0x209084] = 0x21103302
;;; .\..\..\..\src\ble\profile\client\bas_client.c (590)
        0x0020900e:    4607        .F      MOV      r7,r0
        0x00209010:    1ead        ..      SUBS     r5,r5,#2
        0x00209012:    460c        .F      MOV      r4,r1
        0x00209014:    2904        .)      CMP      r1,#4
        0x00209016:    d909        ..      BLS      0x20902c ; bas_add_client + 36
;;;591        uint16_t size;
;;;592        if (link_num > BAS_MAX_LINKS)
;;;593        {
;;;594            PROFILE_PRINT_ERROR1("bas_add_client: invalid link_num %d", link_num);
        0x00209018:    460b        .F      MOV      r3,r1
        0x0020901a:    4917        .I      LDR      r1,[pc,#92] ; [0x209078] = 0x8801004
        0x0020901c:    2201        ."      MOVS     r2,#1
        0x0020901e:    31bc        .1      ADDS     r1,r1,#0xbc
        0x00209020:    4628        (F      MOV      r0,r5
        0x00209022:    f5fefd1c    ....    BL       log_buffer ; 0x7a5e
;;;595            return 0xff;
        0x00209026:    20ff        .       MOVS     r0,#0xff
        0x00209028:    e8bd81f0    ....    POP      {r4-r8,pc}
;;;596        }
;;;597        if (false == client_register_spec_client_cb(&bas_client, &bas_client_cbs))
        0x0020902c:    4916        .I      LDR      r1,[pc,#88] ; [0x209088] = 0x20bfa0
        0x0020902e:    4813        .H      LDR      r0,[pc,#76] ; [0x20907c] = 0x20cf29
        0x00209030:    f645f9a0    E...    BL       client_register_spec_client_cb ; 0x4e374
        0x00209034:    4e11        .N      LDR      r6,[pc,#68] ; [0x20907c] = 0x20cf29
        0x00209036:    b1a8        ..      CBZ      r0,0x209064 ; bas_add_client + 92
;;;598        {
;;;599            bas_client = CLIENT_PROFILE_GENERAL_ID;
;;;600            PROFILE_PRINT_ERROR0("bas_add_client:register fail");
;;;601            return bas_client;
;;;602        }
;;;603        PROFILE_PRINT_INFO1("bas_add_client: client id %d", bas_client);
        0x00209038:    7833        3x      LDRB     r3,[r6,#0]
        0x0020903a:    2201        ."      MOVS     r2,#1
        0x0020903c:    4913        .I      LDR      r1,[pc,#76] ; [0x20908c] = 0x8801108
        0x0020903e:    4811        .H      LDR      r0,[pc,#68] ; [0x209084] = 0x21103302
        0x00209040:    f5fefd0d    ....    BL       log_buffer ; 0x7a5e
;;;604    
;;;605        /* register callback for profile to inform application that some events happened. */
;;;606        bas_client_cb = app_cb;
        0x00209044:    4d0e        .M      LDR      r5,[pc,#56] ; [0x209080] = 0x20cfb4
        0x00209046:    eb040044    ..D.    ADD      r0,r4,r4,LSL #1
        0x0020904a:    4a0f        .J      LDR      r2,[pc,#60] ; [0x209088] = 0x20bfa0
;;;607        bas_link_num = link_num;
        0x0020904c:    606f        o`      STR      r7,[r5,#4]
        0x0020904e:    0081        ..      LSLS     r1,r0,#2
        0x00209050:    702c        ,p      STRB     r4,[r5,#0]
;;;608        size = bas_link_num * sizeof(T_BAS_LINK);
;;;609        bas_table = os_mem_zalloc(RAM_TYPE_DATA_ON, size);
        0x00209052:    f2402361    @.a#    MOV      r3,#0x261
        0x00209056:    3218        .2      ADDS     r2,r2,#0x18
        0x00209058:    2000        .       MOVS     r0,#0
        0x0020905a:    f61cfead    ....    BL       os_mem_zalloc_intern ; 0x25db8
        0x0020905e:    60a8        .`      STR      r0,[r5,#8]
;;;610    
;;;611        return bas_client;
        0x00209060:    7830        0x      LDRB     r0,[r6,#0]
;;;612    }
        0x00209062:    e7e1        ..      B        0x209028 ; bas_add_client + 32
        0x00209064:    20ff        .       MOVS     r0,#0xff
        0x00209066:    4909        .I      LDR      r1,[pc,#36] ; [0x20908c] = 0x8801108
        0x00209068:    7030        0p      STRB     r0,[r6,#0]
        0x0020906a:    2200        ."      MOVS     r2,#0
        0x0020906c:    3920         9      SUBS     r1,r1,#0x20
        0x0020906e:    4628        (F      MOV      r0,r5
        0x00209070:    f5fefcf5    ....    BL       log_buffer ; 0x7a5e
        0x00209074:    e7f4        ..      B        0x209060 ; bas_add_client + 88
    $d
        0x00209076:    0000        ..      DCW    0
        0x00209078:    08801004    ....    DCD    142610436
        0x0020907c:    0020cf29    ). .    DCD    2150185
        0x00209080:    0020cfb4    .. .    DCD    2150324
        0x00209084:    21103302    .3.!    DCD    554709762
        0x00209088:    0020bfa0    .. .    DCD    2146208
        0x0020908c:    08801108    ....    DCD    142610696
    $t
    .text
    gaps_start_discovery
;;; .\..\..\..\src\ble\profile\client\gaps_client.c
;;;59     {
        0x00209090:    b570        p.      PUSH     {r4-r6,lr}
        0x00209092:    4605        .F      MOV      r5,r0
;;;60         PROFILE_PRINT_INFO0("gaps_start_discovery");
        0x00209094:    2200        ."      MOVS     r2,#0
        0x00209096:    49fe        .I      LDR      r1,[pc,#1016] ; [0x209490] = 0x8801128
        0x00209098:    48fe        .H      LDR      r0,[pc,#1016] ; [0x209494] = 0x21103302
        0x0020909a:    f5fefce0    ....    BL       log_buffer ; 0x7a5e
;;;61         /* First clear handle cache. */
;;;62         if (conn_id >= gaps_link_num)
        0x0020909e:    4efe        .N      LDR      r6,[pc,#1016] ; [0x209498] = 0x20cfc0
        0x002090a0:    7830        0x      LDRB     r0,[r6,#0]
        0x002090a2:    4285        .B      CMP      r5,r0
        0x002090a4:    d308        ..      BCC      0x2090b8 ; gaps_start_discovery + 40
;;;63         {
;;;64             PROFILE_PRINT_ERROR1("gaps_start_discovery: failed invalid conn_id %d", conn_id);
        0x002090a6:    49fa        .I      LDR      r1,[pc,#1000] ; [0x209490] = 0x8801128
        0x002090a8:    48fa        .H      LDR      r0,[pc,#1000] ; [0x209494] = 0x21103302
        0x002090aa:    462b        +F      MOV      r3,r5
        0x002090ac:    2201        ."      MOVS     r2,#1
        0x002090ae:    3118        .1      ADDS     r1,r1,#0x18
        0x002090b0:    1e80        ..      SUBS     r0,r0,#2
        0x002090b2:    f5fefcd4    ....    BL       log_buffer ; 0x7a5e
;;;65             return false;
        0x002090b6:    e013        ..      B        0x2090e0 ; gaps_start_discovery + 80
;;;66         }
;;;67         memset(&gaps_table[conn_id], 0, sizeof(T_GAPS_LINK));
        0x002090b8:    68b0        .h      LDR      r0,[r6,#8]
        0x002090ba:    ebc504c5    ....    RSB      r4,r5,r5,LSL #3
        0x002090be:    eb000044    ..D.    ADD      r0,r0,r4,LSL #1
        0x002090c2:    210e        .!      MOVS     r1,#0xe
        0x002090c4:    f650ffaa    P...    BL       __aeabi_memclr ; 0x5a01c
;;;68         gaps_table[conn_id].disc_state = DISC_GAPS_START;
        0x002090c8:    68b1        .h      LDR      r1,[r6,#8]
        0x002090ca:    2001        .       MOVS     r0,#1
        0x002090cc:    f44f52c0    O..R    MOV      r2,#0x1800
        0x002090d0:    f8010014    ....    STRB     r0,[r1,r4,LSL #1]
;;;69         if (client_by_uuid_srv_discovery(conn_id, gaps_client,
        0x002090d4:    48f1        .H      LDR      r0,[pc,#964] ; [0x20949c] = 0x20cf2a
        0x002090d6:    7801        .x      LDRB     r1,[r0,#0]
        0x002090d8:    4628        (F      MOV      r0,r5
        0x002090da:    f645fa25    E.%.    BL       client_by_uuid_srv_discovery ; 0x4e528
        0x002090de:    b108        ..      CBZ      r0,0x2090e4 ; gaps_start_discovery + 84
        0x002090e0:    2000        .       MOVS     r0,#0
        0x002090e2:    bd70        p.      POP      {r4-r6,pc}
;;;70                                          GATT_UUID_GAP) == GAP_CAUSE_SUCCESS)
;;;71         {
;;;72             return true;
        0x002090e4:    2001        .       MOVS     r0,#1
;;;73         }
;;;74         return false;
;;;75     }
        0x002090e6:    bd70        p.      POP      {r4-r6,pc}
    gaps_read
;;;76     
;;;77     
;;;78     /**
;;;79       * @brief  Used by application, to read data from server by using handles.
;;;80       * @param[in]  conn_id connection ID.
;;;81       * @param[in]  read_type one of characteristic that has the readable property.
;;;82       * @retval true send request to upper stack success.
;;;83       * @retval false send request to upper stack failed.
;;;84       *
;;;85       * <b>Example usage</b>
;;;86       * \code{.c}
;;;87         static T_USER_CMD_PARSE_RESULT cmd_gapread(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;88         {
;;;89             uint8_t conn_id = p_parse_value->dw_param[0];
;;;90             T_GAPS_READ_TYPE read_type = (T_GAPS_READ_TYPE)p_parse_value->dw_param[1];
;;;91             bool ret = gaps_read(conn_id, read_type);
;;;92             ......
;;;93         }
;;;94      * \endcode
;;;95       */
;;;96     bool gaps_read(uint8_t conn_id, T_GAPS_READ_TYPE read_type)
;;;97     {
        0x002090e8:    b570        p.      PUSH     {r4-r6,lr}
        0x002090ea:    4606        .F      MOV      r6,r0
        0x002090ec:    48ea        .H      LDR      r0,[pc,#936] ; [0x209498] = 0x20cfc0
;;; .\..\..\..\src\ble\profile\client\gaps_client.c (97)
        0x002090ee:    460d        .F      MOV      r5,r1
        0x002090f0:    7801        .x      LDRB     r1,[r0,#0]
        0x002090f2:    428e        .B      CMP      r6,r1
        0x002090f4:    d308        ..      BCC      0x209108 ; gaps_read + 32
;;;98         bool hdl_valid = false;
;;;99         uint16_t  handle;
;;;100        uint16_t *hdl_cache;
;;;101        if (conn_id >= gaps_link_num)
;;;102        {
;;;103            PROFILE_PRINT_ERROR1("gaps_read: failed invalid conn_id %d", conn_id);
        0x002090f6:    49e6        .I      LDR      r1,[pc,#920] ; [0x209490] = 0x8801128
        0x002090f8:    48e6        .H      LDR      r0,[pc,#920] ; [0x209494] = 0x21103302
        0x002090fa:    4633        3F      MOV      r3,r6
        0x002090fc:    2201        ."      MOVS     r2,#1
        0x002090fe:    314c        L1      ADDS     r1,r1,#0x4c
        0x00209100:    1e80        ..      SUBS     r0,r0,#2
        0x00209102:    f5fefcac    ....    BL       log_buffer ; 0x7a5e
;;;104            return false;
        0x00209106:    e025        %.      B        0x209154 ; gaps_read + 108
;;;105        }
;;;106        hdl_cache = gaps_table[conn_id].hdl_cache;
        0x00209108:    6880        .h      LDR      r0,[r0,#8]
        0x0020910a:    ebc601c6    ....    RSB      r1,r6,r6,LSL #3
        0x0020910e:    eb000441    ..A.    ADD      r4,r0,r1,LSL #1
;;;107    
;;;108        PROFILE_PRINT_INFO1("gaps_read: charType = %d", read_type);
        0x00209112:    49df        .I      LDR      r1,[pc,#892] ; [0x209490] = 0x8801128
        0x00209114:    462b        +F      MOV      r3,r5
        0x00209116:    2201        ."      MOVS     r2,#1
        0x00209118:    3174        t1      ADDS     r1,r1,#0x74
        0x0020911a:    48de        .H      LDR      r0,[pc,#888] ; [0x209494] = 0x21103302
        0x0020911c:    1ca4        ..      ADDS     r4,r4,#2
        0x0020911e:    f5fefc9e    ....    BL       log_buffer ; 0x7a5e
;;;109    
;;;110        switch (read_type)
        0x00209122:    b125        %.      CBZ      r5,0x20912e ; gaps_read + 70
        0x00209124:    2d01        .-      CMP      r5,#1
        0x00209126:    d004        ..      BEQ      0x209132 ; gaps_read + 74
        0x00209128:    2d02        .-      CMP      r5,#2
        0x0020912a:    d113        ..      BNE      0x209154 ; gaps_read + 108
        0x0020912c:    e003        ..      B        0x209136 ; gaps_read + 78
;;;111        {
;;;112        case GAPS_READ_DEVICE_NAME:
;;;113            if (hdl_cache[HDL_GAPS_DEVICE_NAME])
        0x0020912e:    88a2        ..      LDRH     r2,[r4,#4]
        0x00209130:    e002        ..      B        0x209138 ; gaps_read + 80
;;;114            {
;;;115                handle = hdl_cache[HDL_GAPS_DEVICE_NAME];
;;;116                hdl_valid = true;
;;;117            }
;;;118            break;
;;;119        case GAPS_READ_APPEARANCE:
;;;120            if (hdl_cache[HDL_GAPS_APPEARANCE])
        0x00209132:    88e2        ..      LDRH     r2,[r4,#6]
        0x00209134:    e000        ..      B        0x209138 ; gaps_read + 80
;;;121            {
;;;122                handle = hdl_cache[HDL_GAPS_APPEARANCE];
;;;123                hdl_valid = true;
;;;124            }
;;;125            break;
;;;126        case GAPS_READ_CENTRAL_ADDR_RESOLUTION:
;;;127            if (hdl_cache[HDL_GAPS_CENTRAL_ADDR_RESOLUTION])
        0x00209136:    8922        ".      LDRH     r2,[r4,#8]
        0x00209138:    b12a        *.      CBZ      r2,0x209146 ; gaps_read + 94
        0x0020913a:    48d8        .H      LDR      r0,[pc,#864] ; [0x20949c] = 0x20cf2a
        0x0020913c:    7801        .x      LDRB     r1,[r0,#0]
        0x0020913e:    4630        0F      MOV      r0,r6
        0x00209140:    f645fab7    E...    BL       client_attr_read ; 0x4e6b2
        0x00209144:    b140        @.      CBZ      r0,0x209158 ; gaps_read + 112
        0x00209146:    49d2        .I      LDR      r1,[pc,#840] ; [0x209490] = 0x8801128
        0x00209148:    48d2        .H      LDR      r0,[pc,#840] ; [0x209494] = 0x21103302
        0x0020914a:    2200        ."      MOVS     r2,#0
        0x0020914c:    3190        .1      ADDS     r1,r1,#0x90
        0x0020914e:    1e40        @.      SUBS     r0,r0,#1
        0x00209150:    f5fefc85    ....    BL       log_buffer ; 0x7a5e
;;;128            {
;;;129                handle = hdl_cache[HDL_GAPS_CENTRAL_ADDR_RESOLUTION];
;;;130                hdl_valid = true;
;;;131            }
;;;132            break;
;;;133        default:
;;;134            return false;
        0x00209154:    2000        .       MOVS     r0,#0
        0x00209156:    bd70        p.      POP      {r4-r6,pc}
;;;135        }
;;;136    
;;;137        if (hdl_valid)
;;;138        {
;;;139            if (client_attr_read(conn_id, gaps_client, handle) == GAP_CAUSE_SUCCESS)
;;;140            {
;;;141                return true;
        0x00209158:    2001        .       MOVS     r0,#1
;;;142            }
;;;143        }
;;;144    
;;;145        PROFILE_PRINT_WARN0("gaps_read: Request fail! Please check!");
;;;146        return false;
;;;147    }
        0x0020915a:    bd70        p.      POP      {r4-r6,pc}
    gaps_get_hdl_cache
;;;148    
;;;149    /**
;;;150      * @brief  Used by application, to get handle cache.
;;;151      * @param[in]  conn_id connection ID.
;;;152      * @param[in,out]  p_hdl_cache pointer of the handle cache table
;;;153      * @param[in]  len the length of handle cache table
;;;154      * @retval true success.
;;;155      * @retval false failed.
;;;156      *
;;;157      * <b>Example usage</b>
;;;158      * \code{.c}
;;;159        static T_USER_CMD_PARSE_RESULT cmd_gaphdl(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;160        {
;;;161            uint8_t conn_id = p_parse_value->dw_param[0];
;;;162            uint16_t hdl_cache[HDL_GAPS_CACHE_LEN];
;;;163            uint8_t hdl_idx;
;;;164            bool ret = gaps_get_hdl_cache(conn_id, hdl_cache, sizeof(uint16_t) * HDL_GAPS_CACHE_LEN);
;;;165            ......
;;;166        }
;;;167     * \endcode
;;;168      */
;;;169    bool gaps_get_hdl_cache(uint8_t conn_id, uint16_t *p_hdl_cache, uint8_t len)
;;;170    {
        0x0020915c:    b570        p.      PUSH     {r4-r6,lr}
        0x0020915e:    460e        .F      MOV      r6,r1
;;;171        if (conn_id >= gaps_link_num)
        0x00209160:    49cd        .I      LDR      r1,[pc,#820] ; [0x209498] = 0x20cfc0
        0x00209162:    4dcc        .M      LDR      r5,[pc,#816] ; [0x209494] = 0x21103302
        0x00209164:    780b        .x      LDRB     r3,[r1,#0]
        0x00209166:    1ead        ..      SUBS     r5,r5,#2
        0x00209168:    4298        .B      CMP      r0,r3
        0x0020916a:    d304        ..      BCC      0x209176 ; gaps_get_hdl_cache + 26
;;;172        {
;;;173            PROFILE_PRINT_ERROR1("gaps_get_hdl_cache: failed invalid conn_id %d", conn_id);
        0x0020916c:    49c8        .I      LDR      r1,[pc,#800] ; [0x209490] = 0x8801128
        0x0020916e:    2201        ."      MOVS     r2,#1
        0x00209170:    4603        .F      MOV      r3,r0
        0x00209172:    31bc        .1      ADDS     r1,r1,#0xbc
;;;174            return false;
        0x00209174:    e010        ..      B        0x209198 ; gaps_get_hdl_cache + 60
;;;175        }
;;;176        if (gaps_table[conn_id].disc_state != DISC_GAPS_DONE)
        0x00209176:    688b        .h      LDR      r3,[r1,#8]
        0x00209178:    ebc000c0    ....    RSB      r0,r0,r0,LSL #3
        0x0020917c:    f8134010    ...@    LDRB     r4,[r3,r0,LSL #1]
        0x00209180:    2c02        .,      CMP      r4,#2
        0x00209182:    d004        ..      BEQ      0x20918e ; gaps_get_hdl_cache + 50
        0x00209184:    49c2        .I      LDR      r1,[pc,#776] ; [0x209490] = 0x8801128
        0x00209186:    2201        ."      MOVS     r2,#1
        0x00209188:    4623        #F      MOV      r3,r4
;;;177        {
;;;178            PROFILE_PRINT_ERROR1("gaps_get_hdl_cache: failed invalid state %d", gaps_table[conn_id].disc_state);
        0x0020918a:    31f0        .1      ADDS     r1,r1,#0xf0
;;;179            return false;
        0x0020918c:    e004        ..      B        0x209198 ; gaps_get_hdl_cache + 60
;;;180        }
;;;181        if (len != sizeof(uint16_t) * HDL_GAPS_CACHE_LEN)
        0x0020918e:    2a0c        .*      CMP      r2,#0xc
        0x00209190:    d007        ..      BEQ      0x2091a2 ; gaps_get_hdl_cache + 70
;;;182        {
;;;183            PROFILE_PRINT_ERROR1("gaps_get_hdl_cache: failed invalid len %d", len);
        0x00209192:    4613        .F      MOV      r3,r2
        0x00209194:    49c2        .I      LDR      r1,[pc,#776] ; [0x2094a0] = 0x8801248
        0x00209196:    2201        ."      MOVS     r2,#1
        0x00209198:    4628        (F      MOV      r0,r5
        0x0020919a:    f5fefc60    ..`.    BL       log_buffer ; 0x7a5e
;;;184            return false;
        0x0020919e:    2000        .       MOVS     r0,#0
        0x002091a0:    bd70        p.      POP      {r4-r6,pc}
;;;185        }
;;;186        memcpy(p_hdl_cache, gaps_table[conn_id].hdl_cache, len);
        0x002091a2:    eb030140    ..@.    ADD      r1,r3,r0,LSL #1
        0x002091a6:    4630        0F      MOV      r0,r6
        0x002091a8:    1c89        ..      ADDS     r1,r1,#2
        0x002091aa:    f650fe76    P.v.    BL       __aeabi_memcpy ; 0x59e9a
;;;187        return true;
        0x002091ae:    2001        .       MOVS     r0,#1
;;;188    }
        0x002091b0:    bd70        p.      POP      {r4-r6,pc}
    gaps_set_hdl_cache
;;;189    
;;;190    /**
;;;191      * @brief  Used by application, to set handle cache.
;;;192      * @param[in]  conn_id connection ID.
;;;193      * @param[in]  p_hdl_cache pointer of the handle cache table
;;;194      * @param[in]  len the length of handle cache table
;;;195      * @retval true success.
;;;196      * @retval false failed.
;;;197      *
;;;198      * <b>Example usage</b>
;;;199      * \code{.c}
;;;200        void app_discov_services(uint8_t conn_id, bool start)
;;;201        {
;;;202            ......
;;;203            if (app_srvs_table.srv_found_flags & APP_DISCOV_GAPS_FLAG)
;;;204            {
;;;205                gaps_set_hdl_cache(conn_id, app_srvs_table.gaps_hdl_cache, sizeof(uint16_t) * HDL_GAPS_CACHE_LEN);
;;;206            }
;;;207            ......
;;;208        }
;;;209     * \endcode
;;;210      */
;;;211    bool gaps_set_hdl_cache(uint8_t conn_id, uint16_t *p_hdl_cache, uint8_t len)
;;;212    {
        0x002091b2:    b570        p.      PUSH     {r4-r6,lr}
;;;213        if (conn_id >= gaps_link_num)
        0x002091b4:    4db8        .M      LDR      r5,[pc,#736] ; [0x209498] = 0x20cfc0
        0x002091b6:    4eb7        .N      LDR      r6,[pc,#732] ; [0x209494] = 0x21103302
        0x002091b8:    782b        +x      LDRB     r3,[r5,#0]
        0x002091ba:    1eb6        ..      SUBS     r6,r6,#2
        0x002091bc:    4298        .B      CMP      r0,r3
        0x002091be:    d304        ..      BCC      0x2091ca ; gaps_set_hdl_cache + 24
;;;214        {
;;;215            PROFILE_PRINT_ERROR1("gaps_set_hdl_cache: failed invalid conn_id %d", conn_id);
        0x002091c0:    49b7        .I      LDR      r1,[pc,#732] ; [0x2094a0] = 0x8801248
        0x002091c2:    2201        ."      MOVS     r2,#1
        0x002091c4:    4603        .F      MOV      r3,r0
        0x002091c6:    3130        01      ADDS     r1,r1,#0x30
;;;216            return false;
        0x002091c8:    e00f        ..      B        0x2091ea ; gaps_set_hdl_cache + 56
;;;217        }
;;;218        if (gaps_table[conn_id].disc_state != DISC_GAPS_IDLE)
        0x002091ca:    ebc004c0    ....    RSB      r4,r0,r0,LSL #3
        0x002091ce:    68a8        .h      LDR      r0,[r5,#8]
        0x002091d0:    f8103014    ...0    LDRB     r3,[r0,r4,LSL #1]
        0x002091d4:    b11b        ..      CBZ      r3,0x2091de ; gaps_set_hdl_cache + 44
;;;219        {
;;;220            PROFILE_PRINT_ERROR1("gaps_set_hdl_cache: failed invalid state %d", gaps_table[conn_id].disc_state);
        0x002091d6:    49b2        .I      LDR      r1,[pc,#712] ; [0x2094a0] = 0x8801248
        0x002091d8:    2201        ."      MOVS     r2,#1
        0x002091da:    3164        d1      ADDS     r1,r1,#0x64
;;;221            return false;
        0x002091dc:    e005        ..      B        0x2091ea ; gaps_set_hdl_cache + 56
;;;222        }
;;;223        if (len != sizeof(uint16_t) * HDL_GAPS_CACHE_LEN)
        0x002091de:    2a0c        .*      CMP      r2,#0xc
        0x002091e0:    d008        ..      BEQ      0x2091f4 ; gaps_set_hdl_cache + 66
;;;224        {
;;;225            PROFILE_PRINT_ERROR1("gaps_set_hdl_cache: failed invalid len %d", len);
        0x002091e2:    4613        .F      MOV      r3,r2
        0x002091e4:    49ae        .I      LDR      r1,[pc,#696] ; [0x2094a0] = 0x8801248
        0x002091e6:    2201        ."      MOVS     r2,#1
        0x002091e8:    3194        .1      ADDS     r1,r1,#0x94
        0x002091ea:    4630        0F      MOV      r0,r6
        0x002091ec:    f5fefc37    ..7.    BL       log_buffer ; 0x7a5e
;;;226            return false;
        0x002091f0:    2000        .       MOVS     r0,#0
        0x002091f2:    bd70        p.      POP      {r4-r6,pc}
;;;227        }
;;;228        memcpy(gaps_table[conn_id].hdl_cache, p_hdl_cache, len);
        0x002091f4:    eb000044    ..D.    ADD      r0,r0,r4,LSL #1
        0x002091f8:    1c80        ..      ADDS     r0,r0,#2
        0x002091fa:    f650fe4e    P.N.    BL       __aeabi_memcpy ; 0x59e9a
;;;229        gaps_table[conn_id].disc_state = DISC_GAPS_DONE;
        0x002091fe:    68a9        .h      LDR      r1,[r5,#8]
        0x00209200:    2002        .       MOVS     r0,#2
        0x00209202:    f8010014    ....    STRB     r0,[r1,r4,LSL #1]
;;;230        return true;
        0x00209206:    2001        .       MOVS     r0,#1
;;;231    }
        0x00209208:    bd70        p.      POP      {r4-r6,pc}
    gaps_check_resolvable_private_addr_only_char
;;;232    
;;;233    /**
;;;234      * @brief  Used by application, to check Resolvable Private Address Only Characteristics whether existing.
;;;235      * @param[in]  conn_id connection ID.
;;;236      * @param[in,out]  p_is_exist whether existing
;;;237      * @retval true success.
;;;238      * @retval false failed.
;;;239      */
;;;240    bool gaps_check_resolvable_private_addr_only_char(uint8_t conn_id, bool *p_is_exist)
;;;241    {
        0x0020920a:    b510        ..      PUSH     {r4,lr}
;;;242        if (conn_id >= gaps_link_num)
        0x0020920c:    4aa2        .J      LDR      r2,[pc,#648] ; [0x209498] = 0x20cfc0
        0x0020920e:    4ca1        .L      LDR      r4,[pc,#644] ; [0x209494] = 0x21103302
        0x00209210:    7813        .x      LDRB     r3,[r2,#0]
        0x00209212:    1ea4        ..      SUBS     r4,r4,#2
        0x00209214:    4298        .B      CMP      r0,r3
        0x00209216:    d304        ..      BCC      0x209222 ; gaps_check_resolvable_private_addr_only_char + 24
;;;243        {
;;;244            PROFILE_PRINT_ERROR1("gaps_get_hdl_cache: failed invalid conn_id %d", conn_id);
        0x00209218:    49a1        .I      LDR      r1,[pc,#644] ; [0x2094a0] = 0x8801248
        0x0020921a:    2201        ."      MOVS     r2,#1
        0x0020921c:    4603        .F      MOV      r3,r0
        0x0020921e:    31c4        .1      ADDS     r1,r1,#0xc4
;;;245            return false;
        0x00209220:    e009        ..      B        0x209236 ; gaps_check_resolvable_private_addr_only_char + 44
;;;246        }
;;;247        if (gaps_table[conn_id].disc_state != DISC_GAPS_DONE)
        0x00209222:    6892        .h      LDR      r2,[r2,#8]
        0x00209224:    ebc000c0    ....    RSB      r0,r0,r0,LSL #3
        0x00209228:    f8123010    ...0    LDRB     r3,[r2,r0,LSL #1]
        0x0020922c:    2b02        .+      CMP      r3,#2
        0x0020922e:    d007        ..      BEQ      0x209240 ; gaps_check_resolvable_private_addr_only_char + 54
;;;248        {
;;;249            PROFILE_PRINT_ERROR1("gaps_get_hdl_cache: failed invalid state %d", gaps_table[conn_id].disc_state);
        0x00209230:    499b        .I      LDR      r1,[pc,#620] ; [0x2094a0] = 0x8801248
        0x00209232:    2201        ."      MOVS     r2,#1
        0x00209234:    31f8        .1      ADDS     r1,r1,#0xf8
        0x00209236:    4620         F      MOV      r0,r4
        0x00209238:    f5fefc11    ....    BL       log_buffer ; 0x7a5e
;;;250            return false;
        0x0020923c:    2000        .       MOVS     r0,#0
        0x0020923e:    bd10        ..      POP      {r4,pc}
;;;251        }
;;;252        if (gaps_table[conn_id].hdl_cache[HDL_GAPS_RESOLVABLE_PRIVATE_ADDR_ONLY] == 0)
        0x00209240:    eb020040    ..@.    ADD      r0,r2,r0,LSL #1
        0x00209244:    8980        ..      LDRH     r0,[r0,#0xc]
        0x00209246:    b100        ..      CBZ      r0,0x20924a ; gaps_check_resolvable_private_addr_only_char + 64
;;;253        {
;;;254            *p_is_exist = false;
;;;255        }
;;;256        else
;;;257        {
;;;258            *p_is_exist = true;
        0x00209248:    2001        .       MOVS     r0,#1
        0x0020924a:    7008        .p      STRB     r0,[r1,#0]
;;;259        }
;;;260        return true;
        0x0020924c:    2001        .       MOVS     r0,#1
;;;261    }
        0x0020924e:    bd10        ..      POP      {r4,pc}
    gaps_client_discover_state_cb
;;;262    
;;;263    static bool gaps_client_start_gap_char_discovery(uint8_t conn_id)
;;;264    {
;;;265        uint16_t start_handle;
;;;266        uint16_t end_handle;
;;;267    
;;;268        PROFILE_PRINT_INFO0("gap_client_start_gap_char_discovery");
;;;269        start_handle = gaps_table[conn_id].hdl_cache[HDL_GAPS_SRV_START];
;;;270        end_handle = gaps_table[conn_id].hdl_cache[HDL_GAPS_SRV_END];
;;;271        if (client_all_char_discovery(conn_id, gaps_client, start_handle,
;;;272                                      end_handle) == GAP_CAUSE_SUCCESS)
;;;273        {
;;;274            return true;
;;;275        }
;;;276        return false;
;;;277    }
;;;278    
;;;279    static void gaps_client_discover_state_cb(uint8_t conn_id,  T_DISCOVERY_STATE discovery_state)
;;;280    {
        0x00209250:    e92d47f0    -..G    PUSH     {r4-r10,lr}
        0x00209254:    b086        ..      SUB      sp,sp,#0x18
        0x00209256:    4607        .F      MOV      r7,r0
        0x00209258:    2000        .       MOVS     r0,#0
        0x0020925a:    f8dfa238    ..8.    LDR      r10,[pc,#568] ; [0x209494] = 0x21103302
        0x0020925e:    4688        .F      MOV      r8,r1
        0x00209260:    f88d0000    ....    STRB     r0,[sp,#0]
        0x00209264:    460b        .F      MOV      r3,r1
        0x00209266:    2201        ."      MOVS     r2,#1
        0x00209268:    498e        .I      LDR      r1,[pc,#568] ; [0x2094a4] = 0x8801398
        0x0020926a:    4650        PF      MOV      r0,r10
        0x0020926c:    f5fefbf7    ....    BL       log_buffer ; 0x7a5e
        0x00209270:    2603        .&      MOVS     r6,#3
        0x00209272:    f8df9228    ..(.    LDR      r9,[pc,#552] ; [0x20949c] = 0x20cf2a
        0x00209276:    4d88        .M      LDR      r5,[pc,#544] ; [0x209498] = 0x20cfc0
        0x00209278:    ebc704c7    ....    RSB      r4,r7,r7,LSL #3
        0x0020927c:    f1b80f02    ....    CMP      r8,#2
        0x00209280:    d010        ..      BEQ      0x2092a4 ; gaps_client_discover_state_cb + 84
        0x00209282:    f1b80f06    ....    CMP      r8,#6
        0x00209286:    d02a        *.      BEQ      0x2092de ; gaps_client_discover_state_cb + 142
        0x00209288:    f1aa0002    ....    SUB      r0,r10,#2
        0x0020928c:    f1b80f0b    ....    CMP      r8,#0xb
        0x00209290:    f04f0200    O...    MOV      r2,#0
        0x00209294:    d035        5.      BEQ      0x209302 ; gaps_client_discover_state_cb + 178
        0x00209296:    4983        .I      LDR      r1,[pc,#524] ; [0x2094a4] = 0x8801398
        0x00209298:    3150        P1      ADDS     r1,r1,#0x50
        0x0020929a:    f5fefbe0    ....    BL       log_buffer ; 0x7a5e
        0x0020929e:    b006        ..      ADD      sp,sp,#0x18
        0x002092a0:    e8bd87f0    ....    POP      {r4-r10,pc}
        0x002092a4:    68a8        .h      LDR      r0,[r5,#8]
        0x002092a6:    eb000144    ..D.    ADD      r1,r0,r4,LSL #1
        0x002092aa:    884a        J.      LDRH     r2,[r1,#2]
        0x002092ac:    b90a        ..      CBNZ     r2,0x2092b2 ; gaps_client_discover_state_cb + 98
        0x002092ae:    8889        ..      LDRH     r1,[r1,#4]
        0x002092b0:    b191        ..      CBZ      r1,0x2092d8 ; gaps_client_discover_state_cb + 136
;;; .\..\..\..\src\ble\profile\client\gaps_client.c (268)
        0x002092b2:    497c        |I      LDR      r1,[pc,#496] ; [0x2094a4] = 0x8801398
        0x002092b4:    2200        ."      MOVS     r2,#0
        0x002092b6:    3928        (9      SUBS     r1,r1,#0x28
        0x002092b8:    4650        PF      MOV      r0,r10
        0x002092ba:    f5fefbd0    ....    BL       log_buffer ; 0x7a5e
;;;269        start_handle = gaps_table[conn_id].hdl_cache[HDL_GAPS_SRV_START];
        0x002092be:    68a8        .h      LDR      r0,[r5,#8]
        0x002092c0:    f8991000    ....    LDRB     r1,[r9,#0]
        0x002092c4:    eb000044    ..D.    ADD      r0,r0,r4,LSL #1
        0x002092c8:    8842        B.      LDRH     r2,[r0,#2]
;;;270        end_handle = gaps_table[conn_id].hdl_cache[HDL_GAPS_SRV_END];
        0x002092ca:    8883        ..      LDRH     r3,[r0,#4]
;;;271        if (client_all_char_discovery(conn_id, gaps_client, start_handle,
        0x002092cc:    4638        8F      MOV      r0,r7
        0x002092ce:    f645f976    E.v.    BL       client_all_char_discovery ; 0x4e5be
        0x002092d2:    2800        .(      CMP      r0,#0
        0x002092d4:    d0e3        ..      BEQ      0x20929e ; gaps_client_discover_state_cb + 78
;;;272                                      end_handle) == GAP_CAUSE_SUCCESS)
;;;273        {
;;;274            return true;
;;;275        }
;;;276        return false;
;;;277    }
;;;278    
;;;279    static void gaps_client_discover_state_cb(uint8_t conn_id,  T_DISCOVERY_STATE discovery_state)
;;;280    {
;;;281        bool cb_flag = false;
;;;282        T_GAPS_CLIENT_CB_DATA cb_data;
;;;283        cb_data.cb_type = GAPS_CLIENT_CB_TYPE_DISC_STATE;
;;;284    
;;;285        PROFILE_PRINT_INFO1("gaps_client_discover_state_cb: discovery_state %d", discovery_state);
;;;286    
;;;287        switch (discovery_state)
;;;288        {
;;;289        case DISC_STATE_SRV_DONE:
;;;290            /* Indicate that service handle found. Start discover characteristic. */
;;;291            if ((gaps_table[conn_id].hdl_cache[HDL_GAPS_SRV_START] != 0)
;;;292                || (gaps_table[conn_id].hdl_cache[HDL_GAPS_SRV_END] != 0))
;;;293            {
;;;294                if (gaps_client_start_gap_char_discovery(conn_id) == false)
;;;295                {
;;;296                    gaps_table[conn_id].disc_state = DISC_GAPS_FAILED;
        0x002092d6:    68a8        .h      LDR      r0,[r5,#8]
;;;297                    cb_flag = true;
;;;298                }
;;;299            }
;;;300            /* No GAP service handle found. Discover procedure complete. */
;;;301            else
;;;302            {
;;;303                gaps_table[conn_id].disc_state = DISC_GAPS_FAILED;
        0x002092d8:    f8006014    ...`    STRB     r6,[r0,r4,LSL #1]
;;;304                cb_flag = true;
        0x002092dc:    e003        ..      B        0x2092e6 ; gaps_client_discover_state_cb + 150
;;;305            }
;;;306            break;
;;;307    
;;;308        case DISC_STATE_CHAR_DONE:
;;;309            gaps_table[conn_id].disc_state = DISC_GAPS_DONE;
        0x002092de:    68a9        .h      LDR      r1,[r5,#8]
        0x002092e0:    2002        .       MOVS     r0,#2
        0x002092e2:    f8010014    ....    STRB     r0,[r1,r4,LSL #1]
;;;310            cb_flag = true;
;;;311            break;
;;;312    
;;;313        case DISC_STATE_FAILED:
;;;314            PROFILE_PRINT_ERROR0("DISC_STATE_FAILED");
;;;315            gaps_table[conn_id].disc_state = DISC_GAPS_FAILED;
;;;316            cb_flag = true;
;;;317            break;
;;;318        default:
;;;319            PROFILE_PRINT_ERROR0("Invalid Discovery State!");
;;;320            break;
;;;321        }
;;;322        /* Send discover state to application if needed. */
;;;323        if (cb_flag && gaps_client_cb)
        0x002092e6:    686b        kh      LDR      r3,[r5,#4]
        0x002092e8:    2b00        .+      CMP      r3,#0
        0x002092ea:    d0d8        ..      BEQ      0x20929e ; gaps_client_discover_state_cb + 78
;;;324        {
;;;325            cb_data.cb_content.disc_state = gaps_table[conn_id].disc_state;
        0x002092ec:    68a8        .h      LDR      r0,[r5,#8]
        0x002092ee:    466a        jF      MOV      r2,sp
        0x002092f0:    4639        9F      MOV      r1,r7
        0x002092f2:    f8100014    ....    LDRB     r0,[r0,r4,LSL #1]
        0x002092f6:    f88d0004    ....    STRB     r0,[sp,#4]
;;;326            (*gaps_client_cb)(gaps_client, conn_id, &cb_data);
        0x002092fa:    f8990000    ....    LDRB     r0,[r9,#0]
        0x002092fe:    4798        .G      BLX      r3
;;;327        }
;;;328        return;
;;;329    }
        0x00209300:    e7cd        ..      B        0x20929e ; gaps_client_discover_state_cb + 78
        0x00209302:    4968        hI      LDR      r1,[pc,#416] ; [0x2094a4] = 0x8801398
        0x00209304:    3138        81      ADDS     r1,r1,#0x38
        0x00209306:    f5fefbaa    ....    BL       log_buffer ; 0x7a5e
        0x0020930a:    e7e4        ..      B        0x2092d6 ; gaps_client_discover_state_cb + 134
    gaps_client_discover_result_cb
;;;330    
;;;331    static void gaps_client_discover_result_cb(uint8_t conn_id,  T_DISCOVERY_RESULT_TYPE result_type,
;;;332                                               T_DISCOVERY_RESULT_DATA result_data)
;;;333    {
        0x0020930c:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x00209310:    460e        .F      MOV      r6,r1
        0x00209312:    460b        .F      MOV      r3,r1
        0x00209314:    4963        cI      LDR      r1,[pc,#396] ; [0x2094a4] = 0x8801398
        0x00209316:    4d5f        _M      LDR      r5,[pc,#380] ; [0x209494] = 0x21103302
;;; .\..\..\..\src\ble\profile\client\gaps_client.c (333)
        0x00209318:    4614        .F      MOV      r4,r2
        0x0020931a:    4607        .F      MOV      r7,r0
;;;334        PROFILE_PRINT_INFO1("gap_client_discover_result_cb: result_type = %d", result_type);
        0x0020931c:    2201        ."      MOVS     r2,#1
        0x0020931e:    316c        l1      ADDS     r1,r1,#0x6c
        0x00209320:    4628        (F      MOV      r0,r5
        0x00209322:    f5fefb9c    ....    BL       log_buffer ; 0x7a5e
        0x00209326:    4b5c        \K      LDR      r3,[pc,#368] ; [0x209498] = 0x20cfc0
        0x00209328:    ebc701c7    ....    RSB      r1,r7,r7,LSL #3
;;;335        uint16_t handle;
;;;336        switch (result_type)
        0x0020932c:    2e02        ..      CMP      r6,#2
        0x0020932e:    d005        ..      BEQ      0x20933c ; gaps_client_discover_result_cb + 48
        0x00209330:    2e03        ..      CMP      r6,#3
        0x00209332:    d00c        ..      BEQ      0x20934e ; gaps_client_discover_result_cb + 66
        0x00209334:    2200        ."      MOVS     r2,#0
        0x00209336:    495c        \I      LDR      r1,[pc,#368] ; [0x2094a8] = 0x88014a4
        0x00209338:    1ea8        ..      SUBS     r0,r5,#2
        0x0020933a:    e01d        ..      B        0x209378 ; gaps_client_discover_result_cb + 108
;;;337        {
;;;338        case DISC_RESULT_SRV_DATA:
;;;339            gaps_table[conn_id].hdl_cache[HDL_GAPS_SRV_START] =
        0x0020933c:    6898        .h      LDR      r0,[r3,#8]
        0x0020933e:    8822        ".      LDRH     r2,[r4,#0]
        0x00209340:    eb000041    ..A.    ADD      r0,r0,r1,LSL #1
        0x00209344:    8042        B.      STRH     r2,[r0,#2]
;;;340                result_data.p_srv_disc_data->att_handle;
;;;341            gaps_table[conn_id].hdl_cache[HDL_GAPS_SRV_END] =
        0x00209346:    8861        a.      LDRH     r1,[r4,#2]
        0x00209348:    8081        ..      STRH     r1,[r0,#4]
        0x0020934a:    e8bd81f0    ....    POP      {r4-r8,pc}
        0x0020934e:    88e0        ..      LDRH     r0,[r4,#6]
;;;342                result_data.p_srv_disc_data->end_group_handle;
;;;343            break;
;;;344    
;;;345        case DISC_RESULT_CHAR_UUID16:
;;;346            handle = result_data.p_char_uuid16_disc_data->value_handle;
        0x00209350:    88a2        ..      LDRH     r2,[r4,#4]
;;;347            /* we should inform intrested handles to upper application. */
;;;348            switch (result_data.p_char_uuid16_disc_data->uuid16)
        0x00209352:    f5b05f28    ..(_    CMP      r0,#0x2a00
        0x00209356:    d013        ..      BEQ      0x209380 ; gaps_client_discover_result_cb + 116
        0x00209358:    f46f5428    o.(T    MVN      r4,#0x2a00
        0x0020935c:    1900        ..      ADDS     r0,r0,r4
        0x0020935e:    d014        ..      BEQ      0x20938a ; gaps_client_discover_result_cb + 126
        0x00209360:    28a5        .(      CMP      r0,#0xa5
        0x00209362:    d017        ..      BEQ      0x209394 ; gaps_client_discover_result_cb + 136
        0x00209364:    28c8        .(      CMP      r0,#0xc8
        0x00209366:    d1f0        ..      BNE      0x20934a ; gaps_client_discover_result_cb + 62
        0x00209368:    6898        .h      LDR      r0,[r3,#8]
        0x0020936a:    eb000041    ..A.    ADD      r0,r0,r1,LSL #1
        0x0020936e:    494e        NI      LDR      r1,[pc,#312] ; [0x2094a8] = 0x88014a4
        0x00209370:    8182        ..      STRH     r2,[r0,#0xc]
        0x00209372:    2200        ."      MOVS     r2,#0
        0x00209374:    3938        89      SUBS     r1,r1,#0x38
        0x00209376:    4628        (F      MOV      r0,r5
        0x00209378:    e8bd41f0    ...A    POP      {r4-r8,lr}
        0x0020937c:    f5febb6f    ..o.    B        log_buffer ; 0x7a5e
        0x00209380:    6898        .h      LDR      r0,[r3,#8]
        0x00209382:    eb000041    ..A.    ADD      r0,r0,r1,LSL #1
        0x00209386:    80c2        ..      STRH     r2,[r0,#6]
        0x00209388:    e7df        ..      B        0x20934a ; gaps_client_discover_result_cb + 62
        0x0020938a:    6898        .h      LDR      r0,[r3,#8]
        0x0020938c:    eb000041    ..A.    ADD      r0,r0,r1,LSL #1
        0x00209390:    8102        ..      STRH     r2,[r0,#8]
        0x00209392:    e7da        ..      B        0x20934a ; gaps_client_discover_result_cb + 62
;;;349            {
;;;350            case GATT_UUID_CHAR_DEVICE_NAME:
;;;351                gaps_table[conn_id].hdl_cache[HDL_GAPS_DEVICE_NAME] = handle;
;;;352                break;
;;;353            case GATT_UUID_CHAR_APPEARANCE:
;;;354                gaps_table[conn_id].hdl_cache[HDL_GAPS_APPEARANCE] = handle;
;;;355                break;
;;;356            case GATT_UUID_CHAR_CENTRAL_ADDRESS_RESOLUTION:
;;;357                gaps_table[conn_id].hdl_cache[HDL_GAPS_CENTRAL_ADDR_RESOLUTION] = handle;
        0x00209394:    6898        .h      LDR      r0,[r3,#8]
        0x00209396:    eb000041    ..A.    ADD      r0,r0,r1,LSL #1
        0x0020939a:    4943        CI      LDR      r1,[pc,#268] ; [0x2094a8] = 0x88014a4
        0x0020939c:    8142        B.      STRH     r2,[r0,#0xa]
;;;358                PROFILE_PRINT_INFO0("GATT_UUID_CHAR_CENTRAL_ADDRESS_RESOLUTION found");
        0x0020939e:    2200        ."      MOVS     r2,#0
        0x002093a0:    396c        l9      SUBS     r1,r1,#0x6c
;;;359                break;
        0x002093a2:    e7e8        ..      B        0x209376 ; gaps_client_discover_result_cb + 106
    gaps_client_read_result_cb
;;;360            case GATT_UUID_CHAR_RESOLVABLE_PRIVATE_ADDRESS_ONLY:
;;;361                gaps_table[conn_id].hdl_cache[HDL_GAPS_RESOLVABLE_PRIVATE_ADDR_ONLY] = handle;
;;;362                PROFILE_PRINT_INFO0("GATT_UUID_CHAR_RESOLVABLE_PRIVATE_ADDRESS_ONLY found");
;;;363                break;
;;;364            default:
;;;365                /* have no intrest on this handle. */
;;;366                break;
;;;367            }
;;;368            break;
;;;369    
;;;370        default:
;;;371            PROFILE_PRINT_ERROR0("Invalid Discovery Result Type!");
;;;372            break;
;;;373        }
;;;374    
;;;375        return;
;;;376    }
;;;377    
;;;378    static void gaps_client_read_result_cb(uint8_t conn_id,  uint16_t cause,
;;;379                                           uint16_t handle, uint16_t value_size, uint8_t *p_value)
;;;380    {
        0x002093a4:    e92d4ff0    -..O    PUSH     {r4-r11,lr}
        0x002093a8:    f8dfa0ec    ....    LDR      r10,[pc,#236] ; [0x209498] = 0x20cfc0
;;; .\..\..\..\src\ble\profile\client\gaps_client.c (380)
        0x002093ac:    460c        .F      MOV      r4,r1
        0x002093ae:    4683        .F      MOV      r11,r0
        0x002093b0:    ebc001cb    ....    RSB      r1,r0,r11,LSL #3
        0x002093b4:    f8da0008    ....    LDR      r0,[r10,#8]
        0x002093b8:    b087        ..      SUB      sp,sp,#0x1c
        0x002093ba:    eb000541    ..A.    ADD      r5,r0,r1,LSL #1
        0x002093be:    4698        .F      MOV      r8,r3
        0x002093c0:    4939        9I      LDR      r1,[pc,#228] ; [0x2094a8] = 0x88014a4
        0x002093c2:    4617        .F      MOV      r7,r2
;;;381        T_GAPS_CLIENT_CB_DATA cb_data;
;;;382        uint16_t *hdl_cache;
;;;383        hdl_cache = gaps_table[conn_id].hdl_cache;
        0x002093c4:    9e10        ..      LDR      r6,[sp,#0x40]
;;;384        cb_data.cb_type = GAPS_CLIENT_CB_TYPE_READ_RESULT;
        0x002093c6:    f04f0901    O...    MOV      r9,#1
        0x002093ca:    f8ad4014    ...@    STRH     r4,[sp,#0x14]
        0x002093ce:    4613        .F      MOV      r3,r2
        0x002093d0:    f88d9004    ....    STRB     r9,[sp,#4]
;;;385        cb_data.cb_content.read_result.cause = cause;
;;;386    
;;;387        PROFILE_PRINT_INFO2("gap_client_read_result_cb: handle 0x%x, cause 0x%x", handle, cause);
        0x002093d4:    2202        ."      MOVS     r2,#2
        0x002093d6:    3124        $1      ADDS     r1,r1,#0x24
        0x002093d8:    482e        .H      LDR      r0,[pc,#184] ; [0x209494] = 0x21103302
        0x002093da:    1cad        ..      ADDS     r5,r5,#2
        0x002093dc:    9400        ..      STR      r4,[sp,#0]
        0x002093de:    f5fefb3e    ..>.    BL       log_buffer ; 0x7a5e
;;;388    
;;;389        if (handle == hdl_cache[HDL_GAPS_APPEARANCE])
        0x002093e2:    88e8        ..      LDRH     r0,[r5,#6]
        0x002093e4:    42b8        .B      CMP      r0,r7
        0x002093e6:    d118        ..      BNE      0x20941a ; gaps_client_read_result_cb + 118
;;;390        {
;;;391            cb_data.cb_content.read_result.type = GAPS_READ_APPEARANCE;
        0x002093e8:    f88d9008    ....    STRB     r9,[sp,#8]
;;;392            if (cause == GAP_SUCCESS)
        0x002093ec:    b9fc        ..      CBNZ     r4,0x20942e ; gaps_client_read_result_cb + 138
;;;393            {
;;;394                uint16_t appearance;
;;;395                if (value_size != 2)
        0x002093ee:    4640        @F      MOV      r0,r8
        0x002093f0:    f1b80f02    ....    CMP      r8,#2
        0x002093f4:    d00a        ..      BEQ      0x20940c ; gaps_client_read_result_cb + 104
;;;396                {
;;;397                    PROFILE_PRINT_ERROR1("gaps_client_read_result_cb: invalid cccd len %d", value_size);
        0x002093f6:    4603        .F      MOV      r3,r0
        0x002093f8:    492b        +I      LDR      r1,[pc,#172] ; [0x2094a8] = 0x88014a4
        0x002093fa:    4826        &H      LDR      r0,[pc,#152] ; [0x209494] = 0x21103302
        0x002093fc:    2201        ."      MOVS     r2,#1
        0x002093fe:    315c        \1      ADDS     r1,r1,#0x5c
        0x00209400:    1e80        ..      SUBS     r0,r0,#2
        0x00209402:    f5fefb2c    ..,.    BL       log_buffer ; 0x7a5e
        0x00209406:    b007        ..      ADD      sp,sp,#0x1c
        0x00209408:    e8bd8ff0    ....    POP      {r4-r11,pc}
;;;398                    return;
;;;399                }
;;;400                LE_ARRAY_TO_UINT16(appearance, p_value);
        0x0020940c:    7830        0x      LDRB     r0,[r6,#0]
        0x0020940e:    7871        qx      LDRB     r1,[r6,#1]
        0x00209410:    eb002001    ...     ADD      r0,r0,r1,LSL #8
;;;401                cb_data.cb_content.read_result.data.appearance = appearance;
        0x00209414:    f8ad000c    ....    STRH     r0,[sp,#0xc]
;;;402            }
        0x00209418:    e014        ..      B        0x209444 ; gaps_client_read_result_cb + 160
;;;403        }
;;;404        else if (handle == hdl_cache[HDL_GAPS_DEVICE_NAME])
        0x0020941a:    88a8        ..      LDRH     r0,[r5,#4]
        0x0020941c:    42b8        .B      CMP      r0,r7
        0x0020941e:    d107        ..      BNE      0x209430 ; gaps_client_read_result_cb + 140
;;;405        {
;;;406            cb_data.cb_content.read_result.type = GAPS_READ_DEVICE_NAME;
        0x00209420:    2000        .       MOVS     r0,#0
        0x00209422:    f88d0008    ....    STRB     r0,[sp,#8]
;;;407            if (cause == GAP_SUCCESS)
        0x00209426:    b914        ..      CBNZ     r4,0x20942e ; gaps_client_read_result_cb + 138
;;;408            {
;;;409                cb_data.cb_content.read_result.data.device_name.value_size = value_size;
        0x00209428:    f8ad800c    ....    STRH     r8,[sp,#0xc]
;;;410                cb_data.cb_content.read_result.data.device_name.p_value = p_value;
        0x0020942c:    9604        ..      STR      r6,[sp,#0x10]
        0x0020942e:    e009        ..      B        0x209444 ; gaps_client_read_result_cb + 160
;;;411            }
;;;412        }
;;;413        else if (handle == hdl_cache[HDL_GAPS_CENTRAL_ADDR_RESOLUTION])
        0x00209430:    8928        (.      LDRH     r0,[r5,#8]
        0x00209432:    42b8        .B      CMP      r0,r7
        0x00209434:    d1e7        ..      BNE      0x209406 ; gaps_client_read_result_cb + 98
;;;414        {
;;;415            cb_data.cb_content.read_result.type = GAPS_READ_CENTRAL_ADDR_RESOLUTION;
        0x00209436:    2002        .       MOVS     r0,#2
        0x00209438:    f88d0008    ....    STRB     r0,[sp,#8]
;;;416            if (cause == GAP_SUCCESS)
        0x0020943c:    b914        ..      CBNZ     r4,0x209444 ; gaps_client_read_result_cb + 160
;;;417            {
;;;418                cb_data.cb_content.read_result.data.central_addr_res = *p_value;
        0x0020943e:    7830        0x      LDRB     r0,[r6,#0]
        0x00209440:    f88d000c    ....    STRB     r0,[sp,#0xc]
;;;419            }
;;;420        }
;;;421        else
;;;422        {
;;;423            return;
;;;424        }
;;;425    
;;;426        /* Inform application the read result. */
;;;427        if (gaps_client_cb)
        0x00209444:    f8da3004    ...0    LDR      r3,[r10,#4]
        0x00209448:    2b00        .+      CMP      r3,#0
        0x0020944a:    d0dc        ..      BEQ      0x209406 ; gaps_client_read_result_cb + 98
;;;428        {
;;;429            (*gaps_client_cb)(gaps_client, conn_id, &cb_data);
        0x0020944c:    4813        .H      LDR      r0,[pc,#76] ; [0x20949c] = 0x20cf2a
        0x0020944e:    aa01        ..      ADD      r2,sp,#4
        0x00209450:    4659        YF      MOV      r1,r11
        0x00209452:    7800        .x      LDRB     r0,[r0,#0]
        0x00209454:    4798        .G      BLX      r3
;;;430        }
;;;431        return;
;;;432    }
        0x00209456:    e7d6        ..      B        0x209406 ; gaps_client_read_result_cb + 98
    gaps_client_disc_cb
;;;433    
;;;434    
;;;435    static void gaps_client_disc_cb(uint8_t conn_id)
;;;436    {
        0x00209458:    b510        ..      PUSH     {r4,lr}
        0x0020945a:    4913        .I      LDR      r1,[pc,#76] ; [0x2094a8] = 0x88014a4
;;; .\..\..\..\src\ble\profile\client\gaps_client.c (436)
        0x0020945c:    4604        .F      MOV      r4,r0
;;;437        PROFILE_PRINT_INFO0("gap_client_disc_cb.");
        0x0020945e:    2200        ."      MOVS     r2,#0
        0x00209460:    3190        .1      ADDS     r1,r1,#0x90
        0x00209462:    480c        .H      LDR      r0,[pc,#48] ; [0x209494] = 0x21103302
        0x00209464:    f5fefafb    ....    BL       log_buffer ; 0x7a5e
;;;438        if (conn_id >= gaps_link_num)
        0x00209468:    480b        .H      LDR      r0,[pc,#44] ; [0x209498] = 0x20cfc0
        0x0020946a:    7801        .x      LDRB     r1,[r0,#0]
        0x0020946c:    428c        .B      CMP      r4,r1
        0x0020946e:    d309        ..      BCC      0x209484 ; gaps_client_disc_cb + 44
;;;439        {
;;;440            PROFILE_PRINT_ERROR1("gaps_client_disc_cb: failed invalid conn_id %d", conn_id);
        0x00209470:    490d        .I      LDR      r1,[pc,#52] ; [0x2094a8] = 0x88014a4
        0x00209472:    4623        #F      MOV      r3,r4
        0x00209474:    4807        .H      LDR      r0,[pc,#28] ; [0x209494] = 0x21103302
        0x00209476:    2201        ."      MOVS     r2,#1
        0x00209478:    31a8        .1      ADDS     r1,r1,#0xa8
        0x0020947a:    e8bd4010    ...@    POP      {r4,lr}
        0x0020947e:    1e80        ..      SUBS     r0,r0,#2
        0x00209480:    f5febaed    ....    B        log_buffer ; 0x7a5e
;;;441            return;
;;;442        }
;;;443        memset(&gaps_table[conn_id], 0, sizeof(T_GAPS_LINK));
        0x00209484:    6880        .h      LDR      r0,[r0,#8]
        0x00209486:    ebc401c4    ....    RSB      r1,r4,r4,LSL #3
        0x0020948a:    eb000041    ..A.    ADD      r0,r0,r1,LSL #1
        0x0020948e:    e00d        ..      B        0x2094ac ; gaps_client_disc_cb + 84
    $d
        0x00209490:    08801128    (...    DCD    142610728
        0x00209494:    21103302    .3.!    DCD    554709762
        0x00209498:    0020cfc0    .. .    DCD    2150336
        0x0020949c:    0020cf2a    *. .    DCD    2150186
        0x002094a0:    08801248    H...    DCD    142611016
        0x002094a4:    08801398    ....    DCD    142611352
        0x002094a8:    088014a4    ....    DCD    142611620
    $t
        0x002094ac:    e8bd4010    ...@    POP      {r4,lr}
        0x002094b0:    210e        .!      MOVS     r1,#0xe
        0x002094b2:    f650bdb3    P...    B        __aeabi_memclr ; 0x5a01c
    gaps_add_client
;;;444        return;
;;;445    }
;;;446    /**
;;;447     * @brief GAPS Client Callbacks.
;;;448    */
;;;449    const T_FUN_CLIENT_CBS gaps_client_cbs =
;;;450    {
;;;451        gaps_client_discover_state_cb,   //!< Discovery State callback function pointer
;;;452        gaps_client_discover_result_cb,  //!< Discovery result callback function pointer
;;;453        gaps_client_read_result_cb,      //!< Read response callback function pointer
;;;454        NULL,     //!< Write result callback function pointer
;;;455        NULL,  //!< Notify Indicate callback function pointer
;;;456        gaps_client_disc_cb       //!< Link disconnection callback function pointer
;;;457    };
;;;458    
;;;459    /**
;;;460      * @brief  Add gap service client to application.
;;;461      * @param[in]  app_cb pointer of app callback function to handle specific client module data.
;;;462      * @param[in]  link_num initialize link num.
;;;463      * @return Client ID of the specific client module.
;;;464      * @retval 0xff failed.
;;;465      * @retval other success.
;;;466      *
;;;467      * <b>Example usage</b>
;;;468      * \code{.c}
;;;469        void app_le_profile_init(void)
;;;470        {
;;;471            client_init(1);
;;;472            gaps_client_id  = gaps_add_client(app_client_callback, APP_MAX_LINKS);
;;;473        }
;;;474     * \endcode
;;;475      */
;;;476    T_CLIENT_ID gaps_add_client(P_FUN_GENERAL_APP_CB app_cb, uint8_t link_num)
;;;477    {
        0x002094b6:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x002094ba:    4d1a        .M      LDR      r5,[pc,#104] ; [0x209524] = 0x21103300
        0x002094bc:    4607        .F      MOV      r7,r0
        0x002094be:    460c        .F      MOV      r4,r1
        0x002094c0:    2904        .)      CMP      r1,#4
        0x002094c2:    d907        ..      BLS      0x2094d4 ; gaps_add_client + 30
;;;478        uint16_t size;
;;;479        if (link_num > GAPS_MAX_LINKS)
;;;480        {
;;;481            PROFILE_PRINT_ERROR1("gaps_add_client: invalid link_num %d", link_num);
        0x002094c4:    460b        .F      MOV      r3,r1
        0x002094c6:    2201        ."      MOVS     r2,#1
        0x002094c8:    4917        .I      LDR      r1,[pc,#92] ; [0x209528] = 0x8801580
        0x002094ca:    4628        (F      MOV      r0,r5
        0x002094cc:    f5fefac7    ....    BL       log_buffer ; 0x7a5e
;;;482            return 0xff;
        0x002094d0:    20ff        .       MOVS     r0,#0xff
        0x002094d2:    e73a        :.      B        0x20934a ; gaps_client_discover_result_cb + 62
;;;483        }
;;;484        if (false == client_register_spec_client_cb(&gaps_client, &gaps_client_cbs))
        0x002094d4:    4915        .I      LDR      r1,[pc,#84] ; [0x20952c] = 0x20bfc8
        0x002094d6:    4816        .H      LDR      r0,[pc,#88] ; [0x209530] = 0x20cf2a
        0x002094d8:    f644ff4c    D.L.    BL       client_register_spec_client_cb ; 0x4e374
        0x002094dc:    4e14        .N      LDR      r6,[pc,#80] ; [0x209530] = 0x20cf2a
        0x002094de:    b1b8        ..      CBZ      r0,0x209510 ; gaps_add_client + 90
;;;485        {
;;;486            gaps_client = CLIENT_PROFILE_GENERAL_ID;
;;;487            PROFILE_PRINT_ERROR0("gaps_add_client Fail !!!");
;;;488            return gaps_client;
;;;489        }
;;;490        PROFILE_PRINT_INFO1("gaps_add_client: client ID = %d", gaps_client);
        0x002094e0:    4911        .I      LDR      r1,[pc,#68] ; [0x209528] = 0x8801580
        0x002094e2:    4810        .H      LDR      r0,[pc,#64] ; [0x209524] = 0x21103300
        0x002094e4:    7833        3x      LDRB     r3,[r6,#0]
        0x002094e6:    2201        ."      MOVS     r2,#1
        0x002094e8:    3144        D1      ADDS     r1,r1,#0x44
        0x002094ea:    1c80        ..      ADDS     r0,r0,#2
        0x002094ec:    f5fefab7    ....    BL       log_buffer ; 0x7a5e
;;;491    
;;;492        /* register callback for profile to inform application that some events happened. */
;;;493        gaps_client_cb = app_cb;
        0x002094f0:    4d10        .M      LDR      r5,[pc,#64] ; [0x209534] = 0x20cfc0
        0x002094f2:    ebc400c4    ....    RSB      r0,r4,r4,LSL #3
        0x002094f6:    4a0d        .J      LDR      r2,[pc,#52] ; [0x20952c] = 0x20bfc8
;;;494        gaps_link_num = link_num;
        0x002094f8:    606f        o`      STR      r7,[r5,#4]
        0x002094fa:    0041        A.      LSLS     r1,r0,#1
        0x002094fc:    702c        ,p      STRB     r4,[r5,#0]
;;;495        size = gaps_link_num * sizeof(T_GAPS_LINK);
;;;496        gaps_table = os_mem_zalloc(RAM_TYPE_DATA_ON, size);
        0x002094fe:    f44f73f8    O..s    MOV      r3,#0x1f0
        0x00209502:    3218        .2      ADDS     r2,r2,#0x18
        0x00209504:    2000        .       MOVS     r0,#0
        0x00209506:    f61cfc57    ..W.    BL       os_mem_zalloc_intern ; 0x25db8
        0x0020950a:    60a8        .`      STR      r0,[r5,#8]
;;;497    
;;;498        return gaps_client;
        0x0020950c:    7830        0x      LDRB     r0,[r6,#0]
;;;499    }
        0x0020950e:    e71c        ..      B        0x20934a ; gaps_client_discover_result_cb + 62
        0x00209510:    20ff        .       MOVS     r0,#0xff
        0x00209512:    4905        .I      LDR      r1,[pc,#20] ; [0x209528] = 0x8801580
        0x00209514:    7030        0p      STRB     r0,[r6,#0]
        0x00209516:    2200        ."      MOVS     r2,#0
        0x00209518:    3128        (1      ADDS     r1,r1,#0x28
        0x0020951a:    4628        (F      MOV      r0,r5
        0x0020951c:    f5fefa9f    ....    BL       log_buffer ; 0x7a5e
        0x00209520:    e7f4        ..      B        0x20950c ; gaps_add_client + 86
    $d
        0x00209522:    0000        ..      DCW    0
        0x00209524:    21103300    .3.!    DCD    554709760
        0x00209528:    08801580    ....    DCD    142611840
        0x0020952c:    0020bfc8    .. .    DCD    2146248
        0x00209530:    0020cf2a    *. .    DCD    2150186
        0x00209534:    0020cfc0    .. .    DCD    2150336
    $t
    .text
    cmd_showcon
;;; ..\..\..\src\sample\ble_central\user_cmd.c
;;;76     {
        0x00209538:    b510        ..      PUSH     {r4,lr}
        0x0020953a:    b088        ..      SUB      sp,sp,#0x20
;;;77         uint8_t conn_id;
;;;78         T_GAP_CONN_INFO conn_info;
;;;79         for (conn_id = 0; conn_id < APP_MAX_LINKS; conn_id++)
        0x0020953c:    2400        .$      MOVS     r4,#0
;;;80         {
;;;81             if (le_get_conn_info(conn_id, &conn_info))
        0x0020953e:    a905        ..      ADD      r1,sp,#0x14
        0x00209540:    4620         F      MOV      r0,r4
        0x00209542:    f644fb19    D...    BL       le_get_conn_info ; 0x4db78
        0x00209546:    b1f8        ..      CBZ      r0,0x209588 ; cmd_showcon + 80
;;;82             {
;;;83     #if 0   //by vsop     	
;;;84           data_uart_print("#showcon#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",conn_id,
;;;85     				conn_info.remote_bd[5], conn_info.remote_bd[4],
;;;86     				conn_info.remote_bd[3], conn_info.remote_bd[2],
;;;87     				conn_info.remote_bd[1], conn_info.remote_bd[0]);
;;;88     #else
;;;89     	sprintf(cmd_buffer,"#showcon#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",conn_id,
        0x00209548:    f89d0019    ....    LDRB     r0,[sp,#0x19]
        0x0020954c:    f10d0c04    ....    ADD      r12,sp,#4
        0x00209550:    f89d3016    ...0    LDRB     r3,[sp,#0x16]
        0x00209554:    f89d2017    ...     LDRB     r2,[sp,#0x17]
        0x00209558:    f89d1018    ....    LDRB     r1,[sp,#0x18]
        0x0020955c:    e88c000f    ....    STM      r12,{r0-r3}
        0x00209560:    f89d001a    ....    LDRB     r0,[sp,#0x1a]
        0x00209564:    9000        ..      STR      r0,[sp,#0]
        0x00209566:    f89d301b    ...0    LDRB     r3,[sp,#0x1b]
        0x0020956a:    4622        "F      MOV      r2,r4
        0x0020956c:    a1eb        ..      ADR      r1,{pc}+0x3b0 ; 0x20991c
        0x0020956e:    48f7        .H      LDR      r0,[pc,#988] ; [0x20994c] = 0x20d170
        0x00209570:    f002fbee    ....    BL       __2sprintf ; 0x20bd50
;;;90     		conn_info.remote_bd[5], conn_info.remote_bd[4],
;;;91     		conn_info.remote_bd[3], conn_info.remote_bd[2],
;;;92     		conn_info.remote_bd[1], conn_info.remote_bd[0]);
;;;93     
;;;94     	FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));
        0x00209574:    48f5        .H      LDR      r0,[pc,#980] ; [0x20994c] = 0x20d170
        0x00209576:    f650fc71    P.q.    BL       strlen ; 0x59e5c
        0x0020957a:    b281        ..      UXTH     r1,r0
        0x0020957c:    48f3        .H      LDR      r0,[pc,#972] ; [0x20994c] = 0x20d170
        0x0020957e:    f001fb6a    ..j.    BL       FramingWrapFrameUartPrint ; 0x20ac56
;;;95     	os_delay(100);
        0x00209582:    2064        d       MOVS     r0,#0x64
        0x00209584:    f61df8f4    ....    BL       os_delay ; 0x26770
        0x00209588:    1c64        d.      ADDS     r4,r4,#1
        0x0020958a:    b2e4        ..      UXTB     r4,r4
        0x0020958c:    2c04        .,      CMP      r4,#4
        0x0020958e:    d3d6        ..      BCC      0x20953e ; cmd_showcon + 6
        0x00209590:    b008        ..      ADD      sp,sp,#0x20
;;;96     
;;;97     #endif
;;;98             }
;;;99         }
;;;100    #if 0	//by vsop
;;;101        data_uart_print("active link num %d,  idle link num %d\r\n",
;;;102                        le_get_active_link_num(), le_get_idle_link_num());
;;;103    #endif
;;;104        return (RESULT_SUCESS);
        0x00209592:    2000        .       MOVS     r0,#0
;;;105    }
        0x00209594:    bd10        ..      POP      {r4,pc}
    cmd_conupdreq
;;;106    
;;;107    /**
;;;108     * @brief LE connection param update request
;;;109     *
;;;110     * <b>Command table define</b>
;;;111     * \code{.c}
;;;112        {
;;;113            "conupdreq",
;;;114            "conupdreq [conn_id] [interval_min] [interval_max] [latency] [supervision_timeout]\n\r",
;;;115            "LE connection param update request\r\n\
;;;116            sample: conupdreq 0 0x30 0x40 0 500\n\r",
;;;117            cmd_conupdreq
;;;118        },
;;;119     * \endcode
;;;120     */
;;;121    static T_USER_CMD_PARSE_RESULT cmd_conupdreq(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;122    {
        0x00209596:    b5fe        ..      PUSH     {r1-r7,lr}
        0x00209598:    8981        ..      LDRH     r1,[r0,#0xc]
        0x0020959a:    8a02        ..      LDRH     r2,[r0,#0x10]
        0x0020959c:    8a83        ..      LDRH     r3,[r0,#0x14]
;;;123        T_GAP_CAUSE cause;
;;;124        uint8_t  conn_id = p_parse_value->dw_param[0];
        0x0020959e:    7a04        .z      LDRB     r4,[r0,#8]
;;;125        uint16_t conn_interval_min = p_parse_value->dw_param[1];
        0x002095a0:    b289        ..      UXTH     r1,r1
        0x002095a2:    8b00        ..      LDRH     r0,[r0,#0x18]
        0x002095a4:    004e        N.      LSLS     r6,r1,#1
        0x002095a6:    1eb6        ..      SUBS     r6,r6,#2
;;;126        uint16_t conn_interval_max = p_parse_value->dw_param[2];
        0x002095a8:    b292        ..      UXTH     r2,r2
        0x002095aa:    b280        ..      UXTH     r0,r0
        0x002095ac:    b2b6        ..      UXTH     r6,r6
        0x002095ae:    0055        U.      LSLS     r5,r2,#1
        0x002095b0:    e9cd0600    ....    STRD     r0,r6,[sp,#0]
        0x002095b4:    1ead        ..      SUBS     r5,r5,#2
        0x002095b6:    b2ad        ..      UXTH     r5,r5
;;;127        uint16_t conn_latency = p_parse_value->dw_param[3];
        0x002095b8:    b29b        ..      UXTH     r3,r3
;;;128        uint16_t supervision_timeout = p_parse_value->dw_param[4];
;;;129    
;;;130    
;;;131        cause = le_update_conn_param(conn_id,
        0x002095ba:    9502        ..      STR      r5,[sp,#8]
        0x002095bc:    4620         F      MOV      r0,r4
        0x002095be:    f644fb64    D.d.    BL       le_update_conn_param ; 0x4dc8a
;;;132                                     conn_interval_min,
;;;133                                     conn_interval_max,
;;;134                                     conn_latency,
;;;135                                     supervision_timeout,
;;;136                                     2 * (conn_interval_min - 1),
;;;137                                     2 * (conn_interval_max - 1)
;;;138                                    );
;;;139        return (T_USER_CMD_PARSE_RESULT)cause;
;;;140    }
        0x002095c2:    bdfe        ..      POP      {r1-r7,pc}
    cmd_disc
;;;141    
;;;142    /**
;;;143     * @brief Disconnect to remote device
;;;144     *
;;;145     * <b>Command table define</b>
;;;146     * \code{.c}
;;;147        {
;;;148            "disc",
;;;149            "disc [conn_id]\n\r",
;;;150            "Disconnect to remote device\n\r",
;;;151            cmd_disc
;;;152        },
;;;153     * \endcode
;;;154     */
;;;155    static T_USER_CMD_PARSE_RESULT cmd_disc(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;156    {
;;;157        uint8_t conn_id = p_parse_value->dw_param[0];
        0x002095c4:    7a00        .z      LDRB     r0,[r0,#8]
;;;158        T_GAP_CAUSE cause;
;;;159        cause = le_disconnect(conn_id);
        0x002095c6:    f644bb2d    D.-.    B        le_disconnect ; 0x4dc24
    cmd_authmode
;;;160        return (T_USER_CMD_PARSE_RESULT)cause;
;;;161    }
;;;162    
;;;163    /**
;;;164     * @brief Config authentication mode
;;;165     *
;;;166     * <b>Command table define</b>
;;;167     * \code{.c}
;;;168        {
;;;169            "authmode",
;;;170            "authmode [auth_flags] [io_cap] [sec_enable] [oob_enable]\n\r",
;;;171            "Config authentication mode\r\n\
;;;172            [auth_flags]:authentication req bit field: bit0-(bonding), bit2-(MITM), bit3-(SC)\r\n\
;;;173            [io_cap]:set io Capabilities: 0-(display only), 1-(display yes/no), 2-(keyboard noly), 3-(no IO), 4-(keyboard display)\r\n\
;;;174            [sec_enable]:Start smp pairing procedure when connected: 0-(disable), 1-(enable)\r\n\
;;;175            [oob_enable]:Enable oob flag: 0-(disable), 1-(enable)\r\n\
;;;176            sample: authmode 0x5 2 1 0\n\r",
;;;177            cmd_authmode
;;;178        },
;;;179     * \endcode
;;;180     */
;;;181    static T_USER_CMD_PARSE_RESULT cmd_authmode(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;182    {
        0x002095ca:    b500        ..      PUSH     {lr}
        0x002095cc:    b087        ..      SUB      sp,sp,#0x1c
;;;183        T_GAP_CAUSE cause;
;;;184        uint8_t  auth_pair_mode = GAP_PAIRING_MODE_PAIRABLE;
        0x002095ce:    2101        .!      MOVS     r1,#1
        0x002095d0:    2203        ."      MOVS     r2,#3
        0x002095d2:    f88d2010    ...     STRB     r2,[sp,#0x10]
        0x002095d6:    2200        ."      MOVS     r2,#0
        0x002095d8:    f88d1014    ....    STRB     r1,[sp,#0x14]
;;;185        uint16_t auth_flags = GAP_AUTHEN_BIT_BONDING_FLAG;
        0x002095dc:    f8ad100c    ....    STRH     r1,[sp,#0xc]
;;;186        uint8_t  auth_io_cap = GAP_IO_CAP_NO_INPUT_NO_OUTPUT;
;;;187        uint8_t  oob_enable = false;
        0x002095e0:    f88d2000    ...     STRB     r2,[sp,#0]
;;;188        uint8_t  auth_sec_req_enable = false;
        0x002095e4:    f88d2004    ...     STRB     r2,[sp,#4]
;;;189        uint16_t auth_sec_req_flags = GAP_AUTHEN_BIT_BONDING_FLAG;
        0x002095e8:    f8ad1008    ....    STRH     r1,[sp,#8]
;;;190    
;;;191        if (p_parse_value->param_count > 0)
        0x002095ec:    6841        Ah      LDR      r1,[r0,#4]
        0x002095ee:    2900        .)      CMP      r1,#0
        0x002095f0:    dd04        ..      BLE      0x2095fc ; cmd_authmode + 50
;;;192        {
;;;193            auth_flags = p_parse_value->dw_param[0];
        0x002095f2:    8902        ..      LDRH     r2,[r0,#8]
        0x002095f4:    f8ad200c    ...     STRH     r2,[sp,#0xc]
;;;194            auth_sec_req_flags = p_parse_value->dw_param[0];
        0x002095f8:    f8ad2008    ...     STRH     r2,[sp,#8]
;;;195        }
;;;196        if (p_parse_value->param_count > 1)
        0x002095fc:    2901        .)      CMP      r1,#1
        0x002095fe:    dd02        ..      BLE      0x209606 ; cmd_authmode + 60
;;;197        {
;;;198            auth_io_cap = p_parse_value->dw_param[1];
        0x00209600:    7b02        .{      LDRB     r2,[r0,#0xc]
        0x00209602:    f88d2010    ...     STRB     r2,[sp,#0x10]
;;;199        }
;;;200        if (p_parse_value->param_count > 2)
        0x00209606:    2902        .)      CMP      r1,#2
        0x00209608:    dd02        ..      BLE      0x209610 ; cmd_authmode + 70
;;;201        {
;;;202            auth_sec_req_enable = p_parse_value->dw_param[2];
        0x0020960a:    7c02        .|      LDRB     r2,[r0,#0x10]
        0x0020960c:    f88d2004    ...     STRB     r2,[sp,#4]
;;;203        }
;;;204        if (p_parse_value->param_count > 3)
        0x00209610:    2903        .)      CMP      r1,#3
        0x00209612:    dd02        ..      BLE      0x20961a ; cmd_authmode + 80
;;;205        {
;;;206            oob_enable = p_parse_value->dw_param[3];
        0x00209614:    7d00        .}      LDRB     r0,[r0,#0x14]
        0x00209616:    f88d0000    ....    STRB     r0,[sp,#0]
;;;207        }
;;;208        gap_set_param(GAP_PARAM_BOND_PAIRING_MODE, sizeof(auth_pair_mode), &auth_pair_mode);
        0x0020961a:    aa05        ..      ADD      r2,sp,#0x14
        0x0020961c:    2101        .!      MOVS     r1,#1
        0x0020961e:    f2402002    @..     MOV      r0,#0x202
        0x00209622:    f642fcc2    B...    BL       gap_set_param ; 0x4bfaa
;;;209        gap_set_param(GAP_PARAM_BOND_AUTHEN_REQUIREMENTS_FLAGS, sizeof(auth_flags), &auth_flags);
        0x00209626:    aa03        ..      ADD      r2,sp,#0xc
        0x00209628:    2102        .!      MOVS     r1,#2
        0x0020962a:    f2402003    @..     MOV      r0,#0x203
        0x0020962e:    f642fcbc    B...    BL       gap_set_param ; 0x4bfaa
;;;210        gap_set_param(GAP_PARAM_BOND_IO_CAPABILITIES, sizeof(auth_io_cap), &auth_io_cap);
        0x00209632:    aa04        ..      ADD      r2,sp,#0x10
        0x00209634:    2101        .!      MOVS     r1,#1
        0x00209636:    f44f7001    O..p    MOV      r0,#0x204
        0x0020963a:    f642fcb6    B...    BL       gap_set_param ; 0x4bfaa
;;;211        gap_set_param(GAP_PARAM_BOND_OOB_ENABLED, sizeof(uint8_t), &oob_enable);
        0x0020963e:    466a        jF      MOV      r2,sp
        0x00209640:    2101        .!      MOVS     r1,#1
        0x00209642:    f2402005    @..     MOV      r0,#0x205
        0x00209646:    f642fcb0    B...    BL       gap_set_param ; 0x4bfaa
;;;212        le_bond_set_param(GAP_PARAM_BOND_SEC_REQ_ENABLE, sizeof(auth_sec_req_enable), &auth_sec_req_enable);
        0x0020964a:    aa01        ..      ADD      r2,sp,#4
        0x0020964c:    2101        .!      MOVS     r1,#1
        0x0020964e:    f2402013    @..     MOV      r0,#0x213
        0x00209652:    f642fdcc    B...    BL       le_bond_set_param ; 0x4c1ee
;;;213        le_bond_set_param(GAP_PARAM_BOND_SEC_REQ_REQUIREMENT, sizeof(auth_sec_req_flags),
        0x00209656:    aa02        ..      ADD      r2,sp,#8
        0x00209658:    2102        .!      MOVS     r1,#2
        0x0020965a:    f44f7005    O..p    MOV      r0,#0x214
        0x0020965e:    f642fdc6    B...    BL       le_bond_set_param ; 0x4c1ee
;;;214                          &auth_sec_req_flags);
;;;215        cause = gap_set_pairable_mode();
        0x00209662:    f642fc3a    B.:.    BL       gap_set_pairable_mode ; 0x4beda
;;;216        return (T_USER_CMD_PARSE_RESULT)cause;
;;;217    }
        0x00209666:    b007        ..      ADD      sp,sp,#0x1c
        0x00209668:    bd00        ..      POP      {pc}
    cmd_sauth
;;;218    
;;;219    /**
;;;220     * @brief Send authentication request
;;;221     *
;;;222     * <b>Command table define</b>
;;;223     * \code{.c}
;;;224        {
;;;225            "sauth",
;;;226            "sauth [conn_id]\n\r",
;;;227            "Send authentication request\n\r",
;;;228            cmd_sauth
;;;229        },
;;;230     * \endcode
;;;231     */
;;;232    static T_USER_CMD_PARSE_RESULT cmd_sauth(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;233    {
;;;234        uint8_t conn_id = p_parse_value->dw_param[0];
        0x0020966a:    7a00        .z      LDRB     r0,[r0,#8]
;;;235        T_GAP_CAUSE cause;
;;;236        cause = le_bond_pair(conn_id);
        0x0020966c:    f642be71    B.q.    B        le_bond_pair ; 0x4c352
    cmd_userconf
;;;237        return (T_USER_CMD_PARSE_RESULT)cause;
;;;238    }
;;;239    
;;;240    /**
;;;241     * @brief Send user confirmation when show GAP_MSG_LE_BOND_USER_CONFIRMATION
;;;242     *
;;;243     * <b>Command table define</b>
;;;244     * \code{.c}
;;;245        {
;;;246            "userconf",
;;;247            "userconf [conn_id] [conf]\n\r",
;;;248            "Send user confirmation when show GAP_MSG_LE_BOND_USER_CONFIRMATION\r\n\
;;;249            [conf]: 0-(Reject), 1-(Accept)\r\n\
;;;250            sample: userconf 0 1\n\r",
;;;251            cmd_userconf
;;;252        },
;;;253     * \endcode
;;;254     */
;;;255    static T_USER_CMD_PARSE_RESULT cmd_userconf(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;256    {
;;;257        uint8_t conn_id = p_parse_value->dw_param[0];
        0x00209670:    7a02        .z      LDRB     r2,[r0,#8]
        0x00209672:    68c0        .h      LDR      r0,[r0,#0xc]
        0x00209674:    2101        .!      MOVS     r1,#1
;;; ..\..\..\src\sample\ble_central\user_cmd.c (256)
        0x00209676:    b900        ..      CBNZ     r0,0x20967a ; cmd_userconf + 10
;;;257        uint8_t conn_id = p_parse_value->dw_param[0];
;;;258        T_GAP_CFM_CAUSE confirm = GAP_CFM_CAUSE_ACCEPT;
;;;259        T_GAP_CAUSE cause;
;;;260        if (p_parse_value->dw_param[1] == 0)
;;;261        {
;;;262            confirm = GAP_CFM_CAUSE_REJECT;
        0x00209678:    2102        .!      MOVS     r1,#2
;;;263        }
;;;264        cause = le_bond_user_confirm(conn_id, confirm);
        0x0020967a:    4610        .F      MOV      r0,r2
        0x0020967c:    f642beca    B...    B        le_bond_user_confirm ; 0x4c414
    cmd_authkey
;;;265        return (T_USER_CMD_PARSE_RESULT)cause;
;;;266    }
;;;267    
;;;268    /**
;;;269     * @brief Input passkey when show GAP_MSG_LE_BOND_PASSKEY_INPUT
;;;270     *
;;;271     * <b>Command table define</b>
;;;272     * \code{.c}
;;;273        {
;;;274            "authkey",
;;;275            "authkey [conn_id] [passkey]\n\r",
;;;276            "Input passkey when show GAP_MSG_LE_BOND_PASSKEY_INPUT\r\n\
;;;277            [passkey]: 0 - 999999\r\n\
;;;278            sample: authkey 0 123456\n\r",
;;;279            cmd_authkey
;;;280        },
;;;281     * \endcode
;;;282     */
;;;283    static T_USER_CMD_PARSE_RESULT cmd_authkey(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;284    {
;;;285        uint8_t conn_id = p_parse_value->dw_param[0];
        0x00209680:    7a03        .z      LDRB     r3,[r0,#8]
        0x00209682:    68c1        .h      LDR      r1,[r0,#0xc]
        0x00209684:    48b2        .H      LDR      r0,[pc,#712] ; [0x209950] = 0xf423f
        0x00209686:    2201        ."      MOVS     r2,#1
        0x00209688:    4281        .B      CMP      r1,r0
;;; ..\..\..\src\sample\ble_central\user_cmd.c (284)
        0x0020968a:    d900        ..      BLS      0x20968e ; cmd_authkey + 14
;;;285        uint8_t conn_id = p_parse_value->dw_param[0];
;;;286        uint32_t passcode = p_parse_value->dw_param[1];
;;;287        T_GAP_CAUSE cause;
;;;288        T_GAP_CFM_CAUSE confirm = GAP_CFM_CAUSE_ACCEPT;
;;;289        if (passcode > GAP_PASSCODE_MAX)
;;;290        {
;;;291            confirm = GAP_CFM_CAUSE_REJECT;
        0x0020968c:    2202        ."      MOVS     r2,#2
;;;292        }
;;;293        cause = le_bond_passkey_input_confirm(conn_id, passcode,
        0x0020968e:    4618        .F      MOV      r0,r3
        0x00209690:    f642be77    B.w.    B        le_bond_passkey_input_confirm ; 0x4c382
    cmd_bondclear
;;;294                                              confirm);
;;;295        return (T_USER_CMD_PARSE_RESULT)cause;
;;;296    }
;;;297    
;;;298    /**
;;;299     * @brief Clear all bonded devices information
;;;300     *
;;;301     * <b>Command table define</b>
;;;302     * \code{.c}
;;;303        {
;;;304            "bondclear",
;;;305            "bondclear\n\r",
;;;306            "Clear all bonded devices information\n\r",
;;;307            cmd_bondclear
;;;308        },
;;;309     * \endcode
;;;310     */
;;;311    static T_USER_CMD_PARSE_RESULT cmd_bondclear(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;312    {
        0x00209694:    b510        ..      PUSH     {r4,lr}
;;;313        le_bond_clear_all_keys();
        0x00209696:    f642fd5b    B.[.    BL       le_bond_clear_all_keys ; 0x4c150
;;;314        return (RESULT_SUCESS);
        0x0020969a:    2000        .       MOVS     r0,#0
;;;315    }
        0x0020969c:    bd10        ..      POP      {r4,pc}
    cmd_bonddel
;;;316    
;;;317    /**
;;;318     * @brief Clear bonded devices information by connect id
;;;319     *
;;;320     * <b>Command table define</b>
;;;321     * \code{.c}
;;;322        {
;;;323            "bonddel",
;;;324            "bonddel [conn_id]\n\r",
;;;325            "Clear bonded devices information by connect id\n\r",
;;;326            cmd_bonddel
;;;327        },
;;;328     * \endcode
;;;329     */
;;;330    static T_USER_CMD_PARSE_RESULT cmd_bonddel(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;331    {
;;;332        uint8_t conn_id = p_parse_value->dw_param[0];
        0x0020969e:    7a00        .z      LDRB     r0,[r0,#8]
;;;333        T_GAP_CAUSE cause;
;;;334        cause = le_bond_delete_by_idx(conn_id);
        0x002096a0:    f642bd64    B.d.    B        le_bond_delete_by_idx ; 0x4c16c
    uarttest
;;;335        return (T_USER_CMD_PARSE_RESULT)cause;
;;;336    }
;;;337    
;;;338    /**
;;;339     * @brief use for pcba autotest ble module uart test
;;;340     *
;;;341     * <b>Command table define</b>
;;;342     * \code{.c}
;;;343        {
;;;344            "uarttest",
;;;345            "uarttest\n\r",
;;;346            "for autotest uart port test\n\r",
;;;347            uarttest
;;;348    
;;;349        },
;;;350     * \endcode
;;;351     */
;;;352    static T_USER_CMD_PARSE_RESULT uarttest(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;353    {
        0x002096a4:    b510        ..      PUSH     {r4,lr}
;;;354    	data_uart_print("bt uart test ok\r\n");
        0x002096a6:    a0ab        ..      ADR      r0,{pc}+0x2ae ; 0x209954
        0x002096a8:    f001faba    ....    BL       data_uart_print ; 0x20ac20
;;;355         return (RESULT_SUCESS);
        0x002096ac:    2000        .       MOVS     r0,#0
;;;356    }
        0x002096ae:    bd10        ..      POP      {r4,pc}
    cmd_bondinfo
;;;357    
;;;358    
;;;359    /**
;;;360     * @brief Get all Bonded devices information
;;;361     *
;;;362     * <b>Command table define</b>
;;;363     * \code{.c}
;;;364        {
;;;365            "bondinfo",
;;;366            "bondinfo\n\r",
;;;367            "Get all Bonded devices information\n\r",
;;;368            cmd_bondinfo
;;;369        },
;;;370     * \endcode
;;;371     */
;;;372    static T_USER_CMD_PARSE_RESULT cmd_bondinfo(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;373    {
        0x002096b0:    b570        p.      PUSH     {r4-r6,lr}
        0x002096b2:    b086        ..      SUB      sp,sp,#0x18
        0x002096b4:    2400        .$      MOVS     r4,#0
        0x002096b6:    4dac        .M      LDR      r5,[pc,#688] ; [0x209968] = 0x202ebc
;;; ..\..\..\src\sample\ble_central\user_cmd.c (373)
        0x002096b8:    e01f        ..      B        0x2096fa ; cmd_bondinfo + 74
;;;374        uint8_t i;
;;;375        T_LE_KEY_ENTRY *p_entry;
;;;376        for (i = 0; i < bond_storage_num; i++)
;;;377        {
;;;378            p_entry = le_find_key_entry_by_idx(i);
        0x002096ba:    4620         F      MOV      r0,r4
        0x002096bc:    f646fdf0    F...    BL       le_find_key_entry_by_idx ; 0x502a0
;;;379            if (p_entry != NULL)
        0x002096c0:    b1c8        ..      CBZ      r0,0x2096f6 ; cmd_bondinfo + 70
;;;380            {
;;;381    #if 0        
;;;382              	data_uart_print("#bondinfo#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;383    							p_entry->idx,
;;;384    							p_entry->remote_bd.addr[5],
;;;385    							p_entry->remote_bd.addr[4],
;;;386    							p_entry->remote_bd.addr[3],
;;;387    							p_entry->remote_bd.addr[2],
;;;388    							p_entry->remote_bd.addr[1],
;;;389    							p_entry->remote_bd.addr[0]);
;;;390    #else
;;;391    			sprintf(cmd_buffer,"#bondinfo#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
        0x002096c2:    7ac1        .z      LDRB     r1,[r0,#0xb]
        0x002096c4:    f10d0c04    ....    ADD      r12,sp,#4
        0x002096c8:    7a06        .z      LDRB     r6,[r0,#8]
        0x002096ca:    7a43        Cz      LDRB     r3,[r0,#9]
        0x002096cc:    7a82        .z      LDRB     r2,[r0,#0xa]
        0x002096ce:    e88c004e    ..N.    STM      r12,{r1-r3,r6}
        0x002096d2:    7b01        .{      LDRB     r1,[r0,#0xc]
        0x002096d4:    9100        ..      STR      r1,[sp,#0]
        0x002096d6:    7b43        C{      LDRB     r3,[r0,#0xd]
        0x002096d8:    7842        Bx      LDRB     r2,[r0,#1]
        0x002096da:    a1a4        ..      ADR      r1,{pc}+0x292 ; 0x20996c
        0x002096dc:    489b        .H      LDR      r0,[pc,#620] ; [0x20994c] = 0x20d170
        0x002096de:    f002fb37    ..7.    BL       __2sprintf ; 0x20bd50
;;;392    							p_entry->idx,
;;;393    							p_entry->remote_bd.addr[5],
;;;394    							p_entry->remote_bd.addr[4],
;;;395    							p_entry->remote_bd.addr[3],
;;;396    							p_entry->remote_bd.addr[2],
;;;397    							p_entry->remote_bd.addr[1],
;;;398    							p_entry->remote_bd.addr[0]);
;;;399    							
;;;400    							FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));
        0x002096e2:    489a        .H      LDR      r0,[pc,#616] ; [0x20994c] = 0x20d170
        0x002096e4:    f650fbba    P...    BL       strlen ; 0x59e5c
        0x002096e8:    b281        ..      UXTH     r1,r0
        0x002096ea:    4898        .H      LDR      r0,[pc,#608] ; [0x20994c] = 0x20d170
        0x002096ec:    f001fab3    ....    BL       FramingWrapFrameUartPrint ; 0x20ac56
;;;401    							os_delay(100);
        0x002096f0:    2064        d       MOVS     r0,#0x64
        0x002096f2:    f61df83d    ..=.    BL       os_delay ; 0x26770
        0x002096f6:    1c64        d.      ADDS     r4,r4,#1
        0x002096f8:    b2e4        ..      UXTB     r4,r4
        0x002096fa:    7828        (x      LDRB     r0,[r5,#0]
        0x002096fc:    4284        .B      CMP      r4,r0
        0x002096fe:    d3dc        ..      BCC      0x2096ba ; cmd_bondinfo + 10
        0x00209700:    b006        ..      ADD      sp,sp,#0x18
;;;402    #endif
;;;403            }
;;;404        }
;;;405        return (RESULT_SUCESS);
        0x00209702:    2000        .       MOVS     r0,#0
;;;406    }
        0x00209704:    bd70        p.      POP      {r4-r6,pc}
    cmd_scan
;;;407    /************************** Central only *************************************/
;;;408    /**
;;;409     * @brief Start scan
;;;410     *
;;;411     * <b>Command table define</b>
;;;412     * \code{.c}
;;;413        {
;;;414            "scan",
;;;415            "scan [filter_policy] [filter_duplicate]\n\r",
;;;416            "Start scan\r\n\
;;;417            [filter_policy]: 0-(any), 1-(whitelist), 2-(any RPA), 3-(whitelist RPA) \r\n\
;;;418            [filter_duplicate]: 0-(disable), 1-(enable) \n\r",
;;;419            cmd_scan
;;;420        },
;;;421     * \endcode
;;;422     */
;;;423    static T_USER_CMD_PARSE_RESULT cmd_scan(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;424    {
        0x00209706:    b51c        ..      PUSH     {r2-r4,lr}
;;;425        T_GAP_CAUSE cause;
;;;426        uint8_t scan_filter_policy = GAP_SCAN_FILTER_ANY;
        0x00209708:    2100        .!      MOVS     r1,#0
        0x0020970a:    f88d1000    ....    STRB     r1,[sp,#0]
;;;427        uint8_t scan_filter_duplicate = GAP_SCAN_FILTER_DUPLICATE_ENABLE;
        0x0020970e:    2101        .!      MOVS     r1,#1
        0x00209710:    f88d1004    ....    STRB     r1,[sp,#4]
;;;428    
;;;429        if (p_parse_value->param_count > 0)
        0x00209714:    6841        Ah      LDR      r1,[r0,#4]
        0x00209716:    2900        .)      CMP      r1,#0
        0x00209718:    dd02        ..      BLE      0x209720 ; cmd_scan + 26
;;;430        {
;;;431            scan_filter_policy = p_parse_value->dw_param[0];
        0x0020971a:    7a02        .z      LDRB     r2,[r0,#8]
        0x0020971c:    f88d2000    ...     STRB     r2,[sp,#0]
;;;432        }
;;;433        if (p_parse_value->param_count > 1)
        0x00209720:    2901        .)      CMP      r1,#1
        0x00209722:    dd02        ..      BLE      0x20972a ; cmd_scan + 36
;;;434        {
;;;435            scan_filter_duplicate = p_parse_value->dw_param[1];
        0x00209724:    7b00        .{      LDRB     r0,[r0,#0xc]
        0x00209726:    f88d0004    ....    STRB     r0,[sp,#4]
;;;436        }
;;;437    
;;;438        link_mgr_clear_device_list();
        0x0020972a:    f012fe4e    ..N.    BL       link_mgr_clear_device_list ; 0x21c3ca
;;;439        le_scan_set_param(GAP_PARAM_SCAN_FILTER_POLICY, sizeof(scan_filter_policy),
        0x0020972e:    466a        jF      MOV      r2,sp
        0x00209730:    2101        .!      MOVS     r1,#1
        0x00209732:    f44f7011    O..p    MOV      r0,#0x244
        0x00209736:    f648fe1d    H...    BL       le_scan_set_param ; 0x52374
;;;440                          &scan_filter_policy);
;;;441        le_scan_set_param(GAP_PARAM_SCAN_FILTER_DUPLICATES, sizeof(scan_filter_duplicate),
        0x0020973a:    aa01        ..      ADD      r2,sp,#4
        0x0020973c:    2101        .!      MOVS     r1,#1
        0x0020973e:    f2402045    @.E     MOV      r0,#0x245
        0x00209742:    f648fe17    H...    BL       le_scan_set_param ; 0x52374
;;;442                          &scan_filter_duplicate);
;;;443        cause = le_scan_start();
        0x00209746:    f648fe95    H...    BL       le_scan_start ; 0x52474
;;;444        return (T_USER_CMD_PARSE_RESULT)cause;
;;;445    }
        0x0020974a:    bd1c        ..      POP      {r2-r4,pc}
    cmd_stopscan
;;;446    
;;;447    /**
;;;448     * @brief Stop scan
;;;449     *
;;;450     * <b>Command table define</b>
;;;451     * \code{.c}
;;;452        {
;;;453            "stopscan",
;;;454            "stopscan\n\r",
;;;455            "Stop scan\n\r",
;;;456            cmd_stopscan
;;;457        },
;;;458     * \endcode
;;;459     */
;;;460    static T_USER_CMD_PARSE_RESULT cmd_stopscan(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;461    {
;;;462        T_GAP_CAUSE cause;
;;;463        cause = le_scan_stop();
        0x0020974c:    f648bec1    H...    B        le_scan_stop ; 0x524d2
    cmd_showdev
;;;464        return (T_USER_CMD_PARSE_RESULT)cause;
;;;465    }
;;;466    
;;;467    /**
;;;468     * @brief Show scan dev list: filter simple ble service
;;;469     *
;;;470     * <b>Command table define</b>
;;;471     * \code{.c}
;;;472        {
;;;473            "showdev",
;;;474            "showdev\n\r",
;;;475            "Show scan dev list: filter simple ble service\n\r",
;;;476            cmd_showdev
;;;477        },
;;;478     * \endcode
;;;479     */
;;;480    static T_USER_CMD_PARSE_RESULT cmd_showdev(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;481    {
        0x00209750:    b5f0        ..      PUSH     {r4-r7,lr}
        0x00209752:    b085        ..      SUB      sp,sp,#0x14
        0x00209754:    2500        .%      MOVS     r5,#0
        0x00209756:    4f91        .O      LDR      r7,[pc,#580] ; [0x20999c] = 0x20d379
        0x00209758:    4e91        .N      LDR      r6,[pc,#580] ; [0x2099a0] = 0x20d378
;;; ..\..\..\src\sample\ble_central\user_cmd.c (481)
        0x0020975a:    e01e        ..      B        0x20979a ; cmd_showdev + 74
        0x0020975c:    ebc500c5    ....    RSB      r0,r5,r5,LSL #3
        0x00209760:    19c4        ..      ADDS     r4,r0,r7
        0x00209762:    5c39        9\      LDRB     r1,[r7,r0]
        0x00209764:    7860        `x      LDRB     r0,[r4,#1]
        0x00209766:    78a3        .x      LDRB     r3,[r4,#2]
        0x00209768:    78e2        .x      LDRB     r2,[r4,#3]
        0x0020976a:    e9cd0103    ....    STRD     r0,r1,[sp,#0xc]
        0x0020976e:    e9cd2301    ...#    STRD     r2,r3,[sp,#4]
        0x00209772:    7920         y      LDRB     r0,[r4,#4]
        0x00209774:    9000        ..      STR      r0,[sp,#0]
        0x00209776:    7963        cy      LDRB     r3,[r4,#5]
        0x00209778:    462a        *F      MOV      r2,r5
        0x0020977a:    a18a        ..      ADR      r1,{pc}+0x22a ; 0x2099a4
        0x0020977c:    4873        sH      LDR      r0,[pc,#460] ; [0x20994c] = 0x20d170
        0x0020977e:    f002fae7    ....    BL       __2sprintf ; 0x20bd50
        0x00209782:    4872        rH      LDR      r0,[pc,#456] ; [0x20994c] = 0x20d170
        0x00209784:    f650fb6a    P.j.    BL       strlen ; 0x59e5c
        0x00209788:    b281        ..      UXTH     r1,r0
        0x0020978a:    4870        pH      LDR      r0,[pc,#448] ; [0x20994c] = 0x20d170
        0x0020978c:    f001fa63    ..c.    BL       FramingWrapFrameUartPrint ; 0x20ac56
        0x00209790:    2064        d       MOVS     r0,#0x64
        0x00209792:    f61cffed    ....    BL       os_delay ; 0x26770
        0x00209796:    1c6d        m.      ADDS     r5,r5,#1
;;;482        uint8_t i;
;;;483    #if 0 //by vsop	
;;;484        data_uart_print("Advertising and Scan response: filter uuid = 0xA00A dev list\r\n");
;;;485    #endif
;;;486        for (i = 0; i < dev_list_count; i++)
        0x00209798:    b2ed        ..      UXTB     r5,r5
        0x0020979a:    7830        0x      LDRB     r0,[r6,#0]
        0x0020979c:    4285        .B      CMP      r5,r0
        0x0020979e:    d3dd        ..      BCC      0x20975c ; cmd_showdev + 12
;;;487        {
;;;488    #if 0 //by vsop    
;;;489           data_uart_print("#showdev#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;490    						i,
;;;491    						dev_list[i].bd_addr[5], dev_list[i].bd_addr[4],
;;;492    						dev_list[i].bd_addr[3], dev_list[i].bd_addr[2],
;;;493    						dev_list[i].bd_addr[1], dev_list[i].bd_addr[0]);
;;;494    #else
;;;495    		sprintf(cmd_buffer,"#showdev#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;496    						i,
;;;497    						dev_list[i].bd_addr[5], dev_list[i].bd_addr[4],
;;;498    						dev_list[i].bd_addr[3], dev_list[i].bd_addr[2],
;;;499    						dev_list[i].bd_addr[1], dev_list[i].bd_addr[0]);
;;;500    							
;;;501    							FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));
;;;502    							os_delay(100);
;;;503    
;;;504    #endif
;;;505            if (dev_list[i].bd_type == GAP_REMOTE_ADDR_LE_RANDOM)
;;;506            {
;;;507                uint8_t addr = dev_list[i].bd_addr[5] & RANDOM_ADDR_MASK;
;;;508                if (addr == RANDOM_ADDR_MASK_STATIC)
;;;509                {
;;;510                    //data_uart_print("Static Random Addr\r\n");
;;;511                }
;;;512                else if (addr == RANDOM_ADDR_MASK_RESOLVABLE)
;;;513                {
;;;514                    //data_uart_print("Resolv Random Addr\r\n");
;;;515                }
;;;516                else if (addr == RANDOM_ADDR_MASK_NON_RESOLVABLE)
;;;517                {
;;;518                    //data_uart_print("Non-resolv Random Addr\r\n");
;;;519                }
;;;520                else
;;;521                {
;;;522                    //data_uart_print("Unknown Random Addr\r\n");
;;;523                }
;;;524            }
;;;525    				//os_delay(100);
;;;526        }
;;;527    	if(dev_list_count==0)
        0x002097a0:    f0100fff    ....    TST      r0,#0xff
        0x002097a4:    d10a        ..      BNE      0x2097bc ; cmd_showdev + 108
;;;528    	{
;;;529    		#if 0
;;;530    		data_uart_print("#showdev#<Y>\r\n");
;;;531    		#else
;;;532    		strcpy(cmd_buffer,"#showdev#<Y>\r\n");
        0x002097a6:    a18b        ..      ADR      r1,{pc}+0x22e ; 0x2099d4
        0x002097a8:    4868        hH      LDR      r0,[pc,#416] ; [0x20994c] = 0x20d170
        0x002097aa:    f002fb4d    ..M.    BL       strcpy ; 0x20be48
;;;533    		FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));
        0x002097ae:    4867        gH      LDR      r0,[pc,#412] ; [0x20994c] = 0x20d170
        0x002097b0:    f650fb54    P.T.    BL       strlen ; 0x59e5c
        0x002097b4:    b281        ..      UXTH     r1,r0
        0x002097b6:    4865        eH      LDR      r0,[pc,#404] ; [0x20994c] = 0x20d170
        0x002097b8:    f001fa4d    ..M.    BL       FramingWrapFrameUartPrint ; 0x20ac56
        0x002097bc:    b005        ..      ADD      sp,sp,#0x14
;;;534    
;;;535    		#endif
;;;536    	}
;;;537    
;;;538        return (RESULT_SUCESS);
        0x002097be:    2000        .       MOVS     r0,#0
;;;539    }
        0x002097c0:    bdf0        ..      POP      {r4-r7,pc}
    cmd_con
;;;540    
;;;541    /**
;;;542     * @brief Connect to remote device: use address
;;;543     *
;;;544     * <b>Command table define</b>
;;;545     * \code{.c}
;;;546        {
;;;547            "con",
;;;548            "con [BD0] [BD1] [BD2] [BD3] [BD4] [BD5] [addr_type]\n\r",
;;;549            "Connect to remote device: use address\r\n\
;;;550            [BD0] [BD1] [BD2] [BD3] [BD4] [BD5]: remote device address\r\n\
;;;551            [addr_type]: 0-(public), 1-(random)\r\n\
;;;552            sample: con x11 x22 x33 x44 x55 x66 0 \n\r",
;;;553            cmd_con
;;;554        },
;;;555     * \endcode
;;;556     */
;;;557    static T_USER_CMD_PARSE_RESULT cmd_con(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;558    {
        0x002097c2:    b570        p.      PUSH     {r4-r6,lr}
        0x002097c4:    4604        .F      MOV      r4,r0
        0x002097c6:    b088        ..      SUB      sp,sp,#0x20
;;;559        T_GAP_CAUSE cause;
;;;560        uint8_t addr[6] = {0};
        0x002097c8:    2000        .       MOVS     r0,#0
        0x002097ca:    9006        ..      STR      r0,[sp,#0x18]
        0x002097cc:    2110        .!      MOVS     r1,#0x10
        0x002097ce:    f8ad1004    ....    STRH     r1,[sp,#4]
        0x002097d2:    f8ad000c    ....    STRH     r0,[sp,#0xc]
        0x002097d6:    9005        ..      STR      r0,[sp,#0x14]
;;;561        uint8_t addr_len;
;;;562        uint8_t addr_type = GAP_REMOTE_ADDR_LE_PUBLIC;
        0x002097d8:    4605        .F      MOV      r5,r0
;;;563        T_GAP_LE_CONN_REQ_PARAM conn_req_param;
;;;564    
;;;565        conn_req_param.scan_interval = 0x10;
;;;566        conn_req_param.scan_window = 0x10;
        0x002097da:    f8ad1006    ....    STRH     r1,[sp,#6]
;;;567        conn_req_param.conn_interval_min = 80;
        0x002097de:    2150        P!      MOVS     r1,#0x50
        0x002097e0:    209e        .       MOVS     r0,#0x9e
        0x002097e2:    f8ad1008    ....    STRH     r1,[sp,#8]
        0x002097e6:    f8ad0010    ....    STRH     r0,[sp,#0x10]
;;;568        conn_req_param.conn_interval_max = 80;
        0x002097ea:    f8ad100a    ....    STRH     r1,[sp,#0xa]
;;;569        conn_req_param.conn_latency = 0;
;;;570        conn_req_param.supv_tout = 1000;
        0x002097ee:    f44f767a    O.zv    MOV      r6,#0x3e8
        0x002097f2:    f8ad0012    ....    STRH     r0,[sp,#0x12]
        0x002097f6:    f8ad600e    ...`    STRH     r6,[sp,#0xe]
;;;571        conn_req_param.ce_len_min = 2 * (conn_req_param.conn_interval_min - 1);
;;;572        conn_req_param.ce_len_max = 2 * (conn_req_param.conn_interval_max - 1);
;;;573        le_set_conn_param(GAP_CONN_PARAM_1M, &conn_req_param);
        0x002097fa:    a901        ..      ADD      r1,sp,#4
        0x002097fc:    2000        .       MOVS     r0,#0
        0x002097fe:    f644fa66    D.f.    BL       le_set_conn_param ; 0x4dcce
;;;574    
;;;575        for (addr_len = 0; addr_len < GAP_BD_ADDR_LEN; addr_len++)
        0x00209802:    2100        .!      MOVS     r1,#0
        0x00209804:    a805        ..      ADD      r0,sp,#0x14
        0x00209806:    f1c10205    ....    RSB      r2,r1,#5
        0x0020980a:    eb040282    ....    ADD      r2,r4,r2,LSL #2
        0x0020980e:    7a12        .z      LDRB     r2,[r2,#8]
        0x00209810:    5442        BT      STRB     r2,[r0,r1]
        0x00209812:    1c49        I.      ADDS     r1,r1,#1
        0x00209814:    b2c9        ..      UXTB     r1,r1
        0x00209816:    2906        .)      CMP      r1,#6
        0x00209818:    d3f5        ..      BCC      0x209806 ; cmd_con + 68
;;;576        {
;;;577            addr[addr_len] = p_parse_value->dw_param[GAP_BD_ADDR_LEN - addr_len - 1];
;;;578        }
;;;579        if (p_parse_value->param_count >= 7)
        0x0020981a:    6860        `h      LDR      r0,[r4,#4]
        0x0020981c:    2807        .(      CMP      r0,#7
        0x0020981e:    db01        ..      BLT      0x209824 ; cmd_con + 98
;;;580        {
;;;581            addr_type = p_parse_value->dw_param[6];
        0x00209820:    f8945020    .. P    LDRB     r5,[r4,#0x20]
;;;582        }
;;;583    
;;;584        cause = le_connect(GAP_PHYS_CONN_INIT_1M_BIT, addr, (T_GAP_REMOTE_ADDR_TYPE)addr_type,
        0x00209824:    2300        .#      MOVS     r3,#0
        0x00209826:    462a        *F      MOV      r2,r5
        0x00209828:    a905        ..      ADD      r1,sp,#0x14
        0x0020982a:    2001        .       MOVS     r0,#1
        0x0020982c:    9600        ..      STR      r6,[sp,#0]
        0x0020982e:    f644faa3    D...    BL       le_connect ; 0x4dd78
;;;585                           GAP_LOCAL_ADDR_LE_PUBLIC,
;;;586                           1000);
;;;587    
;;;588        return (T_USER_CMD_PARSE_RESULT)cause;
;;;589    }
        0x00209832:    b008        ..      ADD      sp,sp,#0x20
        0x00209834:    bd70        p.      POP      {r4-r6,pc}
    cmd_condev
;;;590    
;;;591    /**
;;;592     * @brief Connect to remote device: use showdev to show idx
;;;593     *
;;;594     * <b>Command table define</b>
;;;595     * \code{.c}
;;;596        {
;;;597            "condev",
;;;598            "condev [idx]\n\r",
;;;599            "Connect to remote device: use showdev to show idx\r\n\
;;;600            [idx]: use cmd showdev to show idx before use this cmd\r\n\
;;;601            sample: condev 0\n\r",
;;;602            cmd_condev
;;;603        },
;;;604     * \endcode
;;;605     */
;;;606    static T_USER_CMD_PARSE_RESULT cmd_condev(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;607    {
        0x00209836:    b530        0.      PUSH     {r4,r5,lr}
        0x00209838:    7a04        .z      LDRB     r4,[r0,#8]
        0x0020983a:    4859        YH      LDR      r0,[pc,#356] ; [0x2099a0] = 0x20d378
        0x0020983c:    b085        ..      SUB      sp,sp,#0x14
        0x0020983e:    7800        .x      LDRB     r0,[r0,#0]
        0x00209840:    4284        .B      CMP      r4,r0
        0x00209842:    d225        %.      BCS      0x209890 ; cmd_condev + 90
;;;608        uint8_t dev_idx = p_parse_value->dw_param[0];
;;;609        if (dev_idx < dev_list_count)
;;;610        {
;;;611            T_GAP_CAUSE cause;
;;;612            T_GAP_LE_CONN_REQ_PARAM conn_req_param;
;;;613    
;;;614            conn_req_param.scan_interval = 0x10;
        0x00209844:    2010        .       MOVS     r0,#0x10
        0x00209846:    f8ad0004    ....    STRH     r0,[sp,#4]
;;;615            conn_req_param.scan_window = 0x10;
        0x0020984a:    f8ad0006    ....    STRH     r0,[sp,#6]
;;;616            conn_req_param.conn_interval_min = 80;
        0x0020984e:    2050        P       MOVS     r0,#0x50
        0x00209850:    f8ad0008    ....    STRH     r0,[sp,#8]
;;;617            conn_req_param.conn_interval_max = 80;
        0x00209854:    f8ad000a    ....    STRH     r0,[sp,#0xa]
;;;618            conn_req_param.conn_latency = 0;
        0x00209858:    2000        .       MOVS     r0,#0
        0x0020985a:    f8ad000c    ....    STRH     r0,[sp,#0xc]
        0x0020985e:    209e        .       MOVS     r0,#0x9e
        0x00209860:    f8ad0010    ....    STRH     r0,[sp,#0x10]
;;;619            conn_req_param.supv_tout = 1000;
        0x00209864:    f44f757a    O.zu    MOV      r5,#0x3e8
        0x00209868:    f8ad0012    ....    STRH     r0,[sp,#0x12]
        0x0020986c:    f8ad500e    ...P    STRH     r5,[sp,#0xe]
;;;620            conn_req_param.ce_len_min = 2 * (conn_req_param.conn_interval_min - 1);
;;;621            conn_req_param.ce_len_max = 2 * (conn_req_param.conn_interval_max - 1);
;;;622            le_set_conn_param(GAP_CONN_PARAM_1M, &conn_req_param);
        0x00209870:    a901        ..      ADD      r1,sp,#4
        0x00209872:    2000        .       MOVS     r0,#0
        0x00209874:    f644fa2b    D.+.    BL       le_set_conn_param ; 0x4dcce
;;;623            cause = le_connect(GAP_PHYS_CONN_INIT_1M_BIT,
        0x00209878:    4848        HH      LDR      r0,[pc,#288] ; [0x20999c] = 0x20d379
        0x0020987a:    ebc401c4    ....    RSB      r1,r4,r4,LSL #3
        0x0020987e:    4401        .D      ADD      r1,r1,r0
        0x00209880:    9500        ..      STR      r5,[sp,#0]
        0x00209882:    798a        .y      LDRB     r2,[r1,#6]
        0x00209884:    2300        .#      MOVS     r3,#0
        0x00209886:    2001        .       MOVS     r0,#1
        0x00209888:    f644fa76    D.v.    BL       le_connect ; 0x4dd78
        0x0020988c:    b005        ..      ADD      sp,sp,#0x14
        0x0020988e:    bd30        0.      POP      {r4,r5,pc}
;;;624                               dev_list[dev_idx].bd_addr,
;;;625                               (T_GAP_REMOTE_ADDR_TYPE)dev_list[dev_idx].bd_type,
;;;626                               GAP_LOCAL_ADDR_LE_PUBLIC,
;;;627                               1000);
;;;628            return (T_USER_CMD_PARSE_RESULT)cause;
;;;629        }
;;;630        else
;;;631        {
;;;632            return RESULT_ERR;
        0x00209890:    2020                MOVS     r0,#0x20
;;;633        }
;;;634    }
        0x00209892:    e7fb        ..      B        0x20988c ; cmd_condev + 86
    cmd_gapread
;;;635    /************************** GATT client *************************************/
;;;636    /**
;;;637     * @brief Read GAP service characteristic value
;;;638     *
;;;639     * <b>Command table define</b>
;;;640     * \code{.c}
;;;641        {
;;;642            "gapread",
;;;643            "gapread [conn_id] [type]\n\r",
;;;644            "Read GAP service characteristic value\r\n\
;;;645            [type]: 0-(read device name), 1-(read appearance)\r\n\
;;;646            simple: gapread 0 0\n\r",
;;;647            cmd_gapread
;;;648        },
;;;649     * \endcode
;;;650     */
;;;651    static T_USER_CMD_PARSE_RESULT cmd_gapread(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;652    {
        0x00209894:    b510        ..      PUSH     {r4,lr}
;;;653        uint8_t conn_id = p_parse_value->dw_param[0];
        0x00209896:    7a02        .z      LDRB     r2,[r0,#8]
;;;654        T_GAPS_READ_TYPE read_type = (T_GAPS_READ_TYPE)p_parse_value->dw_param[1];
        0x00209898:    7b01        .{      LDRB     r1,[r0,#0xc]
;;;655        bool ret = gaps_read(conn_id, read_type);
        0x0020989a:    4610        .F      MOV      r0,r2
        0x0020989c:    f7fffc24    ..$.    BL       gaps_read ; 0x2090e8
;;;656        if (ret)
        0x002098a0:    b108        ..      CBZ      r0,0x2098a6 ; cmd_gapread + 18
;;;657        {
;;;658            return (RESULT_SUCESS);
        0x002098a2:    2000        .       MOVS     r0,#0
        0x002098a4:    bd10        ..      POP      {r4,pc}
;;;659        }
;;;660        else
;;;661        {
;;;662            return (RESULT_ERR);
        0x002098a6:    2020                MOVS     r0,#0x20
;;;663        }
;;;664    }
        0x002098a8:    bd10        ..      POP      {r4,pc}
    cmd_gaphdl
;;;665    
;;;666    /**
;;;667     * @brief List GAP service handle cache
;;;668     *
;;;669     * <b>Command table define</b>
;;;670     * \code{.c}
;;;671        {
;;;672            "gaphdl",
;;;673            "gaphdl [conn_id]\n\r",
;;;674            "List GAP service handle cache\n\r",
;;;675            cmd_gaphdl
;;;676        },
;;;677     * \endcode
;;;678     */
;;;679    static T_USER_CMD_PARSE_RESULT cmd_gaphdl(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;680    {
        0x002098aa:    b50e        ..      PUSH     {r1-r3,lr}
;;;681        uint8_t conn_id = p_parse_value->dw_param[0];
        0x002098ac:    7a00        .z      LDRB     r0,[r0,#8]
;;;682        uint16_t hdl_cache[HDL_GAPS_CACHE_LEN];
;;;683        uint8_t hdl_idx;
;;;684        bool ret = gaps_get_hdl_cache(conn_id, hdl_cache,
        0x002098ae:    220c        ."      MOVS     r2,#0xc
        0x002098b0:    4669        iF      MOV      r1,sp
        0x002098b2:    f7fffc53    ..S.    BL       gaps_get_hdl_cache ; 0x20915c
;;;685                                      sizeof(uint16_t) * HDL_GAPS_CACHE_LEN);
;;;686    
;;;687        if (ret)
        0x002098b6:    b130        0.      CBZ      r0,0x2098c6 ; cmd_gaphdl + 28
;;;688        {
;;;689            for (hdl_idx = HDL_GAPS_SRV_START; hdl_idx < HDL_GAPS_CACHE_LEN; hdl_idx++)
        0x002098b8:    2000        .       MOVS     r0,#0
        0x002098ba:    1c40        @.      ADDS     r0,r0,#1
        0x002098bc:    b2c0        ..      UXTB     r0,r0
        0x002098be:    2806        .(      CMP      r0,#6
        0x002098c0:    d3fb        ..      BCC      0x2098ba ; cmd_gaphdl + 16
;;;690            {
;;;691                //data_uart_print("-->Index %d -- Handle 0x%x\r\n", hdl_idx, hdl_cache[hdl_idx]);
;;;692            }
;;;693            return (RESULT_SUCESS);
        0x002098c2:    2000        .       MOVS     r0,#0
        0x002098c4:    bd0e        ..      POP      {r1-r3,pc}
;;;694        }
;;;695        else
;;;696        {
;;;697            return (RESULT_ERR);
        0x002098c6:    2020                MOVS     r0,#0x20
;;;698        }
;;;699    }
        0x002098c8:    bd0e        ..      POP      {r1-r3,pc}
    cmd_simpread
;;;700    
;;;701    /**
;;;702     * @brief Read simple ble service characteristic and descriptor value
;;;703     *
;;;704     * <b>Command table define</b>
;;;705     * \code{.c}
;;;706        {
;;;707            "simpread",
;;;708            "simpread [conn_id] [type] [pattern]\n\r",
;;;709            "Read simple ble service characteristic and descriptor value\r\n\
;;;710            [type]: 0-(read v1), 1-(v3 cccd), 2-(v4 cccd)\r\n\
;;;711            [pattern]: 0-(read by handle), 1-(read by uuid)\r\n\
;;;712            sample: simpread 0 1 0 \n\r",
;;;713            cmd_simpread
;;;714        },
;;;715     * \endcode
;;;716     */
;;;717    static T_USER_CMD_PARSE_RESULT cmd_simpread(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;718    {
        0x002098ca:    b510        ..      PUSH     {r4,lr}
;;;719        /* Indicate which char to be read. */
;;;720        uint8_t conn_id = p_parse_value->dw_param[0];
        0x002098cc:    7a02        .z      LDRB     r2,[r0,#8]
;;;721        bool ret;
;;;722        T_SIMP_READ_TYPE read_type = (T_SIMP_READ_TYPE)p_parse_value->dw_param[1];
        0x002098ce:    7b01        .{      LDRB     r1,[r0,#0xc]
;;;723        /* Read by handle or UUID, 1--by UUID, 0--by handle. */
;;;724        uint8_t read_pattern = (uint8_t)p_parse_value->dw_param[2];
        0x002098d0:    7c00        .|      LDRB     r0,[r0,#0x10]
        0x002098d2:    f0100fff    ....    TST      r0,#0xff
;;;725    
;;;726        if (read_pattern)
;;;727        {
;;;728            ret = simp_ble_client_read_by_uuid(conn_id, read_type);
;;;729        }
;;;730        else
;;;731        {
;;;732            ret = simp_ble_client_read_by_handle(conn_id, read_type);
        0x002098d6:    4610        .F      MOV      r0,r2
        0x002098d8:    d002        ..      BEQ      0x2098e0 ; cmd_simpread + 22
        0x002098da:    f7fefd3e    ..>.    BL       simp_ble_client_read_by_uuid ; 0x20835a
        0x002098de:    e001        ..      B        0x2098e4 ; cmd_simpread + 26
        0x002098e0:    f7fefce4    ....    BL       simp_ble_client_read_by_handle ; 0x2082ac
;;;733        }
;;;734    
;;;735        if (ret)
        0x002098e4:    b108        ..      CBZ      r0,0x2098ea ; cmd_simpread + 32
;;;736        {
;;;737            return (RESULT_SUCESS);
        0x002098e6:    2000        .       MOVS     r0,#0
        0x002098e8:    bd10        ..      POP      {r4,pc}
;;;738        }
;;;739        else
;;;740        {
;;;741            return (RESULT_ERR);
        0x002098ea:    2020                MOVS     r0,#0x20
;;;742        }
;;;743    }
        0x002098ec:    bd10        ..      POP      {r4,pc}
    cmd_simpcccd
;;;744    
;;;745    /**
;;;746     * @brief Config simple ble service client characteristic configuration descriptor value
;;;747     *
;;;748     * <b>Command table define</b>
;;;749     * \code{.c}
;;;750        {
;;;751            "simpcccd",
;;;752            "simpcccd [conn_id] [type] [enable]\n\r",
;;;753            "Config simple ble service client characteristic configuration descriptor value\r\n\
;;;754            [type]: 0-(v3 notify), 1-(v4 indication)\r\n\
;;;755            [enable]: 0-(disable), 1-(enable) \r\n\
;;;756            sample: simpcccd 0 1 1\n\r",
;;;757            cmd_simpcccd
;;;758        },
;;;759     * \endcode
;;;760     */
;;;761    static T_USER_CMD_PARSE_RESULT cmd_simpcccd(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;762    {
        0x002098ee:    b510        ..      PUSH     {r4,lr}
;;;763        /* Indicate which char CCCD command. */
;;;764        bool ret = false;
;;;765        uint8_t conn_id = p_parse_value->dw_param[0];
        0x002098f0:    7a02        .z      LDRB     r2,[r0,#8]
;;;766        uint8_t type = p_parse_value->dw_param[1];
        0x002098f2:    7b03        .{      LDRB     r3,[r0,#0xc]
;;;767        /* Enable or disable, 1--enable, 0--disable. */
;;;768        bool cccd_data = (bool)p_parse_value->dw_param[2];
        0x002098f4:    6900        .i      LDR      r0,[r0,#0x10]
        0x002098f6:    b108        ..      CBZ      r0,0x2098fc ; cmd_simpcccd + 14
        0x002098f8:    2101        .!      MOVS     r1,#1
        0x002098fa:    e000        ..      B        0x2098fe ; cmd_simpcccd + 16
        0x002098fc:    2100        .!      MOVS     r1,#0
;;;769    
;;;770        switch (type)
        0x002098fe:    b113        ..      CBZ      r3,0x209906 ; cmd_simpcccd + 24
        0x00209900:    2b01        .+      CMP      r3,#1
        0x00209902:    d16f        o.      BNE      0x2099e4 ; cmd_simpcccd + 246
        0x00209904:    e003        ..      B        0x20990e ; cmd_simpcccd + 32
;;;771        {
;;;772        case 0:/* V3 Notify char notif enable/disable. */
;;;773            ret = simp_ble_client_set_v3_notify(conn_id, cccd_data);
        0x00209906:    4610        .F      MOV      r0,r2
        0x00209908:    f7fefd74    ..t.    BL       simp_ble_client_set_v3_notify ; 0x2083f4
;;;774            break;
        0x0020990c:    e002        ..      B        0x209914 ; cmd_simpcccd + 38
;;;775        case 1:/* V4 Indicate char indicate enable/disable. */
;;;776            ret = simp_ble_client_set_v4_ind(conn_id, cccd_data);
        0x0020990e:    4610        .F      MOV      r0,r2
        0x00209910:    f7fefda9    ....    BL       simp_ble_client_set_v4_ind ; 0x208466
;;;777            break;
;;;778        default:
;;;779            break;
;;;780        }
;;;781    
;;;782        if (ret)
        0x00209914:    b108        ..      CBZ      r0,0x20991a ; cmd_simpcccd + 44
;;;783        {
;;;784            return (RESULT_SUCESS);
        0x00209916:    2000        .       MOVS     r0,#0
        0x00209918:    bd10        ..      POP      {r4,pc}
        0x0020991a:    e063        c.      B        0x2099e4 ; cmd_simpcccd + 246
    $d
        0x0020991c:    6f687323    #sho    DCD    1869116195
        0x00209920:    6e6f6377    wcon    DCD    1852793719
        0x00209924:    64252123    #!%d    DCD    1680154915
        0x00209928:    30255b21    ![%0    DCD    807754529
        0x0020992c:    30257832    2x%0    DCD    807761970
        0x00209930:    30257832    2x%0    DCD    807761970
        0x00209934:    30257832    2x%0    DCD    807761970
        0x00209938:    30257832    2x%0    DCD    807761970
        0x0020993c:    30257832    2x%0    DCD    807761970
        0x00209940:    3c5d7832    2x]<    DCD    1012758578
        0x00209944:    0a0d3e59    Y>..    DCD    168640089
        0x00209948:    00000000    ....    DCD    0
        0x0020994c:    0020d170    p. .    DCD    2150768
        0x00209950:    000f423f    ?B..    DCD    999999
        0x00209954:    75207462    bt u    DCD    1965061218
        0x00209958:    20747261    art     DCD    544502369
        0x0020995c:    74736574    test    DCD    1953719668
        0x00209960:    0d6b6f20     ok.    DCD    225144608
        0x00209964:    0000000a    ....    DCD    10
        0x00209968:    00202ebc    .. .    DCD    2109116
        0x0020996c:    6e6f6223    #bon    DCD    1852793379
        0x00209970:    666e6964    dinf    DCD    1718511972
        0x00209974:    2521236f    o#!%    DCD    622928751
        0x00209978:    255b2164    d![%    DCD    626729316
        0x0020997c:    25783230    02x%    DCD    628634160
        0x00209980:    25783230    02x%    DCD    628634160
        0x00209984:    25783230    02x%    DCD    628634160
        0x00209988:    25783230    02x%    DCD    628634160
        0x0020998c:    25783230    02x%    DCD    628634160
        0x00209990:    5d783230    02x]    DCD    1568158256
        0x00209994:    0d3e593c    <Y>.    DCD    222189884
        0x00209998:    0000000a    ....    DCD    10
        0x0020999c:    0020d379    y. .    DCD    2151289
        0x002099a0:    0020d378    x. .    DCD    2151288
        0x002099a4:    6f687323    #sho    DCD    1869116195
        0x002099a8:    76656477    wdev    DCD    1986356343
        0x002099ac:    64252123    #!%d    DCD    1680154915
        0x002099b0:    30255b21    ![%0    DCD    807754529
        0x002099b4:    30257832    2x%0    DCD    807761970
        0x002099b8:    30257832    2x%0    DCD    807761970
        0x002099bc:    30257832    2x%0    DCD    807761970
        0x002099c0:    30257832    2x%0    DCD    807761970
        0x002099c4:    30257832    2x%0    DCD    807761970
        0x002099c8:    3c5d7832    2x]<    DCD    1012758578
        0x002099cc:    0a0d3e59    Y>..    DCD    168640089
        0x002099d0:    00000000    ....    DCD    0
        0x002099d4:    6f687323    #sho    DCD    1869116195
        0x002099d8:    76656477    wdev    DCD    1986356343
        0x002099dc:    3e593c23    #<Y>    DCD    1046035491
        0x002099e0:    00000a0d    ....    DCD    2573
    $t
;;;785        }
;;;786        else
;;;787        {
;;;788            return (RESULT_ERR);
        0x002099e4:    2020                MOVS     r0,#0x20
;;;789        }
;;;790    }
        0x002099e6:    e797        ..      B        0x209918 ; cmd_simpcccd + 42
    cmd_simpwritev2
;;;791    
;;;792    /**
;;;793     * @brief Write simple ble service V2 characteristic value
;;;794     *
;;;795     * <b>Command table define</b>
;;;796     * \code{.c}
;;;797        {
;;;798            "simpwritev2",
;;;799            "simpwritev2 [conn_id] [type] [len]\n\r",
;;;800            "Write simple ble service V2 characteristic value\r\n\
;;;801            [type]: 1-(write request), 2-(write command) \r\n\
;;;802            [len]: type=1 len range:0-270, type=2 len range: 0-(mtu-3)\r\n\
;;;803            sample: simpwritev2 0 1 10\n\r",
;;;804            cmd_simpwritev2
;;;805        },
;;;806     * \endcode
;;;807     */
;;;808    static T_USER_CMD_PARSE_RESULT cmd_simpwritev2(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;809    {
        0x002099e8:    b5fe        ..      PUSH     {r1-r7,lr}
        0x002099ea:    7b03        .{      LDRB     r3,[r0,#0xc]
;;;810        uint8_t conn_id = p_parse_value->dw_param[0];
        0x002099ec:    7a06        .z      LDRB     r6,[r0,#8]
;;;811        T_GATT_WRITE_TYPE write_type = (T_GATT_WRITE_TYPE)p_parse_value->dw_param[1];
;;;812    	uint8_t data[12];
;;;813    	uint8_t length = 12;
        0x002099ee:    210c        .!      MOVS     r1,#0xc
;;;814    	uint8_t i;
;;;815    
;;;816    	if (write_type > GATT_WRITE_TYPE_CMD)
        0x002099f0:    2b02        .+      CMP      r3,#2
        0x002099f2:    d818        ..      BHI      0x209a26 ; cmd_simpwritev2 + 62
;;;817    	{
;;;818    		return (RESULT_ERR);
;;;819    	}
;;;820    
;;;821    	if (p_parse_value->param_count > 2)
        0x002099f4:    6842        Bh      LDR      r2,[r0,#4]
        0x002099f6:    2a02        .*      CMP      r2,#2
        0x002099f8:    dd03        ..      BLE      0x209a02 ; cmd_simpwritev2 + 26
;;;822    	{
;;;823    		length = p_parse_value->dw_param[2];
        0x002099fa:    7c01        .|      LDRB     r1,[r0,#0x10]
;;;824    		if (length > 12)
        0x002099fc:    290c        .)      CMP      r1,#0xc
        0x002099fe:    d900        ..      BLS      0x209a02 ; cmd_simpwritev2 + 26
;;;825    		{
;;;826    			length = 12;
        0x00209a00:    210c        .!      MOVS     r1,#0xc
;;;827    		}
;;;828    	}
;;;829    	
;;;830    	
;;;831        for (i = 0; i < length; i++)
        0x00209a02:    2200        ."      MOVS     r2,#0
        0x00209a04:    466c        lF      MOV      r4,sp
        0x00209a06:    e005        ..      B        0x209a14 ; cmd_simpwritev2 + 44
        0x00209a08:    eb000582    ....    ADD      r5,r0,r2,LSL #2
        0x00209a0c:    7d2d        -}      LDRB     r5,[r5,#0x14]
        0x00209a0e:    54a5        .T      STRB     r5,[r4,r2]
        0x00209a10:    1c52        R.      ADDS     r2,r2,#1
        0x00209a12:    b2d2        ..      UXTB     r2,r2
        0x00209a14:    428a        .B      CMP      r2,r1
        0x00209a16:    d3f7        ..      BCC      0x209a08 ; cmd_simpwritev2 + 32
;;;832        {
;;;833            data[i] = p_parse_value->dw_param[3+i];
;;;834        }
;;;835    
;;;836        if (simp_ble_client_write_v2_char(conn_id, length, data, write_type))
        0x00209a18:    4622        "F      MOV      r2,r4
        0x00209a1a:    4630        0F      MOV      r0,r6
        0x00209a1c:    f7fefd61    ..a.    BL       simp_ble_client_write_v2_char ; 0x2084e2
        0x00209a20:    b108        ..      CBZ      r0,0x209a26 ; cmd_simpwritev2 + 62
;;;837        {
;;;838            return (RESULT_SUCESS);
        0x00209a22:    2000        .       MOVS     r0,#0
        0x00209a24:    bdfe        ..      POP      {r1-r7,pc}
;;;839        }
;;;840        else
;;;841        {
;;;842            return (RESULT_ERR);
        0x00209a26:    2020                MOVS     r0,#0x20
;;;843        }
;;;844    }
        0x00209a28:    bdfe        ..      POP      {r1-r7,pc}
    cmd_simphdl
;;;845    
;;;846    /**
;;;847     * @brief List simple ble service handle cache
;;;848     *
;;;849     * <b>Command table define</b>
;;;850     * \code{.c}
;;;851        {
;;;852            "simphdl",
;;;853            "simphdl [conn_id]\n\r",
;;;854            "List simple ble service handle cache\n\r",
;;;855            cmd_simphdl
;;;856        },
;;;857     * \endcode
;;;858     */
;;;859    static T_USER_CMD_PARSE_RESULT cmd_simphdl(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;860    {
        0x00209a2a:    b51f        ..      PUSH     {r0-r4,lr}
;;;861        uint8_t conn_id = p_parse_value->dw_param[0];
        0x00209a2c:    7a00        .z      LDRB     r0,[r0,#8]
;;;862        uint16_t hdl_cache[HDL_SIMBLE_CACHE_LEN];
;;;863        uint8_t hdl_idx;
;;;864        bool ret = simp_ble_client_get_hdl_cache(conn_id, hdl_cache,
        0x00209a2e:    2210        ."      MOVS     r2,#0x10
        0x00209a30:    4669        iF      MOV      r1,sp
        0x00209a32:    f7fefd7f    ....    BL       simp_ble_client_get_hdl_cache ; 0x208534
;;;865                                                 sizeof(uint16_t) * HDL_SIMBLE_CACHE_LEN);
;;;866    
;;;867        if (ret)
        0x00209a36:    b138        8.      CBZ      r0,0x209a48 ; cmd_simphdl + 30
;;;868        {
;;;869            for (hdl_idx = HDL_SIMBLE_SRV_START; hdl_idx < HDL_SIMBLE_CACHE_LEN; hdl_idx++)
        0x00209a38:    2000        .       MOVS     r0,#0
        0x00209a3a:    1c40        @.      ADDS     r0,r0,#1
        0x00209a3c:    b2c0        ..      UXTB     r0,r0
        0x00209a3e:    2808        .(      CMP      r0,#8
        0x00209a40:    d3fb        ..      BCC      0x209a3a ; cmd_simphdl + 16
;;;870            {
;;;871                //data_uart_print("-->Index %d -- Handle 0x%x\r\n", hdl_idx, hdl_cache[hdl_idx]);
;;;872            }
;;;873            return (RESULT_SUCESS);
        0x00209a42:    2000        .       MOVS     r0,#0
        0x00209a44:    b004        ..      ADD      sp,sp,#0x10
        0x00209a46:    e767        g.      B        0x209918 ; cmd_simpcccd + 42
;;;874        }
;;;875        else
;;;876        {
;;;877            return (RESULT_ERR);
        0x00209a48:    2020                MOVS     r0,#0x20
;;;878        }
;;;879    }
        0x00209a4a:    e7fb        ..      B        0x209a44 ; cmd_simphdl + 26
    cmd_basread
;;;880    
;;;881    /**
;;;882     * @brief Read battery service characteristic and descriptor value
;;;883     *
;;;884     * <b>Command table define</b>
;;;885     * \code{.c}
;;;886        {
;;;887            "basread",
;;;888            "basread [conn_id] [type]\n\r",
;;;889            "Read battery service characteristic and descriptor value\r\n\
;;;890            [type]: 0-(battery level value), 1-(battery cccd)\r\n\
;;;891            sample: basread 0 1 \n\r",
;;;892            cmd_basread
;;;893        },
;;;894     * \endcode
;;;895     */
;;;896    static T_USER_CMD_PARSE_RESULT cmd_basread(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;897    {
        0x00209a4c:    b510        ..      PUSH     {r4,lr}
        0x00209a4e:    4601        .F      MOV      r1,r0
        0x00209a50:    7a00        .z      LDRB     r0,[r0,#8]
        0x00209a52:    68c9        .h      LDR      r1,[r1,#0xc]
;;; ..\..\..\src\sample\ble_central\user_cmd.c (897)
        0x00209a54:    b111        ..      CBZ      r1,0x209a5c ; cmd_basread + 16
        0x00209a56:    2901        .)      CMP      r1,#1
        0x00209a58:    d003        ..      BEQ      0x209a62 ; cmd_basread + 22
        0x00209a5a:    e007        ..      B        0x209a6c ; cmd_basread + 32
;;;898        uint8_t conn_id = p_parse_value->dw_param[0];
;;;899        bool ret = false;
;;;900        if (p_parse_value->dw_param[1] == 0)
;;;901        {
;;;902            ret = bas_read_battery_level(conn_id);
        0x00209a5c:    f7fff87c    ..|.    BL       bas_read_battery_level ; 0x208b58
        0x00209a60:    e001        ..      B        0x209a66 ; cmd_basread + 26
;;;903        }
;;;904        else if (p_parse_value->dw_param[1] == 1)
;;;905        {
;;;906            ret = bas_read_notify(conn_id);
        0x00209a62:    f7fff8d0    ....    BL       bas_read_notify ; 0x208c06
;;;907        }
;;;908    
;;;909        if (ret)
        0x00209a66:    b108        ..      CBZ      r0,0x209a6c ; cmd_basread + 32
;;;910        {
;;;911            return (RESULT_SUCESS);
        0x00209a68:    2000        .       MOVS     r0,#0
        0x00209a6a:    e755        U.      B        0x209918 ; cmd_simpcccd + 42
;;;912        }
;;;913        else
;;;914        {
;;;915            return (RESULT_ERR);
        0x00209a6c:    2020                MOVS     r0,#0x20
;;;916        }
;;;917    }
        0x00209a6e:    e753        S.      B        0x209918 ; cmd_simpcccd + 42
    cmd_bascccd
;;;918    
;;;919    /**
;;;920     * @brief Config battery service client characteristic configuration descriptor value
;;;921     *
;;;922     * <b>Command table define</b>
;;;923     * \code{.c}
;;;924        {
;;;925            "bascccd",
;;;926            "bascccd [conn_id] [notify]\n\r",
;;;927            "Config battery service client characteristic configuration descriptor value\r\n\
;;;928            [notify]: 0-(disable), 1-(enable)\n\r",
;;;929            cmd_bascccd
;;;930        },
;;;931     * \endcode
;;;932     */
;;;933    static T_USER_CMD_PARSE_RESULT cmd_bascccd(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;934    {
        0x00209a70:    b510        ..      PUSH     {r4,lr}
        0x00209a72:    7a02        .z      LDRB     r2,[r0,#8]
        0x00209a74:    68c0        .h      LDR      r0,[r0,#0xc]
;;; ..\..\..\src\sample\ble_central\user_cmd.c (934)
        0x00209a76:    b108        ..      CBZ      r0,0x209a7c ; cmd_bascccd + 12
;;;935        uint8_t conn_id = p_parse_value->dw_param[0];
;;;936        bool notify = p_parse_value->dw_param[1];
        0x00209a78:    2101        .!      MOVS     r1,#1
        0x00209a7a:    e000        ..      B        0x209a7e ; cmd_bascccd + 14
        0x00209a7c:    2100        .!      MOVS     r1,#0
;;;937        bool ret;
;;;938        ret = bas_set_notify(conn_id, notify);
        0x00209a7e:    4610        .F      MOV      r0,r2
        0x00209a80:    f7fff88f    ....    BL       bas_set_notify ; 0x208ba2
;;;939    
;;;940        if (ret)
        0x00209a84:    b108        ..      CBZ      r0,0x209a8a ; cmd_bascccd + 26
;;;941        {
;;;942            return (RESULT_SUCESS);
        0x00209a86:    2000        .       MOVS     r0,#0
        0x00209a88:    e746        F.      B        0x209918 ; cmd_simpcccd + 42
;;;943        }
;;;944        else
;;;945        {
;;;946            return (RESULT_ERR);
        0x00209a8a:    2020                MOVS     r0,#0x20
;;;947        }
;;;948    }
        0x00209a8c:    e744        D.      B        0x209918 ; cmd_simpcccd + 42
    cmd_bashdl
;;;949    
;;;950    /**
;;;951     * @brief List battery service handle cache
;;;952     *
;;;953     * <b>Command table define</b>
;;;954     * \code{.c}
;;;955        {
;;;956            "bashdl",
;;;957            "bashdl [conn_id]\n\r",
;;;958            "List battery service handle cache\n\r",
;;;959            cmd_bashdl
;;;960        },
;;;961     * \endcode
;;;962     */
;;;963    static T_USER_CMD_PARSE_RESULT cmd_bashdl(T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;964    {
        0x00209a8e:    b51c        ..      PUSH     {r2-r4,lr}
;;;965        uint8_t conn_id = p_parse_value->dw_param[0];
        0x00209a90:    7a00        .z      LDRB     r0,[r0,#8]
;;;966        uint16_t hdl_cache[HDL_BAS_CACHE_LEN];
;;;967        uint8_t hdl_idx;
;;;968        bool ret = bas_get_hdl_cache(conn_id, hdl_cache,
        0x00209a92:    2208        ."      MOVS     r2,#8
        0x00209a94:    4669        iF      MOV      r1,sp
        0x00209a96:    f7fff8da    ....    BL       bas_get_hdl_cache ; 0x208c4e
;;;969                                     sizeof(uint16_t) * HDL_BAS_CACHE_LEN);
;;;970    
;;;971        if (ret)
        0x00209a9a:    b130        0.      CBZ      r0,0x209aaa ; cmd_bashdl + 28
;;;972        {
;;;973            for (hdl_idx = HDL_BAS_SRV_START; hdl_idx < HDL_BAS_CACHE_LEN; hdl_idx++)
        0x00209a9c:    2000        .       MOVS     r0,#0
        0x00209a9e:    1c40        @.      ADDS     r0,r0,#1
        0x00209aa0:    b2c0        ..      UXTB     r0,r0
        0x00209aa2:    2804        .(      CMP      r0,#4
        0x00209aa4:    d3fb        ..      BCC      0x209a9e ; cmd_bashdl + 16
;;;974            {
;;;975                //data_uart_print("-->Index %d -- Handle 0x%x\r\n", hdl_idx, hdl_cache[hdl_idx]);
;;;976            }
;;;977            return (RESULT_SUCESS);
        0x00209aa6:    2000        .       MOVS     r0,#0
        0x00209aa8:    bd1c        ..      POP      {r2-r4,pc}
;;;978        }
;;;979        else
;;;980        {
;;;981            return (RESULT_ERR);
        0x00209aaa:    2020                MOVS     r0,#0x20
;;;982        }
;;;983    }
        0x00209aac:    bd1c        ..      POP      {r2-r4,pc}
        0x00209aae:    0000        ..      MOVS     r0,r0
    .text
    app_main_task
;;; ..\..\..\src\sample\ble_central\app_task.c
;;;76     {
        0x00209ab0:    b51f        ..      PUSH     {r0-r4,lr}
;;;77         uint8_t event;
;;;78     
;;;79         os_msg_queue_create(&io_queue_handle, MAX_NUMBER_OF_IO_MESSAGE, sizeof(T_IO_MSG));
        0x00209ab2:    204f        O       MOVS     r0,#0x4f
        0x00209ab4:    9000        ..      STR      r0,[sp,#0]
        0x00209ab6:    4b2a        *K      LDR      r3,[pc,#168] ; [0x209b60] = 0x21ca40
        0x00209ab8:    2208        ."      MOVS     r2,#8
        0x00209aba:    2120         !      MOVS     r1,#0x20
        0x00209abc:    4829        )H      LDR      r0,[pc,#164] ; [0x209b64] = 0x20d370
        0x00209abe:    f61cfa19    ....    BL       os_msg_queue_create_intern ; 0x25ef4
;;;80         os_msg_queue_create(&evt_queue_handle, MAX_NUMBER_OF_EVENT_MESSAGE, sizeof(uint8_t));
        0x00209ac2:    2050        P       MOVS     r0,#0x50
        0x00209ac4:    9000        ..      STR      r0,[sp,#0]
        0x00209ac6:    4827        'H      LDR      r0,[pc,#156] ; [0x209b64] = 0x20d370
        0x00209ac8:    4b25        %K      LDR      r3,[pc,#148] ; [0x209b60] = 0x21ca40
        0x00209aca:    2201        ."      MOVS     r2,#1
        0x00209acc:    2140        @!      MOVS     r1,#0x40
        0x00209ace:    1f00        ..      SUBS     r0,r0,#4
        0x00209ad0:    f61cfa10    ....    BL       os_msg_queue_create_intern ; 0x25ef4
;;;81     
;;;82         gap_start_bt_stack(evt_queue_handle, io_queue_handle, MAX_NUMBER_OF_GAP_MESSAGE);
        0x00209ad4:    4c23        #L      LDR      r4,[pc,#140] ; [0x209b64] = 0x20d370
        0x00209ad6:    2220         "      MOVS     r2,#0x20
        0x00209ad8:    3c08        .<      SUBS     r4,r4,#8
        0x00209ada:    e9d40101    ....    LDRD     r0,r1,[r4,#4]
        0x00209ade:    f642f9c4    B...    BL       gap_start_bt_stack ; 0x4be6a
        0x00209ae2:    e9d40101    ....    LDRD     r0,r1,[r4,#4]
;;;83     
;;;84         data_uart_init(evt_queue_handle, io_queue_handle);
        0x00209ae6:    f001f931    ..1.    BL       data_uart_init ; 0x20ad4c
;;;85         user_cmd_init(&user_cmd_if, "central-vsop");
        0x00209aea:    a11f        ..      ADR      r1,{pc}+0x7e ; 0x209b68
        0x00209aec:    4822        "H      LDR      r0,[pc,#136] ; [0x209b78] = 0x20cfcc
        0x00209aee:    f001fc64    ..d.    BL       user_cmd_init ; 0x20b3ba
;;;86     	APP_PRINT_INFO0("app_main_task by vsop enter");
        0x00209af2:    2200        ."      MOVS     r2,#0
        0x00209af4:    4921        !I      LDR      r1,[pc,#132] ; [0x209b7c] = 0x88015e8
        0x00209af6:    4822        "H      LDR      r0,[pc,#136] ; [0x209b80] = 0x21103002
        0x00209af8:    f5fdffb1    ....    BL       log_buffer ; 0x7a5e
;;;87     
;;;88         driver_init();
        0x00209afc:    f000ffb1    ....    BL       driver_init ; 0x20aa62
;;;89         while (true)
;;;90         {
;;;91     				#if 1
;;;92             if (os_msg_recv(evt_queue_handle, &event, 0xFFFFFFFF) == true)
        0x00209b00:    255c        \%      MOVS     r5,#0x5c
        0x00209b02:    f04f37ff    O..7    MOV      r7,#0xffffffff
        0x00209b06:    2661        a&      MOVS     r6,#0x61
        0x00209b08:    9500        ..      STR      r5,[sp,#0]
        0x00209b0a:    4b15        .K      LDR      r3,[pc,#84] ; [0x209b60] = 0x21ca40
        0x00209b0c:    463a        :F      MOV      r2,r7
        0x00209b0e:    a903        ..      ADD      r1,sp,#0xc
        0x00209b10:    6860        `h      LDR      r0,[r4,#4]
        0x00209b12:    f61cfa97    ....    BL       os_msg_recv_intern ; 0x26044
        0x00209b16:    2800        .(      CMP      r0,#0
        0x00209b18:    d0f6        ..      BEQ      0x209b08 ; app_main_task + 88
;;;93             {
;;;94                 if (event == EVENT_IO_TO_APP)
        0x00209b1a:    f89d000c    ....    LDRB     r0,[sp,#0xc]
        0x00209b1e:    2802        .(      CMP      r0,#2
        0x00209b20:    d002        ..      BEQ      0x209b28 ; app_main_task + 120
        0x00209b22:    f642fa0f    B...    BL       gap_handle_msg ; 0x4bf44
        0x00209b26:    e7ef        ..      B        0x209b08 ; app_main_task + 88
;;;95                 {
;;;96                     T_IO_MSG io_msg;
;;;97                     if (os_msg_recv(io_queue_handle, &io_msg, 0) == true)
        0x00209b28:    9600        ..      STR      r6,[sp,#0]
        0x00209b2a:    4b0d        .K      LDR      r3,[pc,#52] ; [0x209b60] = 0x21ca40
        0x00209b2c:    2200        ."      MOVS     r2,#0
        0x00209b2e:    a901        ..      ADD      r1,sp,#4
        0x00209b30:    68a0        .h      LDR      r0,[r4,#8]
        0x00209b32:    f61cfa87    ....    BL       os_msg_recv_intern ; 0x26044
        0x00209b36:    2800        .(      CMP      r0,#0
        0x00209b38:    d0e6        ..      BEQ      0x209b08 ; app_main_task + 88
        0x00209b3a:    e9dd0101    ....    LDRD     r0,r1,[sp,#4]
;;;98                     {
;;;99                         app_handle_io_msg(io_msg);
        0x00209b3e:    f000faac    ....    BL       app_handle_io_msg ; 0x20a09a
        0x00209b42:    e7e1        ..      B        0x209b08 ; app_main_task + 88
    app_task_init
        0x00209b44:    b51c        ..      PUSH     {r2-r4,lr}
;;; ..\..\..\src\sample\ble_central\app_task.c (66)
        0x00209b46:    2101        .!      MOVS     r1,#1
        0x00209b48:    0288        ..      LSLS     r0,r1,#10
        0x00209b4a:    2300        .#      MOVS     r3,#0
        0x00209b4c:    f2af029f    ....    ADR      r2,{pc}-0x9b ; 0x209ab1
        0x00209b50:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x00209b54:    4803        .H      LDR      r0,[pc,#12] ; [0x209b64] = 0x20d370
        0x00209b56:    a10b        ..      ADR      r1,{pc}+0x2e ; 0x209b84
        0x00209b58:    3808        .8      SUBS     r0,r0,#8
        0x00209b5a:    f61cff39    ..9.    BL       os_task_create ; 0x269d0
;;;67                        APP_TASK_PRIORITY);
;;;68     }
        0x00209b5e:    bd1c        ..      POP      {r2-r4,pc}
    $d
        0x00209b60:    0021ca40    @.!.    DCD    2214464
        0x00209b64:    0020d370    p. .    DCD    2151280
        0x00209b68:    746e6563    cent    DCD    1953391971
        0x00209b6c:    2d6c6172    ral-    DCD    762077554
        0x00209b70:    706f7376    vsop    DCD    1886352246
        0x00209b74:    00000000    ....    DCD    0
        0x00209b78:    0020cfcc    .. .    DCD    2150348
        0x00209b7c:    088015e8    ....    DCD    142611944
        0x00209b80:    21103002    .0.!    DCD    554708994
        0x00209b84:    00707061    app.    DCD    7368801
    $t
    .text
    app_handle_authen_state_evt
;;; ..\..\..\src\sample\ble_central\central_app.c
;;;218    {
        0x00209b88:    b5f0        ..      PUSH     {r4-r7,lr}
        0x00209b8a:    b085        ..      SUB      sp,sp,#0x14
        0x00209b8c:    4efc        .N      LDR      r6,[pc,#1008] ; [0x209f80] = 0x21103002
;;; ..\..\..\src\sample\ble_central\central_app.c (218)
        0x00209b8e:    4614        .F      MOV      r4,r2
        0x00209b90:    460f        .F      MOV      r7,r1
        0x00209b92:    4605        .F      MOV      r5,r0
;;;219        APP_PRINT_INFO2("app_handle_authen_state_evt:conn_id %d, cause 0x%x", conn_id, cause);
        0x00209b94:    4603        .F      MOV      r3,r0
        0x00209b96:    9200        ..      STR      r2,[sp,#0]
        0x00209b98:    2202        ."      MOVS     r2,#2
        0x00209b9a:    49f8        .I      LDR      r1,[pc,#992] ; [0x209f7c] = 0x8801724
        0x00209b9c:    4630        0F      MOV      r0,r6
        0x00209b9e:    f5fdff5e    ..^.    BL       log_buffer ; 0x7a5e
;;;220    
;;;221        switch (new_state)
        0x00209ba2:    b157        W.      CBZ      r7,0x209bba ; app_handle_authen_state_evt + 50
        0x00209ba4:    2f01        ./      CMP      r7,#1
        0x00209ba6:    d00c        ..      BEQ      0x209bc2 ; app_handle_authen_state_evt + 58
        0x00209ba8:    2201        ."      MOVS     r2,#1
        0x00209baa:    b005        ..      ADD      sp,sp,#0x14
        0x00209bac:    463b        ;F      MOV      r3,r7
        0x00209bae:    1eb0        ..      SUBS     r0,r6,#2
        0x00209bb0:    e8bd40f0    ...@    POP      {r4-r7,lr}
        0x00209bb4:    49f3        .I      LDR      r1,[pc,#972] ; [0x209f84] = 0x8801828
        0x00209bb6:    f5fdbf52    ..R.    B        log_buffer ; 0x7a5e
;;;222        {
;;;223        case GAP_AUTHEN_STATE_STARTED:
;;;224            {
;;;225                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
        0x00209bba:    49f0        .I      LDR      r1,[pc,#960] ; [0x209f7c] = 0x8801724
        0x00209bbc:    2200        ."      MOVS     r2,#0
        0x00209bbe:    3138        81      ADDS     r1,r1,#0x38
;;;226            }
;;;227            break;
        0x00209bc0:    e01f        ..      B        0x209c02 ; app_handle_authen_state_evt + 122
        0x00209bc2:    48f1        .H      LDR      r0,[pc,#964] ; [0x209f88] = 0x20d3a3
        0x00209bc4:    eb050185    ....    ADD      r1,r5,r5,LSL #2
        0x00209bc8:    eb000141    ..A.    ADD      r1,r0,r1,LSL #1
;;;228    
;;;229        case GAP_AUTHEN_STATE_COMPLETE:
;;;230            {
;;;231                if (cause == GAP_SUCCESS)
        0x00209bcc:    2c00        .,      CMP      r4,#0
        0x00209bce:    79c8        .y      LDRB     r0,[r1,#7]
        0x00209bd0:    af01        ..      ADD      r7,sp,#4
        0x00209bd2:    790c        .y      LDRB     r4,[r1,#4]
        0x00209bd4:    794b        Ky      LDRB     r3,[r1,#5]
        0x00209bd6:    798a        .y      LDRB     r2,[r1,#6]
        0x00209bd8:    e887001d    ....    STM      r7,{r0,r2-r4}
        0x00209bdc:    7a08        .z      LDRB     r0,[r1,#8]
        0x00209bde:    9000        ..      STR      r0,[sp,#0]
        0x00209be0:    7a4b        Kz      LDRB     r3,[r1,#9]
        0x00209be2:    462a        *F      MOV      r2,r5
        0x00209be4:    d013        ..      BEQ      0x209c0e ; app_handle_authen_state_evt + 134
        0x00209be6:    a1e9        ..      ADR      r1,{pc}+0x3a6 ; 0x209f8c
        0x00209be8:    48f3        .H      LDR      r0,[pc,#972] ; [0x209fb8] = 0x20d170
        0x00209bea:    f002f8b1    ....    BL       __2sprintf ; 0x20bd50
        0x00209bee:    48f2        .H      LDR      r0,[pc,#968] ; [0x209fb8] = 0x20d170
        0x00209bf0:    f650f934    P.4.    BL       strlen ; 0x59e5c
        0x00209bf4:    b281        ..      UXTH     r1,r0
        0x00209bf6:    48f0        .H      LDR      r0,[pc,#960] ; [0x209fb8] = 0x20d170
        0x00209bf8:    f001f82d    ..-.    BL       FramingWrapFrameUartPrint ; 0x20ac56
        0x00209bfc:    49e1        .I      LDR      r1,[pc,#900] ; [0x209f84] = 0x8801828
        0x00209bfe:    2200        ."      MOVS     r2,#0
        0x00209c00:    3948        H9      SUBS     r1,r1,#0x48
        0x00209c02:    b005        ..      ADD      sp,sp,#0x14
        0x00209c04:    4630        0F      MOV      r0,r6
        0x00209c06:    e8bd40f0    ...@    POP      {r4-r7,lr}
        0x00209c0a:    f5fdbf28    ..(.    B        log_buffer ; 0x7a5e
;;;232                {
;;;233    #if 0 //by vsop            
;;;234    				data_uart_print("#sauth#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;235    					conn_id,
;;;236    					app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;237    					app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;238    					app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;239    #else
;;;240    			sprintf(cmd_buffer,"#sauth#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
        0x00209c0e:    a1eb        ..      ADR      r1,{pc}+0x3ae ; 0x209fbc
        0x00209c10:    48e9        .H      LDR      r0,[pc,#932] ; [0x209fb8] = 0x20d170
        0x00209c12:    f002f89d    ....    BL       __2sprintf ; 0x20bd50
;;;241    					conn_id,
;;;242    					app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;243    					app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;244    					app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;245    			FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));	
        0x00209c16:    48e8        .H      LDR      r0,[pc,#928] ; [0x209fb8] = 0x20d170
        0x00209c18:    f650f920    P. .    BL       strlen ; 0x59e5c
        0x00209c1c:    b281        ..      UXTH     r1,r0
        0x00209c1e:    48e6        .H      LDR      r0,[pc,#920] ; [0x209fb8] = 0x20d170
        0x00209c20:    f001f819    ....    BL       FramingWrapFrameUartPrint ; 0x20ac56
;;;246    #endif
;;;247                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
        0x00209c24:    49d5        .I      LDR      r1,[pc,#852] ; [0x209f7c] = 0x8801724
        0x00209c26:    2200        ."      MOVS     r2,#0
        0x00209c28:    3174        t1      ADDS     r1,r1,#0x74
        0x00209c2a:    e7ea        ..      B        0x209c02 ; app_handle_authen_state_evt + 122
    app_handle_conn_param_update_evt
;;;248    
;;;249                }
;;;250                else
;;;251                {
;;;252    #if 0 //by vsop            
;;;253                   	data_uart_print("#sauth#!%d![%02x%02x%02x%02x%02x%02x]<N>\r\n",
;;;254    						conn_id,
;;;255    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;256    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;257    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;258    #else
;;;259    					sprintf(cmd_buffer,"#sauth#!%d![%02x%02x%02x%02x%02x%02x]<N>\r\n",
;;;260    						conn_id,
;;;261    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;262    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;263    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;264    					FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));	
;;;265    #endif            
;;;266                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;267                }
;;;268            }
;;;269            break;
;;;270    
;;;271        default:
;;;272            {
;;;273                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;274            }
;;;275            break;
;;;276        }
;;;277    }
;;;278    
;;;279    /**
;;;280     * @brief    Handle msg GAP_MSG_LE_CONN_MTU_INFO
;;;281     * @note     This msg is used to inform APP that exchange mtu procedure is completed.
;;;282     * @param[in] conn_id Connection ID
;;;283     * @param[in] mtu_size  New mtu size
;;;284     * @return   void
;;;285     */
;;;286    void app_handle_conn_mtu_info_evt(uint8_t conn_id, uint16_t mtu_size)
;;;287    {
;;;288        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
;;;289        app_discov_services(conn_id, true);
;;;290    }
;;;291    
;;;292    /**
;;;293     * @brief    Handle msg GAP_MSG_LE_CONN_PARAM_UPDATE
;;;294     * @note     All the connection parameter update change  events are pre-handled in this function.
;;;295     * @param[in] conn_id Connection ID
;;;296     * @param[in] status  New update state
;;;297     * @param[in] cause Use this cause when status is GAP_CONN_PARAM_UPDATE_STATUS_FAIL
;;;298     * @return   void
;;;299     */
;;;300    void app_handle_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;301    {
        0x00209c2c:    b530        0.      PUSH     {r4,r5,lr}
        0x00209c2e:    4cd4        .L      LDR      r4,[pc,#848] ; [0x209f80] = 0x21103002
;;; ..\..\..\src\sample\ble_central\central_app.c (301)
        0x00209c30:    b087        ..      SUB      sp,sp,#0x1c
        0x00209c32:    4605        .F      MOV      r5,r0
        0x00209c34:    b161        a.      CBZ      r1,0x209c50 ; app_handle_conn_param_update_evt + 36
;;;302        switch (status)
        0x00209c36:    2901        .)      CMP      r1,#1
        0x00209c38:    d02d        -.      BEQ      0x209c96 ; app_handle_conn_param_update_evt + 106
        0x00209c3a:    2902        .)      CMP      r1,#2
        0x00209c3c:    d129        ).      BNE      0x209c92 ; app_handle_conn_param_update_evt + 102
        0x00209c3e:    4603        .F      MOV      r3,r0
        0x00209c40:    b007        ..      ADD      sp,sp,#0x1c
        0x00209c42:    4620         F      MOV      r0,r4
        0x00209c44:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x00209c48:    2201        ."      MOVS     r2,#1
        0x00209c4a:    49e7        .I      LDR      r1,[pc,#924] ; [0x209fe8] = 0x8801970
        0x00209c4c:    f5fdbf07    ....    B        log_buffer ; 0x7a5e
;;;303        {
;;;304        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;305            {
;;;306                uint16_t conn_interval;
;;;307                uint16_t conn_slave_latency;
;;;308                uint16_t conn_supervision_timeout;
;;;309    
;;;310                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
        0x00209c50:    4602        .F      MOV      r2,r0
        0x00209c52:    a905        ..      ADD      r1,sp,#0x14
        0x00209c54:    f2402072    @.r     MOV      r0,#0x272
        0x00209c58:    f643ff11    C...    BL       le_get_conn_param ; 0x4da7e
;;;311                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
        0x00209c5c:    462a        *F      MOV      r2,r5
        0x00209c5e:    a904        ..      ADD      r1,sp,#0x10
        0x00209c60:    f2402073    @.s     MOV      r0,#0x273
        0x00209c64:    f643ff0b    C...    BL       le_get_conn_param ; 0x4da7e
;;;312                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
        0x00209c68:    462a        *F      MOV      r2,r5
        0x00209c6a:    a903        ..      ADD      r1,sp,#0xc
        0x00209c6c:    f44f701d    O..p    MOV      r0,#0x274
        0x00209c70:    f643ff05    C...    BL       le_get_conn_param ; 0x4da7e
;;;313                APP_PRINT_INFO4("app_handle_conn_param_update_evt update success:conn_id %d, conn_interval 0x%x, conn_slave_latency 0x%x, conn_supervision_timeout 0x%x",
        0x00209c74:    f8bd0014    ....    LDRH     r0,[sp,#0x14]
        0x00209c78:    f8bd200c    ...     LDRH     r2,[sp,#0xc]
        0x00209c7c:    f8bd1010    ....    LDRH     r1,[sp,#0x10]
        0x00209c80:    e88d0007    ....    STM      sp,{r0-r2}
        0x00209c84:    49bf        .I      LDR      r1,[pc,#764] ; [0x209f84] = 0x8801828
        0x00209c86:    462b        +F      MOV      r3,r5
        0x00209c88:    2204        ."      MOVS     r2,#4
        0x00209c8a:    3170        p1      ADDS     r1,r1,#0x70
        0x00209c8c:    4620         F      MOV      r0,r4
        0x00209c8e:    f5fdfee6    ....    BL       log_buffer ; 0x7a5e
        0x00209c92:    b007        ..      ADD      sp,sp,#0x1c
        0x00209c94:    bd30        0.      POP      {r4,r5,pc}
;;;314                                conn_id, conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;315            }
;;;316            break;
;;;317    
;;;318        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;319            {
;;;320                APP_PRINT_ERROR2("app_handle_conn_param_update_evt update failed: conn_id %d, cause 0x%x",
        0x00209c96:    4603        .F      MOV      r3,r0
        0x00209c98:    49d3        .I      LDR      r1,[pc,#844] ; [0x209fe8] = 0x8801970
        0x00209c9a:    48b9        .H      LDR      r0,[pc,#740] ; [0x209f80] = 0x21103002
        0x00209c9c:    9200        ..      STR      r2,[sp,#0]
        0x00209c9e:    2202        ."      MOVS     r2,#2
        0x00209ca0:    394c        L9      SUBS     r1,r1,#0x4c
        0x00209ca2:    1e80        ..      SUBS     r0,r0,#2
        0x00209ca4:    f5fdfedb    ....    BL       log_buffer ; 0x7a5e
;;;321                                 conn_id, cause);
;;;322            }
;;;323            break;
;;;324    
;;;325        case GAP_CONN_PARAM_UPDATE_STATUS_PENDING:
;;;326            {
;;;327                APP_PRINT_INFO1("app_handle_conn_param_update_evt update pending: conn_id %d", conn_id);
;;;328            }
;;;329            break;
;;;330    
;;;331        default:
;;;332            break;
;;;333        }
;;;334    }
        0x00209ca8:    e7f3        ..      B        0x209c92 ; app_handle_conn_param_update_evt + 102
    app_discov_services
;;;335    
;;;336    /**
;;;337     * @brief    All the BT GAP MSG are pre-handled in this function.
;;;338     * @note     Then the event handling function shall be called according to the
;;;339     *           subtype of T_IO_MSG
;;;340     * @param[in] p_gap_msg Pointer to GAP msg
;;;341     * @return   void
;;;342     */
;;;343    void app_handle_gap_msg(T_IO_MSG *p_gap_msg)
;;;344    {
;;;345        T_LE_GAP_MSG gap_msg;
;;;346        uint8_t conn_id;
;;;347        memcpy(&gap_msg, &p_gap_msg->u.param, sizeof(p_gap_msg->u.param));
;;;348    
;;;349        APP_PRINT_TRACE1("app_handle_gap_msg: subtype %d", p_gap_msg->subtype);
;;;350        switch (p_gap_msg->subtype)
;;;351        {
;;;352        case GAP_MSG_LE_DEV_STATE_CHANGE:
;;;353            {
;;;354                app_handle_dev_state_evt(gap_msg.msg_data.gap_dev_state_change.new_state,
;;;355                                         gap_msg.msg_data.gap_dev_state_change.cause);
;;;356            }
;;;357            break;
;;;358    
;;;359        case GAP_MSG_LE_CONN_STATE_CHANGE:
;;;360            {
;;;361                app_handle_conn_state_evt(gap_msg.msg_data.gap_conn_state_change.conn_id,
;;;362                                          (T_GAP_CONN_STATE)gap_msg.msg_data.gap_conn_state_change.new_state,
;;;363                                          gap_msg.msg_data.gap_conn_state_change.disc_cause);
;;;364            }
;;;365            break;
;;;366    
;;;367        case GAP_MSG_LE_CONN_MTU_INFO:
;;;368            {
;;;369                app_handle_conn_mtu_info_evt(gap_msg.msg_data.gap_conn_mtu_info.conn_id,
;;;370                                             gap_msg.msg_data.gap_conn_mtu_info.mtu_size);
;;;371            }
;;;372            break;
;;;373    
;;;374        case GAP_MSG_LE_CONN_PARAM_UPDATE:
;;;375            {
;;;376                app_handle_conn_param_update_evt(gap_msg.msg_data.gap_conn_param_update.conn_id,
;;;377                                                 gap_msg.msg_data.gap_conn_param_update.status,
;;;378                                                 gap_msg.msg_data.gap_conn_param_update.cause);
;;;379            }
;;;380            break;
;;;381    
;;;382        case GAP_MSG_LE_AUTHEN_STATE_CHANGE:
;;;383            {
;;;384                app_handle_authen_state_evt(gap_msg.msg_data.gap_authen_state.conn_id,
;;;385                                            gap_msg.msg_data.gap_authen_state.new_state,
;;;386                                            gap_msg.msg_data.gap_authen_state.status);
;;;387            }
;;;388            break;
;;;389    
;;;390        case GAP_MSG_LE_BOND_JUST_WORK:
;;;391            {
;;;392                conn_id = gap_msg.msg_data.gap_bond_just_work_conf.conn_id;
;;;393                le_bond_just_work_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;394                APP_PRINT_INFO0("GAP_MSG_LE_BOND_JUST_WORK");
;;;395            }
;;;396            break;
;;;397    
;;;398        case GAP_MSG_LE_BOND_PASSKEY_DISPLAY:
;;;399            {
;;;400                uint32_t display_value = 0;
;;;401                conn_id = gap_msg.msg_data.gap_bond_passkey_display.conn_id;
;;;402                le_bond_get_display_key(conn_id, &display_value);
;;;403                APP_PRINT_INFO2("GAP_MSG_LE_BOND_PASSKEY_DISPLAY: conn_id %d, passkey %d",
;;;404                                conn_id, display_value);
;;;405                le_bond_passkey_display_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;406    #if 0 //by vsop			
;;;407                data_uart_print("GAP_MSG_LE_BOND_PASSKEY_DISPLAY: conn_id %d, passkey %d\r\n",
;;;408                                conn_id,
;;;409                                display_value);
;;;410    #endif
;;;411            }
;;;412            break;
;;;413    
;;;414        case GAP_MSG_LE_BOND_USER_CONFIRMATION:
;;;415            {
;;;416                uint32_t display_value = 0;
;;;417                conn_id = gap_msg.msg_data.gap_bond_user_conf.conn_id;
;;;418                le_bond_get_display_key(conn_id, &display_value);
;;;419                APP_PRINT_INFO2("GAP_MSG_LE_BOND_USER_CONFIRMATION: conn_id %d, passkey %d",
;;;420                                conn_id, display_value);
;;;421    #if 0 //by vsop			
;;;422                data_uart_print("GAP_MSG_LE_BOND_USER_CONFIRMATION: conn_id %d, passkey %d\r\n",
;;;423                                conn_id,
;;;424                                display_value);
;;;425    #endif
;;;426                //le_bond_user_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;427            }
;;;428            break;
;;;429    
;;;430        case GAP_MSG_LE_BOND_PASSKEY_INPUT:
;;;431            {
;;;432                //uint32_t passkey = 888888;
;;;433                conn_id = gap_msg.msg_data.gap_bond_passkey_input.conn_id;
;;;434                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d", conn_id);
;;;435    #if 0 //by vsop			
;;;436                data_uart_print("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d\r\n", conn_id);
;;;437    #endif
;;;438                //le_bond_passkey_input_confirm(conn_id, passkey, GAP_CFM_CAUSE_ACCEPT);
;;;439            }
;;;440            break;
;;;441    
;;;442        case GAP_MSG_LE_BOND_OOB_INPUT:
;;;443            {
;;;444                uint8_t oob_data[GAP_OOB_LEN] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
;;;445                conn_id = gap_msg.msg_data.gap_bond_oob_input.conn_id;
;;;446                APP_PRINT_INFO1("GAP_MSG_LE_BOND_OOB_INPUT: conn_id %d", conn_id);
;;;447                le_bond_set_param(GAP_PARAM_BOND_OOB_DATA, GAP_OOB_LEN, oob_data);
;;;448                le_bond_oob_input_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;449            }
;;;450            break;
;;;451    
;;;452        default:
;;;453            APP_PRINT_ERROR1("app_handle_gap_msg: unknown subtype %d", p_gap_msg->subtype);
;;;454            break;
;;;455        }
;;;456    }
;;;457    
;;;458    bool filter_scan_info_by_name(uint8_t *name, T_LE_SCAN_INFO *scan_info)
;;;459    {
;;;460        uint8_t buffer[32];
;;;461        uint8_t pos = 0;
;;;462    
;;;463        while (pos < scan_info->data_len)
;;;464        {
;;;465            /* Length of the AD structure. */
;;;466            uint8_t length = scan_info->data[pos++];
;;;467            uint8_t type;
;;;468    
;;;469            if ((length > 0x01) && ((pos + length) <= 31))
;;;470            {
;;;471                /* Copy the AD Data to buffer. */
;;;472                memcpy(buffer, scan_info->data + pos + 1, length - 1);
;;;473                /* AD Type, one octet. */
;;;474                type = scan_info->data[pos];
;;;475                switch (type)
;;;476                {
;;;477    	            case GAP_ADTYPE_LOCAL_NAME_COMPLETE:
;;;478    	                {
;;;479    	                    buffer[length - 1] = '\0';
;;;480    	                    //data_uart_print("GAP_ADTYPE_LOCAL_NAME_XXX: %s\r\n", buffer);
;;;481    						if(strncmp((char *)buffer,(char *)name,5)==0)return true;
;;;482    	                }
;;;483    	                break;
;;;484    	            default:
;;;485    	                break;
;;;486    	            }
;;;487            }
;;;488            pos += length;
;;;489        }
;;;490    	return false;
;;;491    }
;;;492    
;;;493    
;;;494    /** @} */ /* End of group CENTRAL_GAP_MSG */
;;;495    void app_parse_scan_info(T_LE_SCAN_INFO *scan_info)
;;;496    {
;;;497        uint8_t buffer[32];
;;;498        uint8_t pos = 0;
;;;499    	data_uart_print("+++++++++++++++++++++++++++++\r\n");
;;;500    
;;;501        while (pos < scan_info->data_len)
;;;502        {
;;;503            /* Length of the AD structure. */
;;;504            uint8_t length = scan_info->data[pos++];
;;;505            uint8_t type;
;;;506    
;;;507            if ((length > 0x01) && ((pos + length) <= 31))
;;;508            {
;;;509                /* Copy the AD Data to buffer. */
;;;510                memcpy(buffer, scan_info->data + pos + 1, length - 1);
;;;511                /* AD Type, one octet. */
;;;512                type = scan_info->data[pos];
;;;513    
;;;514                data_uart_print("app_parse_scan_info: AD Structure Info: AD type 0x%x, AD Data Length %d\r\n", type,
;;;515                                 length - 1);
;;;516    
;;;517                switch (type)
;;;518                {
;;;519                case GAP_ADTYPE_FLAGS:
;;;520                    {
;;;521                        /* (flags & 0x01) -- LE Limited Discoverable Mode */
;;;522                        /* (flags & 0x02) -- LE General Discoverable Mode */
;;;523                        /* (flags & 0x04) -- BR/EDR Not Supported */
;;;524                        /* (flags & 0x08) -- Simultaneous LE and BR/EDR to Same Device Capable (Controller) */
;;;525                        /* (flags & 0x10) -- Simultaneous LE and BR/EDR to Same Device Capable (Host) */
;;;526                        uint8_t flags = scan_info->data[pos + 1];
;;;527                        data_uart_print("GAP_ADTYPE_FLAGS: 0x%x\r\n", flags);
;;;528                    }
;;;529                    break;
;;;530    
;;;531                case GAP_ADTYPE_16BIT_MORE:
;;;532                case GAP_ADTYPE_16BIT_COMPLETE:
;;;533                case GAP_ADTYPE_SERVICES_LIST_16BIT:
;;;534                    {
;;;535                        uint16_t *p_uuid = (uint16_t *)(buffer);
;;;536                        uint8_t i = length - 1;
;;;537    
;;;538                        while (i >= 2)
;;;539                        {
;;;540                            data_uart_print("GAP_ADTYPE_16BIT_XXX: 0x%x\r\n", *p_uuid++);
;;;541                            i -= 2;
;;;542                        }
;;;543                    }
;;;544                    break;
;;;545    
;;;546                case GAP_ADTYPE_32BIT_MORE:
;;;547                case GAP_ADTYPE_32BIT_COMPLETE:
;;;548                    {
;;;549                        uint32_t *p_uuid = (uint32_t *)(buffer);
;;;550                        uint8_t    i     = length - 1;
;;;551    
;;;552                        while (i >= 4)
;;;553                        {
;;;554                            data_uart_print("GAP_ADTYPE_32BIT_XXX: 0x%x\r\n", *p_uuid++);
;;;555                            i -= 4;
;;;556                        }
;;;557                    }
;;;558                    break;
;;;559    
;;;560                case GAP_ADTYPE_128BIT_MORE:
;;;561                case GAP_ADTYPE_128BIT_COMPLETE:
;;;562                case GAP_ADTYPE_SERVICES_LIST_128BIT:
;;;563                    {
;;;564                        uint32_t *p_uuid = (uint32_t *)(buffer);
;;;565                        data_uart_print("GAP_ADTYPE_128BIT_XXX: 0x%8.8x%8.8x%8.8x%8.8x\r\n",
;;;566                                        p_uuid[3], p_uuid[2], p_uuid[1], p_uuid[0]);
;;;567                    }
;;;568                    break;
;;;569    
;;;570                case GAP_ADTYPE_LOCAL_NAME_SHORT:
;;;571                case GAP_ADTYPE_LOCAL_NAME_COMPLETE:
;;;572                    {
;;;573                        buffer[length - 1] = '\0';
;;;574                        data_uart_print("GAP_ADTYPE_LOCAL_NAME_XXX: %s\r\n", buffer);
;;;575                    }
;;;576                    break;
;;;577    
;;;578                case GAP_ADTYPE_POWER_LEVEL:
;;;579                    {
;;;580                        data_uart_print("GAP_ADTYPE_POWER_LEVEL: 0x%x\r\n", scan_info->data[pos + 1]);
;;;581                    }
;;;582                    break;
;;;583    
;;;584                case GAP_ADTYPE_SLAVE_CONN_INTERVAL_RANGE:
;;;585                    {
;;;586                        uint16_t *p_min = (uint16_t *)(buffer);
;;;587                        uint16_t *p_max = p_min + 1;
;;;588                        APP_PRINT_INFO2("GAP_ADTYPE_SLAVE_CONN_INTERVAL_RANGE: 0x%x - 0x%x", *p_min,
;;;589                                        *p_max);
;;;590                    }
;;;591                    break;
;;;592    
;;;593                case GAP_ADTYPE_SERVICE_DATA:
;;;594                    {
;;;595                        uint16_t *p_uuid = (uint16_t *)(buffer);
;;;596                        uint8_t data_len = length - 3;
;;;597    
;;;598                        data_uart_print("GAP_ADTYPE_SERVICE_DATA: UUID 0x%x, len %d, data %b\r\n", *p_uuid,
;;;599                                        data_len, TRACE_BINARY(data_len, &buffer[2]));
;;;600                    }
;;;601                    break;
;;;602                case GAP_ADTYPE_APPEARANCE:
;;;603                    {
;;;604                        uint16_t *p_appearance = (uint16_t *)(buffer);
;;;605                        data_uart_print("GAP_ADTYPE_APPEARANCE: %d\r\n", *p_appearance);
;;;606                    }
;;;607                    break;
;;;608    
;;;609                case GAP_ADTYPE_MANUFACTURER_SPECIFIC:
;;;610                    {
;;;611                        uint8_t data_len = length - 3;
;;;612                        uint16_t *p_company_id = (uint16_t *)(buffer);
;;;613                        data_uart_print("GAP_ADTYPE_MANUFACTURER_SPECIFIC: company_id 0x%x, len %d, data %b\r\n",
;;;614                                        *p_company_id, data_len, TRACE_BINARY(data_len, &buffer[2]));
;;;615                    }
;;;616                    break;
;;;617    
;;;618                default:
;;;619                    {
;;;620                        uint8_t i = 0;
;;;621    
;;;622                        for (i = 0; i < (length - 1); i++)
;;;623                        {
;;;624                            data_uart_print("  AD Data: Unhandled Data = 0x%x\r\n", scan_info->data[pos + i]);
;;;625                        }
;;;626                    }
;;;627                    break;
;;;628                }
;;;629            }
;;;630    
;;;631            pos += length;
;;;632        }
;;;633    		data_uart_print("------------------------------\r\n");
;;;634    }
;;;635    
;;;636    /** @defgroup  CENTRAL_SCAN_MGR Scan Information manager
;;;637        * @brief Scan Information manager
;;;638        * @{
;;;639        */
;;;640    /**
;;;641      * @brief Use 16 bit uuid to filter scan information
;;;642      * @param[in] uuid 16 bit UUID.
;;;643      * @param[in] scan_info point to scan information data.
;;;644      * @return filter result
;;;645      * @retval true found success
;;;646      * @retval false not found
;;;647      */
;;;648    bool filter_scan_info_by_uuid(uint16_t uuid, T_LE_SCAN_INFO *scan_info)
;;;649    {
;;;650        uint8_t buffer[32];
;;;651        uint8_t pos = 0;
;;;652    
;;;653        while (pos < scan_info->data_len)
;;;654        {
;;;655            /* Length of the AD structure. */
;;;656            uint8_t length = scan_info->data[pos++];
;;;657            uint8_t type;
;;;658    
;;;659            if ((length > 0x01) && ((pos + length) <= 31))
;;;660            {
;;;661                /* Copy the AD Data to buffer. */
;;;662                memcpy(buffer, scan_info->data + pos + 1, length - 1);
;;;663                /* AD Type, one octet. */
;;;664                type = scan_info->data[pos];
;;;665    
;;;666                switch (type)
;;;667                {
;;;668                case GAP_ADTYPE_16BIT_MORE:
;;;669                case GAP_ADTYPE_16BIT_COMPLETE:
;;;670                case GAP_ADTYPE_SERVICES_LIST_16BIT:
;;;671                    {
;;;672                        uint16_t *p_uuid = (uint16_t *)(buffer);
;;;673                        uint8_t i = length - 1;
;;;674    
;;;675                        while (i >= 2)
;;;676                        {
;;;677                            APP_PRINT_INFO2("  AD Data: UUID16 List Item %d = 0x%x", i / 2, *p_uuid);
;;;678    						//data_uart_print("  AD Data: UUID16 List Item %d = 0x%x\r\n", i / 2, *p_uuid);
;;;679                            if (*p_uuid == uuid)
;;;680                            {
;;;681                                return true;
;;;682                            }
;;;683                            p_uuid++;
;;;684                            i -= 2;
;;;685                        }
;;;686                    }
;;;687                    break;
;;;688    
;;;689                default:
;;;690                    break;
;;;691                }
;;;692            }
;;;693    
;;;694            pos += length;
;;;695        }
;;;696        return false;
;;;697    }
;;;698    /** @} */ /* End of group CENTRAL_SCAN_MGR */
;;;699    
;;;700    /** @defgroup  CENTRAL_GAP_CALLBACK GAP Callback Event Handler
;;;701        * @brief Handle GAP callback event
;;;702        * @{
;;;703        */
;;;704    /**
;;;705      * @brief Callback for gap le to notify app
;;;706      * @param[in] cb_type callback msy type @ref GAP_LE_MSG_Types.
;;;707      * @param[in] p_cb_data point to callback data @ref T_LE_CB_DATA.
;;;708      * @retval result @ref T_APP_RESULT
;;;709      */
;;;710    T_APP_RESULT app_gap_callback(uint8_t cb_type, void *p_cb_data)
;;;711    {
;;;712        T_APP_RESULT result = APP_RESULT_SUCCESS;
;;;713        T_LE_CB_DATA *p_data = (T_LE_CB_DATA *)p_cb_data;
;;;714    
;;;715    	uint8_t devname[]="CMT4501-a11005e2";
;;;716    
;;;717        switch (cb_type)
;;;718        {
;;;719        case GAP_MSG_LE_SCAN_INFO:
;;;720            APP_PRINT_INFO5("GAP_MSG_LE_SCAN_INFO:adv_type 0x%x, bd_addr %s, remote_addr_type %d, rssi %d, data_len %d",
;;;721                            p_data->p_le_scan_info->adv_type,
;;;722                            TRACE_BDADDR(p_data->p_le_scan_info->bd_addr),
;;;723                            p_data->p_le_scan_info->remote_addr_type,
;;;724                            p_data->p_le_scan_info->rssi,
;;;725                            p_data->p_le_scan_info->data_len);
;;;726            /* User can split interested information by using the function as follow. */
;;;727    
;;;728    #if 1
;;;729    		//app_parse_scan_info(p_data->p_le_scan_info);
;;;730    		if (filter_scan_info_by_name(devname, p_data->p_le_scan_info))
;;;731            {
;;;732                //data_uart_print("Found simple ble service\r\n");
;;;733                link_mgr_add_device(p_data->p_le_scan_info->bd_addr, p_data->p_le_scan_info->remote_addr_type);
;;;734            }
;;;735    #endif
;;;736    
;;;737            if (filter_scan_info_by_uuid(GATT_UUID_SIMPLE_PROFILE, p_data->p_le_scan_info))
;;;738            {
;;;739                APP_PRINT_INFO0("Found simple ble service");
;;;740                link_mgr_add_device(p_data->p_le_scan_info->bd_addr, p_data->p_le_scan_info->remote_addr_type);
;;;741            }
;;;742            /* If you want to parse the scan info, please reference function app_parse_scan_info in observer app. */
;;;743            break;
;;;744    
;;;745        case GAP_MSG_LE_CONN_UPDATE_IND:
;;;746            APP_PRINT_INFO5("GAP_MSG_LE_CONN_UPDATE_IND: conn_id %d, conn_interval_max 0x%x, conn_interval_min 0x%x, conn_latency 0x%x,supervision_timeout 0x%x",
;;;747                            p_data->p_le_conn_update_ind->conn_id,
;;;748                            p_data->p_le_conn_update_ind->conn_interval_max,
;;;749                            p_data->p_le_conn_update_ind->conn_interval_min,
;;;750                            p_data->p_le_conn_update_ind->conn_latency,
;;;751                            p_data->p_le_conn_update_ind->supervision_timeout);
;;;752            /* if reject the proposed connection parameter from peer device, use APP_RESULT_REJECT. */
;;;753            result = APP_RESULT_ACCEPT;
;;;754            break;
;;;755    
;;;756        default:
;;;757            APP_PRINT_ERROR1("app_gap_callback: unhandled cb_type 0x%x", cb_type);
;;;758            break;
;;;759        }
;;;760        return result;
;;;761    }
;;;762    /** @} */ /* End of group CENTRAL_GAP_CALLBACK */
;;;763    
;;;764    /** @defgroup  CENTRAL_SRV_DIS GATT Services discovery and storage
;;;765        * @brief GATT Services discovery and storage
;;;766        * @{
;;;767        */
;;;768    /**
;;;769     * @brief  Discovery GATT services
;;;770     * @param  conn_id connection ID.
;;;771     * @param  start first call. true - first call this function after conncection, false - not first
;;;772     * @retval None
;;;773     */
;;;774    void app_discov_services(uint8_t conn_id, bool start)
;;;775    {
        0x00209caa:    b538        8.      PUSH     {r3-r5,lr}
        0x00209cac:    4604        .F      MOV      r4,r0
;;;776        if (app_link_table[conn_id].conn_state != GAP_CONN_STATE_CONNECTED)
        0x00209cae:    4ab6        .J      LDR      r2,[pc,#728] ; [0x209f88] = 0x20d3a3
        0x00209cb0:    eb000084    ....    ADD      r0,r0,r4,LSL #2
        0x00209cb4:    4db2        .M      LDR      r5,[pc,#712] ; [0x209f80] = 0x21103002
        0x00209cb6:    f8123010    ...0    LDRB     r3,[r2,r0,LSL #1]
        0x00209cba:    1ead        ..      SUBS     r5,r5,#2
        0x00209cbc:    2b02        .+      CMP      r3,#2
        0x00209cbe:    d003        ..      BEQ      0x209cc8 ; app_discov_services + 30
;;;777        {
;;;778            APP_PRINT_ERROR1("app_discov_services: conn_id %d not connected ", conn_id);
        0x00209cc0:    4623        #F      MOV      r3,r4
        0x00209cc2:    2201        ."      MOVS     r2,#1
        0x00209cc4:    49c9        .I      LDR      r1,[pc,#804] ; [0x209fec] = 0x8801c88
;;;779            return;
        0x00209cc6:    e024        $.      B        0x209d12 ; app_discov_services + 104
;;;780        }
;;;781        if (start)
        0x00209cc8:    b149        I.      CBZ      r1,0x209cde ; app_discov_services + 52
;;;782        {
;;;783    #if F_BT_GATT_SRV_HANDLE_STORAGE
;;;784            bool is_disc = true;
;;;785            T_APP_SRVS_HDL_TABLE app_srvs_table;
;;;786            if (app_load_srvs_hdl_table(&app_srvs_table) == 0)
;;;787            {
;;;788                if ((app_srvs_table.srv_found_flags != 0) &&
;;;789                    (app_srvs_table.bd_type == app_link_table[conn_id].bd_type) &&
;;;790                    (memcmp(app_srvs_table.bd_addr, app_link_table[conn_id].bd_addr, GAP_BD_ADDR_LEN) == 0))
;;;791                {
;;;792                    APP_PRINT_INFO1("app_discov_services: load from flash, srv_found_flags 0x%x",
;;;793                                    app_srvs_table.srv_found_flags);
;;;794                    app_link_table[conn_id].srv_found_flags = app_srvs_table.srv_found_flags;
;;;795                    if (app_srvs_table.srv_found_flags & APP_DISCOV_GAPS_FLAG)
;;;796                    {
;;;797                        gaps_set_hdl_cache(conn_id, app_srvs_table.gaps_hdl_cache, sizeof(uint16_t) * HDL_GAPS_CACHE_LEN);
;;;798                    }
;;;799                    if (app_srvs_table.srv_found_flags & APP_DISCOV_SIMP_FLAG)
;;;800                    {
;;;801                        simp_ble_client_set_hdl_cache(conn_id, app_srvs_table.simp_hdl_cache,
;;;802                                                      sizeof(uint16_t) * HDL_SIMBLE_CACHE_LEN);
;;;803                    }
;;;804                    if (app_srvs_table.srv_found_flags & APP_DISCOV_BAS_FLAG)
;;;805                    {
;;;806                        bas_set_hdl_cache(conn_id, app_srvs_table.bas_hdl_cache, sizeof(uint16_t) * HDL_BAS_CACHE_LEN);
;;;807                    }
;;;808                    is_disc = false;
;;;809                }
;;;810            }
;;;811            else
;;;812            {
;;;813                APP_PRINT_ERROR0("app_load_srvs_hdl_table: failed");
;;;814            }
;;;815    
;;;816            if (is_disc)
;;;817            {
;;;818                if (gaps_start_discovery(conn_id) == false)
;;;819                {
;;;820                    APP_PRINT_ERROR1("app_discov_services: discover gaps failed conn_id %d", conn_id);
;;;821                }
;;;822            }
;;;823    #else
;;;824            if (gaps_start_discovery(conn_id) == false)
        0x00209cca:    4620         F      MOV      r0,r4
        0x00209ccc:    f7fff9e0    ....    BL       gaps_start_discovery ; 0x209090
        0x00209cd0:    2800        .(      CMP      r0,#0
        0x00209cd2:    d12d        -.      BNE      0x209d30 ; app_discov_services + 134
;;;825            {
;;;826                APP_PRINT_ERROR1("app_discov_services: discover gaps failed conn_id %d", conn_id);
        0x00209cd4:    49c5        .I      LDR      r1,[pc,#788] ; [0x209fec] = 0x8801c88
        0x00209cd6:    2201        ."      MOVS     r2,#1
        0x00209cd8:    4623        #F      MOV      r3,r4
        0x00209cda:    3134        41      ADDS     r1,r1,#0x34
        0x00209cdc:    e019        ..      B        0x209d12 ; app_discov_services + 104
;;;827            }
;;;828    #endif
;;;829            return;
;;;830        }
;;;831        if ((app_link_table[conn_id].discovered_flags & APP_DISCOV_SIMP_FLAG) == 0)
        0x00209cde:    eb020140    ..@.    ADD      r1,r2,r0,LSL #1
        0x00209ce2:    784a        Jx      LDRB     r2,[r1,#1]
        0x00209ce4:    0790        ..      LSLS     r0,r2,#30
        0x00209ce6:    d409        ..      BMI      0x209cfc ; app_discov_services + 82
;;;832        {
;;;833            if (simp_ble_client_start_discovery(conn_id) == false)
        0x00209ce8:    4620         F      MOV      r0,r4
        0x00209cea:    f7fefab9    ....    BL       simp_ble_client_start_discovery ; 0x208260
        0x00209cee:    2800        .(      CMP      r0,#0
        0x00209cf0:    d11e        ..      BNE      0x209d30 ; app_discov_services + 134
;;;834            {
;;;835                APP_PRINT_ERROR1("app_discov_services: discover simp failed conn_id %d", conn_id);
        0x00209cf2:    49be        .I      LDR      r1,[pc,#760] ; [0x209fec] = 0x8801c88
        0x00209cf4:    2201        ."      MOVS     r2,#1
        0x00209cf6:    4623        #F      MOV      r3,r4
        0x00209cf8:    316c        l1      ADDS     r1,r1,#0x6c
        0x00209cfa:    e00a        ..      B        0x209d12 ; app_discov_services + 104
;;;836            }
;;;837        }
;;;838        else if ((app_link_table[conn_id].discovered_flags & APP_DISCOV_BAS_FLAG) == 0)
        0x00209cfc:    0750        P.      LSLS     r0,r2,#29
        0x00209cfe:    d40e        ..      BMI      0x209d1e ; app_discov_services + 116
;;;839        {
;;;840            if (bas_start_discovery(conn_id) == false)
        0x00209d00:    4620         F      MOV      r0,r4
        0x00209d02:    f7fefefd    ....    BL       bas_start_discovery ; 0x208b00
        0x00209d06:    2800        .(      CMP      r0,#0
        0x00209d08:    d112        ..      BNE      0x209d30 ; app_discov_services + 134
;;;841            {
;;;842                APP_PRINT_ERROR1("app_discov_services: discover bas failed conn_id %d", conn_id);
        0x00209d0a:    49b8        .I      LDR      r1,[pc,#736] ; [0x209fec] = 0x8801c88
        0x00209d0c:    2201        ."      MOVS     r2,#1
        0x00209d0e:    4623        #F      MOV      r3,r4
        0x00209d10:    31a4        .1      ADDS     r1,r1,#0xa4
        0x00209d12:    b001        ..      ADD      sp,sp,#4
        0x00209d14:    4628        (F      MOV      r0,r5
        0x00209d16:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x00209d1a:    f5fdbea0    ....    B        log_buffer ; 0x7a5e
;;;843            }
;;;844        }
;;;845        else
;;;846        {
;;;847            APP_PRINT_INFO2("app_discov_services: discover complete, conn_id %d, srv_found_flags 0x%x",
        0x00209d1e:    7888        .x      LDRB     r0,[r1,#2]
        0x00209d20:    49b2        .I      LDR      r1,[pc,#712] ; [0x209fec] = 0x8801c88
        0x00209d22:    9000        ..      STR      r0,[sp,#0]
        0x00209d24:    4623        #F      MOV      r3,r4
        0x00209d26:    2202        ."      MOVS     r2,#2
        0x00209d28:    31dc        .1      ADDS     r1,r1,#0xdc
        0x00209d2a:    4895        .H      LDR      r0,[pc,#596] ; [0x209f80] = 0x21103002
        0x00209d2c:    f5fdfe97    ....    BL       log_buffer ; 0x7a5e
;;;848                            conn_id, app_link_table[conn_id].srv_found_flags);
;;;849    #if F_BT_GATT_SRV_HANDLE_STORAGE
;;;850            if (app_link_table[conn_id].srv_found_flags != 0)
;;;851            {
;;;852                T_APP_SRVS_HDL_TABLE app_srvs_table;
;;;853                memset(&app_srvs_table, 0, sizeof(T_APP_SRVS_HDL_TABLE));
;;;854                app_srvs_table.bd_type = app_link_table[conn_id].bd_type;
;;;855                app_srvs_table.srv_found_flags = app_link_table[conn_id].srv_found_flags;
;;;856                memcpy(app_srvs_table.bd_addr, app_link_table[conn_id].bd_addr, GAP_BD_ADDR_LEN);
;;;857                gaps_get_hdl_cache(conn_id, app_srvs_table.gaps_hdl_cache, sizeof(uint16_t) * HDL_GAPS_CACHE_LEN);
;;;858                simp_ble_client_get_hdl_cache(conn_id, app_srvs_table.simp_hdl_cache,
;;;859                                              sizeof(uint16_t) * HDL_SIMBLE_CACHE_LEN);
;;;860                bas_get_hdl_cache(conn_id, app_srvs_table.bas_hdl_cache, sizeof(uint16_t) * HDL_BAS_CACHE_LEN);
;;;861                if (app_save_srvs_hdl_table(&app_srvs_table) != 0)
;;;862                {
;;;863                    APP_PRINT_ERROR0("app_save_srvs_hdl_table: failed");
;;;864                }
;;;865            }
;;;866    #endif
;;;867        }
;;;868    
;;;869        return;
;;;870    }
        0x00209d30:    bd38        8.      POP      {r3-r5,pc}
    app_handle_conn_mtu_info_evt
;;; ..\..\..\src\sample\ble_central\central_app.c (287)
        0x00209d32:    b538        8.      PUSH     {r3-r5,lr}
        0x00209d34:    4604        .F      MOV      r4,r0
;;;288        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
        0x00209d36:    9100        ..      STR      r1,[sp,#0]
        0x00209d38:    4992        .I      LDR      r1,[pc,#584] ; [0x209f84] = 0x8801828
        0x00209d3a:    4603        .F      MOV      r3,r0
        0x00209d3c:    2202        ."      MOVS     r2,#2
        0x00209d3e:    3134        41      ADDS     r1,r1,#0x34
        0x00209d40:    488f        .H      LDR      r0,[pc,#572] ; [0x209f80] = 0x21103002
        0x00209d42:    f5fdfe8c    ....    BL       log_buffer ; 0x7a5e
;;;289        app_discov_services(conn_id, true);
        0x00209d46:    4620         F      MOV      r0,r4
        0x00209d48:    e8bd4038    ..8@    POP      {r3-r5,lr}
        0x00209d4c:    2101        .!      MOVS     r1,#1
        0x00209d4e:    e7ac        ..      B        app_discov_services ; 0x209caa
    app_handle_conn_state_evt
;;; ..\..\..\src\sample\ble_central\central_app.c (141)
        0x00209d50:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x00209d54:    b086        ..      SUB      sp,sp,#0x18
        0x00209d56:    4615        .F      MOV      r5,r2
        0x00209d58:    460e        .F      MOV      r6,r1
        0x00209d5a:    4607        .F      MOV      r7,r0
        0x00209d5c:    2804        .(      CMP      r0,#4
;;; ..\..\..\src\sample\ble_central\central_app.c (141)
        0x00209d5e:    d25f        _.      BCS      0x209e20 ; app_handle_conn_state_evt + 208
;;;142        if (conn_id >= APP_MAX_LINKS)
;;;143        {
;;;144            return;
;;;145        }
;;;146    
;;;147        APP_PRINT_INFO4("app_handle_conn_state_evt: conn_id %d, conn_state(%d -> %d), disc_cause 0x%x",
        0x00209d60:    f8df8224    ..$.    LDR      r8,[pc,#548] ; [0x209f88] = 0x20d3a3
        0x00209d64:    eb070487    ....    ADD      r4,r7,r7,LSL #2
        0x00209d68:    4984        .I      LDR      r1,[pc,#528] ; [0x209f7c] = 0x8801724
        0x00209d6a:    f8180014    ....    LDRB     r0,[r8,r4,LSL #1]
        0x00209d6e:    e9cd0600    ....    STRD     r0,r6,[sp,#0]
        0x00209d72:    463b        ;F      MOV      r3,r7
        0x00209d74:    2204        ."      MOVS     r2,#4
        0x00209d76:    3998        .9      SUBS     r1,r1,#0x98
        0x00209d78:    9502        ..      STR      r5,[sp,#8]
        0x00209d7a:    4881        .H      LDR      r0,[pc,#516] ; [0x209f80] = 0x21103002
        0x00209d7c:    f5fdfe6f    ..o.    BL       log_buffer ; 0x7a5e
        0x00209d80:    f8086014    ...`    STRB     r6,[r8,r4,LSL #1]
        0x00209d84:    4640        @F      MOV      r0,r8
        0x00209d86:    eb000444    ..D.    ADD      r4,r0,r4,LSL #1
;;;148                        conn_id, app_link_table[conn_id].conn_state, new_state, disc_cause);
;;;149    
;;;150        app_link_table[conn_id].conn_state = new_state;
;;;151        switch (new_state)
        0x00209d8a:    b1fe        ..      CBZ      r6,0x209dcc ; app_handle_conn_state_evt + 124
        0x00209d8c:    2e02        ..      CMP      r6,#2
        0x00209d8e:    d147        G.      BNE      0x209e20 ; app_handle_conn_state_evt + 208
        0x00209d90:    1ce2        ..      ADDS     r2,r4,#3
        0x00209d92:    1d21        !.      ADDS     r1,r4,#4
        0x00209d94:    4638        8F      MOV      r0,r7
        0x00209d96:    f643ff2a    C.*.    BL       le_get_conn_addr ; 0x4dbee
        0x00209d9a:    79e0        .y      LDRB     r0,[r4,#7]
        0x00209d9c:    ad01        ..      ADD      r5,sp,#4
        0x00209d9e:    7923        #y      LDRB     r3,[r4,#4]
        0x00209da0:    7962        by      LDRB     r2,[r4,#5]
        0x00209da2:    79a1        .y      LDRB     r1,[r4,#6]
        0x00209da4:    e885000f    ....    STM      r5,{r0-r3}
        0x00209da8:    7a20         z      LDRB     r0,[r4,#8]
        0x00209daa:    9000        ..      STR      r0,[sp,#0]
        0x00209dac:    7a63        cz      LDRB     r3,[r4,#9]
        0x00209dae:    463a        :F      MOV      r2,r7
        0x00209db0:    a18f        ..      ADR      r1,{pc}+0x240 ; 0x209ff0
        0x00209db2:    4881        .H      LDR      r0,[pc,#516] ; [0x209fb8] = 0x20d170
        0x00209db4:    f001ffcc    ....    BL       __2sprintf ; 0x20bd50
        0x00209db8:    487f        .H      LDR      r0,[pc,#508] ; [0x209fb8] = 0x20d170
        0x00209dba:    f650f84f    P.O.    BL       strlen ; 0x59e5c
        0x00209dbe:    b006        ..      ADD      sp,sp,#0x18
        0x00209dc0:    b281        ..      UXTH     r1,r0
        0x00209dc2:    e8bd41f0    ...A    POP      {r4-r8,lr}
        0x00209dc6:    487c        |H      LDR      r0,[pc,#496] ; [0x209fb8] = 0x20d170
        0x00209dc8:    f000bf45    ..E.    B.W      FramingWrapFrameUartPrint ; 0x20ac56
;;;152        {
;;;153        case GAP_CONN_STATE_DISCONNECTED:
;;;154            {
;;;155                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
        0x00209dcc:    f5a57080    ...p    SUB      r0,r5,#0x100
        0x00209dd0:    3813        .8      SUBS     r0,r0,#0x13
        0x00209dd2:    d00b        ..      BEQ      0x209dec ; app_handle_conn_state_evt + 156
;;;156                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
        0x00209dd4:    f5b57f8b    ....    CMP      r5,#0x116
        0x00209dd8:    d008        ..      BEQ      0x209dec ; app_handle_conn_state_evt + 156
;;;157                {
;;;158                    APP_PRINT_ERROR2("app_handle_conn_state_evt: connection lost, conn_id %d, cause 0x%x", conn_id,
        0x00209dda:    4968        hI      LDR      r1,[pc,#416] ; [0x209f7c] = 0x8801724
        0x00209ddc:    4868        hH      LDR      r0,[pc,#416] ; [0x209f80] = 0x21103002
        0x00209dde:    463b        ;F      MOV      r3,r7
        0x00209de0:    2202        ."      MOVS     r2,#2
        0x00209de2:    3948        H9      SUBS     r1,r1,#0x48
        0x00209de4:    1e80        ..      SUBS     r0,r0,#2
        0x00209de6:    9500        ..      STR      r5,[sp,#0]
        0x00209de8:    f5fdfe39    ..9.    BL       log_buffer ; 0x7a5e
;;;159                                     disc_cause);
;;;160                }
;;;161    #if 0 //by vsop	
;;;162               data_uart_print("#disc#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;163    						conn_id,
;;;164    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;165    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;166    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;167    #else
;;;168    			sprintf(cmd_buffer,"#disc#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
        0x00209dec:    79e0        .y      LDRB     r0,[r4,#7]
        0x00209dee:    ad01        ..      ADD      r5,sp,#4
        0x00209df0:    7923        #y      LDRB     r3,[r4,#4]
        0x00209df2:    7962        by      LDRB     r2,[r4,#5]
        0x00209df4:    79a1        .y      LDRB     r1,[r4,#6]
        0x00209df6:    e885000f    ....    STM      r5,{r0-r3}
        0x00209dfa:    7a20         z      LDRB     r0,[r4,#8]
        0x00209dfc:    9000        ..      STR      r0,[sp,#0]
        0x00209dfe:    7a63        cz      LDRB     r3,[r4,#9]
        0x00209e00:    463a        :F      MOV      r2,r7
        0x00209e02:    a186        ..      ADR      r1,{pc}+0x21a ; 0x20a01c
        0x00209e04:    486c        lH      LDR      r0,[pc,#432] ; [0x209fb8] = 0x20d170
        0x00209e06:    f001ffa3    ....    BL       __2sprintf ; 0x20bd50
;;;169    						conn_id,
;;;170    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;171    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;172    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;173    				FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));
        0x00209e0a:    486b        kH      LDR      r0,[pc,#428] ; [0x209fb8] = 0x20d170
        0x00209e0c:    f650f826    P.&.    BL       strlen ; 0x59e5c
        0x00209e10:    b281        ..      UXTH     r1,r0
        0x00209e12:    4869        iH      LDR      r0,[pc,#420] ; [0x209fb8] = 0x20d170
        0x00209e14:    f000ff1f    ....    BL       FramingWrapFrameUartPrint ; 0x20ac56
;;;174    
;;;175    #endif
;;;176                memset(&app_link_table[conn_id], 0, sizeof(T_APP_LINK));
        0x00209e18:    2000        .       MOVS     r0,#0
        0x00209e1a:    6020         `      STR      r0,[r4,#0]
        0x00209e1c:    6060        ``      STR      r0,[r4,#4]
        0x00209e1e:    8120         .      STRH     r0,[r4,#8]
;;;177            }
;;;178            break;
;;;179    
;;;180        case GAP_CONN_STATE_CONNECTED:
;;;181            {
;;;182            	//T_GAP_CAUSE cause;
;;;183                le_get_conn_addr(conn_id, app_link_table[conn_id].bd_addr,
;;;184                                 &app_link_table[conn_id].bd_type);
;;;185    #if 0 //by vsop			
;;;186               data_uart_print("#condev#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;187    						conn_id,
;;;188    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;189    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;190    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;191    #else
;;;192          sprintf(cmd_buffer,"#condev#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;193    						conn_id,
;;;194    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;195    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;196    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;197    	FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));
;;;198    #endif
;;;199            }
;;;200            break;
;;;201    
;;;202        default:
;;;203            break;
;;;204    
;;;205        }
;;;206    }
        0x00209e20:    b006        ..      ADD      sp,sp,#0x18
        0x00209e22:    e8bd81f0    ....    POP      {r4-r8,pc}
    app_handle_dev_state_evt
        0x00209e26:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x00209e2a:    b2c4        ..      UXTB     r4,r0
;;; ..\..\..\src\sample\ble_central\central_app.c (100)
        0x00209e2c:    f3c41501    ....    UBFX     r5,r4,#4,#2
        0x00209e30:    e9cd5100    ...Q    STRD     r5,r1,[sp,#0]
        0x00209e34:    f8df8148    ..H.    LDR      r8,[pc,#328] ; [0x209f80] = 0x21103002
        0x00209e38:    f0040601    ....    AND      r6,r4,#1
        0x00209e3c:    4633        3F      MOV      r3,r6
        0x00209e3e:    2203        ."      MOVS     r2,#3
        0x00209e40:    4981        .I      LDR      r1,[pc,#516] ; [0x20a048] = 0x8801608
        0x00209e42:    4640        @F      MOV      r0,r8
        0x00209e44:    f5fdfe0b    ....    BL       log_buffer ; 0x7a5e
;;;101                        new_state.gap_init_state,
;;;102                        new_state.gap_scan_state, cause);
;;;103        if (gap_dev_state.gap_init_state != new_state.gap_init_state)
        0x00209e48:    4f80        .O      LDR      r7,[pc,#512] ; [0x20a04c] = 0x20d374
        0x00209e4a:    7838        8x      LDRB     r0,[r7,#0]
        0x00209e4c:    f0000001    ....    AND      r0,r0,#1
        0x00209e50:    42b0        .B      CMP      r0,r6
        0x00209e52:    d00c        ..      BEQ      0x209e6e ; app_handle_dev_state_evt + 72
;;;104        {
;;;105            if (new_state.gap_init_state == GAP_INIT_STATE_STACK_READY)
        0x00209e54:    07e0        ..      LSLS     r0,r4,#31
        0x00209e56:    d00a        ..      BEQ      0x209e6e ; app_handle_dev_state_evt + 72
;;;106            {
;;;107                uint8_t bt_addr[6];
;;;108                APP_PRINT_INFO0("GAP stack ready");
        0x00209e58:    497b        {I      LDR      r1,[pc,#492] ; [0x20a048] = 0x8801608
        0x00209e5a:    2200        ."      MOVS     r2,#0
        0x00209e5c:    3148        H1      ADDS     r1,r1,#0x48
        0x00209e5e:    4640        @F      MOV      r0,r8
        0x00209e60:    f5fdfdfd    ....    BL       log_buffer ; 0x7a5e
;;;109                /*stack ready*/
;;;110                gap_get_param(GAP_PARAM_BD_ADDR, bt_addr);
        0x00209e64:    4669        iF      MOV      r1,sp
        0x00209e66:    f44f7000    O..p    MOV      r0,#0x200
        0x00209e6a:    f642f8e4    B...    BL       gap_get_param ; 0x4c036
;;;111            }
;;;112        }
;;;113    
;;;114        if (gap_dev_state.gap_scan_state != new_state.gap_scan_state)
        0x00209e6e:    7838        8x      LDRB     r0,[r7,#0]
        0x00209e70:    f3c01001    ....    UBFX     r0,r0,#4,#2
        0x00209e74:    42a8        .B      CMP      r0,r5
        0x00209e76:    d00f        ..      BEQ      0x209e98 ; app_handle_dev_state_evt + 114
;;;115        {
;;;116            if (new_state.gap_scan_state == GAP_SCAN_STATE_IDLE)
        0x00209e78:    f0140f30    ..0.    TST      r4,#0x30
        0x00209e7c:    d002        ..      BEQ      0x209e84 ; app_handle_dev_state_evt + 94
        0x00209e7e:    2d02        .-      CMP      r5,#2
        0x00209e80:    d004        ..      BEQ      0x209e8c ; app_handle_dev_state_evt + 102
        0x00209e82:    e009        ..      B        0x209e98 ; app_handle_dev_state_evt + 114
;;;117            {
;;;118                APP_PRINT_INFO0("GAP scan stop");
        0x00209e84:    4970        pI      LDR      r1,[pc,#448] ; [0x20a048] = 0x8801608
        0x00209e86:    2200        ."      MOVS     r2,#0
        0x00209e88:    315c        \1      ADDS     r1,r1,#0x5c
        0x00209e8a:    e002        ..      B        0x209e92 ; app_handle_dev_state_evt + 108
;;;119                //data_uart_print("GAP scan stop\r\n"); 	//by vsop
;;;120            }
;;;121            else if (new_state.gap_scan_state == GAP_SCAN_STATE_SCANNING)
;;;122            {
;;;123                APP_PRINT_INFO0("GAP scan start");
        0x00209e8c:    496e        nI      LDR      r1,[pc,#440] ; [0x20a048] = 0x8801608
        0x00209e8e:    2200        ."      MOVS     r2,#0
        0x00209e90:    3170        p1      ADDS     r1,r1,#0x70
        0x00209e92:    4640        @F      MOV      r0,r8
        0x00209e94:    f5fdfde3    ....    BL       log_buffer ; 0x7a5e
;;;124                //data_uart_print("GAP scan start\r\n");	//by vsop
;;;125            }
;;;126        }
;;;127    
;;;128        gap_dev_state = new_state;
        0x00209e98:    703c        <p      STRB     r4,[r7,#0]
;;;129    }
        0x00209e9a:    e8bd81fc    ....    POP      {r2-r8,pc}
    app_handle_gap_msg
;;;130    
;;;131    /**
;;;132     * @brief    Handle msg GAP_MSG_LE_CONN_STATE_CHANGE
;;;133     * @note     All the gap conn state events are pre-handled in this function.
;;;134     *           Then the event handling function shall be called according to the new_state
;;;135     * @param[in] conn_id Connection ID
;;;136     * @param[in] new_state  New gap connection state
;;;137     * @param[in] disc_cause Use this cause when new_state is GAP_CONN_STATE_DISCONNECTED
;;;138     * @return   void
;;;139     */
;;;140    void app_handle_conn_state_evt(uint8_t conn_id, T_GAP_CONN_STATE new_state, uint16_t disc_cause)
;;;141    {
;;;142        if (conn_id >= APP_MAX_LINKS)
;;;143        {
;;;144            return;
;;;145        }
;;;146    
;;;147        APP_PRINT_INFO4("app_handle_conn_state_evt: conn_id %d, conn_state(%d -> %d), disc_cause 0x%x",
;;;148                        conn_id, app_link_table[conn_id].conn_state, new_state, disc_cause);
;;;149    
;;;150        app_link_table[conn_id].conn_state = new_state;
;;;151        switch (new_state)
;;;152        {
;;;153        case GAP_CONN_STATE_DISCONNECTED:
;;;154            {
;;;155                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
;;;156                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
;;;157                {
;;;158                    APP_PRINT_ERROR2("app_handle_conn_state_evt: connection lost, conn_id %d, cause 0x%x", conn_id,
;;;159                                     disc_cause);
;;;160                }
;;;161    #if 0 //by vsop	
;;;162               data_uart_print("#disc#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;163    						conn_id,
;;;164    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;165    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;166    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;167    #else
;;;168    			sprintf(cmd_buffer,"#disc#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;169    						conn_id,
;;;170    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;171    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;172    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;173    				FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));
;;;174    
;;;175    #endif
;;;176                memset(&app_link_table[conn_id], 0, sizeof(T_APP_LINK));
;;;177            }
;;;178            break;
;;;179    
;;;180        case GAP_CONN_STATE_CONNECTED:
;;;181            {
;;;182            	//T_GAP_CAUSE cause;
;;;183                le_get_conn_addr(conn_id, app_link_table[conn_id].bd_addr,
;;;184                                 &app_link_table[conn_id].bd_type);
;;;185    #if 0 //by vsop			
;;;186               data_uart_print("#condev#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;187    						conn_id,
;;;188    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;189    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;190    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;191    #else
;;;192          sprintf(cmd_buffer,"#condev#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;193    						conn_id,
;;;194    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;195    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;196    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;197    	FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));
;;;198    #endif
;;;199            }
;;;200            break;
;;;201    
;;;202        default:
;;;203            break;
;;;204    
;;;205        }
;;;206    }
;;;207    
;;;208    /**
;;;209     * @brief    Handle msg GAP_MSG_LE_AUTHEN_STATE_CHANGE
;;;210     * @note     All the gap authentication state events are pre-handled in this function.
;;;211     *           Then the event handling function shall be called according to the new_state
;;;212     * @param[in] conn_id Connection ID
;;;213     * @param[in] new_state  New authentication state
;;;214     * @param[in] cause Use this cause when new_state is GAP_AUTHEN_STATE_COMPLETE
;;;215     * @return   void
;;;216     */
;;;217    void app_handle_authen_state_evt(uint8_t conn_id, uint8_t new_state, uint16_t cause)
;;;218    {
;;;219        APP_PRINT_INFO2("app_handle_authen_state_evt:conn_id %d, cause 0x%x", conn_id, cause);
;;;220    
;;;221        switch (new_state)
;;;222        {
;;;223        case GAP_AUTHEN_STATE_STARTED:
;;;224            {
;;;225                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
;;;226            }
;;;227            break;
;;;228    
;;;229        case GAP_AUTHEN_STATE_COMPLETE:
;;;230            {
;;;231                if (cause == GAP_SUCCESS)
;;;232                {
;;;233    #if 0 //by vsop            
;;;234    				data_uart_print("#sauth#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;235    					conn_id,
;;;236    					app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;237    					app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;238    					app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;239    #else
;;;240    			sprintf(cmd_buffer,"#sauth#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;241    					conn_id,
;;;242    					app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;243    					app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;244    					app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;245    			FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));	
;;;246    #endif
;;;247                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
;;;248    
;;;249                }
;;;250                else
;;;251                {
;;;252    #if 0 //by vsop            
;;;253                   	data_uart_print("#sauth#!%d![%02x%02x%02x%02x%02x%02x]<N>\r\n",
;;;254    						conn_id,
;;;255    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;256    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;257    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;258    #else
;;;259    					sprintf(cmd_buffer,"#sauth#!%d![%02x%02x%02x%02x%02x%02x]<N>\r\n",
;;;260    						conn_id,
;;;261    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;262    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;263    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;264    					FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));	
;;;265    #endif            
;;;266                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;267                }
;;;268            }
;;;269            break;
;;;270    
;;;271        default:
;;;272            {
;;;273                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;274            }
;;;275            break;
;;;276        }
;;;277    }
;;;278    
;;;279    /**
;;;280     * @brief    Handle msg GAP_MSG_LE_CONN_MTU_INFO
;;;281     * @note     This msg is used to inform APP that exchange mtu procedure is completed.
;;;282     * @param[in] conn_id Connection ID
;;;283     * @param[in] mtu_size  New mtu size
;;;284     * @return   void
;;;285     */
;;;286    void app_handle_conn_mtu_info_evt(uint8_t conn_id, uint16_t mtu_size)
;;;287    {
;;;288        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
;;;289        app_discov_services(conn_id, true);
;;;290    }
;;;291    
;;;292    /**
;;;293     * @brief    Handle msg GAP_MSG_LE_CONN_PARAM_UPDATE
;;;294     * @note     All the connection parameter update change  events are pre-handled in this function.
;;;295     * @param[in] conn_id Connection ID
;;;296     * @param[in] status  New update state
;;;297     * @param[in] cause Use this cause when status is GAP_CONN_PARAM_UPDATE_STATUS_FAIL
;;;298     * @return   void
;;;299     */
;;;300    void app_handle_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;301    {
;;;302        switch (status)
;;;303        {
;;;304        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;305            {
;;;306                uint16_t conn_interval;
;;;307                uint16_t conn_slave_latency;
;;;308                uint16_t conn_supervision_timeout;
;;;309    
;;;310                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;311                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
;;;312                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;313                APP_PRINT_INFO4("app_handle_conn_param_update_evt update success:conn_id %d, conn_interval 0x%x, conn_slave_latency 0x%x, conn_supervision_timeout 0x%x",
;;;314                                conn_id, conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;315            }
;;;316            break;
;;;317    
;;;318        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;319            {
;;;320                APP_PRINT_ERROR2("app_handle_conn_param_update_evt update failed: conn_id %d, cause 0x%x",
;;;321                                 conn_id, cause);
;;;322            }
;;;323            break;
;;;324    
;;;325        case GAP_CONN_PARAM_UPDATE_STATUS_PENDING:
;;;326            {
;;;327                APP_PRINT_INFO1("app_handle_conn_param_update_evt update pending: conn_id %d", conn_id);
;;;328            }
;;;329            break;
;;;330    
;;;331        default:
;;;332            break;
;;;333        }
;;;334    }
;;;335    
;;;336    /**
;;;337     * @brief    All the BT GAP MSG are pre-handled in this function.
;;;338     * @note     Then the event handling function shall be called according to the
;;;339     *           subtype of T_IO_MSG
;;;340     * @param[in] p_gap_msg Pointer to GAP msg
;;;341     * @return   void
;;;342     */
;;;343    void app_handle_gap_msg(T_IO_MSG *p_gap_msg)
;;;344    {
        0x00209e9e:    b57f        ..      PUSH     {r0-r6,lr}
        0x00209ea0:    4605        .F      MOV      r5,r0
;;;345        T_LE_GAP_MSG gap_msg;
;;;346        uint8_t conn_id;
;;;347        memcpy(&gap_msg, &p_gap_msg->u.param, sizeof(p_gap_msg->u.param));
;;;348    
;;;349        APP_PRINT_TRACE1("app_handle_gap_msg: subtype %d", p_gap_msg->subtype);
        0x00209ea2:    8843        C.      LDRH     r3,[r0,#2]
        0x00209ea4:    6844        Dh      LDR      r4,[r0,#4]
        0x00209ea6:    4950        PI      LDR      r1,[pc,#320] ; [0x209fe8] = 0x8801970
        0x00209ea8:    4835        5H      LDR      r0,[pc,#212] ; [0x209f80] = 0x21103002
        0x00209eaa:    2201        ."      MOVS     r2,#1
        0x00209eac:    3140        @1      ADDS     r1,r1,#0x40
        0x00209eae:    1c40        @.      ADDS     r0,r0,#1
        0x00209eb0:    f5fdfdd5    ....    BL       log_buffer ; 0x7a5e
;;;350        switch (p_gap_msg->subtype)
        0x00209eb4:    886b        k.      LDRH     r3,[r5,#2]
        0x00209eb6:    2000        .       MOVS     r0,#0
        0x00209eb8:    4d31        1M      LDR      r5,[pc,#196] ; [0x209f80] = 0x21103002
        0x00209eba:    2b0b        .+      CMP      r3,#0xb
        0x00209ebc:    d25c        \.      BCS      0x209f78 ; app_handle_gap_msg + 218
        0x00209ebe:    e8dff003    ....    TBB      [pc,r3]
    $d
        0x00209ec2:    06e7        ..      DCW    1767
        0x00209ec4:    22141a0c    ..."    DCD    571742732
        0x00209ec8:    4bd0c737    7..K    DCD    1271973687
        0x00209ecc:    002a        *.      DCW    42
    $t
;;;351        {
;;;352        case GAP_MSG_LE_DEV_STATE_CHANGE:
;;;353            {
;;;354                app_handle_dev_state_evt(gap_msg.msg_data.gap_dev_state_change.new_state,
        0x00209ece:    b004        ..      ADD      sp,sp,#0x10
        0x00209ed0:    4620         F      MOV      r0,r4
        0x00209ed2:    0c21        !.      LSRS     r1,r4,#16
        0x00209ed4:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00209ed8:    e7a5        ..      B        app_handle_dev_state_evt ; 0x209e26
        0x00209eda:    b004        ..      ADD      sp,sp,#0x10
        0x00209edc:    0c22        ".      LSRS     r2,r4,#16
        0x00209ede:    f3c42107    ...!    UBFX     r1,r4,#8,#8
        0x00209ee2:    b2e0        ..      UXTB     r0,r4
;;;355                                         gap_msg.msg_data.gap_dev_state_change.cause);
;;;356            }
;;;357            break;
;;;358    
;;;359        case GAP_MSG_LE_CONN_STATE_CHANGE:
;;;360            {
;;;361                app_handle_conn_state_evt(gap_msg.msg_data.gap_conn_state_change.conn_id,
        0x00209ee4:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00209ee8:    e732        2.      B        app_handle_conn_state_evt ; 0x209d50
        0x00209eea:    b004        ..      ADD      sp,sp,#0x10
        0x00209eec:    0c21        !.      LSRS     r1,r4,#16
        0x00209eee:    b2e0        ..      UXTB     r0,r4
;;;362                                          (T_GAP_CONN_STATE)gap_msg.msg_data.gap_conn_state_change.new_state,
;;;363                                          gap_msg.msg_data.gap_conn_state_change.disc_cause);
;;;364            }
;;;365            break;
;;;366    
;;;367        case GAP_MSG_LE_CONN_MTU_INFO:
;;;368            {
;;;369                app_handle_conn_mtu_info_evt(gap_msg.msg_data.gap_conn_mtu_info.conn_id,
        0x00209ef0:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00209ef4:    e71d        ..      B        app_handle_conn_mtu_info_evt ; 0x209d32
        0x00209ef6:    b004        ..      ADD      sp,sp,#0x10
        0x00209ef8:    0c22        ".      LSRS     r2,r4,#16
        0x00209efa:    f3c42107    ...!    UBFX     r1,r4,#8,#8
        0x00209efe:    b2e0        ..      UXTB     r0,r4
;;;370                                             gap_msg.msg_data.gap_conn_mtu_info.mtu_size);
;;;371            }
;;;372            break;
;;;373    
;;;374        case GAP_MSG_LE_CONN_PARAM_UPDATE:
;;;375            {
;;;376                app_handle_conn_param_update_evt(gap_msg.msg_data.gap_conn_param_update.conn_id,
        0x00209f00:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00209f04:    e692        ..      B        app_handle_conn_param_update_evt ; 0x209c2c
        0x00209f06:    b004        ..      ADD      sp,sp,#0x10
        0x00209f08:    0c22        ".      LSRS     r2,r4,#16
        0x00209f0a:    f3c42107    ...!    UBFX     r1,r4,#8,#8
        0x00209f0e:    b2e0        ..      UXTB     r0,r4
;;;377                                                 gap_msg.msg_data.gap_conn_param_update.status,
;;;378                                                 gap_msg.msg_data.gap_conn_param_update.cause);
;;;379            }
;;;380            break;
;;;381    
;;;382        case GAP_MSG_LE_AUTHEN_STATE_CHANGE:
;;;383            {
;;;384                app_handle_authen_state_evt(gap_msg.msg_data.gap_authen_state.conn_id,
        0x00209f10:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00209f14:    e638        8.      B        app_handle_authen_state_evt ; 0x209b88
        0x00209f16:    b2e0        ..      UXTB     r0,r4
;;;385                                            gap_msg.msg_data.gap_authen_state.new_state,
;;;386                                            gap_msg.msg_data.gap_authen_state.status);
;;;387            }
;;;388            break;
;;;389    
;;;390        case GAP_MSG_LE_BOND_JUST_WORK:
;;;391            {
;;;392                conn_id = gap_msg.msg_data.gap_bond_just_work_conf.conn_id;
;;;393                le_bond_just_work_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x00209f18:    2101        .!      MOVS     r1,#1
        0x00209f1a:    f001fdf2    ....    BL       le_bond_just_work_confirm ; 0x20bb02
;;;394                APP_PRINT_INFO0("GAP_MSG_LE_BOND_JUST_WORK");
        0x00209f1e:    b004        ..      ADD      sp,sp,#0x10
        0x00209f20:    4628        (F      MOV      r0,r5
        0x00209f22:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00209f26:    4930        0I      LDR      r1,[pc,#192] ; [0x209fe8] = 0x8801970
        0x00209f28:    2200        ."      MOVS     r2,#0
        0x00209f2a:    3160        `1      ADDS     r1,r1,#0x60
        0x00209f2c:    f5fdbd97    ....    B        log_buffer ; 0x7a5e
;;;395            }
;;;396            break;
;;;397    
;;;398        case GAP_MSG_LE_BOND_PASSKEY_DISPLAY:
;;;399            {
;;;400                uint32_t display_value = 0;
        0x00209f30:    b2e4        ..      UXTB     r4,r4
;;;401                conn_id = gap_msg.msg_data.gap_bond_passkey_display.conn_id;
;;;402                le_bond_get_display_key(conn_id, &display_value);
        0x00209f32:    9001        ..      STR      r0,[sp,#4]
        0x00209f34:    a901        ..      ADD      r1,sp,#4
        0x00209f36:    4620         F      MOV      r0,r4
        0x00209f38:    f642fa57    B.W.    BL       le_bond_get_display_key ; 0x4c3ea
;;;403                APP_PRINT_INFO2("GAP_MSG_LE_BOND_PASSKEY_DISPLAY: conn_id %d, passkey %d",
        0x00209f3c:    9801        ..      LDR      r0,[sp,#4]
        0x00209f3e:    492a        *I      LDR      r1,[pc,#168] ; [0x209fe8] = 0x8801970
        0x00209f40:    9000        ..      STR      r0,[sp,#0]
        0x00209f42:    4623        #F      MOV      r3,r4
        0x00209f44:    2202        ."      MOVS     r2,#2
        0x00209f46:    3180        .1      ADDS     r1,r1,#0x80
        0x00209f48:    4628        (F      MOV      r0,r5
        0x00209f4a:    f5fdfd88    ....    BL       log_buffer ; 0x7a5e
;;;404                                conn_id, display_value);
;;;405                le_bond_passkey_display_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x00209f4e:    2101        .!      MOVS     r1,#1
        0x00209f50:    4620         F      MOV      r0,r4
        0x00209f52:    f642fa8f    B...    BL       le_bond_passkey_display_confirm ; 0x4c474
        0x00209f56:    bd7f        ..      POP      {r0-r6,pc}
;;;406    #if 0 //by vsop			
;;;407                data_uart_print("GAP_MSG_LE_BOND_PASSKEY_DISPLAY: conn_id %d, passkey %d\r\n",
;;;408                                conn_id,
;;;409                                display_value);
;;;410    #endif
;;;411            }
;;;412            break;
;;;413    
;;;414        case GAP_MSG_LE_BOND_USER_CONFIRMATION:
;;;415            {
;;;416                uint32_t display_value = 0;
        0x00209f58:    b2e4        ..      UXTB     r4,r4
;;;417                conn_id = gap_msg.msg_data.gap_bond_user_conf.conn_id;
;;;418                le_bond_get_display_key(conn_id, &display_value);
        0x00209f5a:    9001        ..      STR      r0,[sp,#4]
        0x00209f5c:    a901        ..      ADD      r1,sp,#4
        0x00209f5e:    4620         F      MOV      r0,r4
        0x00209f60:    f642fa43    B.C.    BL       le_bond_get_display_key ; 0x4c3ea
;;;419                APP_PRINT_INFO2("GAP_MSG_LE_BOND_USER_CONFIRMATION: conn_id %d, passkey %d",
        0x00209f64:    9801        ..      LDR      r0,[sp,#4]
        0x00209f66:    4920         I      LDR      r1,[pc,#128] ; [0x209fe8] = 0x8801970
        0x00209f68:    9000        ..      STR      r0,[sp,#0]
        0x00209f6a:    4623        #F      MOV      r3,r4
        0x00209f6c:    2202        ."      MOVS     r2,#2
        0x00209f6e:    31bc        .1      ADDS     r1,r1,#0xbc
        0x00209f70:    4628        (F      MOV      r0,r5
        0x00209f72:    f5fdfd74    ..t.    BL       log_buffer ; 0x7a5e
        0x00209f76:    bd7f        ..      POP      {r0-r6,pc}
        0x00209f78:    e08a        ..      B        0x20a090 ; app_handle_gap_msg + 498
    $d
        0x00209f7a:    0000        ..      DCW    0
        0x00209f7c:    08801724    $...    DCD    142612260
        0x00209f80:    21103002    .0.!    DCD    554708994
        0x00209f84:    08801828    (...    DCD    142612520
        0x00209f88:    0020d3a3    .. .    DCD    2151331
        0x00209f8c:    75617323    #sau    DCD    1969320739
        0x00209f90:    21236874    th#!    DCD    555968628
        0x00209f94:    5b216425    %d![    DCD    1528914981
        0x00209f98:    78323025    %02x    DCD    2016555045
        0x00209f9c:    78323025    %02x    DCD    2016555045
        0x00209fa0:    78323025    %02x    DCD    2016555045
        0x00209fa4:    78323025    %02x    DCD    2016555045
        0x00209fa8:    78323025    %02x    DCD    2016555045
        0x00209fac:    78323025    %02x    DCD    2016555045
        0x00209fb0:    3e4e3c5d    ]<N>    DCD    1045314653
        0x00209fb4:    00000a0d    ....    DCD    2573
        0x00209fb8:    0020d170    p. .    DCD    2150768
        0x00209fbc:    75617323    #sau    DCD    1969320739
        0x00209fc0:    21236874    th#!    DCD    555968628
        0x00209fc4:    5b216425    %d![    DCD    1528914981
        0x00209fc8:    78323025    %02x    DCD    2016555045
        0x00209fcc:    78323025    %02x    DCD    2016555045
        0x00209fd0:    78323025    %02x    DCD    2016555045
        0x00209fd4:    78323025    %02x    DCD    2016555045
        0x00209fd8:    78323025    %02x    DCD    2016555045
        0x00209fdc:    78323025    %02x    DCD    2016555045
        0x00209fe0:    3e593c5d    ]<Y>    DCD    1046035549
        0x00209fe4:    00000a0d    ....    DCD    2573
        0x00209fe8:    08801970    p...    DCD    142612848
        0x00209fec:    08801c88    ....    DCD    142613640
        0x00209ff0:    6e6f6323    #con    DCD    1852793635
        0x00209ff4:    23766564    dev#    DCD    594961764
        0x00209ff8:    21642521    !%d!    DCD    560211233
        0x00209ffc:    3230255b    [%02    DCD    842016091
        0x0020a000:    32302578    x%02    DCD    842016120
        0x0020a004:    32302578    x%02    DCD    842016120
        0x0020a008:    32302578    x%02    DCD    842016120
        0x0020a00c:    32302578    x%02    DCD    842016120
        0x0020a010:    32302578    x%02    DCD    842016120
        0x0020a014:    593c5d78    x]<Y    DCD    1497128312
        0x0020a018:    000a0d3e    >...    DCD    658750
        0x0020a01c:    73696423    #dis    DCD    1936286755
        0x0020a020:    25212363    c#!%    DCD    622928739
        0x0020a024:    255b2164    d![%    DCD    626729316
        0x0020a028:    25783230    02x%    DCD    628634160
        0x0020a02c:    25783230    02x%    DCD    628634160
        0x0020a030:    25783230    02x%    DCD    628634160
        0x0020a034:    25783230    02x%    DCD    628634160
        0x0020a038:    25783230    02x%    DCD    628634160
        0x0020a03c:    5d783230    02x]    DCD    1568158256
        0x0020a040:    0d3e593c    <Y>.    DCD    222189884
        0x0020a044:    0000000a    ....    DCD    10
        0x0020a048:    08801608    ....    DCD    142611976
        0x0020a04c:    0020d374    t. .    DCD    2151284
    $t
;;;420                                conn_id, display_value);
;;;421    #if 0 //by vsop			
;;;422                data_uart_print("GAP_MSG_LE_BOND_USER_CONFIRMATION: conn_id %d, passkey %d\r\n",
;;;423                                conn_id,
;;;424                                display_value);
;;;425    #endif
;;;426                //le_bond_user_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;427            }
;;;428            break;
;;;429    
;;;430        case GAP_MSG_LE_BOND_PASSKEY_INPUT:
;;;431            {
;;;432                //uint32_t passkey = 888888;
;;;433                conn_id = gap_msg.msg_data.gap_bond_passkey_input.conn_id;
;;;434                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d", conn_id);
        0x0020a050:    49fd        .I      LDR      r1,[pc,#1012] ; [0x20a448] = 0x8801a6c
        0x0020a052:    b2e3        ..      UXTB     r3,r4
        0x0020a054:    2201        ."      MOVS     r2,#1
        0x0020a056:    4628        (F      MOV      r0,r5
        0x0020a058:    b004        ..      ADD      sp,sp,#0x10
        0x0020a05a:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0020a05e:    f5fdbcfe    ....    B        log_buffer ; 0x7a5e
        0x0020a062:    49f9        .I      LDR      r1,[pc,#996] ; [0x20a448] = 0x8801a6c
;;;435    #if 0 //by vsop			
;;;436                data_uart_print("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d\r\n", conn_id);
;;;437    #endif
;;;438                //le_bond_passkey_input_confirm(conn_id, passkey, GAP_CFM_CAUSE_ACCEPT);
;;;439            }
;;;440            break;
;;;441    
;;;442        case GAP_MSG_LE_BOND_OOB_INPUT:
;;;443            {
;;;444                uint8_t oob_data[GAP_OOB_LEN] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        0x0020a064:    9000        ..      STR      r0,[sp,#0]
        0x0020a066:    9001        ..      STR      r0,[sp,#4]
        0x0020a068:    9002        ..      STR      r0,[sp,#8]
        0x0020a06a:    b2e4        ..      UXTB     r4,r4
;;;445                conn_id = gap_msg.msg_data.gap_bond_oob_input.conn_id;
;;;446                APP_PRINT_INFO1("GAP_MSG_LE_BOND_OOB_INPUT: conn_id %d", conn_id);
        0x0020a06c:    9003        ..      STR      r0,[sp,#0xc]
        0x0020a06e:    4623        #F      MOV      r3,r4
        0x0020a070:    2201        ."      MOVS     r2,#1
        0x0020a072:    3130        01      ADDS     r1,r1,#0x30
        0x0020a074:    4628        (F      MOV      r0,r5
        0x0020a076:    f5fdfcf2    ....    BL       log_buffer ; 0x7a5e
;;;447                le_bond_set_param(GAP_PARAM_BOND_OOB_DATA, GAP_OOB_LEN, oob_data);
        0x0020a07a:    466a        jF      MOV      r2,sp
        0x0020a07c:    2110        .!      MOVS     r1,#0x10
        0x0020a07e:    f44f7004    O..p    MOV      r0,#0x210
        0x0020a082:    f642f8b4    B...    BL       le_bond_set_param ; 0x4c1ee
;;;448                le_bond_oob_input_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x0020a086:    2101        .!      MOVS     r1,#1
        0x0020a088:    4620         F      MOV      r0,r4
        0x0020a08a:    f642f994    B...    BL       le_bond_oob_input_confirm ; 0x4c3b6
        0x0020a08e:    bd7f        ..      POP      {r0-r6,pc}
;;;449            }
;;;450            break;
;;;451    
;;;452        default:
;;;453            APP_PRINT_ERROR1("app_handle_gap_msg: unknown subtype %d", p_gap_msg->subtype);
        0x0020a090:    49ed        .I      LDR      r1,[pc,#948] ; [0x20a448] = 0x8801a6c
        0x0020a092:    2201        ."      MOVS     r2,#1
        0x0020a094:    315c        \1      ADDS     r1,r1,#0x5c
        0x0020a096:    48ed        .H      LDR      r0,[pc,#948] ; [0x20a44c] = 0x21103000
;;;454            break;
        0x0020a098:    e7de        ..      B        0x20a058 ; app_handle_gap_msg + 442
    app_handle_io_msg
;;; ..\..\..\src\sample\ble_central\central_app.c (69)
        0x0020a09a:    b503        ..      PUSH     {r0,r1,lr}
        0x0020a09c:    b081        ..      SUB      sp,sp,#4
        0x0020a09e:    f8bd0004    ....    LDRH     r0,[sp,#4]
        0x0020a0a2:    b160        `.      CBZ      r0,0x20a0be ; app_handle_io_msg + 36
;;;70         uint16_t msg_type = io_msg.type;
;;;71         uint8_t rx_char;
;;;72     
;;;73         switch (msg_type)
        0x0020a0a4:    2803        .(      CMP      r0,#3
        0x0020a0a6:    d109        ..      BNE      0x20a0bc ; app_handle_io_msg + 34
;;;74         {
;;;75         case IO_MSG_TYPE_BT_STATUS:
;;;76             {
;;;77                 app_handle_gap_msg(&io_msg);
;;;78             }
;;;79             break;
;;;80         case IO_MSG_TYPE_UART:
;;;81             /* We handle user command informations from Data UART in this branch. */
;;;82             rx_char = (uint8_t)io_msg.subtype;
        0x0020a0a8:    f8bd0006    ....    LDRH     r0,[sp,#6]
        0x0020a0ac:    f88d0000    ....    STRB     r0,[sp,#0]
;;;83             user_cmd_collect(&user_cmd_if, &rx_char, sizeof(rx_char), user_cmd_table);
        0x0020a0b0:    4be7        .K      LDR      r3,[pc,#924] ; [0x20a450] = 0x21c8a0
        0x0020a0b2:    2201        ."      MOVS     r2,#1
        0x0020a0b4:    4669        iF      MOV      r1,sp
        0x0020a0b6:    48e7        .H      LDR      r0,[pc,#924] ; [0x20a454] = 0x20cfcc
        0x0020a0b8:    f000ff6d    ..m.    BL       user_cmd_collect ; 0x20af96
;;;84             break;
;;;85         default:
;;;86             break;
;;;87         }
;;;88     }
        0x0020a0bc:    bd0e        ..      POP      {r1-r3,pc}
        0x0020a0be:    a801        ..      ADD      r0,sp,#4
        0x0020a0c0:    f7fffeed    ....    BL       app_handle_gap_msg ; 0x209e9e
        0x0020a0c4:    bd0e        ..      POP      {r1-r3,pc}
    filter_scan_info_by_name
;;;89     
;;;90     /**
;;;91      * @brief    Handle msg GAP_MSG_LE_DEV_STATE_CHANGE
;;;92      * @note     All the gap device state events are pre-handled in this function.
;;;93      *           Then the event handling function shall be called according to the new_state
;;;94      * @param[in] new_state  New gap device state
;;;95      * @param[in] cause GAP device state change cause
;;;96      * @return   void
;;;97      */
;;;98     void app_handle_dev_state_evt(T_GAP_DEV_STATE new_state, uint16_t cause)
;;;99     {
;;;100        APP_PRINT_INFO3("app_handle_dev_state_evt: init state  %d, scan state %d, cause 0x%x",
;;;101                        new_state.gap_init_state,
;;;102                        new_state.gap_scan_state, cause);
;;;103        if (gap_dev_state.gap_init_state != new_state.gap_init_state)
;;;104        {
;;;105            if (new_state.gap_init_state == GAP_INIT_STATE_STACK_READY)
;;;106            {
;;;107                uint8_t bt_addr[6];
;;;108                APP_PRINT_INFO0("GAP stack ready");
;;;109                /*stack ready*/
;;;110                gap_get_param(GAP_PARAM_BD_ADDR, bt_addr);
;;;111            }
;;;112        }
;;;113    
;;;114        if (gap_dev_state.gap_scan_state != new_state.gap_scan_state)
;;;115        {
;;;116            if (new_state.gap_scan_state == GAP_SCAN_STATE_IDLE)
;;;117            {
;;;118                APP_PRINT_INFO0("GAP scan stop");
;;;119                //data_uart_print("GAP scan stop\r\n"); 	//by vsop
;;;120            }
;;;121            else if (new_state.gap_scan_state == GAP_SCAN_STATE_SCANNING)
;;;122            {
;;;123                APP_PRINT_INFO0("GAP scan start");
;;;124                //data_uart_print("GAP scan start\r\n");	//by vsop
;;;125            }
;;;126        }
;;;127    
;;;128        gap_dev_state = new_state;
;;;129    }
;;;130    
;;;131    /**
;;;132     * @brief    Handle msg GAP_MSG_LE_CONN_STATE_CHANGE
;;;133     * @note     All the gap conn state events are pre-handled in this function.
;;;134     *           Then the event handling function shall be called according to the new_state
;;;135     * @param[in] conn_id Connection ID
;;;136     * @param[in] new_state  New gap connection state
;;;137     * @param[in] disc_cause Use this cause when new_state is GAP_CONN_STATE_DISCONNECTED
;;;138     * @return   void
;;;139     */
;;;140    void app_handle_conn_state_evt(uint8_t conn_id, T_GAP_CONN_STATE new_state, uint16_t disc_cause)
;;;141    {
;;;142        if (conn_id >= APP_MAX_LINKS)
;;;143        {
;;;144            return;
;;;145        }
;;;146    
;;;147        APP_PRINT_INFO4("app_handle_conn_state_evt: conn_id %d, conn_state(%d -> %d), disc_cause 0x%x",
;;;148                        conn_id, app_link_table[conn_id].conn_state, new_state, disc_cause);
;;;149    
;;;150        app_link_table[conn_id].conn_state = new_state;
;;;151        switch (new_state)
;;;152        {
;;;153        case GAP_CONN_STATE_DISCONNECTED:
;;;154            {
;;;155                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
;;;156                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
;;;157                {
;;;158                    APP_PRINT_ERROR2("app_handle_conn_state_evt: connection lost, conn_id %d, cause 0x%x", conn_id,
;;;159                                     disc_cause);
;;;160                }
;;;161    #if 0 //by vsop	
;;;162               data_uart_print("#disc#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;163    						conn_id,
;;;164    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;165    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;166    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;167    #else
;;;168    			sprintf(cmd_buffer,"#disc#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;169    						conn_id,
;;;170    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;171    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;172    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;173    				FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));
;;;174    
;;;175    #endif
;;;176                memset(&app_link_table[conn_id], 0, sizeof(T_APP_LINK));
;;;177            }
;;;178            break;
;;;179    
;;;180        case GAP_CONN_STATE_CONNECTED:
;;;181            {
;;;182            	//T_GAP_CAUSE cause;
;;;183                le_get_conn_addr(conn_id, app_link_table[conn_id].bd_addr,
;;;184                                 &app_link_table[conn_id].bd_type);
;;;185    #if 0 //by vsop			
;;;186               data_uart_print("#condev#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;187    						conn_id,
;;;188    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;189    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;190    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;191    #else
;;;192          sprintf(cmd_buffer,"#condev#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;193    						conn_id,
;;;194    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;195    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;196    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;197    	FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));
;;;198    #endif
;;;199            }
;;;200            break;
;;;201    
;;;202        default:
;;;203            break;
;;;204    
;;;205        }
;;;206    }
;;;207    
;;;208    /**
;;;209     * @brief    Handle msg GAP_MSG_LE_AUTHEN_STATE_CHANGE
;;;210     * @note     All the gap authentication state events are pre-handled in this function.
;;;211     *           Then the event handling function shall be called according to the new_state
;;;212     * @param[in] conn_id Connection ID
;;;213     * @param[in] new_state  New authentication state
;;;214     * @param[in] cause Use this cause when new_state is GAP_AUTHEN_STATE_COMPLETE
;;;215     * @return   void
;;;216     */
;;;217    void app_handle_authen_state_evt(uint8_t conn_id, uint8_t new_state, uint16_t cause)
;;;218    {
;;;219        APP_PRINT_INFO2("app_handle_authen_state_evt:conn_id %d, cause 0x%x", conn_id, cause);
;;;220    
;;;221        switch (new_state)
;;;222        {
;;;223        case GAP_AUTHEN_STATE_STARTED:
;;;224            {
;;;225                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
;;;226            }
;;;227            break;
;;;228    
;;;229        case GAP_AUTHEN_STATE_COMPLETE:
;;;230            {
;;;231                if (cause == GAP_SUCCESS)
;;;232                {
;;;233    #if 0 //by vsop            
;;;234    				data_uart_print("#sauth#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;235    					conn_id,
;;;236    					app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;237    					app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;238    					app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;239    #else
;;;240    			sprintf(cmd_buffer,"#sauth#!%d![%02x%02x%02x%02x%02x%02x]<Y>\r\n",
;;;241    					conn_id,
;;;242    					app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;243    					app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;244    					app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;245    			FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));	
;;;246    #endif
;;;247                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
;;;248    
;;;249                }
;;;250                else
;;;251                {
;;;252    #if 0 //by vsop            
;;;253                   	data_uart_print("#sauth#!%d![%02x%02x%02x%02x%02x%02x]<N>\r\n",
;;;254    						conn_id,
;;;255    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;256    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;257    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;258    #else
;;;259    					sprintf(cmd_buffer,"#sauth#!%d![%02x%02x%02x%02x%02x%02x]<N>\r\n",
;;;260    						conn_id,
;;;261    						app_link_table[conn_id].bd_addr[5], app_link_table[conn_id].bd_addr[4],
;;;262    						app_link_table[conn_id].bd_addr[3], app_link_table[conn_id].bd_addr[2],
;;;263    						app_link_table[conn_id].bd_addr[1], app_link_table[conn_id].bd_addr[0]);
;;;264    					FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));	
;;;265    #endif            
;;;266                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;267                }
;;;268            }
;;;269            break;
;;;270    
;;;271        default:
;;;272            {
;;;273                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;274            }
;;;275            break;
;;;276        }
;;;277    }
;;;278    
;;;279    /**
;;;280     * @brief    Handle msg GAP_MSG_LE_CONN_MTU_INFO
;;;281     * @note     This msg is used to inform APP that exchange mtu procedure is completed.
;;;282     * @param[in] conn_id Connection ID
;;;283     * @param[in] mtu_size  New mtu size
;;;284     * @return   void
;;;285     */
;;;286    void app_handle_conn_mtu_info_evt(uint8_t conn_id, uint16_t mtu_size)
;;;287    {
;;;288        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
;;;289        app_discov_services(conn_id, true);
;;;290    }
;;;291    
;;;292    /**
;;;293     * @brief    Handle msg GAP_MSG_LE_CONN_PARAM_UPDATE
;;;294     * @note     All the connection parameter update change  events are pre-handled in this function.
;;;295     * @param[in] conn_id Connection ID
;;;296     * @param[in] status  New update state
;;;297     * @param[in] cause Use this cause when status is GAP_CONN_PARAM_UPDATE_STATUS_FAIL
;;;298     * @return   void
;;;299     */
;;;300    void app_handle_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;301    {
;;;302        switch (status)
;;;303        {
;;;304        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;305            {
;;;306                uint16_t conn_interval;
;;;307                uint16_t conn_slave_latency;
;;;308                uint16_t conn_supervision_timeout;
;;;309    
;;;310                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;311                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
;;;312                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;313                APP_PRINT_INFO4("app_handle_conn_param_update_evt update success:conn_id %d, conn_interval 0x%x, conn_slave_latency 0x%x, conn_supervision_timeout 0x%x",
;;;314                                conn_id, conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;315            }
;;;316            break;
;;;317    
;;;318        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;319            {
;;;320                APP_PRINT_ERROR2("app_handle_conn_param_update_evt update failed: conn_id %d, cause 0x%x",
;;;321                                 conn_id, cause);
;;;322            }
;;;323            break;
;;;324    
;;;325        case GAP_CONN_PARAM_UPDATE_STATUS_PENDING:
;;;326            {
;;;327                APP_PRINT_INFO1("app_handle_conn_param_update_evt update pending: conn_id %d", conn_id);
;;;328            }
;;;329            break;
;;;330    
;;;331        default:
;;;332            break;
;;;333        }
;;;334    }
;;;335    
;;;336    /**
;;;337     * @brief    All the BT GAP MSG are pre-handled in this function.
;;;338     * @note     Then the event handling function shall be called according to the
;;;339     *           subtype of T_IO_MSG
;;;340     * @param[in] p_gap_msg Pointer to GAP msg
;;;341     * @return   void
;;;342     */
;;;343    void app_handle_gap_msg(T_IO_MSG *p_gap_msg)
;;;344    {
;;;345        T_LE_GAP_MSG gap_msg;
;;;346        uint8_t conn_id;
;;;347        memcpy(&gap_msg, &p_gap_msg->u.param, sizeof(p_gap_msg->u.param));
;;;348    
;;;349        APP_PRINT_TRACE1("app_handle_gap_msg: subtype %d", p_gap_msg->subtype);
;;;350        switch (p_gap_msg->subtype)
;;;351        {
;;;352        case GAP_MSG_LE_DEV_STATE_CHANGE:
;;;353            {
;;;354                app_handle_dev_state_evt(gap_msg.msg_data.gap_dev_state_change.new_state,
;;;355                                         gap_msg.msg_data.gap_dev_state_change.cause);
;;;356            }
;;;357            break;
;;;358    
;;;359        case GAP_MSG_LE_CONN_STATE_CHANGE:
;;;360            {
;;;361                app_handle_conn_state_evt(gap_msg.msg_data.gap_conn_state_change.conn_id,
;;;362                                          (T_GAP_CONN_STATE)gap_msg.msg_data.gap_conn_state_change.new_state,
;;;363                                          gap_msg.msg_data.gap_conn_state_change.disc_cause);
;;;364            }
;;;365            break;
;;;366    
;;;367        case GAP_MSG_LE_CONN_MTU_INFO:
;;;368            {
;;;369                app_handle_conn_mtu_info_evt(gap_msg.msg_data.gap_conn_mtu_info.conn_id,
;;;370                                             gap_msg.msg_data.gap_conn_mtu_info.mtu_size);
;;;371            }
;;;372            break;
;;;373    
;;;374        case GAP_MSG_LE_CONN_PARAM_UPDATE:
;;;375            {
;;;376                app_handle_conn_param_update_evt(gap_msg.msg_data.gap_conn_param_update.conn_id,
;;;377                                                 gap_msg.msg_data.gap_conn_param_update.status,
;;;378                                                 gap_msg.msg_data.gap_conn_param_update.cause);
;;;379            }
;;;380            break;
;;;381    
;;;382        case GAP_MSG_LE_AUTHEN_STATE_CHANGE:
;;;383            {
;;;384                app_handle_authen_state_evt(gap_msg.msg_data.gap_authen_state.conn_id,
;;;385                                            gap_msg.msg_data.gap_authen_state.new_state,
;;;386                                            gap_msg.msg_data.gap_authen_state.status);
;;;387            }
;;;388            break;
;;;389    
;;;390        case GAP_MSG_LE_BOND_JUST_WORK:
;;;391            {
;;;392                conn_id = gap_msg.msg_data.gap_bond_just_work_conf.conn_id;
;;;393                le_bond_just_work_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;394                APP_PRINT_INFO0("GAP_MSG_LE_BOND_JUST_WORK");
;;;395            }
;;;396            break;
;;;397    
;;;398        case GAP_MSG_LE_BOND_PASSKEY_DISPLAY:
;;;399            {
;;;400                uint32_t display_value = 0;
;;;401                conn_id = gap_msg.msg_data.gap_bond_passkey_display.conn_id;
;;;402                le_bond_get_display_key(conn_id, &display_value);
;;;403                APP_PRINT_INFO2("GAP_MSG_LE_BOND_PASSKEY_DISPLAY: conn_id %d, passkey %d",
;;;404                                conn_id, display_value);
;;;405                le_bond_passkey_display_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;406    #if 0 //by vsop			
;;;407                data_uart_print("GAP_MSG_LE_BOND_PASSKEY_DISPLAY: conn_id %d, passkey %d\r\n",
;;;408                                conn_id,
;;;409                                display_value);
;;;410    #endif
;;;411            }
;;;412            break;
;;;413    
;;;414        case GAP_MSG_LE_BOND_USER_CONFIRMATION:
;;;415            {
;;;416                uint32_t display_value = 0;
;;;417                conn_id = gap_msg.msg_data.gap_bond_user_conf.conn_id;
;;;418                le_bond_get_display_key(conn_id, &display_value);
;;;419                APP_PRINT_INFO2("GAP_MSG_LE_BOND_USER_CONFIRMATION: conn_id %d, passkey %d",
;;;420                                conn_id, display_value);
;;;421    #if 0 //by vsop			
;;;422                data_uart_print("GAP_MSG_LE_BOND_USER_CONFIRMATION: conn_id %d, passkey %d\r\n",
;;;423                                conn_id,
;;;424                                display_value);
;;;425    #endif
;;;426                //le_bond_user_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;427            }
;;;428            break;
;;;429    
;;;430        case GAP_MSG_LE_BOND_PASSKEY_INPUT:
;;;431            {
;;;432                //uint32_t passkey = 888888;
;;;433                conn_id = gap_msg.msg_data.gap_bond_passkey_input.conn_id;
;;;434                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d", conn_id);
;;;435    #if 0 //by vsop			
;;;436                data_uart_print("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d\r\n", conn_id);
;;;437    #endif
;;;438                //le_bond_passkey_input_confirm(conn_id, passkey, GAP_CFM_CAUSE_ACCEPT);
;;;439            }
;;;440            break;
;;;441    
;;;442        case GAP_MSG_LE_BOND_OOB_INPUT:
;;;443            {
;;;444                uint8_t oob_data[GAP_OOB_LEN] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
;;;445                conn_id = gap_msg.msg_data.gap_bond_oob_input.conn_id;
;;;446                APP_PRINT_INFO1("GAP_MSG_LE_BOND_OOB_INPUT: conn_id %d", conn_id);
;;;447                le_bond_set_param(GAP_PARAM_BOND_OOB_DATA, GAP_OOB_LEN, oob_data);
;;;448                le_bond_oob_input_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;449            }
;;;450            break;
;;;451    
;;;452        default:
;;;453            APP_PRINT_ERROR1("app_handle_gap_msg: unknown subtype %d", p_gap_msg->subtype);
;;;454            break;
;;;455        }
;;;456    }
;;;457    
;;;458    bool filter_scan_info_by_name(uint8_t *name, T_LE_SCAN_INFO *scan_info)
;;;459    {
        0x0020a0c6:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0020a0ca:    4680        .F      MOV      r8,r0
        0x0020a0cc:    b088        ..      SUB      sp,sp,#0x20
        0x0020a0ce:    460e        .F      MOV      r6,r1
        0x0020a0d0:    2000        .       MOVS     r0,#0
        0x0020a0d2:    e01f        ..      B        0x20a114 ; filter_scan_info_by_name + 78
;;;460        uint8_t buffer[32];
;;;461        uint8_t pos = 0;
;;;462    
;;;463        while (pos < scan_info->data_len)
;;;464        {
;;;465            /* Length of the AD structure. */
;;;466            uint8_t length = scan_info->data[pos++];
        0x0020a0d4:    1831        1.      ADDS     r1,r6,r0
        0x0020a0d6:    1c40        @.      ADDS     r0,r0,#1
        0x0020a0d8:    7a8c        .z      LDRB     r4,[r1,#0xa]
        0x0020a0da:    b2c5        ..      UXTB     r5,r0
;;;467            uint8_t type;
;;;468    
;;;469            if ((length > 0x01) && ((pos + length) <= 31))
        0x0020a0dc:    2c01        .,      CMP      r4,#1
        0x0020a0de:    d917        ..      BLS      0x20a110 ; filter_scan_info_by_name + 74
        0x0020a0e0:    1928        (.      ADDS     r0,r5,r4
        0x0020a0e2:    281f        .(      CMP      r0,#0x1f
        0x0020a0e4:    d814        ..      BHI      0x20a110 ; filter_scan_info_by_name + 74
;;;470            {
;;;471                /* Copy the AD Data to buffer. */
;;;472                memcpy(buffer, scan_info->data + pos + 1, length - 1);
        0x0020a0e6:    1977        w.      ADDS     r7,r6,r5
        0x0020a0e8:    f107010b    ....    ADD      r1,r7,#0xb
        0x0020a0ec:    1e62        b.      SUBS     r2,r4,#1
        0x0020a0ee:    4668        hF      MOV      r0,sp
        0x0020a0f0:    f64ffed3    O...    BL       __aeabi_memcpy ; 0x59e9a
;;;473                /* AD Type, one octet. */
;;;474                type = scan_info->data[pos];
        0x0020a0f4:    7ab8        .z      LDRB     r0,[r7,#0xa]
;;;475                switch (type)
        0x0020a0f6:    2809        .(      CMP      r0,#9
        0x0020a0f8:    d10a        ..      BNE      0x20a110 ; filter_scan_info_by_name + 74
;;;476                {
;;;477    	            case GAP_ADTYPE_LOCAL_NAME_COMPLETE:
;;;478    	                {
;;;479    	                    buffer[length - 1] = '\0';
        0x0020a0fa:    eb0d0104    ....    ADD      r1,sp,r4
        0x0020a0fe:    2000        .       MOVS     r0,#0
        0x0020a100:    f8010c01    ....    STRB     r0,[r1,#-1]
;;;480    	                    //data_uart_print("GAP_ADTYPE_LOCAL_NAME_XXX: %s\r\n", buffer);
;;;481    						if(strncmp((char *)buffer,(char *)name,5)==0)return true;
        0x0020a104:    2205        ."      MOVS     r2,#5
        0x0020a106:    4641        AF      MOV      r1,r8
        0x0020a108:    4668        hF      MOV      r0,sp
        0x0020a10a:    f012fac9    ....    BL       strncmp ; 0x21c6a0
        0x0020a10e:    b138        8.      CBZ      r0,0x20a120 ; filter_scan_info_by_name + 90
;;;482    	                }
;;;483    	                break;
;;;484    	            default:
;;;485    	                break;
;;;486    	            }
;;;487            }
;;;488            pos += length;
        0x0020a110:    1928        (.      ADDS     r0,r5,r4
        0x0020a112:    b2c0        ..      UXTB     r0,r0
        0x0020a114:    7a71        qz      LDRB     r1,[r6,#9]
        0x0020a116:    4281        .B      CMP      r1,r0
        0x0020a118:    d8dc        ..      BHI      0x20a0d4 ; filter_scan_info_by_name + 14
;;;489        }
;;;490    	return false;
        0x0020a11a:    2000        .       MOVS     r0,#0
;;;491    }
        0x0020a11c:    b008        ..      ADD      sp,sp,#0x20
        0x0020a11e:    e680        ..      B        0x209e22 ; app_handle_conn_state_evt + 210
        0x0020a120:    2001        .       MOVS     r0,#1
        0x0020a122:    e7fb        ..      B        0x20a11c ; filter_scan_info_by_name + 86
    app_parse_scan_info
;;;492    
;;;493    
;;;494    /** @} */ /* End of group CENTRAL_GAP_MSG */
;;;495    void app_parse_scan_info(T_LE_SCAN_INFO *scan_info)
;;;496    {
        0x0020a124:    e92d47f0    -..G    PUSH     {r4-r10,lr}
        0x0020a128:    4680        .F      MOV      r8,r0
        0x0020a12a:    b08a        ..      SUB      sp,sp,#0x28
        0x0020a12c:    2500        .%      MOVS     r5,#0
        0x0020a12e:    a0ca        ..      ADR      r0,{pc}+0x32a ; 0x20a458
        0x0020a130:    f000fd76    ..v.    BL       data_uart_print ; 0x20ac20
;;;497        uint8_t buffer[32];
        0x0020a134:    f10d0904    ....    ADD      r9,sp,#4
        0x0020a138:    f8dfa33c    ..<.    LDR      r10,[pc,#828] ; [0x20a478] = 0x21500000
;;;498        uint8_t pos = 0;
;;;499    	data_uart_print("+++++++++++++++++++++++++++++\r\n");
;;;500    
;;;501        while (pos < scan_info->data_len)
        0x0020a13c:    e0a5        ..      B        0x20a28a ; app_parse_scan_info + 358
;;;502        {
;;;503            /* Length of the AD structure. */
;;;504            uint8_t length = scan_info->data[pos++];
        0x0020a13e:    eb080005    ....    ADD      r0,r8,r5
        0x0020a142:    1c6d        m.      ADDS     r5,r5,#1
        0x0020a144:    7a84        .z      LDRB     r4,[r0,#0xa]
        0x0020a146:    b2ee        ..      UXTB     r6,r5
;;;505            uint8_t type;
;;;506    
;;;507            if ((length > 0x01) && ((pos + length) <= 31))
        0x0020a148:    2c01        .,      CMP      r4,#1
        0x0020a14a:    d93e        >.      BLS      0x20a1ca ; app_parse_scan_info + 166
        0x0020a14c:    1930        0.      ADDS     r0,r6,r4
        0x0020a14e:    281f        .(      CMP      r0,#0x1f
        0x0020a150:    d83b        ;.      BHI      0x20a1ca ; app_parse_scan_info + 166
;;;508            {
;;;509                /* Copy the AD Data to buffer. */
;;;510                memcpy(buffer, scan_info->data + pos + 1, length - 1);
        0x0020a152:    eb080706    ....    ADD      r7,r8,r6
        0x0020a156:    f107010b    ....    ADD      r1,r7,#0xb
        0x0020a15a:    1e62        b.      SUBS     r2,r4,#1
        0x0020a15c:    a801        ..      ADD      r0,sp,#4
        0x0020a15e:    f64ffe9c    O...    BL       __aeabi_memcpy ; 0x59e9a
;;;511                /* AD Type, one octet. */
;;;512                type = scan_info->data[pos];
        0x0020a162:    7abd        .z      LDRB     r5,[r7,#0xa]
;;;513    
;;;514                data_uart_print("app_parse_scan_info: AD Structure Info: AD type 0x%x, AD Data Length %d\r\n", type,
        0x0020a164:    1e62        b.      SUBS     r2,r4,#1
        0x0020a166:    4629        )F      MOV      r1,r5
        0x0020a168:    48c4        .H      LDR      r0,[pc,#784] ; [0x20a47c] = 0x20ced8
        0x0020a16a:    f000fd59    ..Y.    BL       data_uart_print ; 0x20ac20
;;;515                                 length - 1);
;;;516    
;;;517                switch (type)
        0x0020a16e:    2d09        .-      CMP      r5,#9
        0x0020a170:    d042        B.      BEQ      0x20a1f8 ; app_parse_scan_info + 212
        0x0020a172:    dc07        ..      BGT      0x20a184 ; app_parse_scan_info + 96
        0x0020a174:    d216        ..      BCS      0x20a1a4 ; app_parse_scan_info + 128
        0x0020a176:    e8dff005    ....    TBB      [pc,r5]
    $d
        0x0020a17a:    1815        ..      DCW    6165
        0x0020a17c:    29291b1b    ..))    DCD    690559771
        0x0020a180:    003f3636    66?.    DCD    4142646
    $t
        0x0020a184:    2d15        .-      CMP      r5,#0x15
        0x0020a186:    d02e        ..      BEQ      0x20a1e6 ; app_parse_scan_info + 194
        0x0020a188:    dc06        ..      BGT      0x20a198 ; app_parse_scan_info + 116
        0x0020a18a:    2d0a        .-      CMP      r5,#0xa
        0x0020a18c:    d03c        <.      BEQ      0x20a208 ; app_parse_scan_info + 228
        0x0020a18e:    2d12        .-      CMP      r5,#0x12
        0x0020a190:    d03d        =.      BEQ      0x20a20e ; app_parse_scan_info + 234
        0x0020a192:    2d14        .-      CMP      r5,#0x14
        0x0020a194:    d106        ..      BNE      0x20a1a4 ; app_parse_scan_info + 128
        0x0020a196:    e00b        ..      B        0x20a1b0 ; app_parse_scan_info + 140
        0x0020a198:    2d16        .-      CMP      r5,#0x16
        0x0020a19a:    d045        E.      BEQ      0x20a228 ; app_parse_scan_info + 260
        0x0020a19c:    2d19        .-      CMP      r5,#0x19
        0x0020a19e:    d051        Q.      BEQ      0x20a244 ; app_parse_scan_info + 288
        0x0020a1a0:    2dff        .-      CMP      r5,#0xff
        0x0020a1a2:    d055        U.      BEQ      0x20a250 ; app_parse_scan_info + 300
        0x0020a1a4:    2500        .%      MOVS     r5,#0
        0x0020a1a6:    1e67        g.      SUBS     r7,r4,#1
        0x0020a1a8:    e06b        k.      B        0x20a282 ; app_parse_scan_info + 350
;;;518                {
;;;519                case GAP_ADTYPE_FLAGS:
;;;520                    {
;;;521                        /* (flags & 0x01) -- LE Limited Discoverable Mode */
;;;522                        /* (flags & 0x02) -- LE General Discoverable Mode */
;;;523                        /* (flags & 0x04) -- BR/EDR Not Supported */
;;;524                        /* (flags & 0x08) -- Simultaneous LE and BR/EDR to Same Device Capable (Controller) */
;;;525                        /* (flags & 0x10) -- Simultaneous LE and BR/EDR to Same Device Capable (Host) */
;;;526                        uint8_t flags = scan_info->data[pos + 1];
        0x0020a1aa:    7af9        .z      LDRB     r1,[r7,#0xb]
;;;527                        data_uart_print("GAP_ADTYPE_FLAGS: 0x%x\r\n", flags);
        0x0020a1ac:    a0b4        ..      ADR      r0,{pc}+0x2d4 ; 0x20a480
;;;528                    }
;;;529                    break;
        0x0020a1ae:    e04c        L.      B        0x20a24a ; app_parse_scan_info + 294
        0x0020a1b0:    1e60        `.      SUBS     r0,r4,#1
;;;530    
;;;531                case GAP_ADTYPE_16BIT_MORE:
;;;532                case GAP_ADTYPE_16BIT_COMPLETE:
;;;533                case GAP_ADTYPE_SERVICES_LIST_16BIT:
;;;534                    {
;;;535                        uint16_t *p_uuid = (uint16_t *)(buffer);
        0x0020a1b2:    af01        ..      ADD      r7,sp,#4
;;;536                        uint8_t i = length - 1;
        0x0020a1b4:    b2c5        ..      UXTB     r5,r0
;;;537    
;;;538                        while (i >= 2)
        0x0020a1b6:    e006        ..      B        0x20a1c6 ; app_parse_scan_info + 162
        0x0020a1b8:    f8371b02    7...    LDRH     r1,[r7],#2
        0x0020a1bc:    a0b7        ..      ADR      r0,{pc}+0x2e0 ; 0x20a49c
        0x0020a1be:    f000fd2f    ../.    BL       data_uart_print ; 0x20ac20
        0x0020a1c2:    1ead        ..      SUBS     r5,r5,#2
        0x0020a1c4:    b2ed        ..      UXTB     r5,r5
        0x0020a1c6:    2d02        .-      CMP      r5,#2
        0x0020a1c8:    d2f6        ..      BCS      0x20a1b8 ; app_parse_scan_info + 148
        0x0020a1ca:    e05c        \.      B        0x20a286 ; app_parse_scan_info + 354
        0x0020a1cc:    1e60        `.      SUBS     r0,r4,#1
;;;539                        {
;;;540                            data_uart_print("GAP_ADTYPE_16BIT_XXX: 0x%x\r\n", *p_uuid++);
;;;541                            i -= 2;
;;;542                        }
;;;543                    }
;;;544                    break;
;;;545    
;;;546                case GAP_ADTYPE_32BIT_MORE:
;;;547                case GAP_ADTYPE_32BIT_COMPLETE:
;;;548                    {
;;;549                        uint32_t *p_uuid = (uint32_t *)(buffer);
        0x0020a1ce:    af01        ..      ADD      r7,sp,#4
;;;550                        uint8_t    i     = length - 1;
        0x0020a1d0:    b2c5        ..      UXTB     r5,r0
;;;551    
;;;552                        while (i >= 4)
        0x0020a1d2:    e005        ..      B        0x20a1e0 ; app_parse_scan_info + 188
        0x0020a1d4:    cf02        ..      LDM      r7!,{r1}
        0x0020a1d6:    a0b9        ..      ADR      r0,{pc}+0x2e6 ; 0x20a4bc
        0x0020a1d8:    f000fd22    ..".    BL       data_uart_print ; 0x20ac20
        0x0020a1dc:    1f2d        -.      SUBS     r5,r5,#4
        0x0020a1de:    b2ed        ..      UXTB     r5,r5
        0x0020a1e0:    2d04        .-      CMP      r5,#4
        0x0020a1e2:    d2f7        ..      BCS      0x20a1d4 ; app_parse_scan_info + 176
        0x0020a1e4:    e04f        O.      B        0x20a286 ; app_parse_scan_info + 354
;;;553                        {
;;;554                            data_uart_print("GAP_ADTYPE_32BIT_XXX: 0x%x\r\n", *p_uuid++);
;;;555                            i -= 4;
;;;556                        }
;;;557                    }
;;;558                    break;
;;;559    
;;;560                case GAP_ADTYPE_128BIT_MORE:
;;;561                case GAP_ADTYPE_128BIT_COMPLETE:
;;;562                case GAP_ADTYPE_SERVICES_LIST_128BIT:
;;;563                    {
;;;564                        uint32_t *p_uuid = (uint32_t *)(buffer);
;;;565                        data_uart_print("GAP_ADTYPE_128BIT_XXX: 0x%8.8x%8.8x%8.8x%8.8x\r\n",
        0x0020a1e6:    9801        ..      LDR      r0,[sp,#4]
        0x0020a1e8:    9000        ..      STR      r0,[sp,#0]
        0x0020a1ea:    e9dd2103    ...!    LDRD     r2,r1,[sp,#0xc]
        0x0020a1ee:    a0bb        ..      ADR      r0,{pc}+0x2ee ; 0x20a4dc
        0x0020a1f0:    9b02        ..      LDR      r3,[sp,#8]
        0x0020a1f2:    f000fd15    ....    BL       data_uart_print ; 0x20ac20
;;;566                                        p_uuid[3], p_uuid[2], p_uuid[1], p_uuid[0]);
;;;567                    }
;;;568                    break;
        0x0020a1f6:    e046        F.      B        0x20a286 ; app_parse_scan_info + 354
;;;569    
;;;570                case GAP_ADTYPE_LOCAL_NAME_SHORT:
;;;571                case GAP_ADTYPE_LOCAL_NAME_COMPLETE:
;;;572                    {
;;;573                        buffer[length - 1] = '\0';
        0x0020a1f8:    eb090004    ....    ADD      r0,r9,r4
        0x0020a1fc:    2100        .!      MOVS     r1,#0
        0x0020a1fe:    f8001c01    ....    STRB     r1,[r0,#-1]
;;;574                        data_uart_print("GAP_ADTYPE_LOCAL_NAME_XXX: %s\r\n", buffer);
        0x0020a202:    a901        ..      ADD      r1,sp,#4
        0x0020a204:    a0c1        ..      ADR      r0,{pc}+0x308 ; 0x20a50c
;;;575                    }
;;;576                    break;
        0x0020a206:    e020         .      B        0x20a24a ; app_parse_scan_info + 294
;;;577    
;;;578                case GAP_ADTYPE_POWER_LEVEL:
;;;579                    {
;;;580                        data_uart_print("GAP_ADTYPE_POWER_LEVEL: 0x%x\r\n", scan_info->data[pos + 1]);
        0x0020a208:    7af9        .z      LDRB     r1,[r7,#0xb]
        0x0020a20a:    a0c8        ..      ADR      r0,{pc}+0x322 ; 0x20a52c
;;;581                    }
;;;582                    break;
        0x0020a20c:    e01d        ..      B        0x20a24a ; app_parse_scan_info + 294
;;;583    
;;;584                case GAP_ADTYPE_SLAVE_CONN_INTERVAL_RANGE:
;;;585                    {
;;;586                        uint16_t *p_min = (uint16_t *)(buffer);
;;;587                        uint16_t *p_max = p_min + 1;
;;;588                        APP_PRINT_INFO2("GAP_ADTYPE_SLAVE_CONN_INTERVAL_RANGE: 0x%x - 0x%x", *p_min,
        0x0020a20e:    f8bd0006    ....    LDRH     r0,[sp,#6]
        0x0020a212:    9000        ..      STR      r0,[sp,#0]
        0x0020a214:    498c        .I      LDR      r1,[pc,#560] ; [0x20a448] = 0x8801a6c
        0x0020a216:    488d        .H      LDR      r0,[pc,#564] ; [0x20a44c] = 0x21103000
        0x0020a218:    f8bd3004    ...0    LDRH     r3,[sp,#4]
        0x0020a21c:    2202        ."      MOVS     r2,#2
        0x0020a21e:    3188        .1      ADDS     r1,r1,#0x88
        0x0020a220:    1c80        ..      ADDS     r0,r0,#2
        0x0020a222:    f5fdfc1c    ....    BL       log_buffer ; 0x7a5e
;;;589                                        *p_max);
;;;590                    }
;;;591                    break;
        0x0020a226:    e02e        ..      B        0x20a286 ; app_parse_scan_info + 354
;;;592    
;;;593                case GAP_ADTYPE_SERVICE_DATA:
;;;594                    {
;;;595                        uint16_t *p_uuid = (uint16_t *)(buffer);
;;;596                        uint8_t data_len = length - 3;
        0x0020a228:    1ee0        ..      SUBS     r0,r4,#3
        0x0020a22a:    b2c5        ..      UXTB     r5,r0
;;;597    
;;;598                        data_uart_print("GAP_ADTYPE_SERVICE_DATA: UUID 0x%x, len %d, data %b\r\n", *p_uuid,
        0x0020a22c:    f1090202    ....    ADD      r2,r9,#2
        0x0020a230:    4629        )F      MOV      r1,r5
        0x0020a232:    4650        PF      MOV      r0,r10
        0x0020a234:    f5fdfe69    ..i.    BL       trace_binary ; 0x7f0a
        0x0020a238:    4603        .F      MOV      r3,r0
        0x0020a23a:    f8bd1004    ....    LDRH     r1,[sp,#4]
        0x0020a23e:    462a        *F      MOV      r2,r5
        0x0020a240:    a0c2        ..      ADR      r0,{pc}+0x30c ; 0x20a54c
;;;599                                        data_len, TRACE_BINARY(data_len, &buffer[2]));
;;;600                    }
;;;601                    break;
        0x0020a242:    e012        ..      B        0x20a26a ; app_parse_scan_info + 326
;;;602                case GAP_ADTYPE_APPEARANCE:
;;;603                    {
;;;604                        uint16_t *p_appearance = (uint16_t *)(buffer);
;;;605                        data_uart_print("GAP_ADTYPE_APPEARANCE: %d\r\n", *p_appearance);
        0x0020a244:    f8bd1004    ....    LDRH     r1,[sp,#4]
        0x0020a248:    a0ce        ..      ADR      r0,{pc}+0x33c ; 0x20a584
        0x0020a24a:    f000fce9    ....    BL       data_uart_print ; 0x20ac20
        0x0020a24e:    e01a        ..      B        0x20a286 ; app_parse_scan_info + 354
;;;606                    }
;;;607                    break;
;;;608    
;;;609                case GAP_ADTYPE_MANUFACTURER_SPECIFIC:
;;;610                    {
;;;611                        uint8_t data_len = length - 3;
        0x0020a250:    1ee0        ..      SUBS     r0,r4,#3
        0x0020a252:    b2c5        ..      UXTB     r5,r0
;;;612                        uint16_t *p_company_id = (uint16_t *)(buffer);
;;;613                        data_uart_print("GAP_ADTYPE_MANUFACTURER_SPECIFIC: company_id 0x%x, len %d, data %b\r\n",
        0x0020a254:    f1090202    ....    ADD      r2,r9,#2
        0x0020a258:    4629        )F      MOV      r1,r5
        0x0020a25a:    4650        PF      MOV      r0,r10
        0x0020a25c:    f5fdfe55    ..U.    BL       trace_binary ; 0x7f0a
        0x0020a260:    4603        .F      MOV      r3,r0
        0x0020a262:    f8bd1004    ....    LDRH     r1,[sp,#4]
        0x0020a266:    462a        *F      MOV      r2,r5
        0x0020a268:    48cd        .H      LDR      r0,[pc,#820] ; [0x20a5a0] = 0x20ce90
        0x0020a26a:    f000fcd9    ....    BL       data_uart_print ; 0x20ac20
        0x0020a26e:    e00a        ..      B        0x20a286 ; app_parse_scan_info + 354
        0x0020a270:    1971        q.      ADDS     r1,r6,r5
        0x0020a272:    eb010008    ....    ADD      r0,r1,r8
        0x0020a276:    7a81        .z      LDRB     r1,[r0,#0xa]
        0x0020a278:    a0ca        ..      ADR      r0,{pc}+0x32c ; 0x20a5a4
        0x0020a27a:    f000fcd1    ....    BL       data_uart_print ; 0x20ac20
        0x0020a27e:    1c6d        m.      ADDS     r5,r5,#1
;;;614                                        *p_company_id, data_len, TRACE_BINARY(data_len, &buffer[2]));
;;;615                    }
;;;616                    break;
;;;617    
;;;618                default:
;;;619                    {
;;;620                        uint8_t i = 0;
;;;621    
;;;622                        for (i = 0; i < (length - 1); i++)
        0x0020a280:    b2ed        ..      UXTB     r5,r5
        0x0020a282:    42bd        .B      CMP      r5,r7
        0x0020a284:    dbf4        ..      BLT      0x20a270 ; app_parse_scan_info + 332
;;;623                        {
;;;624                            data_uart_print("  AD Data: Unhandled Data = 0x%x\r\n", scan_info->data[pos + i]);
;;;625                        }
;;;626                    }
;;;627                    break;
;;;628                }
;;;629            }
;;;630    
;;;631            pos += length;
        0x0020a286:    1930        0.      ADDS     r0,r6,r4
        0x0020a288:    b2c5        ..      UXTB     r5,r0
        0x0020a28a:    f8980009    ....    LDRB     r0,[r8,#9]
        0x0020a28e:    42a8        .B      CMP      r0,r5
        0x0020a290:    f63faf55    ?.U.    BHI      0x20a13e ; app_parse_scan_info + 26
;;;632        }
;;;633    		data_uart_print("------------------------------\r\n");
        0x0020a294:    a0cc        ..      ADR      r0,{pc}+0x334 ; 0x20a5c8
        0x0020a296:    f000fcc3    ....    BL       data_uart_print ; 0x20ac20
;;;634    }
        0x0020a29a:    b00a        ..      ADD      sp,sp,#0x28
        0x0020a29c:    e8bd87f0    ....    POP      {r4-r10,pc}
    filter_scan_info_by_uuid
;;;635    
;;;636    /** @defgroup  CENTRAL_SCAN_MGR Scan Information manager
;;;637        * @brief Scan Information manager
;;;638        * @{
;;;639        */
;;;640    /**
;;;641      * @brief Use 16 bit uuid to filter scan information
;;;642      * @param[in] uuid 16 bit UUID.
;;;643      * @param[in] scan_info point to scan information data.
;;;644      * @return filter result
;;;645      * @retval true found success
;;;646      * @retval false not found
;;;647      */
;;;648    bool filter_scan_info_by_uuid(uint16_t uuid, T_LE_SCAN_INFO *scan_info)
;;;649    {
        0x0020a2a0:    e92d47f0    -..G    PUSH     {r4-r10,lr}
        0x0020a2a4:    4681        .F      MOV      r9,r0
        0x0020a2a6:    b08a        ..      SUB      sp,sp,#0x28
        0x0020a2a8:    4688        .F      MOV      r8,r1
        0x0020a2aa:    2000        .       MOVS     r0,#0
;;; ..\..\..\src\sample\ble_central\central_app.c (649)
        0x0020a2ac:    e035        5.      B        0x20a31a ; filter_scan_info_by_uuid + 122
;;;650        uint8_t buffer[32];
;;;651        uint8_t pos = 0;
;;;652    
;;;653        while (pos < scan_info->data_len)
;;;654        {
;;;655            /* Length of the AD structure. */
;;;656            uint8_t length = scan_info->data[pos++];
        0x0020a2ae:    eb080100    ....    ADD      r1,r8,r0
        0x0020a2b2:    1c40        @.      ADDS     r0,r0,#1
        0x0020a2b4:    7a8e        .z      LDRB     r6,[r1,#0xa]
        0x0020a2b6:    b2c7        ..      UXTB     r7,r0
;;;657            uint8_t type;
;;;658    
;;;659            if ((length > 0x01) && ((pos + length) <= 31))
        0x0020a2b8:    2e01        ..      CMP      r6,#1
        0x0020a2ba:    d92c        ,.      BLS      0x20a316 ; filter_scan_info_by_uuid + 118
        0x0020a2bc:    19b8        ..      ADDS     r0,r7,r6
        0x0020a2be:    281f        .(      CMP      r0,#0x1f
        0x0020a2c0:    d829        ).      BHI      0x20a316 ; filter_scan_info_by_uuid + 118
;;;660            {
;;;661                /* Copy the AD Data to buffer. */
;;;662                memcpy(buffer, scan_info->data + pos + 1, length - 1);
        0x0020a2c2:    eb080407    ....    ADD      r4,r8,r7
        0x0020a2c6:    f104010b    ....    ADD      r1,r4,#0xb
        0x0020a2ca:    1e72        r.      SUBS     r2,r6,#1
        0x0020a2cc:    a801        ..      ADD      r0,sp,#4
        0x0020a2ce:    f64ffde4    O...    BL       __aeabi_memcpy ; 0x59e9a
;;;663                /* AD Type, one octet. */
;;;664                type = scan_info->data[pos];
        0x0020a2d2:    7aa0        .z      LDRB     r0,[r4,#0xa]
;;;665    
;;;666                switch (type)
        0x0020a2d4:    2802        .(      CMP      r0,#2
        0x0020a2d6:    d003        ..      BEQ      0x20a2e0 ; filter_scan_info_by_uuid + 64
        0x0020a2d8:    2803        .(      CMP      r0,#3
        0x0020a2da:    d001        ..      BEQ      0x20a2e0 ; filter_scan_info_by_uuid + 64
        0x0020a2dc:    2814        .(      CMP      r0,#0x14
        0x0020a2de:    d11a        ..      BNE      0x20a316 ; filter_scan_info_by_uuid + 118
        0x0020a2e0:    f8dfa168    ..h.    LDR      r10,[pc,#360] ; [0x20a44c] = 0x21103000
        0x0020a2e4:    1e70        p.      SUBS     r0,r6,#1
;;;667                {
;;;668                case GAP_ADTYPE_16BIT_MORE:
;;;669                case GAP_ADTYPE_16BIT_COMPLETE:
;;;670                case GAP_ADTYPE_SERVICES_LIST_16BIT:
;;;671                    {
;;;672                        uint16_t *p_uuid = (uint16_t *)(buffer);
        0x0020a2e6:    ad01        ..      ADD      r5,sp,#4
;;;673                        uint8_t i = length - 1;
        0x0020a2e8:    b2c4        ..      UXTB     r4,r0
        0x0020a2ea:    f10a0a02    ....    ADD      r10,r10,#2
;;;674    
;;;675                        while (i >= 2)
        0x0020a2ee:    e010        ..      B        0x20a312 ; filter_scan_info_by_uuid + 114
;;;676                        {
;;;677                            APP_PRINT_INFO2("  AD Data: UUID16 List Item %d = 0x%x", i / 2, *p_uuid);
        0x0020a2f0:    8828        (.      LDRH     r0,[r5,#0]
        0x0020a2f2:    4955        UI      LDR      r1,[pc,#340] ; [0x20a448] = 0x8801a6c
        0x0020a2f4:    9000        ..      STR      r0,[sp,#0]
        0x0020a2f6:    0863        c.      LSRS     r3,r4,#1
        0x0020a2f8:    2202        ."      MOVS     r2,#2
        0x0020a2fa:    31c0        .1      ADDS     r1,r1,#0xc0
        0x0020a2fc:    4650        PF      MOV      r0,r10
        0x0020a2fe:    f5fdfbae    ....    BL       log_buffer ; 0x7a5e
;;;678    						//data_uart_print("  AD Data: UUID16 List Item %d = 0x%x\r\n", i / 2, *p_uuid);
;;;679                            if (*p_uuid == uuid)
        0x0020a302:    8829        ).      LDRH     r1,[r5,#0]
        0x0020a304:    4549        IE      CMP      r1,r9
        0x0020a306:    d101        ..      BNE      0x20a30c ; filter_scan_info_by_uuid + 108
;;;680                            {
;;;681                                return true;
        0x0020a308:    2001        .       MOVS     r0,#1
        0x0020a30a:    e7c6        ..      B        0x20a29a ; app_parse_scan_info + 374
        0x0020a30c:    1ea4        ..      SUBS     r4,r4,#2
;;;682                            }
;;;683                            p_uuid++;
;;;684                            i -= 2;
        0x0020a30e:    b2e4        ..      UXTB     r4,r4
        0x0020a310:    1cad        ..      ADDS     r5,r5,#2
        0x0020a312:    2c02        .,      CMP      r4,#2
        0x0020a314:    d2ec        ..      BCS      0x20a2f0 ; filter_scan_info_by_uuid + 80
;;;685                        }
;;;686                    }
;;;687                    break;
;;;688    
;;;689                default:
;;;690                    break;
;;;691                }
;;;692            }
;;;693    
;;;694            pos += length;
        0x0020a316:    19b8        ..      ADDS     r0,r7,r6
        0x0020a318:    b2c0        ..      UXTB     r0,r0
        0x0020a31a:    f8981009    ....    LDRB     r1,[r8,#9]
        0x0020a31e:    4281        .B      CMP      r1,r0
        0x0020a320:    d8c5        ..      BHI      0x20a2ae ; filter_scan_info_by_uuid + 14
;;;695        }
;;;696        return false;
        0x0020a322:    2000        .       MOVS     r0,#0
;;;697    }
        0x0020a324:    e7b9        ..      B        0x20a29a ; app_parse_scan_info + 374
    app_gap_callback
;;;698    /** @} */ /* End of group CENTRAL_SCAN_MGR */
;;;699    
;;;700    /** @defgroup  CENTRAL_GAP_CALLBACK GAP Callback Event Handler
;;;701        * @brief Handle GAP callback event
;;;702        * @{
;;;703        */
;;;704    /**
;;;705      * @brief Callback for gap le to notify app
;;;706      * @param[in] cb_type callback msy type @ref GAP_LE_MSG_Types.
;;;707      * @param[in] p_cb_data point to callback data @ref T_LE_CB_DATA.
;;;708      * @retval result @ref T_APP_RESULT
;;;709      */
;;;710    T_APP_RESULT app_gap_callback(uint8_t cb_type, void *p_cb_data)
;;;711    {
        0x0020a326:    b5f0        ..      PUSH     {r4-r7,lr}
        0x0020a328:    b089        ..      SUB      sp,sp,#0x24
        0x0020a32a:    460c        .F      MOV      r4,r1
        0x0020a32c:    4607        .F      MOV      r7,r0
;;;712        T_APP_RESULT result = APP_RESULT_SUCCESS;
        0x0020a32e:    2600        .&      MOVS     r6,#0
;;;713        T_LE_CB_DATA *p_data = (T_LE_CB_DATA *)p_cb_data;
;;;714    
;;;715    	uint8_t devname[]="CMT4501-a11005e2";
        0x0020a330:    2214        ."      MOVS     r2,#0x14
        0x0020a332:    a1ae        ..      ADR      r1,{pc}+0x2ba ; 0x20a5ec
        0x0020a334:    a804        ..      ADD      r0,sp,#0x10
        0x0020a336:    f64ffe37    O.7.    BL       __aeabi_memcpy4 ; 0x59fa8
        0x0020a33a:    4d44        DM      LDR      r5,[pc,#272] ; [0x20a44c] = 0x21103000
        0x0020a33c:    1cad        ..      ADDS     r5,r5,#2
;;;716    
;;;717        switch (cb_type)
        0x0020a33e:    2f15        ./      CMP      r7,#0x15
        0x0020a340:    d038        8.      BEQ      0x20a3b4 ; app_gap_callback + 142
        0x0020a342:    2f30        0/      CMP      r7,#0x30
        0x0020a344:    d008        ..      BEQ      0x20a358 ; app_gap_callback + 50
        0x0020a346:    463b        ;F      MOV      r3,r7
        0x0020a348:    2201        ."      MOVS     r2,#1
        0x0020a34a:    49ad        .I      LDR      r1,[pc,#692] ; [0x20a600] = 0x8801c5c
        0x0020a34c:    1ea8        ..      SUBS     r0,r5,#2
        0x0020a34e:    f5fdfb86    ....    BL       log_buffer ; 0x7a5e
        0x0020a352:    b009        ..      ADD      sp,sp,#0x24
        0x0020a354:    4630        0F      MOV      r0,r6
        0x0020a356:    bdf0        ..      POP      {r4-r7,pc}
;;;718        {
;;;719        case GAP_MSG_LE_SCAN_INFO:
;;;720            APP_PRINT_INFO5("GAP_MSG_LE_SCAN_INFO:adv_type 0x%x, bd_addr %s, remote_addr_type %d, rssi %d, data_len %d",
        0x0020a358:    48aa        .H      LDR      r0,[pc,#680] ; [0x20a604] = 0x21300000
        0x0020a35a:    6821        !h      LDR      r1,[r4,#0]
        0x0020a35c:    f5fdfd3c    ..<.    BL       trace_bdaddr ; 0x7dd8
        0x0020a360:    4601        .F      MOV      r1,r0
        0x0020a362:    6820         h      LDR      r0,[r4,#0]
        0x0020a364:    7a47        Gz      LDRB     r7,[r0,#9]
        0x0020a366:    f9903008    ...0    LDRSB    r3,[r0,#8]
        0x0020a36a:    7982        .y      LDRB     r2,[r0,#6]
        0x0020a36c:    e88d008e    ....    STM      sp,{r1-r3,r7}
        0x0020a370:    4935        5I      LDR      r1,[pc,#212] ; [0x20a448] = 0x8801a6c
        0x0020a372:    79c3        .y      LDRB     r3,[r0,#7]
        0x0020a374:    2205        ."      MOVS     r2,#5
        0x0020a376:    31ec        .1      ADDS     r1,r1,#0xec
        0x0020a378:    4628        (F      MOV      r0,r5
        0x0020a37a:    f5fdfb70    ..p.    BL       log_buffer ; 0x7a5e
;;;721                            p_data->p_le_scan_info->adv_type,
;;;722                            TRACE_BDADDR(p_data->p_le_scan_info->bd_addr),
;;;723                            p_data->p_le_scan_info->remote_addr_type,
;;;724                            p_data->p_le_scan_info->rssi,
;;;725                            p_data->p_le_scan_info->data_len);
;;;726            /* User can split interested information by using the function as follow. */
;;;727    
;;;728    #if 1
;;;729    		//app_parse_scan_info(p_data->p_le_scan_info);
;;;730    		if (filter_scan_info_by_name(devname, p_data->p_le_scan_info))
        0x0020a37e:    a804        ..      ADD      r0,sp,#0x10
        0x0020a380:    6821        !h      LDR      r1,[r4,#0]
        0x0020a382:    f7fffea0    ....    BL       filter_scan_info_by_name ; 0x20a0c6
        0x0020a386:    b118        ..      CBZ      r0,0x20a390 ; app_gap_callback + 106
;;;731            {
;;;732                //data_uart_print("Found simple ble service\r\n");
;;;733                link_mgr_add_device(p_data->p_le_scan_info->bd_addr, p_data->p_le_scan_info->remote_addr_type);
        0x0020a388:    6820         h      LDR      r0,[r4,#0]
        0x0020a38a:    7981        .y      LDRB     r1,[r0,#6]
        0x0020a38c:    f011fff4    ....    BL       link_mgr_add_device ; 0x21c378
;;;734            }
;;;735    #endif
;;;736    
;;;737            if (filter_scan_info_by_uuid(GATT_UUID_SIMPLE_PROFILE, p_data->p_le_scan_info))
        0x0020a390:    f64f70e0    O..p    MOV      r0,#0xffe0
        0x0020a394:    6821        !h      LDR      r1,[r4,#0]
        0x0020a396:    f7ffff83    ....    BL       filter_scan_info_by_uuid ; 0x20a2a0
        0x0020a39a:    2800        .(      CMP      r0,#0
        0x0020a39c:    d0d9        ..      BEQ      0x20a352 ; app_gap_callback + 44
;;;738            {
;;;739                APP_PRINT_INFO0("Found simple ble service");
        0x0020a39e:    4998        .I      LDR      r1,[pc,#608] ; [0x20a600] = 0x8801c5c
        0x0020a3a0:    2200        ."      MOVS     r2,#0
        0x0020a3a2:    39a4        .9      SUBS     r1,r1,#0xa4
        0x0020a3a4:    4628        (F      MOV      r0,r5
        0x0020a3a6:    f5fdfb5a    ..Z.    BL       log_buffer ; 0x7a5e
;;;740                link_mgr_add_device(p_data->p_le_scan_info->bd_addr, p_data->p_le_scan_info->remote_addr_type);
        0x0020a3aa:    6820         h      LDR      r0,[r4,#0]
        0x0020a3ac:    7981        .y      LDRB     r1,[r0,#6]
        0x0020a3ae:    f011ffe3    ....    BL       link_mgr_add_device ; 0x21c378
        0x0020a3b2:    e7ce        ..      B        0x20a352 ; app_gap_callback + 44
;;;741            }
;;;742            /* If you want to parse the scan info, please reference function app_parse_scan_info in observer app. */
;;;743            break;
;;;744    
;;;745        case GAP_MSG_LE_CONN_UPDATE_IND:
;;;746            APP_PRINT_INFO5("GAP_MSG_LE_CONN_UPDATE_IND: conn_id %d, conn_interval_max 0x%x, conn_interval_min 0x%x, conn_latency 0x%x,supervision_timeout 0x%x",
        0x0020a3b4:    6820         h      LDR      r0,[r4,#0]
        0x0020a3b6:    8881        ..      LDRH     r1,[r0,#4]
        0x0020a3b8:    8904        ..      LDRH     r4,[r0,#8]
        0x0020a3ba:    88c3        ..      LDRH     r3,[r0,#6]
        0x0020a3bc:    8842        B.      LDRH     r2,[r0,#2]
        0x0020a3be:    e88d001e    ....    STM      sp,{r1-r4}
        0x0020a3c2:    498f        .I      LDR      r1,[pc,#572] ; [0x20a600] = 0x8801c5c
        0x0020a3c4:    7803        .x      LDRB     r3,[r0,#0]
        0x0020a3c6:    2205        ."      MOVS     r2,#5
        0x0020a3c8:    3988        .9      SUBS     r1,r1,#0x88
        0x0020a3ca:    4628        (F      MOV      r0,r5
        0x0020a3cc:    f5fdfb47    ..G.    BL       log_buffer ; 0x7a5e
;;;747                            p_data->p_le_conn_update_ind->conn_id,
;;;748                            p_data->p_le_conn_update_ind->conn_interval_max,
;;;749                            p_data->p_le_conn_update_ind->conn_interval_min,
;;;750                            p_data->p_le_conn_update_ind->conn_latency,
;;;751                            p_data->p_le_conn_update_ind->supervision_timeout);
;;;752            /* if reject the proposed connection parameter from peer device, use APP_RESULT_REJECT. */
;;;753            result = APP_RESULT_ACCEPT;
        0x0020a3d0:    f6405603    @..V    MOV      r6,#0xd03
;;;754            break;
        0x0020a3d4:    e7bd        ..      B        0x20a352 ; app_gap_callback + 44
    app_client_callback
;;;755    
;;;756        default:
;;;757            APP_PRINT_ERROR1("app_gap_callback: unhandled cb_type 0x%x", cb_type);
;;;758            break;
;;;759        }
;;;760        return result;
;;;761    }
;;;762    /** @} */ /* End of group CENTRAL_GAP_CALLBACK */
;;;763    
;;;764    /** @defgroup  CENTRAL_SRV_DIS GATT Services discovery and storage
;;;765        * @brief GATT Services discovery and storage
;;;766        * @{
;;;767        */
;;;768    /**
;;;769     * @brief  Discovery GATT services
;;;770     * @param  conn_id connection ID.
;;;771     * @param  start first call. true - first call this function after conncection, false - not first
;;;772     * @retval None
;;;773     */
;;;774    void app_discov_services(uint8_t conn_id, bool start)
;;;775    {
;;;776        if (app_link_table[conn_id].conn_state != GAP_CONN_STATE_CONNECTED)
;;;777        {
;;;778            APP_PRINT_ERROR1("app_discov_services: conn_id %d not connected ", conn_id);
;;;779            return;
;;;780        }
;;;781        if (start)
;;;782        {
;;;783    #if F_BT_GATT_SRV_HANDLE_STORAGE
;;;784            bool is_disc = true;
;;;785            T_APP_SRVS_HDL_TABLE app_srvs_table;
;;;786            if (app_load_srvs_hdl_table(&app_srvs_table) == 0)
;;;787            {
;;;788                if ((app_srvs_table.srv_found_flags != 0) &&
;;;789                    (app_srvs_table.bd_type == app_link_table[conn_id].bd_type) &&
;;;790                    (memcmp(app_srvs_table.bd_addr, app_link_table[conn_id].bd_addr, GAP_BD_ADDR_LEN) == 0))
;;;791                {
;;;792                    APP_PRINT_INFO1("app_discov_services: load from flash, srv_found_flags 0x%x",
;;;793                                    app_srvs_table.srv_found_flags);
;;;794                    app_link_table[conn_id].srv_found_flags = app_srvs_table.srv_found_flags;
;;;795                    if (app_srvs_table.srv_found_flags & APP_DISCOV_GAPS_FLAG)
;;;796                    {
;;;797                        gaps_set_hdl_cache(conn_id, app_srvs_table.gaps_hdl_cache, sizeof(uint16_t) * HDL_GAPS_CACHE_LEN);
;;;798                    }
;;;799                    if (app_srvs_table.srv_found_flags & APP_DISCOV_SIMP_FLAG)
;;;800                    {
;;;801                        simp_ble_client_set_hdl_cache(conn_id, app_srvs_table.simp_hdl_cache,
;;;802                                                      sizeof(uint16_t) * HDL_SIMBLE_CACHE_LEN);
;;;803                    }
;;;804                    if (app_srvs_table.srv_found_flags & APP_DISCOV_BAS_FLAG)
;;;805                    {
;;;806                        bas_set_hdl_cache(conn_id, app_srvs_table.bas_hdl_cache, sizeof(uint16_t) * HDL_BAS_CACHE_LEN);
;;;807                    }
;;;808                    is_disc = false;
;;;809                }
;;;810            }
;;;811            else
;;;812            {
;;;813                APP_PRINT_ERROR0("app_load_srvs_hdl_table: failed");
;;;814            }
;;;815    
;;;816            if (is_disc)
;;;817            {
;;;818                if (gaps_start_discovery(conn_id) == false)
;;;819                {
;;;820                    APP_PRINT_ERROR1("app_discov_services: discover gaps failed conn_id %d", conn_id);
;;;821                }
;;;822            }
;;;823    #else
;;;824            if (gaps_start_discovery(conn_id) == false)
;;;825            {
;;;826                APP_PRINT_ERROR1("app_discov_services: discover gaps failed conn_id %d", conn_id);
;;;827            }
;;;828    #endif
;;;829            return;
;;;830        }
;;;831        if ((app_link_table[conn_id].discovered_flags & APP_DISCOV_SIMP_FLAG) == 0)
;;;832        {
;;;833            if (simp_ble_client_start_discovery(conn_id) == false)
;;;834            {
;;;835                APP_PRINT_ERROR1("app_discov_services: discover simp failed conn_id %d", conn_id);
;;;836            }
;;;837        }
;;;838        else if ((app_link_table[conn_id].discovered_flags & APP_DISCOV_BAS_FLAG) == 0)
;;;839        {
;;;840            if (bas_start_discovery(conn_id) == false)
;;;841            {
;;;842                APP_PRINT_ERROR1("app_discov_services: discover bas failed conn_id %d", conn_id);
;;;843            }
;;;844        }
;;;845        else
;;;846        {
;;;847            APP_PRINT_INFO2("app_discov_services: discover complete, conn_id %d, srv_found_flags 0x%x",
;;;848                            conn_id, app_link_table[conn_id].srv_found_flags);
;;;849    #if F_BT_GATT_SRV_HANDLE_STORAGE
;;;850            if (app_link_table[conn_id].srv_found_flags != 0)
;;;851            {
;;;852                T_APP_SRVS_HDL_TABLE app_srvs_table;
;;;853                memset(&app_srvs_table, 0, sizeof(T_APP_SRVS_HDL_TABLE));
;;;854                app_srvs_table.bd_type = app_link_table[conn_id].bd_type;
;;;855                app_srvs_table.srv_found_flags = app_link_table[conn_id].srv_found_flags;
;;;856                memcpy(app_srvs_table.bd_addr, app_link_table[conn_id].bd_addr, GAP_BD_ADDR_LEN);
;;;857                gaps_get_hdl_cache(conn_id, app_srvs_table.gaps_hdl_cache, sizeof(uint16_t) * HDL_GAPS_CACHE_LEN);
;;;858                simp_ble_client_get_hdl_cache(conn_id, app_srvs_table.simp_hdl_cache,
;;;859                                              sizeof(uint16_t) * HDL_SIMBLE_CACHE_LEN);
;;;860                bas_get_hdl_cache(conn_id, app_srvs_table.bas_hdl_cache, sizeof(uint16_t) * HDL_BAS_CACHE_LEN);
;;;861                if (app_save_srvs_hdl_table(&app_srvs_table) != 0)
;;;862                {
;;;863                    APP_PRINT_ERROR0("app_save_srvs_hdl_table: failed");
;;;864                }
;;;865            }
;;;866    #endif
;;;867        }
;;;868    
;;;869        return;
;;;870    }
;;;871    /** @} */ /* End of group CENTRAL_SRV_DIS */
;;;872    
;;;873    /** @defgroup  CENTRAL_CLIIENT_CALLBACK Profile Client Callback Event Handler
;;;874        * @brief Handle profile client callback event
;;;875        * @{
;;;876        */
;;;877    
;;;878    /**
;;;879     * @brief  Callback will be called when data sent from profile client layer.
;;;880     * @param  client_id the ID distinguish which module sent the data.
;;;881     * @param  conn_id connection ID.
;;;882     * @param  p_data  pointer to data.
;;;883     * @retval   result @ref T_APP_RESULT
;;;884     */
;;;885    T_APP_RESULT app_client_callback(T_CLIENT_ID client_id, uint8_t conn_id, void *p_data)
;;;886    {
        0x0020a3d6:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x0020a3da:    4607        .F      MOV      r7,r0
        0x0020a3dc:    460d        .F      MOV      r5,r1
        0x0020a3de:    2000        .       MOVS     r0,#0
        0x0020a3e0:    f8df8068    ..h.    LDR      r8,[pc,#104] ; [0x20a44c] = 0x21103000
        0x0020a3e4:    e9cd5000    ...P    STRD     r5,r0,[sp,#0]
        0x0020a3e8:    4614        .F      MOV      r4,r2
;;;887    	char temp[3]={0};
;;;888        T_APP_RESULT  result = APP_RESULT_SUCCESS;
        0x0020a3ea:    4606        .F      MOV      r6,r0
;;;889        APP_PRINT_INFO2("app_client_callback: client_id %d, conn_id %d",
        0x0020a3ec:    f1080802    ....    ADD      r8,r8,#2
        0x0020a3f0:    463b        ;F      MOV      r3,r7
        0x0020a3f2:    2202        ."      MOVS     r2,#2
        0x0020a3f4:    4984        .I      LDR      r1,[pc,#528] ; [0x20a608] = 0x8801db0
        0x0020a3f6:    4640        @F      MOV      r0,r8
        0x0020a3f8:    f5fdfb31    ..1.    BL       log_buffer ; 0x7a5e
;;;890                        client_id, conn_id);
;;;891        if (client_id == gaps_client_id)
        0x0020a3fc:    4983        .I      LDR      r1,[pc,#524] ; [0x20a60c] = 0x20d374
        0x0020a3fe:    4884        .H      LDR      r0,[pc,#528] ; [0x20a610] = 0x20d3a3
        0x0020a400:    eb050385    ....    ADD      r3,r5,r5,LSL #2
        0x0020a404:    788a        .x      LDRB     r2,[r1,#2]
        0x0020a406:    eb000043    ..C.    ADD      r0,r0,r3,LSL #1
        0x0020a40a:    4297        .B      CMP      r7,r2
        0x0020a40c:    d11a        ..      BNE      0x20a444 ; app_client_callback + 110
;;;892        {
;;;893            T_GAPS_CLIENT_CB_DATA *p_gaps_cb_data = (T_GAPS_CLIENT_CB_DATA *)p_data;
;;;894            switch (p_gaps_cb_data->cb_type)
        0x0020a40e:    7821        !x      LDRB     r1,[r4,#0]
        0x0020a410:    b111        ..      CBZ      r1,0x20a418 ; app_client_callback + 66
        0x0020a412:    2901        .)      CMP      r1,#1
        0x0020a414:    d117        ..      BNE      0x20a446 ; app_client_callback + 112
        0x0020a416:    e108        ..      B        0x20a62a ; app_client_callback + 596
;;;895            {
;;;896            case GAPS_CLIENT_CB_TYPE_DISC_STATE:
;;;897                switch (p_gaps_cb_data->cb_content.disc_state)
        0x0020a418:    7921        !y      LDRB     r1,[r4,#4]
        0x0020a41a:    2902        .)      CMP      r1,#2
        0x0020a41c:    d002        ..      BEQ      0x20a424 ; app_client_callback + 78
        0x0020a41e:    2903        .)      CMP      r1,#3
        0x0020a420:    d1f8        ..      BNE      0x20a414 ; app_client_callback + 62
        0x0020a422:    e0f7        ..      B        0x20a614 ; app_client_callback + 574
;;;898                {
;;;899                case DISC_GAPS_DONE:
;;;900                    app_link_table[conn_id].discovered_flags |= APP_DISCOV_GAPS_FLAG;
        0x0020a424:    7841        Ax      LDRB     r1,[r0,#1]
        0x0020a426:    f0410101    A...    ORR      r1,r1,#1
        0x0020a42a:    7041        Ap      STRB     r1,[r0,#1]
;;;901                    app_link_table[conn_id].srv_found_flags |= APP_DISCOV_GAPS_FLAG;
        0x0020a42c:    7881        .x      LDRB     r1,[r0,#2]
        0x0020a42e:    f0410101    A...    ORR      r1,r1,#1
        0x0020a432:    7081        .p      STRB     r1,[r0,#2]
;;;902                    app_discov_services(conn_id, false);
        0x0020a434:    2100        .!      MOVS     r1,#0
        0x0020a436:    4628        (F      MOV      r0,r5
        0x0020a438:    f7fffc37    ..7.    BL       app_discov_services ; 0x209caa
;;;903                    /* Discovery Simple BLE service procedure successfully done. */
;;;904                    APP_PRINT_INFO0("app_client_callback: discover gaps procedure done.");
        0x0020a43c:    4972        rI      LDR      r1,[pc,#456] ; [0x20a608] = 0x8801db0
        0x0020a43e:    2200        ."      MOVS     r2,#0
        0x0020a440:    3134        41      ADDS     r1,r1,#0x34
;;;905                    break;
        0x0020a442:    e212        ..      B        0x20a86a ; app_client_callback + 1172
        0x0020a444:    e126        &.      B        0x20a694 ; app_client_callback + 702
        0x0020a446:    e10e        ..      B        0x20a666 ; app_client_callback + 656
    $d
        0x0020a448:    08801a6c    l...    DCD    142613100
        0x0020a44c:    21103000    .0.!    DCD    554708992
        0x0020a450:    0021c8a0    ..!.    DCD    2214048
        0x0020a454:    0020cfcc    .. .    DCD    2150348
        0x0020a458:    2b2b2b2b    ++++    DCD    724249387
        0x0020a45c:    2b2b2b2b    ++++    DCD    724249387
        0x0020a460:    2b2b2b2b    ++++    DCD    724249387
        0x0020a464:    2b2b2b2b    ++++    DCD    724249387
        0x0020a468:    2b2b2b2b    ++++    DCD    724249387
        0x0020a46c:    2b2b2b2b    ++++    DCD    724249387
        0x0020a470:    2b2b2b2b    ++++    DCD    724249387
        0x0020a474:    000a0d2b    +...    DCD    658731
        0x0020a478:    21500000    ..P!    DCD    558891008
        0x0020a47c:    0020ced8    .. .    DCD    2150104
        0x0020a480:    5f504147    GAP_    DCD    1599095111
        0x0020a484:    59544441    ADTY    DCD    1498694721
        0x0020a488:    465f4550    PE_F    DCD    1180648784
        0x0020a48c:    5347414c    LAGS    DCD    1397178700
        0x0020a490:    7830203a    : 0x    DCD    2016419898
        0x0020a494:    0a0d7825    %x..    DCD    168654885
        0x0020a498:    00000000    ....    DCD    0
        0x0020a49c:    5f504147    GAP_    DCD    1599095111
        0x0020a4a0:    59544441    ADTY    DCD    1498694721
        0x0020a4a4:    315f4550    PE_1    DCD    828327248
        0x0020a4a8:    54494236    6BIT    DCD    1414087222
        0x0020a4ac:    5858585f    _XXX    DCD    1482184799
        0x0020a4b0:    7830203a    : 0x    DCD    2016419898
        0x0020a4b4:    0a0d7825    %x..    DCD    168654885
        0x0020a4b8:    00000000    ....    DCD    0
        0x0020a4bc:    5f504147    GAP_    DCD    1599095111
        0x0020a4c0:    59544441    ADTY    DCD    1498694721
        0x0020a4c4:    335f4550    PE_3    DCD    861881680
        0x0020a4c8:    54494232    2BIT    DCD    1414087218
        0x0020a4cc:    5858585f    _XXX    DCD    1482184799
        0x0020a4d0:    7830203a    : 0x    DCD    2016419898
        0x0020a4d4:    0a0d7825    %x..    DCD    168654885
        0x0020a4d8:    00000000    ....    DCD    0
        0x0020a4dc:    5f504147    GAP_    DCD    1599095111
        0x0020a4e0:    59544441    ADTY    DCD    1498694721
        0x0020a4e4:    315f4550    PE_1    DCD    828327248
        0x0020a4e8:    49423832    28BI    DCD    1229076530
        0x0020a4ec:    58585f54    T_XX    DCD    1482186580
        0x0020a4f0:    30203a58    X: 0    DCD    807418456
        0x0020a4f4:    2e382578    x%8.    DCD    775431544
        0x0020a4f8:    38257838    8x%8    DCD    941979704
        0x0020a4fc:    2578382e    .8x%    DCD    628635694
        0x0020a500:    78382e38    8.8x    DCD    2016947768
        0x0020a504:    382e3825    %8.8    DCD    942553125
        0x0020a508:    000a0d78    x...    DCD    658808
        0x0020a50c:    5f504147    GAP_    DCD    1599095111
        0x0020a510:    59544441    ADTY    DCD    1498694721
        0x0020a514:    4c5f4550    PE_L    DCD    1281312080
        0x0020a518:    4c41434f    OCAL    DCD    1279345487
        0x0020a51c:    4d414e5f    _NAM    DCD    1296125535
        0x0020a520:    58585f45    E_XX    DCD    1482186565
        0x0020a524:    25203a58    X: %    DCD    622869080
        0x0020a528:    000a0d73    s...    DCD    658803
        0x0020a52c:    5f504147    GAP_    DCD    1599095111
        0x0020a530:    59544441    ADTY    DCD    1498694721
        0x0020a534:    505f4550    PE_P    DCD    1348420944
        0x0020a538:    5245574f    OWER    DCD    1380276047
        0x0020a53c:    56454c5f    _LEV    DCD    1447382111
        0x0020a540:    203a4c45    EL:     DCD    540691525
        0x0020a544:    78257830    0x%x    DCD    2015721520
        0x0020a548:    00000a0d    ....    DCD    2573
        0x0020a54c:    5f504147    GAP_    DCD    1599095111
        0x0020a550:    59544441    ADTY    DCD    1498694721
        0x0020a554:    535f4550    PE_S    DCD    1398752592
        0x0020a558:    49565245    ERVI    DCD    1230393925
        0x0020a55c:    445f4543    CE_D    DCD    1147094339
        0x0020a560:    3a415441    ATA:    DCD    977359937
        0x0020a564:    49555520     UUI    DCD    1230329120
        0x0020a568:    78302044    D 0x    DCD    2016419908
        0x0020a56c:    202c7825    %x,     DCD    539785253
        0x0020a570:    206e656c    len     DCD    544105836
        0x0020a574:    202c6425    %d,     DCD    539780133
        0x0020a578:    61746164    data    DCD    1635017060
        0x0020a57c:    0d622520     %b.    DCD    224535840
        0x0020a580:    0000000a    ....    DCD    10
        0x0020a584:    5f504147    GAP_    DCD    1599095111
        0x0020a588:    59544441    ADTY    DCD    1498694721
        0x0020a58c:    415f4550    PE_A    DCD    1096762704
        0x0020a590:    41455050    PPEA    DCD    1095061584
        0x0020a594:    434e4152    RANC    DCD    1129202002
        0x0020a598:    25203a45    E: %    DCD    622869061
        0x0020a59c:    000a0d64    d...    DCD    658788
        0x0020a5a0:    0020ce90    .. .    DCD    2150032
        0x0020a5a4:    44412020      AD    DCD    1145118752
        0x0020a5a8:    74614420     Dat    DCD    1952531488
        0x0020a5ac:    55203a61    a: U    DCD    1428175457
        0x0020a5b0:    6e61686e    nhan    DCD    1851877486
        0x0020a5b4:    64656c64    dled    DCD    1684368484
        0x0020a5b8:    74614420     Dat    DCD    1952531488
        0x0020a5bc:    203d2061    a =     DCD    540876897
        0x0020a5c0:    78257830    0x%x    DCD    2015721520
        0x0020a5c4:    00000a0d    ....    DCD    2573
        0x0020a5c8:    2d2d2d2d    ----    DCD    757935405
        0x0020a5cc:    2d2d2d2d    ----    DCD    757935405
        0x0020a5d0:    2d2d2d2d    ----    DCD    757935405
        0x0020a5d4:    2d2d2d2d    ----    DCD    757935405
        0x0020a5d8:    2d2d2d2d    ----    DCD    757935405
        0x0020a5dc:    2d2d2d2d    ----    DCD    757935405
        0x0020a5e0:    2d2d2d2d    ----    DCD    757935405
        0x0020a5e4:    0a0d2d2d    --..    DCD    168635693
        0x0020a5e8:    00000000    ....    DCD    0
        0x0020a5ec:    34544d43    CMT4    DCD    877940035
        0x0020a5f0:    2d313035    501-    DCD    758198325
        0x0020a5f4:    30313161    a110    DCD    808530273
        0x0020a5f8:    32653530    05e2    DCD    845493552
        0x0020a5fc:    00000000    ....    DCD    0
        0x0020a600:    08801c5c    \...    DCD    142613596
        0x0020a604:    21300000    ..0!    DCD    556793856
        0x0020a608:    08801db0    ....    DCD    142613936
        0x0020a60c:    0020d374    t. .    DCD    2151284
        0x0020a610:    0020d3a3    .. .    DCD    2151331
    $t
;;;906                case DISC_GAPS_FAILED:
;;;907                    app_link_table[conn_id].discovered_flags |= APP_DISCOV_GAPS_FLAG;
        0x0020a614:    7841        Ax      LDRB     r1,[r0,#1]
        0x0020a616:    f0410101    A...    ORR      r1,r1,#1
        0x0020a61a:    7041        Ap      STRB     r1,[r0,#1]
;;;908                    app_discov_services(conn_id, false);
        0x0020a61c:    2100        .!      MOVS     r1,#0
        0x0020a61e:    4628        (F      MOV      r0,r5
        0x0020a620:    f7fffb43    ..C.    BL       app_discov_services ; 0x209caa
;;;909                    /* Discovery Request failed. */
;;;910                    APP_PRINT_INFO0("app_client_callback: discover gaps request failed.");
        0x0020a624:    2200        ."      MOVS     r2,#0
        0x0020a626:    49aa        .I      LDR      r1,[pc,#680] ; [0x20a8d0] = 0x8801e1c
;;;911                    break;
        0x0020a628:    e11f        ..      B        0x20a86a ; app_client_callback + 1172
;;;912                default:
;;;913                    break;
;;;914                }
;;;915                break;
;;;916            case GAPS_CLIENT_CB_TYPE_READ_RESULT:
;;;917                switch (p_gaps_cb_data->cb_content.read_result.type)
        0x0020a62a:    7920         y      LDRB     r0,[r4,#4]
        0x0020a62c:    b120         .      CBZ      r0,0x20a638 ; app_client_callback + 610
        0x0020a62e:    2801        .(      CMP      r0,#1
        0x0020a630:    d01a        ..      BEQ      0x20a668 ; app_client_callback + 658
        0x0020a632:    2802        .(      CMP      r0,#2
        0x0020a634:    d117        ..      BNE      0x20a666 ; app_client_callback + 656
        0x0020a636:    e022        ".      B        0x20a67e ; app_client_callback + 680
;;;918                {
;;;919                case GAPS_READ_DEVICE_NAME:
;;;920                    if (p_gaps_cb_data->cb_content.read_result.cause == GAP_SUCCESS)
        0x0020a638:    8a23        #.      LDRH     r3,[r4,#0x10]
        0x0020a63a:    b11b        ..      CBZ      r3,0x20a644 ; app_client_callback + 622
        0x0020a63c:    49a4        .I      LDR      r1,[pc,#656] ; [0x20a8d0] = 0x8801e1c
        0x0020a63e:    2201        ."      MOVS     r2,#1
        0x0020a640:    3164        d1      ADDS     r1,r1,#0x64
        0x0020a642:    e020         .      B        0x20a686 ; app_client_callback + 688
;;;921                    {
;;;922                        APP_PRINT_INFO1("GAPS_READ_DEVICE_NAME: device name %s.",
        0x0020a644:    f04f5005    O..P    MOV      r0,#0x21400000
        0x0020a648:    68e1        .h      LDR      r1,[r4,#0xc]
        0x0020a64a:    f5fdfc0e    ....    BL       trace_string ; 0x7e6a
        0x0020a64e:    49a0        .I      LDR      r1,[pc,#640] ; [0x20a8d0] = 0x8801e1c
        0x0020a650:    4603        .F      MOV      r3,r0
        0x0020a652:    2201        ."      MOVS     r2,#1
        0x0020a654:    3138        81      ADDS     r1,r1,#0x38
        0x0020a656:    4640        @F      MOV      r0,r8
        0x0020a658:    f5fdfa01    ....    BL       log_buffer ; 0x7a5e
;;;923                                        TRACE_STRING(p_gaps_cb_data->cb_content.read_result.data.device_name.p_value));
;;;924    					data_uart_print("#gapread#!%d!@%s@<Y>\r\n",conn_id,p_gaps_cb_data->cb_content.read_result.data.device_name.p_value);
        0x0020a65c:    4629        )F      MOV      r1,r5
        0x0020a65e:    a09d        ..      ADR      r0,{pc}+0x276 ; 0x20a8d4
        0x0020a660:    68e2        .h      LDR      r2,[r4,#0xc]
        0x0020a662:    f000fadd    ....    BL       data_uart_print ; 0x20ac20
        0x0020a666:    e121        !.      B        0x20a8ac ; app_client_callback + 1238
;;;925    
;;;926                    }
;;;927                    else
;;;928                    {
;;;929                        APP_PRINT_INFO1("GAPS_READ_DEVICE_NAME: failded cause 0x%x",
;;;930                                        p_gaps_cb_data->cb_content.read_result.cause);
;;;931                    }
;;;932                    break;
;;;933                case GAPS_READ_APPEARANCE:
;;;934                    if (p_gaps_cb_data->cb_content.read_result.cause == GAP_SUCCESS)
        0x0020a668:    8a23        #.      LDRH     r3,[r4,#0x10]
        0x0020a66a:    b11b        ..      CBZ      r3,0x20a674 ; app_client_callback + 670
        0x0020a66c:    4998        .I      LDR      r1,[pc,#608] ; [0x20a8d0] = 0x8801e1c
        0x0020a66e:    2201        ."      MOVS     r2,#1
        0x0020a670:    31bc        .1      ADDS     r1,r1,#0xbc
        0x0020a672:    e008        ..      B        0x20a686 ; app_client_callback + 688
;;;935                    {
;;;936                        APP_PRINT_INFO1("GAPS_READ_APPEARANCE: appearance %d",
        0x0020a674:    4996        .I      LDR      r1,[pc,#600] ; [0x20a8d0] = 0x8801e1c
        0x0020a676:    2201        ."      MOVS     r2,#1
        0x0020a678:    8923        #.      LDRH     r3,[r4,#8]
        0x0020a67a:    3194        .1      ADDS     r1,r1,#0x94
        0x0020a67c:    e003        ..      B        0x20a686 ; app_client_callback + 688
;;;937                                        p_gaps_cb_data->cb_content.read_result.data.appearance);
;;;938                    }
;;;939                    else
;;;940                    {
;;;941                        APP_PRINT_INFO1("GAPS_READ_APPEARANCE: failded cause 0x%x",
;;;942                                        p_gaps_cb_data->cb_content.read_result.cause);
;;;943                    }
;;;944                    break;
;;;945                case GAPS_READ_CENTRAL_ADDR_RESOLUTION:
;;;946                    if (p_gaps_cb_data->cb_content.read_result.cause == GAP_SUCCESS)
        0x0020a67e:    8a23        #.      LDRH     r3,[r4,#0x10]
        0x0020a680:    b11b        ..      CBZ      r3,0x20a68a ; app_client_callback + 692
        0x0020a682:    499a        .I      LDR      r1,[pc,#616] ; [0x20a8ec] = 0x8801f40
        0x0020a684:    2201        ."      MOVS     r2,#1
        0x0020a686:    4640        @F      MOV      r0,r8
        0x0020a688:    e05d        ].      B        0x20a746 ; app_client_callback + 880
;;;947                    {
;;;948                        APP_PRINT_INFO1("GAPS_READ_CENTRAL_ADDR_RESOLUTION: central_addr_res %d",
        0x0020a68a:    4998        .I      LDR      r1,[pc,#608] ; [0x20a8ec] = 0x8801f40
        0x0020a68c:    2201        ."      MOVS     r2,#1
        0x0020a68e:    7a23        #z      LDRB     r3,[r4,#8]
        0x0020a690:    393c        <9      SUBS     r1,r1,#0x3c
        0x0020a692:    e7f8        ..      B        0x20a686 ; app_client_callback + 688
;;;949                                        p_gaps_cb_data->cb_content.read_result.data.central_addr_res);
;;;950                    }
;;;951                    else
;;;952                    {
;;;953                        APP_PRINT_INFO1("GAPS_READ_CENTRAL_ADDR_RESOLUTION: failded cause 0x%x",
;;;954                                        p_gaps_cb_data->cb_content.read_result.cause);
;;;955                    }
;;;956                    break;
;;;957                default:
;;;958                    break;
;;;959                }
;;;960                break;
;;;961    
;;;962            default:
;;;963                break;
;;;964            }
;;;965        }
;;;966        else if (client_id == simple_ble_client_id)
        0x0020a694:    784a        Jx      LDRB     r2,[r1,#1]
        0x0020a696:    f8dfc258    ..X.    LDR      r12,[pc,#600] ; [0x20a8f0] = 0x21103000
        0x0020a69a:    4297        .B      CMP      r7,r2
        0x0020a69c:    d171        q.      BNE      0x20a782 ; app_client_callback + 940
;;;967        {
;;;968            T_SIMP_CLIENT_CB_DATA *p_simp_client_cb_data = (T_SIMP_CLIENT_CB_DATA *)p_data;
;;;969            uint16_t value_size;
;;;970            uint8_t *p_value;
;;;971            switch (p_simp_client_cb_data->cb_type)
        0x0020a69e:    7821        !x      LDRB     r1,[r4,#0]
        0x0020a6a0:    b139        9.      CBZ      r1,0x20a6b2 ; app_client_callback + 732
        0x0020a6a2:    4894        .H      LDR      r0,[pc,#592] ; [0x20a8f4] = 0x21500000
        0x0020a6a4:    2901        .)      CMP      r1,#1
        0x0020a6a6:    d026        &.      BEQ      0x20a6f6 ; app_client_callback + 800
        0x0020a6a8:    2902        .)      CMP      r1,#2
        0x0020a6aa:    d054        T.      BEQ      0x20a756 ; app_client_callback + 896
        0x0020a6ac:    2903        .)      CMP      r1,#3
        0x0020a6ae:    d1da        ..      BNE      0x20a666 ; app_client_callback + 656
        0x0020a6b0:    e068        h.      B        0x20a784 ; app_client_callback + 942
;;;972            {
;;;973            case SIMP_CLIENT_CB_TYPE_DISC_STATE:
;;;974                switch (p_simp_client_cb_data->cb_content.disc_state)
        0x0020a6b2:    7921        !y      LDRB     r1,[r4,#4]
        0x0020a6b4:    2902        .)      CMP      r1,#2
        0x0020a6b6:    d002        ..      BEQ      0x20a6be ; app_client_callback + 744
        0x0020a6b8:    2903        .)      CMP      r1,#3
        0x0020a6ba:    d1d4        ..      BNE      0x20a666 ; app_client_callback + 656
        0x0020a6bc:    e00f        ..      B        0x20a6de ; app_client_callback + 776
;;;975                {
;;;976                case DISC_SIMP_DONE:
;;;977                    /* Discovery Simple BLE service procedure successfully done. */
;;;978                    app_link_table[conn_id].discovered_flags |= APP_DISCOV_SIMP_FLAG;
        0x0020a6be:    7841        Ax      LDRB     r1,[r0,#1]
        0x0020a6c0:    f0410102    A...    ORR      r1,r1,#2
        0x0020a6c4:    7041        Ap      STRB     r1,[r0,#1]
;;;979                    app_link_table[conn_id].srv_found_flags |= APP_DISCOV_SIMP_FLAG;
        0x0020a6c6:    7881        .x      LDRB     r1,[r0,#2]
        0x0020a6c8:    f0410102    A...    ORR      r1,r1,#2
        0x0020a6cc:    7081        .p      STRB     r1,[r0,#2]
;;;980                    app_discov_services(conn_id, false);
        0x0020a6ce:    2100        .!      MOVS     r1,#0
        0x0020a6d0:    4628        (F      MOV      r0,r5
        0x0020a6d2:    f7fffaea    ....    BL       app_discov_services ; 0x209caa
;;;981                    APP_PRINT_INFO0("app_client_callback: discover simp procedure done.");
        0x0020a6d6:    4985        .I      LDR      r1,[pc,#532] ; [0x20a8ec] = 0x8801f40
        0x0020a6d8:    2200        ."      MOVS     r2,#0
        0x0020a6da:    313c        <1      ADDS     r1,r1,#0x3c
;;;982                    break;
        0x0020a6dc:    e0c5        ..      B        0x20a86a ; app_client_callback + 1172
;;;983                case DISC_SIMP_FAILED:
;;;984                    /* Discovery Request failed. */
;;;985                    app_link_table[conn_id].discovered_flags |= APP_DISCOV_SIMP_FLAG;
        0x0020a6de:    7841        Ax      LDRB     r1,[r0,#1]
        0x0020a6e0:    f0410102    A...    ORR      r1,r1,#2
        0x0020a6e4:    7041        Ap      STRB     r1,[r0,#1]
;;;986                    app_discov_services(conn_id, false);
        0x0020a6e6:    2100        .!      MOVS     r1,#0
        0x0020a6e8:    4628        (F      MOV      r0,r5
        0x0020a6ea:    f7fffade    ....    BL       app_discov_services ; 0x209caa
;;;987                    APP_PRINT_INFO0("app_client_callback: discover simp request failed.");
        0x0020a6ee:    497f        .I      LDR      r1,[pc,#508] ; [0x20a8ec] = 0x8801f40
        0x0020a6f0:    2200        ."      MOVS     r2,#0
        0x0020a6f2:    3174        t1      ADDS     r1,r1,#0x74
;;;988                    break;
        0x0020a6f4:    e0b9        ..      B        0x20a86a ; app_client_callback + 1172
;;;989                default:
;;;990                    break;
;;;991                }
;;;992                break;
;;;993            case SIMP_CLIENT_CB_TYPE_READ_RESULT:
;;;994                switch (p_simp_client_cb_data->cb_content.read_result.type)
        0x0020a6f6:    7921        !y      LDRB     r1,[r4,#4]
        0x0020a6f8:    b121        !.      CBZ      r1,0x20a704 ; app_client_callback + 814
        0x0020a6fa:    2901        .)      CMP      r1,#1
        0x0020a6fc:    d013        ..      BEQ      0x20a726 ; app_client_callback + 848
        0x0020a6fe:    2902        .)      CMP      r1,#2
        0x0020a700:    d1b1        ..      BNE      0x20a666 ; app_client_callback + 656
        0x0020a702:    e01a        ..      B        0x20a73a ; app_client_callback + 868
;;;995                {
;;;996                case SIMP_READ_V1_READ:
;;;997                    if (p_simp_client_cb_data->cb_content.read_result.cause == GAP_SUCCESS)
        0x0020a704:    8a23        #.      LDRH     r3,[r4,#0x10]
        0x0020a706:    b11b        ..      CBZ      r3,0x20a710 ; app_client_callback + 826
        0x0020a708:    4978        xI      LDR      r1,[pc,#480] ; [0x20a8ec] = 0x8801f40
        0x0020a70a:    2201        ."      MOVS     r2,#1
        0x0020a70c:    31dc        .1      ADDS     r1,r1,#0xdc
        0x0020a70e:    e019        ..      B        0x20a744 ; app_client_callback + 878
;;;998                    {
;;;999                        value_size = p_simp_client_cb_data->cb_content.read_result.data.v1_read.value_size;
        0x0020a710:    8925        %.      LDRH     r5,[r4,#8]
;;;1000                       p_value = p_simp_client_cb_data->cb_content.read_result.data.v1_read.p_value;
;;;1001                       APP_PRINT_INFO2("SIMP_READ_V1_READ: value_size %d, value %b",
        0x0020a712:    68e2        .h      LDR      r2,[r4,#0xc]
        0x0020a714:    4629        )F      MOV      r1,r5
        0x0020a716:    f5fdfbf8    ....    BL       trace_binary ; 0x7f0a
        0x0020a71a:    4974        tI      LDR      r1,[pc,#464] ; [0x20a8ec] = 0x8801f40
        0x0020a71c:    2202        ."      MOVS     r2,#2
        0x0020a71e:    462b        +F      MOV      r3,r5
        0x0020a720:    31ac        .1      ADDS     r1,r1,#0xac
        0x0020a722:    9000        ..      STR      r0,[sp,#0]
        0x0020a724:    e070        p.      B        0x20a808 ; app_client_callback + 1074
;;;1002                                       value_size, TRACE_BINARY(value_size, p_value));
;;;1003                   }
;;;1004                   else
;;;1005                   {
;;;1006                       APP_PRINT_ERROR1("SIMP_READ_V1_READ: failed cause 0x%x",
;;;1007                                        p_simp_client_cb_data->cb_content.read_result.cause);
;;;1008                   }
;;;1009                   break;
;;;1010               case SIMP_READ_V3_NOTIFY_CCCD:
;;;1011                   if (p_simp_client_cb_data->cb_content.read_result.cause == GAP_SUCCESS)
        0x0020a726:    8a23        #.      LDRH     r3,[r4,#0x10]
        0x0020a728:    b113        ..      CBZ      r3,0x20a730 ; app_client_callback + 858
        0x0020a72a:    2201        ."      MOVS     r2,#1
        0x0020a72c:    4972        rI      LDR      r1,[pc,#456] ; [0x20a8f8] = 0x880206c
        0x0020a72e:    e009        ..      B        0x20a744 ; app_client_callback + 878
;;;1012                   {
;;;1013                       APP_PRINT_INFO1("SIMP_READ_V3_NOTIFY_CCCD: notify %d",
        0x0020a730:    4971        qI      LDR      r1,[pc,#452] ; [0x20a8f8] = 0x880206c
        0x0020a732:    2201        ."      MOVS     r2,#1
        0x0020a734:    7a23        #z      LDRB     r3,[r4,#8]
        0x0020a736:    3928        (9      SUBS     r1,r1,#0x28
        0x0020a738:    e7a5        ..      B        0x20a686 ; app_client_callback + 688
;;;1014                                       p_simp_client_cb_data->cb_content.read_result.data.v3_notify_cccd);
;;;1015                   }
;;;1016                   else
;;;1017                   {
;;;1018                       APP_PRINT_ERROR1("SIMP_READ_V3_NOTIFY_CCCD: failed cause 0x%x",
;;;1019                                        p_simp_client_cb_data->cb_content.read_result.cause);
;;;1020                   };
;;;1021                   break;
;;;1022               case SIMP_READ_V4_INDICATE_CCCD:
;;;1023                   if (p_simp_client_cb_data->cb_content.read_result.cause == GAP_SUCCESS)
        0x0020a73a:    8a23        #.      LDRH     r3,[r4,#0x10]
        0x0020a73c:    b133        3.      CBZ      r3,0x20a74c ; app_client_callback + 886
        0x0020a73e:    496e        nI      LDR      r1,[pc,#440] ; [0x20a8f8] = 0x880206c
        0x0020a740:    2201        ."      MOVS     r2,#1
        0x0020a742:    315c        \1      ADDS     r1,r1,#0x5c
        0x0020a744:    4660        `F      MOV      r0,r12
        0x0020a746:    f5fdf98a    ....    BL       log_buffer ; 0x7a5e
        0x0020a74a:    e0af        ..      B        0x20a8ac ; app_client_callback + 1238
;;;1024                   {
;;;1025                       APP_PRINT_INFO1("SIMP_READ_V4_INDICATE_CCCD: indicate %d",
        0x0020a74c:    496a        jI      LDR      r1,[pc,#424] ; [0x20a8f8] = 0x880206c
        0x0020a74e:    2201        ."      MOVS     r2,#1
        0x0020a750:    7a23        #z      LDRB     r3,[r4,#8]
        0x0020a752:    3130        01      ADDS     r1,r1,#0x30
        0x0020a754:    e797        ..      B        0x20a686 ; app_client_callback + 688
;;;1026                                       p_simp_client_cb_data->cb_content.read_result.data.v4_indicate_cccd);
;;;1027                   }
;;;1028                   else
;;;1029                   {
;;;1030                       APP_PRINT_ERROR1("SIMP_READ_V4_INDICATE_CCCD: failed cause 0x%x",
;;;1031                                        p_simp_client_cb_data->cb_content.read_result.cause);
;;;1032                   };
;;;1033                   break;
;;;1034   
;;;1035               default:
;;;1036                   break;
;;;1037               }
;;;1038               break;
;;;1039           case SIMP_CLIENT_CB_TYPE_WRITE_RESULT:
;;;1040               switch (p_simp_client_cb_data->cb_content.write_result.type)
        0x0020a756:    7920         y      LDRB     r0,[r4,#4]
        0x0020a758:    b120         .      CBZ      r0,0x20a764 ; app_client_callback + 910
        0x0020a75a:    2801        .(      CMP      r0,#1
        0x0020a75c:    d007        ..      BEQ      0x20a76e ; app_client_callback + 920
        0x0020a75e:    2802        .(      CMP      r0,#2
        0x0020a760:    d147        G.      BNE      0x20a7f2 ; app_client_callback + 1052
        0x0020a762:    e009        ..      B        0x20a778 ; app_client_callback + 930
;;;1041               {
;;;1042               case SIMP_WRITE_V2_WRITE:
;;;1043                   APP_PRINT_INFO1("SIMP_WRITE_V2_WRITE: write result 0x%x",
        0x0020a764:    4964        dI      LDR      r1,[pc,#400] ; [0x20a8f8] = 0x880206c
        0x0020a766:    2201        ."      MOVS     r2,#1
        0x0020a768:    88e3        ..      LDRH     r3,[r4,#6]
        0x0020a76a:    3190        .1      ADDS     r1,r1,#0x90
;;;1044                                   p_simp_client_cb_data->cb_content.write_result.cause);
;;;1045                   break;
        0x0020a76c:    e78b        ..      B        0x20a686 ; app_client_callback + 688
;;;1046               case SIMP_WRITE_V3_NOTIFY_CCCD:
;;;1047                   APP_PRINT_INFO1("SIMP_WRITE_V3_NOTIFY_CCCD: write result 0x%x",
        0x0020a76e:    4962        bI      LDR      r1,[pc,#392] ; [0x20a8f8] = 0x880206c
        0x0020a770:    2201        ."      MOVS     r2,#1
        0x0020a772:    88e3        ..      LDRH     r3,[r4,#6]
        0x0020a774:    31bc        .1      ADDS     r1,r1,#0xbc
;;;1048                                   p_simp_client_cb_data->cb_content.write_result.cause);
;;;1049                   break;
        0x0020a776:    e786        ..      B        0x20a686 ; app_client_callback + 688
;;;1050               case SIMP_WRITE_V4_INDICATE_CCCD:
;;;1051                   APP_PRINT_INFO1("SIMP_WRITE_V4_INDICATE_CCCD: write result 0x%x",
        0x0020a778:    495f        _I      LDR      r1,[pc,#380] ; [0x20a8f8] = 0x880206c
        0x0020a77a:    2201        ."      MOVS     r2,#1
        0x0020a77c:    88e3        ..      LDRH     r3,[r4,#6]
        0x0020a77e:    31ec        .1      ADDS     r1,r1,#0xec
;;;1052                                   p_simp_client_cb_data->cb_content.write_result.cause);
;;;1053                   break;
        0x0020a780:    e781        ..      B        0x20a686 ; app_client_callback + 688
        0x0020a782:    e045        E.      B        0x20a810 ; app_client_callback + 1082
;;;1054               default:
;;;1055                   break;
;;;1056               }
;;;1057               break;
;;;1058           case SIMP_CLIENT_CB_TYPE_NOTIF_IND_RESULT:
;;;1059               switch (p_simp_client_cb_data->cb_content.notif_ind_data.type)
        0x0020a784:    7921        !y      LDRB     r1,[r4,#4]
        0x0020a786:    b111        ..      CBZ      r1,0x20a78e ; app_client_callback + 952
        0x0020a788:    2901        .)      CMP      r1,#1
        0x0020a78a:    d132        2.      BNE      0x20a7f2 ; app_client_callback + 1052
        0x0020a78c:    e032        2.      B        0x20a7f4 ; app_client_callback + 1054
;;;1060               {
;;;1061               case SIMP_V3_NOTIFY:
;;;1062                   value_size = p_simp_client_cb_data->cb_content.notif_ind_data.data.value_size;
        0x0020a78e:    8927        '.      LDRH     r7,[r4,#8]
;;;1063                   p_value = p_simp_client_cb_data->cb_content.notif_ind_data.data.p_value;
        0x0020a790:    68e4        .h      LDR      r4,[r4,#0xc]
;;;1064   //by vsop for notify				
;;;1065                   APP_PRINT_INFO2("SIMP_V3_NOTIFY: value_size %d, value %b",
        0x0020a792:    4639        9F      MOV      r1,r7
        0x0020a794:    4622        "F      MOV      r2,r4
        0x0020a796:    f5fdfbb8    ....    BL       trace_binary ; 0x7f0a
        0x0020a79a:    9000        ..      STR      r0,[sp,#0]
        0x0020a79c:    463b        ;F      MOV      r3,r7
        0x0020a79e:    2202        ."      MOVS     r2,#2
        0x0020a7a0:    4956        VI      LDR      r1,[pc,#344] ; [0x20a8fc] = 0x880218c
        0x0020a7a2:    4640        @F      MOV      r0,r8
        0x0020a7a4:    f5fdf95b    ..[.    BL       log_buffer ; 0x7a5e
;;;1066                                   value_size, TRACE_BINARY(value_size, p_value));
;;;1067   				#if 0
;;;1068   				data_uart_print("#notify#!%d![]@%d{ ",conn_id,value_size);
;;;1069   				for(uint16_t i=0;i<value_size;i++)
;;;1070   				{
;;;1071   					sprintf(temp,"%02X",p_value[i]);
;;;1072   					data_uart_print("%s ",temp);					
;;;1073   				}
;;;1074   				data_uart_print("}\r\n");				
;;;1075   				#else
;;;1076   				if(value_size>FRAMING_PAYLOAD_MAX_LENGTH)value_size=FRAMING_PAYLOAD_MAX_LENGTH;
        0x0020a7a8:    f44f70fb    O..p    MOV      r0,#0x1f6
        0x0020a7ac:    4287        .B      CMP      r7,r0
        0x0020a7ae:    d900        ..      BLS      0x20a7b2 ; app_client_callback + 988
        0x0020a7b0:    4607        .F      MOV      r7,r0
;;;1077   				sprintf(cmd_buffer,"#notify#!%d![]@%d{ ",conn_id,value_size);
        0x0020a7b2:    463b        ;F      MOV      r3,r7
        0x0020a7b4:    462a        *F      MOV      r2,r5
        0x0020a7b6:    a152        R.      ADR      r1,{pc}+0x14a ; 0x20a900
        0x0020a7b8:    4856        VH      LDR      r0,[pc,#344] ; [0x20a914] = 0x20d170
        0x0020a7ba:    f001fac9    ....    BL       __2sprintf ; 0x20bd50
;;;1078   				for(uint16_t i=0;i<value_size;i++)
        0x0020a7be:    2500        .%      MOVS     r5,#0
        0x0020a7c0:    e00a        ..      B        0x20a7d8 ; app_client_callback + 1026
        0x0020a7c2:    5d62        b]      LDRB     r2,[r4,r5]
        0x0020a7c4:    a154        T.      ADR      r1,{pc}+0x154 ; 0x20a918
        0x0020a7c6:    a801        ..      ADD      r0,sp,#4
        0x0020a7c8:    f001fac2    ....    BL       __2sprintf ; 0x20bd50
        0x0020a7cc:    a901        ..      ADD      r1,sp,#4
        0x0020a7ce:    4851        QH      LDR      r0,[pc,#324] ; [0x20a914] = 0x20d170
        0x0020a7d0:    f011ffb1    ....    BL       strcat ; 0x21c736
        0x0020a7d4:    1c6d        m.      ADDS     r5,r5,#1
        0x0020a7d6:    b2ad        ..      UXTH     r5,r5
        0x0020a7d8:    42bd        .B      CMP      r5,r7
        0x0020a7da:    d3f2        ..      BCC      0x20a7c2 ; app_client_callback + 1004
;;;1079   				{
;;;1080   					sprintf(temp,"%02X",p_value[i]);
;;;1081   					strcat(cmd_buffer,temp);					
;;;1082   				}
;;;1083   				strcat(cmd_buffer,"}\r\n");
        0x0020a7dc:    a150        P.      ADR      r1,{pc}+0x144 ; 0x20a920
        0x0020a7de:    484d        MH      LDR      r0,[pc,#308] ; [0x20a914] = 0x20d170
        0x0020a7e0:    f011ffa9    ....    BL       strcat ; 0x21c736
;;;1084   				FramingWrapFrameUartPrint((uint8_t *)cmd_buffer, strlen(cmd_buffer));
        0x0020a7e4:    484b        KH      LDR      r0,[pc,#300] ; [0x20a914] = 0x20d170
        0x0020a7e6:    f64ffb39    O.9.    BL       strlen ; 0x59e5c
        0x0020a7ea:    b281        ..      UXTH     r1,r0
        0x0020a7ec:    4849        IH      LDR      r0,[pc,#292] ; [0x20a914] = 0x20d170
        0x0020a7ee:    f000fa32    ..2.    BL       FramingWrapFrameUartPrint ; 0x20ac56
;;;1085   				#endif
;;;1086                   break;
        0x0020a7f2:    e05b        [.      B        0x20a8ac ; app_client_callback + 1238
;;;1087               case SIMP_V4_INDICATE:
;;;1088                   value_size = p_simp_client_cb_data->cb_content.notif_ind_data.data.value_size;
        0x0020a7f4:    8925        %.      LDRH     r5,[r4,#8]
;;;1089                   p_value = p_simp_client_cb_data->cb_content.notif_ind_data.data.p_value;
;;;1090                   APP_PRINT_INFO2("SIMP_V4_INDICATE: value_size %d, value %b",
        0x0020a7f6:    68e2        .h      LDR      r2,[r4,#0xc]
        0x0020a7f8:    4629        )F      MOV      r1,r5
        0x0020a7fa:    f5fdfb86    ....    BL       trace_binary ; 0x7f0a
        0x0020a7fe:    493f        ?I      LDR      r1,[pc,#252] ; [0x20a8fc] = 0x880218c
        0x0020a800:    2202        ."      MOVS     r2,#2
        0x0020a802:    462b        +F      MOV      r3,r5
        0x0020a804:    312c        ,1      ADDS     r1,r1,#0x2c
        0x0020a806:    9000        ..      STR      r0,[sp,#0]
        0x0020a808:    4640        @F      MOV      r0,r8
        0x0020a80a:    f5fdf928    ..(.    BL       log_buffer ; 0x7a5e
        0x0020a80e:    e04d        M.      B        0x20a8ac ; app_client_callback + 1238
;;;1091                                   value_size, TRACE_BINARY(value_size, p_value));
;;;1092                   break;
;;;1093               default:
;;;1094                   break;
;;;1095               }
;;;1096               break;
;;;1097   
;;;1098           default:
;;;1099               break;
;;;1100           }
;;;1101       }
;;;1102       else if (client_id == bas_client_id)
        0x0020a810:    78c9        .x      LDRB     r1,[r1,#3]
        0x0020a812:    428f        .B      CMP      r7,r1
        0x0020a814:    d14a        J.      BNE      0x20a8ac ; app_client_callback + 1238
;;;1103       {
;;;1104           T_BAS_CLIENT_CB_DATA *p_bas_cb_data = (T_BAS_CLIENT_CB_DATA *)p_data;
;;;1105           switch (p_bas_cb_data->cb_type)
        0x0020a816:    7821        !x      LDRB     r1,[r4,#0]
        0x0020a818:    b131        1.      CBZ      r1,0x20a828 ; app_client_callback + 1106
        0x0020a81a:    2901        .)      CMP      r1,#1
        0x0020a81c:    d029        ).      BEQ      0x20a872 ; app_client_callback + 1180
        0x0020a81e:    2902        .)      CMP      r1,#2
        0x0020a820:    d040        @.      BEQ      0x20a8a4 ; app_client_callback + 1230
        0x0020a822:    2903        .)      CMP      r1,#3
        0x0020a824:    d142        B.      BNE      0x20a8ac ; app_client_callback + 1238
        0x0020a826:    e04e        N.      B        0x20a8c6 ; app_client_callback + 1264
;;;1106           {
;;;1107           case BAS_CLIENT_CB_TYPE_DISC_STATE:
;;;1108               switch (p_bas_cb_data->cb_content.disc_state)
        0x0020a828:    78a1        .x      LDRB     r1,[r4,#2]
        0x0020a82a:    2902        .)      CMP      r1,#2
        0x0020a82c:    d002        ..      BEQ      0x20a834 ; app_client_callback + 1118
        0x0020a82e:    2903        .)      CMP      r1,#3
        0x0020a830:    d13c        <.      BNE      0x20a8ac ; app_client_callback + 1238
        0x0020a832:    e00f        ..      B        0x20a854 ; app_client_callback + 1150
;;;1109               {
;;;1110               case DISC_BAS_DONE:
;;;1111                   /* Discovery BAS procedure successfully done. */
;;;1112                   app_link_table[conn_id].discovered_flags |= APP_DISCOV_BAS_FLAG;
        0x0020a834:    7841        Ax      LDRB     r1,[r0,#1]
        0x0020a836:    f0410104    A...    ORR      r1,r1,#4
        0x0020a83a:    7041        Ap      STRB     r1,[r0,#1]
;;;1113                   app_link_table[conn_id].srv_found_flags |= APP_DISCOV_BAS_FLAG;
        0x0020a83c:    7881        .x      LDRB     r1,[r0,#2]
        0x0020a83e:    f0410104    A...    ORR      r1,r1,#4
        0x0020a842:    7081        .p      STRB     r1,[r0,#2]
;;;1114                   app_discov_services(conn_id, false);
        0x0020a844:    2100        .!      MOVS     r1,#0
        0x0020a846:    4628        (F      MOV      r0,r5
        0x0020a848:    f7fffa2f    ../.    BL       app_discov_services ; 0x209caa
;;;1115                   APP_PRINT_INFO0("app_client_callback: discover bas procedure done");
        0x0020a84c:    492b        +I      LDR      r1,[pc,#172] ; [0x20a8fc] = 0x880218c
        0x0020a84e:    2200        ."      MOVS     r2,#0
        0x0020a850:    315c        \1      ADDS     r1,r1,#0x5c
;;;1116                   break;
        0x0020a852:    e00a        ..      B        0x20a86a ; app_client_callback + 1172
;;;1117               case DISC_BAS_FAILED:
;;;1118                   /* Discovery Request failed. */
;;;1119                   app_link_table[conn_id].discovered_flags |= APP_DISCOV_BAS_FLAG;
        0x0020a854:    7841        Ax      LDRB     r1,[r0,#1]
        0x0020a856:    f0410104    A...    ORR      r1,r1,#4
        0x0020a85a:    7041        Ap      STRB     r1,[r0,#1]
;;;1120                   app_discov_services(conn_id, false);
        0x0020a85c:    2100        .!      MOVS     r1,#0
        0x0020a85e:    4628        (F      MOV      r0,r5
        0x0020a860:    f7fffa23    ..#.    BL       app_discov_services ; 0x209caa
;;;1121                   APP_PRINT_INFO0("app_client_callback: discover bas procedure failed");
        0x0020a864:    4925        %I      LDR      r1,[pc,#148] ; [0x20a8fc] = 0x880218c
        0x0020a866:    2200        ."      MOVS     r2,#0
        0x0020a868:    3190        .1      ADDS     r1,r1,#0x90
        0x0020a86a:    4640        @F      MOV      r0,r8
        0x0020a86c:    f5fdf8f7    ....    BL       log_buffer ; 0x7a5e
        0x0020a870:    e01c        ..      B        0x20a8ac ; app_client_callback + 1238
;;;1122                   break;
;;;1123               default:
;;;1124                   break;
;;;1125               }
;;;1126               break;
;;;1127           case BAS_CLIENT_CB_TYPE_READ_RESULT:
;;;1128               switch (p_bas_cb_data->cb_content.read_result.type)
        0x0020a872:    78a0        .x      LDRB     r0,[r4,#2]
        0x0020a874:    b160        `.      CBZ      r0,0x20a890 ; app_client_callback + 1210
        0x0020a876:    2801        .(      CMP      r0,#1
        0x0020a878:    d118        ..      BNE      0x20a8ac ; app_client_callback + 1238
;;;1129               {
;;;1130               case BAS_READ_BATTERY_LEVEL:
;;;1131                   if (p_bas_cb_data->cb_content.read_result.cause == GAP_SUCCESS)
        0x0020a87a:    88a3        ..      LDRH     r3,[r4,#4]
        0x0020a87c:    b11b        ..      CBZ      r3,0x20a886 ; app_client_callback + 1200
        0x0020a87e:    491f        .I      LDR      r1,[pc,#124] ; [0x20a8fc] = 0x880218c
        0x0020a880:    2201        ."      MOVS     r2,#1
        0x0020a882:    31f4        .1      ADDS     r1,r1,#0xf4
        0x0020a884:    e75e        ^.      B        0x20a744 ; app_client_callback + 878
;;;1132                   {
;;;1133                       APP_PRINT_INFO1("BAS_READ_BATTERY_LEVEL: battery level %d",
        0x0020a886:    491d        .I      LDR      r1,[pc,#116] ; [0x20a8fc] = 0x880218c
        0x0020a888:    2201        ."      MOVS     r2,#1
        0x0020a88a:    78e3        .x      LDRB     r3,[r4,#3]
        0x0020a88c:    31c8        .1      ADDS     r1,r1,#0xc8
        0x0020a88e:    e6fa        ..      B        0x20a686 ; app_client_callback + 688
;;;1134                                       p_bas_cb_data->cb_content.read_result.data.battery_level);
;;;1135                   }
;;;1136                   else
;;;1137                   {
;;;1138                       APP_PRINT_ERROR1("BAS_READ_BATTERY_LEVEL: failed cause 0x%x",
;;;1139                                        p_bas_cb_data->cb_content.read_result.cause);
;;;1140                   }
;;;1141                   break;
;;;1142               case BAS_READ_NOTIFY:
;;;1143                   if (p_bas_cb_data->cb_content.read_result.cause == GAP_SUCCESS)
        0x0020a890:    88a3        ..      LDRH     r3,[r4,#4]
        0x0020a892:    b113        ..      CBZ      r3,0x20a89a ; app_client_callback + 1220
        0x0020a894:    2201        ."      MOVS     r2,#1
        0x0020a896:    4923        #I      LDR      r1,[pc,#140] ; [0x20a924] = 0x88022d0
        0x0020a898:    e754        T.      B        0x20a744 ; app_client_callback + 878
;;;1144                   {
;;;1145                       APP_PRINT_INFO1("BAS_READ_NOTIFY: notify %d",
        0x0020a89a:    4922        "I      LDR      r1,[pc,#136] ; [0x20a924] = 0x88022d0
        0x0020a89c:    2201        ."      MOVS     r2,#1
        0x0020a89e:    78e3        .x      LDRB     r3,[r4,#3]
        0x0020a8a0:    3920         9      SUBS     r1,r1,#0x20
        0x0020a8a2:    e6f0        ..      B        0x20a686 ; app_client_callback + 688
;;;1146                                       p_bas_cb_data->cb_content.read_result.data.notify);
;;;1147                   }
;;;1148                   else
;;;1149                   {
;;;1150                       APP_PRINT_ERROR1("BAS_READ_NOTIFY: failed cause 0x%x",
;;;1151                                        p_bas_cb_data->cb_content.read_result.cause);
;;;1152                   };
;;;1153                   break;
;;;1154   
;;;1155               default:
;;;1156                   break;
;;;1157               }
;;;1158               break;
;;;1159           case BAS_CLIENT_CB_TYPE_WRITE_RESULT:
;;;1160               switch (p_bas_cb_data->cb_content.write_result.type)
        0x0020a8a4:    78a0        .x      LDRB     r0,[r4,#2]
        0x0020a8a6:    b120         .      CBZ      r0,0x20a8b2 ; app_client_callback + 1244
        0x0020a8a8:    2801        .(      CMP      r0,#1
        0x0020a8aa:    d007        ..      BEQ      0x20a8bc ; app_client_callback + 1254
        0x0020a8ac:    4630        0F      MOV      r0,r6
        0x0020a8ae:    e8bd81fc    ....    POP      {r2-r8,pc}
;;;1161               {
;;;1162               case BAS_WRITE_NOTIFY_ENABLE:
;;;1163                   APP_PRINT_INFO1("BAS_WRITE_NOTIFY_ENABLE: write result 0x%x",
        0x0020a8b2:    491c        .I      LDR      r1,[pc,#112] ; [0x20a924] = 0x88022d0
        0x0020a8b4:    2201        ."      MOVS     r2,#1
        0x0020a8b6:    88a3        ..      LDRH     r3,[r4,#4]
        0x0020a8b8:    3128        (1      ADDS     r1,r1,#0x28
;;;1164                                   p_bas_cb_data->cb_content.write_result.cause);
;;;1165                   break;
        0x0020a8ba:    e6e4        ..      B        0x20a686 ; app_client_callback + 688
;;;1166               case BAS_WRITE_NOTIFY_DISABLE:
;;;1167                   APP_PRINT_INFO1("BAS_WRITE_NOTIFY_DISABLE: write result 0x%x",
        0x0020a8bc:    4919        .I      LDR      r1,[pc,#100] ; [0x20a924] = 0x88022d0
        0x0020a8be:    2201        ."      MOVS     r2,#1
        0x0020a8c0:    88a3        ..      LDRH     r3,[r4,#4]
        0x0020a8c2:    3158        X1      ADDS     r1,r1,#0x58
;;;1168                                   p_bas_cb_data->cb_content.write_result.cause);
;;;1169                   break;
        0x0020a8c4:    e6df        ..      B        0x20a686 ; app_client_callback + 688
;;;1170               default:
;;;1171                   break;
;;;1172               }
;;;1173               break;
;;;1174           case BAS_CLIENT_CB_TYPE_NOTIF_IND_RESULT:
;;;1175               APP_PRINT_INFO1("BAS_CLIENT_CB_TYPE_NOTIF_IND_RESULT: battery level %d",
        0x0020a8c6:    4917        .I      LDR      r1,[pc,#92] ; [0x20a924] = 0x88022d0
        0x0020a8c8:    2201        ."      MOVS     r2,#1
        0x0020a8ca:    78a3        .x      LDRB     r3,[r4,#2]
        0x0020a8cc:    3188        .1      ADDS     r1,r1,#0x88
;;;1176                               p_bas_cb_data->cb_content.notify_data.battery_level);
;;;1177               break;
        0x0020a8ce:    e6da        ..      B        0x20a686 ; app_client_callback + 688
    $d
        0x0020a8d0:    08801e1c    ....    DCD    142614044
        0x0020a8d4:    70616723    #gap    DCD    1885431587
        0x0020a8d8:    64616572    read    DCD    1684104562
        0x0020a8dc:    64252123    #!%d    DCD    1680154915
        0x0020a8e0:    73254021    !@%s    DCD    1931821089
        0x0020a8e4:    3e593c40    @<Y>    DCD    1046035520
        0x0020a8e8:    00000a0d    ....    DCD    2573
        0x0020a8ec:    08801f40    @...    DCD    142614336
        0x0020a8f0:    21103000    .0.!    DCD    554708992
        0x0020a8f4:    21500000    ..P!    DCD    558891008
        0x0020a8f8:    0880206c    l ..    DCD    142614636
        0x0020a8fc:    0880218c    .!..    DCD    142614924
        0x0020a900:    746f6e23    #not    DCD    1953459747
        0x0020a904:    23796669    ify#    DCD    595158633
        0x0020a908:    21642521    !%d!    DCD    560211233
        0x0020a90c:    25405d5b    []@%    DCD    624975195
        0x0020a910:    00207b64    d{ .    DCD    2128740
        0x0020a914:    0020d170    p. .    DCD    2150768
        0x0020a918:    58323025    %02X    DCD    1479684133
        0x0020a91c:    00000000    ....    DCD    0
        0x0020a920:    000a0d7d    }...    DCD    658813
        0x0020a924:    088022d0    ."..    DCD    142615248
    $t
    .text
    app_le_gap_init
;;; ..\..\..\src\sample\ble_central\main.c
;;;73     {
        0x0020a928:    b500        ..      PUSH     {lr}
        0x0020a92a:    b099        ..      SUB      sp,sp,#0x64
;;;74         /* Device name and device appearance */
;;;75         uint8_t  device_name[GAP_DEVICE_NAME_LEN] = "BLE_CENTRAL";
        0x0020a92c:    2228        ("      MOVS     r2,#0x28
        0x0020a92e:    495a        ZI      LDR      r1,[pc,#360] ; [0x20aa98] = 0x21ca50
        0x0020a930:    4668        hF      MOV      r0,sp
        0x0020a932:    f64ffb39    O.9.    BL       __aeabi_memcpy4 ; 0x59fa8
;;;76         uint16_t appearance = GAP_GATT_APPEARANCE_UNKNOWN;
        0x0020a936:    2000        .       MOVS     r0,#0
        0x0020a938:    2101        .!      MOVS     r1,#1
        0x0020a93a:    2210        ."      MOVS     r2,#0x10
        0x0020a93c:    f8ad0058    ..X.    STRH     r0,[sp,#0x58]
;;;77     
;;;78         /* Scan parameters */
;;;79         uint8_t  scan_mode = GAP_SCAN_MODE_ACTIVE;
        0x0020a940:    f88d105c    ..\.    STRB     r1,[sp,#0x5c]
;;;80         uint16_t scan_interval = DEFAULT_SCAN_INTERVAL;
        0x0020a944:    f8ad2030    ..0     STRH     r2,[sp,#0x30]
;;;81         uint16_t scan_window = DEFAULT_SCAN_WINDOW;
        0x0020a948:    f8ad2034    ..4     STRH     r2,[sp,#0x34]
;;;82         uint8_t  scan_filter_policy = GAP_SCAN_FILTER_ANY;
;;;83         uint8_t  scan_filter_duplicate = GAP_SCAN_FILTER_DUPLICATE_ENABLE;
        0x0020a94c:    f88d103c    ..<.    STRB     r1,[sp,#0x3c]
        0x0020a950:    f8ad102c    ..,.    STRH     r1,[sp,#0x2c]
        0x0020a954:    2203        ."      MOVS     r2,#3
;;;84     
;;;85         /* GAP Bond Manager parameters */
;;;86         uint8_t  auth_pair_mode = GAP_PAIRING_MODE_PAIRABLE;
        0x0020a956:    f88d1028    ..(.    STRB     r1,[sp,#0x28]
;;;87         uint16_t auth_flags = GAP_AUTHEN_BIT_BONDING_FLAG;
;;;88         uint8_t  auth_io_cap = GAP_IO_CAP_NO_INPUT_NO_OUTPUT;
        0x0020a95a:    f88d2040    ..@     STRB     r2,[sp,#0x40]
        0x0020a95e:    f88d0038    ..8.    STRB     r0,[sp,#0x38]
;;;89         uint8_t  auth_oob = false;
        0x0020a962:    f88d0044    ..D.    STRB     r0,[sp,#0x44]
;;;90         uint8_t  auth_use_fix_passkey = false;
        0x0020a966:    f88d0048    ..H.    STRB     r0,[sp,#0x48]
;;;91         uint32_t auth_fix_passkey = 0;
;;;92         uint8_t  auth_sec_req_enable = false;
        0x0020a96a:    9013        ..      STR      r0,[sp,#0x4c]
        0x0020a96c:    f88d0050    ..P.    STRB     r0,[sp,#0x50]
;;;93         uint16_t auth_sec_req_flags = GAP_AUTHEN_BIT_BONDING_FLAG;
        0x0020a970:    f8ad1054    ..T.    STRH     r1,[sp,#0x54]
;;;94     
;;;95         /* Set device name and device appearance */
;;;96         le_set_gap_param(GAP_PARAM_DEVICE_NAME, GAP_DEVICE_NAME_LEN, device_name);
        0x0020a974:    466a        jF      MOV      r2,sp
        0x0020a976:    2128        (!      MOVS     r1,#0x28
        0x0020a978:    f2402022    @."     MOV      r0,#0x222
        0x0020a97c:    f642f964    B.d.    BL       le_set_gap_param ; 0x4cc48
;;;97         le_set_gap_param(GAP_PARAM_APPEARANCE, sizeof(appearance), &appearance);
        0x0020a980:    aa16        ..      ADD      r2,sp,#0x58
        0x0020a982:    2102        .!      MOVS     r1,#2
        0x0020a984:    f2402021    @.!     MOV      r0,#0x221
        0x0020a988:    f642f95e    B.^.    BL       le_set_gap_param ; 0x4cc48
;;;98     
;;;99         /* Set scan parameters */
;;;100        le_scan_set_param(GAP_PARAM_SCAN_MODE, sizeof(scan_mode), &scan_mode);
        0x0020a98c:    aa17        ..      ADD      r2,sp,#0x5c
        0x0020a98e:    2101        .!      MOVS     r1,#1
        0x0020a990:    f2402041    @.A     MOV      r0,#0x241
        0x0020a994:    f647fcee    G...    BL       le_scan_set_param ; 0x52374
;;;101        le_scan_set_param(GAP_PARAM_SCAN_INTERVAL, sizeof(scan_interval), &scan_interval);
        0x0020a998:    aa0c        ..      ADD      r2,sp,#0x30
        0x0020a99a:    2102        .!      MOVS     r1,#2
        0x0020a99c:    f2402042    @.B     MOV      r0,#0x242
        0x0020a9a0:    f647fce8    G...    BL       le_scan_set_param ; 0x52374
;;;102        le_scan_set_param(GAP_PARAM_SCAN_WINDOW, sizeof(scan_window), &scan_window);
        0x0020a9a4:    aa0d        ..      ADD      r2,sp,#0x34
        0x0020a9a6:    2102        .!      MOVS     r1,#2
        0x0020a9a8:    f2402043    @.C     MOV      r0,#0x243
        0x0020a9ac:    f647fce2    G...    BL       le_scan_set_param ; 0x52374
;;;103        le_scan_set_param(GAP_PARAM_SCAN_FILTER_POLICY, sizeof(scan_filter_policy),
        0x0020a9b0:    aa0e        ..      ADD      r2,sp,#0x38
        0x0020a9b2:    2101        .!      MOVS     r1,#1
        0x0020a9b4:    f44f7011    O..p    MOV      r0,#0x244
        0x0020a9b8:    f647fcdc    G...    BL       le_scan_set_param ; 0x52374
;;;104                          &scan_filter_policy);
;;;105        le_scan_set_param(GAP_PARAM_SCAN_FILTER_DUPLICATES, sizeof(scan_filter_duplicate),
        0x0020a9bc:    aa0f        ..      ADD      r2,sp,#0x3c
        0x0020a9be:    2101        .!      MOVS     r1,#1
        0x0020a9c0:    f2402045    @.E     MOV      r0,#0x245
        0x0020a9c4:    f647fcd6    G...    BL       le_scan_set_param ; 0x52374
;;;106                          &scan_filter_duplicate);
;;;107    
;;;108        /* Setup the GAP Bond Manager */
;;;109        gap_set_param(GAP_PARAM_BOND_PAIRING_MODE, sizeof(auth_pair_mode), &auth_pair_mode);
        0x0020a9c8:    aa0a        ..      ADD      r2,sp,#0x28
        0x0020a9ca:    2101        .!      MOVS     r1,#1
        0x0020a9cc:    f2402002    @..     MOV      r0,#0x202
        0x0020a9d0:    f641faeb    A...    BL       gap_set_param ; 0x4bfaa
;;;110        gap_set_param(GAP_PARAM_BOND_AUTHEN_REQUIREMENTS_FLAGS, sizeof(auth_flags), &auth_flags);
        0x0020a9d4:    aa0b        ..      ADD      r2,sp,#0x2c
        0x0020a9d6:    2102        .!      MOVS     r1,#2
        0x0020a9d8:    f2402003    @..     MOV      r0,#0x203
        0x0020a9dc:    f641fae5    A...    BL       gap_set_param ; 0x4bfaa
;;;111        gap_set_param(GAP_PARAM_BOND_IO_CAPABILITIES, sizeof(auth_io_cap), &auth_io_cap);
        0x0020a9e0:    aa10        ..      ADD      r2,sp,#0x40
        0x0020a9e2:    2101        .!      MOVS     r1,#1
        0x0020a9e4:    f44f7001    O..p    MOV      r0,#0x204
        0x0020a9e8:    f641fadf    A...    BL       gap_set_param ; 0x4bfaa
;;;112        gap_set_param(GAP_PARAM_BOND_OOB_ENABLED, sizeof(auth_oob), &auth_oob);
        0x0020a9ec:    aa11        ..      ADD      r2,sp,#0x44
        0x0020a9ee:    2101        .!      MOVS     r1,#1
        0x0020a9f0:    f2402005    @..     MOV      r0,#0x205
        0x0020a9f4:    f641fad9    A...    BL       gap_set_param ; 0x4bfaa
;;;113        le_bond_set_param(GAP_PARAM_BOND_FIXED_PASSKEY, sizeof(auth_fix_passkey), &auth_fix_passkey);
        0x0020a9f8:    aa13        ..      ADD      r2,sp,#0x4c
        0x0020a9fa:    2104        .!      MOVS     r1,#4
        0x0020a9fc:    f2402011    @..     MOV      r0,#0x211
        0x0020aa00:    f641fbf5    A...    BL       le_bond_set_param ; 0x4c1ee
;;;114        le_bond_set_param(GAP_PARAM_BOND_FIXED_PASSKEY_ENABLE, sizeof(auth_use_fix_passkey),
        0x0020aa04:    aa12        ..      ADD      r2,sp,#0x48
        0x0020aa06:    2101        .!      MOVS     r1,#1
        0x0020aa08:    f2402012    @..     MOV      r0,#0x212
        0x0020aa0c:    f641fbef    A...    BL       le_bond_set_param ; 0x4c1ee
;;;115                          &auth_use_fix_passkey);
;;;116        le_bond_set_param(GAP_PARAM_BOND_SEC_REQ_ENABLE, sizeof(auth_sec_req_enable), &auth_sec_req_enable);
        0x0020aa10:    aa14        ..      ADD      r2,sp,#0x50
        0x0020aa12:    2101        .!      MOVS     r1,#1
        0x0020aa14:    f2402013    @..     MOV      r0,#0x213
        0x0020aa18:    f641fbe9    A...    BL       le_bond_set_param ; 0x4c1ee
;;;117        le_bond_set_param(GAP_PARAM_BOND_SEC_REQ_REQUIREMENT, sizeof(auth_sec_req_flags),
        0x0020aa1c:    aa15        ..      ADD      r2,sp,#0x54
        0x0020aa1e:    2102        .!      MOVS     r1,#2
        0x0020aa20:    f44f7005    O..p    MOV      r0,#0x214
        0x0020aa24:    f641fbe3    A...    BL       le_bond_set_param ; 0x4c1ee
;;;118                          &auth_sec_req_flags);
;;;119    
;;;120        /* register gap message callback */
;;;121        le_register_app_cb(app_gap_callback);
        0x0020aa28:    481c        .H      LDR      r0,[pc,#112] ; [0x20aa9c] = 0x20a327
        0x0020aa2a:    f642f90a    B...    BL       le_register_app_cb ; 0x4cc42
;;;122    }
        0x0020aa2e:    b019        ..      ADD      sp,sp,#0x64
        0x0020aa30:    bd00        ..      POP      {pc}
    app_le_profile_init
;;;123    
;;;124    /**
;;;125     * @brief  Add GATT clients and register callbacks
;;;126     * @return void
;;;127     */
;;;128    void app_le_profile_init(void)
;;;129    {
        0x0020aa32:    b510        ..      PUSH     {r4,lr}
;;;130        client_init(3);
        0x0020aa34:    2003        .       MOVS     r0,#3
        0x0020aa36:    f643fc83    C...    BL       client_init ; 0x4e340
;;;131        gaps_client_id  = gaps_add_client(app_client_callback, APP_MAX_LINKS);
        0x0020aa3a:    2104        .!      MOVS     r1,#4
        0x0020aa3c:    4818        .H      LDR      r0,[pc,#96] ; [0x20aaa0] = 0x20a3d7
        0x0020aa3e:    f7fefd3a    ..:.    BL       gaps_add_client ; 0x2094b6
        0x0020aa42:    4918        .I      LDR      r1,[pc,#96] ; [0x20aaa4] = 0x20d376
        0x0020aa44:    7008        .p      STRB     r0,[r1,#0]
;;;132        simple_ble_client_id = simp_ble_add_client(app_client_callback, APP_MAX_LINKS);
        0x0020aa46:    2104        .!      MOVS     r1,#4
        0x0020aa48:    4815        .H      LDR      r0,[pc,#84] ; [0x20aaa0] = 0x20a3d7
        0x0020aa4a:    f7fef817    ....    BL       simp_ble_add_client ; 0x208a7c
        0x0020aa4e:    4916        .I      LDR      r1,[pc,#88] ; [0x20aaa8] = 0x20d375
        0x0020aa50:    7008        .p      STRB     r0,[r1,#0]
;;;133        bas_client_id = bas_add_client(app_client_callback, APP_MAX_LINKS);
        0x0020aa52:    2104        .!      MOVS     r1,#4
        0x0020aa54:    4812        .H      LDR      r0,[pc,#72] ; [0x20aaa0] = 0x20a3d7
        0x0020aa56:    f7fefad7    ....    BL       bas_add_client ; 0x209008
        0x0020aa5a:    4914        .I      LDR      r1,[pc,#80] ; [0x20aaac] = 0x20d377
        0x0020aa5c:    7008        .p      STRB     r0,[r1,#0]
;;;134    }
        0x0020aa5e:    bd10        ..      POP      {r4,pc}
    board_init
;;;135    
;;;136    /**
;;;137     * @brief    Contains the initialization of pinmux settings and pad settings
;;;138     * @note     All the pinmux settings and pad settings shall be initiated in this function,
;;;139     *           but if legacy driver is used, the initialization of pinmux setting and pad setting
;;;140     *           should be peformed with the IO initializing.
;;;141     * @return   void
;;;142     */
;;;143    void board_init(void)
;;;144    {
;;;145    
;;;146    }
        0x0020aa60:    4770        pG      BX       lr
    driver_init
;;;147    
;;;148    /**
;;;149     * @brief    Contains the initialization of peripherals
;;;150     * @note     Both new architecture driver and legacy driver initialization method can be used
;;;151     * @return   void
;;;152     */
;;;153    void driver_init(void)
;;;154    {
;;;155    
;;;156    }
        0x0020aa62:    4770        pG      BX       lr
    pwr_mgr_init
;;;157    
;;;158    /**
;;;159     * @brief    Contains the power mode settings
;;;160     * @return   void
;;;161     */
;;;162    void pwr_mgr_init(void)
;;;163    {
;;;164    }
        0x0020aa64:    4770        pG      BX       lr
    task_init
;;;165    
;;;166    /**
;;;167     * @brief    Contains the initialization of all tasks
;;;168     * @note     There is only one task in BLE Central APP, thus only one APP task is init here
;;;169     * @return   void
;;;170     */
;;;171    void task_init(void)
;;;172    {
;;;173        app_task_init();
        0x0020aa66:    f7ffb86d    ..m.    B        app_task_init ; 0x209b44
    main
;;;174    }
;;;175    
;;;176    /**
;;;177     * @brief    Entry of APP code
;;;178     * @return   int (To avoid compile warning)
;;;179     */
;;;180    int main(void)
;;;181    {
        0x0020aa6a:    b510        ..      PUSH     {r4,lr}
;;;182    	mxchip_qc_init();
        0x0020aa6c:    f000fecf    ....    BL       mxchip_qc_init ; 0x20b80e
;;;183        extern uint32_t random_seed_value;
;;;184        srand(random_seed_value);
        0x0020aa70:    480f        .H      LDR      r0,[pc,#60] ; [0x20aab0] = 0x20cfa4
        0x0020aa72:    6800        .h      LDR      r0,[r0,#0]
        0x0020aa74:    f011fdf6    ....    BL       srand ; 0x21c664
;;;185        board_init();
;;;186        le_gap_init(APP_MAX_LINKS);
        0x0020aa78:    2004        .       MOVS     r0,#4
        0x0020aa7a:    f642f89f    B...    BL       le_gap_init ; 0x4cbbc
;;;187        gap_lib_init();
        0x0020aa7e:    f011fd03    ....    BL       gap_lib_init ; 0x21c488
;;;188        app_le_gap_init();
        0x0020aa82:    f7ffff51    ..Q.    BL       app_le_gap_init ; 0x20a928
;;;189        app_le_profile_init();
        0x0020aa86:    f7ffffd4    ....    BL       app_le_profile_init ; 0x20aa32
        0x0020aa8a:    f7fff85b    ..[.    BL       app_task_init ; 0x209b44
;;;190        pwr_mgr_init();
;;;191        task_init();
;;;192        os_sched_start();
        0x0020aa8e:    f61bfe98    ....    BL       os_sched_start ; 0x267c2
;;;193    
;;;194        return 0;
        0x0020aa92:    2000        .       MOVS     r0,#0
;;;195    }
        0x0020aa94:    bd10        ..      POP      {r4,pc}
    $d
        0x0020aa96:    0000        ..      DCW    0
        0x0020aa98:    0021ca50    P.!.    DCD    2214480
        0x0020aa9c:    0020a327    '. .    DCD    2138919
        0x0020aaa0:    0020a3d7    .. .    DCD    2139095
        0x0020aaa4:    0020d376    v. .    DCD    2151286
        0x0020aaa8:    0020d375    u. .    DCD    2151285
        0x0020aaac:    0020d377    w. .    DCD    2151287
        0x0020aab0:    0020cfa4    .. .    DCD    2150308
    $t
    .text
    data_uart_send_char
;;; ..\..\..\src\mcu\module\data_uart_cmd\data_uart.c
;;;19     {
        0x0020aab4:    b531        1.      PUSH     {r0,r4,r5,lr}
;;;20         UART_SendData(UART, (uint8_t *)&ch, 1);
        0x0020aab6:    4cc5        .L      LDR      r4,[pc,#788] ; [0x20adcc] = 0x40012000
        0x0020aab8:    2201        ."      MOVS     r2,#1
        0x0020aaba:    4669        iF      MOV      r1,sp
        0x0020aabc:    4620         F      MOV      r0,r4
        0x0020aabe:    f011fc00    ....    BL       UART_SendData ; 0x21c2c2
;;;21         /* wait tx fifo empty */
;;;22         while (UART_GetFlagState(UART, UART_FLAG_THR_TSR_EMPTY) != SET);
        0x0020aac2:    2140        @!      MOVS     r1,#0x40
        0x0020aac4:    4620         F      MOV      r0,r4
        0x0020aac6:    f011fc2f    ../.    BL       UART_GetFlagState ; 0x21c328
        0x0020aaca:    2801        .(      CMP      r0,#1
        0x0020aacc:    d1f9        ..      BNE      0x20aac2 ; data_uart_send_char + 14
;;;23     
;;;24         return ch;
        0x0020aace:    9800        ..      LDR      r0,[sp,#0]
;;;25     }
        0x0020aad0:    bd38        8.      POP      {r3-r5,pc}
    data_uart_vsprintf
;;;26     
;;;27     int data_uart_vsprintf(char *buf, const char *fmt, const int *dp)
;;;28     {
        0x0020aad2:    e92d43f0    -..C    PUSH     {r4-r9,lr}
        0x0020aad6:    b085        ..      SUB      sp,sp,#0x14
        0x0020aad8:    4616        .F      MOV      r6,r2
        0x0020aada:    460f        .F      MOV      r7,r1
        0x0020aadc:    4681        .F      MOV      r9,r0
        0x0020aade:    4605        .F      MOV      r5,r0
        0x0020aae0:    e091        ..      B        0x20ac06 ; data_uart_vsprintf + 308
;;;29         char *p, *s;
;;;30     
;;;31         s = buf;
;;;32         for (; *fmt != '\0'; ++fmt)
;;;33         {
;;;34             if (*fmt != '%')
        0x0020aae2:    2825        %(      CMP      r0,#0x25
        0x0020aae4:    d008        ..      BEQ      0x20aaf8 ; data_uart_vsprintf + 38
;;;35             {
;;;36                 buf ? *s++ = *fmt : data_uart_send_char(*fmt);
        0x0020aae6:    f1b90f00    ....    CMP      r9,#0
        0x0020aaea:    d002        ..      BEQ      0x20aaf2 ; data_uart_vsprintf + 32
        0x0020aaec:    f8050b01    ....    STRB     r0,[r5],#1
        0x0020aaf0:    e088        ..      B        0x20ac04 ; data_uart_vsprintf + 306
        0x0020aaf2:    f7ffffdf    ....    BL       data_uart_send_char ; 0x20aab4
        0x0020aaf6:    e085        ..      B        0x20ac04 ; data_uart_vsprintf + 306
;;;37                 continue;
;;;38             }
;;;39             if (*++fmt == 's')
        0x0020aaf8:    f8170f01    ....    LDRB     r0,[r7,#1]!
        0x0020aafc:    2873        s(      CMP      r0,#0x73
        0x0020aafe:    d021        !.      BEQ      0x20ab44 ; data_uart_vsprintf + 114
        0x0020ab00:    211c        .!      MOVS     r1,#0x1c
        0x0020ab02:    f1a00230    ..0.    SUB      r2,r0,#0x30
        0x0020ab06:    466c        lF      MOV      r4,sp
        0x0020ab08:    2a09        .*      CMP      r2,#9
        0x0020ab0a:    d80d        ..      BHI      0x20ab28 ; data_uart_vsprintf + 86
        0x0020ab0c:    2100        .!      MOVS     r1,#0
        0x0020ab0e:    eb010181    ....    ADD      r1,r1,r1,LSL #2
        0x0020ab12:    eb000141    ..A.    ADD      r1,r0,r1,LSL #1
        0x0020ab16:    f8170f01    ....    LDRB     r0,[r7,#1]!
        0x0020ab1a:    3930        09      SUBS     r1,r1,#0x30
        0x0020ab1c:    f1a00230    ..0.    SUB      r2,r0,#0x30
        0x0020ab20:    2a09        .*      CMP      r2,#9
        0x0020ab22:    d9f4        ..      BLS      0x20ab0e ; data_uart_vsprintf + 60
        0x0020ab24:    0089        ..      LSLS     r1,r1,#2
        0x0020ab26:    1f09        ..      SUBS     r1,r1,#4
        0x0020ab28:    b2c0        ..      UXTB     r0,r0
        0x0020ab2a:    2878        x(      CMP      r0,#0x78
        0x0020ab2c:    d019        ..      BEQ      0x20ab62 ; data_uart_vsprintf + 144
        0x0020ab2e:    2858        X(      CMP      r0,#0x58
        0x0020ab30:    d017        ..      BEQ      0x20ab62 ; data_uart_vsprintf + 144
        0x0020ab32:    2870        p(      CMP      r0,#0x70
        0x0020ab34:    d015        ..      BEQ      0x20ab62 ; data_uart_vsprintf + 144
        0x0020ab36:    2850        P(      CMP      r0,#0x50
        0x0020ab38:    d013        ..      BEQ      0x20ab62 ; data_uart_vsprintf + 144
        0x0020ab3a:    2864        d(      CMP      r0,#0x64
        0x0020ab3c:    d02e        ..      BEQ      0x20ab9c ; data_uart_vsprintf + 202
        0x0020ab3e:    2863        c(      CMP      r0,#0x63
        0x0020ab40:    d04b        K.      BEQ      0x20abda ; data_uart_vsprintf + 264
        0x0020ab42:    e04c        L.      B        0x20abde ; data_uart_vsprintf + 268
;;;40             {
;;;41                 for (p = (char *)*dp++; *p != '\0'; p++)
        0x0020ab44:    ce10        ..      LDM      r6!,{r4}
        0x0020ab46:    e008        ..      B        0x20ab5a ; data_uart_vsprintf + 136
;;;42                 {
;;;43                     buf ? *s++ = *p : data_uart_send_char(*p);
        0x0020ab48:    f1b90f00    ....    CMP      r9,#0
        0x0020ab4c:    d002        ..      BEQ      0x20ab54 ; data_uart_vsprintf + 130
        0x0020ab4e:    f8050b01    ....    STRB     r0,[r5],#1
        0x0020ab52:    e001        ..      B        0x20ab58 ; data_uart_vsprintf + 134
        0x0020ab54:    f7ffffae    ....    BL       data_uart_send_char ; 0x20aab4
        0x0020ab58:    1c64        d.      ADDS     r4,r4,#1
        0x0020ab5a:    7820         x      LDRB     r0,[r4,#0]
        0x0020ab5c:    2800        .(      CMP      r0,#0
        0x0020ab5e:    d1f3        ..      BNE      0x20ab48 ; data_uart_vsprintf + 118
        0x0020ab60:    e050        P.      B        0x20ac04 ; data_uart_vsprintf + 306
;;;44                 }
;;;45             }
;;;46             else    /* Length of item is bounded */
;;;47             {
;;;48                 char tmp[20], *q = tmp;
;;;49                 int shift = 28;
;;;50     
;;;51                 if ((*fmt  >= '0') && (*fmt  <= '9'))
;;;52                 {
;;;53                     int width;
;;;54                     unsigned char fch = *fmt;
;;;55                     for (width = 0; (fch >= '0') && (fch <= '9'); fch = *++fmt)
;;;56                     {
;;;57                         width = width * 10 + fch - '0';
;;;58                     }
;;;59                     shift = (width - 1) * 4;
;;;60                 }
;;;61                 /*
;;;62                  * Before each format q points to tmp buffer
;;;63                  * After each format q points past end of item
;;;64                  */
;;;65     
;;;66                 if ((*fmt == 'x') || (*fmt == 'X') || (*fmt == 'p') || (*fmt == 'P'))
;;;67                 {
;;;68                     /* With x86 gcc, sizeof(long) == sizeof(int) */
;;;69                     const long *lp = (const long *)dp;
;;;70                     long h = *lp++;
        0x0020ab62:    ce08        ..      LDM      r6!,{r3}
;;;71                     int ncase = (*fmt & 0x20);
        0x0020ab64:    f0000220    .. .    AND      r2,r0,#0x20
;;;72                     int alt = 0;
;;;73     
;;;74                     dp = (const int *)lp;
;;;75                     if ((*fmt == 'p') || (*fmt == 'P'))
        0x0020ab68:    2870        p(      CMP      r0,#0x70
        0x0020ab6a:    d001        ..      BEQ      0x20ab70 ; data_uart_vsprintf + 158
        0x0020ab6c:    2850        P(      CMP      r0,#0x50
        0x0020ab6e:    d106        ..      BNE      0x20ab7e ; data_uart_vsprintf + 172
;;;76                     {
;;;77                         alt = 1;
;;;78                     }
;;;79                     if (alt)
;;;80                     {
;;;81                         *q++ = '0';
        0x0020ab70:    2030        0       MOVS     r0,#0x30
        0x0020ab72:    f8040b01    ....    STRB     r0,[r4],#1
;;;82                         *q++ = 'X' | ncase;
        0x0020ab76:    f0420058    B.X.    ORR      r0,r2,#0x58
        0x0020ab7a:    f8040b01    ....    STRB     r0,[r4],#1
;;;83                     }
;;;84                     for (; shift >= 0; shift -= 4)
        0x0020ab7e:    2900        .)      CMP      r1,#0
        0x0020ab80:    db2f        /.      BLT      0x20abe2 ; data_uart_vsprintf + 272
        0x0020ab82:    fa43f001    C...    ASR      r0,r3,r1
        0x0020ab86:    f000000f    ....    AND      r0,r0,#0xf
        0x0020ab8a:    f20f2c44    ..D,    ADR.W    r12,{pc}+0x246 ; 0x20add0
        0x0020ab8e:    f81c0000    ....    LDRB     r0,[r12,r0]
        0x0020ab92:    4310        .C      ORRS     r0,r0,r2
        0x0020ab94:    f8040b01    ....    STRB     r0,[r4],#1
        0x0020ab98:    1f09        ..      SUBS     r1,r1,#4
        0x0020ab9a:    e7f0        ..      B        0x20ab7e ; data_uart_vsprintf + 172
;;;85                     {
;;;86                         * q++ = "0123456789ABCDEF"[(h >> shift) & 0xF] | ncase;
;;;87                     }
;;;88                 }
;;;89                 else if (*fmt == 'd')
;;;90                 {
;;;91                     int i = *dp++;
        0x0020ab9c:    ce01        ..      LDM      r6!,{r0}
;;;92                     char *r;
;;;93                     if (i < 0)
        0x0020ab9e:    2800        .(      CMP      r0,#0
        0x0020aba0:    da03        ..      BGE      0x20abaa ; data_uart_vsprintf + 216
;;;94                     {
;;;95                         *q++ = '-';
        0x0020aba2:    212d        -!      MOVS     r1,#0x2d
        0x0020aba4:    f8041b01    ....    STRB     r1,[r4],#1
;;;96                         i = -i;
        0x0020aba8:    4240        @B      RSBS     r0,r0,#0
;;;97                     }
;;;98                     p = q;      /* save beginning of digits */
        0x0020abaa:    4621        !F      MOV      r1,r4
;;;99                     do
;;;100                    {
;;;101                        *q++ = '0' + (i % 10);
        0x0020abac:    220a        ."      MOVS     r2,#0xa
        0x0020abae:    fb90f3f2    ....    SDIV     r3,r0,r2
        0x0020abb2:    fb020313    ....    MLS      r3,r2,r3,r0
        0x0020abb6:    fb90f0f2    ....    SDIV     r0,r0,r2
        0x0020abba:    3330        03      ADDS     r3,r3,#0x30
        0x0020abbc:    f8043b01    ...;    STRB     r3,[r4],#1
;;;102                        i /= 10;
;;;103                    }
;;;104                    while (i);
        0x0020abc0:    2800        .(      CMP      r0,#0
        0x0020abc2:    d1f4        ..      BNE      0x20abae ; data_uart_vsprintf + 220
;;;105                    /* reverse digits, stop in middle */
;;;106                    r = q;      /* don't alter q */
        0x0020abc4:    4620         F      MOV      r0,r4
;;;107                    while (--r > p)
        0x0020abc6:    e004        ..      B        0x20abd2 ; data_uart_vsprintf + 256
;;;108                    {
;;;109                        i = *r;
        0x0020abc8:    7802        .x      LDRB     r2,[r0,#0]
;;;110                        *r = *p;
        0x0020abca:    780b        .x      LDRB     r3,[r1,#0]
        0x0020abcc:    7003        .p      STRB     r3,[r0,#0]
;;;111                        *p++ = i;
        0x0020abce:    f8012b01    ...+    STRB     r2,[r1],#1
        0x0020abd2:    1e40        @.      SUBS     r0,r0,#1
        0x0020abd4:    4288        .B      CMP      r0,r1
        0x0020abd6:    d8f7        ..      BHI      0x20abc8 ; data_uart_vsprintf + 246
        0x0020abd8:    e003        ..      B        0x20abe2 ; data_uart_vsprintf + 272
;;;112                    }
;;;113                }
;;;114                else if (*fmt == 'c')
;;;115                {
;;;116                    *q++ = *dp++;
        0x0020abda:    f8160b04    ....    LDRB     r0,[r6],#4
;;;117                }
;;;118                else
;;;119                {
;;;120                    *q++ = *fmt;
        0x0020abde:    f8040b01    ....    STRB     r0,[r4],#1
;;;121                }
;;;122                /* now output the saved string */
;;;123                for (p = tmp; p < q; ++p)
        0x0020abe2:    4668        hF      MOV      r0,sp
        0x0020abe4:    e00b        ..      B        0x20abfe ; data_uart_vsprintf + 300
        0x0020abe6:    f8980000    ....    LDRB     r0,[r8,#0]
        0x0020abea:    f1b90f00    ....    CMP      r9,#0
        0x0020abee:    d002        ..      BEQ      0x20abf6 ; data_uart_vsprintf + 292
        0x0020abf0:    f8050b01    ....    STRB     r0,[r5],#1
        0x0020abf4:    e001        ..      B        0x20abfa ; data_uart_vsprintf + 296
        0x0020abf6:    f7ffff5d    ..].    BL       data_uart_send_char ; 0x20aab4
        0x0020abfa:    f1080001    ....    ADD      r0,r8,#1
        0x0020abfe:    4680        .F      MOV      r8,r0
        0x0020ac00:    42a0        .B      CMP      r0,r4
        0x0020ac02:    d3f0        ..      BCC      0x20abe6 ; data_uart_vsprintf + 276
        0x0020ac04:    1c7f        ..      ADDS     r7,r7,#1
        0x0020ac06:    7838        8x      LDRB     r0,[r7,#0]
        0x0020ac08:    2800        .(      CMP      r0,#0
        0x0020ac0a:    f47faf6a    ..j.    BNE      0x20aae2 ; data_uart_vsprintf + 16
;;;124                {
;;;125                    buf ? *s++ = *p : data_uart_send_char(*p);
;;;126                }
;;;127            }
;;;128        }
;;;129        if (buf)
        0x0020ac0e:    f1b90f00    ....    CMP      r9,#0
        0x0020ac12:    d000        ..      BEQ      0x20ac16 ; data_uart_vsprintf + 324
;;;130        {
;;;131            *s = '\0';
        0x0020ac14:    7028        (p      STRB     r0,[r5,#0]
        0x0020ac16:    b005        ..      ADD      sp,sp,#0x14
;;;132        }
;;;133        return (s - buf);
        0x0020ac18:    eba50009    ....    SUB      r0,r5,r9
;;;134    }
        0x0020ac1c:    e8bd83f0    ....    POP      {r4-r9,pc}
    data_uart_print
;;;135    
;;;136    /**
;;;137     * @brief  Print the trace information through data uart.
;;;138     * @param[in] fmt   Print parameters.
;;;139     * @return void
;;;140     *
;;;141     * <b>Example usage</b>
;;;142     * \code{.c}
;;;143        void test(void)
;;;144        {
;;;145            data_uart_print("GAP scan stop\r\n");
;;;146        }
;;;147     * \endcode
;;;148     */
;;;149    void data_uart_print(char *fmt, ...)
;;;150    {
        0x0020ac20:    b40f        ..      PUSH     {r0-r3}
        0x0020ac22:    2000        .       MOVS     r0,#0
;;; ..\..\..\src\mcu\module\data_uart_cmd\data_uart.c (150)
        0x0020ac24:    b510        ..      PUSH     {r4,lr}
;;;151        (void)data_uart_vsprintf(0, fmt, ((const int *)&fmt) + 1);
        0x0020ac26:    aa03        ..      ADD      r2,sp,#0xc
        0x0020ac28:    9902        ..      LDR      r1,[sp,#8]
        0x0020ac2a:    f7ffff52    ..R.    BL       data_uart_vsprintf ; 0x20aad2
;;;152    }
        0x0020ac2e:    bc10        ..      POP      {r4}
        0x0020ac30:    f85dfb14    ]...    LDR      pc,[sp],#0x14
    FramingCheckSum
;;;153    
;;;154    bool FramingCheckSum(uint8_t* pu8Buffer, uint16_t u16Length, uint8_t* pu8CheckSum)
;;;155    {
        0x0020ac34:    b510        ..      PUSH     {r4,lr}
        0x0020ac36:    2300        .#      MOVS     r3,#0
;;; ..\..\..\src\mcu\module\data_uart_cmd\data_uart.c (155)
        0x0020ac38:    2800        .(      CMP      r0,#0
        0x0020ac3a:    d001        ..      BEQ      0x20ac40 ; FramingCheckSum + 12
;;;156        uint8_t u8Sum = 0;
;;;157    
;;;158        if (pu8Buffer == NULL) {return false;} ///< Check if the pointers is null 
;;;159        if (pu8CheckSum == NULL) {return false;} ///< Check if the pointers is null 
        0x0020ac3c:    b92a        *.      CBNZ     r2,0x20ac4a ; FramingCheckSum + 22
        0x0020ac3e:    2000        .       MOVS     r0,#0
        0x0020ac40:    bd10        ..      POP      {r4,pc}
        0x0020ac42:    f8104b01    ...K    LDRB     r4,[r0],#1
        0x0020ac46:    1b1b        ..      SUBS     r3,r3,r4
        0x0020ac48:    b2db        ..      UXTB     r3,r3
;;;160    
;;;161        while (u16Length-- > 0)
        0x0020ac4a:    1e49        I.      SUBS     r1,r1,#1
        0x0020ac4c:    b289        ..      UXTH     r1,r1
        0x0020ac4e:    d2f8        ..      BCS      0x20ac42 ; FramingCheckSum + 14
;;;162        {
;;;163            u8Sum -= *pu8Buffer++;
;;;164        } 
;;;165        *pu8CheckSum = u8Sum;
        0x0020ac50:    7013        .p      STRB     r3,[r2,#0]
;;;166    
;;;167        return true;
        0x0020ac52:    2001        .       MOVS     r0,#1
;;;168    }
        0x0020ac54:    bd10        ..      POP      {r4,pc}
    FramingWrapFrameUartPrint
;;;169    
;;;170    void FramingWrapFrameUartPrint(uint8_t* pu8BufferIn, uint16_t u16BufferInLength)
;;;171    {
        0x0020ac56:    b570        p.      PUSH     {r4-r6,lr}
        0x0020ac58:    f5ad7d02    ...}    SUB      sp,sp,#0x208
        0x0020ac5c:    4605        .F      MOV      r5,r0
        0x0020ac5e:    2000        .       MOVS     r0,#0
        0x0020ac60:    460c        .F      MOV      r4,r1
;;;172        uint8_t u8CheckSum = 0;
        0x0020ac62:    f88d0200    ....    STRB     r0,[sp,#0x200]
;;;173    	uint8_t u8BufferOut[512]={0};
        0x0020ac66:    f44f7100    O..q    MOV      r1,#0x200
        0x0020ac6a:    4668        hF      MOV      r0,sp
        0x0020ac6c:    f64ff9f8    O...    BL       __aeabi_memclr4 ; 0x5a060
;;;174    	uint16_t BufferLength;
;;;175    	uint16_t i;
;;;176      
;;;177        if (pu8BufferIn == NULL)           {return ;}     ///< Check if the pointer is null   
        0x0020ac70:    2d00        .-      CMP      r5,#0
        0x0020ac72:    d029        ).      BEQ      0x20acc8 ; FramingWrapFrameUartPrint + 114
;;;178        if (u16BufferInLength > FRAMING_PAYLOAD_MAX_LENGTH)  {return ;}
        0x0020ac74:    f5b47ffb    ....    CMP      r4,#0x1f6
        0x0020ac78:    d826        &.      BHI      0x20acc8 ; FramingWrapFrameUartPrint + 114
;;;179        
;;;180        u8BufferOut[FRAMING_INDEX_SOH]         = FRAMING_SOH;
        0x0020ac7a:    2001        .       MOVS     r0,#1
        0x0020ac7c:    f88d0000    ....    STRB     r0,[sp,#0]
;;;181        u8BufferOut[FRAMING_INDEX_LENGTH_HIGH]      = (uint8_t)(u16BufferInLength>>8);
        0x0020ac80:    0a20         .      LSRS     r0,r4,#8
        0x0020ac82:    f88d0001    ....    STRB     r0,[sp,#1]
        0x0020ac86:    4629        )F      MOV      r1,r5
        0x0020ac88:    466d        mF      MOV      r5,sp
;;;182        u8BufferOut[FRAMING_INDEX_LENGTH_LOW]      =  (uint8_t)(u16BufferInLength&0xff);
        0x0020ac8a:    f88d4002    ...@    STRB     r4,[sp,#2]
;;;183        memcpy(&u8BufferOut[FRAMING_INDEX_PAYLOAD], pu8BufferIn, u16BufferInLength);
        0x0020ac8e:    4622        "F      MOV      r2,r4
        0x0020ac90:    1ce8        ..      ADDS     r0,r5,#3
        0x0020ac92:    f64ff902    O...    BL       __aeabi_memcpy ; 0x59e9a
;;;184        
;;;185        if (FramingCheckSum(&u8BufferOut[FRAMING_INDEX_LENGTH_HIGH], u16BufferInLength + 2,&u8CheckSum) == false) {return ;} 
        0x0020ac96:    1ca0        ..      ADDS     r0,r4,#2
        0x0020ac98:    b281        ..      UXTH     r1,r0
        0x0020ac9a:    aa80        ..      ADD      r2,sp,#0x200
        0x0020ac9c:    1c68        h.      ADDS     r0,r5,#1
        0x0020ac9e:    f7ffffc9    ....    BL       FramingCheckSum ; 0x20ac34
        0x0020aca2:    2800        .(      CMP      r0,#0
        0x0020aca4:    d010        ..      BEQ      0x20acc8 ; FramingWrapFrameUartPrint + 114
;;;186        
;;;187        u8BufferOut[FRAMING_INDEX_PAYLOAD +  u16BufferInLength ] = u8CheckSum;
        0x0020aca6:    1928        (.      ADDS     r0,r5,r4
        0x0020aca8:    f89d1200    ....    LDRB     r1,[sp,#0x200]
        0x0020acac:    70c1        .p      STRB     r1,[r0,#3]
;;;188        u8BufferOut[FRAMING_INDEX_PAYLOAD +  u16BufferInLength + 1] = FRAMING_EOT;
        0x0020acae:    2104        .!      MOVS     r1,#4
        0x0020acb0:    1d64        d.      ADDS     r4,r4,#5
        0x0020acb2:    b2a6        ..      UXTH     r6,r4
        0x0020acb4:    7101        .q      STRB     r1,[r0,#4]
;;;189        
;;;190        BufferLength =  u16BufferInLength + 5;
;;;191    
;;;192    	for(i=0;i<BufferLength;i++)
        0x0020acb6:    2400        .$      MOVS     r4,#0
        0x0020acb8:    e004        ..      B        0x20acc4 ; FramingWrapFrameUartPrint + 110
        0x0020acba:    5d28        (]      LDRB     r0,[r5,r4]
        0x0020acbc:    f7fffefa    ....    BL       data_uart_send_char ; 0x20aab4
        0x0020acc0:    1c64        d.      ADDS     r4,r4,#1
        0x0020acc2:    b2a4        ..      UXTH     r4,r4
        0x0020acc4:    42b4        .B      CMP      r4,r6
        0x0020acc6:    d3f8        ..      BCC      0x20acba ; FramingWrapFrameUartPrint + 100
;;;193    	{
;;;194    		data_uart_send_char(u8BufferOut[i]);
;;;195    	}
;;;196    
;;;197        return  ;
;;;198    
;;;199    }
        0x0020acc8:    f50d7d02    ...}    ADD      sp,sp,#0x208
        0x0020accc:    bd70        p.      POP      {r4-r6,pc}
    UART0_Handler
;;;200    
;;;201    
;;;202    /****************************************************************************/
;;;203    /* UART interrupt                                                           */
;;;204    /****************************************************************************/
;;;205    void UART0_Handler(void)
;;;206    {
        0x0020acce:    b530        0.      PUSH     {r4,r5,lr}
        0x0020acd0:    b085        ..      SUB      sp,sp,#0x14
;;;207        uint8_t rx_char;
;;;208        T_IO_MSG io_driver_msg_send;
;;;209        uint8_t event  = EVENT_IO_TO_APP;
        0x0020acd2:    2002        .       MOVS     r0,#2
        0x0020acd4:    f88d0010    ....    STRB     r0,[sp,#0x10]
;;; ..\..\..\inc\peripheral\rtl876x_uart.h
;;;426        return (uint16_t)(UARTx->INTID_FCR & (0x0000000E));
        0x0020acd8:    4d3c        <M      LDR      r5,[pc,#240] ; [0x20adcc] = 0x40012000
;;; ..\..\..\src\mcu\module\data_uart_cmd\data_uart.c
;;;210        io_driver_msg_send.type = IO_MSG_TYPE_UART;
        0x0020acda:    2003        .       MOVS     r0,#3
        0x0020acdc:    f8ad0004    ....    STRH     r0,[sp,#4]
;;; ..\..\..\inc\peripheral\rtl876x_uart.h
;;;426        return (uint16_t)(UARTx->INTID_FCR & (0x0000000E));
        0x0020ace0:    68a9        .h      LDR      r1,[r5,#8]
        0x0020ace2:    4628        (F      MOV      r0,r5
        0x0020ace4:    f001040e    ....    AND      r4,r1,#0xe
;;; ..\..\..\src\mcu\module\data_uart_cmd\data_uart.c
;;;217        UART_INTConfig(UART, UART_INT_RD_AVA | UART_INT_LINE_STS, DISABLE);
        0x0020ace8:    2200        ."      MOVS     r2,#0
        0x0020acea:    2105        .!      MOVS     r1,#5
        0x0020acec:    f011faf1    ....    BL       UART_INTConfig ; 0x21c2d2
;;;218    
;;;219        switch (interrupt_id)
        0x0020acf0:    2c04        .,      CMP      r4,#4
        0x0020acf2:    d003        ..      BEQ      0x20acfc ; UART0_Handler + 46
        0x0020acf4:    dd23        #.      BLE      0x20ad3e ; UART0_Handler + 112
        0x0020acf6:    2c06        .,      CMP      r4,#6
        0x0020acf8:    d121        !.      BNE      0x20ad3e ; UART0_Handler + 112
        0x0020acfa:    e01b        ..      B        0x20ad34 ; UART0_Handler + 102
;;;220        {
;;;221        /* tx fifo empty, not enable */
;;;222        case UART_INT_ID_TX_EMPTY:
;;;223            break;
;;;224    
;;;225        /* rx data valiable */
;;;226        case UART_INT_ID_RX_LEVEL_REACH:
;;;227            UART_ReceiveData(UART, &rx_char, 1);
        0x0020acfc:    2201        ."      MOVS     r2,#1
        0x0020acfe:    a903        ..      ADD      r1,sp,#0xc
        0x0020ad00:    4628        (F      MOV      r0,r5
        0x0020ad02:    f011fad6    ....    BL       UART_ReceiveData ; 0x21c2b2
;;;228            io_driver_msg_send.subtype = rx_char;
        0x0020ad06:    f89d000c    ....    LDRB     r0,[sp,#0xc]
        0x0020ad0a:    f8ad0006    ....    STRH     r0,[sp,#6]
;;;229    
;;;230            if (os_msg_send(h_io_q, &io_driver_msg_send, 0) == false)
        0x0020ad0e:    4c36        6L      LDR      r4,[pc,#216] ; [0x20ade8] = 0x20d3cc
        0x0020ad10:    20e6        .       MOVS     r0,#0xe6
        0x0020ad12:    9000        ..      STR      r0,[sp,#0]
        0x0020ad14:    4b33        3K      LDR      r3,[pc,#204] ; [0x20ade4] = 0x20bff0
        0x0020ad16:    2200        ."      MOVS     r2,#0
        0x0020ad18:    a901        ..      ADD      r1,sp,#4
        0x0020ad1a:    6860        `h      LDR      r0,[r4,#4]
        0x0020ad1c:    f61bf962    ..b.    BL       os_msg_send_intern ; 0x25fe4
        0x0020ad20:    b168        h.      CBZ      r0,0x20ad3e ; UART0_Handler + 112
;;;231            {
;;;232            }
;;;233            else if (os_msg_send(h_event_q, &event, 0) == false)
        0x0020ad22:    20e9        .       MOVS     r0,#0xe9
        0x0020ad24:    9000        ..      STR      r0,[sp,#0]
        0x0020ad26:    4b2f        /K      LDR      r3,[pc,#188] ; [0x20ade4] = 0x20bff0
        0x0020ad28:    2200        ."      MOVS     r2,#0
        0x0020ad2a:    a904        ..      ADD      r1,sp,#0x10
        0x0020ad2c:    6820         h      LDR      r0,[r4,#0]
        0x0020ad2e:    f61bf959    ..Y.    BL       os_msg_send_intern ; 0x25fe4
        0x0020ad32:    e004        ..      B        0x20ad3e ; UART0_Handler + 112
;;;234            {
;;;235            }
;;;236            break;
;;;237    
;;;238        case UART_INT_ID_RX_TMEOUT:
;;;239            break;
;;;240    
;;;241        /* receive line status interrupt */
;;;242        case UART_INT_ID_LINE_STATUS:
;;;243            {
;;;244                DBG_DIRECT("Line status error!!!!\n");
        0x0020ad34:    a12d        -.      ADR      r1,{pc}+0xb8 ; 0x20adec
        0x0020ad36:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0020ad3a:    f5fcfe39    ..9.    BL       log_direct ; 0x79b0
;;;245            }
;;;246            break;
;;;247    
;;;248        case UART_INT_ID_MODEM_STATUS:
;;;249            break;
;;;250    
;;;251        default:
;;;252            break;
;;;253        }
;;;254    
;;;255        /* enable interrupt again */
;;;256        UART_INTConfig(UART, UART_INT_RD_AVA, ENABLE);
        0x0020ad3e:    2201        ."      MOVS     r2,#1
        0x0020ad40:    4611        .F      MOV      r1,r2
        0x0020ad42:    4628        (F      MOV      r0,r5
        0x0020ad44:    f011fac5    ....    BL       UART_INTConfig ; 0x21c2d2
;;;257    
;;;258        return;
;;;259    }
        0x0020ad48:    b005        ..      ADD      sp,sp,#0x14
        0x0020ad4a:    bd30        0.      POP      {r4,r5,pc}
    data_uart_init
;;;260    
;;;261    /**
;;;262     * @brief  Initializes the Data UART.
;;;263     *
;;;264     * When data uart receives data, data uart will send an event IO_UART_MSG_TYPE to evt_queue_handle and send the data to io_queue_handle.
;;;265     * @param[in] event_queue_handle   Event queue handle which is created by APP.
;;;266     * @param[in] io_queue_handle      IO message queue handle which is created by APP.
;;;267     * @return void
;;;268     *
;;;269     * <b>Example usage</b>
;;;270     * \code{.c}
;;;271        void app_main_task(void *p_param)
;;;272        {
;;;273            char event;
;;;274    
;;;275            os_msg_queue_create(&io_queue_handle, MAX_NUMBER_OF_IO_MESSAGE, sizeof(T_IO_MSG));
;;;276            os_msg_queue_create(&evt_queue_handle, MAX_NUMBER_OF_EVENT_MESSAGE, sizeof(unsigned char));
;;;277    
;;;278            gap_start_bt_stack(evt_queue_handle, io_queue_handle, MAX_NUMBER_OF_GAP_MESSAGE);
;;;279    
;;;280            data_uart_init(evt_queue_handle, io_queue_handle);
;;;281            ......
;;;282        }
;;;283        void app_handle_io_msg(T_IO_MSG io_msg)
;;;284        {
;;;285            uint16_t msg_type = io_msg.type;
;;;286            uint8_t rx_char;
;;;287    
;;;288            switch (msg_type)
;;;289            {
;;;290            case IO_MSG_TYPE_UART:
;;;291                // We handle user command informations from Data UART in this branch.
;;;292                rx_char = (uint8_t)io_msg.subtype;
;;;293                user_cmd_collect(&user_cmd_if, &rx_char, sizeof(rx_char), user_cmd_table);
;;;294                break;
;;;295            default:
;;;296                break;
;;;297            }
;;;298        }
;;;299     * \endcode
;;;300     */
;;;301    void data_uart_init(void *event_queue_handle, void *io_queue_handle)
;;;302    {
        0x0020ad4c:    b530        0.      PUSH     {r4,r5,lr}
        0x0020ad4e:    4a26        &J      LDR      r2,[pc,#152] ; [0x20ade8] = 0x20d3cc
;;; ..\..\..\src\mcu\module\data_uart_cmd\data_uart.c (302)
        0x0020ad50:    b08d        ..      SUB      sp,sp,#0x34
;;;303    
;;;304        h_event_q = event_queue_handle;
        0x0020ad52:    e9c20100    ....    STRD     r0,r1,[r2,#0]
;;;305        h_io_q = io_queue_handle;
;;;306    
;;;307        RCC_PeriphClockCmd(APBPeriph_UART0, APBPeriph_UART0_CLOCK, ENABLE);
        0x0020ad56:    2201        ."      MOVS     r2,#1
        0x0020ad58:    492a        *I      LDR      r1,[pc,#168] ; [0x20ae04] = 0x40000001
        0x0020ad5a:    482b        +H      LDR      r0,[pc,#172] ; [0x20ae08] = 0x8000001
        0x0020ad5c:    f7fdf814    ....    BL       RCC_PeriphClockCmd ; 0x207d88
;;;308        Pinmux_Config(DATA_UART_TX_PIN, UART0_TX);
        0x0020ad60:    2123        #!      MOVS     r1,#0x23
        0x0020ad62:    2018        .       MOVS     r0,#0x18
        0x0020ad64:    f606fb06    ....    BL       Pinmux_Config ; 0x11374
;;;309        Pinmux_Config(DATA_UART_RX_PIN, UART0_RX);
        0x0020ad68:    2124        $!      MOVS     r1,#0x24
        0x0020ad6a:    2019        .       MOVS     r0,#0x19
        0x0020ad6c:    f606fb02    ....    BL       Pinmux_Config ; 0x11374
;;;310        Pad_Config(DATA_UART_TX_PIN, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE,
        0x0020ad70:    2401        .$      MOVS     r4,#1
        0x0020ad72:    9400        ..      STR      r4,[sp,#0]
        0x0020ad74:    2300        .#      MOVS     r3,#0
        0x0020ad76:    4622        "F      MOV      r2,r4
        0x0020ad78:    4621        !F      MOV      r1,r4
        0x0020ad7a:    2018        .       MOVS     r0,#0x18
        0x0020ad7c:    9401        ..      STR      r4,[sp,#4]
        0x0020ad7e:    f606fb2d    ..-.    BL       Pad_Config ; 0x113dc
;;;311                   PAD_OUT_HIGH);
;;;312        Pad_Config(DATA_UART_RX_PIN, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE,
        0x0020ad82:    2000        .       MOVS     r0,#0
        0x0020ad84:    2301        .#      MOVS     r3,#1
        0x0020ad86:    9000        ..      STR      r0,[sp,#0]
        0x0020ad88:    9001        ..      STR      r0,[sp,#4]
        0x0020ad8a:    461a        .F      MOV      r2,r3
        0x0020ad8c:    4619        .F      MOV      r1,r3
        0x0020ad8e:    2019        .       MOVS     r0,#0x19
        0x0020ad90:    f606fb24    ..$.    BL       Pad_Config ; 0x113dc
;;;313                   PAD_OUT_LOW);
;;;314    
;;;315        /* uart init */
;;;316        UART_InitTypeDef uartInitStruct;
;;;317        UART_StructInit(&uartInitStruct);
        0x0020ad94:    a802        ..      ADD      r0,sp,#8
        0x0020ad96:    f011fa74    ..t.    BL       UART_StructInit ; 0x21c282
        0x0020ad9a:    4d0c        .M      LDR      r5,[pc,#48] ; [0x20adcc] = 0x40012000
;;;318        uartInitStruct.rxTriggerLevel = UART_RX_FIFO_TRIGGER_LEVEL_1BYTE;
        0x0020ad9c:    f8ad4016    ...@    STRH     r4,[sp,#0x16]
;;;319        UART_Init(UART, &uartInitStruct);
        0x0020ada0:    a902        ..      ADD      r1,sp,#8
        0x0020ada2:    4628        (F      MOV      r0,r5
        0x0020ada4:    f011f9f4    ....    BL       UART_Init ; 0x21c190
;;;320        UART_INTConfig(UART, UART_INT_RD_AVA, ENABLE);
        0x0020ada8:    2201        ."      MOVS     r2,#1
        0x0020adaa:    4611        .F      MOV      r1,r2
        0x0020adac:    4628        (F      MOV      r0,r5
        0x0020adae:    f011fa90    ....    BL       UART_INTConfig ; 0x21c2d2
;;;321    
;;;322        /*  Enable UART IRQ  */
;;;323        NVIC_InitTypeDef nvic_init_struct;
;;;324        nvic_init_struct.NVIC_IRQChannel         = UART0_IRQn;
        0x0020adb2:    200c        .       MOVS     r0,#0xc
        0x0020adb4:    f88d0024    ..$.    STRB     r0,[sp,#0x24]
        0x0020adb8:    2005        .       MOVS     r0,#5
        0x0020adba:    900a        ..      STR      r0,[sp,#0x28]
;;;325        nvic_init_struct.NVIC_IRQChannelCmd      = ENABLE;
        0x0020adbc:    f88d402c    ..,@    STRB     r4,[sp,#0x2c]
;;;326        nvic_init_struct.NVIC_IRQChannelPriority = 5;
;;;327        NVIC_Init(&nvic_init_struct);
        0x0020adc0:    a809        ..      ADD      r0,sp,#0x24
        0x0020adc2:    f606fa7d    ..}.    BL       NVIC_Init ; 0x112c0
;;;328    }
        0x0020adc6:    b00d        ..      ADD      sp,sp,#0x34
        0x0020adc8:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x0020adca:    0000        ..      DCW    0
        0x0020adcc:    40012000    . .@    DCD    1073815552
        0x0020add0:    33323130    0123    DCD    858927408
        0x0020add4:    37363534    4567    DCD    926299444
        0x0020add8:    42413938    89AB    DCD    1111570744
        0x0020addc:    46454443    CDEF    DCD    1178944579
        0x0020ade0:    00000000    ....    DCD    0
        0x0020ade4:    0020bff0    .. .    DCD    2146288
        0x0020ade8:    0020d3cc    .. .    DCD    2151372
        0x0020adec:    656e694c    Line    DCD    1701734732
        0x0020adf0:    61747320     sta    DCD    1635021600
        0x0020adf4:    20737574    tus     DCD    544437620
        0x0020adf8:    6f727265    erro    DCD    1869771365
        0x0020adfc:    21212172    r!!!    DCD    555819378
        0x0020ae00:    00000a21    !...    DCD    2593
        0x0020ae04:    40000001    ...@    DCD    1073741825
        0x0020ae08:    08000001    ....    DCD    134217729
    $t
    .text
    cmd_send_result
;;; ..\..\..\src\mcu\module\data_uart_cmd\user_cmd_parse.c
;;;133        switch (result)
        0x0020ae0c:    280a        .(      CMP      r0,#0xa
        0x0020ae0e:    d033        3.      BEQ      0x20ae78 ; cmd_send_result + 108
        0x0020ae10:    dc07        ..      BGT      0x20ae22 ; cmd_send_result + 22
        0x0020ae12:    d23d        =.      BCS      0x20ae90 ; cmd_send_result + 132
        0x0020ae14:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x0020ae18:    22201e3c    <. "    DCD    572530236
        0x0020ae1c:    2a282624    $&(*    DCD    707274276
        0x0020ae20:    2e2c        ,.      DCW    11820
    $t
        0x0020ae22:    2824        $(      CMP      r0,#0x24
        0x0020ae24:    d02e        ..      BEQ      0x20ae84 ; cmd_send_result + 120
        0x0020ae26:    dc09        ..      BGT      0x20ae3c ; cmd_send_result + 48
        0x0020ae28:    280b        .(      CMP      r0,#0xb
        0x0020ae2a:    d027        '.      BEQ      0x20ae7c ; cmd_send_result + 112
        0x0020ae2c:    2820         (      CMP      r0,#0x20
        0x0020ae2e:    d00f        ..      BEQ      0x20ae50 ; cmd_send_result + 68
        0x0020ae30:    2822        "(      CMP      r0,#0x22
        0x0020ae32:    d025        %.      BEQ      0x20ae80 ; cmd_send_result + 116
        0x0020ae34:    2823        #(      CMP      r0,#0x23
        0x0020ae36:    d12b        +.      BNE      0x20ae90 ; cmd_send_result + 132
        0x0020ae38:    a1ab        ..      ADR      r1,{pc}+0x2b0 ; 0x20b0e8
        0x0020ae3a:    e006        ..      B        0x20ae4a ; cmd_send_result + 62
;;; ..\..\..\src\mcu\module\data_uart_cmd\user_cmd_parse.c (133)
        0x0020ae3c:    2825        %(      CMP      r0,#0x25
        0x0020ae3e:    d023        #.      BEQ      0x20ae88 ; cmd_send_result + 124
        0x0020ae40:    2826        &(      CMP      r0,#0x26
        0x0020ae42:    d023        #.      BEQ      0x20ae8c ; cmd_send_result + 128
        0x0020ae44:    28ff        .(      CMP      r0,#0xff
        0x0020ae46:    d123        #.      BNE      0x20ae90 ; cmd_send_result + 132
        0x0020ae48:    a1ac        ..      ADR      r1,{pc}+0x2b4 ; 0x20b0fc
        0x0020ae4a:    a0b2        ..      ADR      r0,{pc}+0x2ca ; 0x20b114
        0x0020ae4c:    f7ffbee8    ....    B.W      data_uart_print ; 0x20ac20
;;;134        {
;;;135        case RESULT_ERR:
;;;136            data_uart_print("%s\r\n", "CMD:Error");
        0x0020ae50:    a1b2        ..      ADR      r1,{pc}+0x2cc ; 0x20b11c
;;;137            break;
        0x0020ae52:    e7fa        ..      B        0x20ae4a ; cmd_send_result + 62
;;;138        case RESULT_GAP_CAUSE_ALREADY_IN_REQ:
;;;139            data_uart_print("%s\r\n", "GAP_CAUSE_ALREADY_IN_REQ");
        0x0020ae54:    a1b4        ..      ADR      r1,{pc}+0x2d4 ; 0x20b128
;;;140            break;
        0x0020ae56:    e7f8        ..      B        0x20ae4a ; cmd_send_result + 62
;;;141        case RESULT_GAP_CAUSE_INVALID_STATE:
;;;142            data_uart_print("%s\r\n", "GAP_CAUSE_INVALID_STATE");
        0x0020ae58:    a1ba        ..      ADR      r1,{pc}+0x2ec ; 0x20b144
;;;143            break;
        0x0020ae5a:    e7f6        ..      B        0x20ae4a ; cmd_send_result + 62
;;;144        case RESULT_GAP_CAUSE_INVALID_PARAM:
;;;145            data_uart_print("%s\r\n", "GAP_CAUSE_INVALID_PARAM");
        0x0020ae5c:    a1bf        ..      ADR      r1,{pc}+0x300 ; 0x20b15c
;;;146            break;
        0x0020ae5e:    e7f4        ..      B        0x20ae4a ; cmd_send_result + 62
;;;147        case RESULT_GAP_CAUSE_NON_CONN:
;;;148            data_uart_print("%s\r\n", "GAP_CAUSE_NON_CONN");
        0x0020ae60:    a1c4        ..      ADR      r1,{pc}+0x314 ; 0x20b174
;;;149            break;
        0x0020ae62:    e7f2        ..      B        0x20ae4a ; cmd_send_result + 62
;;;150        case RESULT_GAP_CAUSE_NOT_FIND_IRK:
;;;151            data_uart_print("%s\r\n", "GAP_CAUSE_NOT_FIND_IRK");
        0x0020ae64:    a1c8        ..      ADR      r1,{pc}+0x324 ; 0x20b188
;;;152            break;
        0x0020ae66:    e7f0        ..      B        0x20ae4a ; cmd_send_result + 62
;;;153        case RESULT_GAP_CAUSE_ERROR_CREDITS:
;;;154            data_uart_print("%s\r\n", "GAP_CAUSE_ERROR_CREDITS");
        0x0020ae68:    a1cd        ..      ADR      r1,{pc}+0x338 ; 0x20b1a0
;;;155            break;
        0x0020ae6a:    e7ee        ..      B        0x20ae4a ; cmd_send_result + 62
;;;156        case RESULT_GAP_CAUSE_SEND_REQ_FAILED:
;;;157            data_uart_print("%s\r\n", "GAP_CAUSE_SEND_REQ_FAILED");
        0x0020ae6c:    a1d2        ..      ADR      r1,{pc}+0x34c ; 0x20b1b8
;;;158            break;
        0x0020ae6e:    e7ec        ..      B        0x20ae4a ; cmd_send_result + 62
;;;159        case RESULT_GAP_CAUSE_NO_RESOURCE:
;;;160            data_uart_print("%s\r\n", "GAP_CAUSE_NO_RESOURCE");
        0x0020ae70:    a1d8        ..      ADR      r1,{pc}+0x364 ; 0x20b1d4
;;;161            break;
        0x0020ae72:    e7ea        ..      B        0x20ae4a ; cmd_send_result + 62
;;;162        case RESULT_GAP_CAUSE_INVALID_PDU_SIZE:
;;;163            data_uart_print("%s\r\n", "GAP_CAUSE_INVALID_PDU_SIZE");
        0x0020ae74:    a1dd        ..      ADR      r1,{pc}+0x378 ; 0x20b1ec
;;;164            break;
        0x0020ae76:    e7e8        ..      B        0x20ae4a ; cmd_send_result + 62
;;;165        case RESULT_GAP_CAUSE_NOT_FIND:
;;;166            data_uart_print("%s\r\n", "GAP_CAUSE_NOT_FIND");
        0x0020ae78:    a1e3        ..      ADR      r1,{pc}+0x390 ; 0x20b208
;;;167            break;
        0x0020ae7a:    e7e6        ..      B        0x20ae4a ; cmd_send_result + 62
;;;168        case RESULT_GAP_CAUSE_CONN_LIMIT:
;;;169            data_uart_print("%s\r\n", "GAP_CAUSE_CONN_LIMIT");
        0x0020ae7c:    a1e7        ..      ADR      r1,{pc}+0x3a0 ; 0x20b21c
;;;170            break;
        0x0020ae7e:    e7e4        ..      B        0x20ae4a ; cmd_send_result + 62
;;;171        case RESULT_CMD_NOT_FOUND:
;;;172            data_uart_print("%s\r\n", "CMD:Command not found");
        0x0020ae80:    a1ec        ..      ADR      r1,{pc}+0x3b4 ; 0x20b234
;;;173            break;
        0x0020ae82:    e7e2        ..      B        0x20ae4a ; cmd_send_result + 62
;;;174        case RESULT_CMD_ERR_PARAM_NUM:
;;;175            data_uart_print("%s\r\n", "CMD:Wrong number of parameters");
        0x0020ae84:    a1f1        ..      ADR      r1,{pc}+0x3c8 ; 0x20b24c
;;;176            break;
        0x0020ae86:    e7e0        ..      B        0x20ae4a ; cmd_send_result + 62
;;;177        case RESULT_CMD_ERR_PARAM:
;;;178            data_uart_print("%s\r\n", "CMD:Wrong parameter");
;;;179            break;
;;;180        case RESULT_CMD_OUT_OF_RANGE:
;;;181            data_uart_print("%s\r\n", "CMD:Value out of range");
        0x0020ae88:    a1f8        ..      ADR      r1,{pc}+0x3e4 ; 0x20b26c
;;;182            break;
        0x0020ae8a:    e7de        ..      B        0x20ae4a ; cmd_send_result + 62
;;;183        case RESULT_CMD_NOT_SUPPORT:
;;;184            data_uart_print("%s\r\n", "CMD:Not support");
        0x0020ae8c:    a1fd        ..      ADR      r1,{pc}+0x3f8 ; 0x20b284
;;;185            break;
        0x0020ae8e:    e7dc        ..      B        0x20ae4a ; cmd_send_result + 62
;;;186        case RESULT_GAP_CAUSE_ERROR_UNKNOWN:
;;;187            data_uart_print("%s\r\n", "GAP_CAUSE_ERROR_UNKNOWN");
;;;188            break;
;;;189        default:
;;;190            break;
;;;191        }
;;;192    }
        0x0020ae90:    4770        pG      BX       lr
    user_cmd_parse
        0x0020ae92:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0020ae96:    2600        .&      MOVS     r6,#0
        0x0020ae98:    600e        .`      STR      r6,[r1,#0]
        0x0020ae9a:    460d        .F      MOV      r5,r1
        0x0020ae9c:    604e        N`      STR      r6,[r1,#4]
        0x0020ae9e:    4631        1F      MOV      r1,r6
        0x0020aea0:    eb050281    ....    ADD      r2,r5,r1,LSL #2
        0x0020aea4:    1c49        I.      ADDS     r1,r1,#1
        0x0020aea6:    6516        .e      STR      r6,[r2,#0x50]
        0x0020aea8:    6096        .`      STR      r6,[r2,#8]
        0x0020aeaa:    2912        .)      CMP      r1,#0x12
        0x0020aeac:    dbf8        ..      BLT      0x20aea0 ; user_cmd_parse + 14
        0x0020aeae:    f000fa92    ....    BL       user_cmd_skip_spaces ; 0x20b3d6
        0x0020aeb2:    4604        .F      MOV      r4,r0
        0x0020aeb4:    7800        .x      LDRB     r0,[r0,#0]
        0x0020aeb6:    b120         .      CBZ      r0,0x20aec2 ; user_cmd_parse + 48
        0x0020aeb8:    4620         F      MOV      r0,r4
        0x0020aeba:    f000fa97    ....    BL       user_cmd_find_end_of_word ; 0x20b3ec
        0x0020aebe:    4284        .B      CMP      r4,r0
        0x0020aec0:    d102        ..      BNE      0x20aec8 ; user_cmd_parse + 54
        0x0020aec2:    2021        !       MOVS     r0,#0x21
        0x0020aec4:    e8bd81f0    ....    POP      {r4-r8,pc}
        0x0020aec8:    602c        ,`      STR      r4,[r5,#0]
        0x0020aeca:    f8006b01    ...k    STRB     r6,[r0],#1
        0x0020aece:    7801        .x      LDRB     r1,[r0,#0]
        0x0020aed0:    b391        ..      CBZ      r1,0x20af38 ; user_cmd_parse + 166
        0x0020aed2:    2400        .$      MOVS     r4,#0
        0x0020aed4:    f000fa7f    ....    BL       user_cmd_skip_spaces ; 0x20b3d6
        0x0020aed8:    2200        ."      MOVS     r2,#0
        0x0020aeda:    7801        .x      LDRB     r1,[r0,#0]
        0x0020aedc:    4607        .F      MOV      r7,r0
;;; ..\..\..\src\mcu\module\data_uart_cmd\user_cmd_parse.c (76)
        0x0020aede:    4613        .F      MOV      r3,r2
;;;77     
;;;78         /* check if value is dec */
;;;79         if (p[0] == 'x')
        0x0020aee0:    2978        x)      CMP      r1,#0x78
        0x0020aee2:    d002        ..      BEQ      0x20aeea ; user_cmd_parse + 88
        0x0020aee4:    2930        0)      CMP      r1,#0x30
        0x0020aee6:    d003        ..      BEQ      0x20aef0 ; user_cmd_parse + 94
        0x0020aee8:    e007        ..      B        0x20aefa ; user_cmd_parse + 104
;;;80         {
;;;81             hex = true;
        0x0020aeea:    2301        .#      MOVS     r3,#1
;;;82             p = &p[1];
        0x0020aeec:    1c78        x.      ADDS     r0,r7,#1
        0x0020aeee:    e004        ..      B        0x20aefa ; user_cmd_parse + 104
;;;83         }
;;;84         else if ((p[0] == '0') && (p[1] == 'x'))
        0x0020aef0:    7841        Ax      LDRB     r1,[r0,#1]
        0x0020aef2:    2978        x)      CMP      r1,#0x78
        0x0020aef4:    d101        ..      BNE      0x20aefa ; user_cmd_parse + 104
;;;85         {
;;;86             hex = true;
        0x0020aef6:    2301        .#      MOVS     r3,#1
;;;87             p = &p[2];
        0x0020aef8:    1cb8        ..      ADDS     r0,r7,#2
;;;88         }
;;;89     
;;;90         for (;;)
;;;91         {
;;;92             char     ch;
;;;93             ch = *(p++) | 0x20;                 /* convert to lower case */
        0x0020aefa:    f8101b01    ....    LDRB     r1,[r0],#1
        0x0020aefe:    f0410120    A. .    ORR      r1,r1,#0x20
;;;94     
;;;95             if (hex)                            /* dec value */
        0x0020af02:    b173        s.      CBZ      r3,0x20af22 ; user_cmd_parse + 144
;;;96             {
;;;97                 /* hex value */
;;;98                 if ((ch >= 'a') && (ch <= 'f'))
        0x0020af04:    f1a10c61    ..a.    SUB      r12,r1,#0x61
        0x0020af08:    f1bc0f05    ....    CMP      r12,#5
        0x0020af0c:    d801        ..      BHI      0x20af12 ; user_cmd_parse + 128
        0x0020af0e:    3957        W9      SUBS     r1,r1,#0x57
;;;99                 {
;;;100                    ch -= ('a' - 10);
        0x0020af10:    e002        ..      B        0x20af18 ; user_cmd_parse + 134
        0x0020af12:    3930        09      SUBS     r1,r1,#0x30
;;;101                }
;;;102                else if ((ch >= '0') && (ch <= '9'))
        0x0020af14:    2909        .)      CMP      r1,#9
        0x0020af16:    d810        ..      BHI      0x20af3a ; user_cmd_parse + 168
        0x0020af18:    f001010f    ....    AND      r1,r1,#0xf
        0x0020af1c:    eb011202    ....    ADD      r2,r1,r2,LSL #4
;;;103                {
;;;104                    ch -= '0';
        0x0020af20:    e7eb        ..      B        0x20aefa ; user_cmd_parse + 104
;;;105                }
;;;106                else
;;;107                {
;;;108                    break;
;;;109                }
;;;110                result = (result << 4);
;;;111                result += (ch & 0x0f);
;;;112            }
;;;113            else
;;;114            {
;;;115                if (ch < '0' || ch > '9')
        0x0020af22:    f1a10c30    ..0.    SUB      r12,r1,#0x30
        0x0020af26:    f1bc0f0a    ....    CMP      r12,#0xa
        0x0020af2a:    d206        ..      BCS      0x20af3a ; user_cmd_parse + 168
;;;116                {
;;;117                    break;    /* end of string reached */
;;;118                }
;;;119                result = 10 * result + ch - '0';
        0x0020af2c:    eb020282    ....    ADD      r2,r2,r2,LSL #2
        0x0020af30:    eb010242    ..B.    ADD      r2,r1,r2,LSL #1
        0x0020af34:    3a30        0:      SUBS     r2,r2,#0x30
        0x0020af36:    e7e0        ..      B        0x20aefa ; user_cmd_parse + 104
        0x0020af38:    e00f        ..      B        0x20af5a ; user_cmd_parse + 200
;;;120            }
;;;121        }
;;;122        return (result);
;;;123    }
;;;124    
;;;125    /**
;;;126     * @brief  Send result, display in UART Assitant.
;;;127     *
;;;128     * @param result    Command parse result.
;;;129     * @return none
;;;130    */
;;;131    static void cmd_send_result(T_USER_CMD_PARSE_RESULT result)
;;;132    {
;;;133        switch (result)
;;;134        {
;;;135        case RESULT_ERR:
;;;136            data_uart_print("%s\r\n", "CMD:Error");
;;;137            break;
;;;138        case RESULT_GAP_CAUSE_ALREADY_IN_REQ:
;;;139            data_uart_print("%s\r\n", "GAP_CAUSE_ALREADY_IN_REQ");
;;;140            break;
;;;141        case RESULT_GAP_CAUSE_INVALID_STATE:
;;;142            data_uart_print("%s\r\n", "GAP_CAUSE_INVALID_STATE");
;;;143            break;
;;;144        case RESULT_GAP_CAUSE_INVALID_PARAM:
;;;145            data_uart_print("%s\r\n", "GAP_CAUSE_INVALID_PARAM");
;;;146            break;
;;;147        case RESULT_GAP_CAUSE_NON_CONN:
;;;148            data_uart_print("%s\r\n", "GAP_CAUSE_NON_CONN");
;;;149            break;
;;;150        case RESULT_GAP_CAUSE_NOT_FIND_IRK:
;;;151            data_uart_print("%s\r\n", "GAP_CAUSE_NOT_FIND_IRK");
;;;152            break;
;;;153        case RESULT_GAP_CAUSE_ERROR_CREDITS:
;;;154            data_uart_print("%s\r\n", "GAP_CAUSE_ERROR_CREDITS");
;;;155            break;
;;;156        case RESULT_GAP_CAUSE_SEND_REQ_FAILED:
;;;157            data_uart_print("%s\r\n", "GAP_CAUSE_SEND_REQ_FAILED");
;;;158            break;
;;;159        case RESULT_GAP_CAUSE_NO_RESOURCE:
;;;160            data_uart_print("%s\r\n", "GAP_CAUSE_NO_RESOURCE");
;;;161            break;
;;;162        case RESULT_GAP_CAUSE_INVALID_PDU_SIZE:
;;;163            data_uart_print("%s\r\n", "GAP_CAUSE_INVALID_PDU_SIZE");
;;;164            break;
;;;165        case RESULT_GAP_CAUSE_NOT_FIND:
;;;166            data_uart_print("%s\r\n", "GAP_CAUSE_NOT_FIND");
;;;167            break;
;;;168        case RESULT_GAP_CAUSE_CONN_LIMIT:
;;;169            data_uart_print("%s\r\n", "GAP_CAUSE_CONN_LIMIT");
;;;170            break;
;;;171        case RESULT_CMD_NOT_FOUND:
;;;172            data_uart_print("%s\r\n", "CMD:Command not found");
;;;173            break;
;;;174        case RESULT_CMD_ERR_PARAM_NUM:
;;;175            data_uart_print("%s\r\n", "CMD:Wrong number of parameters");
;;;176            break;
;;;177        case RESULT_CMD_ERR_PARAM:
;;;178            data_uart_print("%s\r\n", "CMD:Wrong parameter");
;;;179            break;
;;;180        case RESULT_CMD_OUT_OF_RANGE:
;;;181            data_uart_print("%s\r\n", "CMD:Value out of range");
;;;182            break;
;;;183        case RESULT_CMD_NOT_SUPPORT:
;;;184            data_uart_print("%s\r\n", "CMD:Not support");
;;;185            break;
;;;186        case RESULT_GAP_CAUSE_ERROR_UNKNOWN:
;;;187            data_uart_print("%s\r\n", "GAP_CAUSE_ERROR_UNKNOWN");
;;;188            break;
;;;189        default:
;;;190            break;
;;;191        }
;;;192    }
;;;193    
;;;194    /**
;;;195     * @brief   List cmd.
;;;196     *
;;;197     * @param p_cmd_table   Command table, include user self-definition command function.
;;;198     * @return  Command execute result.
;;;199    */
;;;200    static T_USER_CMD_PARSE_RESULT user_cmd_list(const T_USER_CMD_TABLE_ENTRY *p_cmd_table)
;;;201    {
;;;202        int32_t i = 0;
;;;203        T_USER_CMD_PARSE_RESULT result = RESULT_CMD_NOT_FOUND;
;;;204    
;;;205        /* find command in table */
;;;206        while ((p_cmd_table + i)->p_cmd != NULL)
;;;207        {
;;;208            data_uart_print("%s", (p_cmd_table + i)->p_option);
;;;209            data_uart_print("%s", "  *");
;;;210            data_uart_print("%s", (p_cmd_table + i)->p_help);
;;;211            result = RESULT_SUCESS;
;;;212            i++;
;;;213        };
;;;214    
;;;215        data_uart_print(",.\r\n  *up down\r\n");
;;;216        data_uart_print("[]\r\n  *left right\r\n");
;;;217        data_uart_print("/\\\r\n  *home end\r\n");
;;;218        data_uart_print("backspace\r\n  *delete\r\n");
;;;219    
;;;220        return result;
;;;221    }
;;;222    
;;;223    /**
;;;224     * @brief  Execute command.
;;;225     *
;;;226     * @param p_parse_value     Command parse value.
;;;227     * @param p_cmd_table       Command table, include user self-definition command function.
;;;228     * @return  Command execute result.
;;;229    */
;;;230    static T_USER_CMD_PARSE_RESULT user_cmd_execute(T_USER_CMD_PARSED_VALUE *p_parse_value,
;;;231                                                    const T_USER_CMD_TABLE_ENTRY *p_cmd_table)
;;;232    {
;;;233        int32_t i = 0;
;;;234        T_USER_CMD_PARSE_RESULT result = RESULT_CMD_NOT_FOUND;
;;;235    
;;;236        if (strcmp((const char *)p_parse_value->p_cmd, (const char *)"?") == 0)
;;;237        {
;;;238            user_cmd_list(p_cmd_table);
;;;239            return RESULT_SUCESS;
;;;240        }
;;;241    
;;;242        /* find command in table */
;;;243        while ((p_cmd_table + i)->p_cmd != NULL)
;;;244        {
;;;245            if (strcmp((const char *)(p_cmd_table + i)->p_cmd, (const char *)p_parse_value->p_cmd) == 0)
;;;246            {
;;;247                /* check if user wants help */
;;;248                if (p_parse_value->param_count && *p_parse_value->p_param[0] == '?')
;;;249                {
;;;250                    data_uart_print("%s", (p_cmd_table + i)->p_option);
;;;251                    data_uart_print("%s", "  *");
;;;252                    data_uart_print("%s", (p_cmd_table + i)->p_help);
;;;253                    result = RESULT_SUCESS;
;;;254                }
;;;255                else
;;;256                {
;;;257                    /* execute command function */
;;;258                    result = (p_cmd_table + i)->func(p_parse_value);
;;;259                }
;;;260                /* exit while */
;;;261                break;
;;;262            }
;;;263            i++;
;;;264        };
;;;265    
;;;266        return result;
;;;267    }
;;;268    
;;;269    /**
;;;270     * @brief  Parse a command line and return the found command and parameters in "p_parse_value"
;;;271     *
;;;272     * @param p_user_cmd_if     Command parsed.
;;;273     * @param p_parse_value     Command parse value.
;;;274     * @return  Command parse result.
;;;275    */
;;;276    static T_USER_CMD_PARSE_RESULT user_cmd_parse(T_USER_CMD_IF *p_user_cmd_if,
;;;277                                                  T_USER_CMD_PARSED_VALUE *p_parse_value)
;;;278    {
;;;279        int32_t i;
;;;280        char *p, *q;
;;;281    
;;;282        /* clear all results */
;;;283        p_parse_value->p_cmd       = NULL;
;;;284        p_parse_value->param_count = 0;
;;;285        for (i = 0 ; i < USER_CMD_MAX_PARAMETERS; i++)
;;;286        {
;;;287            p_parse_value->p_param[i]  = NULL;
;;;288            p_parse_value->dw_param[i] = 0;
;;;289        }
;;;290    
;;;291        /* Parse line */
;;;292        p = p_user_cmd_if->cmdline_buf;
;;;293    
;;;294        /*ignore leading spaces */
;;;295        p = user_cmd_skip_spaces(p);
;;;296        if (*p == '\0')                     /* empty command line ? */
;;;297        {
;;;298            return RESULT_CMD_EMPTY_LINE;
;;;299        }
;;;300    
;;;301        /* find end of word */
;;;302        q = user_cmd_find_end_of_word(p);
;;;303        if (p == q)                         /* empty command line ? */
;;;304        {
;;;305            return RESULT_CMD_EMPTY_LINE;
;;;306        }
;;;307    
;;;308        p_parse_value->p_cmd = p;
;;;309        *q = '\0';                        /* mark end of command */
;;;310        p = q + 1;
;;;311    
;;;312        /* parse parameters */
;;;313        if (*p != '\0')                   /* end of line ? */
;;;314        {
;;;315            int32_t j;
;;;316    
;;;317            j = 0;
;;;318            do
;;;319            {
;;;320                uint32_t d;
;;;321                /* ignore leading spaces */
;;;322                p = user_cmd_skip_spaces(p);
;;;323                d = user_cmd_str_to_uint32(p);
;;;324    
;;;325                p_parse_value->p_param[j]    = p;
        0x0020af3a:    eb050084    ....    ADD      r0,r5,r4,LSL #2
;;;326                p_parse_value->dw_param[j++] = d;
        0x0020af3e:    1c64        d.      ADDS     r4,r4,#1
;;;327    
;;;328                if (j >= USER_CMD_MAX_PARAMETERS)
        0x0020af40:    6507        .e      STR      r7,[r0,#0x50]
        0x0020af42:    6082        .`      STR      r2,[r0,#8]
        0x0020af44:    2c12        .,      CMP      r4,#0x12
        0x0020af46:    da07        ..      BGE      0x20af58 ; user_cmd_parse + 198
;;;329                {
;;;330                    break;
;;;331                }
;;;332    
;;;333                /* find next parameter */
;;;334                p  = user_cmd_find_end_of_word(p);
        0x0020af48:    4638        8F      MOV      r0,r7
        0x0020af4a:    f000fa4f    ..O.    BL       user_cmd_find_end_of_word ; 0x20b3ec
;;;335                *p++ = '\0';                        /* mark end of parameter */
        0x0020af4e:    f8006b01    ...k    STRB     r6,[r0],#1
;;;336            }
;;;337            while (*p != '\0');
        0x0020af52:    7801        .x      LDRB     r1,[r0,#0]
        0x0020af54:    2900        .)      CMP      r1,#0
        0x0020af56:    d1bd        ..      BNE      0x20aed4 ; user_cmd_parse + 66
;;;338    
;;;339            p_parse_value->param_count = j;
        0x0020af58:    606c        l`      STR      r4,[r5,#4]
;;;340        }
;;;341    
;;;342        return RESULT_SUCESS;
        0x0020af5a:    2000        .       MOVS     r0,#0
;;;343    }
        0x0020af5c:    e7b2        ..      B        0x20aec4 ; user_cmd_parse + 50
    cmd_clear_screen
;;;344    
;;;345    /**
;;;346     * @brief  Clear command line buffer.
;;;347     *
;;;348     * @param p_user_cmd_if     Command parsed.
;;;349     * @return none.
;;;350    */
;;;351    static void cmd_clear(T_USER_CMD_IF *p_user_cmd_if)
;;;352    {
;;;353        p_user_cmd_if->accum_cmd_len = 0;
;;;354        p_user_cmd_if->cmd_cur = 0;
;;;355        memset(p_user_cmd_if->cmdline_buf, 0, sizeof(p_user_cmd_if->cmdline_buf));
;;;356    }
;;;357    
;;;358    static void cmd_move_back(T_USER_CMD_IF *p_user_cmd_if)
;;;359    {
;;;360        for (uint8_t loop = 0; loop < p_user_cmd_if->accum_cmd_len - p_user_cmd_if->cmd_cur; loop ++)
;;;361        {
;;;362            p_user_cmd_if->cmdline_buf[p_user_cmd_if->accum_cmd_len - loop] =
;;;363                p_user_cmd_if->cmdline_buf[p_user_cmd_if->accum_cmd_len - loop - 1];
;;;364        }
;;;365    }
;;;366    
;;;367    static void cmd_move_forward(T_USER_CMD_IF *p_user_cmd_if)
;;;368    {
;;;369        for (uint8_t loop = 0; loop < p_user_cmd_if->accum_cmd_len - p_user_cmd_if->cmd_cur; loop ++)
;;;370        {
;;;371            p_user_cmd_if->cmdline_buf[p_user_cmd_if->cmd_cur + loop - 1] =
;;;372                p_user_cmd_if->cmdline_buf[p_user_cmd_if->cmd_cur + loop];
;;;373        }
;;;374    }
;;;375    static void cmd_clear_screen(T_USER_CMD_IF *p_user_cmd_if)
;;;376    {
        0x0020af5e:    b570        p.      PUSH     {r4-r6,lr}
        0x0020af60:    4604        .F      MOV      r4,r0
        0x0020af62:    f8900066    ..f.    LDRB     r0,[r0,#0x66]
        0x0020af66:    f8d411a0    ....    LDR      r1,[r4,#0x1a0]
        0x0020af6a:    2500        .%      MOVS     r5,#0
        0x0020af6c:    4288        .B      CMP      r0,r1
        0x0020af6e:    da0b        ..      BGE      0x20af88 ; cmd_clear_screen + 42
;;;377        if (p_user_cmd_if->cmd_cur < p_user_cmd_if->accum_cmd_len)
;;;378        {
;;;379            data_uart_print("%s", p_user_cmd_if->cmdline_buf + p_user_cmd_if->cmd_cur);
        0x0020af70:    1901        ..      ADDS     r1,r0,r4
        0x0020af72:    a0c8        ..      ADR      r0,{pc}+0x322 ; 0x20b294
        0x0020af74:    f7fffe54    ..T.    BL       data_uart_print ; 0x20ac20
        0x0020af78:    e006        ..      B        0x20af88 ; cmd_clear_screen + 42
        0x0020af7a:    1e40        @.      SUBS     r0,r0,#1
        0x0020af7c:    f8c401a0    ....    STR      r0,[r4,#0x1a0]
        0x0020af80:    5425        %T      STRB     r5,[r4,r0]
        0x0020af82:    a0c5        ..      ADR      r0,{pc}+0x316 ; 0x20b298
        0x0020af84:    f7fffe4c    ..L.    BL       data_uart_print ; 0x20ac20
;;;380        }
;;;381    
;;;382        while (p_user_cmd_if->accum_cmd_len != 0)
        0x0020af88:    f8d401a0    ....    LDR      r0,[r4,#0x1a0]
        0x0020af8c:    2800        .(      CMP      r0,#0
        0x0020af8e:    d1f4        ..      BNE      0x20af7a ; cmd_clear_screen + 28
;;;383        {
;;;384            p_user_cmd_if->accum_cmd_len--;
;;;385            p_user_cmd_if->cmdline_buf[p_user_cmd_if->accum_cmd_len] = '\0';
;;;386            data_uart_print("\b \b");
;;;387        }
;;;388        p_user_cmd_if->cmd_cur = 0;
        0x0020af90:    f8845066    ..fP    STRB     r5,[r4,#0x66]
;;;389    }
        0x0020af94:    bd70        p.      POP      {r4-r6,pc}
    user_cmd_collect
;;;390    
;;;391    /**
;;;392     * @brief  Collect command characters.
;;;393     *
;;;394     * @param[in] p_user_cmd_if   Store parsed commands.
;;;395     * @param[in] p_data          Data to be parsed.
;;;396     * @param[in] len             Length of data to be command parsed.
;;;397     * @param[in] p_cmd_table     Command table to execute function.
;;;398     * @return  Command collect result.
;;;399     * @retval 1 true.
;;;400     * @retval 0 false.
;;;401     *
;;;402     * <b>Example usage</b>
;;;403     * \code{.c}
;;;404        void app_handle_io_msg(T_IO_MSG io_msg)
;;;405        {
;;;406            uint16_t msg_type = io_msg.type;
;;;407            uint8_t rx_char;
;;;408    
;;;409            switch (msg_type)
;;;410            {
;;;411            case IO_MSG_TYPE_UART:
;;;412                // We handle user command informations from Data UART in this branch.
;;;413                rx_char = (uint8_t)io_msg.subtype;
;;;414                user_cmd_collect(&user_cmd_if, &rx_char, sizeof(rx_char), user_cmd_table);
;;;415                break;
;;;416            default:
;;;417                break;
;;;418            }
;;;419        }
;;;420     * \endcode
;;;421     */
;;;422    bool user_cmd_collect(T_USER_CMD_IF *p_user_cmd_if, uint8_t *p_data, int32_t len,
;;;423                          const T_USER_CMD_TABLE_ENTRY *p_cmd_table)
;;;424    {
        0x0020af96:    e92d47f0    -..G    PUSH     {r4-r10,lr}
        0x0020af9a:    b0a6        ..      SUB      sp,sp,#0x98
        0x0020af9c:    469a        .F      MOV      r10,r3
        0x0020af9e:    4691        .F      MOV      r9,r2
        0x0020afa0:    460e        .F      MOV      r6,r1
        0x0020afa2:    4604        .F      MOV      r4,r0
        0x0020afa4:    f04f0800    O...    MOV      r8,#0
        0x0020afa8:    2703        .'      MOVS     r7,#3
        0x0020afaa:    f2001599    ....    ADD      r5,r0,#0x199
        0x0020afae:    e1fc        ..      B        0x20b3aa ; user_cmd_collect + 1044
;;;425        T_USER_CMD_PARSED_VALUE parse_result;
;;;426    
;;;427        while (len--)
;;;428        {
;;;429            char c = *p_data++;
        0x0020afb0:    f8160b01    ....    LDRB     r0,[r6],#1
;;;430    
;;;431            if (c != 0x0)                   /* not ESC character received */
        0x0020afb4:    2800        .(      CMP      r0,#0
        0x0020afb6:    d0fa        ..      BEQ      0x20afae ; user_cmd_collect + 24
;;;432            {
;;;433                switch (c)                  /* Normal handling */
        0x0020afb8:    282e        .(      CMP      r0,#0x2e
        0x0020afba:    d07c        |.      BEQ      0x20b0b6 ; user_cmd_collect + 288
        0x0020afbc:    dc08        ..      BGT      0x20afd0 ; user_cmd_collect + 58
        0x0020afbe:    2808        .(      CMP      r0,#8
        0x0020afc0:    d060        `.      BEQ      0x20b084 ; user_cmd_collect + 238
        0x0020afc2:    280a        .(      CMP      r0,#0xa
        0x0020afc4:    d012        ..      BEQ      0x20afec ; user_cmd_collect + 86
        0x0020afc6:    280d        .(      CMP      r0,#0xd
        0x0020afc8:    d010        ..      BEQ      0x20afec ; user_cmd_collect + 86
        0x0020afca:    282c        ,(      CMP      r0,#0x2c
        0x0020afcc:    d108        ..      BNE      0x20afe0 ; user_cmd_collect + 74
        0x0020afce:    e16a        j.      B        0x20b2a6 ; user_cmd_collect + 784
        0x0020afd0:    282f        /(      CMP      r0,#0x2f
        0x0020afd2:    d071        q.      BEQ      0x20b0b8 ; user_cmd_collect + 290
        0x0020afd4:    285b        [(      CMP      r0,#0x5b
        0x0020afd6:    d070        p.      BEQ      0x20b0ba ; user_cmd_collect + 292
        0x0020afd8:    285c        \(      CMP      r0,#0x5c
        0x0020afda:    d06f        o.      BEQ      0x20b0bc ; user_cmd_collect + 294
        0x0020afdc:    285d        ](      CMP      r0,#0x5d
        0x0020afde:    d06e        n.      BEQ      0x20b0be ; user_cmd_collect + 296
        0x0020afe0:    f8d411a0    ....    LDR      r1,[r4,#0x1a0]
        0x0020afe4:    2964        d)      CMP      r1,#0x64
        0x0020afe6:    dae2        ..      BGE      0x20afae ; user_cmd_collect + 24
        0x0020afe8:    2100        .!      MOVS     r1,#0
        0x0020afea:    e1c1        ..      B        0x20b370 ; user_cmd_collect + 986
;;;434                {
;;;435                case '\n':
;;;436                case '\r':                  /* end of line */
;;;437                    //vsop data_uart_print("\r\n");
;;;438                    p_user_cmd_if->history_cur = USER_CMD_MAX_HISTORY_LINE;
        0x0020afec:    f884719e    ...q    STRB     r7,[r4,#0x19e]
;;;439    #if F_BT_DLPS_EN
;;;440                    data_uart_can_enter_dlps(true);
;;;441    #endif
;;;442                    if (p_user_cmd_if->accum_cmd_len > 0)  /* at least one character in command line ? */
        0x0020aff0:    f8d421a0    ...!    LDR      r2,[r4,#0x1a0]
        0x0020aff4:    2a00        .*      CMP      r2,#0
        0x0020aff6:    dd3c        <.      BLE      0x20b072 ; user_cmd_collect + 220
;;;443                    {
;;;444                        T_USER_CMD_PARSE_RESULT result;
;;;445    
;;;446                        // save cmd first
;;;447                        if (p_user_cmd_if->history_head == USER_CMD_MAX_HISTORY_LINE)
        0x0020aff8:    f894019c    ....    LDRB     r0,[r4,#0x19c]
        0x0020affc:    2803        .(      CMP      r0,#3
        0x0020affe:    d02c        ,.      BEQ      0x20b05a ; user_cmd_collect + 196
;;;448                        {
;;;449                            p_user_cmd_if->history_head = 0;
;;;450                            p_user_cmd_if->history_tail = 0;
;;;451                        }
;;;452                        else
;;;453                        {
;;;454                            p_user_cmd_if->history_tail = (p_user_cmd_if->history_tail + 1) % USER_CMD_MAX_HISTORY_LINE;
        0x0020b000:    f894119d    ....    LDRB     r1,[r4,#0x19d]
        0x0020b004:    1c49        I.      ADDS     r1,r1,#1
        0x0020b006:    fbb1f3f7    ....    UDIV     r3,r1,r7
        0x0020b00a:    fb071113    ....    MLS      r1,r7,r3,r1
        0x0020b00e:    f884119d    ....    STRB     r1,[r4,#0x19d]
;;;455                            if (p_user_cmd_if->history_tail == p_user_cmd_if->history_head)
        0x0020b012:    4281        .B      CMP      r1,r0
        0x0020b014:    d106        ..      BNE      0x20b024 ; user_cmd_collect + 142
        0x0020b016:    1c40        @.      ADDS     r0,r0,#1
;;;456                            {
;;;457                                p_user_cmd_if->history_head = (p_user_cmd_if->history_head + 1) % USER_CMD_MAX_HISTORY_LINE;
        0x0020b018:    fbb0f1f7    ....    UDIV     r1,r0,r7
        0x0020b01c:    fb070011    ....    MLS      r0,r7,r1,r0
        0x0020b020:    f884019c    ....    STRB     r0,[r4,#0x19c]
;;;458                            }
;;;459                        }
;;;460                        p_user_cmd_if->cmd_history_len[p_user_cmd_if->history_tail] = p_user_cmd_if->accum_cmd_len;
        0x0020b024:    f894019d    ....    LDRB     r0,[r4,#0x19d]
        0x0020b028:    4621        !F      MOV      r1,r4
        0x0020b02a:    5542        BU      STRB     r2,[r0,r5]
;;;461                        memcpy(p_user_cmd_if->cmd_history[p_user_cmd_if->history_tail], p_user_cmd_if->cmdline_buf,
        0x0020b02c:    f894019d    ....    LDRB     r0,[r4,#0x19d]
        0x0020b030:    f8d421a0    ...!    LDR      r2,[r4,#0x1a0]
        0x0020b034:    eb001000    ....    ADD      r0,r0,r0,LSL #4
        0x0020b038:    eb000040    ..@.    ADD      r0,r0,r0,LSL #1
        0x0020b03c:    eb040040    ..@.    ADD      r0,r4,r0,LSL #1
        0x0020b040:    3067        g0      ADDS     r0,r0,#0x67
        0x0020b042:    f64eff2a    N.*.    BL       __aeabi_memcpy ; 0x59e9a
;;;462                               p_user_cmd_if->accum_cmd_len);
;;;463    
;;;464                        p_user_cmd_if->cmdline_buf[p_user_cmd_if->accum_cmd_len] = '\0';
        0x0020b046:    f8d411a0    ....    LDR      r1,[r4,#0x1a0]
        0x0020b04a:    4620         F      MOV      r0,r4
        0x0020b04c:    f8048001    ....    STRB     r8,[r4,r1]
;;;465                        result = user_cmd_parse(p_user_cmd_if, &parse_result);
        0x0020b050:    4669        iF      MOV      r1,sp
        0x0020b052:    f7ffff1e    ....    BL       user_cmd_parse ; 0x20ae92
;;;466                        if (result == RESULT_SUCESS)
        0x0020b056:    b128        (.      CBZ      r0,0x20b064 ; user_cmd_collect + 206
        0x0020b058:    e009        ..      B        0x20b06e ; user_cmd_collect + 216
        0x0020b05a:    f884819c    ....    STRB     r8,[r4,#0x19c]
        0x0020b05e:    f884819d    ....    STRB     r8,[r4,#0x19d]
        0x0020b062:    e7df        ..      B        0x20b024 ; user_cmd_collect + 142
;;;467                        {
;;;468                            result = user_cmd_execute(&parse_result, p_cmd_table);
        0x0020b064:    4651        QF      MOV      r1,r10
        0x0020b066:    4668        hF      MOV      r0,sp
        0x0020b068:    f000f9cd    ....    BL       user_cmd_execute ; 0x20b406
        0x0020b06c:    b108        ..      CBZ      r0,0x20b072 ; user_cmd_collect + 220
;;;469                        }
;;;470    
;;;471                        if (result != RESULT_SUCESS)
;;;472                        {
;;;473                            cmd_send_result(result);
        0x0020b06e:    f7fffecd    ....    BL       cmd_send_result ; 0x20ae0c
        0x0020b072:    f8c481a0    ....    STR      r8,[r4,#0x1a0]
;;;474                        }
;;;475                    }
;;;476    
;;;477                    cmd_clear(p_user_cmd_if);
        0x0020b076:    4620         F      MOV      r0,r4
        0x0020b078:    f8848066    ..f.    STRB     r8,[r4,#0x66]
        0x0020b07c:    2166        f!      MOVS     r1,#0x66
        0x0020b07e:    f64effef    N...    BL       __aeabi_memclr4 ; 0x5a060
;;;478                    break;
        0x0020b082:    e192        ..      B        0x20b3aa ; user_cmd_collect + 1044
;;;479    
;;;480                case '\b':                        /* backspace */
;;;481                    if (p_user_cmd_if->accum_cmd_len > 0 && p_user_cmd_if->cmd_cur > 0)
        0x0020b084:    f8d401a0    ....    LDR      r0,[r4,#0x1a0]
        0x0020b088:    2800        .(      CMP      r0,#0
        0x0020b08a:    dd2c        ,.      BLE      0x20b0e6 ; user_cmd_collect + 336
        0x0020b08c:    f8940066    ..f.    LDRB     r0,[r4,#0x66]
        0x0020b090:    2800        .(      CMP      r0,#0
        0x0020b092:    d028        (.      BEQ      0x20b0e6 ; user_cmd_collect + 336
        0x0020b094:    2000        .       MOVS     r0,#0
;;;482                    {
;;;483                        uint8_t loop;
;;;484    
;;;485                        cmd_move_forward(p_user_cmd_if);
        0x0020b096:    e006        ..      B        0x20b0a6 ; user_cmd_collect + 272
        0x0020b098:    1822        ".      ADDS     r2,r4,r0
        0x0020b09a:    5c8b        .\      LDRB     r3,[r1,r2]
        0x0020b09c:    190a        ..      ADDS     r2,r1,r4
        0x0020b09e:    1e41        A.      SUBS     r1,r0,#1
        0x0020b0a0:    1c40        @.      ADDS     r0,r0,#1
        0x0020b0a2:    5453        ST      STRB     r3,[r2,r1]
        0x0020b0a4:    b2c0        ..      UXTB     r0,r0
        0x0020b0a6:    f8941066    ..f.    LDRB     r1,[r4,#0x66]
        0x0020b0aa:    f8d421a0    ...!    LDR      r2,[r4,#0x1a0]
        0x0020b0ae:    1a52        R.      SUBS     r2,r2,r1
        0x0020b0b0:    4282        .B      CMP      r2,r0
        0x0020b0b2:    dcf1        ..      BGT      0x20b098 ; user_cmd_collect + 258
;;;486                        p_user_cmd_if->accum_cmd_len--;
        0x0020b0b4:    e004        ..      B        0x20b0c0 ; user_cmd_collect + 298
        0x0020b0b6:    e10d        ..      B        0x20b2d4 ; user_cmd_collect + 830
        0x0020b0b8:    e14f        O.      B        0x20b35a ; user_cmd_collect + 964
        0x0020b0ba:    e135        5.      B        0x20b328 ; user_cmd_collect + 914
        0x0020b0bc:    e143        C.      B        0x20b346 ; user_cmd_collect + 944
        0x0020b0be:    e138        8.      B        0x20b332 ; user_cmd_collect + 924
        0x0020b0c0:    f8d401a0    ....    LDR      r0,[r4,#0x1a0]
        0x0020b0c4:    1e40        @.      SUBS     r0,r0,#1
;;;487                        p_user_cmd_if->cmd_cur--;
        0x0020b0c6:    f8c401a0    ....    STR      r0,[r4,#0x1a0]
        0x0020b0ca:    f8941066    ..f.    LDRB     r1,[r4,#0x66]
        0x0020b0ce:    1e49        I.      SUBS     r1,r1,#1
        0x0020b0d0:    f8841066    ..f.    STRB     r1,[r4,#0x66]
;;;488                        p_user_cmd_if->cmdline_buf[p_user_cmd_if->accum_cmd_len] = '\0';
        0x0020b0d4:    f8048000    ....    STRB     r8,[r4,r0]
        0x0020b0d8:    f8941066    ..f.    LDRB     r1,[r4,#0x66]
;;;489                        //vsop data_uart_print("\b%s", p_user_cmd_if->cmdline_buf + p_user_cmd_if->cmd_cur);
;;;490                        //vsop data_uart_print(" \b");
;;;491                        for (loop = 0; loop < p_user_cmd_if->accum_cmd_len - p_user_cmd_if->cmd_cur; loop++)
        0x0020b0dc:    f8d421a0    ...!    LDR      r2,[r4,#0x1a0]
        0x0020b0e0:    2000        .       MOVS     r0,#0
        0x0020b0e2:    1a51        Q.      SUBS     r1,r2,r1
        0x0020b0e4:    e0dc        ..      B        0x20b2a0 ; user_cmd_collect + 778
        0x0020b0e6:    e0f4        ..      B        0x20b2d2 ; user_cmd_collect + 828
    $d
        0x0020b0e8:    3a444d43    CMD:    DCD    977554755
        0x0020b0ec:    6e6f7257    Wron    DCD    1852797527
        0x0020b0f0:    61702067    g pa    DCD    1634738279
        0x0020b0f4:    656d6172    rame    DCD    1701667186
        0x0020b0f8:    00726574    ter.    DCD    7497076
        0x0020b0fc:    5f504147    GAP_    DCD    1599095111
        0x0020b100:    53554143    CAUS    DCD    1398096195
        0x0020b104:    52455f45    E_ER    DCD    1380278085
        0x0020b108:    5f524f52    ROR_    DCD    1599229778
        0x0020b10c:    4e4b4e55    UNKN    DCD    1313558101
        0x0020b110:    004e574f    OWN.    DCD    5134159
        0x0020b114:    0a0d7325    %s..    DCD    168653605
        0x0020b118:    00000000    ....    DCD    0
        0x0020b11c:    3a444d43    CMD:    DCD    977554755
        0x0020b120:    6f727245    Erro    DCD    1869771333
        0x0020b124:    00000072    r...    DCD    114
        0x0020b128:    5f504147    GAP_    DCD    1599095111
        0x0020b12c:    53554143    CAUS    DCD    1398096195
        0x0020b130:    4c415f45    E_AL    DCD    1279352645
        0x0020b134:    44414552    READ    DCD    1145128274
        0x0020b138:    4e495f59    Y_IN    DCD    1313431385
        0x0020b13c:    5145525f    _REQ    DCD    1363497567
        0x0020b140:    00000000    ....    DCD    0
        0x0020b144:    5f504147    GAP_    DCD    1599095111
        0x0020b148:    53554143    CAUS    DCD    1398096195
        0x0020b14c:    4e495f45    E_IN    DCD    1313431365
        0x0020b150:    494c4156    VALI    DCD    1229734230
        0x0020b154:    54535f44    D_ST    DCD    1414750020
        0x0020b158:    00455441    ATE.    DCD    4543553
        0x0020b15c:    5f504147    GAP_    DCD    1599095111
        0x0020b160:    53554143    CAUS    DCD    1398096195
        0x0020b164:    4e495f45    E_IN    DCD    1313431365
        0x0020b168:    494c4156    VALI    DCD    1229734230
        0x0020b16c:    41505f44    D_PA    DCD    1095786308
        0x0020b170:    004d4152    RAM.    DCD    5062994
        0x0020b174:    5f504147    GAP_    DCD    1599095111
        0x0020b178:    53554143    CAUS    DCD    1398096195
        0x0020b17c:    4f4e5f45    E_NO    DCD    1330536261
        0x0020b180:    4f435f4e    N_CO    DCD    1329815374
        0x0020b184:    00004e4e    NN..    DCD    20046
        0x0020b188:    5f504147    GAP_    DCD    1599095111
        0x0020b18c:    53554143    CAUS    DCD    1398096195
        0x0020b190:    4f4e5f45    E_NO    DCD    1330536261
        0x0020b194:    49465f54    T_FI    DCD    1229348692
        0x0020b198:    495f444e    ND_I    DCD    1230980174
        0x0020b19c:    00004b52    RK..    DCD    19282
        0x0020b1a0:    5f504147    GAP_    DCD    1599095111
        0x0020b1a4:    53554143    CAUS    DCD    1398096195
        0x0020b1a8:    52455f45    E_ER    DCD    1380278085
        0x0020b1ac:    5f524f52    ROR_    DCD    1599229778
        0x0020b1b0:    44455243    CRED    DCD    1145393731
        0x0020b1b4:    00535449    ITS.    DCD    5461065
        0x0020b1b8:    5f504147    GAP_    DCD    1599095111
        0x0020b1bc:    53554143    CAUS    DCD    1398096195
        0x0020b1c0:    45535f45    E_SE    DCD    1163091781
        0x0020b1c4:    525f444e    ND_R    DCD    1381975118
        0x0020b1c8:    465f5145    EQ_F    DCD    1180651845
        0x0020b1cc:    454c4941    AILE    DCD    1162627393
        0x0020b1d0:    00000044    D...    DCD    68
        0x0020b1d4:    5f504147    GAP_    DCD    1599095111
        0x0020b1d8:    53554143    CAUS    DCD    1398096195
        0x0020b1dc:    4f4e5f45    E_NO    DCD    1330536261
        0x0020b1e0:    5345525f    _RES    DCD    1397051999
        0x0020b1e4:    4352554f    OURC    DCD    1129469263
        0x0020b1e8:    00000045    E...    DCD    69
        0x0020b1ec:    5f504147    GAP_    DCD    1599095111
        0x0020b1f0:    53554143    CAUS    DCD    1398096195
        0x0020b1f4:    4e495f45    E_IN    DCD    1313431365
        0x0020b1f8:    494c4156    VALI    DCD    1229734230
        0x0020b1fc:    44505f44    D_PD    DCD    1146117956
        0x0020b200:    49535f55    U_SI    DCD    1230200661
        0x0020b204:    0000455a    ZE..    DCD    17754
        0x0020b208:    5f504147    GAP_    DCD    1599095111
        0x0020b20c:    53554143    CAUS    DCD    1398096195
        0x0020b210:    4f4e5f45    E_NO    DCD    1330536261
        0x0020b214:    49465f54    T_FI    DCD    1229348692
        0x0020b218:    0000444e    ND..    DCD    17486
        0x0020b21c:    5f504147    GAP_    DCD    1599095111
        0x0020b220:    53554143    CAUS    DCD    1398096195
        0x0020b224:    4f435f45    E_CO    DCD    1329815365
        0x0020b228:    4c5f4e4e    NN_L    DCD    1281314382
        0x0020b22c:    54494d49    IMIT    DCD    1414090057
        0x0020b230:    00000000    ....    DCD    0
        0x0020b234:    3a444d43    CMD:    DCD    977554755
        0x0020b238:    6d6d6f43    Comm    DCD    1835888451
        0x0020b23c:    20646e61    and     DCD    543452769
        0x0020b240:    20746f6e    not     DCD    544501614
        0x0020b244:    6e756f66    foun    DCD    1853189990
        0x0020b248:    00000064    d...    DCD    100
        0x0020b24c:    3a444d43    CMD:    DCD    977554755
        0x0020b250:    6e6f7257    Wron    DCD    1852797527
        0x0020b254:    756e2067    g nu    DCD    1970151527
        0x0020b258:    7265626d    mber    DCD    1919246957
        0x0020b25c:    20666f20     of     DCD    543584032
        0x0020b260:    61726170    para    DCD    1634886000
        0x0020b264:    6574656d    mete    DCD    1702126957
        0x0020b268:    00007372    rs..    DCD    29554
        0x0020b26c:    3a444d43    CMD:    DCD    977554755
        0x0020b270:    756c6156    Valu    DCD    1970037078
        0x0020b274:    756f2065    e ou    DCD    1970217061
        0x0020b278:    666f2074    t of    DCD    1718558836
        0x0020b27c:    6e617220     ran    DCD    1851879968
        0x0020b280:    00006567    ge..    DCD    25959
        0x0020b284:    3a444d43    CMD:    DCD    977554755
        0x0020b288:    20746f4e    Not     DCD    544501582
        0x0020b28c:    70707573    supp    DCD    1886418291
        0x0020b290:    0074726f    ort.    DCD    7631471
        0x0020b294:    00007325    %s..    DCD    29477
        0x0020b298:    00082008    . ..    DCD    532488
    $t
        0x0020b29c:    1c40        @.      ADDS     r0,r0,#1
        0x0020b29e:    b2c0        ..      UXTB     r0,r0
        0x0020b2a0:    4281        .B      CMP      r1,r0
        0x0020b2a2:    dd16        ..      BLE      0x20b2d2 ; user_cmd_collect + 828
        0x0020b2a4:    e7fa        ..      B        0x20b29c ; user_cmd_collect + 774
;;;492                        {
;;;493                            //vsop data_uart_print("\b");
;;;494                        }
;;;495                    }
;;;496                    break;
;;;497    
;;;498                case 44:                            /* up: < */
;;;499                    if (p_user_cmd_if->history_head != USER_CMD_MAX_HISTORY_LINE)
        0x0020b2a6:    f894019c    ....    LDRB     r0,[r4,#0x19c]
        0x0020b2aa:    2803        .(      CMP      r0,#3
        0x0020b2ac:    d07d        }.      BEQ      0x20b3aa ; user_cmd_collect + 1044
;;;500                    {
;;;501                        cmd_clear_screen(p_user_cmd_if);
        0x0020b2ae:    4620         F      MOV      r0,r4
        0x0020b2b0:    f7fffe55    ..U.    BL       cmd_clear_screen ; 0x20af5e
;;;502                        if (p_user_cmd_if->history_cur == USER_CMD_MAX_HISTORY_LINE)
        0x0020b2b4:    f894019e    ....    LDRB     r0,[r4,#0x19e]
        0x0020b2b8:    2803        .(      CMP      r0,#3
        0x0020b2ba:    d005        ..      BEQ      0x20b2c8 ; user_cmd_collect + 818
        0x0020b2bc:    f894119c    ....    LDRB     r1,[r4,#0x19c]
        0x0020b2c0:    4288        .B      CMP      r0,r1
        0x0020b2c2:    d004        ..      BEQ      0x20b2ce ; user_cmd_collect + 824
        0x0020b2c4:    1c80        ..      ADDS     r0,r0,#2
        0x0020b2c6:    e015        ..      B        0x20b2f4 ; user_cmd_collect + 862
;;;503                        {
;;;504                            p_user_cmd_if->history_cur = p_user_cmd_if->history_tail;
        0x0020b2c8:    f894019d    ....    LDRB     r0,[r4,#0x19d]
        0x0020b2cc:    e016        ..      B        0x20b2fc ; user_cmd_collect + 870
;;;505                        }
;;;506                        else
;;;507                        {
;;;508                            if (p_user_cmd_if->history_cur != p_user_cmd_if->history_head)
;;;509                            {
;;;510                                p_user_cmd_if->history_cur = (p_user_cmd_if->history_cur + USER_CMD_MAX_HISTORY_LINE - 1) %
;;;511                                                             USER_CMD_MAX_HISTORY_LINE;
;;;512                            }
;;;513                            else
;;;514                            {
;;;515                                p_user_cmd_if->history_cur = USER_CMD_MAX_HISTORY_LINE;
        0x0020b2ce:    f884719e    ...q    STRB     r7,[r4,#0x19e]
;;;516                                break;
        0x0020b2d2:    e06a        j.      B        0x20b3aa ; user_cmd_collect + 1044
        0x0020b2d4:    f894019c    ....    LDRB     r0,[r4,#0x19c]
        0x0020b2d8:    2803        .(      CMP      r0,#3
        0x0020b2da:    d066        f.      BEQ      0x20b3aa ; user_cmd_collect + 1044
        0x0020b2dc:    4620         F      MOV      r0,r4
        0x0020b2de:    f7fffe3e    ..>.    BL       cmd_clear_screen ; 0x20af5e
        0x0020b2e2:    f894019e    ....    LDRB     r0,[r4,#0x19e]
        0x0020b2e6:    2803        .(      CMP      r0,#3
        0x0020b2e8:    d01b        ..      BEQ      0x20b322 ; user_cmd_collect + 908
        0x0020b2ea:    f894119d    ....    LDRB     r1,[r4,#0x19d]
        0x0020b2ee:    4288        .B      CMP      r0,r1
        0x0020b2f0:    d0ed        ..      BEQ      0x20b2ce ; user_cmd_collect + 824
        0x0020b2f2:    1c40        @.      ADDS     r0,r0,#1
        0x0020b2f4:    fbb0f1f7    ....    UDIV     r1,r0,r7
        0x0020b2f8:    fb070011    ....    MLS      r0,r7,r1,r0
        0x0020b2fc:    f884019e    ....    STRB     r0,[r4,#0x19e]
;;;517                            }
;;;518                        }
;;;519                        p_user_cmd_if->accum_cmd_len = p_user_cmd_if->cmd_history_len[p_user_cmd_if->history_cur];
        0x0020b300:    b2c0        ..      UXTB     r0,r0
        0x0020b302:    5d42        B]      LDRB     r2,[r0,r5]
        0x0020b304:    eb001000    ....    ADD      r0,r0,r0,LSL #4
        0x0020b308:    eb000040    ..@.    ADD      r0,r0,r0,LSL #1
        0x0020b30c:    eb040140    ..@.    ADD      r1,r4,r0,LSL #1
;;;520                        p_user_cmd_if->cmd_cur = p_user_cmd_if->accum_cmd_len;
        0x0020b310:    f8c421a0    ...!    STR      r2,[r4,#0x1a0]
        0x0020b314:    f8842066    ..f     STRB     r2,[r4,#0x66]
;;;521                        memcpy(p_user_cmd_if->cmdline_buf, p_user_cmd_if->cmd_history[p_user_cmd_if->history_cur],
        0x0020b318:    4620         F      MOV      r0,r4
        0x0020b31a:    3167        g1      ADDS     r1,r1,#0x67
        0x0020b31c:    f64efdbd    N...    BL       __aeabi_memcpy ; 0x59e9a
        0x0020b320:    e043        C.      B        0x20b3aa ; user_cmd_collect + 1044
;;;522                               p_user_cmd_if->accum_cmd_len);
;;;523                        //vsop data_uart_print("%s", p_user_cmd_if->cmdline_buf);
;;;524                    }
;;;525                    break;
;;;526    
;;;527                case 46:                            /* down: > */
;;;528                    if (p_user_cmd_if->history_head != USER_CMD_MAX_HISTORY_LINE)
;;;529                    {
;;;530                        cmd_clear_screen(p_user_cmd_if);
;;;531                        if (p_user_cmd_if->history_cur == USER_CMD_MAX_HISTORY_LINE)
;;;532                        {
;;;533                            p_user_cmd_if->history_cur = p_user_cmd_if->history_head;
        0x0020b322:    f894019c    ....    LDRB     r0,[r4,#0x19c]
        0x0020b326:    e7e9        ..      B        0x20b2fc ; user_cmd_collect + 870
;;;534                        }
;;;535                        else
;;;536                        {
;;;537                            if (p_user_cmd_if->history_cur != p_user_cmd_if->history_tail)
;;;538                            {
;;;539                                p_user_cmd_if->history_cur = (p_user_cmd_if->history_cur + 1) % USER_CMD_MAX_HISTORY_LINE;
;;;540                            }
;;;541                            else
;;;542                            {
;;;543                                p_user_cmd_if->history_cur = USER_CMD_MAX_HISTORY_LINE;
;;;544                                break;
;;;545                            }
;;;546                        }
;;;547                        p_user_cmd_if->accum_cmd_len = p_user_cmd_if->cmd_history_len[p_user_cmd_if->history_cur];
;;;548                        p_user_cmd_if->cmd_cur = p_user_cmd_if->accum_cmd_len;
;;;549                        memcpy(p_user_cmd_if->cmdline_buf, p_user_cmd_if->cmd_history[p_user_cmd_if->history_cur],
;;;550                               p_user_cmd_if->accum_cmd_len);
;;;551                        //vsop data_uart_print("%s", p_user_cmd_if->cmdline_buf);
;;;552                    }
;;;553                    break;
;;;554    
;;;555                case 91:                           /* left: { */
;;;556                    if (p_user_cmd_if->cmd_cur > 0)
        0x0020b328:    f8940066    ..f.    LDRB     r0,[r4,#0x66]
        0x0020b32c:    b3c0        ..      CBZ      r0,0x20b3a0 ; user_cmd_collect + 1034
        0x0020b32e:    1e40        @.      SUBS     r0,r0,#1
;;;557                    {
;;;558                        //vsop data_uart_print("\b");
;;;559                        p_user_cmd_if->cmd_cur--;
        0x0020b330:    e006        ..      B        0x20b340 ; user_cmd_collect + 938
        0x0020b332:    f8940066    ..f.    LDRB     r0,[r4,#0x66]
        0x0020b336:    f8d411a0    ....    LDR      r1,[r4,#0x1a0]
        0x0020b33a:    4288        .B      CMP      r0,r1
        0x0020b33c:    da35        5.      BGE      0x20b3aa ; user_cmd_collect + 1044
        0x0020b33e:    1c40        @.      ADDS     r0,r0,#1
        0x0020b340:    f8840066    ..f.    STRB     r0,[r4,#0x66]
        0x0020b344:    e031        1.      B        0x20b3aa ; user_cmd_collect + 1044
;;;560                    }
;;;561                    break;
;;;562    
;;;563                case 93:                           /* right: } */
;;;564                    if (p_user_cmd_if->cmd_cur < p_user_cmd_if->accum_cmd_len)
;;;565                    {
;;;566                        //vsop data_uart_print("%c", p_user_cmd_if->cmdline_buf[p_user_cmd_if->cmd_cur]);
;;;567                        p_user_cmd_if->cmd_cur++;
;;;568                    }
;;;569                    break;
;;;570    
;;;571                case 92:                            /* end: \ */
;;;572                    if (p_user_cmd_if->cmd_cur < p_user_cmd_if->accum_cmd_len)
        0x0020b346:    f8941066    ..f.    LDRB     r1,[r4,#0x66]
        0x0020b34a:    f8d401a0    ....    LDR      r0,[r4,#0x1a0]
        0x0020b34e:    4281        .B      CMP      r1,r0
        0x0020b350:    da2b        +.      BGE      0x20b3aa ; user_cmd_collect + 1044
        0x0020b352:    e7f5        ..      B        0x20b340 ; user_cmd_collect + 938
        0x0020b354:    1e40        @.      SUBS     r0,r0,#1
        0x0020b356:    f8840066    ..f.    STRB     r0,[r4,#0x66]
;;;573                    {
;;;574                        //vsop data_uart_print("%s", p_user_cmd_if->cmdline_buf + p_user_cmd_if->cmd_cur);
;;;575                        p_user_cmd_if->cmd_cur = p_user_cmd_if->accum_cmd_len;
;;;576                    }
;;;577                    break;
;;;578    
;;;579                case 47:                            /* begin: / */
;;;580                    while (p_user_cmd_if->cmd_cur > 0)
        0x0020b35a:    f8940066    ..f.    LDRB     r0,[r4,#0x66]
        0x0020b35e:    b1f8        ..      CBZ      r0,0x20b3a0 ; user_cmd_collect + 1034
        0x0020b360:    e7f8        ..      B        0x20b354 ; user_cmd_collect + 958
        0x0020b362:    1a52        R.      SUBS     r2,r2,r1
        0x0020b364:    1913        ..      ADDS     r3,r2,r4
        0x0020b366:    1c49        I.      ADDS     r1,r1,#1
        0x0020b368:    f8133c01    ...<    LDRB     r3,[r3,#-1]
        0x0020b36c:    54a3        .T      STRB     r3,[r4,r2]
        0x0020b36e:    b2c9        ..      UXTB     r1,r1
        0x0020b370:    f8943066    ..f0    LDRB     r3,[r4,#0x66]
        0x0020b374:    f8d421a0    ...!    LDR      r2,[r4,#0x1a0]
        0x0020b378:    1ad3        ..      SUBS     r3,r2,r3
        0x0020b37a:    428b        .B      CMP      r3,r1
        0x0020b37c:    dcf1        ..      BGT      0x20b362 ; user_cmd_collect + 972
;;;581                    {
;;;582                        //vsop data_uart_print("\b");
;;;583                        p_user_cmd_if->cmd_cur--;
;;;584                    }
;;;585                    break;
;;;586    
;;;587                default:
;;;588                    /* Put character in command buffer */
;;;589                    if (p_user_cmd_if->accum_cmd_len < USER_CMD_MAX_COMMAND_LINE)
;;;590                    {
;;;591                        uint8_t loop;
;;;592    
;;;593                        cmd_move_back(p_user_cmd_if);
;;;594                        p_user_cmd_if->cmdline_buf[p_user_cmd_if->cmd_cur] = c;
        0x0020b37e:    f8941066    ..f.    LDRB     r1,[r4,#0x66]
        0x0020b382:    5460        `T      STRB     r0,[r4,r1]
;;;595                        //vsop data_uart_print("%s", p_user_cmd_if->cmdline_buf + p_user_cmd_if->cmd_cur);
;;;596                        p_user_cmd_if->accum_cmd_len++;
        0x0020b384:    f8d411a0    ....    LDR      r1,[r4,#0x1a0]
        0x0020b388:    1c49        I.      ADDS     r1,r1,#1
;;;597                        p_user_cmd_if->cmd_cur++;
        0x0020b38a:    f8c411a0    ....    STR      r1,[r4,#0x1a0]
        0x0020b38e:    f8940066    ..f.    LDRB     r0,[r4,#0x66]
        0x0020b392:    1c40        @.      ADDS     r0,r0,#1
        0x0020b394:    b2c2        ..      UXTB     r2,r0
        0x0020b396:    2000        .       MOVS     r0,#0
        0x0020b398:    f8842066    ..f     STRB     r2,[r4,#0x66]
        0x0020b39c:    1a89        ..      SUBS     r1,r1,r2
;;;598                        for (loop = 0; loop < p_user_cmd_if->accum_cmd_len - p_user_cmd_if->cmd_cur; loop++)
        0x0020b39e:    e002        ..      B        0x20b3a6 ; user_cmd_collect + 1040
        0x0020b3a0:    e003        ..      B        0x20b3aa ; user_cmd_collect + 1044
        0x0020b3a2:    1c40        @.      ADDS     r0,r0,#1
        0x0020b3a4:    b2c0        ..      UXTB     r0,r0
        0x0020b3a6:    4281        .B      CMP      r1,r0
        0x0020b3a8:    dcfb        ..      BGT      0x20b3a2 ; user_cmd_collect + 1036
        0x0020b3aa:    f1b90901    ....    SUBS     r9,r9,#1
        0x0020b3ae:    f4bfadff    ....    BCS      0x20afb0 ; user_cmd_collect + 26
        0x0020b3b2:    b026        &.      ADD      sp,sp,#0x98
;;;599                        {
;;;600                            //data_uart_print("\b");
;;;601                        }
;;;602                    }
;;;603                    break;
;;;604                }
;;;605            }
;;;606        }
;;;607    
;;;608        return true;
        0x0020b3b4:    2001        .       MOVS     r0,#1
;;;609    }
        0x0020b3b6:    e8bd87f0    ....    POP      {r4-r10,pc}
    user_cmd_init
;;;610    
;;;611    /**
;;;612     * @brief  Initiate command interface structure
;;;613     * @param[in] p_user_cmd_if   Store parsed commands.
;;;614     * @param[in] project_name    Initiate project name.
;;;615     * @return void
;;;616     *
;;;617     * <b>Example usage</b>
;;;618     * \code{.c}
;;;619        void app_main_task(void *p_param)
;;;620        {
;;;621            char event;
;;;622    
;;;623            os_msg_queue_create(&io_queue_handle, MAX_NUMBER_OF_IO_MESSAGE, sizeof(T_IO_MSG));
;;;624            os_msg_queue_create(&evt_queue_handle, MAX_NUMBER_OF_EVENT_MESSAGE, sizeof(unsigned char));
;;;625    
;;;626            gap_start_bt_stack(evt_queue_handle, io_queue_handle, MAX_NUMBER_OF_GAP_MESSAGE);
;;;627    
;;;628            data_uart_init(evt_queue_handle, io_queue_handle);
;;;629            user_cmd_init(&user_cmd_if, "central");
;;;630            ......
;;;631        }
;;;632     * \endcode
;;;633     */
;;;634    void user_cmd_init(T_USER_CMD_IF *p_user_cmd_if, char *project_name)
;;;635    {
        0x0020b3ba:    b510        ..      PUSH     {r4,lr}
        0x0020b3bc:    4604        .F      MOV      r4,r0
;;;636        memset(p_user_cmd_if, 0, sizeof(T_USER_CMD_IF));
        0x0020b3be:    f44f71d2    O..q    MOV      r1,#0x1a4
        0x0020b3c2:    f64efe4d    N.M.    BL       __aeabi_memclr4 ; 0x5a060
;;;637        p_user_cmd_if->history_head = USER_CMD_MAX_HISTORY_LINE;
        0x0020b3c6:    2003        .       MOVS     r0,#3
        0x0020b3c8:    f884019c    ....    STRB     r0,[r4,#0x19c]
;;;638        p_user_cmd_if->history_tail = USER_CMD_MAX_HISTORY_LINE;
        0x0020b3cc:    f884019d    ....    STRB     r0,[r4,#0x19d]
;;;639        p_user_cmd_if->history_cur  = USER_CMD_MAX_HISTORY_LINE;
        0x0020b3d0:    f884019e    ....    STRB     r0,[r4,#0x19e]
;;;640        //data_uart_print(">> Command Parse Init (%s) <<\r\n", project_name);
;;;641    }
        0x0020b3d4:    bd10        ..      POP      {r4,pc}
    user_cmd_skip_spaces
;;; ..\..\..\src\mcu\module\data_uart_cmd\user_cmd_parse.c (40)
        0x0020b3d6:    b510        ..      PUSH     {r4,lr}
        0x0020b3d8:    4604        .F      MOV      r4,r0
        0x0020b3da:    e000        ..      B        0x20b3de ; user_cmd_skip_spaces + 8
        0x0020b3dc:    1c64        d.      ADDS     r4,r4,#1
;;;41         char *p = buffer;
;;;42     
;;;43         while (user_cmd_is_white_space(*p)) /* white space */
        0x0020b3de:    7820         x      LDRB     r0,[r4,#0]
        0x0020b3e0:    f000f84b    ..K.    BL       user_cmd_is_white_space ; 0x20b47a
        0x0020b3e4:    2800        .(      CMP      r0,#0
        0x0020b3e6:    d1f9        ..      BNE      0x20b3dc ; user_cmd_skip_spaces + 6
;;;44         {
;;;45             p++;
;;;46         }
;;;47         return p;
        0x0020b3e8:    4620         F      MOV      r0,r4
;;;48     }
        0x0020b3ea:    bd10        ..      POP      {r4,pc}
    user_cmd_find_end_of_word
;;;49     
;;;50     /**
;;;51      * @brief  Find end of a word.
;;;52      *
;;;53      * @param buffer    Address of the buffer.
;;;54      * @return
;;;55      */
;;;56     static char *user_cmd_find_end_of_word(char *buffer)
;;;57     {
        0x0020b3ec:    b510        ..      PUSH     {r4,lr}
        0x0020b3ee:    4604        .F      MOV      r4,r0
        0x0020b3f0:    e000        ..      B        0x20b3f4 ; user_cmd_find_end_of_word + 8
        0x0020b3f2:    1c64        d.      ADDS     r4,r4,#1
;;;58         char *p = buffer;
;;;59     
;;;60         while (!user_cmd_is_white_space(*p) && (*p != '\0'))
        0x0020b3f4:    7820         x      LDRB     r0,[r4,#0]
        0x0020b3f6:    f000f840    ..@.    BL       user_cmd_is_white_space ; 0x20b47a
        0x0020b3fa:    b910        ..      CBNZ     r0,0x20b402 ; user_cmd_find_end_of_word + 22
        0x0020b3fc:    7820         x      LDRB     r0,[r4,#0]
        0x0020b3fe:    2800        .(      CMP      r0,#0
        0x0020b400:    d1f7        ..      BNE      0x20b3f2 ; user_cmd_find_end_of_word + 6
;;;61         {
;;;62             p++;
;;;63         }
;;;64         return p;
        0x0020b402:    4620         F      MOV      r0,r4
;;;65     }
        0x0020b404:    bd10        ..      POP      {r4,pc}
    user_cmd_execute
;;;66     
;;;67     /**
;;;68      * @brief  Read ASCII string and convert to uint32_t.
;;;69      *
;;;70      * @param p  String address.
;;;71      * @return
;;;72      */
;;;73     static uint32_t user_cmd_str_to_uint32(char *p)
;;;74     {
;;;75         uint32_t result = 0;
;;;76         bool     hex = false;
;;;77     
;;;78         /* check if value is dec */
;;;79         if (p[0] == 'x')
;;;80         {
;;;81             hex = true;
;;;82             p = &p[1];
;;;83         }
;;;84         else if ((p[0] == '0') && (p[1] == 'x'))
;;;85         {
;;;86             hex = true;
;;;87             p = &p[2];
;;;88         }
;;;89     
;;;90         for (;;)
;;;91         {
;;;92             char     ch;
;;;93             ch = *(p++) | 0x20;                 /* convert to lower case */
;;;94     
;;;95             if (hex)                            /* dec value */
;;;96             {
;;;97                 /* hex value */
;;;98                 if ((ch >= 'a') && (ch <= 'f'))
;;;99                 {
;;;100                    ch -= ('a' - 10);
;;;101                }
;;;102                else if ((ch >= '0') && (ch <= '9'))
;;;103                {
;;;104                    ch -= '0';
;;;105                }
;;;106                else
;;;107                {
;;;108                    break;
;;;109                }
;;;110                result = (result << 4);
;;;111                result += (ch & 0x0f);
;;;112            }
;;;113            else
;;;114            {
;;;115                if (ch < '0' || ch > '9')
;;;116                {
;;;117                    break;    /* end of string reached */
;;;118                }
;;;119                result = 10 * result + ch - '0';
;;;120            }
;;;121        }
;;;122        return (result);
;;;123    }
;;;124    
;;;125    /**
;;;126     * @brief  Send result, display in UART Assitant.
;;;127     *
;;;128     * @param result    Command parse result.
;;;129     * @return none
;;;130    */
;;;131    static void cmd_send_result(T_USER_CMD_PARSE_RESULT result)
;;;132    {
;;;133        switch (result)
;;;134        {
;;;135        case RESULT_ERR:
;;;136            data_uart_print("%s\r\n", "CMD:Error");
;;;137            break;
;;;138        case RESULT_GAP_CAUSE_ALREADY_IN_REQ:
;;;139            data_uart_print("%s\r\n", "GAP_CAUSE_ALREADY_IN_REQ");
;;;140            break;
;;;141        case RESULT_GAP_CAUSE_INVALID_STATE:
;;;142            data_uart_print("%s\r\n", "GAP_CAUSE_INVALID_STATE");
;;;143            break;
;;;144        case RESULT_GAP_CAUSE_INVALID_PARAM:
;;;145            data_uart_print("%s\r\n", "GAP_CAUSE_INVALID_PARAM");
;;;146            break;
;;;147        case RESULT_GAP_CAUSE_NON_CONN:
;;;148            data_uart_print("%s\r\n", "GAP_CAUSE_NON_CONN");
;;;149            break;
;;;150        case RESULT_GAP_CAUSE_NOT_FIND_IRK:
;;;151            data_uart_print("%s\r\n", "GAP_CAUSE_NOT_FIND_IRK");
;;;152            break;
;;;153        case RESULT_GAP_CAUSE_ERROR_CREDITS:
;;;154            data_uart_print("%s\r\n", "GAP_CAUSE_ERROR_CREDITS");
;;;155            break;
;;;156        case RESULT_GAP_CAUSE_SEND_REQ_FAILED:
;;;157            data_uart_print("%s\r\n", "GAP_CAUSE_SEND_REQ_FAILED");
;;;158            break;
;;;159        case RESULT_GAP_CAUSE_NO_RESOURCE:
;;;160            data_uart_print("%s\r\n", "GAP_CAUSE_NO_RESOURCE");
;;;161            break;
;;;162        case RESULT_GAP_CAUSE_INVALID_PDU_SIZE:
;;;163            data_uart_print("%s\r\n", "GAP_CAUSE_INVALID_PDU_SIZE");
;;;164            break;
;;;165        case RESULT_GAP_CAUSE_NOT_FIND:
;;;166            data_uart_print("%s\r\n", "GAP_CAUSE_NOT_FIND");
;;;167            break;
;;;168        case RESULT_GAP_CAUSE_CONN_LIMIT:
;;;169            data_uart_print("%s\r\n", "GAP_CAUSE_CONN_LIMIT");
;;;170            break;
;;;171        case RESULT_CMD_NOT_FOUND:
;;;172            data_uart_print("%s\r\n", "CMD:Command not found");
;;;173            break;
;;;174        case RESULT_CMD_ERR_PARAM_NUM:
;;;175            data_uart_print("%s\r\n", "CMD:Wrong number of parameters");
;;;176            break;
;;;177        case RESULT_CMD_ERR_PARAM:
;;;178            data_uart_print("%s\r\n", "CMD:Wrong parameter");
;;;179            break;
;;;180        case RESULT_CMD_OUT_OF_RANGE:
;;;181            data_uart_print("%s\r\n", "CMD:Value out of range");
;;;182            break;
;;;183        case RESULT_CMD_NOT_SUPPORT:
;;;184            data_uart_print("%s\r\n", "CMD:Not support");
;;;185            break;
;;;186        case RESULT_GAP_CAUSE_ERROR_UNKNOWN:
;;;187            data_uart_print("%s\r\n", "GAP_CAUSE_ERROR_UNKNOWN");
;;;188            break;
;;;189        default:
;;;190            break;
;;;191        }
;;;192    }
;;;193    
;;;194    /**
;;;195     * @brief   List cmd.
;;;196     *
;;;197     * @param p_cmd_table   Command table, include user self-definition command function.
;;;198     * @return  Command execute result.
;;;199    */
;;;200    static T_USER_CMD_PARSE_RESULT user_cmd_list(const T_USER_CMD_TABLE_ENTRY *p_cmd_table)
;;;201    {
;;;202        int32_t i = 0;
;;;203        T_USER_CMD_PARSE_RESULT result = RESULT_CMD_NOT_FOUND;
;;;204    
;;;205        /* find command in table */
;;;206        while ((p_cmd_table + i)->p_cmd != NULL)
;;;207        {
;;;208            data_uart_print("%s", (p_cmd_table + i)->p_option);
;;;209            data_uart_print("%s", "  *");
;;;210            data_uart_print("%s", (p_cmd_table + i)->p_help);
;;;211            result = RESULT_SUCESS;
;;;212            i++;
;;;213        };
;;;214    
;;;215        data_uart_print(",.\r\n  *up down\r\n");
;;;216        data_uart_print("[]\r\n  *left right\r\n");
;;;217        data_uart_print("/\\\r\n  *home end\r\n");
;;;218        data_uart_print("backspace\r\n  *delete\r\n");
;;;219    
;;;220        return result;
;;;221    }
;;;222    
;;;223    /**
;;;224     * @brief  Execute command.
;;;225     *
;;;226     * @param p_parse_value     Command parse value.
;;;227     * @param p_cmd_table       Command table, include user self-definition command function.
;;;228     * @return  Command execute result.
;;;229    */
;;;230    static T_USER_CMD_PARSE_RESULT user_cmd_execute(T_USER_CMD_PARSED_VALUE *p_parse_value,
;;;231                                                    const T_USER_CMD_TABLE_ENTRY *p_cmd_table)
;;;232    {
        0x0020b406:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0020b40a:    460e        .F      MOV      r6,r1
        0x0020b40c:    4605        .F      MOV      r5,r0
;;;233        int32_t i = 0;
        0x0020b40e:    2400        .$      MOVS     r4,#0
;;;234        T_USER_CMD_PARSE_RESULT result = RESULT_CMD_NOT_FOUND;
        0x0020b410:    f04f0822    O.".    MOV      r8,#0x22
;;;235    
;;;236        if (strcmp((const char *)p_parse_value->p_cmd, (const char *)"?") == 0)
        0x0020b414:    6800        .h      LDR      r0,[r0,#0]
        0x0020b416:    a131        1.      ADR      r1,{pc}+0xc6 ; 0x20b4dc
        0x0020b418:    f64ffd0e    O...    BL       strcmp ; 0x5ae38
        0x0020b41c:    b948        H.      CBNZ     r0,0x20b432 ; user_cmd_execute + 44
;;;237        {
;;;238            user_cmd_list(p_cmd_table);
        0x0020b41e:    4630        0F      MOV      r0,r6
        0x0020b420:    f000f835    ..5.    BL       user_cmd_list ; 0x20b48e
;;;239            return RESULT_SUCESS;
        0x0020b424:    2000        .       MOVS     r0,#0
        0x0020b426:    e54d        M.      B        0x20aec4 ; user_cmd_parse + 50
        0x0020b428:    6829        )h      LDR      r1,[r5,#0]
        0x0020b42a:    f64ffd05    O...    BL       strcmp ; 0x5ae38
        0x0020b42e:    b138        8.      CBZ      r0,0x20b440 ; user_cmd_execute + 58
        0x0020b430:    1c64        d.      ADDS     r4,r4,#1
;;;240        }
;;;241    
;;;242        /* find command in table */
;;;243        while ((p_cmd_table + i)->p_cmd != NULL)
        0x0020b432:    eb061704    ....    ADD      r7,r6,r4,LSL #4
        0x0020b436:    6838        8h      LDR      r0,[r7,#0]
        0x0020b438:    2800        .(      CMP      r0,#0
        0x0020b43a:    d1f5        ..      BNE      0x20b428 ; user_cmd_execute + 34
        0x0020b43c:    4640        @F      MOV      r0,r8
        0x0020b43e:    e541        A.      B        0x20aec4 ; user_cmd_parse + 50
;;;244        {
;;;245            if (strcmp((const char *)(p_cmd_table + i)->p_cmd, (const char *)p_parse_value->p_cmd) == 0)
;;;246            {
;;;247                /* check if user wants help */
;;;248                if (p_parse_value->param_count && *p_parse_value->p_param[0] == '?')
        0x0020b440:    6868        hh      LDR      r0,[r5,#4]
        0x0020b442:    b118        ..      CBZ      r0,0x20b44c ; user_cmd_execute + 70
        0x0020b444:    6d28        (m      LDR      r0,[r5,#0x50]
        0x0020b446:    7800        .x      LDRB     r0,[r0,#0]
        0x0020b448:    283f        ?(      CMP      r0,#0x3f
        0x0020b44a:    d006        ..      BEQ      0x20b45a ; user_cmd_execute + 84
        0x0020b44c:    eb061004    ....    ADD      r0,r6,r4,LSL #4
        0x0020b450:    68c1        .h      LDR      r1,[r0,#0xc]
        0x0020b452:    4628        (F      MOV      r0,r5
        0x0020b454:    4788        .G      BLX      r1
        0x0020b456:    4680        .F      MOV      r8,r0
        0x0020b458:    e7f0        ..      B        0x20b43c ; user_cmd_execute + 54
;;;249                {
;;;250                    data_uart_print("%s", (p_cmd_table + i)->p_option);
        0x0020b45a:    eb061004    ....    ADD      r0,r6,r4,LSL #4
        0x0020b45e:    6841        Ah      LDR      r1,[r0,#4]
        0x0020b460:    a01f        ..      ADR      r0,{pc}+0x80 ; 0x20b4e0
        0x0020b462:    f7fffbdd    ....    BL       data_uart_print ; 0x20ac20
;;;251                    data_uart_print("%s", "  *");
        0x0020b466:    a11f        ..      ADR      r1,{pc}+0x7e ; 0x20b4e4
        0x0020b468:    a01d        ..      ADR      r0,{pc}+0x78 ; 0x20b4e0
        0x0020b46a:    f7fffbd9    ....    BL       data_uart_print ; 0x20ac20
;;;252                    data_uart_print("%s", (p_cmd_table + i)->p_help);
        0x0020b46e:    a01c        ..      ADR      r0,{pc}+0x72 ; 0x20b4e0
        0x0020b470:    68b9        .h      LDR      r1,[r7,#8]
        0x0020b472:    f7fffbd5    ....    BL       data_uart_print ; 0x20ac20
;;;253                    result = RESULT_SUCESS;
        0x0020b476:    2000        .       MOVS     r0,#0
        0x0020b478:    e7ed        ..      B        0x20b456 ; user_cmd_execute + 80
    user_cmd_is_white_space
        0x0020b47a:    f1a00109    ....    SUB      r1,r0,#9
        0x0020b47e:    2904        .)      CMP      r1,#4
;;; ..\..\..\src\mcu\module\data_uart_cmd\user_cmd_parse.c (29)
        0x0020b480:    d903        ..      BLS      0x20b48a ; user_cmd_is_white_space + 16
;;;30         return (((c >= 9) && (c <= 13)) || (c == 32));
        0x0020b482:    2820         (      CMP      r0,#0x20
        0x0020b484:    d001        ..      BEQ      0x20b48a ; user_cmd_is_white_space + 16
        0x0020b486:    2000        .       MOVS     r0,#0
        0x0020b488:    4770        pG      BX       lr
        0x0020b48a:    2001        .       MOVS     r0,#1
;;;31     }
        0x0020b48c:    4770        pG      BX       lr
    user_cmd_list
;;;32     
;;;33     /**
;;;34      * @brief  Skip white spaces in buffer.
;;;35      *
;;;36      * @param  buffer    Address of the buffer.
;;;37      * @return pointer to skipped white spaces' new buffer.
;;;38      */
;;;39     static char *user_cmd_skip_spaces(char *buffer)
;;;40     {
;;;41         char *p = buffer;
;;;42     
;;;43         while (user_cmd_is_white_space(*p)) /* white space */
;;;44         {
;;;45             p++;
;;;46         }
;;;47         return p;
;;;48     }
;;;49     
;;;50     /**
;;;51      * @brief  Find end of a word.
;;;52      *
;;;53      * @param buffer    Address of the buffer.
;;;54      * @return
;;;55      */
;;;56     static char *user_cmd_find_end_of_word(char *buffer)
;;;57     {
;;;58         char *p = buffer;
;;;59     
;;;60         while (!user_cmd_is_white_space(*p) && (*p != '\0'))
;;;61         {
;;;62             p++;
;;;63         }
;;;64         return p;
;;;65     }
;;;66     
;;;67     /**
;;;68      * @brief  Read ASCII string and convert to uint32_t.
;;;69      *
;;;70      * @param p  String address.
;;;71      * @return
;;;72      */
;;;73     static uint32_t user_cmd_str_to_uint32(char *p)
;;;74     {
;;;75         uint32_t result = 0;
;;;76         bool     hex = false;
;;;77     
;;;78         /* check if value is dec */
;;;79         if (p[0] == 'x')
;;;80         {
;;;81             hex = true;
;;;82             p = &p[1];
;;;83         }
;;;84         else if ((p[0] == '0') && (p[1] == 'x'))
;;;85         {
;;;86             hex = true;
;;;87             p = &p[2];
;;;88         }
;;;89     
;;;90         for (;;)
;;;91         {
;;;92             char     ch;
;;;93             ch = *(p++) | 0x20;                 /* convert to lower case */
;;;94     
;;;95             if (hex)                            /* dec value */
;;;96             {
;;;97                 /* hex value */
;;;98                 if ((ch >= 'a') && (ch <= 'f'))
;;;99                 {
;;;100                    ch -= ('a' - 10);
;;;101                }
;;;102                else if ((ch >= '0') && (ch <= '9'))
;;;103                {
;;;104                    ch -= '0';
;;;105                }
;;;106                else
;;;107                {
;;;108                    break;
;;;109                }
;;;110                result = (result << 4);
;;;111                result += (ch & 0x0f);
;;;112            }
;;;113            else
;;;114            {
;;;115                if (ch < '0' || ch > '9')
;;;116                {
;;;117                    break;    /* end of string reached */
;;;118                }
;;;119                result = 10 * result + ch - '0';
;;;120            }
;;;121        }
;;;122        return (result);
;;;123    }
;;;124    
;;;125    /**
;;;126     * @brief  Send result, display in UART Assitant.
;;;127     *
;;;128     * @param result    Command parse result.
;;;129     * @return none
;;;130    */
;;;131    static void cmd_send_result(T_USER_CMD_PARSE_RESULT result)
;;;132    {
;;;133        switch (result)
;;;134        {
;;;135        case RESULT_ERR:
;;;136            data_uart_print("%s\r\n", "CMD:Error");
;;;137            break;
;;;138        case RESULT_GAP_CAUSE_ALREADY_IN_REQ:
;;;139            data_uart_print("%s\r\n", "GAP_CAUSE_ALREADY_IN_REQ");
;;;140            break;
;;;141        case RESULT_GAP_CAUSE_INVALID_STATE:
;;;142            data_uart_print("%s\r\n", "GAP_CAUSE_INVALID_STATE");
;;;143            break;
;;;144        case RESULT_GAP_CAUSE_INVALID_PARAM:
;;;145            data_uart_print("%s\r\n", "GAP_CAUSE_INVALID_PARAM");
;;;146            break;
;;;147        case RESULT_GAP_CAUSE_NON_CONN:
;;;148            data_uart_print("%s\r\n", "GAP_CAUSE_NON_CONN");
;;;149            break;
;;;150        case RESULT_GAP_CAUSE_NOT_FIND_IRK:
;;;151            data_uart_print("%s\r\n", "GAP_CAUSE_NOT_FIND_IRK");
;;;152            break;
;;;153        case RESULT_GAP_CAUSE_ERROR_CREDITS:
;;;154            data_uart_print("%s\r\n", "GAP_CAUSE_ERROR_CREDITS");
;;;155            break;
;;;156        case RESULT_GAP_CAUSE_SEND_REQ_FAILED:
;;;157            data_uart_print("%s\r\n", "GAP_CAUSE_SEND_REQ_FAILED");
;;;158            break;
;;;159        case RESULT_GAP_CAUSE_NO_RESOURCE:
;;;160            data_uart_print("%s\r\n", "GAP_CAUSE_NO_RESOURCE");
;;;161            break;
;;;162        case RESULT_GAP_CAUSE_INVALID_PDU_SIZE:
;;;163            data_uart_print("%s\r\n", "GAP_CAUSE_INVALID_PDU_SIZE");
;;;164            break;
;;;165        case RESULT_GAP_CAUSE_NOT_FIND:
;;;166            data_uart_print("%s\r\n", "GAP_CAUSE_NOT_FIND");
;;;167            break;
;;;168        case RESULT_GAP_CAUSE_CONN_LIMIT:
;;;169            data_uart_print("%s\r\n", "GAP_CAUSE_CONN_LIMIT");
;;;170            break;
;;;171        case RESULT_CMD_NOT_FOUND:
;;;172            data_uart_print("%s\r\n", "CMD:Command not found");
;;;173            break;
;;;174        case RESULT_CMD_ERR_PARAM_NUM:
;;;175            data_uart_print("%s\r\n", "CMD:Wrong number of parameters");
;;;176            break;
;;;177        case RESULT_CMD_ERR_PARAM:
;;;178            data_uart_print("%s\r\n", "CMD:Wrong parameter");
;;;179            break;
;;;180        case RESULT_CMD_OUT_OF_RANGE:
;;;181            data_uart_print("%s\r\n", "CMD:Value out of range");
;;;182            break;
;;;183        case RESULT_CMD_NOT_SUPPORT:
;;;184            data_uart_print("%s\r\n", "CMD:Not support");
;;;185            break;
;;;186        case RESULT_GAP_CAUSE_ERROR_UNKNOWN:
;;;187            data_uart_print("%s\r\n", "GAP_CAUSE_ERROR_UNKNOWN");
;;;188            break;
;;;189        default:
;;;190            break;
;;;191        }
;;;192    }
;;;193    
;;;194    /**
;;;195     * @brief   List cmd.
;;;196     *
;;;197     * @param p_cmd_table   Command table, include user self-definition command function.
;;;198     * @return  Command execute result.
;;;199    */
;;;200    static T_USER_CMD_PARSE_RESULT user_cmd_list(const T_USER_CMD_TABLE_ENTRY *p_cmd_table)
;;;201    {
        0x0020b48e:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0020b492:    2400        .$      MOVS     r4,#0
        0x0020b494:    4607        .F      MOV      r7,r0
        0x0020b496:    2622        "&      MOVS     r6,#0x22
        0x0020b498:    e00d        ..      B        0x20b4b6 ; user_cmd_list + 40
;;;202        int32_t i = 0;
;;;203        T_USER_CMD_PARSE_RESULT result = RESULT_CMD_NOT_FOUND;
;;;204    
;;;205        /* find command in table */
;;;206        while ((p_cmd_table + i)->p_cmd != NULL)
;;;207        {
;;;208            data_uart_print("%s", (p_cmd_table + i)->p_option);
        0x0020b49a:    a011        ..      ADR      r0,{pc}+0x46 ; 0x20b4e0
        0x0020b49c:    6869        ih      LDR      r1,[r5,#4]
        0x0020b49e:    f7fffbbf    ....    BL       data_uart_print ; 0x20ac20
;;;209            data_uart_print("%s", "  *");
        0x0020b4a2:    a110        ..      ADR      r1,{pc}+0x42 ; 0x20b4e4
        0x0020b4a4:    a00e        ..      ADR      r0,{pc}+0x3c ; 0x20b4e0
        0x0020b4a6:    f7fffbbb    ....    BL       data_uart_print ; 0x20ac20
;;;210            data_uart_print("%s", (p_cmd_table + i)->p_help);
        0x0020b4aa:    a00d        ..      ADR      r0,{pc}+0x36 ; 0x20b4e0
        0x0020b4ac:    68a9        .h      LDR      r1,[r5,#8]
        0x0020b4ae:    f7fffbb7    ....    BL       data_uart_print ; 0x20ac20
;;;211            result = RESULT_SUCESS;
        0x0020b4b2:    2600        .&      MOVS     r6,#0
        0x0020b4b4:    1c64        d.      ADDS     r4,r4,#1
        0x0020b4b6:    eb071504    ....    ADD      r5,r7,r4,LSL #4
        0x0020b4ba:    6828        (h      LDR      r0,[r5,#0]
        0x0020b4bc:    2800        .(      CMP      r0,#0
        0x0020b4be:    d1ec        ..      BNE      0x20b49a ; user_cmd_list + 12
;;;212            i++;
;;;213        };
;;;214    
;;;215        data_uart_print(",.\r\n  *up down\r\n");
        0x0020b4c0:    a009        ..      ADR      r0,{pc}+0x28 ; 0x20b4e8
        0x0020b4c2:    f7fffbad    ....    BL       data_uart_print ; 0x20ac20
;;;216        data_uart_print("[]\r\n  *left right\r\n");
        0x0020b4c6:    a00d        ..      ADR      r0,{pc}+0x36 ; 0x20b4fc
        0x0020b4c8:    f7fffbaa    ....    BL       data_uart_print ; 0x20ac20
;;;217        data_uart_print("/\\\r\n  *home end\r\n");
        0x0020b4cc:    a010        ..      ADR      r0,{pc}+0x44 ; 0x20b510
        0x0020b4ce:    f7fffba7    ....    BL       data_uart_print ; 0x20ac20
;;;218        data_uart_print("backspace\r\n  *delete\r\n");
        0x0020b4d2:    a014        ..      ADR      r0,{pc}+0x52 ; 0x20b524
        0x0020b4d4:    f7fffba4    ....    BL       data_uart_print ; 0x20ac20
;;;219    
;;;220        return result;
        0x0020b4d8:    4630        0F      MOV      r0,r6
;;;221    }
        0x0020b4da:    e4f3        ..      B        0x20aec4 ; user_cmd_parse + 50
    $d
        0x0020b4dc:    0000003f    ?...    DCD    63
        0x0020b4e0:    00007325    %s..    DCD    29477
        0x0020b4e4:    002a2020      *.    DCD    2760736
        0x0020b4e8:    0a0d2e2c    ,...    DCD    168635948
        0x0020b4ec:    752a2020      *u    DCD    1965695008
        0x0020b4f0:    6f642070    p do    DCD    1868832880
        0x0020b4f4:    0a0d6e77    wn..    DCD    168652407
        0x0020b4f8:    00000000    ....    DCD    0
        0x0020b4fc:    0a0d5d5b    []..    DCD    168648027
        0x0020b500:    6c2a2020      *l    DCD    1814700064
        0x0020b504:    20746665    eft     DCD    544499301
        0x0020b508:    68676972    righ    DCD    1751607666
        0x0020b50c:    000a0d74    t...    DCD    658804
        0x0020b510:    0a0d5c2f    /\..    DCD    168647727
        0x0020b514:    682a2020      *h    DCD    1747591200
        0x0020b518:    20656d6f    ome     DCD    543518063
        0x0020b51c:    0d646e65    end.    DCD    224685669
        0x0020b520:    0000000a    ....    DCD    10
        0x0020b524:    6b636162    back    DCD    1801675106
        0x0020b528:    63617073    spac    DCD    1667330163
        0x0020b52c:    200a0d65    e..     DCD    537529701
        0x0020b530:    65642a20     *de    DCD    1701063200
        0x0020b534:    6574656c    lete    DCD    1702126956
        0x0020b538:    00000a0d    ....    DCD    2573
    $t
    .text
    qc_app_main_task
;;; ..\..\..\src\sample\ble_central\mxchip_qc.c
;;;55     {
        0x0020b53c:    b51c        ..      PUSH     {r2-r4,lr}
;;;56         uint8_t event;
;;;57         os_msg_queue_create(&qc_io_queue_handle, MAX_NUMBER_OF_IO_MESSAGE, sizeof(T_IO_MSG));
        0x0020b53e:    2039        9       MOVS     r0,#0x39
        0x0020b540:    9000        ..      STR      r0,[sp,#0]
        0x0020b542:    4bef        .K      LDR      r3,[pc,#956] ; [0x20b900] = 0x20bffe
        0x0020b544:    2208        ."      MOVS     r2,#8
        0x0020b546:    2120         !      MOVS     r1,#0x20
        0x0020b548:    48ee        .H      LDR      r0,[pc,#952] ; [0x20b904] = 0x20d3e8
        0x0020b54a:    f61afcd3    ....    BL       os_msg_queue_create_intern ; 0x25ef4
;;;58         os_msg_queue_create(&qc_evt_queue_handle, MAX_NUMBER_OF_EVENT_MESSAGE, sizeof(uint8_t));
        0x0020b54e:    203a        :       MOVS     r0,#0x3a
        0x0020b550:    9000        ..      STR      r0,[sp,#0]
        0x0020b552:    48ec        .H      LDR      r0,[pc,#944] ; [0x20b904] = 0x20d3e8
        0x0020b554:    4bea        .K      LDR      r3,[pc,#936] ; [0x20b900] = 0x20bffe
        0x0020b556:    2201        ."      MOVS     r2,#1
        0x0020b558:    2140        @!      MOVS     r1,#0x40
        0x0020b55a:    1f00        ..      SUBS     r0,r0,#4
        0x0020b55c:    f61afcca    ....    BL       os_msg_queue_create_intern ; 0x25ef4
        0x0020b560:    4ce8        .L      LDR      r4,[pc,#928] ; [0x20b904] = 0x20d3e8
        0x0020b562:    2220         "      MOVS     r2,#0x20
        0x0020b564:    3c0c        .<      SUBS     r4,r4,#0xc
        0x0020b566:    e9d40102    ....    LDRD     r0,r1,[r4,#8]
        0x0020b56a:    f640fc7e    @.~.    BL       gap_start_bt_stack ; 0x4be6a
        0x0020b56e:    2540        @%      MOVS     r5,#0x40
;;;59     
;;;60         gap_start_bt_stack(qc_evt_queue_handle, qc_io_queue_handle, MAX_NUMBER_OF_GAP_MESSAGE);
;;;61     
;;;62         while (true)
;;;63         {
;;;64             if (os_msg_recv(qc_evt_queue_handle, &event, 0xFFFFFFFF) == true)
        0x0020b570:    f04f36ff    O..6    MOV      r6,#0xffffffff
        0x0020b574:    9500        ..      STR      r5,[sp,#0]
        0x0020b576:    4be2        .K      LDR      r3,[pc,#904] ; [0x20b900] = 0x20bffe
        0x0020b578:    4632        2F      MOV      r2,r6
        0x0020b57a:    a901        ..      ADD      r1,sp,#4
        0x0020b57c:    68a0        .h      LDR      r0,[r4,#8]
        0x0020b57e:    f61afd61    ..a.    BL       os_msg_recv_intern ; 0x26044
        0x0020b582:    2800        .(      CMP      r0,#0
        0x0020b584:    d0f6        ..      BEQ      0x20b574 ; qc_app_main_task + 56
;;;65             {
;;;66                 if (event == EVENT_GAP_MSG)
        0x0020b586:    f89d0004    ....    LDRB     r0,[sp,#4]
        0x0020b58a:    2801        .(      CMP      r0,#1
        0x0020b58c:    d1f2        ..      BNE      0x20b574 ; qc_app_main_task + 56
;;;67                 {
;;;68                     gap_handle_msg(event);
        0x0020b58e:    f640fcd9    @...    BL       gap_handle_msg ; 0x4bf44
        0x0020b592:    e7ef        ..      B        0x20b574 ; qc_app_main_task + 56
    qc_app_task_init
        0x0020b594:    b51c        ..      PUSH     {r2-r4,lr}
;;; ..\..\..\src\sample\ble_central\mxchip_qc.c (45)
        0x0020b596:    2101        .!      MOVS     r1,#1
        0x0020b598:    0288        ..      LSLS     r0,r1,#10
        0x0020b59a:    2300        .#      MOVS     r3,#0
        0x0020b59c:    f2af0263    ..c.    ADR      r2,{pc}-0x5f ; 0x20b53d
        0x0020b5a0:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0020b5a4:    48d7        .H      LDR      r0,[pc,#860] ; [0x20b904] = 0x20d3e8
        0x0020b5a6:    a1d8        ..      ADR      r1,{pc}+0x362 ; 0x20b908
        0x0020b5a8:    380c        .8      SUBS     r0,r0,#0xc
        0x0020b5aa:    f61bfa11    ....    BL       os_task_create ; 0x269d0
;;;46                        APP_TASK_PRIORITY);
;;;47     }
        0x0020b5ae:    bd1c        ..      POP      {r2-r4,pc}
    mf_printf
;;;48     
;;;49     /**
;;;50      * @brief        App task to handle events & messages
;;;51      * @param[in]    p_param    Parameters sending to the task
;;;52      * @return       void
;;;53      */
;;;54     void qc_app_main_task(void *p_param)
;;;55     {
;;;56         uint8_t event;
;;;57         os_msg_queue_create(&qc_io_queue_handle, MAX_NUMBER_OF_IO_MESSAGE, sizeof(T_IO_MSG));
;;;58         os_msg_queue_create(&qc_evt_queue_handle, MAX_NUMBER_OF_EVENT_MESSAGE, sizeof(uint8_t));
;;;59     
;;;60         gap_start_bt_stack(qc_evt_queue_handle, qc_io_queue_handle, MAX_NUMBER_OF_GAP_MESSAGE);
;;;61     
;;;62         while (true)
;;;63         {
;;;64             if (os_msg_recv(qc_evt_queue_handle, &event, 0xFFFFFFFF) == true)
;;;65             {
;;;66                 if (event == EVENT_GAP_MSG)
;;;67                 {
;;;68                     gap_handle_msg(event);
;;;69                 }
;;;70             }
;;;71         }
;;;72     }
;;;73     
;;;74     static void _qc_uart_send(uint8_t *srt, uint8_t len)
;;;75     {
;;;76         uint8_t count = 0, remainder = 0, i = 0;
;;;77     
;;;78         count = len / 16;
;;;79         remainder = len % 16;
;;;80         for (i = 0; i < count; i++)
;;;81         {
;;;82             UART_SendData(UART, &srt[16 * i], 16);
;;;83             while (UART_GetFlagState(UART, UART_FLAG_THR_TSR_EMPTY) != SET)
;;;84                 ;
;;;85         }
;;;86         /* send left bytes */
;;;87         UART_SendData(UART, &srt[16 * i], remainder);
;;;88         /* wait tx fifo empty */
;;;89         while (UART_GetFlagState(UART, UART_FLAG_THR_TSR_EMPTY) != SET)
;;;90             ;
;;;91     }
;;;92     
;;;93     void mf_printf(char *str)
;;;94     {
        0x0020b5b0:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0020b5b4:    0005        ..      MOVS     r5,r0
        0x0020b5b6:    d027        '.      BEQ      0x20b608 ; mf_printf + 88
        0x0020b5b8:    f64efc50    N.P.    BL       strlen ; 0x59e5c
        0x0020b5bc:    2800        .(      CMP      r0,#0
        0x0020b5be:    d023        #.      BEQ      0x20b608 ; mf_printf + 88
        0x0020b5c0:    4628        (F      MOV      r0,r5
        0x0020b5c2:    f64efc4b    N.K.    BL       strlen ; 0x59e5c
        0x0020b5c6:    b2c0        ..      UXTB     r0,r0
;;; ..\..\..\src\sample\ble_central\mxchip_qc.c (76)
        0x0020b5c8:    2400        .$      MOVS     r4,#0
;;;77     
;;;78         count = len / 16;
        0x0020b5ca:    0906        ..      LSRS     r6,r0,#4
;;;79         remainder = len % 16;
        0x0020b5cc:    f000080f    ....    AND      r8,r0,#0xf
        0x0020b5d0:    4fcf        .O      LDR      r7,[pc,#828] ; [0x20b910] = 0x40012000
        0x0020b5d2:    e00b        ..      B        0x20b5ec ; mf_printf + 60
        0x0020b5d4:    2210        ."      MOVS     r2,#0x10
        0x0020b5d6:    4638        8F      MOV      r0,r7
        0x0020b5d8:    f010fe73    ..s.    BL       UART_SendData ; 0x21c2c2
        0x0020b5dc:    2140        @!      MOVS     r1,#0x40
        0x0020b5de:    4638        8F      MOV      r0,r7
        0x0020b5e0:    f010fea2    ....    BL       UART_GetFlagState ; 0x21c328
        0x0020b5e4:    2801        .(      CMP      r0,#1
        0x0020b5e6:    d1f9        ..      BNE      0x20b5dc ; mf_printf + 44
        0x0020b5e8:    1c64        d.      ADDS     r4,r4,#1
;;;80         for (i = 0; i < count; i++)
        0x0020b5ea:    b2e4        ..      UXTB     r4,r4
        0x0020b5ec:    42b4        .B      CMP      r4,r6
        0x0020b5ee:    eb051104    ....    ADD      r1,r5,r4,LSL #4
        0x0020b5f2:    d3ef        ..      BCC      0x20b5d4 ; mf_printf + 36
;;;81         {
;;;82             UART_SendData(UART, &srt[16 * i], 16);
;;;83             while (UART_GetFlagState(UART, UART_FLAG_THR_TSR_EMPTY) != SET)
;;;84                 ;
;;;85         }
;;;86         /* send left bytes */
;;;87         UART_SendData(UART, &srt[16 * i], remainder);
        0x0020b5f4:    4642        BF      MOV      r2,r8
        0x0020b5f6:    4638        8F      MOV      r0,r7
        0x0020b5f8:    f010fe63    ..c.    BL       UART_SendData ; 0x21c2c2
;;;88         /* wait tx fifo empty */
;;;89         while (UART_GetFlagState(UART, UART_FLAG_THR_TSR_EMPTY) != SET)
        0x0020b5fc:    2140        @!      MOVS     r1,#0x40
        0x0020b5fe:    4638        8F      MOV      r0,r7
        0x0020b600:    f010fe92    ....    BL       UART_GetFlagState ; 0x21c328
        0x0020b604:    2801        .(      CMP      r0,#1
        0x0020b606:    d1f9        ..      BNE      0x20b5fc ; mf_printf + 76
;;;90             ;
;;;91     }
;;;92     
;;;93     void mf_printf(char *str)
;;;94     {
;;;95         if ((str == NULL) || (strlen(str) == 0))
;;;96             return;
;;;97         _qc_uart_send((uint8_t *)str, strlen(str));
;;;98     }
        0x0020b608:    e8bd81f0    ....    POP      {r4-r8,pc}
    mf_putc
;;; ..\..\..\inc\peripheral\rtl876x_uart.h
;;;392        UARTx->RB_THR = data;
        0x0020b60c:    49c0        .I      LDR      r1,[pc,#768] ; [0x20b910] = 0x40012000
        0x0020b60e:    6248        Hb      STR      r0,[r1,#0x24]
;;; ..\..\..\src\sample\ble_central\mxchip_qc.c
;;;103    }
        0x0020b610:    4770        pG      BX       lr
    _qc_uart_io_init
;;;104    
;;;105    void _qc_uart_io_init(void)
;;;106    {
        0x0020b612:    b51c        ..      PUSH     {r2-r4,lr}
;;;107        Pinmux_Config(UART_TX, UART0_TX);
        0x0020b614:    2123        #!      MOVS     r1,#0x23
        0x0020b616:    2018        .       MOVS     r0,#0x18
        0x0020b618:    f605feac    ....    BL       Pinmux_Config ; 0x11374
;;;108        Pinmux_Config(UART_RX, UART0_RX);
        0x0020b61c:    2124        $!      MOVS     r1,#0x24
        0x0020b61e:    2019        .       MOVS     r0,#0x19
        0x0020b620:    f605fea8    ....    BL       Pinmux_Config ; 0x11374
;;;109    
;;;110        Pad_Config(UART_TX, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0020b624:    2400        .$      MOVS     r4,#0
        0x0020b626:    2301        .#      MOVS     r3,#1
        0x0020b628:    9400        ..      STR      r4,[sp,#0]
        0x0020b62a:    461a        .F      MOV      r2,r3
        0x0020b62c:    4619        .F      MOV      r1,r3
        0x0020b62e:    2018        .       MOVS     r0,#0x18
        0x0020b630:    9401        ..      STR      r4,[sp,#4]
        0x0020b632:    f605fed3    ....    BL       Pad_Config ; 0x113dc
;;;111        Pad_Config(UART_RX, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0020b636:    2301        .#      MOVS     r3,#1
        0x0020b638:    9400        ..      STR      r4,[sp,#0]
        0x0020b63a:    461a        .F      MOV      r2,r3
        0x0020b63c:    4619        .F      MOV      r1,r3
        0x0020b63e:    2019        .       MOVS     r0,#0x19
        0x0020b640:    9401        ..      STR      r4,[sp,#4]
        0x0020b642:    f605fecb    ....    BL       Pad_Config ; 0x113dc
;;;112    }
        0x0020b646:    bd1c        ..      POP      {r2-r4,pc}
    _qc_uart_config
;;;113    
;;;114    void _qc_uart_config(void)
;;;115    {
        0x0020b648:    b510        ..      PUSH     {r4,lr}
        0x0020b64a:    b088        ..      SUB      sp,sp,#0x20
;;;116        UART_InitTypeDef UART_InitStruct;
;;;117        UART_StructInit(&UART_InitStruct);
        0x0020b64c:    4668        hF      MOV      r0,sp
        0x0020b64e:    f010fe18    ....    BL       UART_StructInit ; 0x21c282
;;;118        //    UART_InitStruct.div = 4; //921600
;;;119        //    UART_InitStruct.ovsr = 5;
;;;120        //    UART_InitStruct.ovsr_adj = 0x3F7;
;;;121    
;;;122        UART_Init(UART, &UART_InitStruct);
        0x0020b652:    4caf        .L      LDR      r4,[pc,#700] ; [0x20b910] = 0x40012000
        0x0020b654:    4669        iF      MOV      r1,sp
        0x0020b656:    4620         F      MOV      r0,r4
        0x0020b658:    f010fd9a    ....    BL       UART_Init ; 0x21c190
;;;123        /*  enable line status interrupt and rx data avaliable interrupt    */
;;;124        UART_INTConfig(UART, UART_INT_RD_AVA | UART_INT_LINE_STS | UART_INT_IDLE, ENABLE);
        0x0020b65c:    2201        ."      MOVS     r2,#1
        0x0020b65e:    2185        .!      MOVS     r1,#0x85
        0x0020b660:    4620         F      MOV      r0,r4
        0x0020b662:    f010fe36    ..6.    BL       UART_INTConfig ; 0x21c2d2
;;;125    }
        0x0020b666:    b008        ..      ADD      sp,sp,#0x20
        0x0020b668:    bd10        ..      POP      {r4,pc}
    _qc_test_uart_init
;;;126    
;;;127    /****************************************************************************/
;;;128    /* UART init                                                                */
;;;129    /****************************************************************************/
;;;130    void _qc_test_uart_init(void)
;;;131    {
        0x0020b66a:    b510        ..      PUSH     {r4,lr}
;;;132        RCC_PeriphClockCmd(APBPeriph_UART0, APBPeriph_UART0_CLOCK, ENABLE);
        0x0020b66c:    2201        ."      MOVS     r2,#1
        0x0020b66e:    49a9        .I      LDR      r1,[pc,#676] ; [0x20b914] = 0x40000001
        0x0020b670:    48a9        .H      LDR      r0,[pc,#676] ; [0x20b918] = 0x8000001
        0x0020b672:    f7fcfb89    ....    BL       RCC_PeriphClockCmd ; 0x207d88
;;;133        _qc_uart_io_init();
        0x0020b676:    f7ffffcc    ....    BL       _qc_uart_io_init ; 0x20b612
;;;134        /*  UART Init   */
;;;135        _qc_uart_config();
        0x0020b67a:    e8bd4010    ...@    POP      {r4,lr}
        0x0020b67e:    e7e3        ..      B        _qc_uart_config ; 0x20b648
    _qc_gap_callback
;;;136        return;
;;;137    }
;;;138    
;;;139    static char *sdk_version_get(void)
;;;140    {
;;;141        return "Bee2_SDK_v" VERSION_BUILD_STR;
;;;142    }
;;;143    
;;;144    static void _qc_get_mac_addr(uint8_t *mac)
;;;145    {
;;;146        gap_get_param(GAP_PARAM_BD_ADDR, mac);
;;;147    }
;;;148    
;;;149    static void _qc_ble_scan_start(void)
;;;150    {
;;;151        le_scan_start();
;;;152    }
;;;153    
;;;154    static void _qc_ble_scan_stop(void)
;;;155    {
;;;156        le_scan_stop();
;;;157    }
;;;158    
;;;159    T_APP_RESULT _qc_gap_callback(uint8_t cb_type, void *p_cb_data)
;;;160    {
        0x0020b680:    b570        p.      PUSH     {r4-r6,lr}
        0x0020b682:    b0a6        ..      SUB      sp,sp,#0x98
        0x0020b684:    460c        .F      MOV      r4,r1
        0x0020b686:    4606        .F      MOV      r6,r0
;;;161        T_APP_RESULT result = APP_RESULT_SUCCESS;
        0x0020b688:    2500        .%      MOVS     r5,#0
;;;162        T_LE_CB_DATA *p_data = (T_LE_CB_DATA *)p_cb_data;
;;;163        char str[128] = {0};
        0x0020b68a:    2180        .!      MOVS     r1,#0x80
        0x0020b68c:    a805        ..      ADD      r0,sp,#0x14
        0x0020b68e:    f64efce7    N...    BL       __aeabi_memclr4 ; 0x5a060
;;;164    
;;;165        switch (cb_type)
        0x0020b692:    2e30        0.      CMP      r6,#0x30
        0x0020b694:    d113        ..      BNE      0x20b6be ; _qc_gap_callback + 62
;;;166        {
;;;167        case GAP_MSG_LE_SCAN_INFO:
;;;168            sprintf(str, "ADDR: " BT_MAC_STR_FORMAT ", RSSI: %d\r\n",
        0x0020b696:    6821        !h      LDR      r1,[r4,#0]
        0x0020b698:    ae01        ..      ADD      r6,sp,#4
        0x0020b69a:    7888        .x      LDRB     r0,[r1,#2]
        0x0020b69c:    f9914008    ...@    LDRSB    r4,[r1,#8]
        0x0020b6a0:    780b        .x      LDRB     r3,[r1,#0]
        0x0020b6a2:    784a        Jx      LDRB     r2,[r1,#1]
        0x0020b6a4:    e886001d    ....    STM      r6,{r0,r2-r4}
        0x0020b6a8:    78c8        .x      LDRB     r0,[r1,#3]
        0x0020b6aa:    9000        ..      STR      r0,[sp,#0]
        0x0020b6ac:    790b        .y      LDRB     r3,[r1,#4]
        0x0020b6ae:    794a        Jy      LDRB     r2,[r1,#5]
        0x0020b6b0:    a19a        ..      ADR      r1,{pc}+0x26c ; 0x20b91c
        0x0020b6b2:    a805        ..      ADD      r0,sp,#0x14
        0x0020b6b4:    f000fb4c    ..L.    BL       __2sprintf ; 0x20bd50
;;;169                    p_data->p_le_scan_info->bd_addr[5], p_data->p_le_scan_info->bd_addr[4],
;;;170                    p_data->p_le_scan_info->bd_addr[3], p_data->p_le_scan_info->bd_addr[2],
;;;171                    p_data->p_le_scan_info->bd_addr[1], p_data->p_le_scan_info->bd_addr[0],
;;;172                    p_data->p_le_scan_info->rssi);
;;;173            mf_printf(str);
        0x0020b6b8:    a805        ..      ADD      r0,sp,#0x14
        0x0020b6ba:    f7ffff79    ..y.    BL       mf_printf ; 0x20b5b0
        0x0020b6be:    b026        &.      ADD      sp,sp,#0x98
;;;174        default:
;;;175            break;
;;;176        }
;;;177        return result;
        0x0020b6c0:    4628        (F      MOV      r0,r5
;;;178    }
        0x0020b6c2:    bd70        p.      POP      {r4-r6,pc}
    _qc_le_gap_init
;;;179    
;;;180    void _qc_le_gap_init(void)
;;;181    {
        0x0020b6c4:    b500        ..      PUSH     {lr}
        0x0020b6c6:    b085        ..      SUB      sp,sp,#0x14
;;;182        //scan patameters
;;;183        uint8_t scan_mode = GAP_SCAN_MODE_ACTIVE;
        0x0020b6c8:    2101        .!      MOVS     r1,#1
;;;184        uint16_t scan_interval = 0x10;
        0x0020b6ca:    2010        .       MOVS     r0,#0x10
        0x0020b6cc:    f8ad0008    ....    STRH     r0,[sp,#8]
;;;185        uint16_t scan_window = 0x10;
        0x0020b6d0:    f8ad000c    ....    STRH     r0,[sp,#0xc]
;;;186        uint8_t scan_filter_policy = GAP_SCAN_FILTER_ANY;
        0x0020b6d4:    2000        .       MOVS     r0,#0
        0x0020b6d6:    f88d1010    ....    STRB     r1,[sp,#0x10]
        0x0020b6da:    f88d0000    ....    STRB     r0,[sp,#0]
;;;187        uint8_t scan_filter_duplicate = GAP_SCAN_FILTER_DUPLICATE_ENABLE;
        0x0020b6de:    f88d1004    ....    STRB     r1,[sp,#4]
;;;188    
;;;189        //Register gap callback
;;;190        le_register_app_cb(_qc_gap_callback);
        0x0020b6e2:    f2af0063    ..c.    ADR      r0,{pc}-0x61 ; 0x20b681
        0x0020b6e6:    f641faac    A...    BL       le_register_app_cb ; 0x4cc42
;;;191    
;;;192        le_scan_set_param(GAP_PARAM_SCAN_MODE, sizeof(scan_mode), &scan_mode);
        0x0020b6ea:    aa04        ..      ADD      r2,sp,#0x10
        0x0020b6ec:    2101        .!      MOVS     r1,#1
        0x0020b6ee:    f2402041    @.A     MOV      r0,#0x241
        0x0020b6f2:    f646fe3f    F.?.    BL       le_scan_set_param ; 0x52374
;;;193        le_scan_set_param(GAP_PARAM_SCAN_INTERVAL, sizeof(scan_interval), &scan_interval);
        0x0020b6f6:    aa02        ..      ADD      r2,sp,#8
        0x0020b6f8:    2102        .!      MOVS     r1,#2
        0x0020b6fa:    f2402042    @.B     MOV      r0,#0x242
        0x0020b6fe:    f646fe39    F.9.    BL       le_scan_set_param ; 0x52374
;;;194        le_scan_set_param(GAP_PARAM_SCAN_WINDOW, sizeof(scan_window), &scan_window);
        0x0020b702:    aa03        ..      ADD      r2,sp,#0xc
        0x0020b704:    2102        .!      MOVS     r1,#2
        0x0020b706:    f2402043    @.C     MOV      r0,#0x243
        0x0020b70a:    f646fe33    F.3.    BL       le_scan_set_param ; 0x52374
;;;195        le_scan_set_param(GAP_PARAM_SCAN_FILTER_POLICY, sizeof(scan_filter_policy),
        0x0020b70e:    466a        jF      MOV      r2,sp
        0x0020b710:    2101        .!      MOVS     r1,#1
        0x0020b712:    f44f7011    O..p    MOV      r0,#0x244
        0x0020b716:    f646fe2d    F.-.    BL       le_scan_set_param ; 0x52374
;;;196                          &scan_filter_policy);
;;;197        le_scan_set_param(GAP_PARAM_SCAN_FILTER_DUPLICATES, sizeof(scan_filter_duplicate),
        0x0020b71a:    aa01        ..      ADD      r2,sp,#4
        0x0020b71c:    2101        .!      MOVS     r1,#1
        0x0020b71e:    f2402045    @.E     MOV      r0,#0x245
        0x0020b722:    f646fe27    F.'.    BL       le_scan_set_param ; 0x52374
;;;198                          &scan_filter_duplicate);
;;;199    }
        0x0020b726:    b005        ..      ADD      sp,sp,#0x14
        0x0020b728:    bd00        ..      POP      {pc}
    _mxchip_qc_test
        0x0020b72a:    b500        ..      PUSH     {lr}
        0x0020b72c:    b0a7        ..      SUB      sp,sp,#0x9c
        0x0020b72e:    f7ffff9c    ....    BL       _qc_test_uart_init ; 0x20b66a
;;;200    
;;;201    static void _qc_ble_init(void)
;;;202    {
;;;203        le_gap_init(1);
        0x0020b732:    2001        .       MOVS     r0,#1
        0x0020b734:    f641fa42    A.B.    BL       le_gap_init ; 0x4cbbc
;;;204        gap_lib_init();
        0x0020b738:    f010fea6    ....    BL       gap_lib_init ; 0x21c488
;;;205        _qc_le_gap_init();
        0x0020b73c:    f7ffffc2    ....    BL       _qc_le_gap_init ; 0x20b6c4
;;;206    }
;;;207    
;;;208    /* MXCHIP standard QC test function main entrance, available for all modules */
;;;209    static void _mxchip_qc_test(void *arg)
;;;210    {
;;;211        char str[128];
;;;212        uint8_t mac[6];
;;;213    
;;;214        _qc_test_uart_init();
;;;215        _qc_ble_init();
;;;216        qc_app_task_init();
        0x0020b740:    f7ffff28    ..(.    BL       qc_app_task_init ; 0x20b594
;;;217    
;;;218        mf_printf("==== MXCHIP Manufacture Test ====\r\n");
        0x0020b744:    a081        ..      ADR      r0,{pc}+0x208 ; 0x20b94c
        0x0020b746:    f7ffff33    ..3.    BL       mf_printf ; 0x20b5b0
;;;219        QC_TEST_PRINT_STRING("Serial Number:", SERIAL_NUMBER);
        0x0020b74a:    a089        ..      ADR      r0,{pc}+0x226 ; 0x20b970
        0x0020b74c:    f7ffff30    ..0.    BL       mf_printf ; 0x20b5b0
        0x0020b750:    a08b        ..      ADR      r0,{pc}+0x230 ; 0x20b980
        0x0020b752:    f7ffff2d    ..-.    BL       mf_printf ; 0x20b5b0
        0x0020b756:    a08b        ..      ADR      r0,{pc}+0x22e ; 0x20b984
        0x0020b758:    f7ffff2a    ..*.    BL       mf_printf ; 0x20b5b0
        0x0020b75c:    a08d        ..      ADR      r0,{pc}+0x238 ; 0x20b994
        0x0020b75e:    f7ffff27    ..'.    BL       mf_printf ; 0x20b5b0
;;;220        QC_TEST_PRINT_STRING("Library Version:", sdk_version_get());
        0x0020b762:    a08d        ..      ADR      r0,{pc}+0x236 ; 0x20b998
        0x0020b764:    f7ffff24    ..$.    BL       mf_printf ; 0x20b5b0
        0x0020b768:    a085        ..      ADR      r0,{pc}+0x218 ; 0x20b980
        0x0020b76a:    f7ffff21    ..!.    BL       mf_printf ; 0x20b5b0
        0x0020b76e:    a08f        ..      ADR      r0,{pc}+0x23e ; 0x20b9ac
        0x0020b770:    f7ffff1e    ....    BL       mf_printf ; 0x20b5b0
        0x0020b774:    a087        ..      ADR      r0,{pc}+0x220 ; 0x20b994
        0x0020b776:    f7ffff1b    ....    BL       mf_printf ; 0x20b5b0
;;;221        QC_TEST_PRINT_STRING("APP Version:", APP_VERSION_STR);
        0x0020b77a:    a091        ..      ADR      r0,{pc}+0x246 ; 0x20b9c0
        0x0020b77c:    f7ffff18    ....    BL       mf_printf ; 0x20b5b0
        0x0020b780:    a07f        ..      ADR      r0,{pc}+0x200 ; 0x20b980
        0x0020b782:    f7ffff15    ....    BL       mf_printf ; 0x20b5b0
        0x0020b786:    a092        ..      ADR      r0,{pc}+0x24a ; 0x20b9d0
        0x0020b788:    f7ffff12    ....    BL       mf_printf ; 0x20b5b0
        0x0020b78c:    a081        ..      ADR      r0,{pc}+0x208 ; 0x20b994
        0x0020b78e:    f7ffff0f    ....    BL       mf_printf ; 0x20b5b0
;;;222    
;;;223        _qc_get_mac_addr(mac);
        0x0020b792:    a924        $.      ADD      r1,sp,#0x90
        0x0020b794:    f44f7000    O..p    MOV      r0,#0x200
        0x0020b798:    f640fc4d    @.M.    BL       gap_get_param ; 0x4c036
;;;224        sprintf(str, MAC_STR_FORMAT, mac[5], mac[4], mac[3], mac[2], mac[1], mac[0]);
        0x0020b79c:    f89d0093    ....    LDRB     r0,[sp,#0x93]
        0x0020b7a0:    f89d3090    ...0    LDRB     r3,[sp,#0x90]
        0x0020b7a4:    f89d2091    ...     LDRB     r2,[sp,#0x91]
        0x0020b7a8:    f89d1092    ....    LDRB     r1,[sp,#0x92]
        0x0020b7ac:    e88d000f    ....    STM      sp,{r0-r3}
        0x0020b7b0:    f89d3094    ...0    LDRB     r3,[sp,#0x94]
        0x0020b7b4:    f89d2095    ...     LDRB     r2,[sp,#0x95]
        0x0020b7b8:    a188        ..      ADR      r1,{pc}+0x224 ; 0x20b9dc
        0x0020b7ba:    a804        ..      ADD      r0,sp,#0x10
        0x0020b7bc:    f000fac8    ....    BL       __2sprintf ; 0x20bd50
;;;225        QC_TEST_PRINT_STRING("MAC:", str);
        0x0020b7c0:    a08e        ..      ADR      r0,{pc}+0x23c ; 0x20b9fc
        0x0020b7c2:    f7fffef5    ....    BL       mf_printf ; 0x20b5b0
        0x0020b7c6:    a06e        n.      ADR      r0,{pc}+0x1ba ; 0x20b980
        0x0020b7c8:    f7fffef2    ....    BL       mf_printf ; 0x20b5b0
        0x0020b7cc:    a804        ..      ADD      r0,sp,#0x10
        0x0020b7ce:    f7fffeef    ....    BL       mf_printf ; 0x20b5b0
        0x0020b7d2:    a070        p.      ADR      r0,{pc}+0x1c2 ; 0x20b994
        0x0020b7d4:    f7fffeec    ....    BL       mf_printf ; 0x20b5b0
;;;226        QC_TEST_PRINT_STRING("Local Bluetooth Address:", str);
        0x0020b7d8:    a08a        ..      ADR      r0,{pc}+0x22c ; 0x20ba04
        0x0020b7da:    f7fffee9    ....    BL       mf_printf ; 0x20b5b0
        0x0020b7de:    a068        h.      ADR      r0,{pc}+0x1a2 ; 0x20b980
        0x0020b7e0:    f7fffee6    ....    BL       mf_printf ; 0x20b5b0
        0x0020b7e4:    a804        ..      ADD      r0,sp,#0x10
        0x0020b7e6:    f7fffee3    ....    BL       mf_printf ; 0x20b5b0
        0x0020b7ea:    a06a        j.      ADR      r0,{pc}+0x1aa ; 0x20b994
        0x0020b7ec:    f7fffee0    ....    BL       mf_printf ; 0x20b5b0
        0x0020b7f0:    f646fe40    F.@.    BL       le_scan_start ; 0x52474
;;;227    
;;;228        _qc_ble_scan_start();
;;;229        os_delay(1000);
        0x0020b7f4:    f44f707a    O.zp    MOV      r0,#0x3e8
        0x0020b7f8:    f61affba    ....    BL       os_delay ; 0x26770
        0x0020b7fc:    f646fe69    F.i.    BL       le_scan_stop ; 0x524d2
;;;230        _qc_ble_scan_stop();
;;;231    
;;;232        os_task_delete(mxchp_qc_task);
        0x0020b800:    4840        @H      LDR      r0,[pc,#256] ; [0x20b904] = 0x20d3e8
        0x0020b802:    380c        .8      SUBS     r0,r0,#0xc
        0x0020b804:    6840        @h      LDR      r0,[r0,#4]
        0x0020b806:    f61bf906    ....    BL       os_task_delete ; 0x26a16
;;;233    }
        0x0020b80a:    b027        '.      ADD      sp,sp,#0x9c
        0x0020b80c:    bd00        ..      POP      {pc}
    mxchip_qc_init
        0x0020b80e:    b51c        ..      PUSH     {r2-r4,lr}
;;;234    
;;;235    static void _qc_init(void)
;;;236    {
;;;237        RCC_PeriphClockCmd(APBPeriph_GPIO, APBPeriph_GPIO_CLOCK, ENABLE);
;;;238        Pinmux_Config(MXCHIP_QC_CHECK_PIN, DWGPIO);
;;;239        Pinmux_Config(MXCHIP_ATE_CHECK_PIN, DWGPIO);
;;;240        Pad_Config(MXCHIP_QC_CHECK_PIN, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;241        Pad_Config(MXCHIP_ATE_CHECK_PIN, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;242        GPIO_InitTypeDef qc_pin_param;
;;;243        GPIO_StructInit(&qc_pin_param);
;;;244        qc_pin_param.GPIO_Pin = GPIO_GetPin(MXCHIP_QC_CHECK_PIN) | GPIO_GetPin(MXCHIP_ATE_CHECK_PIN);
;;;245        qc_pin_param.GPIO_Mode = GPIO_Mode_IN;
;;;246        GPIO_Init(&qc_pin_param);
;;;247    }
;;;248    
;;;249    static uint8_t _qc_check(void)
;;;250    {
;;;251        _qc_init();
        0x0020b810:    f000f842    ..B.    BL       _qc_init ; 0x20b898
;;;252        if (GPIO_ReadInputDataBit(GPIO_GetPin(MXCHIP_QC_CHECK_PIN)) == 0 && GPIO_ReadInputDataBit(GPIO_GetPin(MXCHIP_ATE_CHECK_PIN)) != 0)
        0x0020b814:    2001        .       MOVS     r0,#1
        0x0020b816:    f7fcfce8    ....    BL       GPIO_GetPin ; 0x2081ea
        0x0020b81a:    f000f835    ..5.    BL       GPIO_ReadInputDataBit ; 0x20b888
        0x0020b81e:    b938        8.      CBNZ     r0,0x20b830 ; mxchip_qc_init + 34
        0x0020b820:    2000        .       MOVS     r0,#0
        0x0020b822:    f7fcfce2    ....    BL       GPIO_GetPin ; 0x2081ea
        0x0020b826:    f000f82f    ../.    BL       GPIO_ReadInputDataBit ; 0x20b888
        0x0020b82a:    b108        ..      CBZ      r0,0x20b830 ; mxchip_qc_init + 34
;;;253        {
;;;254            return 1;
        0x0020b82c:    2001        .       MOVS     r0,#1
        0x0020b82e:    e00c        ..      B        0x20b84a ; mxchip_qc_init + 60
;;;255        }
;;;256        if (GPIO_ReadInputDataBit(GPIO_GetPin(MXCHIP_QC_CHECK_PIN)) == 0 && GPIO_ReadInputDataBit(GPIO_GetPin(MXCHIP_ATE_CHECK_PIN)) == 0)
        0x0020b830:    2001        .       MOVS     r0,#1
        0x0020b832:    f7fcfcda    ....    BL       GPIO_GetPin ; 0x2081ea
        0x0020b836:    f000f827    ..'.    BL       GPIO_ReadInputDataBit ; 0x20b888
        0x0020b83a:    b928        (.      CBNZ     r0,0x20b848 ; mxchip_qc_init + 58
        0x0020b83c:    2000        .       MOVS     r0,#0
        0x0020b83e:    f7fcfcd4    ....    BL       GPIO_GetPin ; 0x2081ea
        0x0020b842:    f000f821    ..!.    BL       GPIO_ReadInputDataBit ; 0x20b888
        0x0020b846:    b168        h.      CBZ      r0,0x20b864 ; mxchip_qc_init + 86
        0x0020b848:    2000        .       MOVS     r0,#0
        0x0020b84a:    2801        .(      CMP      r0,#1
        0x0020b84c:    d00c        ..      BEQ      0x20b868 ; mxchip_qc_init + 90
        0x0020b84e:    2802        .(      CMP      r0,#2
        0x0020b850:    d119        ..      BNE      0x20b886 ; mxchip_qc_init + 120
;;; ..\..\..\inc\platform\test_mode.h
;;;146        set_hci_mode_flag(true);
        0x0020b852:    2001        .       MOVS     r0,#1
        0x0020b854:    f600ff74    ..t.    BL       set_hci_mode_flag ; 0xc740
;;;147        WDG_SystemReset(RESET_ALL_EXCEPT_AON, SWITCH_HCI_MODE);
        0x0020b858:    e8bd401c    ...@    POP      {r2-r4,lr}
        0x0020b85c:    21d5        .!      MOVS     r1,#0xd5
        0x0020b85e:    2001        .       MOVS     r0,#1
        0x0020b860:    f010bc1b    ....    B.W      WDG_SystemReset ; 0x21c09a
;;; ..\..\..\src\sample\ble_central\mxchip_qc.c
;;;258            return 2;
        0x0020b864:    2002        .       MOVS     r0,#2
        0x0020b866:    e7f0        ..      B        0x20b84a ; mxchip_qc_init + 60
;;;259        }
;;;260    
;;;261        return 0;
;;;262    }
;;;263    
;;;264    void mxchip_qc_init(void)
;;;265    {
;;;266        uint8_t qc_state = _qc_check();
;;;267        if (qc_state == 1)
;;;268        {
;;;269            os_task_create(&mxchp_qc_task, "qc", _mxchip_qc_test, 0, 2048,
        0x0020b868:    2101        .!      MOVS     r1,#1
        0x0020b86a:    02c8        ..      LSLS     r0,r1,#11
        0x0020b86c:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0020b870:    4824        $H      LDR      r0,[pc,#144] ; [0x20b904] = 0x20d3e8
        0x0020b872:    2300        .#      MOVS     r3,#0
        0x0020b874:    4a6a        jJ      LDR      r2,[pc,#424] ; [0x20ba20] = 0x20b72b
        0x0020b876:    a16b        k.      ADR      r1,{pc}+0x1ae ; 0x20ba24
        0x0020b878:    3808        .8      SUBS     r0,r0,#8
        0x0020b87a:    f61bf8a9    ....    BL       os_task_create ; 0x269d0
;;;270                           APP_TASK_PRIORITY);
;;;271    
;;;272            os_sched_start();
        0x0020b87e:    e8bd401c    ...@    POP      {r2-r4,lr}
        0x0020b882:    f61abf9e    ....    B        os_sched_start ; 0x267c2
;;;273        }
;;;274        else if (qc_state == 2)
;;;275        {
;;;276            switch_to_hci_mode();
;;;277        }
;;;278        else
;;;279        {
;;;280            ;
;;;281        }
;;;282    }
        0x0020b886:    bd1c        ..      POP      {r2-r4,pc}
    GPIO_ReadInputDataBit
;;; ..\..\..\inc\peripheral\rtl876x_gpio.h
;;;391        if (GPIO->DATAIN & GPIO_Pin)
        0x0020b888:    4a67        gJ      LDR      r2,[pc,#412] ; [0x20ba28] = 0x40001000
;;; ..\..\..\inc\peripheral\rtl876x_gpio.h (385)
        0x0020b88a:    4601        .F      MOV      r1,r0
        0x0020b88c:    2000        .       MOVS     r0,#0
        0x0020b88e:    6d12        .m      LDR      r2,[r2,#0x50]
        0x0020b890:    420a        .B      TST      r2,r1
        0x0020b892:    d000        ..      BEQ      0x20b896 ; GPIO_ReadInputDataBit + 14
;;;386        uint8_t bitstatus = RESET;
;;;387    
;;;388        /* Check the parameters */
;;;389        assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;390    
;;;391        if (GPIO->DATAIN & GPIO_Pin)
;;;392        {
;;;393            bitstatus = (uint8_t)SET;
        0x0020b894:    2001        .       MOVS     r0,#1
;;;394        }
;;;395    
;;;396        return bitstatus;
;;;397    }
        0x0020b896:    4770        pG      BX       lr
    _qc_init
;;; ..\..\..\src\sample\ble_central\mxchip_qc.c
;;;236    {
        0x0020b898:    b530        0.      PUSH     {r4,r5,lr}
        0x0020b89a:    b087        ..      SUB      sp,sp,#0x1c
;;;237        RCC_PeriphClockCmd(APBPeriph_GPIO, APBPeriph_GPIO_CLOCK, ENABLE);
        0x0020b89c:    2201        ."      MOVS     r2,#1
        0x0020b89e:    f04f5104    O..Q    MOV      r1,#0x21000000
        0x0020b8a2:    4862        bH      LDR      r0,[pc,#392] ; [0x20ba2c] = 0xc000100
        0x0020b8a4:    f7fcfa70    ..p.    BL       RCC_PeriphClockCmd ; 0x207d88
;;;238        Pinmux_Config(MXCHIP_QC_CHECK_PIN, DWGPIO);
        0x0020b8a8:    215a        Z!      MOVS     r1,#0x5a
        0x0020b8aa:    2001        .       MOVS     r0,#1
        0x0020b8ac:    f605fd62    ..b.    BL       Pinmux_Config ; 0x11374
;;;239        Pinmux_Config(MXCHIP_ATE_CHECK_PIN, DWGPIO);
        0x0020b8b0:    215a        Z!      MOVS     r1,#0x5a
        0x0020b8b2:    2000        .       MOVS     r0,#0
        0x0020b8b4:    f605fd5e    ..^.    BL       Pinmux_Config ; 0x11374
;;;240        Pad_Config(MXCHIP_QC_CHECK_PIN, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0020b8b8:    2301        .#      MOVS     r3,#1
        0x0020b8ba:    2400        .$      MOVS     r4,#0
        0x0020b8bc:    9400        ..      STR      r4,[sp,#0]
        0x0020b8be:    461a        .F      MOV      r2,r3
        0x0020b8c0:    4619        .F      MOV      r1,r3
        0x0020b8c2:    4618        .F      MOV      r0,r3
        0x0020b8c4:    9401        ..      STR      r4,[sp,#4]
        0x0020b8c6:    f605fd89    ....    BL       Pad_Config ; 0x113dc
;;;241        Pad_Config(MXCHIP_ATE_CHECK_PIN, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0020b8ca:    2301        .#      MOVS     r3,#1
        0x0020b8cc:    9400        ..      STR      r4,[sp,#0]
        0x0020b8ce:    461a        .F      MOV      r2,r3
        0x0020b8d0:    4619        .F      MOV      r1,r3
        0x0020b8d2:    2000        .       MOVS     r0,#0
        0x0020b8d4:    9401        ..      STR      r4,[sp,#4]
        0x0020b8d6:    f605fd81    ....    BL       Pad_Config ; 0x113dc
;;;242        GPIO_InitTypeDef qc_pin_param;
;;;243        GPIO_StructInit(&qc_pin_param);
        0x0020b8da:    a802        ..      ADD      r0,sp,#8
        0x0020b8dc:    f7fcfc63    ..c.    BL       GPIO_StructInit ; 0x2081a6
;;;244        qc_pin_param.GPIO_Pin = GPIO_GetPin(MXCHIP_QC_CHECK_PIN) | GPIO_GetPin(MXCHIP_ATE_CHECK_PIN);
        0x0020b8e0:    2001        .       MOVS     r0,#1
        0x0020b8e2:    f7fcfc82    ....    BL       GPIO_GetPin ; 0x2081ea
        0x0020b8e6:    4605        .F      MOV      r5,r0
        0x0020b8e8:    2000        .       MOVS     r0,#0
        0x0020b8ea:    f7fcfc7e    ..~.    BL       GPIO_GetPin ; 0x2081ea
        0x0020b8ee:    4305        .C      ORRS     r5,r5,r0
;;;245        qc_pin_param.GPIO_Mode = GPIO_Mode_IN;
        0x0020b8f0:    9502        ..      STR      r5,[sp,#8]
        0x0020b8f2:    f88d400c    ...@    STRB     r4,[sp,#0xc]
;;;246        GPIO_Init(&qc_pin_param);
        0x0020b8f6:    a802        ..      ADD      r0,sp,#8
        0x0020b8f8:    f7fcfbf6    ....    BL       GPIO_Init ; 0x2080e8
;;;247    }
        0x0020b8fc:    b007        ..      ADD      sp,sp,#0x1c
        0x0020b8fe:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x0020b900:    0020bffe    .. .    DCD    2146302
        0x0020b904:    0020d3e8    .. .    DCD    2151400
        0x0020b908:    615f6371    qc_a    DCD    1633641329
        0x0020b90c:    00007070    pp..    DCD    28784
        0x0020b910:    40012000    . .@    DCD    1073815552
        0x0020b914:    40000001    ...@    DCD    1073741825
        0x0020b918:    08000001    ....    DCD    134217729
        0x0020b91c:    52444441    ADDR    DCD    1380205633
        0x0020b920:    3025203a    : %0    DCD    807739450
        0x0020b924:    253a5832    2X:%    DCD    624580658
        0x0020b928:    3a583230    02X:    DCD    978858544
        0x0020b92c:    58323025    %02X    DCD    1479684133
        0x0020b930:    3230253a    :%02    DCD    842016058
        0x0020b934:    30253a58    X:%0    DCD    807746136
        0x0020b938:    253a5832    2X:%    DCD    624580658
        0x0020b93c:    2c583230    02X,    DCD    743977520
        0x0020b940:    53535220     RSS    DCD    1397969440
        0x0020b944:    25203a49    I: %    DCD    622869065
        0x0020b948:    000a0d64    d...    DCD    658788
        0x0020b94c:    3d3d3d3d    ====    DCD    1027423549
        0x0020b950:    43584d20     MXC    DCD    1129860384
        0x0020b954:    20504948    HIP     DCD    542132552
        0x0020b958:    756e614d    Manu    DCD    1970168141
        0x0020b95c:    74636166    fact    DCD    1952670054
        0x0020b960:    20657275    ure     DCD    543519349
        0x0020b964:    74736554    Test    DCD    1953719636
        0x0020b968:    3d3d3d20     ===    DCD    1027423520
        0x0020b96c:    000a0d3d    =...    DCD    658749
        0x0020b970:    69726553    Seri    DCD    1769104723
        0x0020b974:    4e206c61    al N    DCD    1310747745
        0x0020b978:    65626d75    umbe    DCD    1700949365
        0x0020b97c:    00003a72    r:..    DCD    14962
        0x0020b980:    00000020     ...    DCD    32
        0x0020b984:    30363630    0660    DCD    808859184
        0x0020b988:    3046582e    .XF0    DCD    809916462
        0x0020b98c:    594c2e31    1.LY    DCD    1498164785
        0x0020b990:    00003130    01..    DCD    12592
        0x0020b994:    00000a0d    ....    DCD    2573
        0x0020b998:    7262694c    Libr    DCD    1919052108
        0x0020b99c:    20797261    ary     DCD    544830049
        0x0020b9a0:    73726556    Vers    DCD    1936876886
        0x0020b9a4:    3a6e6f69    ion:    DCD    980316009
        0x0020b9a8:    00000000    ....    DCD    0
        0x0020b9ac:    32656542    Bee2    DCD    845505858
        0x0020b9b0:    4b44535f    _SDK    DCD    1262768991
        0x0020b9b4:    2e31765f    _v1.    DCD    774993503
        0x0020b9b8:    2e322e30    0.2.    DCD    775040560
        0x0020b9bc:    00000030    0...    DCD    48
        0x0020b9c0:    20505041    APP     DCD    542134337
        0x0020b9c4:    73726556    Vers    DCD    1936876886
        0x0020b9c8:    3a6e6f69    ion:    DCD    980316009
        0x0020b9cc:    00000000    ....    DCD    0
        0x0020b9d0:    5f505041    APP_    DCD    1599098945
        0x0020b9d4:    302e3176    v1.0    DCD    808333686
        0x0020b9d8:    0000312e    .1..    DCD    12590
        0x0020b9dc:    58323025    %02X    DCD    1479684133
        0x0020b9e0:    3230252d    -%02    DCD    842016045
        0x0020b9e4:    30252d58    X-%0    DCD    807742808
        0x0020b9e8:    252d5832    2X-%    DCD    623728690
        0x0020b9ec:    2d583230    02X-    DCD    760754736
        0x0020b9f0:    58323025    %02X    DCD    1479684133
        0x0020b9f4:    3230252d    -%02    DCD    842016045
        0x0020b9f8:    00000058    X...    DCD    88
        0x0020b9fc:    3a43414d    MAC:    DCD    977486157
        0x0020ba00:    00000000    ....    DCD    0
        0x0020ba04:    61636f4c    Loca    DCD    1633906508
        0x0020ba08:    6c42206c    l Bl    DCD    1816273004
        0x0020ba0c:    6f746575    ueto    DCD    1869899125
        0x0020ba10:    2068746f    oth     DCD    543716463
        0x0020ba14:    72646441    Addr    DCD    1919181889
        0x0020ba18:    3a737365    ess:    DCD    980644709
        0x0020ba1c:    00000000    ....    DCD    0
        0x0020ba20:    0020b72b    +. .    DCD    2144043
        0x0020ba24:    00006371    qc..    DCD    25457
        0x0020ba28:    40001000    ...@    DCD    1073745920
        0x0020ba2c:    0c000100    ....    DCD    201326848
    $t
    .text
    gap_sw_reset_req
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (123)
        0x0020ba30:    b570        p.      PUSH     {r4-r6,lr}
        0x0020ba32:    2402        .$      MOVS     r4,#2
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (123)
        0x0020ba34:    4605        .F      MOV      r5,r0
        0x0020ba36:    2801        .(      CMP      r0,#1
        0x0020ba38:    d002        ..      BEQ      0x20ba40 ; gap_sw_reset_req + 16
        0x0020ba3a:    2403        .$      MOVS     r4,#3
        0x0020ba3c:    4620         F      MOV      r0,r4
        0x0020ba3e:    bd70        p.      POP      {r4-r6,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (127)
        0x0020ba40:    f642f896    B...    BL       le_get_active_link_num ; 0x4db70
        0x0020ba44:    2800        .(      CMP      r0,#0
        0x0020ba46:    d1f9        ..      BNE      0x20ba3c ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (128)
        0x0020ba48:    4873        sH      LDR      r0,[pc,#460] ; [0x20bc18] = 0x202e38
        0x0020ba4a:    7801        .x      LDRB     r1,[r0,#0]
        0x0020ba4c:    07c8        ..      LSLS     r0,r1,#31
        0x0020ba4e:    d0f5        ..      BEQ      0x20ba3c ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (129)
        0x0020ba50:    f0110f0c    ....    TST      r1,#0xc
        0x0020ba54:    d0f2        ..      BEQ      0x20ba3c ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (130)
        0x0020ba56:    f0110f30    ..0.    TST      r1,#0x30
        0x0020ba5a:    d1ef        ..      BNE      0x20ba3c ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (131)
        0x0020ba5c:    0988        ..      LSRS     r0,r1,#6
        0x0020ba5e:    d1ed        ..      BNE      0x20ba3c ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (133)
        0x0020ba60:    4628        (F      MOV      r0,r5
        0x0020ba62:    f615fe3e    ..>.    BL       btif_sw_reset_req ; 0x216e2
        0x0020ba66:    2800        .(      CMP      r0,#0
        0x0020ba68:    d0e8        ..      BEQ      0x20ba3c ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (135)
        0x0020ba6a:    2400        .$      MOVS     r4,#0
        0x0020ba6c:    e7e6        ..      B        0x20ba3c ; gap_sw_reset_req + 12
    le_handle_sw_reset_rsp
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (147)
        0x0020ba6e:    b538        8.      PUSH     {r3-r5,lr}
        0x0020ba70:    0004        ..      MOVS     r4,r0
        0x0020ba72:    d107        ..      BNE      0x20ba84 ; le_handle_sw_reset_rsp + 22
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (150)
        0x0020ba74:    4968        hI      LDR      r1,[pc,#416] ; [0x20bc18] = 0x202e38
        0x0020ba76:    7808        .x      LDRB     r0,[r1,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (151)
        0x0020ba78:    f020000e     ...    BIC      r0,r0,#0xe
        0x0020ba7c:    7008        .p      STRB     r0,[r1,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (152)
        0x0020ba7e:    20fc        .       MOVS     r0,#0xfc
        0x0020ba80:    f641fa1f    A...    BL       gap_send_dev_state ; 0x4cec2
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (154)
        0x0020ba84:    4865        eH      LDR      r0,[pc,#404] ; [0x20bc1c] = 0x202e48
        0x0020ba86:    6802        .h      LDR      r2,[r0,#0]
        0x0020ba88:    2a00        .*      CMP      r2,#0
        0x0020ba8a:    d004        ..      BEQ      0x20ba96 ; le_handle_sw_reset_rsp + 40
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (157)
        0x0020ba8c:    f8ad4000    ...@    STRH     r4,[sp,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (158)
        0x0020ba90:    4669        iF      MOV      r1,sp
        0x0020ba92:    20a5        .       MOVS     r0,#0xa5
        0x0020ba94:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (160)
        0x0020ba96:    bd38        8.      POP      {r3-r5,pc}
    le_check_privacy_bond
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (166)
        0x0020ba98:    b530        0.      PUSH     {r4,r5,lr}
        0x0020ba9a:    b08b        ..      SUB      sp,sp,#0x2c
        0x0020ba9c:    f04f0100    O...    MOV      r1,#0
        0x0020baa0:    4d5f        _M      LDR      r5,[pc,#380] ; [0x20bc20] = 0x21103502
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (166)
        0x0020baa2:    0004        ..      MOVS     r4,r0
        0x0020baa4:    9106        ..      STR      r1,[sp,#0x18]
        0x0020baa6:    9107        ..      STR      r1,[sp,#0x1c]
        0x0020baa8:    9108        ..      STR      r1,[sp,#0x20]
        0x0020baaa:    9109        ..      STR      r1,[sp,#0x24]
        0x0020baac:    d002        ..      BEQ      0x20bab4 ; le_check_privacy_bond + 28
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (169)
        0x0020baae:    7820         x      LDRB     r0,[r4,#0]
        0x0020bab0:    2801        .(      CMP      r0,#1
        0x0020bab2:    d008        ..      BEQ      0x20bac6 ; le_check_privacy_bond + 46
        0x0020bab4:    2301        .#      MOVS     r3,#1
        0x0020bab6:    2201        ."      MOVS     r2,#1
        0x0020bab8:    495a        ZI      LDR      r1,[pc,#360] ; [0x20bc24] = 0x88026ec
        0x0020baba:    4628        (F      MOV      r0,r5
        0x0020babc:    f5fbffcf    ....    BL       log_buffer ; 0x7a5e
        0x0020bac0:    2000        .       MOVS     r0,#0
        0x0020bac2:    b00b        ..      ADD      sp,sp,#0x2c
        0x0020bac4:    bd30        0.      POP      {r4,r5,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (171)
        0x0020bac6:    78a0        .x      LDRB     r0,[r4,#2]
        0x0020bac8:    0700        ..      LSLS     r0,r0,#28
        0x0020baca:    d518        ..      BPL      0x20bafe ; le_check_privacy_bond + 102
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (174)
        0x0020bacc:    466a        jF      MOV      r2,sp
        0x0020bace:    2114        .!      MOVS     r1,#0x14
        0x0020bad0:    4620         F      MOV      r0,r4
        0x0020bad2:    f644fc47    D.G.    BL       le_get_key ; 0x50364
        0x0020bad6:    b180        ..      CBZ      r0,0x20bafa ; le_check_privacy_bond + 98
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (176)
        0x0020bad8:    2210        ."      MOVS     r2,#0x10
        0x0020bada:    a906        ..      ADD      r1,sp,#0x18
        0x0020badc:    4668        hF      MOV      r0,sp
        0x0020bade:    f64ef991    N...    BL       memcmp ; 0x59e04
        0x0020bae2:    b140        @.      CBZ      r0,0x20baf6 ; le_check_privacy_bond + 94
        0x0020bae4:    494f        OI      LDR      r1,[pc,#316] ; [0x20bc24] = 0x88026ec
        0x0020bae6:    7863        cx      LDRB     r3,[r4,#1]
        0x0020bae8:    2201        ."      MOVS     r2,#1
        0x0020baea:    3930        09      SUBS     r1,r1,#0x30
        0x0020baec:    4628        (F      MOV      r0,r5
        0x0020baee:    f5fbffb6    ....    BL       log_buffer ; 0x7a5e
        0x0020baf2:    2001        .       MOVS     r0,#1
        0x0020baf4:    e7e5        ..      B        0x20bac2 ; le_check_privacy_bond + 42
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (178)
        0x0020baf6:    2305        .#      MOVS     r3,#5
        0x0020baf8:    e7dd        ..      B        0x20bab6 ; le_check_privacy_bond + 30
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (188)
        0x0020bafa:    2304        .#      MOVS     r3,#4
        0x0020bafc:    e7db        ..      B        0x20bab6 ; le_check_privacy_bond + 30
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (193)
        0x0020bafe:    2302        .#      MOVS     r3,#2
        0x0020bb00:    e7d9        ..      B        0x20bab6 ; le_check_privacy_bond + 30
    le_bond_just_work_confirm
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (205)
        0x0020bb02:    460a        .F      MOV      r2,r1
        0x0020bb04:    eb000140    ..@.    ADD      r1,r0,r0,LSL #1
        0x0020bb08:    4847        GH      LDR      r0,[pc,#284] ; [0x20bc28] = 0x202e64
        0x0020bb0a:    b510        ..      PUSH     {r4,lr}
        0x0020bb0c:    6800        .h      LDR      r0,[r0,#0]
        0x0020bb0e:    eb001001    ....    ADD      r0,r0,r1,LSL #4
        0x0020bb12:    7801        .x      LDRB     r1,[r0,#0]
        0x0020bb14:    b129        ).      CBZ      r1,0x20bb22 ; le_bond_just_work_confirm + 32
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (208)
        0x0020bb16:    7981        .y      LDRB     r1,[r0,#6]
        0x0020bb18:    1dc0        ..      ADDS     r0,r0,#7
        0x0020bb1a:    f615fd9e    ....    BL       btif_just_work_req_cfm ; 0x2165a
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (210)
        0x0020bb1e:    2000        .       MOVS     r0,#0
        0x0020bb20:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (214)
        0x0020bb22:    2004        .       MOVS     r0,#4
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (216)
        0x0020bb24:    bd10        ..      POP      {r4,pc}
    le_gen_rand_addr
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (220)
        0x0020bb26:    b5f0        ..      PUSH     {r4-r7,lr}
        0x0020bb28:    b085        ..      SUB      sp,sp,#0x14
        0x0020bb2a:    460c        .F      MOV      r4,r1
        0x0020bb2c:    0005        ..      MOVS     r5,r0
        0x0020bb2e:    d006        ..      BEQ      0x20bb3e ; le_gen_rand_addr + 24
        0x0020bb30:    f616fadf    ....    BL       btif_le_gen_rand_addr ; 0x220f2
        0x0020bb34:    2800        .(      CMP      r0,#0
        0x0020bb36:    d048        H.      BEQ      0x20bbca ; le_gen_rand_addr + 164
        0x0020bb38:    2000        .       MOVS     r0,#0
        0x0020bb3a:    b005        ..      ADD      sp,sp,#0x14
        0x0020bb3c:    bdf0        ..      POP      {r4-r7,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (224)
        0x0020bb3e:    2600        .&      MOVS     r6,#0
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (226)
        0x0020bb40:    b384        ..      CBZ      r4,0x20bba4 ; le_gen_rand_addr + 126
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (232)
        0x0020bb42:    f010fa6b    ..k.    BL       rand ; 0x21c01c
        0x0020bb46:    7020         p      STRB     r0,[r4,#0]
        0x0020bb48:    1c67        g.      ADDS     r7,r4,#1
        0x0020bb4a:    f010fa67    ..g.    BL       rand ; 0x21c01c
        0x0020bb4e:    0a00        ..      LSRS     r0,r0,#8
        0x0020bb50:    7038        8p      STRB     r0,[r7,#0]
        0x0020bb52:    f010fa63    ..c.    BL       rand ; 0x21c01c
        0x0020bb56:    0c00        ..      LSRS     r0,r0,#16
        0x0020bb58:    7078        xp      STRB     r0,[r7,#1]
        0x0020bb5a:    f010fa5f    .._.    BL       rand ; 0x21c01c
        0x0020bb5e:    0e00        ..      LSRS     r0,r0,#24
        0x0020bb60:    70b8        .p      STRB     r0,[r7,#2]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (233)
        0x0020bb62:    f010fa5b    ..[.    BL       rand ; 0x21c01c
        0x0020bb66:    70f8        .p      STRB     r0,[r7,#3]
        0x0020bb68:    f010fa58    ..X.    BL       rand ; 0x21c01c
        0x0020bb6c:    0a00        ..      LSRS     r0,r0,#8
        0x0020bb6e:    7138        8q      STRB     r0,[r7,#4]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (235)
        0x0020bb70:    f04000c0    @...    ORR      r0,r0,#0xc0
        0x0020bb74:    7160        `q      STRB     r0,[r4,#5]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (236)
        0x0020bb76:    a02d        -.      ADR      r0,{pc}+0xb6 ; 0x20bc2c
        0x0020bb78:    2206        ."      MOVS     r2,#6
        0x0020bb7a:    e9d01000    ....    LDRD     r1,r0,[r0,#0]
        0x0020bb7e:    e9cd1001    ....    STRD     r1,r0,[sp,#4]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (237)
        0x0020bb82:    a02c        ,.      ADR      r0,{pc}+0xb2 ; 0x20bc34
        0x0020bb84:    e9d01000    ....    LDRD     r1,r0,[r0,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (238)
        0x0020bb88:    e9cd1003    ....    STRD     r1,r0,[sp,#0xc]
        0x0020bb8c:    a901        ..      ADD      r1,sp,#4
        0x0020bb8e:    4620         F      MOV      r0,r4
        0x0020bb90:    f64ef938    N.8.    BL       memcmp ; 0x59e04
        0x0020bb94:    b148        H.      CBZ      r0,0x20bbaa ; le_gen_rand_addr + 132
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (239)
        0x0020bb96:    2206        ."      MOVS     r2,#6
        0x0020bb98:    a903        ..      ADD      r1,sp,#0xc
        0x0020bb9a:    4620         F      MOV      r0,r4
        0x0020bb9c:    f64ef932    N.2.    BL       memcmp ; 0x59e04
        0x0020bba0:    b118        ..      CBZ      r0,0x20bbaa ; le_gen_rand_addr + 132
        0x0020bba2:    e004        ..      B        0x20bbae ; le_gen_rand_addr + 136
        0x0020bba4:    e7ff        ..      B        0x20bba6 ; le_gen_rand_addr + 128
        0x0020bba6:    2003        .       MOVS     r0,#3
        0x0020bba8:    e7c7        ..      B        0x20bb3a ; le_gen_rand_addr + 20
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (241)
        0x0020bbaa:    2066        f       MOVS     r0,#0x66
        0x0020bbac:    7020         p      STRB     r0,[r4,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (243)
        0x0020bbae:    4621        !F      MOV      r1,r4
        0x0020bbb0:    4822        "H      LDR      r0,[pc,#136] ; [0x20bc3c] = 0x21300000
        0x0020bbb2:    f5fcf911    ....    BL       trace_bdaddr ; 0x7dd8
        0x0020bbb6:    491b        .I      LDR      r1,[pc,#108] ; [0x20bc24] = 0x88026ec
        0x0020bbb8:    4603        .F      MOV      r3,r0
        0x0020bbba:    2202        ."      MOVS     r2,#2
        0x0020bbbc:    3138        81      ADDS     r1,r1,#0x38
        0x0020bbbe:    4818        .H      LDR      r0,[pc,#96] ; [0x20bc20] = 0x21103502
        0x0020bbc0:    9500        ..      STR      r5,[sp,#0]
        0x0020bbc2:    f5fbff4c    ..L.    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (245)
        0x0020bbc6:    4630        0F      MOV      r0,r6
        0x0020bbc8:    e7b7        ..      B        0x20bb3a ; le_gen_rand_addr + 20
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (251)
        0x0020bbca:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (252)
        0x0020bbcc:    e7b5        ..      B        0x20bb3a ; le_gen_rand_addr + 20
    le_bond_get_sec_level
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (266)
        0x0020bbce:    b510        ..      PUSH     {r4,lr}
        0x0020bbd0:    b08a        ..      SUB      sp,sp,#0x28
        0x0020bbd2:    460c        .F      MOV      r4,r1
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (269)
        0x0020bbd4:    2100        .!      MOVS     r1,#0
        0x0020bbd6:    7021        !p      STRB     r1,[r4,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (270)
        0x0020bbd8:    aa09        ..      ADD      r2,sp,#0x24
        0x0020bbda:    a907        ..      ADD      r1,sp,#0x1c
        0x0020bbdc:    f642f807    B...    BL       le_get_conn_addr ; 0x4dbee
        0x0020bbe0:    b1c0        ..      CBZ      r0,0x20bc14 ; le_bond_get_sec_level + 70
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (273)
        0x0020bbe2:    f89d1024    ..$.    LDRB     r1,[sp,#0x24]
        0x0020bbe6:    a807        ..      ADD      r0,sp,#0x1c
        0x0020bbe8:    f644fad1    D...    BL       le_find_key_entry ; 0x5018e
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (274)
        0x0020bbec:    b190        ..      CBZ      r0,0x20bc14 ; le_bond_get_sec_level + 70
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (277)
        0x0020bbee:    466a        jF      MOV      r2,sp
        0x0020bbf0:    2111        .!      MOVS     r1,#0x11
        0x0020bbf2:    f644fbb7    D...    BL       le_get_key ; 0x50364
        0x0020bbf6:    b168        h.      CBZ      r0,0x20bc14 ; le_bond_get_sec_level + 70
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (279)
        0x0020bbf8:    490a        .I      LDR      r1,[pc,#40] ; [0x20bc24] = 0x88026ec
        0x0020bbfa:    f89d301b    ...0    LDRB     r3,[sp,#0x1b]
        0x0020bbfe:    2201        ."      MOVS     r2,#1
        0x0020bc00:    3174        t1      ADDS     r1,r1,#0x74
        0x0020bc02:    4807        .H      LDR      r0,[pc,#28] ; [0x20bc20] = 0x21103502
        0x0020bc04:    f5fbff2b    ..+.    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (280)
        0x0020bc08:    f89d001b    ....    LDRB     r0,[sp,#0x1b]
        0x0020bc0c:    7020         p      STRB     r0,[r4,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (281)
        0x0020bc0e:    2000        .       MOVS     r0,#0
        0x0020bc10:    b00a        ..      ADD      sp,sp,#0x28
        0x0020bc12:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (285)
        0x0020bc14:    2003        .       MOVS     r0,#3
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (286)
        0x0020bc16:    e7fb        ..      B        0x20bc10 ; le_bond_get_sec_level + 66
    $d
        0x0020bc18:    00202e38    8. .    DCD    2108984
        0x0020bc1c:    00202e48    H. .    DCD    2109000
        0x0020bc20:    21103502    .5.!    DCD    554710274
        0x0020bc24:    088026ec    .&..    DCD    142616300
        0x0020bc28:    00202e64    d. .    DCD    2109028
        0x0020bc2c:    00000000    ....    DCD    0
        0x0020bc30:    0000c000    ....    DCD    49152
        0x0020bc34:    ffffffff    ....    DCD    4294967295
        0x0020bc38:    0000ffff    ....    DCD    65535
        0x0020bc3c:    21300000    ..0!    DCD    556793856
    $t
    .text
    gap_set_lps_bootup_active_time
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (51)
        0x0020bc40:    b508        ..      PUSH     {r3,lr}
        0x0020bc42:    1ec1        ..      SUBS     r1,r0,#3
        0x0020bc44:    f24072fe    @..r    MOV      r2,#0x7fe
        0x0020bc48:    4291        .B      CMP      r1,r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (51)
        0x0020bc4a:    d301        ..      BCC      0x20bc50 ; gap_set_lps_bootup_active_time + 16
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (56)
        0x0020bc4c:    2000        .       MOVS     r0,#0
        0x0020bc4e:    bd08        ..      POP      {r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (58)
        0x0020bc50:    2105        .!      MOVS     r1,#5
        0x0020bc52:    f88d1000    ....    STRB     r1,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (59)
        0x0020bc56:    f88d0001    ....    STRB     r0,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (60)
        0x0020bc5a:    0a00        ..      LSRS     r0,r0,#8
        0x0020bc5c:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (62)
        0x0020bc60:    466a        jF      MOV      r2,sp
        0x0020bc62:    2103        .!      MOVS     r1,#3
        0x0020bc64:    f64f406e    O.n@    MOV      r0,#0xfc6e
        0x0020bc68:    f615fc40    ..@.    BL       btif_vendor_cmd_req ; 0x214ec
        0x0020bc6c:    2800        .(      CMP      r0,#0
        0x0020bc6e:    d0ee        ..      BEQ      0x20bc4e ; gap_set_lps_bootup_active_time + 14
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (64)
        0x0020bc70:    2001        .       MOVS     r0,#1
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (67)
        0x0020bc72:    bd08        ..      POP      {r3,pc}
    lps_get_wakeup_time
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (70)
        0x0020bc74:    b530        0.      PUSH     {r4,r5,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (71)
        0x0020bc76:    4b33        3K      LDR      r3,[pc,#204] ; [0x20bd44] = 0x201b1c
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (72)
        0x0020bc78:    681d        .h      LDR      r5,[r3,#0]
        0x0020bc7a:    1d1b        ..      ADDS     r3,r3,#4
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (73)
        0x0020bc7c:    681c        .h      LDR      r4,[r3,#0]
        0x0020bc7e:    1d1b        ..      ADDS     r3,r3,#4
        0x0020bc80:    681b        .h      LDR      r3,[r3,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (75)
        0x0020bc82:    6005        .`      STR      r5,[r0,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (76)
        0x0020bc84:    600c        .`      STR      r4,[r1,#0]
        0x0020bc86:    6013        .`      STR      r3,[r2,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (77)
        0x0020bc88:    bd30        0.      POP      {r4,r5,pc}
    le_handle_vendor_cmd_rsp
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (177)
        0x0020bc8a:    b538        8.      PUSH     {r3-r5,lr}
        0x0020bc8c:    4604        .F      MOV      r4,r0
        0x0020bc8e:    8800        ..      LDRH     r0,[r0,#0]
        0x0020bc90:    f64f456e    O.nE    MOV      r5,#0xfc6e
        0x0020bc94:    42a8        .B      CMP      r0,r5
        0x0020bc96:    d108        ..      BNE      0x20bcaa ; le_handle_vendor_cmd_rsp + 32
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (267)
        0x0020bc98:    8860        `.      LDRH     r0,[r4,#2]
        0x0020bc9a:    f8ad0000    ....    STRH     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (268)
        0x0020bc9e:    482a        *H      LDR      r0,[pc,#168] ; [0x20bd48] = 0x202e48
        0x0020bca0:    6802        .h      LDR      r2,[r0,#0]
        0x0020bca2:    b112        ..      CBZ      r2,0x20bcaa ; le_handle_vendor_cmd_rsp + 32
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (270)
        0x0020bca4:    4669        iF      MOV      r1,sp
        0x0020bca6:    20a6        .       MOVS     r0,#0xa6
        0x0020bca8:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (276)
        0x0020bcaa:    8820         .      LDRH     r0,[r4,#0]
        0x0020bcac:    f5a0417d    ..}A    SUB      r1,r0,#0xfd00
        0x0020bcb0:    3980        .9      SUBS     r1,r1,#0x80
        0x0020bcb2:    d00d        ..      BEQ      0x20bcd0 ; le_handle_vendor_cmd_rsp + 70
        0x0020bcb4:    1e49        I.      SUBS     r1,r1,#1
        0x0020bcb6:    d00b        ..      BEQ      0x20bcd0 ; le_handle_vendor_cmd_rsp + 70
        0x0020bcb8:    1e49        I.      SUBS     r1,r1,#1
        0x0020bcba:    d009        ..      BEQ      0x20bcd0 ; le_handle_vendor_cmd_rsp + 70
        0x0020bcbc:    42a8        .B      CMP      r0,r5
        0x0020bcbe:    d007        ..      BEQ      0x20bcd0 ; le_handle_vendor_cmd_rsp + 70
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (279)
        0x0020bcc0:    4822        "H      LDR      r0,[pc,#136] ; [0x20bd4c] = 0x202df4
        0x0020bcc2:    6802        .h      LDR      r2,[r0,#0]
        0x0020bcc4:    2a00        .*      CMP      r2,#0
        0x0020bcc6:    d003        ..      BEQ      0x20bcd0 ; le_handle_vendor_cmd_rsp + 70
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (282)
        0x0020bcc8:    2003        .       MOVS     r0,#3
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (284)
        0x0020bcca:    4669        iF      MOV      r1,sp
        0x0020bccc:    9400        ..      STR      r4,[sp,#0]
        0x0020bcce:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (287)
        0x0020bcd0:    bd38        8.      POP      {r3-r5,pc}
    gap_vendor_cmd_req
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (291)
        0x0020bcd2:    b510        ..      PUSH     {r4,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (292)
        0x0020bcd4:    f615fc0a    ....    BL       btif_vendor_cmd_req ; 0x214ec
        0x0020bcd8:    b108        ..      CBZ      r0,0x20bcde ; gap_vendor_cmd_req + 12
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (294)
        0x0020bcda:    2000        .       MOVS     r0,#0
        0x0020bcdc:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (296)
        0x0020bcde:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (297)
        0x0020bce0:    bd10        ..      POP      {r4,pc}
    le_handle_vendor_evt_info
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (300)
        0x0020bce2:    4601        .F      MOV      r1,r0
        0x0020bce4:    4819        .H      LDR      r0,[pc,#100] ; [0x20bd4c] = 0x202df4
        0x0020bce6:    b508        ..      PUSH     {r3,lr}
        0x0020bce8:    6802        .h      LDR      r2,[r0,#0]
        0x0020bcea:    2a00        .*      CMP      r2,#0
        0x0020bcec:    d003        ..      BEQ      0x20bcf6 ; le_handle_vendor_evt_info + 20
        0x0020bcee:    9100        ..      STR      r1,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (304)
        0x0020bcf0:    2004        .       MOVS     r0,#4
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (306)
        0x0020bcf2:    4669        iF      MOV      r1,sp
        0x0020bcf4:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (308)
        0x0020bcf6:    bd08        ..      POP      {r3,pc}
    le_vendor_modify_bt_le_fw_policy
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (313)
        0x0020bcf8:    b50e        ..      PUSH     {r1-r3,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (316)
        0x0020bcfa:    2210        ."      MOVS     r2,#0x10
        0x0020bcfc:    f88d2000    ...     STRB     r2,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (317)
        0x0020bd00:    f88d0001    ....    STRB     r0,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (318)
        0x0020bd04:    0a02        ..      LSRS     r2,r0,#8
        0x0020bd06:    f88d2002    ...     STRB     r2,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (319)
        0x0020bd0a:    0c02        ..      LSRS     r2,r0,#16
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (320)
        0x0020bd0c:    0e00        ..      LSRS     r0,r0,#24
        0x0020bd0e:    f88d0004    ....    STRB     r0,[sp,#4]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (321)
        0x0020bd12:    f88d1005    ....    STRB     r1,[sp,#5]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (322)
        0x0020bd16:    0a08        ..      LSRS     r0,r1,#8
        0x0020bd18:    f88d0006    ....    STRB     r0,[sp,#6]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (323)
        0x0020bd1c:    0c08        ..      LSRS     r0,r1,#16
        0x0020bd1e:    f88d0007    ....    STRB     r0,[sp,#7]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (324)
        0x0020bd22:    0e08        ..      LSRS     r0,r1,#24
        0x0020bd24:    f88d2003    ...     STRB     r2,[sp,#3]
        0x0020bd28:    f88d0008    ....    STRB     r0,[sp,#8]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (326)
        0x0020bd2c:    466a        jF      MOV      r2,sp
        0x0020bd2e:    2109        .!      MOVS     r1,#9
        0x0020bd30:    f64f5080    O..P    MOV      r0,#0xfd80
        0x0020bd34:    f615fbda    ....    BL       btif_vendor_cmd_req ; 0x214ec
        0x0020bd38:    b108        ..      CBZ      r0,0x20bd3e ; le_vendor_modify_bt_le_fw_policy + 70
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (328)
        0x0020bd3a:    2000        .       MOVS     r0,#0
        0x0020bd3c:    bd0e        ..      POP      {r1-r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (330)
        0x0020bd3e:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (337)
        0x0020bd40:    bd0e        ..      POP      {r1-r3,pc}
    $d
        0x0020bd42:    0000        ..      DCW    0
        0x0020bd44:    00201b1c    .. .    DCD    2104092
        0x0020bd48:    00202e48    H. .    DCD    2109000
        0x0020bd4c:    00202df4    .- .    DCD    2108916
    $t
    .text
    __2sprintf
        0x0020bd50:    b40f        ..      PUSH     {r0-r3}
        0x0020bd52:    b51c        ..      PUSH     {r2-r4,lr}
        0x0020bd54:    4b07        .K      LDR      r3,[pc,#28] ; [0x20bd74] = 0x219
        0x0020bd56:    aa06        ..      ADD      r2,sp,#0x18
        0x0020bd58:    447b        {D      ADD      r3,r3,pc
        0x0020bd5a:    4669        iF      MOV      r1,sp
        0x0020bd5c:    9000        ..      STR      r0,[sp,#0]
        0x0020bd5e:    9805        ..      LDR      r0,[sp,#0x14]
        0x0020bd60:    f000f8f5    ....    BL       _printf_char_common ; 0x20bf4e
        0x0020bd64:    2000        .       MOVS     r0,#0
        0x0020bd66:    4669        iF      MOV      r1,sp
        0x0020bd68:    f000f904    ....    BL       _sputc ; 0x20bf74
        0x0020bd6c:    bc1c        ..      POP      {r2-r4}
        0x0020bd6e:    f85dfb14    ]...    LDR      pc,[sp],#0x14
    $d
        0x0020bd72:    0000        ..      DCW    0
        0x0020bd74:    00000219    ....    DCD    537
    $t
    .text
    _printf_int_dec
        0x0020bd78:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0020bd7c:    4606        .F      MOV      r6,r0
        0x0020bd7e:    2400        .$      MOVS     r4,#0
        0x0020bd80:    6810        .h      LDR      r0,[r2,#0]
        0x0020bd82:    2975        u)      CMP      r1,#0x75
        0x0020bd84:    4631        1F      MOV      r1,r6
        0x0020bd86:    a516        ..      ADR      r5,{pc}+0x5a ; 0x20bde0
        0x0020bd88:    d010        ..      BEQ      0x20bdac ; _printf_int_dec + 52
        0x0020bd8a:    f3af8000    ....    NOP.W    
        0x0020bd8e:    2800        .(      CMP      r0,#0
        0x0020bd90:    da02        ..      BGE      0x20bd98 ; _printf_int_dec + 32
        0x0020bd92:    4240        @B      RSBS     r0,r0,#0
        0x0020bd94:    a513        ..      ADR      r5,{pc}+0x50 ; 0x20bde4
        0x0020bd96:    e007        ..      B        0x20bda8 ; _printf_int_dec + 48
        0x0020bd98:    6831        1h      LDR      r1,[r6,#0]
        0x0020bd9a:    078a        ..      LSLS     r2,r1,#30
        0x0020bd9c:    d501        ..      BPL      0x20bda2 ; _printf_int_dec + 42
        0x0020bd9e:    a512        ..      ADR      r5,{pc}+0x4a ; 0x20bde8
        0x0020bda0:    e002        ..      B        0x20bda8 ; _printf_int_dec + 48
        0x0020bda2:    0749        I.      LSLS     r1,r1,#29
        0x0020bda4:    d504        ..      BPL      0x20bdb0 ; _printf_int_dec + 56
        0x0020bda6:    a511        ..      ADR      r5,{pc}+0x46 ; 0x20bdec
        0x0020bda8:    2401        .$      MOVS     r4,#1
        0x0020bdaa:    e001        ..      B        0x20bdb0 ; _printf_int_dec + 56
        0x0020bdac:    f3af8000    ....    NOP.W    
        0x0020bdb0:    2100        .!      MOVS     r1,#0
        0x0020bdb2:    220a        ."      MOVS     r2,#0xa
        0x0020bdb4:    f1060724    ..$.    ADD      r7,r6,#0x24
        0x0020bdb8:    e009        ..      B        0x20bdce ; _printf_int_dec + 86
        0x0020bdba:    fbb0fcf2    ....    UDIV     r12,r0,r2
        0x0020bdbe:    fbb0f3f2    ....    UDIV     r3,r0,r2
        0x0020bdc2:    fb02001c    ....    MLS      r0,r2,r12,r0
        0x0020bdc6:    3030        00      ADDS     r0,r0,#0x30
        0x0020bdc8:    5478        xT      STRB     r0,[r7,r1]
        0x0020bdca:    4618        .F      MOV      r0,r3
        0x0020bdcc:    1c49        I.      ADDS     r1,r1,#1
        0x0020bdce:    2800        .(      CMP      r0,#0
        0x0020bdd0:    d1f3        ..      BNE      0x20bdba ; _printf_int_dec + 66
        0x0020bdd2:    4623        #F      MOV      r3,r4
        0x0020bdd4:    462a        *F      MOV      r2,r5
        0x0020bdd6:    4630        0F      MOV      r0,r6
        0x0020bdd8:    e8bd41f0    ...A    POP      {r4-r8,lr}
        0x0020bddc:    f000b858    ..X.    B.W      _printf_int_common ; 0x20be90
    $d
        0x0020bde0:    00000000    ....    DCD    0
        0x0020bde4:    0000002d    -...    DCD    45
        0x0020bde8:    0000002b    +...    DCD    43
        0x0020bdec:    00000020     ...    DCD    32
    $t
    .text
    _printf_int_hex
    _printf_longlong_hex
        0x0020bdf0:    b570        p.      PUSH     {r4-r6,lr}
        0x0020bdf2:    4604        .F      MOV      r4,r0
        0x0020bdf4:    460d        .F      MOV      r5,r1
        0x0020bdf6:    4621        !F      MOV      r1,r4
        0x0020bdf8:    6810        .h      LDR      r0,[r2,#0]
        0x0020bdfa:    f3af8000    ....    NOP.W    
        0x0020bdfe:    8821        !.      LDRH     r1,[r4,#0]
        0x0020be00:    0509        ..      LSLS     r1,r1,#20
        0x0020be02:    d502        ..      BPL      0x20be0a ; _printf_int_hex + 26
        0x0020be04:    4a0f        .J      LDR      r2,[pc,#60] ; [0x20be44] = 0x10c6e
        0x0020be06:    447a        zD      ADD      r2,r2,pc
        0x0020be08:    e002        ..      B        0x20be10 ; _printf_int_hex + 32
        0x0020be0a:    4a0e        .J      LDR      r2,[pc,#56] ; [0x20be44] = 0x10c6e
        0x0020be0c:    447a        zD      ADD      r2,r2,pc
        0x0020be0e:    320e        .2      ADDS     r2,r2,#0xe
        0x0020be10:    2100        .!      MOVS     r1,#0
        0x0020be12:    f1040324    ..$.    ADD      r3,r4,#0x24
        0x0020be16:    e005        ..      B        0x20be24 ; _printf_int_hex + 52
        0x0020be18:    f000060f    ....    AND      r6,r0,#0xf
        0x0020be1c:    0900        ..      LSRS     r0,r0,#4
        0x0020be1e:    5d96        .]      LDRB     r6,[r2,r6]
        0x0020be20:    545e        ^T      STRB     r6,[r3,r1]
        0x0020be22:    1c49        I.      ADDS     r1,r1,#1
        0x0020be24:    2800        .(      CMP      r0,#0
        0x0020be26:    d1f7        ..      BNE      0x20be18 ; _printf_int_hex + 40
        0x0020be28:    7820         x      LDRB     r0,[r4,#0]
        0x0020be2a:    2300        .#      MOVS     r3,#0
        0x0020be2c:    0700        ..      LSLS     r0,r0,#28
        0x0020be2e:    d504        ..      BPL      0x20be3a ; _printf_int_hex + 74
        0x0020be30:    2d70        p-      CMP      r5,#0x70
        0x0020be32:    d002        ..      BEQ      0x20be3a ; _printf_int_hex + 74
        0x0020be34:    b109        ..      CBZ      r1,0x20be3a ; _printf_int_hex + 74
        0x0020be36:    2302        .#      MOVS     r3,#2
        0x0020be38:    3211        .2      ADDS     r2,r2,#0x11
        0x0020be3a:    4620         F      MOV      r0,r4
        0x0020be3c:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0020be40:    f000b826    ..&.    B.W      _printf_int_common ; 0x20be90
    $d
        0x0020be44:    00010c6e    n...    DCD    68718
    $t
    .text
    strcpy
        0x0020be48:    ea400301    @...    ORR      r3,r0,r1
        0x0020be4c:    4602        .F      MOV      r2,r0
        0x0020be4e:    b530        0.      PUSH     {r4,r5,lr}
        0x0020be50:    079b        ..      LSLS     r3,r3,#30
        0x0020be52:    d110        ..      BNE      0x20be76 ; strcpy + 46
        0x0020be54:    f04f3401    O..4    MOV      r4,#0x1010101
        0x0020be58:    e000        ..      B        0x20be5c ; strcpy + 20
        0x0020be5a:    c208        ..      STM      r2!,{r3}
        0x0020be5c:    c908        ..      LDM      r1!,{r3}
        0x0020be5e:    1b1d        ..      SUBS     r5,r3,r4
        0x0020be60:    439d        .C      BICS     r5,r5,r3
        0x0020be62:    ea151fc4    ....    TST      r5,r4,LSL #7
        0x0020be66:    d0f8        ..      BEQ      0x20be5a ; strcpy + 18
        0x0020be68:    f01301ff    ....    ANDS     r1,r3,#0xff
        0x0020be6c:    f8021b01    ....    STRB     r1,[r2],#1
        0x0020be70:    d00d        ..      BEQ      0x20be8e ; strcpy + 70
        0x0020be72:    0a1b        ..      LSRS     r3,r3,#8
        0x0020be74:    e7f8        ..      B        0x20be68 ; strcpy + 32
        0x0020be76:    f8113b01    ...;    LDRB     r3,[r1],#1
        0x0020be7a:    2b00        .+      CMP      r3,#0
        0x0020be7c:    f8023b01    ...;    STRB     r3,[r2],#1
        0x0020be80:    d005        ..      BEQ      0x20be8e ; strcpy + 70
        0x0020be82:    f8113b01    ...;    LDRB     r3,[r1],#1
        0x0020be86:    2b00        .+      CMP      r3,#0
        0x0020be88:    f8023b01    ...;    STRB     r3,[r2],#1
        0x0020be8c:    d1f3        ..      BNE      0x20be76 ; strcpy + 46
        0x0020be8e:    bd30        0.      POP      {r4,r5,pc}
    .text
    _printf_int_common
        0x0020be90:    e92d47f0    -..G    PUSH     {r4-r10,lr}
        0x0020be94:    460d        .F      MOV      r5,r1
        0x0020be96:    4699        .F      MOV      r9,r3
        0x0020be98:    4692        .F      MOV      r10,r2
        0x0020be9a:    4604        .F      MOV      r4,r0
        0x0020be9c:    f1000824    ..$.    ADD      r8,r0,#0x24
        0x0020bea0:    6801        .h      LDR      r1,[r0,#0]
        0x0020bea2:    0688        ..      LSLS     r0,r1,#26
        0x0020bea4:    d504        ..      BPL      0x20beb0 ; _printf_int_common + 32
        0x0020bea6:    69e0        .i      LDR      r0,[r4,#0x1c]
        0x0020bea8:    f0210110    !...    BIC      r1,r1,#0x10
        0x0020beac:    6021        !`      STR      r1,[r4,#0]
        0x0020beae:    e000        ..      B        0x20beb2 ; _printf_int_common + 34
        0x0020beb0:    2001        .       MOVS     r0,#1
        0x0020beb2:    42a8        .B      CMP      r0,r5
        0x0020beb4:    dd01        ..      BLE      0x20beba ; _printf_int_common + 42
        0x0020beb6:    1b47        G.      SUBS     r7,r0,r5
        0x0020beb8:    e000        ..      B        0x20bebc ; _printf_int_common + 44
        0x0020beba:    2700        .'      MOVS     r7,#0
        0x0020bebc:    69a1        .i      LDR      r1,[r4,#0x18]
        0x0020bebe:    197a        z.      ADDS     r2,r7,r5
        0x0020bec0:    eb020009    ....    ADD      r0,r2,r9
        0x0020bec4:    1a08        ..      SUBS     r0,r1,r0
        0x0020bec6:    61a0        .a      STR      r0,[r4,#0x18]
        0x0020bec8:    7820         x      LDRB     r0,[r4,#0]
        0x0020beca:    06c0        ..      LSLS     r0,r0,#27
        0x0020becc:    d402        ..      BMI      0x20bed4 ; _printf_int_common + 68
        0x0020bece:    4620         F      MOV      r0,r4
        0x0020bed0:    f010fb04    ....    BL       _printf_pre_padding ; 0x21c4dc
        0x0020bed4:    2600        .&      MOVS     r6,#0
        0x0020bed6:    e008        ..      B        0x20beea ; _printf_int_common + 90
        0x0020bed8:    e9d42101    ...!    LDRD     r2,r1,[r4,#4]
        0x0020bedc:    f81a0006    ....    LDRB     r0,[r10,r6]
        0x0020bee0:    4790        .G      BLX      r2
        0x0020bee2:    6a20         j      LDR      r0,[r4,#0x20]
        0x0020bee4:    1c40        @.      ADDS     r0,r0,#1
        0x0020bee6:    1c76        v.      ADDS     r6,r6,#1
        0x0020bee8:    6220         b      STR      r0,[r4,#0x20]
        0x0020beea:    454e        NE      CMP      r6,r9
        0x0020beec:    dbf4        ..      BLT      0x20bed8 ; _printf_int_common + 72
        0x0020beee:    7820         x      LDRB     r0,[r4,#0]
        0x0020bef0:    06c0        ..      LSLS     r0,r0,#27
        0x0020bef2:    d50a        ..      BPL      0x20bf0a ; _printf_int_common + 122
        0x0020bef4:    4620         F      MOV      r0,r4
        0x0020bef6:    f010faf1    ....    BL       _printf_pre_padding ; 0x21c4dc
        0x0020befa:    e006        ..      B        0x20bf0a ; _printf_int_common + 122
        0x0020befc:    e9d42101    ...!    LDRD     r2,r1,[r4,#4]
        0x0020bf00:    2030        0       MOVS     r0,#0x30
        0x0020bf02:    4790        .G      BLX      r2
        0x0020bf04:    6a20         j      LDR      r0,[r4,#0x20]
        0x0020bf06:    1c40        @.      ADDS     r0,r0,#1
        0x0020bf08:    6220         b      STR      r0,[r4,#0x20]
        0x0020bf0a:    1e38        8.      SUBS     r0,r7,#0
        0x0020bf0c:    f1a70701    ....    SUB      r7,r7,#1
        0x0020bf10:    dcf4        ..      BGT      0x20befc ; _printf_int_common + 108
        0x0020bf12:    e007        ..      B        0x20bf24 ; _printf_int_common + 148
        0x0020bf14:    e9d42101    ...!    LDRD     r2,r1,[r4,#4]
        0x0020bf18:    f8180005    ....    LDRB     r0,[r8,r5]
        0x0020bf1c:    4790        .G      BLX      r2
        0x0020bf1e:    6a20         j      LDR      r0,[r4,#0x20]
        0x0020bf20:    1c40        @.      ADDS     r0,r0,#1
        0x0020bf22:    6220         b      STR      r0,[r4,#0x20]
        0x0020bf24:    1e28        (.      SUBS     r0,r5,#0
        0x0020bf26:    f1a50501    ....    SUB      r5,r5,#1
        0x0020bf2a:    dcf3        ..      BGT      0x20bf14 ; _printf_int_common + 132
        0x0020bf2c:    4620         F      MOV      r0,r4
        0x0020bf2e:    f010faeb    ....    BL       _printf_post_padding ; 0x21c508
        0x0020bf32:    7820         x      LDRB     r0,[r4,#0]
        0x0020bf34:    0600        ..      LSLS     r0,r0,#24
        0x0020bf36:    d502        ..      BPL      0x20bf3e ; _printf_int_common + 174
        0x0020bf38:    2002        .       MOVS     r0,#2
        0x0020bf3a:    e8bd87f0    ....    POP      {r4-r10,pc}
        0x0020bf3e:    2001        .       MOVS     r0,#1
        0x0020bf40:    e7fb        ..      B        0x20bf3a ; _printf_int_common + 170
        0x0020bf42:    0000        ..      MOVS     r0,r0
    .text
    _printf_input_char
        0x0020bf44:    6901        .i      LDR      r1,[r0,#0x10]
        0x0020bf46:    1c4a        J.      ADDS     r2,r1,#1
        0x0020bf48:    6102        .a      STR      r2,[r0,#0x10]
        0x0020bf4a:    7808        .x      LDRB     r0,[r1,#0]
        0x0020bf4c:    4770        pG      BX       lr
    _printf_char_common
        0x0020bf4e:    b500        ..      PUSH     {lr}
        0x0020bf50:    b08f        ..      SUB      sp,sp,#0x3c
        0x0020bf52:    e9cd3101    ...1    STRD     r3,r1,[sp,#4]
        0x0020bf56:    2100        .!      MOVS     r1,#0
        0x0020bf58:    9105        ..      STR      r1,[sp,#0x14]
        0x0020bf5a:    4905        .I      LDR      r1,[pc,#20] ; [0x20bf70] = 0xffffffe5
        0x0020bf5c:    4479        yD      ADD      r1,r1,pc
        0x0020bf5e:    e9cd1003    ....    STRD     r1,r0,[sp,#0xc]
        0x0020bf62:    4611        .F      MOV      r1,r2
        0x0020bf64:    4668        hF      MOV      r0,sp
        0x0020bf66:    f010fae1    ....    BL       __printf ; 0x21c52c
        0x0020bf6a:    b00f        ..      ADD      sp,sp,#0x3c
        0x0020bf6c:    bd00        ..      POP      {pc}
    $d
        0x0020bf6e:    0000        ..      DCW    0
        0x0020bf70:    ffffffe5    ....    DCD    4294967269
    $t
    .text
    _sputc
        0x0020bf74:    680a        .h      LDR      r2,[r1,#0]
        0x0020bf76:    f8020b01    ....    STRB     r0,[r2],#1
        0x0020bf7a:    600a        .`      STR      r2,[r1,#0]
        0x0020bf7c:    4770        pG      BX       lr
        0x0020bf7e:    0000        ..      MOVS     r0,r0
    $d.realdata
    .constdata
    app_cb_table
        0x0020bf80:    0e85d101    ....    DCD    243650817
        0x0020bf84:    00000006    ....    DCD    6
        0x0020bf88:    0021c115    ..!.    DCD    2212117
        0x0020bf8c:    00000000    ....    DCD    0
        0x0020bf90:    00000000    ....    DCD    0
        0x0020bf94:    00000000    ....    DCD    0
        0x0020bf98:    00000000    ....    DCD    0
        0x0020bf9c:    0021c125    %.!.    DCD    2212133
    .constdata
    bas_client_cbs
        0x0020bfa0:    00208cfd    .. .    DCD    2133245
        0x0020bfa4:    00208de5    .. .    DCD    2133477
        0x0020bfa8:    00208ebf    .. .    DCD    2133695
        0x0020bfac:    00208e61    a. .    DCD    2133601
        0x0020bfb0:    00208f8f    .. .    DCD    2133903
        0x0020bfb4:    00208fc9    .. .    DCD    2133961
    __func__
        0x0020bfb8:    5f736162    bas_    DCD    1601397090
        0x0020bfbc:    5f646461    add_    DCD    1600414817
        0x0020bfc0:    65696c63    clie    DCD    1701407843
        0x0020bfc4:    0000746e    nt..    DCD    29806
    .constdata
    gaps_client_cbs
        0x0020bfc8:    00209251    Q. .    DCD    2134609
        0x0020bfcc:    0020930d    .. .    DCD    2134797
        0x0020bfd0:    002093a5    .. .    DCD    2134949
        0x0020bfd4:    00000000    ....    DCD    0
        0x0020bfd8:    00000000    ....    DCD    0
        0x0020bfdc:    00209459    Y. .    DCD    2135129
    __func__
        0x0020bfe0:    73706167    gaps    DCD    1936744807
        0x0020bfe4:    6464615f    _add    DCD    1684300127
        0x0020bfe8:    696c635f    _cli    DCD    1768711007
        0x0020bfec:    00746e65    ent.    DCD    7630437
    .constdata
    __func__
        0x0020bff0:    54524155    UART    DCD    1414676821
        0x0020bff4:    61485f30    0_Ha    DCD    1632132912
        0x0020bff8:    656c646e    ndle    DCD    1701602414
        0x0020bffc:    0072        r.      DCW    114
    .constdata
    __func__
        0x0020bffe:    6371        qc      DCW    25457
        0x0020c000:    7070615f    _app    DCD    1886413151
        0x0020c004:    69616d5f    _mai    DCD    1767992671
        0x0020c008:    61745f6e    n_ta    DCD    1635016558
        0x0020c00c:    6b73        sk      DCW    27507
        0x0020c00e:    00          .       DCB    0
    .constdata
    maptable
        0x0020c00f:    04          .       DCB    4
        0x0020c010:    00080000    ....    DCD    524288
        0x0020c014:    00000000    ....    DCD    0
        0x0020c018:    00020000    ....    DCD    131072
        0x0020c01c:    10000001    ....    DCD    268435457
    .conststring
        0x0020c020:    72617453    Star    DCD    1918989395
        0x0020c024:    63732074    t sc    DCD    1668489332
        0x0020c028:    0a0d6e61    an..    DCD    168652385
        0x0020c02c:    20202020            DCD    538976288
        0x0020c030:    20202020            DCD    538976288
        0x0020c034:    6c69665b    [fil    DCD    1818846811
        0x0020c038:    5f726574    ter_    DCD    1601332596
        0x0020c03c:    696c6f70    poli    DCD    1768714096
        0x0020c040:    3a5d7963    cy]:    DCD    979204451
        0x0020c044:    282d3020     0-(    DCD    674050080
        0x0020c048:    29796e61    any)    DCD    695823969
        0x0020c04c:    2d31202c    , 1-    DCD    758194220
        0x0020c050:    69687728    (whi    DCD    1768453928
        0x0020c054:    696c6574    teli    DCD    1768711540
        0x0020c058:    2c297473    st),    DCD    740914291
        0x0020c05c:    282d3220     2-(    DCD    674050592
        0x0020c060:    20796e61    any     DCD    544829025
        0x0020c064:    29415052    RPA)    DCD    692146258
        0x0020c068:    2d33202c    , 3-    DCD    758325292
        0x0020c06c:    69687728    (whi    DCD    1768453928
        0x0020c070:    696c6574    teli    DCD    1768711540
        0x0020c074:    52207473    st R    DCD    1377858675
        0x0020c078:    20294150    PA)     DCD    539574608
        0x0020c07c:    20200a0d    ..      DCD    538970637
        0x0020c080:    20202020            DCD    538976288
        0x0020c084:    665b2020      [f    DCD    1717248032
        0x0020c088:    65746c69    ilte    DCD    1702128745
        0x0020c08c:    75645f72    r_du    DCD    1969512306
        0x0020c090:    63696c70    plic    DCD    1667853424
        0x0020c094:    5d657461    ate]    DCD    1566930017
        0x0020c098:    2d30203a    : 0-    DCD    758128698
        0x0020c09c:    73696428    (dis    DCD    1936286760
        0x0020c0a0:    656c6261    able    DCD    1701601889
        0x0020c0a4:    31202c29    ), 1    DCD    824192041
        0x0020c0a8:    6e65282d    -(en    DCD    1852123181
        0x0020c0ac:    656c6261    able    DCD    1701601889
        0x0020c0b0:    0d0a2029    ) ..    DCD    218767401
        0x0020c0b4:    00000000    ....    DCD    0
        0x0020c0b8:    64616552    Read    DCD    1684104530
        0x0020c0bc:    6d697320     sim    DCD    1835627296
        0x0020c0c0:    20656c70    ple     DCD    543517808
        0x0020c0c4:    20656c62    ble     DCD    543517794
        0x0020c0c8:    76726573    serv    DCD    1987208563
        0x0020c0cc:    20656369    ice     DCD    543515497
        0x0020c0d0:    72616863    char    DCD    1918986339
        0x0020c0d4:    65746361    acte    DCD    1702126433
        0x0020c0d8:    74736972    rist    DCD    1953720690
        0x0020c0dc:    61206369    ic a    DCD    1629512553
        0x0020c0e0:    6420646e    nd d    DCD    1679844462
        0x0020c0e4:    72637365    escr    DCD    1919120229
        0x0020c0e8:    6f747069    ipto    DCD    1869901929
        0x0020c0ec:    61762072    r va    DCD    1635131506
        0x0020c0f0:    0d65756c    lue.    DCD    224753004
        0x0020c0f4:    2020200a    .       DCD    538976266
        0x0020c0f8:    20202020            DCD    538976288
        0x0020c0fc:    79745b20     [ty    DCD    2037668640
        0x0020c100:    3a5d6570    pe]:    DCD    979199344
        0x0020c104:    282d3020     0-(    DCD    674050080
        0x0020c108:    64616572    read    DCD    1684104562
        0x0020c10c:    29317620     v1)    DCD    691107360
        0x0020c110:    2d31202c    , 1-    DCD    758194220
        0x0020c114:    20337628    (v3     DCD    540243496
        0x0020c118:    64636363    cccd    DCD    1684235107
        0x0020c11c:    32202c29    ), 2    DCD    840969257
        0x0020c120:    3476282d    -(v4    DCD    880158765
        0x0020c124:    63636320     ccc    DCD    1667457824
        0x0020c128:    0a0d2964    d)..    DCD    168634724
        0x0020c12c:    20202020            DCD    538976288
        0x0020c130:    20202020            DCD    538976288
        0x0020c134:    7461705b    [pat    DCD    1952542811
        0x0020c138:    6e726574    tern    DCD    1852990836
        0x0020c13c:    30203a5d    ]: 0    DCD    807418461
        0x0020c140:    6572282d    -(re    DCD    1701980205
        0x0020c144:    62206461    ad b    DCD    1646290017
        0x0020c148:    61682079    y ha    DCD    1634214009
        0x0020c14c:    656c646e    ndle    DCD    1701602414
        0x0020c150:    31202c29    ), 1    DCD    824192041
        0x0020c154:    6572282d    -(re    DCD    1701980205
        0x0020c158:    62206461    ad b    DCD    1646290017
        0x0020c15c:    75752079    y uu    DCD    1970610297
        0x0020c160:    0d296469    id).    DCD    220816489
        0x0020c164:    2020200a    .       DCD    538976266
        0x0020c168:    20202020            DCD    538976288
        0x0020c16c:    6d617320     sam    DCD    1835103008
        0x0020c170:    3a656c70    ple:    DCD    979725424
        0x0020c174:    6d697320     sim    DCD    1835627296
        0x0020c178:    61657270    prea    DCD    1634038384
        0x0020c17c:    20302064    d 0     DCD    540024932
        0x0020c180:    20302031    1 0     DCD    540024881
        0x0020c184:    00000d0a    ....    DCD    3338
        0x0020c188:    6e6e6f43    Conn    DCD    1852731203
        0x0020c18c:    20746365    ect     DCD    544498533
        0x0020c190:    72206f74    to r    DCD    1914728308
        0x0020c194:    746f6d65    emot    DCD    1953459557
        0x0020c198:    65642065    e de    DCD    1701060709
        0x0020c19c:    65636976    vice    DCD    1701013878
        0x0020c1a0:    7375203a    : us    DCD    1937055802
        0x0020c1a4:    64612065    e ad    DCD    1684086885
        0x0020c1a8:    73657264    dres    DCD    1936028260
        0x0020c1ac:    200a0d73    s..     DCD    537529715
        0x0020c1b0:    20202020            DCD    538976288
        0x0020c1b4:    5b202020       [    DCD    1528832032
        0x0020c1b8:    5d304442    BD0]    DCD    1563444290
        0x0020c1bc:    44425b20     [BD    DCD    1145199392
        0x0020c1c0:    5b205d31    1] [    DCD    1528847665
        0x0020c1c4:    5d324442    BD2]    DCD    1563575362
        0x0020c1c8:    44425b20     [BD    DCD    1145199392
        0x0020c1cc:    5b205d33    3] [    DCD    1528847667
        0x0020c1d0:    5d344442    BD4]    DCD    1563706434
        0x0020c1d4:    44425b20     [BD    DCD    1145199392
        0x0020c1d8:    203a5d35    5]:     DCD    540695861
        0x0020c1dc:    6f6d6572    remo    DCD    1869440370
        0x0020c1e0:    64206574    te d    DCD    1679844724
        0x0020c1e4:    63697665    evic    DCD    1667855973
        0x0020c1e8:    64612065    e ad    DCD    1684086885
        0x0020c1ec:    73657264    dres    DCD    1936028260
        0x0020c1f0:    200a0d73    s..     DCD    537529715
        0x0020c1f4:    20202020            DCD    538976288
        0x0020c1f8:    5b202020       [    DCD    1528832032
        0x0020c1fc:    72646461    addr    DCD    1919181921
        0x0020c200:    7079745f    _typ    DCD    1887007839
        0x0020c204:    203a5d65    e]:     DCD    540695909
        0x0020c208:    70282d30    0-(p    DCD    1881681200
        0x0020c20c:    696c6275    ubli    DCD    1768710773
        0x0020c210:    202c2963    c),     DCD    539765091
        0x0020c214:    72282d31    1-(r    DCD    1915235633
        0x0020c218:    6f646e61    ando    DCD    1868852833
        0x0020c21c:    0a0d296d    m)..    DCD    168634733
        0x0020c220:    20202020            DCD    538976288
        0x0020c224:    20202020            DCD    538976288
        0x0020c228:    706d6173    samp    DCD    1886216563
        0x0020c22c:    203a656c    le:     DCD    540697964
        0x0020c230:    206e6f63    con     DCD    544108387
        0x0020c234:    20313178    x11     DCD    540094840
        0x0020c238:    20323278    x22     DCD    540160632
        0x0020c23c:    20333378    x33     DCD    540226424
        0x0020c240:    20343478    x44     DCD    540292216
        0x0020c244:    20353578    x55     DCD    540358008
        0x0020c248:    20363678    x66     DCD    540423800
        0x0020c24c:    0d0a2030    0 ..    DCD    218767408
        0x0020c250:    00000000    ....    DCD    0
        0x0020c254:    64616552    Read    DCD    1684104530
        0x0020c258:    74616220     bat    DCD    1952539168
        0x0020c25c:    79726574    tery    DCD    2037540212
        0x0020c260:    72657320     ser    DCD    1919251232
        0x0020c264:    65636976    vice    DCD    1701013878
        0x0020c268:    61686320     cha    DCD    1634231072
        0x0020c26c:    74636172    ract    DCD    1952670066
        0x0020c270:    73697265    eris    DCD    1936290405
        0x0020c274:    20636974    tic     DCD    543385972
        0x0020c278:    20646e61    and     DCD    543452769
        0x0020c27c:    63736564    desc    DCD    1668506980
        0x0020c280:    74706972    ript    DCD    1953524082
        0x0020c284:    7620726f    or v    DCD    1981837935
        0x0020c288:    65756c61    alue    DCD    1702194273
        0x0020c28c:    20200a0d    ..      DCD    538970637
        0x0020c290:    20202020            DCD    538976288
        0x0020c294:    745b2020      [t    DCD    1952129056
        0x0020c298:    5d657079    ype]    DCD    1566929017
        0x0020c29c:    2d30203a    : 0-    DCD    758128698
        0x0020c2a0:    74616228    (bat    DCD    1952539176
        0x0020c2a4:    79726574    tery    DCD    2037540212
        0x0020c2a8:    76656c20     lev    DCD    1986358304
        0x0020c2ac:    76206c65    el v    DCD    1981836389
        0x0020c2b0:    65756c61    alue    DCD    1702194273
        0x0020c2b4:    31202c29    ), 1    DCD    824192041
        0x0020c2b8:    6162282d    -(ba    DCD    1633822765
        0x0020c2bc:    72657474    tter    DCD    1919251572
        0x0020c2c0:    63632079    y cc    DCD    1667440761
        0x0020c2c4:    0d296463    cd).    DCD    220816483
        0x0020c2c8:    2020200a    .       DCD    538976266
        0x0020c2cc:    20202020            DCD    538976288
        0x0020c2d0:    6d617320     sam    DCD    1835103008
        0x0020c2d4:    3a656c70    ple:    DCD    979725424
        0x0020c2d8:    73616220     bas    DCD    1935761952
        0x0020c2dc:    64616572    read    DCD    1684104562
        0x0020c2e0:    31203020     0 1    DCD    824193056
        0x0020c2e4:    000d0a20     ...    DCD    854560
        0x0020c2e8:    666e6f43    Conf    DCD    1718513475
        0x0020c2ec:    62206769    ig b    DCD    1646290793
        0x0020c2f0:    65747461    atte    DCD    1702130785
        0x0020c2f4:    73207972    ry s    DCD    1931508082
        0x0020c2f8:    69767265    ervi    DCD    1769370213
        0x0020c2fc:    63206563    ce c    DCD    1663067491
        0x0020c300:    6e65696c    lien    DCD    1852139884
        0x0020c304:    68632074    t ch    DCD    1751326836
        0x0020c308:    63617261    arac    DCD    1667330657
        0x0020c30c:    69726574    teri    DCD    1769104756
        0x0020c310:    63697473    stic    DCD    1667855475
        0x0020c314:    6e6f6320     con    DCD    1852793632
        0x0020c318:    75676966    figu    DCD    1969711462
        0x0020c31c:    69746172    rati    DCD    1769234802
        0x0020c320:    64206e6f    on d    DCD    1679847023
        0x0020c324:    72637365    escr    DCD    1919120229
        0x0020c328:    6f747069    ipto    DCD    1869901929
        0x0020c32c:    61762072    r va    DCD    1635131506
        0x0020c330:    0d65756c    lue.    DCD    224753004
        0x0020c334:    2020200a    .       DCD    538976266
        0x0020c338:    20202020            DCD    538976288
        0x0020c33c:    6f6e5b20     [no    DCD    1869503264
        0x0020c340:    79666974    tify    DCD    2036754804
        0x0020c344:    30203a5d    ]: 0    DCD    807418461
        0x0020c348:    6964282d    -(di    DCD    1768171565
        0x0020c34c:    6c626173    sabl    DCD    1818386803
        0x0020c350:    202c2965    e),     DCD    539765093
        0x0020c354:    65282d31    1-(e    DCD    1697131825
        0x0020c358:    6c62616e    nabl    DCD    1818386798
        0x0020c35c:    0d0a2965    e)..    DCD    218769765
        0x0020c360:    00000000    ....    DCD    0
        0x0020c364:    64616552    Read    DCD    1684104530
        0x0020c368:    50414720     GAP    DCD    1346455328
        0x0020c36c:    72657320     ser    DCD    1919251232
        0x0020c370:    65636976    vice    DCD    1701013878
        0x0020c374:    61686320     cha    DCD    1634231072
        0x0020c378:    74636172    ract    DCD    1952670066
        0x0020c37c:    73697265    eris    DCD    1936290405
        0x0020c380:    20636974    tic     DCD    543385972
        0x0020c384:    756c6176    valu    DCD    1970037110
        0x0020c388:    200a0d65    e..     DCD    537529701
        0x0020c38c:    20202020            DCD    538976288
        0x0020c390:    5b202020       [    DCD    1528832032
        0x0020c394:    65707974    type    DCD    1701869940
        0x0020c398:    30203a5d    ]: 0    DCD    807418461
        0x0020c39c:    6572282d    -(re    DCD    1701980205
        0x0020c3a0:    64206461    ad d    DCD    1679844449
        0x0020c3a4:    63697665    evic    DCD    1667855973
        0x0020c3a8:    616e2065    e na    DCD    1634607205
        0x0020c3ac:    2c29656d    me),    DCD    740910445
        0x0020c3b0:    282d3120     1-(    DCD    674050336
        0x0020c3b4:    64616572    read    DCD    1684104562
        0x0020c3b8:    70706120     app    DCD    1886413088
        0x0020c3bc:    61726165    eara    DCD    1634885989
        0x0020c3c0:    2965636e    nce)    DCD    694510446
        0x0020c3c4:    20200a0d    ..      DCD    538970637
        0x0020c3c8:    20202020            DCD    538976288
        0x0020c3cc:    69732020      si    DCD    1769152544
        0x0020c3d0:    656c706d    mple    DCD    1701605485
        0x0020c3d4:    6167203a    : ga    DCD    1634148410
        0x0020c3d8:    61657270    prea    DCD    1634038384
        0x0020c3dc:    20302064    d 0     DCD    540024932
        0x0020c3e0:    000d0a30    0...    DCD    854576
        0x0020c3e4:    666e6f43    Conf    DCD    1718513475
        0x0020c3e8:    61206769    ig a    DCD    1629513577
        0x0020c3ec:    65687475    uthe    DCD    1701344373
        0x0020c3f0:    6369746e    ntic    DCD    1667855470
        0x0020c3f4:    6f697461    atio    DCD    1869182049
        0x0020c3f8:    6f6d206e    n mo    DCD    1869422702
        0x0020c3fc:    0a0d6564    de..    DCD    168650084
        0x0020c400:    20202020            DCD    538976288
        0x0020c404:    20202020            DCD    538976288
        0x0020c408:    7475615b    [aut    DCD    1953849691
        0x0020c40c:    6c665f68    h_fl    DCD    1818648424
        0x0020c410:    5d736761    ags]    DCD    1567844193
        0x0020c414:    7475613a    :aut    DCD    1953849658
        0x0020c418:    746e6568    hent    DCD    1953391976
        0x0020c41c:    74616369    icat    DCD    1952539497
        0x0020c420:    206e6f69    ion     DCD    544108393
        0x0020c424:    20716572    req     DCD    544302450
        0x0020c428:    20746962    bit     DCD    544500066
        0x0020c42c:    6c656966    fiel    DCD    1818585446
        0x0020c430:    62203a64    d: b    DCD    1646279268
        0x0020c434:    2d307469    it0-    DCD    758150249
        0x0020c438:    6e6f6228    (bon    DCD    1852793384
        0x0020c43c:    676e6964    ding    DCD    1735289188
        0x0020c440:    62202c29    ), b    DCD    1646275625
        0x0020c444:    2d327469    it2-    DCD    758281321
        0x0020c448:    54494d28    (MIT    DCD    1414090024
        0x0020c44c:    202c294d    M),     DCD    539765069
        0x0020c450:    33746962    bit3    DCD    863267170
        0x0020c454:    4353282d    -(SC    DCD    1129523245
        0x0020c458:    200a0d29    )..     DCD    537529641
        0x0020c45c:    20202020            DCD    538976288
        0x0020c460:    5b202020       [    DCD    1528832032
        0x0020c464:    635f6f69    io_c    DCD    1667198825
        0x0020c468:    3a5d7061    ap]:    DCD    979202145
        0x0020c46c:    20746573    set     DCD    544499059
        0x0020c470:    43206f69    io C    DCD    1126199145
        0x0020c474:    62617061    apab    DCD    1650552929
        0x0020c478:    74696c69    ilit    DCD    1953066089
        0x0020c47c:    3a736569    ies:    DCD    980641129
        0x0020c480:    282d3020     0-(    DCD    674050080
        0x0020c484:    70736964    disp    DCD    1886611812
        0x0020c488:    2079616c    lay     DCD    544825708
        0x0020c48c:    796c6e6f    only    DCD    2037149295
        0x0020c490:    31202c29    ), 1    DCD    824192041
        0x0020c494:    6964282d    -(di    DCD    1768171565
        0x0020c498:    616c7073    spla    DCD    1634496627
        0x0020c49c:    65792079    y ye    DCD    1702436985
        0x0020c4a0:    6f6e2f73    s/no    DCD    1869492083
        0x0020c4a4:    32202c29    ), 2    DCD    840969257
        0x0020c4a8:    656b282d    -(ke    DCD    1701521453
        0x0020c4ac:    616f6279    yboa    DCD    1634689657
        0x0020c4b0:    6e206472    rd n    DCD    1847616626
        0x0020c4b4:    29796c6f    oly)    DCD    695823471
        0x0020c4b8:    2d33202c    , 3-    DCD    758325292
        0x0020c4bc:    206f6e28    (no     DCD    544173608
        0x0020c4c0:    2c294f49    IO),    DCD    740904777
        0x0020c4c4:    282d3420     4-(    DCD    674051104
        0x0020c4c8:    6279656b    keyb    DCD    1652122987
        0x0020c4cc:    6472616f    oard    DCD    1685217647
        0x0020c4d0:    73696420     dis    DCD    1936286752
        0x0020c4d4:    79616c70    play    DCD    2036427888
        0x0020c4d8:    200a0d29    )..     DCD    537529641
        0x0020c4dc:    20202020            DCD    538976288
        0x0020c4e0:    5b202020       [    DCD    1528832032
        0x0020c4e4:    5f636573    sec_    DCD    1600349555
        0x0020c4e8:    62616e65    enab    DCD    1650552421
        0x0020c4ec:    3a5d656c    le]:    DCD    979199340
        0x0020c4f0:    72617453    Star    DCD    1918989395
        0x0020c4f4:    6d732074    t sm    DCD    1836261492
        0x0020c4f8:    61702070    p pa    DCD    1634738288
        0x0020c4fc:    6e697269    irin    DCD    1852404329
        0x0020c500:    72702067    g pr    DCD    1919950951
        0x0020c504:    6465636f    oced    DCD    1684366191
        0x0020c508:    20657275    ure     DCD    543519349
        0x0020c50c:    6e656877    when    DCD    1852139639
        0x0020c510:    6e6f6320     con    DCD    1852793632
        0x0020c514:    7463656e    nect    DCD    1952671086
        0x0020c518:    203a6465    ed:     DCD    540697701
        0x0020c51c:    64282d30    0-(d    DCD    1680354608
        0x0020c520:    62617369    isab    DCD    1650553705
        0x0020c524:    2c29656c    le),    DCD    740910444
        0x0020c528:    282d3120     1-(    DCD    674050336
        0x0020c52c:    62616e65    enab    DCD    1650552421
        0x0020c530:    0d29656c    le).    DCD    220816748
        0x0020c534:    2020200a    .       DCD    538976266
        0x0020c538:    20202020            DCD    538976288
        0x0020c53c:    6f6f5b20     [oo    DCD    1869568800
        0x0020c540:    6e655f62    b_en    DCD    1852137314
        0x0020c544:    656c6261    able    DCD    1701601889
        0x0020c548:    6e453a5d    ]:En    DCD    1850030685
        0x0020c54c:    656c6261    able    DCD    1701601889
        0x0020c550:    626f6f20     oob    DCD    1651470112
        0x0020c554:    616c6620     fla    DCD    1634493984
        0x0020c558:    30203a67    g: 0    DCD    807418471
        0x0020c55c:    6964282d    -(di    DCD    1768171565
        0x0020c560:    6c626173    sabl    DCD    1818386803
        0x0020c564:    202c2965    e),     DCD    539765093
        0x0020c568:    65282d31    1-(e    DCD    1697131825
        0x0020c56c:    6c62616e    nabl    DCD    1818386798
        0x0020c570:    0a0d2965    e)..    DCD    168634725
        0x0020c574:    20202020            DCD    538976288
        0x0020c578:    20202020            DCD    538976288
        0x0020c57c:    706d6173    samp    DCD    1886216563
        0x0020c580:    203a656c    le:     DCD    540697964
        0x0020c584:    68747561    auth    DCD    1752462689
        0x0020c588:    65646f6d    mode    DCD    1701080941
        0x0020c58c:    35783020     0x5    DCD    897069088
        0x0020c590:    31203220     2 1    DCD    824193568
        0x0020c594:    0d0a3020     0..    DCD    218771488
        0x0020c598:    00000000    ....    DCD    0
        0x0020c59c:    6e6e6f43    Conn    DCD    1852731203
        0x0020c5a0:    20746365    ect     DCD    544498533
        0x0020c5a4:    72206f74    to r    DCD    1914728308
        0x0020c5a8:    746f6d65    emot    DCD    1953459557
        0x0020c5ac:    65642065    e de    DCD    1701060709
        0x0020c5b0:    65636976    vice    DCD    1701013878
        0x0020c5b4:    7375203a    : us    DCD    1937055802
        0x0020c5b8:    68732065    e sh    DCD    1752375397
        0x0020c5bc:    6564776f    owde    DCD    1701082991
        0x0020c5c0:    6f742076    v to    DCD    1869881462
        0x0020c5c4:    6f687320     sho    DCD    1869116192
        0x0020c5c8:    64692077    w id    DCD    1684611191
        0x0020c5cc:    200a0d78    x..     DCD    537529720
        0x0020c5d0:    20202020            DCD    538976288
        0x0020c5d4:    5b202020       [    DCD    1528832032
        0x0020c5d8:    5d786469    idx]    DCD    1568171113
        0x0020c5dc:    7375203a    : us    DCD    1937055802
        0x0020c5e0:    6d632065    e cm    DCD    1835212901
        0x0020c5e4:    68732064    d sh    DCD    1752375396
        0x0020c5e8:    6564776f    owde    DCD    1701082991
        0x0020c5ec:    6f742076    v to    DCD    1869881462
        0x0020c5f0:    6f687320     sho    DCD    1869116192
        0x0020c5f4:    64692077    w id    DCD    1684611191
        0x0020c5f8:    65622078    x be    DCD    1700929656
        0x0020c5fc:    65726f66    fore    DCD    1701998438
        0x0020c600:    65737520     use    DCD    1702065440
        0x0020c604:    69687420     thi    DCD    1768453152
        0x0020c608:    6d632073    s cm    DCD    1835212915
        0x0020c60c:    200a0d64    d..     DCD    537529700
        0x0020c610:    20202020            DCD    538976288
        0x0020c614:    73202020       s    DCD    1931485216
        0x0020c618:    6c706d61    ampl    DCD    1819307361
        0x0020c61c:    63203a65    e: c    DCD    1663056485
        0x0020c620:    65646e6f    onde    DCD    1701080687
        0x0020c624:    0a302076    v 0.    DCD    170926198
        0x0020c628:    0000000d    ....    DCD    13
        0x0020c62c:    6320454c    LE c    DCD    1663059276
        0x0020c630:    656e6e6f    onne    DCD    1701736047
        0x0020c634:    6f697463    ctio    DCD    1869182051
        0x0020c638:    6170206e    n pa    DCD    1634738286
        0x0020c63c:    206d6172    ram     DCD    544039282
        0x0020c640:    61647075    upda    DCD    1633972341
        0x0020c644:    72206574    te r    DCD    1914725748
        0x0020c648:    65757165    eque    DCD    1702195557
        0x0020c64c:    0a0d7473    st..    DCD    168653939
        0x0020c650:    20202020            DCD    538976288
        0x0020c654:    20202020            DCD    538976288
        0x0020c658:    706d6173    samp    DCD    1886216563
        0x0020c65c:    203a656c    le:     DCD    540697964
        0x0020c660:    756e6f63    conu    DCD    1970171747
        0x0020c664:    65726470    pdre    DCD    1701995632
        0x0020c668:    20302071    q 0     DCD    540024945
        0x0020c66c:    30337830    0x30    DCD    808679472
        0x0020c670:    34783020     0x4    DCD    880291872
        0x0020c674:    20302030    0 0     DCD    540024880
        0x0020c678:    0a303035    500.    DCD    170930229
        0x0020c67c:    0000000d    ....    DCD    13
        0x0020c680:    74697257    Writ    DCD    1953067607
        0x0020c684:    69732065    e si    DCD    1769152613
        0x0020c688:    656c706d    mple    DCD    1701605485
        0x0020c68c:    656c6220     ble    DCD    1701601824
        0x0020c690:    72657320     ser    DCD    1919251232
        0x0020c694:    65636976    vice    DCD    1701013878
        0x0020c698:    20325620     V2     DCD    540169760
        0x0020c69c:    72616863    char    DCD    1918986339
        0x0020c6a0:    65746361    acte    DCD    1702126433
        0x0020c6a4:    74736972    rist    DCD    1953720690
        0x0020c6a8:    76206369    ic v    DCD    1981834089
        0x0020c6ac:    65756c61    alue    DCD    1702194273
        0x0020c6b0:    20200a0d    ..      DCD    538970637
        0x0020c6b4:    20202020            DCD    538976288
        0x0020c6b8:    745b2020      [t    DCD    1952129056
        0x0020c6bc:    5d657079    ype]    DCD    1566929017
        0x0020c6c0:    2d31203a    : 1-    DCD    758194234
        0x0020c6c4:    69727728    (wri    DCD    1769109288
        0x0020c6c8:    72206574    te r    DCD    1914725748
        0x0020c6cc:    65757165    eque    DCD    1702195557
        0x0020c6d0:    2c297473    st),    DCD    740914291
        0x0020c6d4:    282d3220     2-(    DCD    674050592
        0x0020c6d8:    74697277    writ    DCD    1953067639
        0x0020c6dc:    6f632065    e co    DCD    1868767333
        0x0020c6e0:    6e616d6d    mman    DCD    1851878765
        0x0020c6e4:    0d202964    d) .    DCD    220211556
        0x0020c6e8:    2020200a    .       DCD    538976266
        0x0020c6ec:    20202020            DCD    538976288
        0x0020c6f0:    656c5b20     [le    DCD    1701600032
        0x0020c6f4:    203a5d6e    n]:     DCD    540695918
        0x0020c6f8:    65707974    type    DCD    1701869940
        0x0020c6fc:    6c20313d    =1 l    DCD    1814049085
        0x0020c700:    72206e65    en r    DCD    1914728037
        0x0020c704:    65676e61    ange    DCD    1701277281
        0x0020c708:    322d303a    :0-2    DCD    841822266
        0x0020c70c:    202c3037    70,     DCD    539766839
        0x0020c710:    65707974    type    DCD    1701869940
        0x0020c714:    6c20323d    =2 l    DCD    1814049341
        0x0020c718:    72206e65    en r    DCD    1914728037
        0x0020c71c:    65676e61    ange    DCD    1701277281
        0x0020c720:    2d30203a    : 0-    DCD    758128698
        0x0020c724:    75746d28    (mtu    DCD    1970564392
        0x0020c728:    0d29332d    -3).    DCD    220803885
        0x0020c72c:    2020200a    .       DCD    538976266
        0x0020c730:    20202020            DCD    538976288
        0x0020c734:    6d617320     sam    DCD    1835103008
        0x0020c738:    3a656c70    ple:    DCD    979725424
        0x0020c73c:    6d697320     sim    DCD    1835627296
        0x0020c740:    69727770    pwri    DCD    1769109360
        0x0020c744:    32766574    tev2    DCD    846620020
        0x0020c748:    31203020     0 1    DCD    824193056
        0x0020c74c:    0a303120     10.    DCD    170930464
        0x0020c750:    0000000d    ....    DCD    13
        0x0020c754:    646e6553    Send    DCD    1684956499
        0x0020c758:    65737520     use    DCD    1702065440
        0x0020c75c:    6f632072    r co    DCD    1868767346
        0x0020c760:    7269666e    nfir    DCD    1919510126
        0x0020c764:    6974616d    mati    DCD    1769234797
        0x0020c768:    77206e6f    on w    DCD    1998614127
        0x0020c76c:    206e6568    hen     DCD    544105832
        0x0020c770:    776f6873    show    DCD    2003789939
        0x0020c774:    50414720     GAP    DCD    1346455328
        0x0020c778:    47534d5f    _MSG    DCD    1196641631
        0x0020c77c:    5f454c5f    _LE_    DCD    1598377055
        0x0020c780:    444e4f42    BOND    DCD    1145982786
        0x0020c784:    4553555f    _USE    DCD    1163089247
        0x0020c788:    4f435f52    R_CO    DCD    1329815378
        0x0020c78c:    5249464e    NFIR    DCD    1380533838
        0x0020c790:    4954414d    MATI    DCD    1230258509
        0x0020c794:    0a0d4e4f    ON..    DCD    168644175
        0x0020c798:    20202020            DCD    538976288
        0x0020c79c:    20202020            DCD    538976288
        0x0020c7a0:    6e6f635b    [con    DCD    1852793691
        0x0020c7a4:    203a5d66    f]:     DCD    540695910
        0x0020c7a8:    52282d30    0-(R    DCD    1378364720
        0x0020c7ac:    63656a65    ejec    DCD    1667590757
        0x0020c7b0:    202c2974    t),     DCD    539765108
        0x0020c7b4:    41282d31    1-(A    DCD    1093152049
        0x0020c7b8:    70656363    ccep    DCD    1885692771
        0x0020c7bc:    0a0d2974    t)..    DCD    168634740
        0x0020c7c0:    20202020            DCD    538976288
        0x0020c7c4:    20202020            DCD    538976288
        0x0020c7c8:    706d6173    samp    DCD    1886216563
        0x0020c7cc:    203a656c    le:     DCD    540697964
        0x0020c7d0:    72657375    user    DCD    1919251317
        0x0020c7d4:    666e6f63    conf    DCD    1718513507
        0x0020c7d8:    31203020     0 1    DCD    824193056
        0x0020c7dc:    00000d0a    ....    DCD    3338
        0x0020c7e0:    666e6f43    Conf    DCD    1718513475
        0x0020c7e4:    73206769    ig s    DCD    1931503465
        0x0020c7e8:    6c706d69    impl    DCD    1819307369
        0x0020c7ec:    6c622065    e bl    DCD    1818370149
        0x0020c7f0:    65732065    e se    DCD    1702043749
        0x0020c7f4:    63697672    rvic    DCD    1667855986
        0x0020c7f8:    6c632065    e cl    DCD    1818435685
        0x0020c7fc:    746e6569    ient    DCD    1953391977
        0x0020c800:    61686320     cha    DCD    1634231072
        0x0020c804:    74636172    ract    DCD    1952670066
        0x0020c808:    73697265    eris    DCD    1936290405
        0x0020c80c:    20636974    tic     DCD    543385972
        0x0020c810:    666e6f63    conf    DCD    1718513507
        0x0020c814:    72756769    igur    DCD    1920296809
        0x0020c818:    6f697461    atio    DCD    1869182049
        0x0020c81c:    6564206e    n de    DCD    1701060718
        0x0020c820:    69726373    scri    DCD    1769104243
        0x0020c824:    726f7470    ptor    DCD    1919906928
        0x0020c828:    6c617620     val    DCD    1818326560
        0x0020c82c:    0a0d6575    ue..    DCD    168650101
        0x0020c830:    20202020            DCD    538976288
        0x0020c834:    20202020            DCD    538976288
        0x0020c838:    7079745b    [typ    DCD    1887007835
        0x0020c83c:    203a5d65    e]:     DCD    540695909
        0x0020c840:    76282d30    0-(v    DCD    1982344496
        0x0020c844:    6f6e2033    3 no    DCD    1869488179
        0x0020c848:    79666974    tify    DCD    2036754804
        0x0020c84c:    31202c29    ), 1    DCD    824192041
        0x0020c850:    3476282d    -(v4    DCD    880158765
        0x0020c854:    646e6920     ind    DCD    1684957472
        0x0020c858:    74616369    icat    DCD    1952539497
        0x0020c85c:    296e6f69    ion)    DCD    695103337
        0x0020c860:    20200a0d    ..      DCD    538970637
        0x0020c864:    20202020            DCD    538976288
        0x0020c868:    655b2020      [e    DCD    1700470816
        0x0020c86c:    6c62616e    nabl    DCD    1818386798
        0x0020c870:    203a5d65    e]:     DCD    540695909
        0x0020c874:    64282d30    0-(d    DCD    1680354608
        0x0020c878:    62617369    isab    DCD    1650553705
        0x0020c87c:    2c29656c    le),    DCD    740910444
        0x0020c880:    282d3120     1-(    DCD    674050336
        0x0020c884:    62616e65    enab    DCD    1650552421
        0x0020c888:    2029656c    le)     DCD    539583852
        0x0020c88c:    20200a0d    ..      DCD    538970637
        0x0020c890:    20202020            DCD    538976288
        0x0020c894:    61732020      sa    DCD    1634934816
        0x0020c898:    656c706d    mple    DCD    1701605485
        0x0020c89c:    6973203a    : si    DCD    1769152570
        0x0020c8a0:    6363706d    mpcc    DCD    1667461229
        0x0020c8a4:    30206463    cd 0    DCD    807429219
        0x0020c8a8:    31203120     1 1    DCD    824193312
        0x0020c8ac:    00000d0a    ....    DCD    3338
        0x0020c8b0:    75706e49    Inpu    DCD    1970302537
        0x0020c8b4:    61702074    t pa    DCD    1634738292
        0x0020c8b8:    656b7373    sske    DCD    1701540723
        0x0020c8bc:    68772079    y wh    DCD    1752637561
        0x0020c8c0:    73206e65    en s    DCD    1931505253
        0x0020c8c4:    20776f68    how     DCD    544698216
        0x0020c8c8:    5f504147    GAP_    DCD    1599095111
        0x0020c8cc:    5f47534d    MSG_    DCD    1598509901
        0x0020c8d0:    425f454c    LE_B    DCD    1113539916
        0x0020c8d4:    5f444e4f    OND_    DCD    1598312015
        0x0020c8d8:    53534150    PASS    DCD    1397965136
        0x0020c8dc:    5f59454b    KEY_    DCD    1599685963
        0x0020c8e0:    55504e49    INPU    DCD    1431326281
        0x0020c8e4:    200a0d54    T..     DCD    537529684
        0x0020c8e8:    20202020            DCD    538976288
        0x0020c8ec:    5b202020       [    DCD    1528832032
        0x0020c8f0:    73736170    pass    DCD    1936941424
        0x0020c8f4:    5d79656b    key]    DCD    1568236907
        0x0020c8f8:    2030203a    : 0     DCD    540024890
        0x0020c8fc:    3939202d    - 99    DCD    960045101
        0x0020c900:    39393939    9999    DCD    960051513
        0x0020c904:    20200a0d    ..      DCD    538970637
        0x0020c908:    20202020            DCD    538976288
        0x0020c90c:    61732020      sa    DCD    1634934816
        0x0020c910:    656c706d    mple    DCD    1701605485
        0x0020c914:    7561203a    : au    DCD    1969299514
        0x0020c918:    656b6874    thke    DCD    1701537908
        0x0020c91c:    20302079    y 0     DCD    540024953
        0x0020c920:    34333231    1234    DCD    875770417
        0x0020c924:    0d0a3635    56..    DCD    218773045
        0x0020c928:    00000000    ....    DCD    0
        0x0020c92c:    63736964    disc    DCD    1668508004
        0x0020c930:    6f635b20     [co    DCD    1868782368
        0x0020c934:    695f6e6e    nn_i    DCD    1767861870
        0x0020c938:    0d0a5d64    d]..    DCD    218783076
        0x0020c93c:    00000000    ....    DCD    0
        0x0020c940:    74756173    saut    DCD    1953849715
        0x0020c944:    635b2068    h [c    DCD    1666916456
        0x0020c948:    5f6e6e6f    onn_    DCD    1601072751
        0x0020c94c:    0a5d6469    id].    DCD    173892713
        0x0020c950:    0000000d    ....    DCD    13
        0x0020c954:    68706167    gaph    DCD    1752195431
        0x0020c958:    5b206c64    dl [    DCD    1528851556
        0x0020c95c:    6e6e6f63    conn    DCD    1852731235
        0x0020c960:    5d64695f    _id]    DCD    1566861663
        0x0020c964:    00000d0a    ....    DCD    3338
        0x0020c968:    706d6973    simp    DCD    1886218611
        0x0020c96c:    206c6468    hdl     DCD    543974504
        0x0020c970:    6e6f635b    [con    DCD    1852793691
        0x0020c974:    64695f6e    n_id    DCD    1684627310
        0x0020c978:    000d0a5d    ]...    DCD    854621
        0x0020c97c:    68736162    bash    DCD    1752392034
        0x0020c980:    5b206c64    dl [    DCD    1528851556
        0x0020c984:    6e6e6f63    conn    DCD    1852731235
        0x0020c988:    5d64695f    _id]    DCD    1566861663
        0x0020c98c:    00000d0a    ....    DCD    3338
        0x0020c990:    646e6f62    bond    DCD    1684959074
        0x0020c994:    206c6564    del     DCD    543974756
        0x0020c998:    6e6f635b    [con    DCD    1852793691
        0x0020c99c:    64695f6e    n_id    DCD    1684627310
        0x0020c9a0:    000d0a5d    ]...    DCD    854621
        0x0020c9a4:    706d6973    simp    DCD    1886218611
        0x0020c9a8:    64636363    cccd    DCD    1684235107
        0x0020c9ac:    6f635b20     [co    DCD    1868782368
        0x0020c9b0:    695f6e6e    nn_i    DCD    1767861870
        0x0020c9b4:    5b205d64    d] [    DCD    1528847716
        0x0020c9b8:    65707974    type    DCD    1701869940
        0x0020c9bc:    655b205d    ] [e    DCD    1700470877
        0x0020c9c0:    6c62616e    nabl    DCD    1818386798
        0x0020c9c4:    0d0a5d65    e]..    DCD    218783077
        0x0020c9c8:    00000000    ....    DCD    0
        0x0020c9cc:    68747561    auth    DCD    1752462689
        0x0020c9d0:    65646f6d    mode    DCD    1701080941
        0x0020c9d4:    75615b20     [au    DCD    1969314592
        0x0020c9d8:    665f6874    th_f    DCD    1717528692
        0x0020c9dc:    7367616c    lags    DCD    1936154988
        0x0020c9e0:    695b205d    ] [i    DCD    1767579741
        0x0020c9e4:    61635f6f    o_ca    DCD    1633902447
        0x0020c9e8:    5b205d70    p] [    DCD    1528847728
        0x0020c9ec:    5f636573    sec_    DCD    1600349555
        0x0020c9f0:    62616e65    enab    DCD    1650552421
        0x0020c9f4:    205d656c    le]     DCD    542991724
        0x0020c9f8:    626f6f5b    [oob    DCD    1651470171
        0x0020c9fc:    616e655f    _ena    DCD    1634624863
        0x0020ca00:    5d656c62    ble]    DCD    1566927970
        0x0020ca04:    00000d0a    ....    DCD    3338
        0x0020ca08:    72706167    gapr    DCD    1919967591
        0x0020ca0c:    20646165    ead     DCD    543449445
        0x0020ca10:    6e6f635b    [con    DCD    1852793691
        0x0020ca14:    64695f6e    n_id    DCD    1684627310
        0x0020ca18:    745b205d    ] [t    DCD    1952129117
        0x0020ca1c:    5d657079    ype]    DCD    1566929017
        0x0020ca20:    00000d0a    ....    DCD    3338
        0x0020ca24:    72736162    basr    DCD    1920164194
        0x0020ca28:    20646165    ead     DCD    543449445
        0x0020ca2c:    6e6f635b    [con    DCD    1852793691
        0x0020ca30:    64695f6e    n_id    DCD    1684627310
        0x0020ca34:    745b205d    ] [t    DCD    1952129117
        0x0020ca38:    5d657079    ype]    DCD    1566929017
        0x0020ca3c:    00000d0a    ....    DCD    3338
        0x0020ca40:    206e6f63    con     DCD    544108387
        0x0020ca44:    3044425b    [BD0    DCD    809779803
        0x0020ca48:    425b205d    ] [B    DCD    1113268317
        0x0020ca4c:    205d3144    D1]     DCD    542978372
        0x0020ca50:    3244425b    [BD2    DCD    843334235
        0x0020ca54:    425b205d    ] [B    DCD    1113268317
        0x0020ca58:    205d3344    D3]     DCD    542978884
        0x0020ca5c:    3444425b    [BD4    DCD    876888667
        0x0020ca60:    425b205d    ] [B    DCD    1113268317
        0x0020ca64:    205d3544    D5]     DCD    542979396
        0x0020ca68:    6464615b    [add    DCD    1684300123
        0x0020ca6c:    79745f72    r_ty    DCD    2037669746
        0x0020ca70:    0a5d6570    pe].    DCD    173892976
        0x0020ca74:    0000000d    ....    DCD    13
        0x0020ca78:    6e616373    scan    DCD    1851876211
        0x0020ca7c:    69665b20     [fi    DCD    1768315680
        0x0020ca80:    7265746c    lter    DCD    1919251564
        0x0020ca84:    6c6f705f    _pol    DCD    1819242591
        0x0020ca88:    5d796369    icy]    DCD    1568236393
        0x0020ca8c:    69665b20     [fi    DCD    1768315680
        0x0020ca90:    7265746c    lter    DCD    1919251564
        0x0020ca94:    7075645f    _dup    DCD    1886741599
        0x0020ca98:    6163696c    lica    DCD    1633905004
        0x0020ca9c:    0a5d6574    te].    DCD    173892980
        0x0020caa0:    0000000d    ....    DCD    13
        0x0020caa4:    72657375    user    DCD    1919251317
        0x0020caa8:    666e6f63    conf    DCD    1718513507
        0x0020caac:    6f635b20     [co    DCD    1868782368
        0x0020cab0:    695f6e6e    nn_i    DCD    1767861870
        0x0020cab4:    5b205d64    d] [    DCD    1528847716
        0x0020cab8:    666e6f63    conf    DCD    1718513507
        0x0020cabc:    000d0a5d    ]...    DCD    854621
        0x0020cac0:    706d6973    simp    DCD    1886218611
        0x0020cac4:    74697277    writ    DCD    1953067639
        0x0020cac8:    20327665    ev2     DCD    540178021
        0x0020cacc:    6e6f635b    [con    DCD    1852793691
        0x0020cad0:    64695f6e    n_id    DCD    1684627310
        0x0020cad4:    745b205d    ] [t    DCD    1952129117
        0x0020cad8:    5d657079    ype]    DCD    1566929017
        0x0020cadc:    656c5b20     [le    DCD    1701600032
        0x0020cae0:    0d0a5d6e    n]..    DCD    218783086
        0x0020cae4:    00000000    ....    DCD    0
        0x0020cae8:    706d6973    simp    DCD    1886218611
        0x0020caec:    64616572    read    DCD    1684104562
        0x0020caf0:    6f635b20     [co    DCD    1868782368
        0x0020caf4:    695f6e6e    nn_i    DCD    1767861870
        0x0020caf8:    5b205d64    d] [    DCD    1528847716
        0x0020cafc:    65707974    type    DCD    1701869940
        0x0020cb00:    705b205d    ] [p    DCD    1885020253
        0x0020cb04:    65747461    atte    DCD    1702130785
        0x0020cb08:    0a5d6e72    rn].    DCD    173895282
        0x0020cb0c:    0000000d    ....    DCD    13
        0x0020cb10:    756e6f63    conu    DCD    1970171747
        0x0020cb14:    65726470    pdre    DCD    1701995632
        0x0020cb18:    635b2071    q [c    DCD    1666916465
        0x0020cb1c:    5f6e6e6f    onn_    DCD    1601072751
        0x0020cb20:    205d6469    id]     DCD    542991465
        0x0020cb24:    746e695b    [int    DCD    1953392987
        0x0020cb28:    61767265    erva    DCD    1635152485
        0x0020cb2c:    696d5f6c    l_mi    DCD    1768775532
        0x0020cb30:    5b205d6e    n] [    DCD    1528847726
        0x0020cb34:    65746e69    inte    DCD    1702129257
        0x0020cb38:    6c617672    rval    DCD    1818326642
        0x0020cb3c:    78616d5f    _max    DCD    2019650911
        0x0020cb40:    6c5b205d    ] [l    DCD    1817911389
        0x0020cb44:    6e657461    aten    DCD    1852142689
        0x0020cb48:    205d7963    cy]     DCD    542996835
        0x0020cb4c:    7075735b    [sup    DCD    1886745435
        0x0020cb50:    69767265    ervi    DCD    1769370213
        0x0020cb54:    6e6f6973    sion    DCD    1852795251
        0x0020cb58:    6d69745f    _tim    DCD    1835627615
        0x0020cb5c:    74756f65    eout    DCD    1953853285
        0x0020cb60:    000d0a5d    ]...    DCD    854621
        0x0020cb64:    646e6f63    cond    DCD    1684959075
        0x0020cb68:    5b207665    ev [    DCD    1528854117
        0x0020cb6c:    5d786469    idx]    DCD    1568171113
        0x0020cb70:    00000d0a    ....    DCD    3338
        0x0020cb74:    68747561    auth    DCD    1752462689
        0x0020cb78:    2079656b    key     DCD    544826731
        0x0020cb7c:    6e6f635b    [con    DCD    1852793691
        0x0020cb80:    64695f6e    n_id    DCD    1684627310
        0x0020cb84:    705b205d    ] [p    DCD    1885020253
        0x0020cb88:    6b737361    assk    DCD    1802728289
        0x0020cb8c:    0a5d7965    ey].    DCD    173898085
        0x0020cb90:    0000000d    ....    DCD    13
        0x0020cb94:    63736162    basc    DCD    1668505954
        0x0020cb98:    20646363    ccd     DCD    543449955
        0x0020cb9c:    6e6f635b    [con    DCD    1852793691
        0x0020cba0:    64695f6e    n_id    DCD    1684627310
        0x0020cba4:    6e5b205d    ] [n    DCD    1851465821
        0x0020cba8:    6669746f    otif    DCD    1718187119
        0x0020cbac:    0d0a5d79    y]..    DCD    218783097
        0x0020cbb0:    00000000    ....    DCD    0
        0x0020cbb4:    61656c43    Clea    DCD    1634036803
        0x0020cbb8:    6f622072    r bo    DCD    1868701810
        0x0020cbbc:    6465646e    nded    DCD    1684366446
        0x0020cbc0:    76656420     dev    DCD    1986356256
        0x0020cbc4:    73656369    ices    DCD    1936024425
        0x0020cbc8:    666e6920     inf    DCD    1718511904
        0x0020cbcc:    616d726f    orma    DCD    1634562671
        0x0020cbd0:    6e6f6974    tion    DCD    1852795252
        0x0020cbd4:    20796220     by     DCD    544825888
        0x0020cbd8:    6e6e6f63    conn    DCD    1852731235
        0x0020cbdc:    20746365    ect     DCD    544498533
        0x0020cbe0:    0d0a6469    id..    DCD    218784873
        0x0020cbe4:    00000000    ....    DCD    0
        0x0020cbe8:    63736944    Disc    DCD    1668507972
        0x0020cbec:    656e6e6f    onne    DCD    1701736047
        0x0020cbf0:    74207463    ct t    DCD    1948284003
        0x0020cbf4:    6572206f    o re    DCD    1701978223
        0x0020cbf8:    65746f6d    mote    DCD    1702129517
        0x0020cbfc:    76656420     dev    DCD    1986356256
        0x0020cc00:    0a656369    ice.    DCD    174416745
        0x0020cc04:    0000000d    ....    DCD    13
        0x0020cc08:    776f6853    Show    DCD    2003789907
        0x0020cc0c:    61637320     sca    DCD    1633907488
        0x0020cc10:    6564206e    n de    DCD    1701060718
        0x0020cc14:    696c2076    v li    DCD    1768693878
        0x0020cc18:    203a7473    st:     DCD    540701811
        0x0020cc1c:    746c6966    filt    DCD    1953261926
        0x0020cc20:    73207265    er s    DCD    1931506277
        0x0020cc24:    6c706d69    impl    DCD    1819307369
        0x0020cc28:    6c622065    e bl    DCD    1818370149
        0x0020cc2c:    65732065    e se    DCD    1702043749
        0x0020cc30:    63697672    rvic    DCD    1667855986
        0x0020cc34:    000d0a65    e...    DCD    854629
        0x0020cc38:    7473694c    List    DCD    1953720652
        0x0020cc3c:    50414720     GAP    DCD    1346455328
        0x0020cc40:    72657320     ser    DCD    1919251232
        0x0020cc44:    65636976    vice    DCD    1701013878
        0x0020cc48:    6e616820     han    DCD    1851877408
        0x0020cc4c:    20656c64    dle     DCD    543517796
        0x0020cc50:    68636163    cach    DCD    1751343459
        0x0020cc54:    000d0a65    e...    DCD    854629
        0x0020cc58:    7473694c    List    DCD    1953720652
        0x0020cc5c:    6d697320     sim    DCD    1835627296
        0x0020cc60:    20656c70    ple     DCD    543517808
        0x0020cc64:    20656c62    ble     DCD    543517794
        0x0020cc68:    76726573    serv    DCD    1987208563
        0x0020cc6c:    20656369    ice     DCD    543515497
        0x0020cc70:    646e6168    hand    DCD    1684955496
        0x0020cc74:    6320656c    le c    DCD    1663067500
        0x0020cc78:    65686361    ache    DCD    1701340001
        0x0020cc7c:    00000d0a    ....    DCD    3338
        0x0020cc80:    7473694c    List    DCD    1953720652
        0x0020cc84:    74616220     bat    DCD    1952539168
        0x0020cc88:    79726574    tery    DCD    2037540212
        0x0020cc8c:    72657320     ser    DCD    1919251232
        0x0020cc90:    65636976    vice    DCD    1701013878
        0x0020cc94:    6e616820     han    DCD    1851877408
        0x0020cc98:    20656c64    dle     DCD    543517796
        0x0020cc9c:    68636163    cach    DCD    1751343459
        0x0020cca0:    000d0a65    e...    DCD    854629
        0x0020cca4:    706f7453    Stop    DCD    1886352467
        0x0020cca8:    61637320     sca    DCD    1633907488
        0x0020ccac:    000d0a6e    n...    DCD    854638
        0x0020ccb0:    706f7473    stop    DCD    1886352499
        0x0020ccb4:    6e616373    scan    DCD    1851876211
        0x0020ccb8:    00000d0a    ....    DCD    3338
        0x0020ccbc:    776f6873    show    DCD    2003789939
        0x0020ccc0:    0a6e6f63    con.    DCD    175009635
        0x0020ccc4:    0000000d    ....    DCD    13
        0x0020ccc8:    20746547    Get     DCD    544499015
        0x0020cccc:    206c6c61    all     DCD    543976545
        0x0020ccd0:    646e6f42    Bond    DCD    1684959042
        0x0020ccd4:    64206465    ed d    DCD    1679844453
        0x0020ccd8:    63697665    evic    DCD    1667855973
        0x0020ccdc:    69207365    es i    DCD    1763734373
        0x0020cce0:    726f666e    nfor    DCD    1919903342
        0x0020cce4:    6974616d    mati    DCD    1769234797
        0x0020cce8:    0d0a6e6f    on..    DCD    218787439
        0x0020ccec:    00000000    ....    DCD    0
        0x0020ccf0:    61656c43    Clea    DCD    1634036803
        0x0020ccf4:    6c612072    r al    DCD    1818304626
        0x0020ccf8:    6f62206c    l bo    DCD    1868701804
        0x0020ccfc:    6465646e    nded    DCD    1684366446
        0x0020cd00:    76656420     dev    DCD    1986356256
        0x0020cd04:    73656369    ices    DCD    1936024425
        0x0020cd08:    666e6920     inf    DCD    1718511904
        0x0020cd0c:    616d726f    orma    DCD    1634562671
        0x0020cd10:    6e6f6974    tion    DCD    1852795252
        0x0020cd14:    00000d0a    ....    DCD    3338
        0x0020cd18:    646e6f62    bond    DCD    1684959074
        0x0020cd1c:    6f666e69    info    DCD    1868983913
        0x0020cd20:    00000d0a    ....    DCD    3338
        0x0020cd24:    646e6f62    bond    DCD    1684959074
        0x0020cd28:    61656c63    clea    DCD    1634036835
        0x0020cd2c:    000d0a72    r...    DCD    854642
        0x0020cd30:    776f6853    Show    DCD    2003789907
        0x0020cd34:    6c6c6120     all    DCD    1819042080
        0x0020cd38:    76656420     dev    DCD    1986356256
        0x0020cd3c:    73656369    ices    DCD    1936024425
        0x0020cd40:    6e6f6320     con    DCD    1852793632
        0x0020cd44:    7463656e    nect    DCD    1952671086
        0x0020cd48:    20676e69    ing     DCD    543649385
        0x0020cd4c:    74617473    stat    DCD    1952543859
        0x0020cd50:    0d0a7375    us..    DCD    218788725
        0x0020cd54:    00000000    ....    DCD    0
        0x0020cd58:    20726f66    for     DCD    544370534
        0x0020cd5c:    6f747561    auto    DCD    1869903201
        0x0020cd60:    74736574    test    DCD    1953719668
        0x0020cd64:    72617520     uar    DCD    1918989600
        0x0020cd68:    6f702074    t po    DCD    1869619316
        0x0020cd6c:    74207472    rt t    DCD    1948284018
        0x0020cd70:    0a747365    est.    DCD    175403877
        0x0020cd74:    0000000d    ....    DCD    13
        0x0020cd78:    74726175    uart    DCD    1953653109
        0x0020cd7c:    74736574    test    DCD    1953719668
        0x0020cd80:    00000d0a    ....    DCD    3338
        0x0020cd84:    646e6553    Send    DCD    1684956499
        0x0020cd88:    74756120     aut    DCD    1953849632
        0x0020cd8c:    746e6568    hent    DCD    1953391976
        0x0020cd90:    74616369    icat    DCD    1952539497
        0x0020cd94:    206e6f69    ion     DCD    544108393
        0x0020cd98:    75716572    requ    DCD    1970365810
        0x0020cd9c:    0a747365    est.    DCD    175403877
        0x0020cda0:    0000000d    ....    DCD    13
        0x0020cda4:    776f6873    show    DCD    2003789939
        0x0020cda8:    0a766564    dev.    DCD    175531364
        0x0020cdac:    0000000d    ....    DCD    13
        0x0020cdb0:    706d6973    simp    DCD    1886218611
        0x0020cdb4:    74697277    writ    DCD    1953067639
        0x0020cdb8:    00327665    ev2.    DCD    3307109
        0x0020cdbc:    63736964    disc    DCD    1668508004
        0x0020cdc0:    00000000    ....    DCD    0
        0x0020cdc4:    72706167    gapr    DCD    1919967591
        0x0020cdc8:    00646165    ead.    DCD    6578533
        0x0020cdcc:    706d6973    simp    DCD    1886218611
        0x0020cdd0:    64616572    read    DCD    1684104562
        0x0020cdd4:    00000000    ....    DCD    0
        0x0020cdd8:    72736162    basr    DCD    1920164194
        0x0020cddc:    00646165    ead.    DCD    6578533
        0x0020cde0:    706d6973    simp    DCD    1886218611
        0x0020cde4:    64636363    cccd    DCD    1684235107
        0x0020cde8:    00000000    ....    DCD    0
        0x0020cdec:    63736162    basc    DCD    1668505954
        0x0020cdf0:    00646363    ccd.    DCD    6579043
        0x0020cdf4:    68747561    auth    DCD    1752462689
        0x0020cdf8:    65646f6d    mode    DCD    1701080941
        0x0020cdfc:    00000000    ....    DCD    0
        0x0020ce00:    72657375    user    DCD    1919251317
        0x0020ce04:    666e6f63    conf    DCD    1718513507
        0x0020ce08:    00000000    ....    DCD    0
        0x0020ce0c:    74756173    saut    DCD    1953849715
        0x0020ce10:    00000068    h...    DCD    104
        0x0020ce14:    68706167    gaph    DCD    1752195431
        0x0020ce18:    00006c64    dl..    DCD    27748
        0x0020ce1c:    706d6973    simp    DCD    1886218611
        0x0020ce20:    006c6468    hdl.    DCD    7103592
        0x0020ce24:    68736162    bash    DCD    1752392034
        0x0020ce28:    00006c64    dl..    DCD    27748
        0x0020ce2c:    646e6f62    bond    DCD    1684959074
        0x0020ce30:    006c6564    del.    DCD    7103844
        0x0020ce34:    706f7473    stop    DCD    1886352499
        0x0020ce38:    6e616373    scan    DCD    1851876211
        0x0020ce3c:    00000000    ....    DCD    0
        0x0020ce40:    776f6873    show    DCD    2003789939
        0x0020ce44:    006e6f63    con.    DCD    7237475
        0x0020ce48:    646e6f62    bond    DCD    1684959074
        0x0020ce4c:    6f666e69    info    DCD    1868983913
        0x0020ce50:    00000000    ....    DCD    0
        0x0020ce54:    756e6f63    conu    DCD    1970171747
        0x0020ce58:    65726470    pdre    DCD    1701995632
        0x0020ce5c:    00000071    q...    DCD    113
        0x0020ce60:    646e6f62    bond    DCD    1684959074
        0x0020ce64:    61656c63    clea    DCD    1634036835
        0x0020ce68:    00000072    r...    DCD    114
        0x0020ce6c:    74726175    uart    DCD    1953653109
        0x0020ce70:    74736574    test    DCD    1953719668
        0x0020ce74:    00000000    ....    DCD    0
        0x0020ce78:    646e6f63    cond    DCD    1684959075
        0x0020ce7c:    00007665    ev..    DCD    30309
        0x0020ce80:    776f6873    show    DCD    2003789939
        0x0020ce84:    00766564    dev.    DCD    7759204
        0x0020ce88:    68747561    auth    DCD    1752462689
        0x0020ce8c:    0079656b    key.    DCD    7955819
    .conststring
        0x0020ce90:    5f504147    GAP_    DCD    1599095111
        0x0020ce94:    59544441    ADTY    DCD    1498694721
        0x0020ce98:    4d5f4550    PE_M    DCD    1298089296
        0x0020ce9c:    46554e41    ANUF    DCD    1179995713
        0x0020cea0:    55544341    ACTU    DCD    1431585601
        0x0020cea4:    5f524552    RER_    DCD    1599227218
        0x0020cea8:    43455053    SPEC    DCD    1128616019
        0x0020ceac:    43494649    IFIC    DCD    1128875593
        0x0020ceb0:    6f63203a    : co    DCD    1868767290
        0x0020ceb4:    6e61706d    mpan    DCD    1851879533
        0x0020ceb8:    64695f79    y_id    DCD    1684627321
        0x0020cebc:    25783020     0x%    DCD    628633632
        0x0020cec0:    6c202c78    x, l    DCD    1814047864
        0x0020cec4:    25206e65    en %    DCD    622882405
        0x0020cec8:    64202c64    d, d    DCD    1679830116
        0x0020cecc:    20617461    ata     DCD    543257697
        0x0020ced0:    0a0d6225    %b..    DCD    168649253
        0x0020ced4:    00000000    ....    DCD    0
        0x0020ced8:    5f707061    app_    DCD    1601204321
        0x0020cedc:    73726170    pars    DCD    1936875888
        0x0020cee0:    63735f65    e_sc    DCD    1668505445
        0x0020cee4:    695f6e61    an_i    DCD    1767861857
        0x0020cee8:    3a6f666e    nfo:    DCD    980379246
        0x0020ceec:    20444120     AD     DCD    541344032
        0x0020cef0:    75727453    Stru    DCD    1970435155
        0x0020cef4:    72757463    ctur    DCD    1920300131
        0x0020cef8:    6e492065    e In    DCD    1850286181
        0x0020cefc:    203a6f66    fo:     DCD    540700518
        0x0020cf00:    74204441    AD t    DCD    1948271681
        0x0020cf04:    20657079    ype     DCD    543518841
        0x0020cf08:    78257830    0x%x    DCD    2015721520
        0x0020cf0c:    4441202c    , AD    DCD    1145118764
        0x0020cf10:    74614420     Dat    DCD    1952531488
        0x0020cf14:    654c2061    a Le    DCD    1699487841
        0x0020cf18:    6874676e    ngth    DCD    1752459118
        0x0020cf1c:    0d642520     %d.    DCD    224666912
        0x0020cf20:    0000000a    ....    DCD    10

** Section #6 'RAM_DATA_ON' (SHT_PROGBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 116 bytes (alignment 4)
    Address: 0x0020cf24

    0x20cf24:   74 65 72 01 ff ff ff 00 d0 cc 21 00 08 3c 81 00    ter.......!..<..
    0x20cf34:   c8 3c 81 00 d0 d4 20 00 90 d5 20 00 90 d5 20 00    .<.... ... ... .
    0x20cf44:   c0 00 00 00 00 00 00 00 00 00 00 00 c0 cc 21 00    ..............!.
    0x20cf54:   c8 3c 81 00 c8 3c 81 00 d0 d4 20 00 d0 d4 20 00    .<...<.... ... .
    0x20cf64:   d0 d4 20 00 00 00 00 00 00 00 00 00 00 00 00 00    .. .............
    0x20cf74:   c8 cc 21 00 c8 3c 81 00 c8 3c 81 00 d0 d4 20 00    ..!..<...<.... .
    0x20cf84:   d0 d4 20 00 d0 d4 20 00 00 00 00 00 00 00 00 00    .. ... .........
    0x20cf94:   00 00 00 00                                        ....


** Section #7 'RAM_DATA_ON' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 1336 bytes (alignment 4)
    Address: 0x0020cf98


** Section #8 'OVERLAY_A' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 192 bytes (alignment 4)
    Address: 0x0020d4d0

    $t
    .app.overlay_a
    AppUpdateVectorTable
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c
;;;628    static void AppUpdateVectorTable(void)
;;;628    {
        0x0020d4d0:    e92d43f0    -..C    PUSH     {r4-r9,lr}
        0x0020d4d4:    b0bd        ..      SUB      sp,sp,#0xf4
;;;629        extern uint32_t Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;630        extern uint32_t Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;631        extern void Default_Handler(void);
;;;632        const char *SysException[] =
        0x0020d4d6:    2240        @"      MOVS     r2,#0x40
        0x0020d4d8:    4926        &I      LDR      r1,[pc,#152] ; [0x20d574] = 0x21c780
        0x0020d4da:    a82d        -.      ADD      r0,sp,#0xb4
        0x0020d4dc:    f64cfd64    L.d.    BL       __aeabi_memcpy4 ; 0x59fa8
;;;633        {
;;;634            "InitialSP", "Reset", "NMI", "HardFault", "MemManage", "BusFault", "UsageFault", "Rsvd",
;;;635            "Rsvd", "Rsvd", "Rsvd", "SVC", "DebugMon", "Rsvd", "PendSV", "SysTick"
;;;636        };
;;;637        const char *ExtIrq[] =
        0x0020d4e0:    4924        $I      LDR      r1,[pc,#144] ; [0x20d574] = 0x21c780
        0x0020d4e2:    22b4        ."      MOVS     r2,#0xb4
        0x0020d4e4:    3140        @1      ADDS     r1,r1,#0x40
        0x0020d4e6:    4668        hF      MOV      r0,sp
        0x0020d4e8:    f64cfd5e    L.^.    BL       __aeabi_memcpy4 ; 0x59fa8
        0x0020d4ec:    4924        $I      LDR      r1,[pc,#144] ; [0x20d580] = 0xe000ed08
;;;638        {
;;;639            "System", "WDG", "BTMAC", "TIM3", "TIM2", "Platform", "I2S0_TX", "I2S0_RX", "Timer4-7",
;;;640            "GPIO4", "GPIO5", "UART1", "UART0", "RTC", "SPI0", "SPI1", "I2C0", "I2C1", "ADC",
;;;641            "Peripheral", "GDMA0 Channel0", "GDMA0 Channel1", "GDMA0 Channel2", "GDMA0 Channel3",
;;;642            "GDMA0 Channel4", "GDMA0 Channel5", "GPIO_Group3", "GPIO_Group2", "IR", "GPIO_Group1",
;;;643            "GPIO_Group0", "UART2", "TIM4", "TIM5", "TIM6", "TIM7", "SPI_Flash", "Qdecode",
;;;644            "Keyscan", "SPI2W", "LPCOMP", "PTA_Mailbox", "SPORT1 TX", "SPORT1 RX", "LCD"
;;;645        };
;;;646    
;;;647        IRQ_Fun *pRamVector    = (IRQ_Fun *)VTOR_RAM_ADDR;
        0x0020d4ee:    f44f1000    O...    MOV      r0,#0x200000
        0x0020d4f2:    4d21        !M      LDR      r5,[pc,#132] ; [0x20d578] = 0x80e77c
        0x0020d4f4:    4f21        !O      LDR      r7,[pc,#132] ; [0x20d57c] = 0xf4
        0x0020d4f6:    6809        .h      LDR      r1,[r1,#0]
        0x0020d4f8:    4606        .F      MOV      r6,r0
;;;648        IRQ_Fun *pAppVector    = (IRQ_Fun *)&Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;649        uint32_t AppVectorSize = (uint32_t)&Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;650        uint32_t i             = 0;
        0x0020d4fa:    2400        .$      MOVS     r4,#0
;;;651    
;;;652        if (SCB->VTOR != VTOR_RAM_ADDR)
        0x0020d4fc:    42b1        .B      CMP      r1,r6
        0x0020d4fe:    d001        ..      BEQ      0x20d504 ; AppUpdateVectorTable + 52
;;;653        {
;;;654            RamVectorTableInit(VTOR_RAM_ADDR);
        0x0020d500:    f5f7fbd2    ....    BL       RamVectorTableInit ; 0x4ca8
        0x0020d504:    f04f5805    O..X    MOV      r8,#0x21400000
        0x0020d508:    f8df9078    ..x.    LDR      r9,[pc,#120] ; [0x20d584] = 0x21100101
;;;655        }
;;;656    
;;;657        /* Update APP defined handlers */
;;;658        for (i = 0; i < AppVectorSize / 4; ++i)
        0x0020d50c:    e027        '.      B        0x20d55e ; AppUpdateVectorTable + 142
;;;659        {
;;;660            if (i == 1) //skip reset_handler remap
        0x0020d50e:    2c01        .,      CMP      r4,#1
        0x0020d510:    d024        $.      BEQ      0x20d55c ; AppUpdateVectorTable + 140
;;;661            {
;;;662                continue;
;;;663            }
;;;664    
;;;665            if ((pAppVector[i] != Default_Handler) && (pAppVector[i] != 0))
        0x0020d512:    f8550024    U.$.    LDR      r0,[r5,r4,LSL #2]
        0x0020d516:    491c        .I      LDR      r1,[pc,#112] ; [0x20d588] = 0x207d39
        0x0020d518:    4288        .B      CMP      r0,r1
        0x0020d51a:    d01f        ..      BEQ      0x20d55c ; AppUpdateVectorTable + 140
        0x0020d51c:    b1f0        ..      CBZ      r0,0x20d55c ; AppUpdateVectorTable + 140
;;;666            {
;;;667                if (i < System_VECTORn)
        0x0020d51e:    2c10        .,      CMP      r4,#0x10
        0x0020d520:    d209        ..      BCS      0x20d536 ; AppUpdateVectorTable + 102
;;;668                {
;;;669                    OS_PRINT_WARN1("Warning! %s is updated by APP!", TRACE_STRING(SysException[i]));
        0x0020d522:    a82d        -.      ADD      r0,sp,#0xb4
        0x0020d524:    f8501024    P.$.    LDR      r1,[r0,r4,LSL #2]
        0x0020d528:    4640        @F      MOV      r0,r8
        0x0020d52a:    f5fafc9e    ....    BL       trace_string ; 0x7e6a
        0x0020d52e:    4603        .F      MOV      r3,r0
        0x0020d530:    2201        ."      MOVS     r2,#1
        0x0020d532:    4916        .I      LDR      r1,[pc,#88] ; [0x20d58c] = 0x880009c
        0x0020d534:    e00b        ..      B        0x20d54e ; AppUpdateVectorTable + 126
;;;670                }
;;;671                else
;;;672                {
;;;673                    OS_PRINT_WARN1("Warning! ISR %s is updated by APP!",
        0x0020d536:    4668        hF      MOV      r0,sp
        0x0020d538:    eb000084    ....    ADD      r0,r0,r4,LSL #2
        0x0020d53c:    f8501c40    P.@.    LDR      r1,[r0,#-0x40]
        0x0020d540:    4640        @F      MOV      r0,r8
        0x0020d542:    f5fafc92    ....    BL       trace_string ; 0x7e6a
        0x0020d546:    4911        .I      LDR      r1,[pc,#68] ; [0x20d58c] = 0x880009c
        0x0020d548:    2201        ."      MOVS     r2,#1
        0x0020d54a:    4603        .F      MOV      r3,r0
        0x0020d54c:    3124        $1      ADDS     r1,r1,#0x24
        0x0020d54e:    4648        HF      MOV      r0,r9
        0x0020d550:    f5fafa85    ....    BL       log_buffer ; 0x7a5e
;;;674                                   TRACE_STRING(ExtIrq[i - System_VECTORn]));
;;;675                }
;;;676    
;;;677                pRamVector[i] = pAppVector[i];
        0x0020d554:    f8550024    U.$.    LDR      r0,[r5,r4,LSL #2]
        0x0020d558:    f8460024    F.$.    STR      r0,[r6,r4,LSL #2]
        0x0020d55c:    1c64        d.      ADDS     r4,r4,#1
        0x0020d55e:    ebb40f97    ....    CMP      r4,r7,LSR #2
        0x0020d562:    d3d4        ..      BCC      0x20d50e ; AppUpdateVectorTable + 62
;;;678            }
;;;679        }
;;;680    
;;;681        __DMB();
        0x0020d564:    f3bf8f5f    .._.    DMB      
;;;682        __DSB();
        0x0020d568:    f3bf8f4f    ..O.    DSB      
;;;683    }
        0x0020d56c:    b03d        =.      ADD      sp,sp,#0xf4
        0x0020d56e:    e8bd83f0    ....    POP      {r4-r9,pc}
    $d
        0x0020d572:    0000        ..      DCW    0
        0x0020d574:    0021c780    ..!.    DCD    2213760
        0x0020d578:    0080e77c    |...    DCD    8447868
        0x0020d57c:    000000f4    ....    DCD    244
        0x0020d580:    e000ed08    ....    DCD    3758157064
        0x0020d584:    21100101    ...!    DCD    554696961
        0x0020d588:    00207d39    9} .    DCD    2129209
        0x0020d58c:    0880009c    ....    DCD    142606492

** Section #9 'CACHE_DATA_ON' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 3292 bytes (alignment 4)
    Address: 0x0021c000

    $t
    .ARM.Collect$$_printf_percent$$00000009
    .ARM.Collect$$_printf_percent$$00000000
    _printf_d
    _printf_percent
        0x0021c000:    2964        d)      CMP      r1,#0x64
        0x0021c002:    f42faeb9    /...    BEQ      _printf_int_dec ; 0x20bd78
    .ARM.Collect$$_printf_percent$$0000000C
    _printf_x
        0x0021c006:    2978        x)      CMP      r1,#0x78
        0x0021c008:    f42faef2    /...    BEQ      _printf_int_hex ; 0x20bdf0
    .ARM.Collect$$_printf_percent$$00000017
    _printf_percent_end
        0x0021c00c:    2000        .       MOVS     r0,#0
        0x0021c00e:    4770        pG      BX       lr
    .ARM.Collect$$libinit$$00000000
    __rt_lib_init
        0x0021c010:    b51f        ..      PUSH     {r0-r4,lr}
    .ARM.Collect$$libinit$$00000001
    __rt_lib_init_fp_1
        0x0021c012:    f000fba3    ....    BL       _fp_init ; 0x21c75c
    .ARM.Collect$$libinit$$00000004
    .ARM.Collect$$libinit$$0000000A
    .ARM.Collect$$libinit$$0000000C
    .ARM.Collect$$libinit$$0000000D
    __rt_lib_init_heap_1
    __rt_lib_init_preinit_1
    __rt_lib_init_rand_2
    __rt_lib_init_user_alloc_1
        0x0021c016:    f000fb3a    ..:.    BL       _rand_init ; 0x21c68e
    .ARM.Collect$$libinit$$0000000E
    .ARM.Collect$$libinit$$00000011
    .ARM.Collect$$libinit$$00000013
    .ARM.Collect$$libinit$$00000015
    .ARM.Collect$$libinit$$00000017
    .ARM.Collect$$libinit$$00000019
    .ARM.Collect$$libinit$$0000001B
    .ARM.Collect$$libinit$$0000001D
    .ARM.Collect$$libinit$$0000001F
    .ARM.Collect$$libinit$$00000021
    .ARM.Collect$$libinit$$00000023
    .ARM.Collect$$libinit$$00000025
    .ARM.Collect$$libinit$$0000002C
    .ARM.Collect$$libinit$$0000002E
    .ARM.Collect$$libinit$$00000030
    .ARM.Collect$$libinit$$00000032
    .ARM.Collect$$libinit$$00000033
    __rt_lib_init_alloca_1
    __rt_lib_init_argv_1
    __rt_lib_init_atexit_1
    __rt_lib_init_clock_1
    __rt_lib_init_cpp_1
    __rt_lib_init_exceptions_1
    __rt_lib_init_fp_trap_1
    __rt_lib_init_getenv_1
    __rt_lib_init_lc_collate_1
    __rt_lib_init_lc_ctype_1
    __rt_lib_init_lc_monetary_1
    __rt_lib_init_lc_numeric_1
    __rt_lib_init_lc_time_1
    __rt_lib_init_rand_1
    __rt_lib_init_return
    __rt_lib_init_signal_1
    __rt_lib_init_stdio_1
        0x0021c01a:    bd1f        ..      POP      {r0-r4,pc}
    .emb_text
    rand
        0x0021c01c:    490b        .I      LDR      r1,[pc,#44] ; [0x21c04c] = 0x20d4c8
        0x0021c01e:    f8d1c000    ....    LDR      r12,[r1,#0]
        0x0021c022:    684a        Jh      LDR      r2,[r1,#4]
        0x0021c024:    f85c3b04    \..;    LDR      r3,[r12],#4
        0x0021c028:    6810        .h      LDR      r0,[r2,#0]
        0x0021c02a:    4418        .D      ADD      r0,r0,r3
        0x0021c02c:    f8420b04    B...    STR      r0,[r2],#4
        0x0021c030:    458c        .E      CMP      r12,r1
        0x0021c032:    bf28        (.      IT       CS
        0x0021c034:    f1a10cdc    ....    SUBCS    r12,r1,#0xdc
        0x0021c038:    428a        .B      CMP      r2,r1
        0x0021c03a:    bf28        (.      IT       CS
        0x0021c03c:    f1a102dc    ....    SUBCS    r2,r1,#0xdc
        0x0021c040:    f8c1c000    ....    STR      r12,[r1,#0]
        0x0021c044:    604a        J`      STR      r2,[r1,#4]
        0x0021c046:    f0204000     ..@    BIC      r0,r0,#0x80000000
        0x0021c04a:    4770        pG      BX       lr
    $d
        0x0021c04c:    0020d4c8    .. .    DCD    2151624
    $t
    .text
    common_main
;;;304    {
        0x0021c050:    b510        ..      PUSH     {r4,lr}
;;;305    //add common system code here before enter user defined main function
;;;306        OTP->run_in_app = 1;
        0x0021c052:    f44f1400    O...    MOV      r4,#0x200000
        0x0021c056:    f894039b    ....    LDRB     r0,[r4,#0x39b]
        0x0021c05a:    f0400080    @...    ORR      r0,r0,#0x80
        0x0021c05e:    f884039b    ....    STRB     r0,[r4,#0x39b]
;;;307    
;;;308    #if (RUN_APP_IN_HCIMODE_ENABLE == 0)
;;;309        if (OTP->stack_en)
        0x0021c062:    f89402dc    ....    LDRB     r0,[r4,#0x2dc]
        0x0021c066:    07c1        ..      LSLS     r1,r0,#31
;;;310        {
;;;311            DBG_DIRECT("In SoC Mode");
        0x0021c068:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0021c06c:    d003        ..      BEQ      0x21c076 ; common_main + 38
        0x0021c06e:    a136        6.      ADR      r1,{pc}+0xda ; 0x21c148
        0x0021c070:    f5ebfc9e    ....    BL       log_direct ; 0x79b0
        0x0021c074:    e006        ..      B        0x21c084 ; common_main + 52
;;;312        }
;;;313        else
;;;314        {
;;;315            DBG_DIRECT("WARNING: In HCI Mode, will not run APP Task");
        0x0021c076:    a137        7.      ADR      r1,{pc}+0xde ; 0x21c154
        0x0021c078:    f5ebfc9a    ....    BL       log_direct ; 0x79b0
;;;316            WDG_Disable();
        0x0021c07c:    f5f5fc61    ..a.    BL       WDG_Disable ; 0x11942
;;;317            os_sched_start();
        0x0021c080:    f60afb9f    ....    BL       os_sched_start ; 0x267c2
;;;318        }
;;;319    #endif
;;;320    
;;;321        //fix system hang if app call log_module_trace_set after enable RELEASE_VERSION
;;;322        if (OTP->logDisable == 1)
        0x0021c084:    f894039a    ....    LDRB     r0,[r4,#0x39a]
        0x0021c088:    07c0        ..      LSLS     r0,r0,#31
        0x0021c08a:    d002        ..      BEQ      0x21c092 ; common_main + 66
;;;323        {
;;;324            log_module_trace_init(NULL);
        0x0021c08c:    2000        .       MOVS     r0,#0
        0x0021c08e:    f5ecf8a1    ....    BL       log_module_trace_init ; 0x81d4
;;;325        }
;;;326    
;;;327    #if (SYSTEM_TRACE_ENABLE == 1)
;;;328        extern void system_trace_init(void);
;;;329        system_trace_init();
;;;330    #endif
;;;331    
;;;332        extern int __main(void);
;;;333        __main();
        0x0021c092:    e8bd4010    ...@    POP      {r4,lr}
        0x0021c096:    f1f2b1b7    ....    B.W      __main ; 0x80e408
    WDG_SystemReset
;;;334    }
;;;335    
;;;336    #if (DEBUG_WATCHPOINT_ENABLE == 1)
;;;337    /**
;;;338     * @brief  Enable Debug Monitor Function (include NVIC Enable and DWT configuration)
;;;339     * @param  none
;;;340     * @return none
;;;341     */
;;;342    
;;;343    DATA_RAM_FUNCTION
;;;344    void debug_monitor_enable(void)
;;;345    {
;;;346        //DBG_DIRECT("debug_monitor_enable");
;;;347    
;;;348        //set debug monitor priority
;;;349        NVIC_SetPriority(DebugMonitor_IRQn, 3);
;;;350    
;;;351        //enable exception and monitor control register
;;;352        CoreDebug->DEMCR |= CoreDebug_DEMCR_MON_EN_Msk | CoreDebug_DEMCR_TRCENA_Msk;
;;;353    
;;;354        //set DWT compare registers (max 4 comparators)
;;;355        //watch_point_0_setting(0x1000180C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_WRITE);
;;;356        //watch_point_1_setting(0x10000004, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;357        //watch_point_2_setting(0x10000008, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;358        //watch_point_3_setting(0x1000000C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;359    
;;;360        //enable DWT control register
;;;361        DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
;;;362    
;;;363        return;
;;;364    }
;;;365    #endif
;;;366    
;;;367    APP_FLASH_TEXT_SECTION
;;;368    void ram_init(void)
;;;369    {
;;;370        //copy data on ro
;;;371        extern char Image$$RAM_DATA_ON$$RO$$Base[];
;;;372        extern char Load$$RAM_DATA_ON$$RO$$Base[];
;;;373        extern unsigned int Image$$RAM_DATA_ON$$RO$$Length;
;;;374    
;;;375        memcpy(Image$$RAM_DATA_ON$$RO$$Base,
;;;376               Load$$RAM_DATA_ON$$RO$$Base,
;;;377               (unsigned int)&Image$$RAM_DATA_ON$$RO$$Length);
;;;378    
;;;379        //copy data on rw
;;;380        extern char Image$$RAM_DATA_ON$$RW$$Base[];
;;;381        extern char Load$$RAM_DATA_ON$$RW$$Base[];
;;;382        extern unsigned int Image$$RAM_DATA_ON$$RW$$Length;
;;;383    
;;;384        memcpy(Image$$RAM_DATA_ON$$RW$$Base,
;;;385               Load$$RAM_DATA_ON$$RW$$Base,
;;;386               (unsigned int)&Image$$RAM_DATA_ON$$RW$$Length);
;;;387    
;;;388        //clear data on zi
;;;389        extern char Image$$RAM_DATA_ON$$ZI$$Base[];
;;;390        extern unsigned int Image$$RAM_DATA_ON$$ZI$$Length;
;;;391    
;;;392        memset(Image$$RAM_DATA_ON$$ZI$$Base,
;;;393               0,
;;;394               (unsigned int)&Image$$RAM_DATA_ON$$ZI$$Length);
;;;395    
;;;396        //copy cache ro
;;;397        extern char Image$$CACHE_DATA_ON$$RO$$Base[];
;;;398        extern char Load$$CACHE_DATA_ON$$RO$$Base[];
;;;399        extern unsigned int Image$$CACHE_DATA_ON$$RO$$Length;
;;;400    
;;;401        memcpy(Image$$CACHE_DATA_ON$$RO$$Base,
;;;402               Load$$CACHE_DATA_ON$$RO$$Base,
;;;403               (unsigned int)&Image$$CACHE_DATA_ON$$RO$$Length);
;;;404    
;;;405        //copy share cache ram rw
;;;406        extern char Image$$CACHE_DATA_ON$$RW$$Base[];
;;;407        extern char Load$$CACHE_DATA_ON$$RW$$Base[];
;;;408        extern unsigned int Image$$CACHE_DATA_ON$$RW$$Length;
;;;409    
;;;410        memcpy(Image$$CACHE_DATA_ON$$RW$$Base,
;;;411               Load$$CACHE_DATA_ON$$RW$$Base,
;;;412               (unsigned int)&Image$$CACHE_DATA_ON$$RW$$Length);
;;;413    
;;;414        //clear share cache ram zi
;;;415        extern char Image$$CACHE_DATA_ON$$ZI$$Base[];
;;;416        extern unsigned int Image$$CACHE_DATA_ON$$ZI$$Length;
;;;417    
;;;418        memset(Image$$CACHE_DATA_ON$$ZI$$Base,
;;;419               0,
;;;420               (unsigned int)&Image$$CACHE_DATA_ON$$ZI$$Length);
;;;421    }
;;;422    
;;;423    uint32_t random_seed_value;
;;;424    
;;;425    APP_FLASH_TEXT_SECTION
;;;426    void random_seed_init(void)
;;;427    {
;;;428        uint16_t crc16;
;;;429        uint8_t buf[DATA_SIZE_FOR_RANDOM_SEED];
;;;430        uint8_t *sour_addr = (uint8_t *)(OTP->appDataAddr + OTP->appDataSize + OTP->heapDataONSize);
;;;431    
;;;432        memcpy(buf, sour_addr, DATA_SIZE_FOR_RANDOM_SEED);
;;;433        crc16 = btxfcs(0, buf, DATA_SIZE_FOR_RANDOM_SEED);
;;;434    
;;;435        random_seed_value = (crc16 << 16) | (*(volatile uint32_t *)(0x4005817C) & 0xFFFF);
;;;436    
;;;437        random_seed_value *= platform_random(0xFFFFFFFF);
;;;438    
;;;439        srand(random_seed_value);
;;;440    
;;;441        for (int i = 0; i < (DATA_SIZE_FOR_RANDOM_SEED / 4); ++i)
;;;442        {
;;;443            *(uint32_t *)(sour_addr + i * 4) = rand();
;;;444        }
;;;445    
;;;446        random_seed_value = rand();
;;;447    }
;;;448    
;;;449    APP_FLASH_TEXT_SECTION
;;;450    void SystemInit(void)
;;;451    {
;;;452        //hci mode check and bypass app
;;;453        if (check_hci_mode_flag())
;;;454        {
;;;455            return;
;;;456        }
;;;457    
;;;458        //init pre_main and main functions
;;;459        extern void pre_main(void);
;;;460        app_pre_main = (APP_MAIN_FUNC)pre_main;
;;;461        app_main = (APP_MAIN_FUNC)common_main;
;;;462    
;;;463        /******** update otp here**********/
;;;464        //ram config
;;;465        OTP->appDataSize = APP_GLOBAL_SIZE;
;;;466        OTP->heapDataONSize = HEAP_DATA_ON_SIZE - DATA_SIZE_FOR_RANDOM_SEED;
;;;467    
;;;468        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;469    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;470        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
;;;471    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;472        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;473    #else
;;;474        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;475    #endif
;;;476    
;;;477        //sw timer config
;;;478    #ifdef TIMER_MAX_NUMBER
;;;479        //define TIMER_MAX_NUMBER in otp_config.h
;;;480        OTP->timerMaxNumber = TIMER_MAX_NUMBER;
;;;481    #endif
;;;482    
;;;483        //flash config
;;;484        /*config enable flash block proect depending on flash layout and flash id*/
;;;485    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;486        OTP->bp_enable = 1;
;;;487    #else
;;;488        OTP->bp_enable = 0;
;;;489    #endif
;;;490        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
;;;491    
;;;492    
;;;493        //os config
;;;494        /*config enable check task stack overflow*/
;;;495    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;496        OTP->checkForStackOverflow = 1;
;;;497    #else
;;;498        OTP->checkForStackOverflow = 0;
;;;499    #endif
;;;500    
;;;501    
;;;502        //platform config
;;;503        /*config enable platform assert*/
;;;504    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;505        OTP->enableASSERT = 1;
;;;506    #else
;;;507        OTP->enableASSERT = 0;
;;;508    #endif
;;;509    
;;;510        /*Print all log in log buffer before entering DLPS */
;;;511    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;512        OTP->printAllLogBeforeEnterDLPS = 1;
;;;513    #else
;;;514        OTP->printAllLogBeforeEnterDLPS = 0;
;;;515    #endif
;;;516    
;;;517        /*config enable log or not*/
;;;518    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;519        OTP->logDisable = 0;
;;;520    #else
;;;521        OTP->logDisable = 1;
;;;522    #endif
;;;523    
;;;524        /*config enable swd pinmux*/
;;;525    #if (SWD_PINMUX_ENABLE == 1)
;;;526        OTP->SWD_ENABLE = 1;
;;;527    #else
;;;528        OTP->SWD_ENABLE = 0;
;;;529    #endif
;;;530    
;;;531        /*config enable watch dog in rom*/
;;;532    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;533        OTP->wdgEnableInRom = 1;
;;;534    #else
;;;535        OTP->wdgEnableInRom = 0;
;;;536    #endif
;;;537    
;;;538        /*config watch dog mode in rom, defualt reset all*/
;;;539        OTP->wdgMode = ROM_WATCH_DOG_MODE;
;;;540    
;;;541        /*use os tick as log timestamp instead of TIM7*/
;;;542        OTP->log_timestamp_src = LOG_TIMESTAMP_OS;
;;;543    
;;;544    
;;;545        //app config
;;;546        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
;;;547        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
;;;548        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
;;;549        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
;;;550    
;;;551    #if ROM_OTA_LINKLOSS_RST
;;;552        OTP->ota_link_loss_reset = 1;
;;;553    #endif
;;;554        /*config bt stack parameters in rom*/
;;;555    #ifdef BT_STACK_CONFIG_ENABLE
;;;556        bt_stack_config_init();
;;;557    #endif
;;;558    
;;;559    //add more otp config here
;;;560    }
;;;561    
;;;562    //Note: call print_reset_reason() before ram_init();
;;;563    APP_FLASH_TEXT_SECTION
;;;564    void print_reset_reason(void)
;;;565    {
;;;566        if (check_reset_ram.check_reset_ram_pattern != RESET_RAM_PATTERN)
;;;567        {
;;;568            BOOT_PRINT_INFO0("RESET Reason: HW or OTA");
;;;569        }
;;;570        else
;;;571        {
;;;572            T_SW_RESET_REASON sw_reset_type = get_aon_record_reset_reason();
;;;573    
;;;574            if (sw_reset_type != (T_SW_RESET_REASON)0)
;;;575            {
;;;576                BOOT_PRINT_INFO1("RESET Reason: SW(reset except aon), TYPE 0x%x", sw_reset_type);
;;;577            }
;;;578            else //reset all will clear aon register
;;;579            {
;;;580                BOOT_PRINT_INFO1("RESET Reason: SW(reset all), TYPE 0x%x", check_reset_ram.check_reset_ram_type);
;;;581            }
;;;582        }
;;;583    }
;;;584    
;;;585    APP_FLASH_TEXT_SECTION
;;;586    void pre_main(void)
;;;587    {
;;;588        __disable_irq();
;;;589    
;;;590        print_reset_reason();  //Note: call this function before ram_init();
;;;591    
;;;592        ram_init();
;;;593    
;;;594        random_seed_init();
;;;595    
;;;596        load_overlay(OVERLAY_SCENARIO_BOOT_ONCE);
;;;597    
;;;598        //reset NVIC of DMA channel used in image decryption
;;;599        NVIC_DisableIRQ(GDMA0_Channel2_IRQn);
;;;600        NVIC_DisableIRQ(GDMA0_Channel3_IRQn);
;;;601    
;;;602        setlocale(LC_ALL, "C");
;;;603    
;;;604        BOOT_PRINT_ERROR2("SDK Ver: %s, Build Time: %s",
;;;605                          TRACE_STRING(VERSION_BUILD_STR),
;;;606                          TRACE_STRING(BUILDING_TIME));
;;;607    
;;;608        AppUpdateVectorTable();
;;;609    
;;;610    #if (DEBUG_WATCHPOINT_ENABLE == 1)
;;;611        debug_monitor_enable();
;;;612    #endif
;;;613    
;;;614        if (app_pre_main_cb)
;;;615        {
;;;616            app_pre_main_cb();
;;;617        }
;;;618    
;;;619        return;
;;;620    }
;;;621    /**
;;;622     * @brief  update vector table in app
;;;623     * @param  none
;;;624     * @return none
;;;625      */
;;;626    OVERLAY_SECTION_BOOT_ONCE
;;;627    static void AppUpdateVectorTable(void)
;;;628    {
;;;629        extern uint32_t Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;630        extern uint32_t Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;631        extern void Default_Handler(void);
;;;632        const char *SysException[] =
;;;633        {
;;;634            "InitialSP", "Reset", "NMI", "HardFault", "MemManage", "BusFault", "UsageFault", "Rsvd",
;;;635            "Rsvd", "Rsvd", "Rsvd", "SVC", "DebugMon", "Rsvd", "PendSV", "SysTick"
;;;636        };
;;;637        const char *ExtIrq[] =
;;;638        {
;;;639            "System", "WDG", "BTMAC", "TIM3", "TIM2", "Platform", "I2S0_TX", "I2S0_RX", "Timer4-7",
;;;640            "GPIO4", "GPIO5", "UART1", "UART0", "RTC", "SPI0", "SPI1", "I2C0", "I2C1", "ADC",
;;;641            "Peripheral", "GDMA0 Channel0", "GDMA0 Channel1", "GDMA0 Channel2", "GDMA0 Channel3",
;;;642            "GDMA0 Channel4", "GDMA0 Channel5", "GPIO_Group3", "GPIO_Group2", "IR", "GPIO_Group1",
;;;643            "GPIO_Group0", "UART2", "TIM4", "TIM5", "TIM6", "TIM7", "SPI_Flash", "Qdecode",
;;;644            "Keyscan", "SPI2W", "LPCOMP", "PTA_Mailbox", "SPORT1 TX", "SPORT1 RX", "LCD"
;;;645        };
;;;646    
;;;647        IRQ_Fun *pRamVector    = (IRQ_Fun *)VTOR_RAM_ADDR;
;;;648        IRQ_Fun *pAppVector    = (IRQ_Fun *)&Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;649        uint32_t AppVectorSize = (uint32_t)&Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;650        uint32_t i             = 0;
;;;651    
;;;652        if (SCB->VTOR != VTOR_RAM_ADDR)
;;;653        {
;;;654            RamVectorTableInit(VTOR_RAM_ADDR);
;;;655        }
;;;656    
;;;657        /* Update APP defined handlers */
;;;658        for (i = 0; i < AppVectorSize / 4; ++i)
;;;659        {
;;;660            if (i == 1) //skip reset_handler remap
;;;661            {
;;;662                continue;
;;;663            }
;;;664    
;;;665            if ((pAppVector[i] != Default_Handler) && (pAppVector[i] != 0))
;;;666            {
;;;667                if (i < System_VECTORn)
;;;668                {
;;;669                    OS_PRINT_WARN1("Warning! %s is updated by APP!", TRACE_STRING(SysException[i]));
;;;670                }
;;;671                else
;;;672                {
;;;673                    OS_PRINT_WARN1("Warning! ISR %s is updated by APP!",
;;;674                                   TRACE_STRING(ExtIrq[i - System_VECTORn]));
;;;675                }
;;;676    
;;;677                pRamVector[i] = pAppVector[i];
;;;678            }
;;;679        }
;;;680    
;;;681        __DMB();
;;;682        __DSB();
;;;683    }
;;;684    /**
;;;685     * @brief  GPIO Group3 Handler
;;;686     * @param  none
;;;687     * @return none
;;;688      */
;;;689    DATA_RAM_FUNCTION void GPIO_Group3_Handler(void)
;;;690    {
;;;691        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;692    
;;;693        //Check exact IRQ function
;;;694        if (GPIOIrqStatus & BIT3)
;;;695        {
;;;696            GPIO3_Handler();
;;;697        }
;;;698        if (GPIOIrqStatus & BIT7)
;;;699        {
;;;700            GPIO7_Handler();
;;;701        }
;;;702        if (GPIOIrqStatus & BIT11)
;;;703        {
;;;704            GPIO11_Handler();
;;;705        }
;;;706        if (GPIOIrqStatus & BIT15)
;;;707        {
;;;708            GPIO15_Handler();
;;;709        }
;;;710        if (GPIOIrqStatus & BIT19)
;;;711        {
;;;712            GPIO19_Handler();
;;;713        }
;;;714        if (GPIOIrqStatus & BIT23)
;;;715        {
;;;716            GPIO23_Handler();
;;;717        }
;;;718        if (GPIOIrqStatus & BIT27)
;;;719        {
;;;720            GPIO27_Handler();
;;;721        }
;;;722        if (GPIOIrqStatus & BIT31)
;;;723        {
;;;724            GPIO31_Handler();
;;;725        }
;;;726    }
;;;727    /**
;;;728     * @brief  GPIO Group2 Handler
;;;729     * @param  none
;;;730     * @return none
;;;731      */
;;;732    DATA_RAM_FUNCTION void GPIO_Group2_Handler(void)
;;;733    {
;;;734        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;735    
;;;736        //Check exact IRQ function
;;;737        if (GPIOIrqStatus & BIT2)
;;;738        {
;;;739            GPIO2_Handler();
;;;740        }
;;;741        if (GPIOIrqStatus & BIT6)
;;;742        {
;;;743            GPIO6_Handler();
;;;744        }
;;;745        if (GPIOIrqStatus & BIT10)
;;;746        {
;;;747            GPIO10_Handler();
;;;748        }
;;;749        if (GPIOIrqStatus & BIT14)
;;;750        {
;;;751            GPIO14_Handler();
;;;752        }
;;;753        if (GPIOIrqStatus & BIT18)
;;;754        {
;;;755            GPIO18_Handler();
;;;756        }
;;;757        if (GPIOIrqStatus & BIT22)
;;;758        {
;;;759            GPIO22_Handler();
;;;760        }
;;;761        if (GPIOIrqStatus & BIT26)
;;;762        {
;;;763            GPIO26_Handler();
;;;764        }
;;;765        if (GPIOIrqStatus & BIT30)
;;;766        {
;;;767            GPIO30_Handler();
;;;768        }
;;;769    }
;;;770    /**
;;;771     * @brief  GPIO Group1 Handler
;;;772     * @param  none
;;;773     * @return none
;;;774      */
;;;775    DATA_RAM_FUNCTION void GPIO_Group1_Handler(void)
;;;776    {
;;;777        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;778    
;;;779        //Check exact IRQ function
;;;780        if (GPIOIrqStatus & BIT1)
;;;781        {
;;;782            GPIO1_Handler();
;;;783        }
;;;784        if (GPIOIrqStatus & BIT9)
;;;785        {
;;;786            GPIO9_Handler();
;;;787        }
;;;788        if (GPIOIrqStatus & BIT13)
;;;789        {
;;;790            GPIO13_Handler();
;;;791        }
;;;792        if (GPIOIrqStatus & BIT17)
;;;793        {
;;;794            GPIO17_Handler();
;;;795        }
;;;796        if (GPIOIrqStatus & BIT21)
;;;797        {
;;;798            GPIO21_Handler();
;;;799        }
;;;800        if (GPIOIrqStatus & BIT25)
;;;801        {
;;;802            GPIO25_Handler();
;;;803        }
;;;804        if (GPIOIrqStatus & BIT29)
;;;805        {
;;;806            GPIO29_Handler();
;;;807        }
;;;808    }
;;;809    /**
;;;810     * @brief  GPIO Group0 Handler
;;;811     * @param  none
;;;812     * @return none
;;;813      */
;;;814    DATA_RAM_FUNCTION void GPIO_Group0_Handler(void)
;;;815    {
;;;816        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;817    
;;;818        //Check exact IRQ function
;;;819        if (GPIOIrqStatus & BIT0)
;;;820        {
;;;821            GPIO0_Handler();
;;;822        }
;;;823        if (GPIOIrqStatus & BIT8)
;;;824        {
;;;825            GPIO8_Handler();
;;;826        }
;;;827        if (GPIOIrqStatus & BIT12)
;;;828        {
;;;829            GPIO12_Handler();
;;;830        }
;;;831        if (GPIOIrqStatus & BIT16)
;;;832        {
;;;833            GPIO16_Handler();
;;;834        }
;;;835        if (GPIOIrqStatus & BIT20)
;;;836        {
;;;837            GPIO20_Handler();
;;;838        }
;;;839        if (GPIOIrqStatus & BIT24)
;;;840        {
;;;841            GPIO24_Handler();
;;;842        }
;;;843        if (GPIOIrqStatus & BIT28)
;;;844        {
;;;845            GPIO28_Handler();
;;;846        }
;;;847    }
;;;848    
;;;849    void WDG_SystemReset(T_WDG_MODE wdg_mode, T_SW_RESET_REASON reset_reason)
;;;850    {
;;;851        uint32_t parm = wdg_mode | (reset_reason << 8);
        0x0021c09a:    ea402101    @..!    ORR      r1,r0,r1,LSL #8
;;;852        SystemCall(SYSTEM_CALL_WDG_RESET, parm);
        0x0021c09e:    2001        .       MOVS     r0,#1
        0x0021c0a0:    f5ebb8fe    ....    B        SystemCall ; 0x72a0
    flash_try_high_speed
;;;853    }
;;;854    
;;;855    /**
;;;856     * @brief  flash try to switch to high speed bit mode
;;;857     * @note  switch back to 1 bit mode, if flash switch to high speed bit mode fail
;;;858     * @param  bit_mode config bit mode @ref T_FLASH_MODE
;;;859     * @retval 0 fail
;;;860     * @retval 1 success
;;;861      */
;;;862    uint32_t flash_try_high_speed(T_FLASH_MODE bit_mode)
;;;863    {
        0x0021c0a4:    b510        ..      PUSH     {r4,lr}
;;;864        uint32_t result = 0;
;;;865        OTP->bit_mode = bit_mode;
        0x0021c0a6:    f44f1400    O...    MOV      r4,#0x200000
        0x0021c0aa:    2200        ."      MOVS     r2,#0
        0x0021c0ac:    f894134c    ..L.    LDRB     r1,[r4,#0x34c]
        0x0021c0b0:    f3600101    `...    BFI      r1,r0,#0,#2
        0x0021c0b4:    f884134c    ..L.    STRB     r1,[r4,#0x34c]
;;;866        result = flash_ioctl(flash_ioctrl_try_high_speed, 0, 0);
        0x0021c0b8:    4611        .F      MOV      r1,r2
        0x0021c0ba:    f2450002    E...    MOV      r0,#0x5002
        0x0021c0be:    f5efffd8    ....    BL       flash_ioctl ; 0xc072
;;;867        //if try fail, set back OTP->bit_mode to one bit mode
;;;868        if (!result)
        0x0021c0c2:    2800        .(      CMP      r0,#0
        0x0021c0c4:    d105        ..      BNE      0x21c0d2 ; flash_try_high_speed + 46
;;;869        {
;;;870            OTP->bit_mode = FLASH_MODE_1BIT;
        0x0021c0c6:    f894134c    ..L.    LDRB     r1,[r4,#0x34c]
        0x0021c0ca:    f0210103    !...    BIC      r1,r1,#3
        0x0021c0ce:    f884134c    ..L.    STRB     r1,[r4,#0x34c]
;;;871        }
;;;872        return result;
;;;873    }
        0x0021c0d2:    bd10        ..      POP      {r4,pc}
    malloc
;;;874    
;;;875    void *malloc(size_t size)
;;;876    {
;;;877        return os_mem_alloc(RAM_TYPE_DATA_ON, size);
        0x0021c0d4:    4601        .F      MOV      r1,r0
        0x0021c0d6:    f240336d    @.m3    MOV      r3,#0x36d
        0x0021c0da:    4a29        )J      LDR      r2,[pc,#164] ; [0x21c180] = 0x21c768
        0x0021c0dc:    2000        .       MOVS     r0,#0
        0x0021c0de:    f609be3f    ..?.    B        os_mem_alloc_intern ; 0x25d60
    calloc
;;;878    }
;;;879    
;;;880    void *calloc(size_t n, size_t size)
;;;881    {
;;;882        return os_mem_zalloc(RAM_TYPE_DATA_ON, n * size);
        0x0021c0e2:    4a27        'J      LDR      r2,[pc,#156] ; [0x21c180] = 0x21c768
        0x0021c0e4:    4341        AC      MULS     r1,r0,r1
        0x0021c0e6:    1dd2        ..      ADDS     r2,r2,#7
        0x0021c0e8:    f2403372    @.r3    MOV      r3,#0x372
        0x0021c0ec:    2000        .       MOVS     r0,#0
        0x0021c0ee:    f609be63    ..c.    B        os_mem_zalloc_intern ; 0x25db8
    realloc
;;;883    }
;;;884    
;;;885    void *realloc(void *ptr, size_t size)
;;;886    {
        0x0021c0f2:    b510        ..      PUSH     {r4,lr}
        0x0021c0f4:    460c        .F      MOV      r4,r1
        0x0021c0f6:    b108        ..      CBZ      r0,0x21c0fc ; realloc + 10
;;;887        if (ptr)
;;;888        {
;;;889            os_mem_free(ptr);
        0x0021c0f8:    f609febd    ....    BL       os_mem_free ; 0x25e76
;;;890        }
;;;891    
;;;892        return os_mem_alloc(RAM_TYPE_DATA_ON, size);
        0x0021c0fc:    4a20         J      LDR      r2,[pc,#128] ; [0x21c180] = 0x21c768
        0x0021c0fe:    4621        !F      MOV      r1,r4
        0x0021c100:    320e        .2      ADDS     r2,r2,#0xe
        0x0021c102:    e8bd4010    ...@    POP      {r4,lr}
        0x0021c106:    f44f735f    O._s    MOV      r3,#0x37c
        0x0021c10a:    2000        .       MOVS     r0,#0
        0x0021c10c:    f609be28    ..(.    B        os_mem_alloc_intern ; 0x25d60
    free
;;;893    }
;;;894    
;;;895    void free(void *ptr)
;;;896    {
;;;897        os_mem_free(ptr);
        0x0021c110:    f609beb1    ....    B        os_mem_free ; 0x25e76
    app_cb0_wdg_reset
;;;898    }
;;;899    
;;;900    void app_cb0_wdg_reset(T_WDG_MODE wdg_mode, T_SW_RESET_REASON reset_reason)
;;;901    {
;;;902        check_reset_ram.check_reset_ram_type = reset_reason;
        0x0021c114:    4a1b        .J      LDR      r2,[pc,#108] ; [0x21c184] = 0x20cf24
        0x0021c116:    70d1        .p      STRB     r1,[r2,#3]
        0x0021c118:    4a1b        .J      LDR      r2,[pc,#108] ; [0x21c188] = 0x20cf98
        0x0021c11a:    6812        .h      LDR      r2,[r2,#0]
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (901)
        0x0021c11c:    2a00        .*      CMP      r2,#0
        0x0021c11e:    d000        ..      BEQ      0x21c122 ; app_cb0_wdg_reset + 14
;;;902        check_reset_ram.check_reset_ram_type = reset_reason;
;;;903    
;;;904        if (user_wdg_cb)
;;;905        {
;;;906            if (user_wdg_cb(wdg_mode, reset_reason))
        0x0021c120:    4710        .G      BX       r2
;;;907            {
;;;908                return;
;;;909            }
;;;910        }
;;;911    
;;;912        //do something necessary before watch dog reset
;;;913    }
        0x0021c122:    4770        pG      BX       lr
    app_cb5_dfu_status
;;;914    
;;;915    void app_cb5_dfu_status(DFU_PROGRESS_STATUS status, uint32_t length)
;;;916    {
;;;917    //    uint32_t value = 0;
;;;918    //    switch(status)
;;;919    //    {
;;;920    //        case DFU_START:
;;;921    //            value = *((uint32_t *)0x180e000);
;;;922    //            DBG_DIRECT("DFU start, total length = %d, value = 0x%x", length, value);
;;;923    //            break;
;;;924    //        case DFU_DOING:
;;;925    //            value = *((uint32_t *)0x180e000);
;;;926    //            DBG_DIRECT("DFU doing, paccket length = %d, value = 0x%x", length, value);
;;;927    //            break;
;;;928    //        case DFU_END:
;;;929    //            value = *((uint32_t *)0x180e000);
;;;930    //            DBG_DIRECT("DFU end, check result = %d, value = 0x%x", length, value);
;;;931    //            break;
;;;932    //        default:
;;;933    //            DBG_DIRECT("wrong status input");
;;;934    //    }
;;;935        if (user_dfu_status_cb)
        0x0021c124:    4a19        .J      LDR      r2,[pc,#100] ; [0x21c18c] = 0x20cf9c
        0x0021c126:    6812        .h      LDR      r2,[r2,#0]
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (916)
        0x0021c128:    2a00        .*      CMP      r2,#0
        0x0021c12a:    d000        ..      BEQ      0x21c12e ; app_cb5_dfu_status + 10
;;;917    //    uint32_t value = 0;
;;;918    //    switch(status)
;;;919    //    {
;;;920    //        case DFU_START:
;;;921    //            value = *((uint32_t *)0x180e000);
;;;922    //            DBG_DIRECT("DFU start, total length = %d, value = 0x%x", length, value);
;;;923    //            break;
;;;924    //        case DFU_DOING:
;;;925    //            value = *((uint32_t *)0x180e000);
;;;926    //            DBG_DIRECT("DFU doing, paccket length = %d, value = 0x%x", length, value);
;;;927    //            break;
;;;928    //        case DFU_END:
;;;929    //            value = *((uint32_t *)0x180e000);
;;;930    //            DBG_DIRECT("DFU end, check result = %d, value = 0x%x", length, value);
;;;931    //            break;
;;;932    //        default:
;;;933    //            DBG_DIRECT("wrong status input");
;;;934    //    }
;;;935        if (user_dfu_status_cb)
;;;936        {
;;;937            if (user_dfu_status_cb(status, length))
        0x0021c12c:    4710        .G      BX       r2
;;;938            {
;;;939                return;
;;;940            }
;;;941        }
;;;942    }
        0x0021c12e:    4770        pG      BX       lr
    NVIC_DisableIRQ
;;; ..\..\..\inc\platform\cmsis\core_cm4.h
;;;1659       NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
        0x0021c130:    f000021f    ....    AND      r2,r0,#0x1f
        0x0021c134:    2101        .!      MOVS     r1,#1
        0x0021c136:    4091        .@      LSLS     r1,r1,r2
        0x0021c138:    0940        @.      LSRS     r0,r0,#5
        0x0021c13a:    0080        ..      LSLS     r0,r0,#2
        0x0021c13c:    f10020e0    ...     ADD      r0,r0,#0xe000e000
        0x0021c140:    f8c01180    ....    STR      r1,[r0,#0x180]
;;;1660   }
        0x0021c144:    4770        pG      BX       lr
    $d
        0x0021c146:    0000        ..      DCW    0
        0x0021c148:    53206e49    In S    DCD    1394634313
        0x0021c14c:    4d20436f    oC M    DCD    1293960047
        0x0021c150:    0065646f    ode.    DCD    6644847
        0x0021c154:    4e524157    WARN    DCD    1314013527
        0x0021c158:    3a474e49    ING:    DCD    977751625
        0x0021c15c:    206e4920     In     DCD    544098592
        0x0021c160:    20494348    HCI     DCD    541672264
        0x0021c164:    65646f4d    Mode    DCD    1701080909
        0x0021c168:    6977202c    , wi    DCD    1769414700
        0x0021c16c:    6e206c6c    ll n    DCD    1847618668
        0x0021c170:    7220746f    ot r    DCD    1914729583
        0x0021c174:    41206e75    un A    DCD    1092644469
        0x0021c178:    54205050    PP T    DCD    1411403856
        0x0021c17c:    006b7361    ask.    DCD    7041889
        0x0021c180:    0021c768    h.!.    DCD    2213736
        0x0021c184:    0020cf24    $. .    DCD    2150180
        0x0021c188:    0020cf98    .. .    DCD    2150296
        0x0021c18c:    0020cf9c    .. .    DCD    2150300
    $t
    .text
    UART_Init
;;; .\..\..\..\src\mcu\peripheral\rtl876x_uart.c
;;;30     {
        0x0021c190:    b510        ..      PUSH     {r4,lr}
;;;31         assert_param(IS_UART_PERIPH(UARTx));
;;;32         assert_param(IS_UART_WORD_LENGTH(UART_InitStruct->wordLen));
;;;33         assert_param(IS_UART_PARITY(UART_InitStruct->parity));
;;;34         assert_param(IS_UART_STOPBITS(UART_InitStruct->stopBits));
;;;35         assert_param(IS_UART_AUTO_FLOW_CTRL(UART_InitStruct->autoFlowCtrl));
;;;36         assert_param(IS_UART_DMA_CFG(UART_InitStruct->dmaEn));
;;;37         assert_param(IS_UART_RX_FIFO_TRIGGER_LEVEL(UART_InitStruct->rxTriggerLevel));
;;;38         assert_param(IS_UART_IDLE_TIME(UART_InitStruct->idle_time));
;;;39     
;;;40         //clear DLAB bit
;;;41         UARTx->LCR &= LCR_DLAB_Reset;
        0x0021c192:    68c2        .h      LDR      r2,[r0,#0xc]
        0x0021c194:    f0220280    "...    BIC      r2,r2,#0x80
        0x0021c198:    60c2        .`      STR      r2,[r0,#0xc]
;;;42         //disable all interrupt
;;;43         UARTx->DLH_INTCR = 0x00;
        0x0021c19a:    2200        ."      MOVS     r2,#0
        0x0021c19c:    6042        B`      STR      r2,[r0,#4]
;;;44     
;;;45         //read to clear Line Status Reg
;;;46         UARTx->LSR;
        0x0021c19e:    6942        Bi      LDR      r2,[r0,#0x14]
;;;47         //clear FIFO
;;;48         UARTx->INTID_FCR |= (FCR_CLEAR_RX_FIFO_Set | FCR_CLEAR_TX_FIFO_Set);
        0x0021c1a0:    6882        .h      LDR      r2,[r0,#8]
        0x0021c1a2:    f0420206    B...    ORR      r2,r2,#6
        0x0021c1a6:    6082        .`      STR      r2,[r0,#8]
;;;49     
;;;50         //set baudrate, firstly set DLAB bit
;;;51         UARTx->LCR |= LCR_DLAB_Set;
        0x0021c1a8:    68c2        .h      LDR      r2,[r0,#0xc]
        0x0021c1aa:    f0420280    B...    ORR      r2,r2,#0x80
        0x0021c1ae:    60c2        .`      STR      r2,[r0,#0xc]
;;;52         //set calibration parameters(OVSR)
;;;53         UARTx->STSR &= ~0xF0;
        0x0021c1b0:    6a02        .j      LDR      r2,[r0,#0x20]
        0x0021c1b2:    f02202f0    "...    BIC      r2,r2,#0xf0
        0x0021c1b6:    6202        .b      STR      r2,[r0,#0x20]
;;;54         UARTx->STSR |= (UART_InitStruct->ovsr << 4);
        0x0021c1b8:    6a02        .j      LDR      r2,[r0,#0x20]
        0x0021c1ba:    888b        ..      LDRH     r3,[r1,#4]
        0x0021c1bc:    ea421203    B...    ORR      r2,r2,r3,LSL #4
        0x0021c1c0:    6202        .b      STR      r2,[r0,#0x20]
;;;55         //set calibration parameters(OVSR_adj)
;;;56         UARTx->SPR &= (~(0x7ff << 16));
        0x0021c1c2:    69c2        .i      LDR      r2,[r0,#0x1c]
        0x0021c1c4:    4b64        dK      LDR      r3,[pc,#400] ; [0x21c358] = 0xf800ffff
        0x0021c1c6:    401a        .@      ANDS     r2,r2,r3
        0x0021c1c8:    61c2        .a      STR      r2,[r0,#0x1c]
;;;57         UARTx->SPR |= (UART_InitStruct->ovsr_adj << 16);
        0x0021c1ca:    69c2        .i      LDR      r2,[r0,#0x1c]
        0x0021c1cc:    880b        ..      LDRH     r3,[r1,#0]
        0x0021c1ce:    ea424203    B..B    ORR      r2,r2,r3,LSL #16
        0x0021c1d2:    61c2        .a      STR      r2,[r0,#0x1c]
;;;58         //set DLL and DLH
;;;59         UARTx->DLL = (UART_InitStruct->div & 0x00FF);
        0x0021c1d4:    788a        .x      LDRB     r2,[r1,#2]
        0x0021c1d6:    6002        .`      STR      r2,[r0,#0]
;;;60         UARTx->DLH_INTCR = ((UART_InitStruct->div & 0xFF00) >> 8);
        0x0021c1d8:    884a        J.      LDRH     r2,[r1,#2]
        0x0021c1da:    0a12        ..      LSRS     r2,r2,#8
        0x0021c1dc:    6042        B`      STR      r2,[r0,#4]
;;;61         //after set baudrate, clear DLAB bit
;;;62         UARTx->LCR &= LCR_DLAB_Reset;
        0x0021c1de:    68c2        .h      LDR      r2,[r0,#0xc]
        0x0021c1e0:    f0220280    "...    BIC      r2,r2,#0x80
        0x0021c1e4:    60c2        .`      STR      r2,[r0,#0xc]
;;;63     
;;;64         //set LCR reg
;;;65         UARTx->LCR = (UART_InitStruct->parity | UART_InitStruct->stopBits | UART_InitStruct->wordLen);
        0x0021c1e6:    890a        ..      LDRH     r2,[r1,#8]
        0x0021c1e8:    894b        K.      LDRH     r3,[r1,#0xa]
        0x0021c1ea:    431a        .C      ORRS     r2,r2,r3
        0x0021c1ec:    88cb        ..      LDRH     r3,[r1,#6]
        0x0021c1ee:    431a        .C      ORRS     r2,r2,r3
        0x0021c1f0:    60c2        .`      STR      r2,[r0,#0xc]
;;;66         //set FCR reg, FIFO must enable
;;;67         UARTx->INTID_FCR = ((1 << 0) | UART_InitStruct->rxTriggerLevel << 8 | UART_InitStruct->dmaEn);
        0x0021c1f2:    89ca        ..      LDRH     r2,[r1,#0xe]
        0x0021c1f4:    2301        .#      MOVS     r3,#1
        0x0021c1f6:    eb032202    ..."    ADD      r2,r3,r2,LSL #8
        0x0021c1fa:    8a0b        ..      LDRH     r3,[r1,#0x10]
        0x0021c1fc:    431a        .C      ORRS     r2,r2,r3
        0x0021c1fe:    6082        .`      STR      r2,[r0,#8]
;;;68     
;;;69         /* auto flow control */
;;;70         UARTx->MCR &= (~((1 << 5) | (1 << 1)));
        0x0021c200:    6902        .i      LDR      r2,[r0,#0x10]
        0x0021c202:    f0220222    ".".    BIC      r2,r2,#0x22
        0x0021c206:    6102        .a      STR      r2,[r0,#0x10]
;;;71         UARTx->MCR |= UART_InitStruct->autoFlowCtrl;
        0x0021c208:    6902        .i      LDR      r2,[r0,#0x10]
        0x0021c20a:    898b        ..      LDRH     r3,[r1,#0xc]
        0x0021c20c:    431a        .C      ORRS     r2,r2,r3
        0x0021c20e:    6102        .a      STR      r2,[r0,#0x10]
;;;72     
;;;73         /* set rx idle time */
;;;74         UARTx->RX_IDLE_INTTCR = (UART_InitStruct->idle_time);
        0x0021c210:    8a4a        J.      LDRH     r2,[r1,#0x12]
        0x0021c212:    6402        .d      STR      r2,[r0,#0x40]
;;;75     
;;;76         if (UART_InitStruct->dmaEn == UART_DMA_ENABLE)
        0x0021c214:    8a0a        ..      LDRH     r2,[r1,#0x10]
        0x0021c216:    2a08        .*      CMP      r2,#8
        0x0021c218:    d11a        ..      BNE      0x21c250 ; UART_Init + 192
;;;77         {
;;;78             /* Config UART Tx dma parameter */
;;;79             if (UART_InitStruct->TxDmaEn != DISABLE)
        0x0021c21a:    8aca        ..      LDRH     r2,[r1,#0x16]
        0x0021c21c:    b152        R.      CBZ      r2,0x21c234 ; UART_Init + 164
;;;80             {
;;;81                 /* Mask uart TX threshold value */
;;;82                 UARTx->MISCR &= ~(0x1f << 3);
        0x0021c21e:    6a82        .j      LDR      r2,[r0,#0x28]
        0x0021c220:    f02202f8    "...    BIC      r2,r2,#0xf8
        0x0021c224:    6282        .b      STR      r2,[r0,#0x28]
;;;83                 UARTx->MISCR |= ((UART_InitStruct->TxWaterlevel) << 3) | BIT(1);
        0x0021c226:    6a82        .j      LDR      r2,[r0,#0x28]
        0x0021c228:    7d0b        .}      LDRB     r3,[r1,#0x14]
        0x0021c22a:    2402        .$      MOVS     r4,#2
        0x0021c22c:    ea4403c3    D...    ORR      r3,r4,r3,LSL #3
        0x0021c230:    431a        .C      ORRS     r2,r2,r3
        0x0021c232:    6282        .b      STR      r2,[r0,#0x28]
;;;84             }
;;;85             /* Config UART Rx dma parameter */
;;;86             if (UART_InitStruct->RxDmaEn != DISABLE)
        0x0021c234:    8b0a        ..      LDRH     r2,[r1,#0x18]
        0x0021c236:    2a00        .*      CMP      r2,#0
        0x0021c238:    d00a        ..      BEQ      0x21c250 ; UART_Init + 192
;;;87             {
;;;88                 /* Mask uart RX threshold value */
;;;89                 UARTx->MISCR &= ~(0x3f << 8);
        0x0021c23a:    6a82        .j      LDR      r2,[r0,#0x28]
        0x0021c23c:    f422527c    ".|R    BIC      r2,r2,#0x3f00
        0x0021c240:    6282        .b      STR      r2,[r0,#0x28]
;;;90                 UARTx->MISCR |= (UART_InitStruct->RxWaterlevel << 8) | BIT(2);
        0x0021c242:    6a82        .j      LDR      r2,[r0,#0x28]
        0x0021c244:    7d49        I}      LDRB     r1,[r1,#0x15]
        0x0021c246:    2304        .#      MOVS     r3,#4
        0x0021c248:    ea432101    C..!    ORR      r1,r3,r1,LSL #8
        0x0021c24c:    430a        .C      ORRS     r2,r2,r1
        0x0021c24e:    6282        .b      STR      r2,[r0,#0x28]
;;;91             }
;;;92         }
;;;93     
;;;94         return;
;;;95     }
        0x0021c250:    bd10        ..      POP      {r4,pc}
    UART_DeInit
        0x0021c252:    4942        BI      LDR      r1,[pc,#264] ; [0x21c35c] = 0x40012000
        0x0021c254:    4288        .B      CMP      r0,r1
;;;96     
;;;97     /**
;;;98       * @brief  Deinitializes the UART peripheral registers to their default reset values(turn off UART clock).
;;;99       * @param  UARTx: selected UART peripheral.
;;;100      * @retval None
;;;101      */
;;;102    void UART_DeInit(UART_TypeDef *UARTx)
;;;103    {
        0x0021c256:    d103        ..      BNE      0x21c260 ; UART_DeInit + 14
;;;104        assert_param(IS_UART_PERIPH(UARTx));
;;;105    
;;;106        if (UARTx == UART)
;;;107        {
;;;108            RCC_PeriphClockCmd(APBPeriph_UART0, APBPeriph_UART0_CLOCK, DISABLE);
        0x0021c258:    2200        ."      MOVS     r2,#0
        0x0021c25a:    4941        AI      LDR      r1,[pc,#260] ; [0x21c360] = 0x40000001
        0x0021c25c:    4841        AH      LDR      r0,[pc,#260] ; [0x21c364] = 0x8000001
        0x0021c25e:    e00d        ..      B        0x21c27c ; UART_DeInit + 42
;;;109        }
;;;110        else if (UARTx == UART1)
        0x0021c260:    4941        AI      LDR      r1,[pc,#260] ; [0x21c368] = 0x40011000
        0x0021c262:    4288        .B      CMP      r0,r1
        0x0021c264:    d103        ..      BNE      0x21c26e ; UART_DeInit + 28
;;;111        {
;;;112            RCC_PeriphClockCmd(APBPeriph_UART1, APBPeriph_UART1_CLOCK, DISABLE);
        0x0021c266:    2200        ."      MOVS     r2,#0
        0x0021c268:    4940        @I      LDR      r1,[pc,#256] ; [0x21c36c] = 0x20001000
        0x0021c26a:    1480        ..      ASRS     r0,r0,#18
        0x0021c26c:    e006        ..      B        0x21c27c ; UART_DeInit + 42
;;;113        }
;;;114        else if (UARTx == UART2)
        0x0021c26e:    4940        @I      LDR      r1,[pc,#256] ; [0x21c370] = 0x40024000
        0x0021c270:    4288        .B      CMP      r0,r1
        0x0021c272:    d105        ..      BNE      0x21c280 ; UART_DeInit + 46
;;;115        {
;;;116            RCC_PeriphClockCmd(APBPeriph_UART2, APBPeriph_UART2_CLOCK, DISABLE);
        0x0021c274:    483b        ;H      LDR      r0,[pc,#236] ; [0x21c364] = 0x8000001
        0x0021c276:    2200        ."      MOVS     r2,#0
        0x0021c278:    493e        >I      LDR      r1,[pc,#248] ; [0x21c374] = 0x20000400
        0x0021c27a:    1c40        @.      ADDS     r0,r0,#1
        0x0021c27c:    f7ebbd84    ....    B        RCC_PeriphClockCmd ; 0x207d88
;;;117        }
;;;118        return;
;;;119    }
        0x0021c280:    4770        pG      BX       lr
    UART_StructInit
;;;120    
;;;121    /**
;;;122      * @brief  Fills each UART_InitStruct member with its default value.
;;;123      * @param  UART_InitStruct: pointer to an UART_InitTypeDef structure which will be initialized.
;;;124      * @retval None
;;;125      */
;;;126    void UART_StructInit(UART_InitTypeDef *UART_InitStruct)
;;;127    {
;;;128    		#if 0
;;;129        //115200 default
;;;130        UART_InitStruct->div            = 20;
;;;131        UART_InitStruct->ovsr           = 12;
;;;132        UART_InitStruct->ovsr_adj       = 0x252;
;;;133    	  #else
;;;134    	  //9600 bps
;;;135        UART_InitStruct->div            = 271;
        0x0021c282:    f240110f    @...    MOV      r1,#0x10f
        0x0021c286:    8041        A.      STRH     r1,[r0,#2]
;;;136        UART_InitStruct->ovsr           = 10;
        0x0021c288:    210a        .!      MOVS     r1,#0xa
        0x0021c28a:    8081        ..      STRH     r1,[r0,#4]
;;;137        UART_InitStruct->ovsr_adj       = 0x24A;
        0x0021c28c:    f240214a    @.J!    MOV      r1,#0x24a
        0x0021c290:    8001        ..      STRH     r1,[r0,#0]
;;;138    	
;;;139    		#endif
;;;140        UART_InitStruct->parity         = UART_PARITY_NO_PARTY;
        0x0021c292:    2100        .!      MOVS     r1,#0
        0x0021c294:    8101        ..      STRH     r1,[r0,#8]
;;;141        UART_InitStruct->stopBits       = UART_STOP_BITS_1;
        0x0021c296:    8141        A.      STRH     r1,[r0,#0xa]
;;;142        UART_InitStruct->wordLen        = UART_WROD_LENGTH_8BIT;
        0x0021c298:    2201        ."      MOVS     r2,#1
        0x0021c29a:    80c2        ..      STRH     r2,[r0,#6]
;;;143        UART_InitStruct->dmaEn          = UART_DMA_DISABLE;
        0x0021c29c:    8201        ..      STRH     r1,[r0,#0x10]
;;;144        UART_InitStruct->autoFlowCtrl   = UART_AUTO_FLOW_CTRL_DIS;
        0x0021c29e:    8181        ..      STRH     r1,[r0,#0xc]
;;;145        UART_InitStruct->rxTriggerLevel = 16;                       //1~29
        0x0021c2a0:    2310        .#      MOVS     r3,#0x10
        0x0021c2a2:    81c3        ..      STRH     r3,[r0,#0xe]
;;;146        UART_InitStruct->idle_time      = UART_RX_IDLE_2BYTE;      //idle interrupt wait time
        0x0021c2a4:    8242        B.      STRH     r2,[r0,#0x12]
;;;147        UART_InitStruct->TxWaterlevel   = 15;     //Better to equal TX_FIFO_SIZE(16)- GDMA_MSize
        0x0021c2a6:    230f        .#      MOVS     r3,#0xf
        0x0021c2a8:    7503        .u      STRB     r3,[r0,#0x14]
;;;148        UART_InitStruct->RxWaterlevel   = 1;      //Better to equal GDMA_MSize
        0x0021c2aa:    7542        Bu      STRB     r2,[r0,#0x15]
;;;149        UART_InitStruct->TxDmaEn   = DISABLE;
        0x0021c2ac:    82c1        ..      STRH     r1,[r0,#0x16]
;;;150        UART_InitStruct->RxDmaEn   = DISABLE;
        0x0021c2ae:    8301        ..      STRH     r1,[r0,#0x18]
;;;151        return;
;;;152    }
        0x0021c2b0:    4770        pG      BX       lr
    UART_ReceiveData
        0x0021c2b2:    e002        ..      B        0x21c2ba ; UART_ReceiveData + 8
        0x0021c2b4:    6a43        Cj      LDR      r3,[r0,#0x24]
        0x0021c2b6:    f8013b01    ...;    STRB     r3,[r1],#1
;;;153    
;;;154    /**
;;;155      * @brief  Receive data from rx FIFO.
;;;156      * @param  UARTx: selected UART peripheral.
;;;157      * @param[out]  outBuf: buffer to save data read from UART FIFO.
;;;158      * @param  count: number of data to be read.
;;;159      * @retval None
;;;160      */
;;;161    void UART_ReceiveData(UART_TypeDef *UARTx, uint8_t *outBuf, uint16_t count)
;;;162    {
;;;163        /* Check the parameters */
;;;164        assert_param(IS_UART_PERIPH(UARTx));
;;;165    
;;;166        while (count--)
        0x0021c2ba:    1e52        R.      SUBS     r2,r2,#1
        0x0021c2bc:    b292        ..      UXTH     r2,r2
        0x0021c2be:    d2f9        ..      BCS      0x21c2b4 ; UART_ReceiveData + 2
;;;167        {
;;;168            *outBuf++ = (uint8_t)UARTx->RB_THR;
;;;169        }
;;;170    
;;;171        return;
;;;172    }
        0x0021c2c0:    4770        pG      BX       lr
    UART_SendData
        0x0021c2c2:    e002        ..      B        0x21c2ca ; UART_SendData + 8
        0x0021c2c4:    f8113b01    ...;    LDRB     r3,[r1],#1
        0x0021c2c8:    6243        Cb      STR      r3,[r0,#0x24]
;;;173    
;;;174    /**
;;;175      * @brief  Send data to tx FIFO.
;;;176      * @param  UARTx: selected UART peripheral.
;;;177      * @param  inBuf: buffer to be written to Tx FIFO.
;;;178      * @param  count: number of data to be written.
;;;179      * @retval None
;;;180      */
;;;181    void UART_SendData(UART_TypeDef *UARTx, const uint8_t *inBuf, uint16_t count)
;;;182    {
;;;183        /* Check the parameters */
;;;184        assert_param(IS_UART_PERIPH(UARTx));
;;;185    
;;;186        while (count--)
        0x0021c2ca:    1e52        R.      SUBS     r2,r2,#1
        0x0021c2cc:    b292        ..      UXTH     r2,r2
        0x0021c2ce:    d2f9        ..      BCS      0x21c2c4 ; UART_SendData + 2
;;;187        {
;;;188            UARTx->RB_THR = *inBuf++;
;;;189        }
;;;190    
;;;191        return;
;;;192    }
        0x0021c2d0:    4770        pG      BX       lr
    UART_INTConfig
        0x0021c2d2:    060b        ..      LSLS     r3,r1,#24
;;;193    
;;;194    /**
;;;195      * @brief  Enables or disables the specified UART interrupts.
;;;196      * @param  UARTx: selected UARTx peripheral.
;;;197      * @param  UART_IT: specifies the UART interrupts sources to be enabled or disabled.
;;;198      *   This parameter can be any combination of the following values:
;;;199      *     @arg UART_INT_RD_AVA: enable Rx data avaliable interrupt.
;;;200      *     @arg UART_INT_FIFO_EMPTY: enable FIFO empty interrupt.
;;;201      *     @arg UART_INT_LINE_STS: enable line status interrupt.
;;;202      *     @arg UART_INT_MODEM_STS: enable modem status interrupt.
;;;203      * @param  NewState: new state of the specified UART interrupts.
;;;204      *   This parameter can be: ENABLE or DISABLE.
;;;205      * @retval None
;;;206      */
;;;207    void UART_INTConfig(UART_TypeDef *UARTx, uint32_t UART_IT, FunctionalState newState)
;;;208    {
        0x0021c2d4:    d50d        ..      BPL      0x21c2f2 ; UART_INTConfig + 32
;;;209        /* Check the parameters */
;;;210        assert_param(IS_UART_PERIPH(UARTx));
;;;211        assert_param(IS_FUNCTIONAL_STATE(newState));
;;;212        assert_param(IS_UART_IT(UART_IT));
;;;213    
;;;214        if (UART_IT & UART_INT_IDLE)
;;;215        {
;;;216            if (newState == ENABLE)
        0x0021c2d6:    2a01        .*      CMP      r2,#1
        0x0021c2d8:    d013        ..      BEQ      0x21c302 ; UART_INTConfig + 48
;;;217            {
;;;218                UARTx->STSR  |= BIT3;
;;;219                UARTx->STSR  &= (~BIT3);
;;;220                UARTx->RXIDLE_INTCR |= BIT0;
;;;221                UARTx->RX_IDLE_INTTCR |= BIT31;
;;;222            }
;;;223            else
;;;224            {
;;;225                UARTx->RX_IDLE_INTTCR &= (~BIT31);
        0x0021c2da:    6c03        .l      LDR      r3,[r0,#0x40]
        0x0021c2dc:    f0234300    #..C    BIC      r3,r3,#0x80000000
        0x0021c2e0:    6403        .d      STR      r3,[r0,#0x40]
;;;226                UARTx->RX_IDLE_SR |= BIT0;
        0x0021c2e2:    6c43        Cl      LDR      r3,[r0,#0x44]
        0x0021c2e4:    f0430301    C...    ORR      r3,r3,#1
        0x0021c2e8:    6443        Cd      STR      r3,[r0,#0x44]
;;;227                UARTx->RXIDLE_INTCR &= (~BIT0);
        0x0021c2ea:    6c83        .l      LDR      r3,[r0,#0x48]
        0x0021c2ec:    f0230301    #...    BIC      r3,r3,#1
        0x0021c2f0:    6483        .d      STR      r3,[r0,#0x48]
;;;228            }
;;;229        }
;;;230        if (UART_IT & 0xf)
        0x0021c2f2:    070b        ..      LSLS     r3,r1,#28
        0x0021c2f4:    d004        ..      BEQ      0x21c300 ; UART_INTConfig + 46
;;;231        {
;;;232            if (newState == ENABLE)
        0x0021c2f6:    2a01        .*      CMP      r2,#1
        0x0021c2f8:    6842        Bh      LDR      r2,[r0,#4]
        0x0021c2fa:    d013        ..      BEQ      0x21c324 ; UART_INTConfig + 82
;;;233            {
;;;234                /* Enable the selected UARTx interrupts */
;;;235                UARTx->DLH_INTCR |= UART_IT;
;;;236            }
;;;237            else
;;;238            {
;;;239                /* Disable the selected UARTx interrupts */
;;;240                UARTx->DLH_INTCR &= (uint32_t)~UART_IT;
        0x0021c2fc:    438a        .C      BICS     r2,r2,r1
        0x0021c2fe:    6042        B`      STR      r2,[r0,#4]
;;;241            }
;;;242        }
;;;243        return;
;;;244    }
        0x0021c300:    4770        pG      BX       lr
        0x0021c302:    6a03        .j      LDR      r3,[r0,#0x20]
        0x0021c304:    f0430308    C...    ORR      r3,r3,#8
        0x0021c308:    6203        .b      STR      r3,[r0,#0x20]
        0x0021c30a:    6a03        .j      LDR      r3,[r0,#0x20]
        0x0021c30c:    f0230308    #...    BIC      r3,r3,#8
        0x0021c310:    6203        .b      STR      r3,[r0,#0x20]
        0x0021c312:    6c83        .l      LDR      r3,[r0,#0x48]
        0x0021c314:    f0430301    C...    ORR      r3,r3,#1
        0x0021c318:    6483        .d      STR      r3,[r0,#0x48]
        0x0021c31a:    6c03        .l      LDR      r3,[r0,#0x40]
        0x0021c31c:    f0434300    C..C    ORR      r3,r3,#0x80000000
        0x0021c320:    6403        .d      STR      r3,[r0,#0x40]
        0x0021c322:    e7e6        ..      B        0x21c2f2 ; UART_INTConfig + 32
        0x0021c324:    430a        .C      ORRS     r2,r2,r1
        0x0021c326:    e7ea        ..      B        0x21c2fe ; UART_INTConfig + 44
    UART_GetFlagState
;;;245    
;;;246    /**
;;;247      * @brief  Checks whether the specified UART flag is set or not.
;;;248      * @param  UARTx: selected UART peripheral.
;;;249      * @param  UART_FLAG: specifies the flag to check.
;;;250      *   This parameter can be one of the following values:
;;;251      *     @arg UART_FLAG_RX_DATA_RDY: rx data is avaliable.
;;;252      *     @arg UART_FLAG_RX_OVERRUN: rx overrun.
;;;253      *     @arg UART_FLAG_PARTY_ERR: parity error.
;;;254      *     @arg UART_FLAG_FRAME_ERR: UARTx frame error.
;;;255      *     @arg UART_FLAG_BREAK_ERR: UARTx break error.
;;;256      *     @arg UART_FLAG_THR_EMPTY: tx FIFO is empty.
;;;257      *     @arg UART_FLAG_THR_TSR_EMPTY: tx FIFO and tx shift reg are both empty.
;;;258      *     @arg UART_FLAG_RX_FIFO_ERR: rx FIFO error.
;;;259      *     @arg UART_FLAG_RX_IDLE.
;;;260      * @retval The new state of UART_FLAG (SET or RESET).
;;;261      */
;;;262    FlagStatus UART_GetFlagState(UART_TypeDef *UARTx, uint32_t UART_FLAG)
;;;263    {
        0x0021c328:    4602        .F      MOV      r2,r0
        0x0021c32a:    2000        .       MOVS     r0,#0
        0x0021c32c:    f5b17f80    ....    CMP      r1,#0x100
;;; .\..\..\..\src\mcu\peripheral\rtl876x_uart.c (263)
        0x0021c330:    d004        ..      BEQ      0x21c33c ; UART_GetFlagState + 20
;;;264        FlagStatus bitstatus = RESET;
;;;265    
;;;266        /* Check the parameters */
;;;267        assert_param(IS_UART_PERIPH(UARTx));
;;;268        assert_param(IS_UART_GET_FLAG(UART_FLAG));
;;;269    
;;;270        if (UART_FLAG != UART_FLAG_RX_IDLE)
;;;271        {
;;;272            if (UARTx->LSR & UART_FLAG)
        0x0021c332:    6952        Ri      LDR      r2,[r2,#0x14]
        0x0021c334:    420a        .B      TST      r2,r1
        0x0021c336:    d000        ..      BEQ      0x21c33a ; UART_GetFlagState + 18
;;;273            {
;;;274                bitstatus = SET;
        0x0021c338:    2001        .       MOVS     r0,#1
        0x0021c33a:    4770        pG      BX       lr
;;;275            }
;;;276        }
;;;277        else
;;;278        {
;;;279            if (UARTx->RX_IDLE_SR & BIT(0))
        0x0021c33c:    6c51        Ql      LDR      r1,[r2,#0x44]
        0x0021c33e:    07c9        ..      LSLS     r1,r1,#31
        0x0021c340:    d1fa        ..      BNE      0x21c338 ; UART_GetFlagState + 16
;;;280            {
;;;281                bitstatus = SET;
;;;282            }
;;;283        }
;;;284        return bitstatus;
;;;285    
;;;286    }
        0x0021c342:    4770        pG      BX       lr
    UART_LoopBackCmd
;;;287    
;;;288    /**
;;;289      *@brief  UART loop back mode config.
;;;290      *@param  UARTx: selected UART peripheral.
;;;291      *@param  NewState: new state of the DMA Channelx.
;;;292      *   This parameter can be: ENABLE or DISABLE.
;;;293      *@retval None.
;;;294      */
;;;295    void UART_LoopBackCmd(UART_TypeDef *UARTx, FunctionalState NewState)
;;;296    {
;;;297        assert_param(IS_UART_PERIPH(UARTx));
;;;298    
;;;299        if (NewState == ENABLE)
        0x0021c344:    2901        .)      CMP      r1,#1
        0x0021c346:    6901        .i      LDR      r1,[r0,#0x10]
;;; .\..\..\..\src\mcu\peripheral\rtl876x_uart.c (296)
        0x0021c348:    d003        ..      BEQ      0x21c352 ; UART_LoopBackCmd + 14
        0x0021c34a:    f0210110    !...    BIC      r1,r1,#0x10
;;;297        assert_param(IS_UART_PERIPH(UARTx));
;;;298    
;;;299        if (NewState == ENABLE)
;;;300        {
;;;301            UARTx->MCR |= BIT4;
        0x0021c34e:    6101        .a      STR      r1,[r0,#0x10]
        0x0021c350:    4770        pG      BX       lr
        0x0021c352:    f0410110    A...    ORR      r1,r1,#0x10
        0x0021c356:    e7fa        ..      B        0x21c34e ; UART_LoopBackCmd + 10
    $d
        0x0021c358:    f800ffff    ....    DCD    4160815103
        0x0021c35c:    40012000    . .@    DCD    1073815552
        0x0021c360:    40000001    ...@    DCD    1073741825
        0x0021c364:    08000001    ....    DCD    134217729
        0x0021c368:    40011000    ...@    DCD    1073811456
        0x0021c36c:    20001000    ...     DCD    536875008
        0x0021c370:    40024000    .@.@    DCD    1073889280
        0x0021c374:    20000400    ...     DCD    536871936
    $t
    .text
    link_mgr_add_device
;;; ..\..\..\src\sample\ble_central\link_mgr.c
;;;66     {
        0x0021c378:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0021c37c:    4d15        .M      LDR      r5,[pc,#84] ; [0x21c3d4] = 0x20d378
;;; ..\..\..\src\sample\ble_central\link_mgr.c (66)
        0x0021c37e:    4607        .F      MOV      r7,r0
        0x0021c380:    4688        .F      MOV      r8,r1
        0x0021c382:    7828        (x      LDRB     r0,[r5,#0]
        0x0021c384:    2806        .(      CMP      r0,#6
        0x0021c386:    d21e        ..      BCS      0x21c3c6 ; link_mgr_add_device + 78
;;;67         /* If result count not at max */
;;;68         if (dev_list_count < APP_MAX_DEVICE_INFO)
;;;69         {
;;;70             uint8_t i;
;;;71             /* Check if device is already in device list*/
;;;72             for (i = 0; i < dev_list_count; i++)
        0x0021c388:    2400        .$      MOVS     r4,#0
        0x0021c38a:    1c6e        n.      ADDS     r6,r5,#1
        0x0021c38c:    e009        ..      B        0x21c3a2 ; link_mgr_add_device + 42
        0x0021c38e:    ebc400c4    ....    RSB      r0,r4,r4,LSL #3
        0x0021c392:    1981        ..      ADDS     r1,r0,r6
        0x0021c394:    2206        ."      MOVS     r2,#6
        0x0021c396:    4638        8F      MOV      r0,r7
        0x0021c398:    f63dfd34    =.4.    BL       memcmp ; 0x59e04
        0x0021c39c:    b180        ..      CBZ      r0,0x21c3c0 ; link_mgr_add_device + 72
        0x0021c39e:    1c64        d.      ADDS     r4,r4,#1
        0x0021c3a0:    b2e4        ..      UXTB     r4,r4
        0x0021c3a2:    7828        (x      LDRB     r0,[r5,#0]
        0x0021c3a4:    4284        .B      CMP      r4,r0
        0x0021c3a6:    d3f2        ..      BCC      0x21c38e ; link_mgr_add_device + 22
;;;73             {
;;;74                 if (memcmp(bd_addr, dev_list[i].bd_addr, GAP_BD_ADDR_LEN) == 0)
;;;75                 {
;;;76                     return true;
;;;77                 }
;;;78             }
;;;79     
;;;80             /*Add addr to device list list*/
;;;81             memcpy(dev_list[dev_list_count].bd_addr, bd_addr, GAP_BD_ADDR_LEN);
        0x0021c3a8:    b2c0        ..      UXTB     r0,r0
        0x0021c3aa:    ebc001c0    ....    RSB      r1,r0,r0,LSL #3
        0x0021c3ae:    4431        1D      ADD      r1,r1,r6
        0x0021c3b0:    683a        :h      LDR      r2,[r7,#0]
        0x0021c3b2:    600a        .`      STR      r2,[r1,#0]
        0x0021c3b4:    88ba        ..      LDRH     r2,[r7,#4]
        0x0021c3b6:    808a        ..      STRH     r2,[r1,#4]
;;;82             dev_list[dev_list_count].bd_type = bd_type;
        0x0021c3b8:    f8818006    ....    STRB     r8,[r1,#6]
        0x0021c3bc:    1c40        @.      ADDS     r0,r0,#1
;;;83     
;;;84             /*Increment device list count*/
;;;85             dev_list_count++;
        0x0021c3be:    7028        (p      STRB     r0,[r5,#0]
        0x0021c3c0:    2001        .       MOVS     r0,#1
        0x0021c3c2:    e8bd81f0    ....    POP      {r4-r8,pc}
;;;86         }
;;;87         else
;;;88         {
;;;89             return false;
        0x0021c3c6:    2000        .       MOVS     r0,#0
;;;90         }
;;;91         return true;
;;;92     }
        0x0021c3c8:    e7fb        ..      B        0x21c3c2 ; link_mgr_add_device + 74
    link_mgr_clear_device_list
;;;93     
;;;94     /**
;;;95      * @brief Clear device list.
;;;96      * @retval None.
;;;97      */
;;;98     void link_mgr_clear_device_list(void)
;;;99     {
;;;100        dev_list_count = 0;
        0x0021c3ca:    4902        .I      LDR      r1,[pc,#8] ; [0x21c3d4] = 0x20d378
        0x0021c3cc:    2000        .       MOVS     r0,#0
        0x0021c3ce:    7008        .p      STRB     r0,[r1,#0]
;;;101    }
        0x0021c3d0:    4770        pG      BX       lr
    $d
        0x0021c3d2:    0000        ..      DCW    0
        0x0021c3d4:    0020d378    x. .    DCD    2151288
    $t
    .text
    load_overlay
;;; .\..\..\..\src\mcu\rtl876x\overlay_mgr.c
;;;116    {
        0x0021c3d8:    b510        ..      PUSH     {r4,lr}
        0x0021c3da:    2803        .(      CMP      r0,#3
;;; .\..\..\..\src\mcu\rtl876x\overlay_mgr.c (116)
        0x0021c3dc:    d301        ..      BCC      0x21c3e2 ; load_overlay + 10
;;;117        const T_OVERLAY_SECTION *selected_scenario;
;;;118    
;;;119        if (scenario_idx >= OVERLAY_SCENARIO_NUM)
;;;120        {
;;;121            return false;
        0x0021c3de:    2000        .       MOVS     r0,#0
        0x0021c3e0:    bd10        ..      POP      {r4,pc}
;;;122        }
;;;123    
;;;124        selected_scenario = &overlay_sections[scenario_idx];
        0x0021c3e2:    491a        .I      LDR      r1,[pc,#104] ; [0x21c44c] = 0x20cf2c
        0x0021c3e4:    eb0000c0    ....    ADD      r0,r0,r0,LSL #3
        0x0021c3e8:    eb010480    ....    ADD      r4,r1,r0,LSL #2
;;;125    
;;;126        if (memcmp(selected_scenario->signature, scenario_name, 8) == 0)
        0x0021c3ec:    2208        ."      MOVS     r2,#8
        0x0021c3ee:    4918        .I      LDR      r1,[pc,#96] ; [0x21c450] = 0x20d3d4
        0x0021c3f0:    6820         h      LDR      r0,[r4,#0]
        0x0021c3f2:    f63dfd07    =...    BL       memcmp ; 0x59e04
        0x0021c3f6:    b198        ..      CBZ      r0,0x21c420 ; load_overlay + 72
;;;127        {
;;;128            return true;
;;;129        }
;;;130    
;;;131        /* load code */
;;;132        memcpy(selected_scenario->image_ro_base, selected_scenario->load_ro_base,
        0x0021c3f8:    69a2        .i      LDR      r2,[r4,#0x18]
        0x0021c3fa:    6861        ah      LDR      r1,[r4,#4]
        0x0021c3fc:    68e0        .h      LDR      r0,[r4,#0xc]
        0x0021c3fe:    f63dfd4c    =.L.    BL       __aeabi_memcpy ; 0x59e9a
;;;133               selected_scenario->ro_length);
;;;134        /* load rw data */
;;;135        memcpy(selected_scenario->image_rw_base, selected_scenario->load_rw_base,
        0x0021c402:    69e2        .i      LDR      r2,[r4,#0x1c]
        0x0021c404:    68a1        .h      LDR      r1,[r4,#8]
        0x0021c406:    6920         i      LDR      r0,[r4,#0x10]
        0x0021c408:    f63dfd47    =.G.    BL       __aeabi_memcpy ; 0x59e9a
;;;136               selected_scenario->rw_length);
;;;137        /* clear zi data */
;;;138        memset(selected_scenario->image_zi_base, 0x0, selected_scenario->zi_length);
        0x0021c40c:    6a21        !j      LDR      r1,[r4,#0x20]
        0x0021c40e:    6960        `i      LDR      r0,[r4,#0x14]
        0x0021c410:    f63dfe04    =...    BL       __aeabi_memclr ; 0x5a01c
;;;139    
;;;140        memcpy(scenario_name, selected_scenario->signature, 8);
        0x0021c414:    6820         h      LDR      r0,[r4,#0]
        0x0021c416:    490e        .I      LDR      r1,[pc,#56] ; [0x21c450] = 0x20d3d4
        0x0021c418:    6802        .h      LDR      r2,[r0,#0]
        0x0021c41a:    600a        .`      STR      r2,[r1,#0]
        0x0021c41c:    6840        @h      LDR      r0,[r0,#4]
        0x0021c41e:    6048        H`      STR      r0,[r1,#4]
        0x0021c420:    2001        .       MOVS     r0,#1
;;;141    
;;;142        return true;
;;;143    }
        0x0021c422:    bd10        ..      POP      {r4,pc}
    get_current_scenario_index
;;;144    
;;;145    T_OVERLAY_SCENARIO_IDX get_current_scenario_index(void)
;;;146    {
        0x0021c424:    b570        p.      PUSH     {r4-r6,lr}
        0x0021c426:    4d09        .M      LDR      r5,[pc,#36] ; [0x21c44c] = 0x20cf2c
;;;147        const T_OVERLAY_SECTION *selected_scenario;
;;;148    
;;;149        for (int i = 0; i < (int)OVERLAY_SCENARIO_NUM; ++i)
        0x0021c428:    2400        .$      MOVS     r4,#0
        0x0021c42a:    eb0400c4    ....    ADD      r0,r4,r4,LSL #3
        0x0021c42e:    2208        ."      MOVS     r2,#8
        0x0021c430:    f8550020    U. .    LDR      r0,[r5,r0,LSL #2]
        0x0021c434:    4906        .I      LDR      r1,[pc,#24] ; [0x21c450] = 0x20d3d4
        0x0021c436:    f63dfce5    =...    BL       memcmp ; 0x59e04
        0x0021c43a:    b120         .      CBZ      r0,0x21c446 ; get_current_scenario_index + 34
        0x0021c43c:    1c64        d.      ADDS     r4,r4,#1
        0x0021c43e:    2c03        .,      CMP      r4,#3
        0x0021c440:    dbf3        ..      BLT      0x21c42a ; get_current_scenario_index + 6
        0x0021c442:    2003        .       MOVS     r0,#3
        0x0021c444:    bd70        p.      POP      {r4-r6,pc}
;;;150        {
;;;151            selected_scenario = &overlay_sections[i];
;;;152            if (memcmp(selected_scenario->signature, scenario_name, 8) == 0)
;;;153            {
;;;154                return (T_OVERLAY_SCENARIO_IDX)i;
        0x0021c446:    b2e0        ..      UXTB     r0,r4
;;;155            }
;;;156        }
;;;157    
;;;158        return OVERLAY_SCENARIO_NUM; //not found valid scenario
;;;159    }
        0x0021c448:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x0021c44a:    0000        ..      DCW    0
        0x0021c44c:    0020cf2c    ,. .    DCD    2150188
        0x0021c450:    0020d3d4    .. .    DCD    2151380
    $t
    .text
    gap_lib_handle_btif_msg
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (31)
        0x0021c454:    b510        ..      PUSH     {r4,lr}
        0x0021c456:    2201        ."      MOVS     r2,#1
        0x0021c458:    700a        .p      STRB     r2,[r1,#0]
        0x0021c45a:    8841        A.      LDRH     r1,[r0,#2]
        0x0021c45c:    2400        .$      MOVS     r4,#0
        0x0021c45e:    290e        .)      CMP      r1,#0xe
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (31)
        0x0021c460:    d004        ..      BEQ      0x21c46c ; gap_lib_handle_btif_msg + 24
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (35)
        0x0021c462:    290f        .)      CMP      r1,#0xf
        0x0021c464:    d00b        ..      BEQ      0x21c47e ; gap_lib_handle_btif_msg + 42
        0x0021c466:    2922        ")      CMP      r1,#0x22
        0x0021c468:    d10c        ..      BNE      0x21c484 ; gap_lib_handle_btif_msg + 48
        0x0021c46a:    e003        ..      B        0x21c474 ; gap_lib_handle_btif_msg + 32
        0x0021c46c:    1d00        ..      ADDS     r0,r0,#4
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (39)
        0x0021c46e:    f7effc0c    ....    BL       le_handle_vendor_cmd_rsp ; 0x20bc8a
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (40)
        0x0021c472:    e007        ..      B        0x21c484 ; gap_lib_handle_btif_msg + 48
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (44)
        0x0021c474:    8880        ..      LDRH     r0,[r0,#4]
        0x0021c476:    f7effafa    ....    BL       le_handle_sw_reset_rsp ; 0x20ba6e
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (45)
        0x0021c47a:    2401        .$      MOVS     r4,#1
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (46)
        0x0021c47c:    e002        ..      B        0x21c484 ; gap_lib_handle_btif_msg + 48
        0x0021c47e:    1d00        ..      ADDS     r0,r0,#4
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (109)
        0x0021c480:    f7effc2f    ../.    BL       le_handle_vendor_evt_info ; 0x20bce2
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (117)
        0x0021c484:    4620         F      MOV      r0,r4
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (118)
        0x0021c486:    bd10        ..      POP      {r4,pc}
    gap_lib_init
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (121)
        0x0021c488:    b530        0.      PUSH     {r4,r5,lr}
        0x0021c48a:    b087        ..      SUB      sp,sp,#0x1c
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (122)
        0x0021c48c:    2000        .       MOVS     r0,#0
        0x0021c48e:    9005        ..      STR      r0,[sp,#0x14]
        0x0021c490:    2401        .$      MOVS     r4,#1
        0x0021c492:    9006        ..      STR      r0,[sp,#0x18]
        0x0021c494:    e9cd4000    ...@    STRD     r4,r0,[sp,#0]
        0x0021c498:    4d0f        .M      LDR      r5,[pc,#60] ; [0x21c4d8] = 0x21103500
        0x0021c49a:    9003        ..      STR      r0,[sp,#0xc]
        0x0021c49c:    9004        ..      STR      r0,[sp,#0x10]
        0x0021c49e:    9002        ..      STR      r0,[sp,#8]
        0x0021c4a0:    230d        .#      MOVS     r3,#0xd
        0x0021c4a2:    2208        ."      MOVS     r2,#8
        0x0021c4a4:    490b        .I      LDR      r1,[pc,#44] ; [0x21c4d4] = 0x8802528
        0x0021c4a6:    4628        (F      MOV      r0,r5
        0x0021c4a8:    f5ebfad9    ....    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (126)
        0x0021c4ac:    4909        .I      LDR      r1,[pc,#36] ; [0x21c4d4] = 0x8802528
        0x0021c4ae:    9401        ..      STR      r4,[sp,#4]
        0x0021c4b0:    9402        ..      STR      r4,[sp,#8]
        0x0021c4b2:    9403        ..      STR      r4,[sp,#0xc]
        0x0021c4b4:    9404        ..      STR      r4,[sp,#0x10]
        0x0021c4b6:    2300        .#      MOVS     r3,#0
        0x0021c4b8:    2206        ."      MOVS     r2,#6
        0x0021c4ba:    31f0        .1      ADDS     r1,r1,#0xf0
        0x0021c4bc:    4628        (F      MOV      r0,r5
        0x0021c4be:    9400        ..      STR      r4,[sp,#0]
        0x0021c4c0:    f5ebfacd    ....    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (129)
        0x0021c4c4:    f2af0073    ..s.    ADR      r0,{pc}-0x6f ; 0x21c455
        0x0021c4c8:    b007        ..      ADD      sp,sp,#0x1c
        0x0021c4ca:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x0021c4ce:    f62fbc9f    /...    B        gap_register_extend_cb ; 0x4be10
    $d
        0x0021c4d2:    0000        ..      DCW    0
        0x0021c4d4:    08802528    (%..    DCD    142615848
        0x0021c4d8:    21103500    .5.!    DCD    554710272
    $t
    .text
    _printf_pre_padding
        0x0021c4dc:    b570        p.      PUSH     {r4-r6,lr}
        0x0021c4de:    4604        .F      MOV      r4,r0
        0x0021c4e0:    6985        .i      LDR      r5,[r0,#0x18]
        0x0021c4e2:    6800        .h      LDR      r0,[r0,#0]
        0x0021c4e4:    06c1        ..      LSLS     r1,r0,#27
        0x0021c4e6:    d501        ..      BPL      0x21c4ec ; _printf_pre_padding + 16
        0x0021c4e8:    2630        0&      MOVS     r6,#0x30
        0x0021c4ea:    e000        ..      B        0x21c4ee ; _printf_pre_padding + 18
        0x0021c4ec:    2620         &      MOVS     r6,#0x20
        0x0021c4ee:    07c0        ..      LSLS     r0,r0,#31
        0x0021c4f0:    d007        ..      BEQ      0x21c502 ; _printf_pre_padding + 38
        0x0021c4f2:    bd70        p.      POP      {r4-r6,pc}
        0x0021c4f4:    e9d42101    ...!    LDRD     r2,r1,[r4,#4]
        0x0021c4f8:    4630        0F      MOV      r0,r6
        0x0021c4fa:    4790        .G      BLX      r2
        0x0021c4fc:    6a20         j      LDR      r0,[r4,#0x20]
        0x0021c4fe:    1c40        @.      ADDS     r0,r0,#1
        0x0021c500:    6220         b      STR      r0,[r4,#0x20]
        0x0021c502:    1e6d        m.      SUBS     r5,r5,#1
        0x0021c504:    d5f6        ..      BPL      0x21c4f4 ; _printf_pre_padding + 24
        0x0021c506:    bd70        p.      POP      {r4-r6,pc}
    _printf_post_padding
        0x0021c508:    b570        p.      PUSH     {r4-r6,lr}
        0x0021c50a:    4604        .F      MOV      r4,r0
        0x0021c50c:    6985        .i      LDR      r5,[r0,#0x18]
        0x0021c50e:    7800        .x      LDRB     r0,[r0,#0]
        0x0021c510:    07c0        ..      LSLS     r0,r0,#31
        0x0021c512:    d107        ..      BNE      0x21c524 ; _printf_post_padding + 28
        0x0021c514:    bd70        p.      POP      {r4-r6,pc}
        0x0021c516:    e9d42101    ...!    LDRD     r2,r1,[r4,#4]
        0x0021c51a:    2020                MOVS     r0,#0x20
        0x0021c51c:    4790        .G      BLX      r2
        0x0021c51e:    6a20         j      LDR      r0,[r4,#0x20]
        0x0021c520:    1c40        @.      ADDS     r0,r0,#1
        0x0021c522:    6220         b      STR      r0,[r4,#0x20]
        0x0021c524:    1e6d        m.      SUBS     r5,r5,#1
        0x0021c526:    d5f6        ..      BPL      0x21c516 ; _printf_post_padding + 14
        0x0021c528:    bd70        p.      POP      {r4-r6,pc}
        0x0021c52a:    0000        ..      MOVS     r0,r0
    .text
    __printf
        0x0021c52c:    e92d5ff0    -.._    PUSH     {r4-r12,lr}
        0x0021c530:    4689        .F      MOV      r9,r1
        0x0021c532:    4604        .F      MOV      r4,r0
        0x0021c534:    f04f0a00    O...    MOV      r10,#0
        0x0021c538:    f8dfb124    ..$.    LDR      r11,[pc,#292] ; [0x21c660] = 0xfffefacf
        0x0021c53c:    44fb        .D      ADD      r11,r11,pc
        0x0021c53e:    f8c0a020    .. .    STR      r10,[r0,#0x20]
        0x0021c542:    4620         F      MOV      r0,r4
        0x0021c544:    68e1        .h      LDR      r1,[r4,#0xc]
        0x0021c546:    4788        .G      BLX      r1
        0x0021c548:    2800        .(      CMP      r0,#0
        0x0021c54a:    d07d        }.      BEQ      0x21c648 ; __printf + 284
        0x0021c54c:    2825        %(      CMP      r0,#0x25
        0x0021c54e:    d006        ..      BEQ      0x21c55e ; __printf + 50
        0x0021c550:    e9d42101    ...!    LDRD     r2,r1,[r4,#4]
        0x0021c554:    4790        .G      BLX      r2
        0x0021c556:    6a20         j      LDR      r0,[r4,#0x20]
        0x0021c558:    1c40        @.      ADDS     r0,r0,#1
        0x0021c55a:    6220         b      STR      r0,[r4,#0x20]
        0x0021c55c:    e7f1        ..      B        0x21c542 ; __printf + 22
        0x0021c55e:    2500        .%      MOVS     r5,#0
        0x0021c560:    465f        _F      MOV      r7,r11
        0x0021c562:    4620         F      MOV      r0,r4
        0x0021c564:    68e1        .h      LDR      r1,[r4,#0xc]
        0x0021c566:    4788        .G      BLX      r1
        0x0021c568:    2820         (      CMP      r0,#0x20
        0x0021c56a:    4606        .F      MOV      r6,r0
        0x0021c56c:    db07        ..      BLT      0x21c57e ; __printf + 82
        0x0021c56e:    2e31        1.      CMP      r6,#0x31
        0x0021c570:    d205        ..      BCS      0x21c57e ; __printf + 82
        0x0021c572:    19b8        ..      ADDS     r0,r7,r6
        0x0021c574:    f8100c20    .. .    LDRB     r0,[r0,#-0x20]
        0x0021c578:    b108        ..      CBZ      r0,0x21c57e ; __printf + 82
        0x0021c57a:    4305        .C      ORRS     r5,r5,r0
        0x0021c57c:    e7f1        ..      B        0x21c562 ; __printf + 54
        0x0021c57e:    07a8        ..      LSLS     r0,r5,#30
        0x0021c580:    d501        ..      BPL      0x21c586 ; __printf + 90
        0x0021c582:    f0250504    %...    BIC      r5,r5,#4
        0x0021c586:    f8c4a01c    ....    STR      r10,[r4,#0x1c]
        0x0021c58a:    2700        .'      MOVS     r7,#0
        0x0021c58c:    f8c4a018    ....    STR      r10,[r4,#0x18]
        0x0021c590:    2e2a        *.      CMP      r6,#0x2a
        0x0021c592:    d009        ..      BEQ      0x21c5a8 ; __printf + 124
        0x0021c594:    4630        0F      MOV      r0,r6
        0x0021c596:    f000f8da    ....    BL       _is_digit ; 0x21c74e
        0x0021c59a:    b338        8.      CBZ      r0,0x21c5ec ; __printf + 192
        0x0021c59c:    eb040887    ....    ADD      r8,r4,r7,LSL #2
        0x0021c5a0:    3e30        0>      SUBS     r6,r6,#0x30
        0x0021c5a2:    f8c86018    ...`    STR      r6,[r8,#0x18]
        0x0021c5a6:    e019        ..      B        0x21c5dc ; __printf + 176
        0x0021c5a8:    f8591b04    Y...    LDR      r1,[r9],#4
        0x0021c5ac:    4620         F      MOV      r0,r4
        0x0021c5ae:    eb040287    ....    ADD      r2,r4,r7,LSL #2
        0x0021c5b2:    6191        .a      STR      r1,[r2,#0x18]
        0x0021c5b4:    68e1        .h      LDR      r1,[r4,#0xc]
        0x0021c5b6:    4788        .G      BLX      r1
        0x0021c5b8:    2f01        ./      CMP      r7,#1
        0x0021c5ba:    4606        .F      MOV      r6,r0
        0x0021c5bc:    d118        ..      BNE      0x21c5f0 ; __printf + 196
        0x0021c5be:    69e0        .i      LDR      r0,[r4,#0x1c]
        0x0021c5c0:    2800        .(      CMP      r0,#0
        0x0021c5c2:    da20         .      BGE      0x21c606 ; __printf + 218
        0x0021c5c4:    f0250520    %. .    BIC      r5,r5,#0x20
        0x0021c5c8:    e01d        ..      B        0x21c606 ; __printf + 218
        0x0021c5ca:    f8d80018    ....    LDR      r0,[r8,#0x18]
        0x0021c5ce:    eb000080    ....    ADD      r0,r0,r0,LSL #2
        0x0021c5d2:    eb060040    ..@.    ADD      r0,r6,r0,LSL #1
        0x0021c5d6:    3830        08      SUBS     r0,r0,#0x30
        0x0021c5d8:    f8c80018    ....    STR      r0,[r8,#0x18]
        0x0021c5dc:    4620         F      MOV      r0,r4
        0x0021c5de:    68e1        .h      LDR      r1,[r4,#0xc]
        0x0021c5e0:    4788        .G      BLX      r1
        0x0021c5e2:    4606        .F      MOV      r6,r0
        0x0021c5e4:    f000f8b3    ....    BL       _is_digit ; 0x21c74e
        0x0021c5e8:    2800        .(      CMP      r0,#0
        0x0021c5ea:    d1ee        ..      BNE      0x21c5ca ; __printf + 158
        0x0021c5ec:    2f01        ./      CMP      r7,#1
        0x0021c5ee:    d00a        ..      BEQ      0x21c606 ; __printf + 218
        0x0021c5f0:    2e2e        ..      CMP      r6,#0x2e
        0x0021c5f2:    d108        ..      BNE      0x21c606 ; __printf + 218
        0x0021c5f4:    4620         F      MOV      r0,r4
        0x0021c5f6:    68e1        .h      LDR      r1,[r4,#0xc]
        0x0021c5f8:    4788        .G      BLX      r1
        0x0021c5fa:    1c7f        ..      ADDS     r7,r7,#1
        0x0021c5fc:    4606        .F      MOV      r6,r0
        0x0021c5fe:    2f02        ./      CMP      r7,#2
        0x0021c600:    f0450520    E. .    ORR      r5,r5,#0x20
        0x0021c604:    dbc4        ..      BLT      0x21c590 ; __printf + 100
        0x0021c606:    69a0        .i      LDR      r0,[r4,#0x18]
        0x0021c608:    2800        .(      CMP      r0,#0
        0x0021c60a:    da03        ..      BGE      0x21c614 ; __printf + 232
        0x0021c60c:    4240        @B      RSBS     r0,r0,#0
        0x0021c60e:    f0450501    E...    ORR      r5,r5,#1
        0x0021c612:    61a0        .a      STR      r0,[r4,#0x18]
        0x0021c614:    07e8        ..      LSLS     r0,r5,#31
        0x0021c616:    d001        ..      BEQ      0x21c61c ; __printf + 240
        0x0021c618:    f0250510    %...    BIC      r5,r5,#0x10
        0x0021c61c:    b1a6        ..      CBZ      r6,0x21c648 ; __printf + 284
        0x0021c61e:    f1a60041    ..A.    SUB      r0,r6,#0x41
        0x0021c622:    2819        .(      CMP      r0,#0x19
        0x0021c624:    d802        ..      BHI      0x21c62c ; __printf + 256
        0x0021c626:    3620         6      ADDS     r6,r6,#0x20
        0x0021c628:    f4456500    E..e    ORR      r5,r5,#0x800
        0x0021c62c:    464a        JF      MOV      r2,r9
        0x0021c62e:    4631        1F      MOV      r1,r6
        0x0021c630:    4620         F      MOV      r0,r4
        0x0021c632:    6025        %`      STR      r5,[r4,#0]
        0x0021c634:    464d        MF      MOV      r5,r9
        0x0021c636:    f7fffce3    ....    BL       _printf_d ; 0x21c000
        0x0021c63a:    b160        `.      CBZ      r0,0x21c656 ; __printf + 298
        0x0021c63c:    2801        .(      CMP      r0,#1
        0x0021c63e:    d007        ..      BEQ      0x21c650 ; __printf + 292
        0x0021c640:    1ded        ..      ADDS     r5,r5,#7
        0x0021c642:    f0250007    %...    BIC      r0,r5,#7
        0x0021c646:    e000        ..      B        0x21c64a ; __printf + 286
        0x0021c648:    e007        ..      B        0x21c65a ; __printf + 302
        0x0021c64a:    f1000908    ....    ADD      r9,r0,#8
        0x0021c64e:    e778        x.      B        0x21c542 ; __printf + 22
        0x0021c650:    f1050904    ....    ADD      r9,r5,#4
        0x0021c654:    e775        u.      B        0x21c542 ; __printf + 22
        0x0021c656:    4630        0F      MOV      r0,r6
        0x0021c658:    e77a        z.      B        0x21c550 ; __printf + 36
        0x0021c65a:    6a20         j      LDR      r0,[r4,#0x20]
        0x0021c65c:    e8bd9ff0    ....    POP      {r4-r12,pc}
    $d
        0x0021c660:    fffefacf    ....    DCD    4294900431
    $t
    .text
    srand
        0x0021c664:    490b        .I      LDR      r1,[pc,#44] ; [0x21c694] = 0x20d468
        0x0021c666:    b510        ..      PUSH     {r4,lr}
        0x0021c668:    f1a1027c    ..|.    SUB      r2,r1,#0x7c
        0x0021c66c:    4c0a        .L      LDR      r4,[pc,#40] ; [0x21c698] = 0x66d619e1
        0x0021c66e:    e9c21237    ..7.    STRD     r1,r2,[r2,#0xdc]
        0x0021c672:    2137        7!      MOVS     r1,#0x37
        0x0021c674:    e006        ..      B        0x21c684 ; srand + 32
        0x0021c676:    eb004310    ...C    ADD      r3,r0,r0,LSR #16
        0x0021c67a:    f8423021    B.!0    STR      r3,[r2,r1,LSL #2]
        0x0021c67e:    4b07        .K      LDR      r3,[pc,#28] ; [0x21c69c] = 0x10dcd
        0x0021c680:    fb004003    ...@    MLA      r0,r0,r3,r4
        0x0021c684:    1e0b        ..      SUBS     r3,r1,#0
        0x0021c686:    f1a10101    ....    SUB      r1,r1,#1
        0x0021c68a:    dcf4        ..      BGT      0x21c676 ; srand + 18
        0x0021c68c:    bd10        ..      POP      {r4,pc}
    _rand_init
        0x0021c68e:    2001        .       MOVS     r0,#1
        0x0021c690:    e7e8        ..      B        srand ; 0x21c664
    $d
        0x0021c692:    0000        ..      DCW    0
        0x0021c694:    0020d468    h. .    DCD    2151528
        0x0021c698:    66d619e1    ...f    DCD    1725307361
        0x0021c69c:    00010dcd    ....    DCD    69069
    $t
    .text
    strncmp
        0x0021c6a0:    ea400301    @...    ORR      r3,r0,r1
        0x0021c6a4:    b570        p.      PUSH     {r4-r6,lr}
        0x0021c6a6:    079b        ..      LSLS     r3,r3,#30
        0x0021c6a8:    d12e        ..      BNE      0x21c708 ; strncmp + 104
        0x0021c6aa:    f04f3601    O..6    MOV      r6,#0x1010101
        0x0021c6ae:    2a04        .*      CMP      r2,#4
        0x0021c6b0:    d32a        *.      BCC      0x21c708 ; strncmp + 104
        0x0021c6b2:    c808        ..      LDM      r0!,{r3}
        0x0021c6b4:    c910        ..      LDM      r1!,{r4}
        0x0021c6b6:    1b9d        ..      SUBS     r5,r3,r6
        0x0021c6b8:    439d        .C      BICS     r5,r5,r3
        0x0021c6ba:    1f12        ..      SUBS     r2,r2,#4
        0x0021c6bc:    ea1515c6    ....    ANDS     r5,r5,r6,LSL #7
        0x0021c6c0:    d017        ..      BEQ      0x21c6f2 ; strncmp + 82
        0x0021c6c2:    b2d8        ..      UXTB     r0,r3
        0x0021c6c4:    b2e1        ..      UXTB     r1,r4
        0x0021c6c6:    1a40        @.      SUBS     r0,r0,r1
        0x0021c6c8:    ea506105    P..a    ORRS     r1,r0,r5,LSL #24
        0x0021c6cc:    d110        ..      BNE      0x21c6f0 ; strncmp + 80
        0x0021c6ce:    b298        ..      UXTH     r0,r3
        0x0021c6d0:    b2a1        ..      UXTH     r1,r4
        0x0021c6d2:    1a40        @.      SUBS     r0,r0,r1
        0x0021c6d4:    ea504105    P..A    ORRS     r1,r0,r5,LSL #16
        0x0021c6d8:    d10a        ..      BNE      0x21c6f0 ; strncmp + 80
        0x0021c6da:    f023407f    #..@    BIC      r0,r3,#0xff000000
        0x0021c6de:    f024417f    $..A    BIC      r1,r4,#0xff000000
        0x0021c6e2:    1a40        @.      SUBS     r0,r0,r1
        0x0021c6e4:    ea502105    P..!    ORRS     r1,r0,r5,LSL #8
        0x0021c6e8:    d102        ..      BNE      0x21c6f0 ; strncmp + 80
        0x0021c6ea:    0e18        ..      LSRS     r0,r3,#24
        0x0021c6ec:    eba06014    ...`    SUB      r0,r0,r4,LSR #24
        0x0021c6f0:    bd70        p.      POP      {r4-r6,pc}
        0x0021c6f2:    42a3        .B      CMP      r3,r4
        0x0021c6f4:    d0db        ..      BEQ      0x21c6ae ; strncmp + 14
        0x0021c6f6:    ba18        ..      REV      r0,r3
        0x0021c6f8:    ba21        !.      REV      r1,r4
        0x0021c6fa:    4288        .B      CMP      r0,r1
        0x0021c6fc:    d901        ..      BLS      0x21c702 ; strncmp + 98
        0x0021c6fe:    2001        .       MOVS     r0,#1
        0x0021c700:    bd70        p.      POP      {r4-r6,pc}
        0x0021c702:    f04f30ff    O..0    MOV      r0,#0xffffffff
        0x0021c706:    bd70        p.      POP      {r4-r6,pc}
        0x0021c708:    b90a        ..      CBNZ     r2,0x21c70e ; strncmp + 110
        0x0021c70a:    2000        .       MOVS     r0,#0
        0x0021c70c:    bd70        p.      POP      {r4-r6,pc}
        0x0021c70e:    f8103b01    ...;    LDRB     r3,[r0],#1
        0x0021c712:    f8114b01    ...K    LDRB     r4,[r1],#1
        0x0021c716:    b163        c.      CBZ      r3,0x21c732 ; strncmp + 146
        0x0021c718:    42a3        .B      CMP      r3,r4
        0x0021c71a:    d10a        ..      BNE      0x21c732 ; strncmp + 146
        0x0021c71c:    1e52        R.      SUBS     r2,r2,#1
        0x0021c71e:    d008        ..      BEQ      0x21c732 ; strncmp + 146
        0x0021c720:    f8103b01    ...;    LDRB     r3,[r0],#1
        0x0021c724:    f8114b01    ...K    LDRB     r4,[r1],#1
        0x0021c728:    b11b        ..      CBZ      r3,0x21c732 ; strncmp + 146
        0x0021c72a:    42a3        .B      CMP      r3,r4
        0x0021c72c:    d101        ..      BNE      0x21c732 ; strncmp + 146
        0x0021c72e:    1e52        R.      SUBS     r2,r2,#1
        0x0021c730:    d1ed        ..      BNE      0x21c70e ; strncmp + 110
        0x0021c732:    1b18        ..      SUBS     r0,r3,r4
        0x0021c734:    bd70        p.      POP      {r4-r6,pc}
    .text
    strcat
        0x0021c736:    1e42        B.      SUBS     r2,r0,#1
        0x0021c738:    f8123f01    ...?    LDRB     r3,[r2,#1]!
        0x0021c73c:    2b00        .+      CMP      r3,#0
        0x0021c73e:    d1fb        ..      BNE      0x21c738 ; strcat + 2
        0x0021c740:    f8113b01    ...;    LDRB     r3,[r1],#1
        0x0021c744:    2b00        .+      CMP      r3,#0
        0x0021c746:    f8023b01    ...;    STRB     r3,[r2],#1
        0x0021c74a:    d1f9        ..      BNE      0x21c740 ; strcat + 10
        0x0021c74c:    4770        pG      BX       lr
    i._is_digit
    _is_digit
        0x0021c74e:    3830        08      SUBS     r0,r0,#0x30
        0x0021c750:    280a        .(      CMP      r0,#0xa
        0x0021c752:    d201        ..      BCS      0x21c758 ; _is_digit + 10
        0x0021c754:    2001        .       MOVS     r0,#1
        0x0021c756:    4770        pG      BX       lr
        0x0021c758:    2000        .       MOVS     r0,#0
        0x0021c75a:    4770        pG      BX       lr
    x$fpl$fpinit
    $v0
    _fp_init
        0x0021c75c:    f04f7040    O.@p    MOV      r0,#0x3000000
        0x0021c760:    eee10a10    ....    VMSR     FPSCR,r0
    __fplib_config_fpu_vfp
    __fplib_config_pureend_doubles
        0x0021c764:    4770        pG      BX       lr
        0x0021c766:    0000        ..      MOVS     r0,r0
    $d.realdata
    .constdata
    __func__
        0x0021c768:    6c6c616d    mall    DCD    1819042157
        0x0021c76c:    636f        oc      DCW    25455
        0x0021c76e:    00          .       DCB    0
    __func__
        0x0021c76f:    63          c       DCB    99
        0x0021c770:    6f6c6c61    allo    DCD    1869376609
        0x0021c774:    0063        c.      DCW    99
    __func__
        0x0021c776:    6572        re      DCW    25970
        0x0021c778:    6f6c6c61    allo    DCD    1869376609
        0x0021c77c:    00000063    c...    DCD    99
        0x0021c780:    0021cbdc    ..!.    DCD    2214876
        0x0021c784:    0021cc88    ..!.    DCD    2215048
        0x0021c788:    0021cbd0    ..!.    DCD    2214864
        0x0021c78c:    0021cc90    ..!.    DCD    2215056
        0x0021c790:    0021cc34    4.!.    DCD    2214964
        0x0021c794:    0021cca8    ..!.    DCD    2215080
        0x0021c798:    0021cc9c    ..!.    DCD    2215068
        0x0021c79c:    0021cc24    $.!.    DCD    2214948
        0x0021c7a0:    0021cc24    $.!.    DCD    2214948
        0x0021c7a4:    0021cc24    $.!.    DCD    2214948
        0x0021c7a8:    0021cc24    $.!.    DCD    2214948
        0x0021c7ac:    0021cbc4    ..!.    DCD    2214852
        0x0021c7b0:    0021cc7c    |.!.    DCD    2215036
        0x0021c7b4:    0021cc24    $.!.    DCD    2214948
        0x0021c7b8:    0021cbec    ..!.    DCD    2214892
        0x0021c7bc:    0021cc4c    L.!.    DCD    2214988
        0x0021c7c0:    0021cc60    `.!.    DCD    2215008
        0x0021c7c4:    0021cbcc    ..!.    DCD    2214860
        0x0021c7c8:    0021cbb4    ..!.    DCD    2214836
        0x0021c7cc:    0021cb34    4.!.    DCD    2214708
        0x0021c7d0:    0021cb08    ..!.    DCD    2214664
        0x0021c7d4:    0021cc68    h.!.    DCD    2215016
        0x0021c7d8:    0021cc1c    ..!.    DCD    2214940
        0x0021c7dc:    0021cc08    ..!.    DCD    2214920
        0x0021c7e0:    0021cba0    ..!.    DCD    2214816
        0x0021c7e4:    0021cb60    `.!.    DCD    2214752
        0x0021c7e8:    0021cb80    ..!.    DCD    2214784
        0x0021c7ec:    0021cae4    ..!.    DCD    2214628
        0x0021c7f0:    0021cab0    ..!.    DCD    2214576
        0x0021c7f4:    0021cbc0    ..!.    DCD    2214848
        0x0021c7f8:    0021caa8    ..!.    DCD    2214568
        0x0021c7fc:    0021cadc    ..!.    DCD    2214620
        0x0021c800:    0021caa0    ..!.    DCD    2214560
        0x0021c804:    0021cad4    ..!.    DCD    2214612
        0x0021c808:    0021cbbc    ..!.    DCD    2214844
        0x0021c80c:    0021cc54    T.!.    DCD    2214996
        0x0021c810:    0021cab8    ..!.    DCD    2214584
        0x0021c814:    0021caec    ..!.    DCD    2214636
        0x0021c818:    0021cb18    ..!.    DCD    2214680
        0x0021c81c:    0021cb3c    <.!.    DCD    2214716
        0x0021c820:    0021cb68    h.!.    DCD    2214760
        0x0021c824:    0021cb88    ..!.    DCD    2214792
        0x0021c828:    0021cb4c    L.!.    DCD    2214732
        0x0021c82c:    0021cb28    (.!.    DCD    2214696
        0x0021c830:    0021cbe8    ..!.    DCD    2214888
        0x0021c834:    0021cafc    ..!.    DCD    2214652
        0x0021c838:    0021cac8    ..!.    DCD    2214600
        0x0021c83c:    0021cb10    ..!.    DCD    2214672
        0x0021c840:    0021cb58    X.!.    DCD    2214744
        0x0021c844:    0021cb78    x.!.    DCD    2214776
        0x0021c848:    0021cb98    ..!.    DCD    2214808
        0x0021c84c:    0021cbac    ..!.    DCD    2214828
        0x0021c850:    0021cc40    @.!.    DCD    2214976
        0x0021c854:    0021cc2c    ,.!.    DCD    2214956
        0x0021c858:    0021cc74    t.!.    DCD    2215028
        0x0021c85c:    0021cbf4    ..!.    DCD    2214900
        0x0021c860:    0021cbd4    ..!.    DCD    2214868
        0x0021c864:    0021ccb4    ..!.    DCD    2215092
        0x0021c868:    0021cc10    ..!.    DCD    2214928
        0x0021c86c:    0021cbfc    ..!.    DCD    2214908
        0x0021c870:    0021cbc8    ..!.    DCD    2214856
    .constdata
    simp_ble_client_cbs
        0x0021c874:    002085e3    .. .    DCD    2131427
        0x0021c878:    002086f3    .. .    DCD    2131699
        0x0021c87c:    0020880f    .. .    DCD    2131983
        0x0021c880:    00208911    .. .    DCD    2132241
        0x0021c884:    0020897f    .. .    DCD    2132351
        0x0021c888:    00208a19    .. .    DCD    2132505
    __func__
        0x0021c88c:    706d6973    simp    DCD    1886218611
        0x0021c890:    656c625f    _ble    DCD    1701601887
        0x0021c894:    6464615f    _add    DCD    1684300127
        0x0021c898:    696c635f    _cli    DCD    1768711007
        0x0021c89c:    00746e65    ent.    DCD    7630437
    .constdata
    user_cmd_table
        0x0021c8a0:    0020ce54    T. .    DCD    2149972
        0x0021c8a4:    0020cb10    .. .    DCD    2149136
        0x0021c8a8:    0020c62c    ,. .    DCD    2147884
        0x0021c8ac:    00209597    .. .    DCD    2135447
        0x0021c8b0:    0020ce40    @. .    DCD    2149952
        0x0021c8b4:    0020ccbc    .. .    DCD    2149564
        0x0021c8b8:    0020cd30    0. .    DCD    2149680
        0x0021c8bc:    00209539    9. .    DCD    2135353
        0x0021c8c0:    0020cdbc    .. .    DCD    2149820
        0x0021c8c4:    0020c92c    ,. .    DCD    2148652
        0x0021c8c8:    0020cbe8    .. .    DCD    2149352
        0x0021c8cc:    002095c5    .. .    DCD    2135493
        0x0021c8d0:    0020cdf4    .. .    DCD    2149876
        0x0021c8d4:    0020c9cc    .. .    DCD    2148812
        0x0021c8d8:    0020c3e4    .. .    DCD    2147300
        0x0021c8dc:    002095cb    .. .    DCD    2135499
        0x0021c8e0:    0020ce0c    .. .    DCD    2149900
        0x0021c8e4:    0020c940    @. .    DCD    2148672
        0x0021c8e8:    0020cd84    .. .    DCD    2149764
        0x0021c8ec:    0020966b    k. .    DCD    2135659
        0x0021c8f0:    0020ce00    .. .    DCD    2149888
        0x0021c8f4:    0020caa4    .. .    DCD    2149028
        0x0021c8f8:    0020c754    T. .    DCD    2148180
        0x0021c8fc:    00209671    q. .    DCD    2135665
        0x0021c900:    0020ce88    .. .    DCD    2150024
        0x0021c904:    0020cb74    t. .    DCD    2149236
        0x0021c908:    0020c8b0    .. .    DCD    2148528
        0x0021c90c:    00209681    .. .    DCD    2135681
        0x0021c910:    0020ce48    H. .    DCD    2149960
        0x0021c914:    0020cd18    .. .    DCD    2149656
        0x0021c918:    0020ccc8    .. .    DCD    2149576
        0x0021c91c:    002096b1    .. .    DCD    2135729
        0x0021c920:    0020ce60    `. .    DCD    2149984
        0x0021c924:    0020cd24    $. .    DCD    2149668
        0x0021c928:    0020ccf0    .. .    DCD    2149616
        0x0021c92c:    00209695    .. .    DCD    2135701
        0x0021c930:    0020ce2c    ,. .    DCD    2149932
        0x0021c934:    0020c990    .. .    DCD    2148752
        0x0021c938:    0020cbb4    .. .    DCD    2149300
        0x0021c93c:    0020969f    .. .    DCD    2135711
        0x0021c940:    0020ce6c    l. .    DCD    2149996
        0x0021c944:    0020cd78    x. .    DCD    2149752
        0x0021c948:    0020cd58    X. .    DCD    2149720
        0x0021c94c:    002096a5    .. .    DCD    2135717
        0x0021c950:    0020ce38    8. .    DCD    2149944
        0x0021c954:    0020ca78    x. .    DCD    2148984
        0x0021c958:    0020c020     . .    DCD    2146336
        0x0021c95c:    00209707    .. .    DCD    2135815
        0x0021c960:    0020ce34    4. .    DCD    2149940
        0x0021c964:    0020ccb0    .. .    DCD    2149552
        0x0021c968:    0020cca4    .. .    DCD    2149540
        0x0021c96c:    0020974d    M. .    DCD    2135885
        0x0021c970:    0020ce80    .. .    DCD    2150016
        0x0021c974:    0020cda4    .. .    DCD    2149796
        0x0021c978:    0020cc08    .. .    DCD    2149384
        0x0021c97c:    00209751    Q. .    DCD    2135889
        0x0021c980:    0020ce44    D. .    DCD    2149956
        0x0021c984:    0020ca40    @. .    DCD    2148928
        0x0021c988:    0020c188    .. .    DCD    2146696
        0x0021c98c:    002097c3    .. .    DCD    2136003
        0x0021c990:    0020ce78    x. .    DCD    2150008
        0x0021c994:    0020cb64    d. .    DCD    2149220
        0x0021c998:    0020c59c    .. .    DCD    2147740
        0x0021c99c:    00209837    7. .    DCD    2136119
        0x0021c9a0:    0020cdc4    .. .    DCD    2149828
        0x0021c9a4:    0020ca08    .. .    DCD    2148872
        0x0021c9a8:    0020c364    d. .    DCD    2147172
        0x0021c9ac:    00209895    .. .    DCD    2136213
        0x0021c9b0:    0020ce14    .. .    DCD    2149908
        0x0021c9b4:    0020c954    T. .    DCD    2148692
        0x0021c9b8:    0020cc38    8. .    DCD    2149432
        0x0021c9bc:    002098ab    .. .    DCD    2136235
        0x0021c9c0:    0020cdcc    .. .    DCD    2149836
        0x0021c9c4:    0020cae8    .. .    DCD    2149096
        0x0021c9c8:    0020c0b8    .. .    DCD    2146488
        0x0021c9cc:    002098cb    .. .    DCD    2136267
        0x0021c9d0:    0020cde0    .. .    DCD    2149856
        0x0021c9d4:    0020c9a4    .. .    DCD    2148772
        0x0021c9d8:    0020c7e0    .. .    DCD    2148320
        0x0021c9dc:    002098ef    .. .    DCD    2136303
        0x0021c9e0:    0020cdb0    .. .    DCD    2149808
        0x0021c9e4:    0020cac0    .. .    DCD    2149056
        0x0021c9e8:    0020c680    .. .    DCD    2147968
        0x0021c9ec:    002099e9    .. .    DCD    2136553
        0x0021c9f0:    0020ce1c    .. .    DCD    2149916
        0x0021c9f4:    0020c968    h. .    DCD    2148712
        0x0021c9f8:    0020cc58    X. .    DCD    2149464
        0x0021c9fc:    00209a2b    +. .    DCD    2136619
        0x0021ca00:    0020cdd8    .. .    DCD    2149848
        0x0021ca04:    0020ca24    $. .    DCD    2148900
        0x0021ca08:    0020c254    T. .    DCD    2146900
        0x0021ca0c:    00209a4d    M. .    DCD    2136653
        0x0021ca10:    0020cdec    .. .    DCD    2149868
        0x0021ca14:    0020cb94    .. .    DCD    2149268
        0x0021ca18:    0020c2e8    .. .    DCD    2147048
        0x0021ca1c:    00209a71    q. .    DCD    2136689
        0x0021ca20:    0020ce24    $. .    DCD    2149924
        0x0021ca24:    0020c97c    |. .    DCD    2148732
        0x0021ca28:    0020cc80    .. .    DCD    2149504
        0x0021ca2c:    00209a8f    .. .    DCD    2136719
        0x0021ca30:    00000000    ....    DCD    0
        0x0021ca34:    00000000    ....    DCD    0
        0x0021ca38:    00000000    ....    DCD    0
        0x0021ca3c:    00000000    ....    DCD    0
    .constdata
    __func__
        0x0021ca40:    5f707061    app_    DCD    1601204321
        0x0021ca44:    6e69616d    main    DCD    1852399981
        0x0021ca48:    7361745f    _tas    DCD    1935766623
        0x0021ca4c:    0000006b    k...    DCD    107
    .constdata
        0x0021ca50:    5f454c42    BLE_    DCD    1598377026
        0x0021ca54:    544e4543    CENT    DCD    1414415683
        0x0021ca58:    004c4152    RAL.    DCD    4997458
        0x0021ca5c:    00000000    ....    DCD    0
        0x0021ca60:    00000000    ....    DCD    0
        0x0021ca64:    00000000    ....    DCD    0
        0x0021ca68:    00000000    ....    DCD    0
        0x0021ca6c:    00000000    ....    DCD    0
        0x0021ca70:    00000000    ....    DCD    0
        0x0021ca74:    00000000    ....    DCD    0
    .constdata
    uc_hextab
        0x0021ca78:    33323130    0123    DCD    858927408
        0x0021ca7c:    37363534    4567    DCD    926299444
        0x0021ca80:    42413938    89AB    DCD    1111570744
        0x0021ca84:    46454443    CDEF    DCD    1178944579
        0x0021ca88:    00583040    @0X.    DCD    5779520
    lc_hextab
        0x0021ca8c:    33323130    0123    DCD    858927408
        0x0021ca90:    37363534    4567    DCD    926299444
        0x0021ca94:    62613938    89ab    DCD    1650538808
        0x0021ca98:    66656463    cdef    DCD    1717920867
        0x0021ca9c:    00783040    @0x.    DCD    7876672
    .conststring
        0x0021caa0:    30433249    I2C0    DCD    809710153
        0x0021caa4:    00000000    ....    DCD    0
        0x0021caa8:    30495053    SPI0    DCD    810111059
        0x0021caac:    00000000    ....    DCD    0
        0x0021cab0:    54524155    UART    DCD    1414676821
        0x0021cab4:    00000030    0...    DCD    48
        0x0021cab8:    414d4447    GDMA    DCD    1095582791
        0x0021cabc:    68432030    0 Ch    DCD    1749229616
        0x0021cac0:    656e6e61    anne    DCD    1701736033
        0x0021cac4:    0000306c    l0..    DCD    12396
        0x0021cac8:    4f495047    GPIO    DCD    1330204743
        0x0021cacc:    6f72475f    _Gro    DCD    1869760351
        0x0021cad0:    00307075    up0.    DCD    3174517
        0x0021cad4:    31433249    I2C1    DCD    826487369
        0x0021cad8:    00000000    ....    DCD    0
        0x0021cadc:    31495053    SPI1    DCD    826888275
        0x0021cae0:    00000000    ....    DCD    0
        0x0021cae4:    54524155    UART    DCD    1414676821
        0x0021cae8:    00000031    1...    DCD    49
        0x0021caec:    414d4447    GDMA    DCD    1095582791
        0x0021caf0:    68432030    0 Ch    DCD    1749229616
        0x0021caf4:    656e6e61    anne    DCD    1701736033
        0x0021caf8:    0000316c    l1..    DCD    12652
        0x0021cafc:    4f495047    GPIO    DCD    1330204743
        0x0021cb00:    6f72475f    _Gro    DCD    1869760351
        0x0021cb04:    00317075    up1.    DCD    3240053
        0x0021cb08:    324d4954    TIM2    DCD    843925844
        0x0021cb0c:    00000000    ....    DCD    0
        0x0021cb10:    54524155    UART    DCD    1414676821
        0x0021cb14:    00000032    2...    DCD    50
        0x0021cb18:    414d4447    GDMA    DCD    1095582791
        0x0021cb1c:    68432030    0 Ch    DCD    1749229616
        0x0021cb20:    656e6e61    anne    DCD    1701736033
        0x0021cb24:    0000326c    l2..    DCD    12908
        0x0021cb28:    4f495047    GPIO    DCD    1330204743
        0x0021cb2c:    6f72475f    _Gro    DCD    1869760351
        0x0021cb30:    00327075    up2.    DCD    3305589
        0x0021cb34:    334d4954    TIM3    DCD    860703060
        0x0021cb38:    00000000    ....    DCD    0
        0x0021cb3c:    414d4447    GDMA    DCD    1095582791
        0x0021cb40:    68432030    0 Ch    DCD    1749229616
        0x0021cb44:    656e6e61    anne    DCD    1701736033
        0x0021cb48:    0000336c    l3..    DCD    13164
        0x0021cb4c:    4f495047    GPIO    DCD    1330204743
        0x0021cb50:    6f72475f    _Gro    DCD    1869760351
        0x0021cb54:    00337075    up3.    DCD    3371125
        0x0021cb58:    344d4954    TIM4    DCD    877480276
        0x0021cb5c:    00000000    ....    DCD    0
        0x0021cb60:    4f495047    GPIO    DCD    1330204743
        0x0021cb64:    00000034    4...    DCD    52
        0x0021cb68:    414d4447    GDMA    DCD    1095582791
        0x0021cb6c:    68432030    0 Ch    DCD    1749229616
        0x0021cb70:    656e6e61    anne    DCD    1701736033
        0x0021cb74:    0000346c    l4..    DCD    13420
        0x0021cb78:    354d4954    TIM5    DCD    894257492
        0x0021cb7c:    00000000    ....    DCD    0
        0x0021cb80:    4f495047    GPIO    DCD    1330204743
        0x0021cb84:    00000035    5...    DCD    53
        0x0021cb88:    414d4447    GDMA    DCD    1095582791
        0x0021cb8c:    68432030    0 Ch    DCD    1749229616
        0x0021cb90:    656e6e61    anne    DCD    1701736033
        0x0021cb94:    0000356c    l5..    DCD    13676
        0x0021cb98:    364d4954    TIM6    DCD    911034708
        0x0021cb9c:    00000000    ....    DCD    0
        0x0021cba0:    656d6954    Time    DCD    1701669204
        0x0021cba4:    372d3472    r4-7    DCD    925709426
        0x0021cba8:    00000000    ....    DCD    0
        0x0021cbac:    374d4954    TIM7    DCD    927811924
        0x0021cbb0:    00000000    ....    DCD    0
        0x0021cbb4:    414d5442    BTMA    DCD    1095586882
        0x0021cbb8:    00000043    C...    DCD    67
        0x0021cbbc:    00434441    ADC.    DCD    4408385
        0x0021cbc0:    00435452    RTC.    DCD    4412498
        0x0021cbc4:    00435653    SVC.    DCD    4413011
        0x0021cbc8:    0044434c    LCD.    DCD    4473676
        0x0021cbcc:    00474457    WDG.    DCD    4670551
        0x0021cbd0:    00494d4e    NMI.    DCD    4803918
        0x0021cbd4:    4f43504c    LPCO    DCD    1329811532
        0x0021cbd8:    0000504d    MP..    DCD    20557
        0x0021cbdc:    74696e49    Init    DCD    1953066569
        0x0021cbe0:    536c6169    ialS    DCD    1399611753
        0x0021cbe4:    00000050    P...    DCD    80
        0x0021cbe8:    00005249    IR..    DCD    21065
        0x0021cbec:    646e6550    Pend    DCD    1684956496
        0x0021cbf0:    00005653    SV..    DCD    22099
        0x0021cbf4:    32495053    SPI2    DCD    843665491
        0x0021cbf8:    00000057    W...    DCD    87
        0x0021cbfc:    524f5053    SPOR    DCD    1380929619
        0x0021cc00:    52203154    T1 R    DCD    1377841492
        0x0021cc04:    00000058    X...    DCD    88
        0x0021cc08:    30533249    I2S0    DCD    810758729
        0x0021cc0c:    0058525f    _RX.    DCD    5788255
        0x0021cc10:    524f5053    SPOR    DCD    1380929619
        0x0021cc14:    54203154    T1 T    DCD    1411395924
        0x0021cc18:    00000058    X...    DCD    88
        0x0021cc1c:    30533249    I2S0    DCD    810758729
        0x0021cc20:    0058545f    _TX.    DCD    5788767
        0x0021cc24:    64767352    Rsvd    DCD    1685484370
        0x0021cc28:    00000000    ....    DCD    0
        0x0021cc2c:    63656451    Qdec    DCD    1667589201
        0x0021cc30:    0065646f    ode.    DCD    6644847
        0x0021cc34:    4d6d654d    MemM    DCD    1299014989
        0x0021cc38:    67616e61    anag    DCD    1734438497
        0x0021cc3c:    00000065    e...    DCD    101
        0x0021cc40:    5f495053    SPI_    DCD    1598640211
        0x0021cc44:    73616c46    Flas    DCD    1935764550
        0x0021cc48:    00000068    h...    DCD    104
        0x0021cc4c:    54737953    SysT    DCD    1416853843
        0x0021cc50:    006b6369    ick.    DCD    7037801
        0x0021cc54:    69726550    Peri    DCD    1769104720
        0x0021cc58:    72656870    pher    DCD    1919248496
        0x0021cc5c:    00006c61    al..    DCD    27745
        0x0021cc60:    74737953    Syst    DCD    1953724755
        0x0021cc64:    00006d65    em..    DCD    28005
        0x0021cc68:    74616c50    Plat    DCD    1952541776
        0x0021cc6c:    6d726f66    form    DCD    1836216166
        0x0021cc70:    00000000    ....    DCD    0
        0x0021cc74:    7379654b    Keys    DCD    1937335627
        0x0021cc78:    006e6163    can.    DCD    7233891
        0x0021cc7c:    75626544    Debu    DCD    1969382724
        0x0021cc80:    6e6f4d67    gMon    DCD    1852788071
        0x0021cc84:    00000000    ....    DCD    0
        0x0021cc88:    65736552    Rese    DCD    1702061394
        0x0021cc8c:    00000074    t...    DCD    116
        0x0021cc90:    64726148    Hard    DCD    1685217608
        0x0021cc94:    6c756146    Faul    DCD    1819631942
        0x0021cc98:    00000074    t...    DCD    116
        0x0021cc9c:    67617355    Usag    DCD    1734439765
        0x0021cca0:    75614665    eFau    DCD    1969309285
        0x0021cca4:    0000746c    lt..    DCD    29804
        0x0021cca8:    46737542    BusF    DCD    1181971778
        0x0021ccac:    746c7561    ault    DCD    1953264993
        0x0021ccb0:    00000000    ....    DCD    0
        0x0021ccb4:    5f415450    PTA_    DCD    1598116944
        0x0021ccb8:    6c69614d    Mail    DCD    1818845517
        0x0021ccbc:    00786f62    box.    DCD    7892834
    .conststring
        0x0021ccc0:    6e656353    Scen    DCD    1852138323
        0x0021ccc4:    00425f65    e_B.    DCD    4349797
        0x0021ccc8:    6e656353    Scen    DCD    1852138323
        0x0021cccc:    00435f65    e_C.    DCD    4415333
        0x0021ccd0:    746f6f42    Boot    DCD    1953460034
        0x0021ccd4:    65636e4f    Once    DCD    1701015119
        0x0021ccd8:    00000000    ....    DCD    0

** Section #10 'App.trace' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 10112 bytes (alignment 4)
    Address: 0x08800000

    0x8800000:   21 2a 2a 52 45 53 45 54 20 52 65 61 73 6f 6e 3a    !**RESET Reason:
    0x8800010:   20 48 57 20 6f 72 20 4f 54 41 00 00 21 2a 2a 52     HW or OTA..!**R
    0x8800020:   45 53 45 54 20 52 65 61 73 6f 6e 3a 20 53 57 28    ESET Reason: SW(
    0x8800030:   72 65 73 65 74 20 65 78 63 65 70 74 20 61 6f 6e    reset except aon
    0x8800040:   29 2c 20 54 59 50 45 20 30 78 25 78 00 00 00 00    ), TYPE 0x%x....
    0x8800050:   21 2a 2a 52 45 53 45 54 20 52 65 61 73 6f 6e 3a    !**RESET Reason:
    0x8800060:   20 53 57 28 72 65 73 65 74 20 61 6c 6c 29 2c 20     SW(reset all), 
    0x8800070:   54 59 50 45 20 30 78 25 78 00 00 00 21 21 21 53    TYPE 0x%x...!!!S
    0x8800080:   44 4b 20 56 65 72 3a 20 25 73 2c 20 42 75 69 6c    DK Ver: %s, Buil
    0x8800090:   64 20 54 69 6d 65 3a 20 25 73 00 00 21 21 2a 57    d Time: %s..!!*W
    0x88000a0:   61 72 6e 69 6e 67 21 20 25 73 20 69 73 20 75 70    arning! %s is up
    0x88000b0:   64 61 74 65 64 20 62 79 20 41 50 50 21 00 00 00    dated by APP!...
    0x88000c0:   21 21 2a 57 61 72 6e 69 6e 67 21 20 49 53 52 20    !!*Warning! ISR 
    0x88000d0:   25 73 20 69 73 20 75 70 64 61 74 65 64 20 62 79    %s is updated by
    0x88000e0:   20 41 50 50 21 00 00 00 21 2a 2a 73 69 6d 70 5f     APP!...!**simp_
    0x88000f0:   62 6c 65 5f 63 6c 69 65 6e 74 5f 73 74 61 72 74    ble_client_start
    0x8800100:   5f 64 69 73 63 6f 76 65 72 79 00 00 21 21 21 73    _discovery..!!!s
    0x8800110:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 73    imp_ble_client_s
    0x8800120:   74 61 72 74 5f 64 69 73 63 6f 76 65 72 79 3a 20    tart_discovery: 
    0x8800130:   66 61 69 6c 65 64 20 69 6e 76 61 6c 69 64 20 63    failed invalid c
    0x8800140:   6f 6e 6e 5f 69 64 20 25 64 00 00 00 21 21 21 73    onn_id %d...!!!s
    0x8800150:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 72    imp_ble_client_r
    0x8800160:   65 61 64 5f 62 79 5f 68 61 6e 64 6c 65 3a 20 66    ead_by_handle: f
    0x8800170:   61 69 6c 65 64 20 69 6e 76 61 6c 69 64 20 63 6f    ailed invalid co
    0x8800180:   6e 6e 5f 69 64 20 25 64 00 00 00 00 21 2a 2a 76    nn_id %d....!**v
    0x8800190:   73 6f 70 2d 2d 2d 2d 72 65 61 64 5f 62 79 5f 68    sop----read_by_h
    0x88001a0:   61 6e 64 6c 65 2d 2d 2d 2d 2d 2d 72 65 74 75 72    andle------retur
    0x88001b0:   6e 3d 25 64 00 00 00 00 21 2a 2a 76 73 6f 70 2d    n=%d....!**vsop-
    0x88001c0:   2d 2d 2d 72 65 61 64 5f 62 79 5f 68 61 6e 64 6c    ---read_by_handl
    0x88001d0:   65 2d 2d 2d 2d 2d 2d 72 65 61 64 5f 74 79 70 65    e------read_type
    0x88001e0:   3d 25 64 00 21 2a 2a 76 73 6f 70 2d 2d 2d 2d 72    =%d.!**vsop----r
    0x88001f0:   65 61 64 5f 62 79 5f 68 61 6e 64 6c 65 2d 2d 2d    ead_by_handle---
    0x8800200:   2d 2d 2d 68 64 6c 5f 76 61 6c 69 64 3d 25 64 00    ---hdl_valid=%d.
    0x8800210:   21 2a 2a 76 73 6f 70 2d 2d 2d 2d 72 65 61 64 5f    !**vsop----read_
    0x8800220:   62 79 5f 68 61 6e 64 6c 65 2d 2d 2d 2d 2d 2d 6f    by_handle------o
    0x8800230:   6b 6b 6b 6b 6b 3d 25 64 00 00 00 00 21 21 2a 73    kkkkk=%d....!!*s
    0x8800240:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 72    imp_ble_client_r
    0x8800250:   65 61 64 5f 62 79 5f 68 61 6e 64 6c 65 3a 20 52    ead_by_handle: R
    0x8800260:   65 71 75 65 73 74 20 66 61 69 6c 21 20 50 6c 65    equest fail! Ple
    0x8800270:   61 73 65 20 63 68 65 63 6b 21 00 00 21 21 21 73    ase check!..!!!s
    0x8800280:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 72    imp_ble_client_r
    0x8800290:   65 61 64 5f 62 79 5f 75 75 69 64 3a 20 66 61 69    ead_by_uuid: fai
    0x88002a0:   6c 65 64 20 69 6e 76 61 6c 69 64 20 63 6f 6e 6e    led invalid conn
    0x88002b0:   5f 69 64 20 25 64 00 00 21 2a 2a 76 73 6f 70 2d    _id %d..!**vsop-
    0x88002c0:   2d 2d 2d 72 65 61 64 5f 62 79 5f 75 75 69 64 2d    ---read_by_uuid-
    0x88002d0:   2d 2d 2d 2d 2d 72 65 61 64 5f 74 79 70 65 3d 25    -----read_type=%
    0x88002e0:   64 00 00 00 21 2a 2a 76 73 6f 70 2d 2d 2d 2d 72    d...!**vsop----r
    0x88002f0:   65 61 64 5f 62 79 5f 75 75 69 64 2d 2d 2d 2d 2d    ead_by_uuid-----
    0x8800300:   2d 20 53 49 4d 50 5f 52 45 41 44 5f 56 33 5f 4e    - SIMP_READ_V3_N
    0x8800310:   4f 54 49 46 59 5f 43 43 43 44 00 00 21 21 21 73    OTIFY_CCCD..!!!s
    0x8800320:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 73    imp_ble_client_s
    0x8800330:   65 74 5f 76 33 5f 6e 6f 74 69 66 79 3a 20 66 61    et_v3_notify: fa
    0x8800340:   69 6c 65 64 20 69 6e 76 61 6c 69 64 20 63 6f 6e    iled invalid con
    0x8800350:   6e 5f 69 64 20 25 64 00 21 2a 2a 76 73 6f 70 2d    n_id %d.!**vsop-
    0x8800360:   2d 2d 2d 73 69 6d 70 5f 62 6c 65 5f 63 6c 69 65    ---simp_ble_clie
    0x8800370:   6e 74 5f 73 65 74 5f 76 33 5f 6e 6f 74 69 66 79    nt_set_v3_notify
    0x8800380:   20 3d 09 30 78 25 30 32 58 00 00 00 21 21 2a 73     =.0x%02X...!!*s
    0x8800390:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 73    imp_ble_client_s
    0x88003a0:   65 74 5f 76 33 5f 6e 6f 74 69 66 79 3a 20 52 65    et_v3_notify: Re
    0x88003b0:   71 75 65 73 74 20 66 61 69 6c 21 20 50 6c 65 61    quest fail! Plea
    0x88003c0:   73 65 20 63 68 65 63 6b 21 00 00 00 21 21 21 73    se check!...!!!s
    0x88003d0:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 73    imp_ble_client_s
    0x88003e0:   65 74 5f 76 34 5f 69 6e 64 3a 20 66 61 69 6c 65    et_v4_ind: faile
    0x88003f0:   64 20 69 6e 76 61 6c 69 64 20 63 6f 6e 6e 5f 69    d invalid conn_i
    0x8800400:   64 20 25 64 00 00 00 00 21 2a 2a 76 73 6f 70 2d    d %d....!**vsop-
    0x8800410:   2d 2d 2d 48 44 4c 5f 53 49 4d 42 4c 45 5f 56 34    ---HDL_SIMBLE_V4
    0x8800420:   5f 49 4e 44 49 43 41 54 45 5f 43 43 43 44 20 3d    _INDICATE_CCCD =
    0x8800430:   20 20 30 78 25 30 32 58 00 00 00 00 21 21 2a 73      0x%02X....!!*s
    0x8800440:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 73    imp_ble_client_s
    0x8800450:   65 74 5f 76 34 5f 69 6e 64 3a 20 52 65 71 75 65    et_v4_ind: Reque
    0x8800460:   73 74 20 66 61 69 6c 21 20 50 6c 65 61 73 65 20    st fail! Please 
    0x8800470:   63 68 65 63 6b 21 00 00 21 21 21 73 69 6d 70 5f    check!..!!!simp_
    0x8800480:   62 6c 65 5f 63 6c 69 65 6e 74 5f 77 72 69 74 65    ble_client_write
    0x8800490:   5f 76 32 5f 63 68 61 72 3a 20 66 61 69 6c 65 64    _v2_char: failed
    0x88004a0:   20 69 6e 76 61 6c 69 64 20 63 6f 6e 6e 5f 69 64     invalid conn_id
    0x88004b0:   20 25 64 00 21 21 2a 73 69 6d 70 5f 62 6c 65 5f     %d.!!*simp_ble_
    0x88004c0:   63 6c 69 65 6e 74 5f 77 72 69 74 65 5f 76 32 5f    client_write_v2_
    0x88004d0:   63 68 61 72 3a 20 52 65 71 75 65 73 74 20 66 61    char: Request fa
    0x88004e0:   69 6c 21 20 50 6c 65 61 73 65 20 63 68 65 63 6b    il! Please check
    0x88004f0:   21 00 00 00 21 21 21 73 69 6d 70 5f 62 6c 65 5f    !...!!!simp_ble_
    0x8800500:   63 6c 69 65 6e 74 5f 67 65 74 5f 68 64 6c 5f 63    client_get_hdl_c
    0x8800510:   61 63 68 65 3a 20 66 61 69 6c 65 64 20 69 6e 76    ache: failed inv
    0x8800520:   61 6c 69 64 20 63 6f 6e 6e 5f 69 64 20 25 64 00    alid conn_id %d.
    0x8800530:   21 21 21 73 69 6d 70 5f 62 6c 65 5f 63 6c 69 65    !!!simp_ble_clie
    0x8800540:   6e 74 5f 67 65 74 5f 68 64 6c 5f 63 61 63 68 65    nt_get_hdl_cache
    0x8800550:   3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c 69 64    : failed invalid
    0x8800560:   20 73 74 61 74 65 20 25 64 00 00 00 21 21 21 73     state %d...!!!s
    0x8800570:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 67    imp_ble_client_g
    0x8800580:   65 74 5f 68 64 6c 5f 63 61 63 68 65 3a 20 66 61    et_hdl_cache: fa
    0x8800590:   69 6c 65 64 20 69 6e 76 61 6c 69 64 20 6c 65 6e    iled invalid len
    0x88005a0:   20 25 64 00 21 21 21 73 69 6d 70 5f 62 6c 65 5f     %d.!!!simp_ble_
    0x88005b0:   63 6c 69 65 6e 74 5f 73 65 74 5f 68 64 6c 5f 63    client_set_hdl_c
    0x88005c0:   61 63 68 65 3a 20 66 61 69 6c 65 64 20 69 6e 76    ache: failed inv
    0x88005d0:   61 6c 69 64 20 63 6f 6e 6e 5f 69 64 20 25 64 00    alid conn_id %d.
    0x88005e0:   21 21 21 73 69 6d 70 5f 62 6c 65 5f 63 6c 69 65    !!!simp_ble_clie
    0x88005f0:   6e 74 5f 73 65 74 5f 68 64 6c 5f 63 61 63 68 65    nt_set_hdl_cache
    0x8800600:   3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c 69 64    : failed invalid
    0x8800610:   20 73 74 61 74 65 20 25 64 00 00 00 21 21 21 73     state %d...!!!s
    0x8800620:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 73    imp_ble_client_s
    0x8800630:   65 74 5f 68 64 6c 5f 63 61 63 68 65 3a 20 66 61    et_hdl_cache: fa
    0x8800640:   69 6c 65 64 20 69 6e 76 61 6c 69 64 20 6c 65 6e    iled invalid len
    0x8800650:   20 25 64 00 21 2a 2a 73 69 6d 70 5f 62 6c 65 5f     %d.!**simp_ble_
    0x8800660:   63 6c 69 65 6e 74 5f 73 74 61 72 74 5f 73 69 6d    client_start_sim
    0x8800670:   70 5f 63 68 61 72 5f 64 69 73 63 6f 76 65 72 79    p_char_discovery
    0x8800680:   00 00 00 00 21 2a 2a 73 69 6d 70 5f 62 6c 65 5f    ....!**simp_ble_
    0x8800690:   63 6c 69 65 6e 74 5f 73 74 61 72 74 5f 63 68 61    client_start_cha
    0x88006a0:   72 5f 64 65 73 63 72 69 70 74 6f 72 5f 64 69 73    r_descriptor_dis
    0x88006b0:   63 6f 76 65 72 79 00 00 21 2a 2a 73 69 6d 70 5f    covery..!**simp_
    0x88006c0:   62 6c 65 5f 63 6c 69 65 6e 74 5f 64 69 73 63 6f    ble_client_disco
    0x88006d0:   76 65 72 5f 73 74 61 74 65 5f 63 62 3a 20 64 69    ver_state_cb: di
    0x88006e0:   73 63 6f 76 65 72 79 5f 73 74 61 74 65 20 25 64    scovery_state %d
    0x88006f0:   00 00 00 00 21 21 21 73 69 6d 70 5f 68 61 6e 64    ....!!!simp_hand
    0x8800700:   6c 65 5f 64 69 73 63 6f 76 65 72 5f 73 74 61 74    le_discover_stat
    0x8800710:   65 3a 20 49 6e 76 61 6c 69 64 20 44 69 73 63 6f    e: Invalid Disco
    0x8800720:   76 65 72 79 20 53 74 61 74 65 21 00 21 2a 2a 73    very State!.!**s
    0x8800730:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 64    imp_ble_client_d
    0x8800740:   69 73 63 6f 76 65 72 5f 72 65 73 75 6c 74 5f 63    iscover_result_c
    0x8800750:   62 3a 20 72 65 73 75 6c 74 5f 74 79 70 65 20 25    b: result_type %
    0x8800760:   64 20 2c 20 30 78 25 30 32 58 00 00 21 2a 2a 76    d , 0x%02X..!**v
    0x8800770:   73 6f 70 20 73 69 6d 70 5f 62 6c 65 5f 63 6c 69    sop simp_ble_cli
    0x8800780:   65 6e 74 5f 64 69 73 63 6f 76 65 72 5f 72 65 73    ent_discover_res
    0x8800790:   75 6c 74 5f 63 62 3a 20 72 65 73 75 6c 74 5f 74    ult_cb: result_t
    0x88007a0:   79 70 65 20 25 64 20 2c 20 30 78 25 30 32 58 00    ype %d , 0x%02X.
    0x88007b0:   21 2a 2a 76 73 6f 70 20 72 65 73 75 6c 74 5f 64    !**vsop result_d
    0x88007c0:   61 74 61 20 44 49 53 43 5f 52 45 53 55 4c 54 5f    ata DISC_RESULT_
    0x88007d0:   43 48 41 52 5f 55 55 49 44 31 36 3a 20 30 78 25    CHAR_UUID16: 0x%
    0x88007e0:   30 32 58 00 21 2a 2a 76 73 6f 70 2b 2b 2b 2b 2b    02X.!**vsop+++++
    0x88007f0:   2b 2b 2b 2b 2b 2b 2b 2b 47 41 54 54 5f 55 55 49    ++++++++GATT_UUI
    0x8800800:   44 5f 43 48 41 52 5f 53 49 4d 50 4c 45 5f 56 33    D_CHAR_SIMPLE_V3
    0x8800810:   5f 4e 4f 54 49 46 59 2c 20 68 61 6e 64 6c 65 3d    _NOTIFY, handle=
    0x8800820:   25 64 00 00 21 2a 2a 76 73 6f 70 2b 2b 2b 2b 2b    %d..!**vsop+++++
    0x8800830:   2b 2b 2b 2b 2b 2b 2b 2b 47 41 54 54 5f 55 55 49    ++++++++GATT_UUI
    0x8800840:   44 5f 43 48 41 52 5f 53 49 4d 50 4c 45 5f 56 34    D_CHAR_SIMPLE_V4
    0x8800850:   5f 49 4e 44 49 43 41 54 45 2c 20 68 61 6e 64 6c    _INDICATE, handl
    0x8800860:   65 3d 25 64 00 00 00 00 21 2a 2a 76 73 6f 70 20    e=%d....!**vsop 
    0x8800870:   31 20 44 49 53 43 5f 52 45 53 55 4c 54 5f 43 48    1 DISC_RESULT_CH
    0x8800880:   41 52 5f 44 45 53 43 5f 55 55 49 44 31 36 3a 20    AR_DESC_UUID16: 
    0x8800890:   75 75 69 64 31 36 20 2c 20 30 78 25 30 32 58 00    uuid16 , 0x%02X.
    0x88008a0:   21 2a 2a 76 73 6f 70 20 32 20 44 49 53 43 5f 52    !**vsop 2 DISC_R
    0x88008b0:   45 53 55 4c 54 5f 43 48 41 52 5f 44 45 53 43 5f    ESULT_CHAR_DESC_
    0x88008c0:   55 55 49 44 31 36 3a 20 68 61 6e 64 6c 65 20 2c    UUID16: handle ,
    0x88008d0:   20 30 78 25 30 32 58 00 21 2a 2a 76 73 6f 70 78     0x%02X.!**vsopx
    0x88008e0:   78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78    xxxxxxxxxxxxxxxx
    0x88008f0:   31 2c 20 68 61 6e 64 6c 65 3d 25 64 00 00 00 00    1, handle=%d....
    0x8800900:   21 2a 2a 76 73 6f 70 78 78 78 78 78 78 78 78 78    !**vsopxxxxxxxxx
    0x8800910:   78 78 78 78 78 78 78 78 32 2c 20 68 61 6e 64 6c    xxxxxxxx2, handl
    0x8800920:   65 3d 25 64 00 00 00 00 21 21 21 73 69 6d 70 5f    e=%d....!!!simp_
    0x8800930:   68 61 6e 64 6c 65 5f 64 69 73 63 6f 76 65 72 5f    handle_discover_
    0x8800940:   72 65 73 75 6c 74 3a 20 49 6e 76 61 6c 69 64 20    result: Invalid 
    0x8800950:   44 69 73 63 6f 76 65 72 79 20 52 65 73 75 6c 74    Discovery Result
    0x8800960:   20 54 79 70 65 21 00 00 21 2a 2a 73 69 6d 70 5f     Type!..!**simp_
    0x8800970:   62 6c 65 5f 63 6c 69 65 6e 74 5f 72 65 61 64 5f    ble_client_read_
    0x8800980:   72 65 73 75 6c 74 5f 63 62 3a 20 68 61 6e 64 6c    result_cb: handl
    0x8800990:   65 20 30 78 25 78 2c 20 63 61 75 73 65 20 30 78    e 0x%x, cause 0x
    0x88009a0:   25 78 00 00 21 21 21 73 69 6d 70 5f 62 6c 65 5f    %x..!!!simp_ble_
    0x88009b0:   63 6c 69 65 6e 74 5f 72 65 61 64 5f 72 65 73 75    client_read_resu
    0x88009c0:   6c 74 5f 63 62 3a 20 69 6e 76 61 6c 69 64 20 63    lt_cb: invalid c
    0x88009d0:   63 63 64 20 6c 65 6e 20 25 64 00 00 21 2a 2a 76    ccd len %d..!**v
    0x88009e0:   73 6f 70 2d 2d 2d 2d 2d 2d 2d 20 69 6e 64 69 63    sop------- indic
    0x88009f0:   61 74 65 20 5f 63 63 63 64 20 31 00 21 21 21 73    ate _cccd 1.!!!s
    0x8800a00:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 72    imp_ble_client_r
    0x8800a10:   65 61 64 5f 72 65 73 75 6c 74 5f 63 62 3a 20 69    ead_result_cb: i
    0x8800a20:   6e 76 61 6c 69 64 20 63 63 63 64 20 6c 65 6e 20    nvalid cccd len 
    0x8800a30:   25 64 00 00 21 2a 2a 76 73 6f 70 2d 2d 2d 2d 2d    %d..!**vsop-----
    0x8800a40:   2d 2d 20 69 6e 64 69 63 61 74 65 20 5f 63 63 63    -- indicate _ccc
    0x8800a50:   64 20 3d 20 20 25 64 00 21 2a 2a 73 69 6d 70 5f    d =  %d.!**simp_
    0x8800a60:   62 6c 65 5f 63 6c 69 65 6e 74 5f 77 72 69 74 65    ble_client_write
    0x8800a70:   5f 72 65 73 75 6c 74 5f 63 62 3a 20 68 61 6e 64    _result_cb: hand
    0x8800a80:   6c 65 20 30 78 25 78 2c 20 63 61 75 73 65 20 30    le 0x%x, cause 0
    0x8800a90:   78 25 78 00 21 2a 2a 76 73 6f 70 2d 2d 2d 2d 2d    x%x.!**vsop-----
    0x8800aa0:   2d 2d 2d 2d 2d 2d 2d 48 44 4c 5f 53 49 4d 42 4c    -------HDL_SIMBL
    0x8800ab0:   45 5f 56 33 5f 4e 4f 54 49 46 59 20 25 64 00 00    E_V3_NOTIFY %d..
    0x8800ac0:   21 2a 2a 76 73 6f 70 2d 2d 2d 2d 2d 2d 2d 2d 2d    !**vsop---------
    0x8800ad0:   2d 2d 2d 48 44 4c 5f 53 49 4d 42 4c 45 5f 56 34    ---HDL_SIMBLE_V4
    0x8800ae0:   5f 49 4e 44 49 43 41 54 45 20 25 64 00 00 00 00    _INDICATE %d....
    0x8800af0:   21 2a 2a 76 73 6f 70 2d 2d 2d 2d 2d 2d 2d 2d 2d    !**vsop---------
    0x8800b00:   2d 2d 2d 6e 6f 20 68 61 6e 64 6c 65 20 25 64 00    ---no handle %d.
    0x8800b10:   21 2a 2a 76 73 6f 70 2d 2d 2d 2d 2d 2d 2d 2d 2d    !**vsop---------
    0x8800b20:   2d 2d 2d 73 69 6d 70 5f 63 6c 69 65 6e 74 5f 63    ---simp_client_c
    0x8800b30:   62 20 25 64 00 00 00 00 21 2a 2a 76 73 6f 70 2d    b %d....!**vsop-
    0x8800b40:   2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 72 65 74 75 72    -----------retur
    0x8800b50:   6e 20 25 64 00 00 00 00 21 2a 2a 73 69 6d 70 5f    n %d....!**simp_
    0x8800b60:   62 6c 65 5f 63 6c 69 65 6e 74 5f 64 69 73 63 6f    ble_client_disco
    0x8800b70:   6e 6e 65 63 74 5f 63 62 2e 00 00 00 21 21 21 73    nnect_cb....!!!s
    0x8800b80:   69 6d 70 5f 62 6c 65 5f 63 6c 69 65 6e 74 5f 64    imp_ble_client_d
    0x8800b90:   69 73 63 6f 6e 6e 65 63 74 5f 63 62 3a 20 66 61    isconnect_cb: fa
    0x8800ba0:   69 6c 65 64 20 69 6e 76 61 6c 69 64 20 63 6f 6e    iled invalid con
    0x8800bb0:   6e 5f 69 64 20 25 64 00 21 21 21 73 69 6d 70 5f    n_id %d.!!!simp_
    0x8800bc0:   62 6c 65 5f 61 64 64 5f 63 6c 69 65 6e 74 3a 20    ble_add_client: 
    0x8800bd0:   69 6e 76 61 6c 69 64 20 6c 69 6e 6b 5f 6e 75 6d    invalid link_num
    0x8800be0:   20 25 64 00 21 21 21 73 69 6d 70 5f 62 6c 65 5f     %d.!!!simp_ble_
    0x8800bf0:   61 64 64 5f 63 6c 69 65 6e 74 20 66 61 69 6c 65    add_client faile
    0x8800c00:   64 00 00 00 21 2a 2a 73 69 6d 70 5f 62 6c 65 5f    d...!**simp_ble_
    0x8800c10:   61 64 64 5f 63 6c 69 65 6e 74 3a 20 73 69 6d 70    add_client: simp
    0x8800c20:   5f 63 6c 69 65 6e 74 20 25 64 00 00 21 2a 2a 62    _client %d..!**b
    0x8800c30:   61 73 5f 73 74 61 72 74 5f 64 69 73 63 6f 76 65    as_start_discove
    0x8800c40:   72 79 00 00 21 21 21 62 61 73 5f 73 74 61 72 74    ry..!!!bas_start
    0x8800c50:   5f 64 69 73 63 6f 76 65 72 79 3a 20 66 61 69 6c    _discovery: fail
    0x8800c60:   65 64 20 69 6e 76 61 6c 69 64 20 63 6f 6e 6e 5f    ed invalid conn_
    0x8800c70:   69 64 20 25 64 00 00 00 21 21 21 62 61 73 5f 72    id %d...!!!bas_r
    0x8800c80:   65 61 64 5f 62 61 74 74 65 72 79 5f 6c 65 76 65    ead_battery_leve
    0x8800c90:   6c 3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c 69    l: failed invali
    0x8800ca0:   64 20 63 6f 6e 6e 5f 69 64 20 25 64 00 00 00 00    d conn_id %d....
    0x8800cb0:   21 21 21 62 61 73 5f 72 65 61 64 5f 62 61 74 74    !!!bas_read_batt
    0x8800cc0:   65 72 79 5f 6c 65 76 65 6c 3a 20 66 61 6c 73 65    ery_level: false
    0x8800cd0:   20 68 61 6e 64 6c 65 20 3d 20 30 00 21 21 21 62     handle = 0.!!!b
    0x8800ce0:   61 73 5f 73 65 74 5f 6e 6f 74 69 66 79 3a 20 66    as_set_notify: f
    0x8800cf0:   61 69 6c 65 64 20 69 6e 76 61 6c 69 64 20 63 6f    ailed invalid co
    0x8800d00:   6e 6e 5f 69 64 20 25 64 00 00 00 00 21 21 21 62    nn_id %d....!!!b
    0x8800d10:   61 73 5f 73 65 74 5f 6e 6f 74 69 66 79 3a 20 66    as_set_notify: f
    0x8800d20:   61 6c 73 65 20 68 61 6e 64 6c 65 20 3d 20 30 00    alse handle = 0.
    0x8800d30:   21 21 21 62 61 73 5f 72 65 61 64 5f 6e 6f 74 69    !!!bas_read_noti
    0x8800d40:   66 79 3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c    fy: failed inval
    0x8800d50:   69 64 20 63 6f 6e 6e 5f 69 64 20 25 64 00 00 00    id conn_id %d...
    0x8800d60:   21 21 21 62 61 73 5f 72 65 61 64 5f 62 61 74 74    !!!bas_read_batt
    0x8800d70:   65 72 79 5f 6c 65 76 65 6c 3a 20 66 61 6c 73 65    ery_level: false
    0x8800d80:   20 68 61 6e 64 6c 65 20 3d 20 30 00 21 21 21 62     handle = 0.!!!b
    0x8800d90:   61 73 5f 67 65 74 5f 68 64 6c 5f 63 61 63 68 65    as_get_hdl_cache
    0x8800da0:   3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c 69 64    : failed invalid
    0x8800db0:   20 63 6f 6e 6e 5f 69 64 20 25 64 00 21 21 21 62     conn_id %d.!!!b
    0x8800dc0:   61 73 5f 67 65 74 5f 68 64 6c 5f 63 61 63 68 65    as_get_hdl_cache
    0x8800dd0:   3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c 69 64    : failed invalid
    0x8800de0:   20 73 74 61 74 65 20 25 64 00 00 00 21 21 21 62     state %d...!!!b
    0x8800df0:   61 73 5f 67 65 74 5f 68 64 6c 5f 63 61 63 68 65    as_get_hdl_cache
    0x8800e00:   3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c 69 64    : failed invalid
    0x8800e10:   20 6c 65 6e 20 25 64 00 21 21 21 62 61 73 5f 73     len %d.!!!bas_s
    0x8800e20:   65 74 5f 68 64 6c 5f 63 61 63 68 65 3a 20 66 61    et_hdl_cache: fa
    0x8800e30:   69 6c 65 64 20 69 6e 76 61 6c 69 64 20 63 6f 6e    iled invalid con
    0x8800e40:   6e 5f 69 64 20 25 64 00 21 21 21 62 61 73 5f 73    n_id %d.!!!bas_s
    0x8800e50:   65 74 5f 68 64 6c 5f 63 61 63 68 65 3a 20 66 61    et_hdl_cache: fa
    0x8800e60:   69 6c 65 64 20 69 6e 76 61 6c 69 64 20 73 74 61    iled invalid sta
    0x8800e70:   74 65 20 25 64 00 00 00 21 21 21 62 61 73 5f 73    te %d...!!!bas_s
    0x8800e80:   65 74 5f 68 64 6c 5f 63 61 63 68 65 3a 20 66 61    et_hdl_cache: fa
    0x8800e90:   69 6c 65 64 20 69 6e 76 61 6c 69 64 20 6c 65 6e    iled invalid len
    0x8800ea0:   20 25 64 00 21 2a 2a 62 61 73 5f 73 74 61 72 74     %d.!**bas_start
    0x8800eb0:   5f 63 68 61 72 5f 64 69 73 63 6f 76 65 72 79 00    _char_discovery.
    0x8800ec0:   21 2a 2a 62 61 73 5f 73 74 61 72 74 5f 63 68 61    !**bas_start_cha
    0x8800ed0:   72 5f 64 65 73 63 72 69 70 74 6f 72 5f 64 69 73    r_descriptor_dis
    0x8800ee0:   63 6f 76 65 72 79 00 00 21 2a 2a 62 61 73 5f 63    covery..!**bas_c
    0x8800ef0:   6c 69 65 6e 74 5f 64 69 73 63 6f 76 65 72 5f 73    lient_discover_s
    0x8800f00:   74 61 74 65 5f 63 62 3a 20 64 69 73 63 6f 76 65    tate_cb: discove
    0x8800f10:   72 79 5f 73 74 61 74 65 20 3d 20 25 64 00 00 00    ry_state = %d...
    0x8800f20:   21 21 21 49 6e 76 61 6c 69 64 20 44 69 73 63 6f    !!!Invalid Disco
    0x8800f30:   76 65 72 79 20 53 74 61 74 65 21 00 21 2a 2a 62    very State!.!**b
    0x8800f40:   61 73 5f 63 6c 69 65 6e 74 5f 64 69 73 63 6f 76    as_client_discov
    0x8800f50:   65 72 5f 72 65 73 75 6c 74 5f 63 62 3a 20 72 65    er_result_cb: re
    0x8800f60:   73 75 6c 74 5f 74 79 70 65 20 3d 20 25 64 00 00    sult_type = %d..
    0x8800f70:   21 21 21 49 6e 76 61 6c 69 64 20 44 69 73 63 6f    !!!Invalid Disco
    0x8800f80:   76 65 72 79 20 52 65 73 75 6c 74 20 54 79 70 65    very Result Type
    0x8800f90:   21 00 00 00 21 2a 2a 62 61 73 5f 63 6c 69 65 6e    !...!**bas_clien
    0x8800fa0:   74 5f 77 72 69 74 65 5f 72 65 73 75 6c 74 5f 63    t_write_result_c
    0x8800fb0:   62 3a 20 68 61 6e 64 6c 65 20 30 78 25 78 2c 20    b: handle 0x%x, 
    0x8800fc0:   63 61 75 73 65 20 30 78 25 78 00 00 21 2a 2a 62    cause 0x%x..!**b
    0x8800fd0:   61 73 5f 63 6c 69 65 6e 74 5f 72 65 61 64 5f 72    as_client_read_r
    0x8800fe0:   65 73 75 6c 74 5f 63 62 3a 20 68 61 6e 64 6c 65    esult_cb: handle
    0x8800ff0:   20 30 78 25 78 2c 20 63 61 75 73 65 20 30 78 25     0x%x, cause 0x%
    0x8801000:   78 00 00 00 21 21 21 62 61 73 5f 63 6c 69 65 6e    x...!!!bas_clien
    0x8801010:   74 5f 72 65 61 64 5f 72 65 73 75 6c 74 5f 63 62    t_read_result_cb
    0x8801020:   3a 20 69 6e 76 61 6c 69 64 20 63 63 63 64 20 6c    : invalid cccd l
    0x8801030:   65 6e 20 25 64 00 00 00 21 21 21 62 61 73 5f 63    en %d...!!!bas_c
    0x8801040:   6c 69 65 6e 74 5f 72 65 61 64 5f 72 65 73 75 6c    lient_read_resul
    0x8801050:   74 5f 63 62 3a 20 69 6e 76 61 6c 69 64 20 62 61    t_cb: invalid ba
    0x8801060:   74 74 65 72 79 20 76 61 6c 75 65 20 6c 65 6e 20    ttery value len 
    0x8801070:   25 64 00 00 21 2a 2a 62 61 73 5f 63 6c 69 65 6e    %d..!**bas_clien
    0x8801080:   74 5f 64 69 73 63 5f 63 62 2e 00 00 21 21 21 62    t_disc_cb...!!!b
    0x8801090:   61 73 5f 63 6c 69 65 6e 74 5f 64 69 73 63 5f 63    as_client_disc_c
    0x88010a0:   62 3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c 69    b: failed invali
    0x88010b0:   64 20 63 6f 6e 6e 5f 69 64 20 25 64 00 00 00 00    d conn_id %d....
    0x88010c0:   21 21 21 62 61 73 5f 61 64 64 5f 63 6c 69 65 6e    !!!bas_add_clien
    0x88010d0:   74 3a 20 69 6e 76 61 6c 69 64 20 6c 69 6e 6b 5f    t: invalid link_
    0x88010e0:   6e 75 6d 20 25 64 00 00 21 21 21 62 61 73 5f 61    num %d..!!!bas_a
    0x88010f0:   64 64 5f 63 6c 69 65 6e 74 3a 72 65 67 69 73 74    dd_client:regist
    0x8801100:   65 72 20 66 61 69 6c 00 21 2a 2a 62 61 73 5f 61    er fail.!**bas_a
    0x8801110:   64 64 5f 63 6c 69 65 6e 74 3a 20 63 6c 69 65 6e    dd_client: clien
    0x8801120:   74 20 69 64 20 25 64 00 21 2a 2a 67 61 70 73 5f    t id %d.!**gaps_
    0x8801130:   73 74 61 72 74 5f 64 69 73 63 6f 76 65 72 79 00    start_discovery.
    0x8801140:   21 21 21 67 61 70 73 5f 73 74 61 72 74 5f 64 69    !!!gaps_start_di
    0x8801150:   73 63 6f 76 65 72 79 3a 20 66 61 69 6c 65 64 20    scovery: failed 
    0x8801160:   69 6e 76 61 6c 69 64 20 63 6f 6e 6e 5f 69 64 20    invalid conn_id 
    0x8801170:   25 64 00 00 21 21 21 67 61 70 73 5f 72 65 61 64    %d..!!!gaps_read
    0x8801180:   3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c 69 64    : failed invalid
    0x8801190:   20 63 6f 6e 6e 5f 69 64 20 25 64 00 21 2a 2a 67     conn_id %d.!**g
    0x88011a0:   61 70 73 5f 72 65 61 64 3a 20 63 68 61 72 54 79    aps_read: charTy
    0x88011b0:   70 65 20 3d 20 25 64 00 21 21 2a 67 61 70 73 5f    pe = %d.!!*gaps_
    0x88011c0:   72 65 61 64 3a 20 52 65 71 75 65 73 74 20 66 61    read: Request fa
    0x88011d0:   69 6c 21 20 50 6c 65 61 73 65 20 63 68 65 63 6b    il! Please check
    0x88011e0:   21 00 00 00 21 21 21 67 61 70 73 5f 67 65 74 5f    !...!!!gaps_get_
    0x88011f0:   68 64 6c 5f 63 61 63 68 65 3a 20 66 61 69 6c 65    hdl_cache: faile
    0x8801200:   64 20 69 6e 76 61 6c 69 64 20 63 6f 6e 6e 5f 69    d invalid conn_i
    0x8801210:   64 20 25 64 00 00 00 00 21 21 21 67 61 70 73 5f    d %d....!!!gaps_
    0x8801220:   67 65 74 5f 68 64 6c 5f 63 61 63 68 65 3a 20 66    get_hdl_cache: f
    0x8801230:   61 69 6c 65 64 20 69 6e 76 61 6c 69 64 20 73 74    ailed invalid st
    0x8801240:   61 74 65 20 25 64 00 00 21 21 21 67 61 70 73 5f    ate %d..!!!gaps_
    0x8801250:   67 65 74 5f 68 64 6c 5f 63 61 63 68 65 3a 20 66    get_hdl_cache: f
    0x8801260:   61 69 6c 65 64 20 69 6e 76 61 6c 69 64 20 6c 65    ailed invalid le
    0x8801270:   6e 20 25 64 00 00 00 00 21 21 21 67 61 70 73 5f    n %d....!!!gaps_
    0x8801280:   73 65 74 5f 68 64 6c 5f 63 61 63 68 65 3a 20 66    set_hdl_cache: f
    0x8801290:   61 69 6c 65 64 20 69 6e 76 61 6c 69 64 20 63 6f    ailed invalid co
    0x88012a0:   6e 6e 5f 69 64 20 25 64 00 00 00 00 21 21 21 67    nn_id %d....!!!g
    0x88012b0:   61 70 73 5f 73 65 74 5f 68 64 6c 5f 63 61 63 68    aps_set_hdl_cach
    0x88012c0:   65 3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c 69    e: failed invali
    0x88012d0:   64 20 73 74 61 74 65 20 25 64 00 00 21 21 21 67    d state %d..!!!g
    0x88012e0:   61 70 73 5f 73 65 74 5f 68 64 6c 5f 63 61 63 68    aps_set_hdl_cach
    0x88012f0:   65 3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c 69    e: failed invali
    0x8801300:   64 20 6c 65 6e 20 25 64 00 00 00 00 21 21 21 67    d len %d....!!!g
    0x8801310:   61 70 73 5f 67 65 74 5f 68 64 6c 5f 63 61 63 68    aps_get_hdl_cach
    0x8801320:   65 3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c 69    e: failed invali
    0x8801330:   64 20 63 6f 6e 6e 5f 69 64 20 25 64 00 00 00 00    d conn_id %d....
    0x8801340:   21 21 21 67 61 70 73 5f 67 65 74 5f 68 64 6c 5f    !!!gaps_get_hdl_
    0x8801350:   63 61 63 68 65 3a 20 66 61 69 6c 65 64 20 69 6e    cache: failed in
    0x8801360:   76 61 6c 69 64 20 73 74 61 74 65 20 25 64 00 00    valid state %d..
    0x8801370:   21 2a 2a 67 61 70 5f 63 6c 69 65 6e 74 5f 73 74    !**gap_client_st
    0x8801380:   61 72 74 5f 67 61 70 5f 63 68 61 72 5f 64 69 73    art_gap_char_dis
    0x8801390:   63 6f 76 65 72 79 00 00 21 2a 2a 67 61 70 73 5f    covery..!**gaps_
    0x88013a0:   63 6c 69 65 6e 74 5f 64 69 73 63 6f 76 65 72 5f    client_discover_
    0x88013b0:   73 74 61 74 65 5f 63 62 3a 20 64 69 73 63 6f 76    state_cb: discov
    0x88013c0:   65 72 79 5f 73 74 61 74 65 20 25 64 00 00 00 00    ery_state %d....
    0x88013d0:   21 21 21 44 49 53 43 5f 53 54 41 54 45 5f 46 41    !!!DISC_STATE_FA
    0x88013e0:   49 4c 45 44 00 00 00 00 21 21 21 49 6e 76 61 6c    ILED....!!!Inval
    0x88013f0:   69 64 20 44 69 73 63 6f 76 65 72 79 20 53 74 61    id Discovery Sta
    0x8801400:   74 65 21 00 21 2a 2a 67 61 70 5f 63 6c 69 65 6e    te!.!**gap_clien
    0x8801410:   74 5f 64 69 73 63 6f 76 65 72 5f 72 65 73 75 6c    t_discover_resul
    0x8801420:   74 5f 63 62 3a 20 72 65 73 75 6c 74 5f 74 79 70    t_cb: result_typ
    0x8801430:   65 20 3d 20 25 64 00 00 21 2a 2a 47 41 54 54 5f    e = %d..!**GATT_
    0x8801440:   55 55 49 44 5f 43 48 41 52 5f 43 45 4e 54 52 41    UUID_CHAR_CENTRA
    0x8801450:   4c 5f 41 44 44 52 45 53 53 5f 52 45 53 4f 4c 55    L_ADDRESS_RESOLU
    0x8801460:   54 49 4f 4e 20 66 6f 75 6e 64 00 00 21 2a 2a 47    TION found..!**G
    0x8801470:   41 54 54 5f 55 55 49 44 5f 43 48 41 52 5f 52 45    ATT_UUID_CHAR_RE
    0x8801480:   53 4f 4c 56 41 42 4c 45 5f 50 52 49 56 41 54 45    SOLVABLE_PRIVATE
    0x8801490:   5f 41 44 44 52 45 53 53 5f 4f 4e 4c 59 20 66 6f    _ADDRESS_ONLY fo
    0x88014a0:   75 6e 64 00 21 21 21 49 6e 76 61 6c 69 64 20 44    und.!!!Invalid D
    0x88014b0:   69 73 63 6f 76 65 72 79 20 52 65 73 75 6c 74 20    iscovery Result 
    0x88014c0:   54 79 70 65 21 00 00 00 21 2a 2a 67 61 70 5f 63    Type!...!**gap_c
    0x88014d0:   6c 69 65 6e 74 5f 72 65 61 64 5f 72 65 73 75 6c    lient_read_resul
    0x88014e0:   74 5f 63 62 3a 20 68 61 6e 64 6c 65 20 30 78 25    t_cb: handle 0x%
    0x88014f0:   78 2c 20 63 61 75 73 65 20 30 78 25 78 00 00 00    x, cause 0x%x...
    0x8801500:   21 21 21 67 61 70 73 5f 63 6c 69 65 6e 74 5f 72    !!!gaps_client_r
    0x8801510:   65 61 64 5f 72 65 73 75 6c 74 5f 63 62 3a 20 69    ead_result_cb: i
    0x8801520:   6e 76 61 6c 69 64 20 63 63 63 64 20 6c 65 6e 20    nvalid cccd len 
    0x8801530:   25 64 00 00 21 2a 2a 67 61 70 5f 63 6c 69 65 6e    %d..!**gap_clien
    0x8801540:   74 5f 64 69 73 63 5f 63 62 2e 00 00 21 21 21 67    t_disc_cb...!!!g
    0x8801550:   61 70 73 5f 63 6c 69 65 6e 74 5f 64 69 73 63 5f    aps_client_disc_
    0x8801560:   63 62 3a 20 66 61 69 6c 65 64 20 69 6e 76 61 6c    cb: failed inval
    0x8801570:   69 64 20 63 6f 6e 6e 5f 69 64 20 25 64 00 00 00    id conn_id %d...
    0x8801580:   21 21 21 67 61 70 73 5f 61 64 64 5f 63 6c 69 65    !!!gaps_add_clie
    0x8801590:   6e 74 3a 20 69 6e 76 61 6c 69 64 20 6c 69 6e 6b    nt: invalid link
    0x88015a0:   5f 6e 75 6d 20 25 64 00 21 21 21 67 61 70 73 5f    _num %d.!!!gaps_
    0x88015b0:   61 64 64 5f 63 6c 69 65 6e 74 20 46 61 69 6c 20    add_client Fail 
    0x88015c0:   21 21 21 00 21 2a 2a 67 61 70 73 5f 61 64 64 5f    !!!.!**gaps_add_
    0x88015d0:   63 6c 69 65 6e 74 3a 20 63 6c 69 65 6e 74 20 49    client: client I
    0x88015e0:   44 20 3d 20 25 64 00 00 21 2a 2a 61 70 70 5f 6d    D = %d..!**app_m
    0x88015f0:   61 69 6e 5f 74 61 73 6b 20 62 79 20 76 73 6f 70    ain_task by vsop
    0x8801600:   20 65 6e 74 65 72 00 00 21 2a 2a 61 70 70 5f 68     enter..!**app_h
    0x8801610:   61 6e 64 6c 65 5f 64 65 76 5f 73 74 61 74 65 5f    andle_dev_state_
    0x8801620:   65 76 74 3a 20 69 6e 69 74 20 73 74 61 74 65 20    evt: init state 
    0x8801630:   20 25 64 2c 20 73 63 61 6e 20 73 74 61 74 65 20     %d, scan state 
    0x8801640:   25 64 2c 20 63 61 75 73 65 20 30 78 25 78 00 00    %d, cause 0x%x..
    0x8801650:   21 2a 2a 47 41 50 20 73 74 61 63 6b 20 72 65 61    !**GAP stack rea
    0x8801660:   64 79 00 00 21 2a 2a 47 41 50 20 73 63 61 6e 20    dy..!**GAP scan 
    0x8801670:   73 74 6f 70 00 00 00 00 21 2a 2a 47 41 50 20 73    stop....!**GAP s
    0x8801680:   63 61 6e 20 73 74 61 72 74 00 00 00 21 2a 2a 61    can start...!**a
    0x8801690:   70 70 5f 68 61 6e 64 6c 65 5f 63 6f 6e 6e 5f 73    pp_handle_conn_s
    0x88016a0:   74 61 74 65 5f 65 76 74 3a 20 63 6f 6e 6e 5f 69    tate_evt: conn_i
    0x88016b0:   64 20 25 64 2c 20 63 6f 6e 6e 5f 73 74 61 74 65    d %d, conn_state
    0x88016c0:   28 25 64 20 2d 3e 20 25 64 29 2c 20 64 69 73 63    (%d -> %d), disc
    0x88016d0:   5f 63 61 75 73 65 20 30 78 25 78 00 21 21 21 61    _cause 0x%x.!!!a
    0x88016e0:   70 70 5f 68 61 6e 64 6c 65 5f 63 6f 6e 6e 5f 73    pp_handle_conn_s
    0x88016f0:   74 61 74 65 5f 65 76 74 3a 20 63 6f 6e 6e 65 63    tate_evt: connec
    0x8801700:   74 69 6f 6e 20 6c 6f 73 74 2c 20 63 6f 6e 6e 5f    tion lost, conn_
    0x8801710:   69 64 20 25 64 2c 20 63 61 75 73 65 20 30 78 25    id %d, cause 0x%
    0x8801720:   78 00 00 00 21 2a 2a 61 70 70 5f 68 61 6e 64 6c    x...!**app_handl
    0x8801730:   65 5f 61 75 74 68 65 6e 5f 73 74 61 74 65 5f 65    e_authen_state_e
    0x8801740:   76 74 3a 63 6f 6e 6e 5f 69 64 20 25 64 2c 20 63    vt:conn_id %d, c
    0x8801750:   61 75 73 65 20 30 78 25 78 00 00 00 21 2a 2a 61    ause 0x%x...!**a
    0x8801760:   70 70 5f 68 61 6e 64 6c 65 5f 61 75 74 68 65 6e    pp_handle_authen
    0x8801770:   5f 73 74 61 74 65 5f 65 76 74 3a 20 47 41 50 5f    _state_evt: GAP_
    0x8801780:   41 55 54 48 45 4e 5f 53 54 41 54 45 5f 53 54 41    AUTHEN_STATE_STA
    0x8801790:   52 54 45 44 00 00 00 00 21 2a 2a 61 70 70 5f 68    RTED....!**app_h
    0x88017a0:   61 6e 64 6c 65 5f 61 75 74 68 65 6e 5f 73 74 61    andle_authen_sta
    0x88017b0:   74 65 5f 65 76 74 3a 20 47 41 50 5f 41 55 54 48    te_evt: GAP_AUTH
    0x88017c0:   45 4e 5f 53 54 41 54 45 5f 43 4f 4d 50 4c 45 54    EN_STATE_COMPLET
    0x88017d0:   45 20 70 61 69 72 20 73 75 63 63 65 73 73 00 00    E pair success..
    0x88017e0:   21 2a 2a 61 70 70 5f 68 61 6e 64 6c 65 5f 61 75    !**app_handle_au
    0x88017f0:   74 68 65 6e 5f 73 74 61 74 65 5f 65 76 74 3a 20    then_state_evt: 
    0x8801800:   47 41 50 5f 41 55 54 48 45 4e 5f 53 54 41 54 45    GAP_AUTHEN_STATE
    0x8801810:   5f 43 4f 4d 50 4c 45 54 45 20 70 61 69 72 20 66    _COMPLETE pair f
    0x8801820:   61 69 6c 65 64 00 00 00 21 21 21 61 70 70 5f 68    ailed...!!!app_h
    0x8801830:   61 6e 64 6c 65 5f 61 75 74 68 65 6e 5f 73 74 61    andle_authen_sta
    0x8801840:   74 65 5f 65 76 74 3a 20 75 6e 6b 6e 6f 77 6e 20    te_evt: unknown 
    0x8801850:   6e 65 77 73 74 61 74 65 20 25 64 00 21 2a 2a 61    newstate %d.!**a
    0x8801860:   70 70 5f 68 61 6e 64 6c 65 5f 63 6f 6e 6e 5f 6d    pp_handle_conn_m
    0x8801870:   74 75 5f 69 6e 66 6f 5f 65 76 74 3a 20 63 6f 6e    tu_info_evt: con
    0x8801880:   6e 5f 69 64 20 25 64 2c 20 6d 74 75 5f 73 69 7a    n_id %d, mtu_siz
    0x8801890:   65 20 25 64 00 00 00 00 21 2a 2a 61 70 70 5f 68    e %d....!**app_h
    0x88018a0:   61 6e 64 6c 65 5f 63 6f 6e 6e 5f 70 61 72 61 6d    andle_conn_param
    0x88018b0:   5f 75 70 64 61 74 65 5f 65 76 74 20 75 70 64 61    _update_evt upda
    0x88018c0:   74 65 20 73 75 63 63 65 73 73 3a 63 6f 6e 6e 5f    te success:conn_
    0x88018d0:   69 64 20 25 64 2c 20 63 6f 6e 6e 5f 69 6e 74 65    id %d, conn_inte
    0x88018e0:   72 76 61 6c 20 30 78 25 78 2c 20 63 6f 6e 6e 5f    rval 0x%x, conn_
    0x88018f0:   73 6c 61 76 65 5f 6c 61 74 65 6e 63 79 20 30 78    slave_latency 0x
    0x8801900:   25 78 2c 20 63 6f 6e 6e 5f 73 75 70 65 72 76 69    %x, conn_supervi
    0x8801910:   73 69 6f 6e 5f 74 69 6d 65 6f 75 74 20 30 78 25    sion_timeout 0x%
    0x8801920:   78 00 00 00 21 21 21 61 70 70 5f 68 61 6e 64 6c    x...!!!app_handl
    0x8801930:   65 5f 63 6f 6e 6e 5f 70 61 72 61 6d 5f 75 70 64    e_conn_param_upd
    0x8801940:   61 74 65 5f 65 76 74 20 75 70 64 61 74 65 20 66    ate_evt update f
    0x8801950:   61 69 6c 65 64 3a 20 63 6f 6e 6e 5f 69 64 20 25    ailed: conn_id %
    0x8801960:   64 2c 20 63 61 75 73 65 20 30 78 25 78 00 00 00    d, cause 0x%x...
    0x8801970:   21 2a 2a 61 70 70 5f 68 61 6e 64 6c 65 5f 63 6f    !**app_handle_co
    0x8801980:   6e 6e 5f 70 61 72 61 6d 5f 75 70 64 61 74 65 5f    nn_param_update_
    0x8801990:   65 76 74 20 75 70 64 61 74 65 20 70 65 6e 64 69    evt update pendi
    0x88019a0:   6e 67 3a 20 63 6f 6e 6e 5f 69 64 20 25 64 00 00    ng: conn_id %d..
    0x88019b0:   61 70 70 5f 68 61 6e 64 6c 65 5f 67 61 70 5f 6d    app_handle_gap_m
    0x88019c0:   73 67 3a 20 73 75 62 74 79 70 65 20 25 64 00 00    sg: subtype %d..
    0x88019d0:   21 2a 2a 47 41 50 5f 4d 53 47 5f 4c 45 5f 42 4f    !**GAP_MSG_LE_BO
    0x88019e0:   4e 44 5f 4a 55 53 54 5f 57 4f 52 4b 00 00 00 00    ND_JUST_WORK....
    0x88019f0:   21 2a 2a 47 41 50 5f 4d 53 47 5f 4c 45 5f 42 4f    !**GAP_MSG_LE_BO
    0x8801a00:   4e 44 5f 50 41 53 53 4b 45 59 5f 44 49 53 50 4c    ND_PASSKEY_DISPL
    0x8801a10:   41 59 3a 20 63 6f 6e 6e 5f 69 64 20 25 64 2c 20    AY: conn_id %d, 
    0x8801a20:   70 61 73 73 6b 65 79 20 25 64 00 00 21 2a 2a 47    passkey %d..!**G
    0x8801a30:   41 50 5f 4d 53 47 5f 4c 45 5f 42 4f 4e 44 5f 55    AP_MSG_LE_BOND_U
    0x8801a40:   53 45 52 5f 43 4f 4e 46 49 52 4d 41 54 49 4f 4e    SER_CONFIRMATION
    0x8801a50:   3a 20 63 6f 6e 6e 5f 69 64 20 25 64 2c 20 70 61    : conn_id %d, pa
    0x8801a60:   73 73 6b 65 79 20 25 64 00 00 00 00 21 2a 2a 47    sskey %d....!**G
    0x8801a70:   41 50 5f 4d 53 47 5f 4c 45 5f 42 4f 4e 44 5f 50    AP_MSG_LE_BOND_P
    0x8801a80:   41 53 53 4b 45 59 5f 49 4e 50 55 54 3a 20 63 6f    ASSKEY_INPUT: co
    0x8801a90:   6e 6e 5f 69 64 20 25 64 00 00 00 00 21 2a 2a 47    nn_id %d....!**G
    0x8801aa0:   41 50 5f 4d 53 47 5f 4c 45 5f 42 4f 4e 44 5f 4f    AP_MSG_LE_BOND_O
    0x8801ab0:   4f 42 5f 49 4e 50 55 54 3a 20 63 6f 6e 6e 5f 69    OB_INPUT: conn_i
    0x8801ac0:   64 20 25 64 00 00 00 00 21 21 21 61 70 70 5f 68    d %d....!!!app_h
    0x8801ad0:   61 6e 64 6c 65 5f 67 61 70 5f 6d 73 67 3a 20 75    andle_gap_msg: u
    0x8801ae0:   6e 6b 6e 6f 77 6e 20 73 75 62 74 79 70 65 20 25    nknown subtype %
    0x8801af0:   64 00 00 00 21 2a 2a 47 41 50 5f 41 44 54 59 50    d...!**GAP_ADTYP
    0x8801b00:   45 5f 53 4c 41 56 45 5f 43 4f 4e 4e 5f 49 4e 54    E_SLAVE_CONN_INT
    0x8801b10:   45 52 56 41 4c 5f 52 41 4e 47 45 3a 20 30 78 25    ERVAL_RANGE: 0x%
    0x8801b20:   78 20 2d 20 30 78 25 78 00 00 00 00 21 2a 2a 20    x - 0x%x....!** 
    0x8801b30:   20 41 44 20 44 61 74 61 3a 20 55 55 49 44 31 36     AD Data: UUID16
    0x8801b40:   20 4c 69 73 74 20 49 74 65 6d 20 25 64 20 3d 20     List Item %d = 
    0x8801b50:   30 78 25 78 00 00 00 00 21 2a 2a 47 41 50 5f 4d    0x%x....!**GAP_M
    0x8801b60:   53 47 5f 4c 45 5f 53 43 41 4e 5f 49 4e 46 4f 3a    SG_LE_SCAN_INFO:
    0x8801b70:   61 64 76 5f 74 79 70 65 20 30 78 25 78 2c 20 62    adv_type 0x%x, b
    0x8801b80:   64 5f 61 64 64 72 20 25 73 2c 20 72 65 6d 6f 74    d_addr %s, remot
    0x8801b90:   65 5f 61 64 64 72 5f 74 79 70 65 20 25 64 2c 20    e_addr_type %d, 
    0x8801ba0:   72 73 73 69 20 25 64 2c 20 64 61 74 61 5f 6c 65    rssi %d, data_le
    0x8801bb0:   6e 20 25 64 00 00 00 00 21 2a 2a 46 6f 75 6e 64    n %d....!**Found
    0x8801bc0:   20 73 69 6d 70 6c 65 20 62 6c 65 20 73 65 72 76     simple ble serv
    0x8801bd0:   69 63 65 00 21 2a 2a 47 41 50 5f 4d 53 47 5f 4c    ice.!**GAP_MSG_L
    0x8801be0:   45 5f 43 4f 4e 4e 5f 55 50 44 41 54 45 5f 49 4e    E_CONN_UPDATE_IN
    0x8801bf0:   44 3a 20 63 6f 6e 6e 5f 69 64 20 25 64 2c 20 63    D: conn_id %d, c
    0x8801c00:   6f 6e 6e 5f 69 6e 74 65 72 76 61 6c 5f 6d 61 78    onn_interval_max
    0x8801c10:   20 30 78 25 78 2c 20 63 6f 6e 6e 5f 69 6e 74 65     0x%x, conn_inte
    0x8801c20:   72 76 61 6c 5f 6d 69 6e 20 30 78 25 78 2c 20 63    rval_min 0x%x, c
    0x8801c30:   6f 6e 6e 5f 6c 61 74 65 6e 63 79 20 30 78 25 78    onn_latency 0x%x
    0x8801c40:   2c 73 75 70 65 72 76 69 73 69 6f 6e 5f 74 69 6d    ,supervision_tim
    0x8801c50:   65 6f 75 74 20 30 78 25 78 00 00 00 21 21 21 61    eout 0x%x...!!!a
    0x8801c60:   70 70 5f 67 61 70 5f 63 61 6c 6c 62 61 63 6b 3a    pp_gap_callback:
    0x8801c70:   20 75 6e 68 61 6e 64 6c 65 64 20 63 62 5f 74 79     unhandled cb_ty
    0x8801c80:   70 65 20 30 78 25 78 00 21 21 21 61 70 70 5f 64    pe 0x%x.!!!app_d
    0x8801c90:   69 73 63 6f 76 5f 73 65 72 76 69 63 65 73 3a 20    iscov_services: 
    0x8801ca0:   63 6f 6e 6e 5f 69 64 20 25 64 20 6e 6f 74 20 63    conn_id %d not c
    0x8801cb0:   6f 6e 6e 65 63 74 65 64 20 00 00 00 21 21 21 61    onnected ...!!!a
    0x8801cc0:   70 70 5f 64 69 73 63 6f 76 5f 73 65 72 76 69 63    pp_discov_servic
    0x8801cd0:   65 73 3a 20 64 69 73 63 6f 76 65 72 20 67 61 70    es: discover gap
    0x8801ce0:   73 20 66 61 69 6c 65 64 20 63 6f 6e 6e 5f 69 64    s failed conn_id
    0x8801cf0:   20 25 64 00 21 21 21 61 70 70 5f 64 69 73 63 6f     %d.!!!app_disco
    0x8801d00:   76 5f 73 65 72 76 69 63 65 73 3a 20 64 69 73 63    v_services: disc
    0x8801d10:   6f 76 65 72 20 73 69 6d 70 20 66 61 69 6c 65 64    over simp failed
    0x8801d20:   20 63 6f 6e 6e 5f 69 64 20 25 64 00 21 21 21 61     conn_id %d.!!!a
    0x8801d30:   70 70 5f 64 69 73 63 6f 76 5f 73 65 72 76 69 63    pp_discov_servic
    0x8801d40:   65 73 3a 20 64 69 73 63 6f 76 65 72 20 62 61 73    es: discover bas
    0x8801d50:   20 66 61 69 6c 65 64 20 63 6f 6e 6e 5f 69 64 20     failed conn_id 
    0x8801d60:   25 64 00 00 21 2a 2a 61 70 70 5f 64 69 73 63 6f    %d..!**app_disco
    0x8801d70:   76 5f 73 65 72 76 69 63 65 73 3a 20 64 69 73 63    v_services: disc
    0x8801d80:   6f 76 65 72 20 63 6f 6d 70 6c 65 74 65 2c 20 63    over complete, c
    0x8801d90:   6f 6e 6e 5f 69 64 20 25 64 2c 20 73 72 76 5f 66    onn_id %d, srv_f
    0x8801da0:   6f 75 6e 64 5f 66 6c 61 67 73 20 30 78 25 78 00    ound_flags 0x%x.
    0x8801db0:   21 2a 2a 61 70 70 5f 63 6c 69 65 6e 74 5f 63 61    !**app_client_ca
    0x8801dc0:   6c 6c 62 61 63 6b 3a 20 63 6c 69 65 6e 74 5f 69    llback: client_i
    0x8801dd0:   64 20 25 64 2c 20 63 6f 6e 6e 5f 69 64 20 25 64    d %d, conn_id %d
    0x8801de0:   00 00 00 00 21 2a 2a 61 70 70 5f 63 6c 69 65 6e    ....!**app_clien
    0x8801df0:   74 5f 63 61 6c 6c 62 61 63 6b 3a 20 64 69 73 63    t_callback: disc
    0x8801e00:   6f 76 65 72 20 67 61 70 73 20 70 72 6f 63 65 64    over gaps proced
    0x8801e10:   75 72 65 20 64 6f 6e 65 2e 00 00 00 21 2a 2a 61    ure done....!**a
    0x8801e20:   70 70 5f 63 6c 69 65 6e 74 5f 63 61 6c 6c 62 61    pp_client_callba
    0x8801e30:   63 6b 3a 20 64 69 73 63 6f 76 65 72 20 67 61 70    ck: discover gap
    0x8801e40:   73 20 72 65 71 75 65 73 74 20 66 61 69 6c 65 64    s request failed
    0x8801e50:   2e 00 00 00 21 2a 2a 47 41 50 53 5f 52 45 41 44    ....!**GAPS_READ
    0x8801e60:   5f 44 45 56 49 43 45 5f 4e 41 4d 45 3a 20 64 65    _DEVICE_NAME: de
    0x8801e70:   76 69 63 65 20 6e 61 6d 65 20 25 73 2e 00 00 00    vice name %s....
    0x8801e80:   21 2a 2a 47 41 50 53 5f 52 45 41 44 5f 44 45 56    !**GAPS_READ_DEV
    0x8801e90:   49 43 45 5f 4e 41 4d 45 3a 20 66 61 69 6c 64 65    ICE_NAME: failde
    0x8801ea0:   64 20 63 61 75 73 65 20 30 78 25 78 00 00 00 00    d cause 0x%x....
    0x8801eb0:   21 2a 2a 47 41 50 53 5f 52 45 41 44 5f 41 50 50    !**GAPS_READ_APP
    0x8801ec0:   45 41 52 41 4e 43 45 3a 20 61 70 70 65 61 72 61    EARANCE: appeara
    0x8801ed0:   6e 63 65 20 25 64 00 00 21 2a 2a 47 41 50 53 5f    nce %d..!**GAPS_
    0x8801ee0:   52 45 41 44 5f 41 50 50 45 41 52 41 4e 43 45 3a    READ_APPEARANCE:
    0x8801ef0:   20 66 61 69 6c 64 65 64 20 63 61 75 73 65 20 30     failded cause 0
    0x8801f00:   78 25 78 00 21 2a 2a 47 41 50 53 5f 52 45 41 44    x%x.!**GAPS_READ
    0x8801f10:   5f 43 45 4e 54 52 41 4c 5f 41 44 44 52 5f 52 45    _CENTRAL_ADDR_RE
    0x8801f20:   53 4f 4c 55 54 49 4f 4e 3a 20 63 65 6e 74 72 61    SOLUTION: centra
    0x8801f30:   6c 5f 61 64 64 72 5f 72 65 73 20 25 64 00 00 00    l_addr_res %d...
    0x8801f40:   21 2a 2a 47 41 50 53 5f 52 45 41 44 5f 43 45 4e    !**GAPS_READ_CEN
    0x8801f50:   54 52 41 4c 5f 41 44 44 52 5f 52 45 53 4f 4c 55    TRAL_ADDR_RESOLU
    0x8801f60:   54 49 4f 4e 3a 20 66 61 69 6c 64 65 64 20 63 61    TION: failded ca
    0x8801f70:   75 73 65 20 30 78 25 78 00 00 00 00 21 2a 2a 61    use 0x%x....!**a
    0x8801f80:   70 70 5f 63 6c 69 65 6e 74 5f 63 61 6c 6c 62 61    pp_client_callba
    0x8801f90:   63 6b 3a 20 64 69 73 63 6f 76 65 72 20 73 69 6d    ck: discover sim
    0x8801fa0:   70 20 70 72 6f 63 65 64 75 72 65 20 64 6f 6e 65    p procedure done
    0x8801fb0:   2e 00 00 00 21 2a 2a 61 70 70 5f 63 6c 69 65 6e    ....!**app_clien
    0x8801fc0:   74 5f 63 61 6c 6c 62 61 63 6b 3a 20 64 69 73 63    t_callback: disc
    0x8801fd0:   6f 76 65 72 20 73 69 6d 70 20 72 65 71 75 65 73    over simp reques
    0x8801fe0:   74 20 66 61 69 6c 65 64 2e 00 00 00 21 2a 2a 53    t failed....!**S
    0x8801ff0:   49 4d 50 5f 52 45 41 44 5f 56 31 5f 52 45 41 44    IMP_READ_V1_READ
    0x8802000:   3a 20 76 61 6c 75 65 5f 73 69 7a 65 20 25 64 2c    : value_size %d,
    0x8802010:   20 76 61 6c 75 65 20 25 62 00 00 00 21 21 21 53     value %b...!!!S
    0x8802020:   49 4d 50 5f 52 45 41 44 5f 56 31 5f 52 45 41 44    IMP_READ_V1_READ
    0x8802030:   3a 20 66 61 69 6c 65 64 20 63 61 75 73 65 20 30    : failed cause 0
    0x8802040:   78 25 78 00 21 2a 2a 53 49 4d 50 5f 52 45 41 44    x%x.!**SIMP_READ
    0x8802050:   5f 56 33 5f 4e 4f 54 49 46 59 5f 43 43 43 44 3a    _V3_NOTIFY_CCCD:
    0x8802060:   20 6e 6f 74 69 66 79 20 25 64 00 00 21 21 21 53     notify %d..!!!S
    0x8802070:   49 4d 50 5f 52 45 41 44 5f 56 33 5f 4e 4f 54 49    IMP_READ_V3_NOTI
    0x8802080:   46 59 5f 43 43 43 44 3a 20 66 61 69 6c 65 64 20    FY_CCCD: failed 
    0x8802090:   63 61 75 73 65 20 30 78 25 78 00 00 21 2a 2a 53    cause 0x%x..!**S
    0x88020a0:   49 4d 50 5f 52 45 41 44 5f 56 34 5f 49 4e 44 49    IMP_READ_V4_INDI
    0x88020b0:   43 41 54 45 5f 43 43 43 44 3a 20 69 6e 64 69 63    CATE_CCCD: indic
    0x88020c0:   61 74 65 20 25 64 00 00 21 21 21 53 49 4d 50 5f    ate %d..!!!SIMP_
    0x88020d0:   52 45 41 44 5f 56 34 5f 49 4e 44 49 43 41 54 45    READ_V4_INDICATE
    0x88020e0:   5f 43 43 43 44 3a 20 66 61 69 6c 65 64 20 63 61    _CCCD: failed ca
    0x88020f0:   75 73 65 20 30 78 25 78 00 00 00 00 21 2a 2a 53    use 0x%x....!**S
    0x8802100:   49 4d 50 5f 57 52 49 54 45 5f 56 32 5f 57 52 49    IMP_WRITE_V2_WRI
    0x8802110:   54 45 3a 20 77 72 69 74 65 20 72 65 73 75 6c 74    TE: write result
    0x8802120:   20 30 78 25 78 00 00 00 21 2a 2a 53 49 4d 50 5f     0x%x...!**SIMP_
    0x8802130:   57 52 49 54 45 5f 56 33 5f 4e 4f 54 49 46 59 5f    WRITE_V3_NOTIFY_
    0x8802140:   43 43 43 44 3a 20 77 72 69 74 65 20 72 65 73 75    CCCD: write resu
    0x8802150:   6c 74 20 30 78 25 78 00 21 2a 2a 53 49 4d 50 5f    lt 0x%x.!**SIMP_
    0x8802160:   57 52 49 54 45 5f 56 34 5f 49 4e 44 49 43 41 54    WRITE_V4_INDICAT
    0x8802170:   45 5f 43 43 43 44 3a 20 77 72 69 74 65 20 72 65    E_CCCD: write re
    0x8802180:   73 75 6c 74 20 30 78 25 78 00 00 00 21 2a 2a 53    sult 0x%x...!**S
    0x8802190:   49 4d 50 5f 56 33 5f 4e 4f 54 49 46 59 3a 20 76    IMP_V3_NOTIFY: v
    0x88021a0:   61 6c 75 65 5f 73 69 7a 65 20 25 64 2c 20 76 61    alue_size %d, va
    0x88021b0:   6c 75 65 20 25 62 00 00 21 2a 2a 53 49 4d 50 5f    lue %b..!**SIMP_
    0x88021c0:   56 34 5f 49 4e 44 49 43 41 54 45 3a 20 76 61 6c    V4_INDICATE: val
    0x88021d0:   75 65 5f 73 69 7a 65 20 25 64 2c 20 76 61 6c 75    ue_size %d, valu
    0x88021e0:   65 20 25 62 00 00 00 00 21 2a 2a 61 70 70 5f 63    e %b....!**app_c
    0x88021f0:   6c 69 65 6e 74 5f 63 61 6c 6c 62 61 63 6b 3a 20    lient_callback: 
    0x8802200:   64 69 73 63 6f 76 65 72 20 62 61 73 20 70 72 6f    discover bas pro
    0x8802210:   63 65 64 75 72 65 20 64 6f 6e 65 00 21 2a 2a 61    cedure done.!**a
    0x8802220:   70 70 5f 63 6c 69 65 6e 74 5f 63 61 6c 6c 62 61    pp_client_callba
    0x8802230:   63 6b 3a 20 64 69 73 63 6f 76 65 72 20 62 61 73    ck: discover bas
    0x8802240:   20 70 72 6f 63 65 64 75 72 65 20 66 61 69 6c 65     procedure faile
    0x8802250:   64 00 00 00 21 2a 2a 42 41 53 5f 52 45 41 44 5f    d...!**BAS_READ_
    0x8802260:   42 41 54 54 45 52 59 5f 4c 45 56 45 4c 3a 20 62    BATTERY_LEVEL: b
    0x8802270:   61 74 74 65 72 79 20 6c 65 76 65 6c 20 25 64 00    attery level %d.
    0x8802280:   21 21 21 42 41 53 5f 52 45 41 44 5f 42 41 54 54    !!!BAS_READ_BATT
    0x8802290:   45 52 59 5f 4c 45 56 45 4c 3a 20 66 61 69 6c 65    ERY_LEVEL: faile
    0x88022a0:   64 20 63 61 75 73 65 20 30 78 25 78 00 00 00 00    d cause 0x%x....
    0x88022b0:   21 2a 2a 42 41 53 5f 52 45 41 44 5f 4e 4f 54 49    !**BAS_READ_NOTI
    0x88022c0:   46 59 3a 20 6e 6f 74 69 66 79 20 25 64 00 00 00    FY: notify %d...
    0x88022d0:   21 21 21 42 41 53 5f 52 45 41 44 5f 4e 4f 54 49    !!!BAS_READ_NOTI
    0x88022e0:   46 59 3a 20 66 61 69 6c 65 64 20 63 61 75 73 65    FY: failed cause
    0x88022f0:   20 30 78 25 78 00 00 00 21 2a 2a 42 41 53 5f 57     0x%x...!**BAS_W
    0x8802300:   52 49 54 45 5f 4e 4f 54 49 46 59 5f 45 4e 41 42    RITE_NOTIFY_ENAB
    0x8802310:   4c 45 3a 20 77 72 69 74 65 20 72 65 73 75 6c 74    LE: write result
    0x8802320:   20 30 78 25 78 00 00 00 21 2a 2a 42 41 53 5f 57     0x%x...!**BAS_W
    0x8802330:   52 49 54 45 5f 4e 4f 54 49 46 59 5f 44 49 53 41    RITE_NOTIFY_DISA
    0x8802340:   42 4c 45 3a 20 77 72 69 74 65 20 72 65 73 75 6c    BLE: write resul
    0x8802350:   74 20 30 78 25 78 00 00 21 2a 2a 42 41 53 5f 43    t 0x%x..!**BAS_C
    0x8802360:   4c 49 45 4e 54 5f 43 42 5f 54 59 50 45 5f 4e 4f    LIENT_CB_TYPE_NO
    0x8802370:   54 49 46 5f 49 4e 44 5f 52 45 53 55 4c 54 3a 20    TIF_IND_RESULT: 
    0x8802380:   62 61 74 74 65 72 79 20 6c 65 76 65 6c 20 25 64    battery level %d
    0x8802390:   00 00 00 00 21 21 21 67 61 70 5f 63 6f 6e 66 69    ....!!!gap_confi
    0x88023a0:   67 5f 70 72 69 6e 74 5f 63 6f 6e 66 69 67 5f 70    g_print_config_p
    0x88023b0:   61 72 61 6d 3a 20 67 61 74 74 5f 63 63 63 64 5f    aram: gatt_cccd_
    0x88023c0:   6e 6f 74 5f 63 68 65 63 6b 20 25 64 2c 20 6c 65    not_check %d, le
    0x88023d0:   5f 6d 69 6e 5f 72 65 6d 5f 73 63 61 5f 66 6c 61    _min_rem_sca_fla
    0x88023e0:   67 20 25 64 2c 20 6c 65 5f 6d 69 6e 5f 72 65 6d    g %d, le_min_rem
    0x88023f0:   5f 73 63 61 5f 65 6e 63 6f 64 69 6e 67 20 25 64    _sca_encoding %d
    0x8802400:   2c 20 62 74 5f 72 65 70 6f 72 74 5f 62 75 66 5f    , bt_report_buf_
    0x8802410:   6e 75 6d 20 25 64 2c 20 67 61 74 74 5f 73 65 72    num %d, gatt_ser
    0x8802420:   76 65 72 5f 63 63 63 5f 62 69 74 73 5f 63 6f 75    ver_ccc_bits_cou
    0x8802430:   6e 74 20 25 64 2c 20 67 61 74 74 5f 73 74 6f 72    nt %d, gatt_stor
    0x8802440:   61 67 65 5f 63 63 63 5f 62 69 74 73 5f 63 6f 75    age_ccc_bits_cou
    0x8802450:   6e 74 20 25 64 2c 20 67 61 74 74 5f 6d 61 78 5f    nt %d, gatt_max_
    0x8802460:   61 74 74 72 69 62 75 74 65 5f 74 61 62 6c 65 5f    attribute_table_
    0x8802470:   63 6f 75 6e 74 20 25 64 2c 20 61 74 74 5f 6d 61    count %d, att_ma
    0x8802480:   78 5f 6d 74 75 5f 73 69 7a 65 20 25 64 00 00 00    x_mtu_size %d...
    0x8802490:   21 21 21 67 61 70 5f 63 6f 6e 66 69 67 5f 70 72    !!!gap_config_pr
    0x88024a0:   69 6e 74 5f 63 6f 6e 66 69 67 5f 70 61 72 61 6d    int_config_param
    0x88024b0:   3a 20 6c 65 5f 6b 65 79 5f 73 74 6f 72 61 67 65    : le_key_storage
    0x88024c0:   5f 66 6c 61 67 20 30 78 25 78 2c 20 6d 61 78 5f    _flag 0x%x, max_
    0x88024d0:   6c 65 5f 70 61 69 72 65 64 5f 64 65 76 69 63 65    le_paired_device
    0x88024e0:   20 25 64 2c 20 62 74 65 5f 70 6f 6f 6c 5f 73 69     %d, bte_pool_si
    0x88024f0:   7a 65 20 25 64 00 00 00 21 21 21 67 61 70 5f 63    ze %d...!!!gap_c
    0x8802500:   6f 6e 66 69 67 5f 70 72 69 6e 74 5f 63 6f 6e 66    onfig_print_conf
    0x8802510:   69 67 5f 70 61 72 61 6d 3a 62 74 5f 62 64 5f 61    ig_param:bt_bd_a
    0x8802520:   64 64 72 20 25 73 00 00 21 21 21 67 61 70 5f 6c    ddr %s..!!!gap_l
    0x8802530:   69 62 5f 69 6e 69 74 3a 20 76 65 72 20 25 64 2c    ib_init: ver %d,
    0x8802540:   20 46 5f 42 54 5f 4c 45 5f 35 5f 30 5f 53 55 50     F_BT_LE_5_0_SUP
    0x8802550:   50 4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 4c 45    PORT %d, F_BT_LE
    0x8802560:   5f 35 5f 30 5f 41 45 5f 41 44 56 5f 53 55 50 50    _5_0_AE_ADV_SUPP
    0x8802570:   4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 4c 45 5f    ORT %d, F_BT_LE_
    0x8802580:   35 5f 30 5f 41 45 5f 53 43 41 4e 5f 53 55 50 50    5_0_AE_SCAN_SUPP
    0x8802590:   4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 4c 45 5f    ORT %d, F_BT_LE_
    0x88025a0:   34 5f 31 5f 43 42 43 5f 53 55 50 50 4f 52 54 20    4_1_CBC_SUPPORT 
    0x88025b0:   25 64 2c 20 46 5f 42 54 5f 56 45 4e 44 4f 52 5f    %d, F_BT_VENDOR_
    0x88025c0:   46 45 41 54 55 52 45 5f 53 55 50 50 4f 52 54 20    FEATURE_SUPPORT 
    0x88025d0:   25 64 2c 20 46 5f 42 54 5f 4c 45 5f 36 5f 30 5f    %d, F_BT_LE_6_0_
    0x88025e0:   41 4f 41 5f 41 4f 44 5f 53 55 50 50 4f 52 54 20    AOA_AOD_SUPPORT 
    0x88025f0:   25 64 2c 20 46 5f 42 54 5f 4c 45 5f 36 5f 30 5f    %d, F_BT_LE_6_0_
    0x8802600:   41 4f 58 5f 43 4f 4e 4e 4c 45 53 53 5f 53 55 50    AOX_CONNLESS_SUP
    0x8802610:   50 4f 52 54 20 25 64 00 21 21 21 67 61 70 5f 6c    PORT %d.!!!gap_l
    0x8802620:   69 62 5f 69 6e 69 74 3a 20 46 5f 42 54 5f 4c 45    ib_init: F_BT_LE
    0x8802630:   5f 53 4d 50 5f 53 43 5f 4f 4f 42 5f 53 55 50 50    _SMP_SC_OOB_SUPP
    0x8802640:   4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 53 57 5f    ORT %d, F_BT_SW_
    0x8802650:   52 45 53 45 54 5f 53 55 50 50 4f 52 54 20 25 64    RESET_SUPPORT %d
    0x8802660:   2c 20 46 5f 42 54 5f 50 41 54 43 48 5f 46 4f 52    , F_BT_PATCH_FOR
    0x8802670:   5f 43 48 41 4e 47 45 5f 41 50 49 20 25 64 2c 20    _CHANGE_API %d, 
    0x8802680:   46 5f 42 54 5f 44 4c 50 53 5f 41 50 49 20 25 64    F_BT_DLPS_API %d
    0x8802690:   2c 20 46 5f 42 54 5f 43 4f 4e 46 49 47 5f 41 50    , F_BT_CONFIG_AP
    0x88026a0:   49 20 25 64 2c 20 46 5f 42 54 5f 56 45 4e 44 4f    I %d, F_BT_VENDO
    0x88026b0:   52 5f 41 50 49 20 25 64 00 00 00 00 21 2a 2a 6c    R_API %d....!**l
    0x88026c0:   65 5f 63 68 65 63 6b 5f 70 72 69 76 61 63 79 5f    e_check_privacy_
    0x88026d0:   62 6f 6e 64 3a 20 69 64 78 20 25 64 20 70 72 69    bond: idx %d pri
    0x88026e0:   76 61 63 79 20 64 65 76 69 63 65 00 21 2a 2a 6c    vacy device.!**l
    0x88026f0:   65 5f 63 68 65 63 6b 5f 70 72 69 76 61 63 79 5f    e_check_privacy_
    0x8802700:   62 6f 6e 64 3a 20 6e 6f 74 20 70 72 69 76 61 63    bond: not privac
    0x8802710:   79 20 64 65 76 69 63 65 2c 20 63 61 75 73 65 20    y device, cause 
    0x8802720:   25 64 00 00 21 2a 2a 6c 65 5f 67 65 6e 5f 72 61    %d..!**le_gen_ra
    0x8802730:   6e 64 5f 61 64 64 72 3a 20 67 61 70 5f 6c 69 62    nd_addr: gap_lib
    0x8802740:   2c 20 72 61 6e 64 6f 6d 20 61 64 64 72 20 25 73    , random addr %s
    0x8802750:   2c 20 61 64 64 72 20 74 79 70 65 20 25 64 00 00    , addr type %d..
    0x8802760:   21 2a 2a 6c 65 5f 62 6f 6e 64 5f 67 65 74 5f 73    !**le_bond_get_s
    0x8802770:   65 63 5f 6c 65 76 65 6c 3a 20 25 64 00 00 00 00    ec_level: %d....


** Section #11 '.debug_abbrev' (SHT_PROGBITS)
    Size   : 1476 bytes


** Section #12 '.debug_frame' (SHT_PROGBITS)
    Size   : 6576 bytes


** Section #13 '.debug_info' (SHT_PROGBITS)
    Size   : 170632 bytes


** Section #14 '.debug_line' (SHT_PROGBITS)
    Size   : 30940 bytes


** Section #15 '.debug_loc' (SHT_PROGBITS)
    Size   : 20056 bytes


** Section #16 '.debug_macinfo' (SHT_PROGBITS)
    Size   : 78536 bytes


** Section #17 '.debug_pubnames' (SHT_PROGBITS)
    Size   : 6238 bytes


** Section #18 '.symtab' (SHT_SYMTAB)
    Size   : 26096 bytes (alignment 4)
    String table #19 '.strtab'
    Last local symbol no. 787


** Section #19 '.strtab' (SHT_STRTAB)
    Size   : 20868 bytes


** Section #20 '.note' (SHT_NOTE)
    Size   : 56 bytes (alignment 4)


** Section #21 '.comment' (SHT_PROGBITS)
    Size   : 23464 bytes


** Section #22 '.shstrtab' (SHT_STRTAB)
    Size   : 276 bytes


address     size       variable name                            type
0x0020d3e0  0x4        mxchp_qc_task                            pointer to unknown Type 

address     size       variable name                            type
0x0020d3dc  0x4        qc_app_task_handle                       pointer to unknown Type 

address     size       variable name                            type
0x0020d3e4  0x4        qc_evt_queue_handle                      pointer to unknown Type 

address     size       variable name                            type
0x0020d3e8  0x4        qc_io_queue_handle                       pointer to unknown Type 

address     size       variable name                            type
0x0020cf2c  0x6c       overlay_sections                         array[3] of T_OVERLAY_SECTION

address     size       variable name                            type
0x0020d3d4  0x8        scenario_name                            array[8] of char

address     size       variable name                            type
0x0020d3cc  0x4        h_event_q                                pointer to unknown Type 

address     size       variable name                            type
0x0020d3d0  0x4        h_io_q                                   pointer to unknown Type 

address     size       variable name                            type
0x0020d3a3  0x28       app_link_table                           array[4] of T_APP_LINK

address     size       variable name                            type
0x0020d379  0x2a       dev_list                                 array[6] of T_DEV_INFO

address     size       variable name                            type
0x0020d378  0x1        dev_list_count                           uint8_t

address     size       variable name                            type
0x0020d377  0x1        bas_client_id                            T_CLIENT_ID

address     size       variable name                            type
0x0020d374  0x1        gap_dev_state                            T_GAP_DEV_STATE
0x0020d374  0x1(7:1)   gap_dev_state.gap_init_state             uint8_t
0x0020d374  0x1(6:1)   gap_dev_state.gap_adv_sub_state          uint8_t
0x0020d374  0x1(4:2)   gap_dev_state.gap_adv_state              uint8_t
0x0020d374  0x1(2:2)   gap_dev_state.gap_scan_state             uint8_t
0x0020d374  0x1(0:2)   gap_dev_state.gap_conn_state             uint8_t

address     size       variable name                            type
0x0020d376  0x1        gaps_client_id                           T_CLIENT_ID

address     size       variable name                            type
0x0020d375  0x1        simple_ble_client_id                     T_CLIENT_ID

address     size       variable name                            type
0x0020d368  0x4        app_task_handle                          pointer to unknown Type 

address     size       variable name                            type
0x0020d36c  0x4        evt_queue_handle                         pointer to unknown Type 

address     size       variable name                            type
0x0020d370  0x4        io_queue_handle                          pointer to unknown Type 

address     size       variable name                            type
0x0020d170  0x1f6      cmd_buffer                               array[502] of char

address     size       variable name                            type
0x0020cfcc  0x1a4      user_cmd_if                              T_USER_CMD_IF
0x0020cfcc  0x66       user_cmd_if.cmdline_buf                  array[102] of char
0x0020d032  0x1        user_cmd_if.cmd_cur                      uint8_t
0x0020d033  0x132      user_cmd_if.cmd_history                  array[3] of array[102] of uint8_t
0x0020d165  0x3        user_cmd_if.cmd_history_len              array[3] of uint8_t
0x0020d168  0x1        user_cmd_if.history_head                 uint8_t
0x0020d169  0x1        user_cmd_if.history_tail                 uint8_t
0x0020d16a  0x1      * user_cmd_if.history_cur                  uint8_t
0x0020d16c  0x4        user_cmd_if.accum_cmd_len                int32_t

address     size       variable name                            type
0x0021c8a0  0x1a0      user_cmd_table                           array[26] of const T_USER_CMD_TABLE_ENTRY

address     size       variable name                            type
0x0020cf2a  0x1        gaps_client                              T_CLIENT_ID

address     size       variable name                            type
0x0020cfc4  0x4        gaps_client_cb                           P_FUN_GENERAL_APP_CB

address     size       variable name                            type
0x0020bfc8  0x18       gaps_client_cbs                          const T_FUN_CLIENT_CBS
0x0020bfc8  0x4        gaps_client_cbs.discover_state_cb        P_FUN_DISCOVER_STATE_CB
0x0020bfcc  0x4        gaps_client_cbs.discover_result_cb       P_FUN_DISCOVER_RESULT_CB
0x0020bfd0  0x4        gaps_client_cbs.read_result_cb           P_FUN_READ_RESULT_CB
0x0020bfd4  0x4        gaps_client_cbs.write_result_cb          P_FUN_WRITE_RESULT_CB
0x0020bfd8  0x4        gaps_client_cbs.notify_ind_result_cb     P_FUN_NOTIFY_IND_RESULT_CB
0x0020bfdc  0x4        gaps_client_cbs.disconnect_cb            P_FUN_DISCONNECT_CB

address     size       variable name                            type
0x0020cfc0  0x1        gaps_link_num                            uint8_t

address     size       variable name                            type
0x0020cfc8  0x4        gaps_table                               P_GAPS_LINK

address     size       variable name                            type
0x0020cf29  0x1        bas_client                               T_CLIENT_ID

address     size       variable name                            type
0x0020cfb8  0x4        bas_client_cb                            P_FUN_GENERAL_APP_CB

address     size       variable name                            type
0x0020bfa0  0x18       bas_client_cbs                           const T_FUN_CLIENT_CBS
0x0020bfa0  0x4        bas_client_cbs.discover_state_cb         P_FUN_DISCOVER_STATE_CB
0x0020bfa4  0x4        bas_client_cbs.discover_result_cb        P_FUN_DISCOVER_RESULT_CB
0x0020bfa8  0x4        bas_client_cbs.read_result_cb            P_FUN_READ_RESULT_CB
0x0020bfac  0x4        bas_client_cbs.write_result_cb           P_FUN_WRITE_RESULT_CB
0x0020bfb0  0x4        bas_client_cbs.notify_ind_result_cb      P_FUN_NOTIFY_IND_RESULT_CB
0x0020bfb4  0x4        bas_client_cbs.disconnect_cb             P_FUN_DISCONNECT_CB

address     size       variable name                            type
0x0020cfb4  0x1        bas_link_num                             uint8_t

address     size       variable name                            type
0x0020cfbc  0x4        bas_table                                P_BAS_LINK

address     size       variable name                            type
0x0021c874  0x18       simp_ble_client_cbs                      const T_FUN_CLIENT_CBS
0x0021c874  0x4        simp_ble_client_cbs.discover_state_cb    P_FUN_DISCOVER_STATE_CB
0x0021c878  0x4        simp_ble_client_cbs.discover_result_cb   P_FUN_DISCOVER_RESULT_CB
0x0021c87c  0x4        simp_ble_client_cbs.read_result_cb       P_FUN_READ_RESULT_CB
0x0021c880  0x4        simp_ble_client_cbs.write_result_cb      P_FUN_WRITE_RESULT_CB
0x0021c884  0x4        simp_ble_client_cbs.notify_ind_result_cb P_FUN_NOTIFY_IND_RESULT_CB
0x0021c888  0x4        simp_ble_client_cbs.disconnect_cb        P_FUN_DISCONNECT_CB

address     size       variable name                            type
0x0020cf28  0x1        simp_client                              T_CLIENT_ID

address     size       variable name                            type
0x0020cfac  0x4        simp_client_cb                           P_FUN_GENERAL_APP_CB

address     size       variable name                            type
0x0020cfa8  0x1        simp_link_num                            uint8_t

address     size       variable name                            type
0x0020cfb0  0x4        simp_table                               P_SIMP_LINK

address     size       variable name                            type
0x0020bf80  0x20       app_cb_table                             const T_APP_CB_TABLE
0x0020bf80  0x4        app_cb_table.app_cb_signature            uint32_t
0x0020bf84  0x4        app_cb_table.app_cb_numbers              uint32_t
0x0020bf88  0x18       app_cb_table.app_cb_addr                 array[6] of uint32_t

address     size       variable name                            type
0x0020cfa0  0x4        app_pre_main_cb                          USER_CALL_BACK

address     size       variable name                            type
0x0080e1e0  0x220      auth_header                              const T_AUTH_HEADER_FORMAT
0x0080e1e0  0x100      auth_header.payload_signature            array[256] of uint8_t
0x0080e2e0  0x10       auth_header.payload_mac                  array[16] of uint8_t
0x0080e2f0  0x100      auth_header.header_signature             array[256] of uint8_t
0x0080e3f0  0x10       auth_header.header_mac                   array[16] of uint8_t

address     size       variable name                            type
0x0020cf24  0x4        check_reset_ram                          T_CHECK_RESET_RAM_RECORD
0x0020cf24  0x4(8:24)  check_reset_ram.check_reset_ram_pattern  uint32_t
0x0020cf24  0x4(0:8)   check_reset_ram.check_reset_ram_type     uint32_t

address     size       variable name                            type
0x0080e000  0x1e0      img_header                               const T_IMG_HEADER_FORMAT
0x0080e000  0xc        img_header.ctrl_header                   T_IMG_CTRL_HEADER_FORMAT
0x0080e000  0x1        img_header.ctrl_header.ic_type           uint8_t
0x0080e001  0x1        img_header.ctrl_header.secure_version    uint8_t
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag         anonymous
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag.value   uint16_t
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag.flag_value anonymous
0x0080e002  0x2(15:1)  img_header.ctrl_header.ctrl_flag.flag_value.xip uint16_t
0x0080e002  0x2(14:1)  img_header.ctrl_header.ctrl_flag.flag_value.enc uint16_t
0x0080e002  0x2(13:1)  img_header.ctrl_header.ctrl_flag.flag_value.load_when_boot uint16_t
0x0080e002  0x2(12:1)  img_header.ctrl_header.ctrl_flag.flag_value.enc_load uint16_t
0x0080e002  0x2(9:3)   img_header.ctrl_header.ctrl_flag.flag_value.enc_key_select uint16_t
0x0080e002  0x2(8:1)   img_header.ctrl_header.ctrl_flag.flag_value.not_ready uint16_t
0x0080e002  0x2(7:1)   img_header.ctrl_header.ctrl_flag.flag_value.not_obsolete uint16_t
0x0080e002  0x2(6:1)   img_header.ctrl_header.ctrl_flag.flag_value.integrity_check_en_in_boot uint16_t
0x0080e002  0x2(0:6)   img_header.ctrl_header.ctrl_flag.flag_value.rsvd uint16_t
0x0080e004  0x2        img_header.ctrl_header.image_id          uint16_t
0x0080e006  0x2        img_header.ctrl_header.crc16             uint16_t
0x0080e008  0x4        img_header.ctrl_header.payload_len       uint32_t
0x0080e00c  0x10       img_header.uuid                          array[16] of uint8_t
0x0080e01c  0x4        img_header.exe_base                      uint32_t
0x0080e020  0x4        img_header.load_base                     uint32_t
0x0080e024  0x4        img_header.load_len                      uint32_t
0x0080e028  0x4        img_header.img_base                      uint32_t
0x0080e02c  0x4        img_header.rsvd0                         array[4] of uint8_t
0x0080e030  0x4        img_header.magic_pattern                 uint32_t
0x0080e034  0x10       img_header.dec_key                       array[16] of uint8_t
0x0080e044  0x1c       img_header.rsvd1                         array[28] of uint8_t
0x0080e060  0x10       img_header.git_ver                       T_VERSION_FORMAT
0x0080e060  0x4        img_header.git_ver.ver_info              anonymous
0x0080e060  0x4        img_header.git_ver.ver_info.version      uint32_t
0x0080e060  0x4        img_header.git_ver.ver_info.sub_version  anonymous
0x0080e060  0x4(28:4)  img_header.git_ver.ver_info.sub_version._version_major uint32_t
0x0080e060  0x4(20:8)  img_header.git_ver.ver_info.sub_version._version_minor uint32_t
0x0080e060  0x4(5:15)  img_header.git_ver.ver_info.sub_version._version_revision uint32_t
0x0080e060  0x4(0:5)   img_header.git_ver.ver_info.sub_version._version_reserve uint32_t
0x0080e064  0x4        img_header.git_ver._version_commitid     uint32_t
0x0080e068  0x8        img_header.git_ver._customer_name        array[8] of uint8_t
0x0080e070  0x104      img_header.rsaPubKey                     T_RSA_PUBLIC_KEY
0x0080e070  0x100      img_header.rsaPubKey.N                   array[256] of uint8_t
0x0080e170  0x4        img_header.rsaPubKey.E                   array[4] of uint8_t
0x0080e174  0x20       img_header.sha256                        array[32] of uint8_t
0x0080e194  0x44       img_header.rsvd2                         array[68] of uint8_t
0x0080e1d8  0x4        img_header.app_cb_signature              uint32_t
0x0080e1dc  0x4        img_header.app_cb_table_base_address     uint32_t

address     size       variable name                            type
0x0020cfa4  0x4        random_seed_value                        uint32_t

address     size       variable name                            type
0x0020cf9c  0x4        user_dfu_status_cb                       BOOL_DFU_STATUS_CB

address     size       variable name                            type
0x0020cf98  0x4        user_wdg_cb                              BOOL_WDG_CB


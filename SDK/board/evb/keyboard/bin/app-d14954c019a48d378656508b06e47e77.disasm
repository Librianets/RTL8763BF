
========================================================================

** ELF Header Information

    File Name: F:\zhoulonghui\Project-201902-before\À¶ÑÀMESH\REALTEK\SDK\00011936-BEE2-SDK-v1.0.2\BEE2-SDK-v1.0.2\board\evb\keyboard\Objects\app.axf

    Machine class: ELFCLASS32 (32-bit)
    Data encoding: ELFDATA2LSB (Little endian)
    Header version: EV_CURRENT (Current version)
    Operating System ABI: none
    ABI Version: 0
    File Type: ET_EXEC (Executable) (2)
    Machine: EM_ARM (ARM)

    Image Entry point: 0x0080e409
    Flags: EF_ARM_HASENTRY + EF_ARM_ABI_FLOAT_HARD (0x05000402)

    ARM ELF revision: 5 (ABI version 2)

    Conforms to Hard float procedure-call standard

    Built with
    Component: ARM Compiler 5.06 update 6 (build 750) Tool: armasm [4d35ec]
    Component: ARM Compiler 5.06 update 6 (build 750) Tool: armlink [4d35ed]

    Header size: 52 bytes (0x34)
    Program header entry size: 32 bytes (0x20)
    Section header entry size: 40 bytes (0x28)

    Program header entries: 2
    Section header entries: 22

    Program header offset: 443276 (0x0006c38c)
    Section header offset: 443340 (0x0006c3cc)

    Section header string table index: 21

========================================================================

** Program header #0 (PT_LOAD) [PF_X + PF_W + PF_R + PF_ARM_ENTRY]
    Size : 18672 bytes (18136 bytes in file)
    Virtual address: 0x0080e000 (Alignment 4)


====================================

** Program header #1 (PT_LOAD) [PF_R]
    Size : 6200 bytes
    Virtual address: 0x08800000 (Alignment 4)


========================================================================

** Section #1 'app.bin' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 1024 bytes (alignment 4)
    Address: 0x0080e000

    0x80e000:   05 00 01 01 93 27 00 00 00 01 00 00 6d 67 de f1    .....'......mg..
    0x80e010:   3e 33 e8 11 b1 02 4d 2d f4 0c de 01 00 e4 80 00    >3....M-........
    0x80e020:   00 e4 80 00 00 00 00 00 00 e0 80 00 00 00 00 00    ................
    0x80e030:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e040:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e050:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e060:   01 20 00 00 a8 ac 83 2a 73 64 6b 23 23 23 23 23    . .....*sdk#####
    0x80e070:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e080:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e090:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e100:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e110:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e120:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e130:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e140:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e150:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e160:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e170:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e180:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e190:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1d0:   00 00 00 00 00 00 00 00 01 d1 85 0e d4 ad 20 00    .............. .
    0x80e1e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e200:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e210:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e220:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e230:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e240:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e250:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e260:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e270:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e280:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e290:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2e0:   ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................
    0x80e2f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e300:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e310:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e320:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e330:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e340:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e350:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e360:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e370:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e380:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e390:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3f0:   ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................


** Section #2 'FLASH_START_ADDR' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 8 bytes (alignment 4)
    Address: 0x0080e400

    $t
    RESET
    $v0
    Reset_Handler
;;; ..\\..\\..\\src\\mcu\\rtl876x\\arm\\startup_rtl8762c.s
;;;96                     IMPORT SystemInit
;;;96                     LDR    R0, =SystemInit
        0x0080e400:    4800        .H      LDR      r0,[pc,#0] ; [0x80e404] = 0x80e50b
;;;97                     BX     R0
        0x0080e402:    4700        .G      BX       r0
    $d
        0x0080e404:    0080e50b    ....    DCD    8447243

** Section #3 'FLASH_TEXT' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 584 bytes (alignment 4)
    Address: 0x0080e408

    $t
    !!!main
    __main
        0x0080e408:    f000f802    ....    BL       __scatterload ; 0x80e410
        0x0080e40c:    f5f9f3fc    ....    BL       __rt_entry ; 0x207c08
    !!!scatter
    __scatterload
    __scatterload_rt2
    __scatterload_rt2_thumb_only
        0x0080e410:    a00a        ..      ADR      r0,{pc}+0x2c ; 0x80e43c
        0x0080e412:    e8900c00    ....    LDM      r0,{r10,r11}
        0x0080e416:    4482        .D      ADD      r10,r10,r0
        0x0080e418:    4483        .D      ADD      r11,r11,r0
        0x0080e41a:    f1aa0701    ....    SUB      r7,r10,#1
    __scatterload_null
        0x0080e41e:    45da        .E      CMP      r10,r11
        0x0080e420:    d101        ..      BNE      0x80e426 ; __scatterload_null + 8
        0x0080e422:    f5f9f3f1    ....    BL       __rt_entry ; 0x207c08
        0x0080e426:    f2af0e09    ....    ADR      lr,{pc}-7 ; 0x80e41f
        0x0080e42a:    e8ba000f    ....    LDM      r10!,{r0-r3}
        0x0080e42e:    f0130f01    ....    TST      r3,#1
        0x0080e432:    bf18        ..      IT       NE
        0x0080e434:    1afb        ..      SUBNE    r3,r7,r3
        0x0080e436:    f0430301    C...    ORR      r3,r3,#1
        0x0080e43a:    4718        .G      BX       r3
    $d
        0x0080e43c:    000001d4    ....    DCD    468
        0x0080e440:    00000214    ....    DCD    532
    $t
    !!handler_copy
    __scatterload_copy
        0x0080e444:    3a10        .:      SUBS     r2,r2,#0x10
        0x0080e446:    bf24        $.      ITT      CS
        0x0080e448:    c878        x.      LDMCS    r0!,{r3-r6}
        0x0080e44a:    c178        x.      STMCS    r1!,{r3-r6}
        0x0080e44c:    d8fa        ..      BHI      __scatterload_copy ; 0x80e444
        0x0080e44e:    0752        R.      LSLS     r2,r2,#29
        0x0080e450:    bf24        $.      ITT      CS
        0x0080e452:    c830        0.      LDMCS    r0!,{r4,r5}
        0x0080e454:    c130        0.      STMCS    r1!,{r4,r5}
        0x0080e456:    bf44        D.      ITT      MI
        0x0080e458:    6804        .h      LDRMI    r4,[r0,#0]
        0x0080e45a:    600c        .`      STRMI    r4,[r1,#0]
        0x0080e45c:    4770        pG      BX       lr
        0x0080e45e:    0000        ..      MOVS     r0,r0
    !!handler_zi
    __scatterload_zeroinit
        0x0080e460:    2300        .#      MOVS     r3,#0
        0x0080e462:    2400        .$      MOVS     r4,#0
        0x0080e464:    2500        .%      MOVS     r5,#0
        0x0080e466:    2600        .&      MOVS     r6,#0
        0x0080e468:    3a10        .:      SUBS     r2,r2,#0x10
        0x0080e46a:    bf28        (.      IT       CS
        0x0080e46c:    c178        x.      STMCS    r1!,{r3-r6}
        0x0080e46e:    d8fb        ..      BHI      0x80e468 ; __scatterload_zeroinit + 8
        0x0080e470:    0752        R.      LSLS     r2,r2,#29
        0x0080e472:    bf28        (.      IT       CS
        0x0080e474:    c130        0.      STMCS    r1!,{r4,r5}
        0x0080e476:    bf48        H.      IT       MI
        0x0080e478:    600b        .`      STRMI    r3,[r1,#0]
        0x0080e47a:    4770        pG      BX       lr
    .app.flash.text
    debug_monitor_enable
;;;1734           SCB->SHP[((uint32_t)(IRQn) & 0xF) - 4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);
        0x0080e47c:    4945        EI      LDR      r1,[pc,#276] ; [0x80e594] = 0xe000e00c
        0x0080e47e:    2060        `       MOVS     r0,#0x60
        0x0080e480:    f8810d14    ....    STRB     r0,[r1,#0xd14]
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c
;;;298        CoreDebug->DEMCR |= CoreDebug_DEMCR_MON_EN_Msk | CoreDebug_DEMCR_TRCENA_Msk;
        0x0080e484:    4844        DH      LDR      r0,[pc,#272] ; [0x80e598] = 0xe000edfc
        0x0080e486:    6801        .h      LDR      r1,[r0,#0]
        0x0080e488:    4a44        DJ      LDR      r2,[pc,#272] ; [0x80e59c] = 0x1010000
        0x0080e48a:    4311        .C      ORRS     r1,r1,r2
        0x0080e48c:    6001        .`      STR      r1,[r0,#0]
;;;299    
;;;300        //set DWT compare registers (max 4 comparators)
;;;301        //watch_point_0_setting(0x1000180C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_WRITE);
;;;302        //watch_point_1_setting(0x10000004, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;303        //watch_point_2_setting(0x10000008, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;304        //watch_point_3_setting(0x1000000C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;305    
;;;306        //enable DWT control register
;;;307        DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
        0x0080e48e:    4844        DH      LDR      r0,[pc,#272] ; [0x80e5a0] = 0xe0001000
        0x0080e490:    6801        .h      LDR      r1,[r0,#0]
        0x0080e492:    f0410101    A...    ORR      r1,r1,#1
        0x0080e496:    6001        .`      STR      r1,[r0,#0]
;;;308    
;;;309        return;
;;;310    }
        0x0080e498:    4770        pG      BX       lr
    ram_init
;;;311    
;;;312    APP_FLASH_TEXT_SECTION
;;;313    void ram_init(void)
;;;314    {
        0x0080e49a:    b510        ..      PUSH     {r4,lr}
;;;315        //copy data on ro
;;;316        extern char Image$$RAM_DATA_ON$$RO$$Base[];
;;;317        extern char Load$$RAM_DATA_ON$$RO$$Base[];
;;;318        extern unsigned int Image$$RAM_DATA_ON$$RO$$Length;
;;;319    
;;;320        memcpy(Image$$RAM_DATA_ON$$RO$$Base,
        0x0080e49c:    4a41        AJ      LDR      r2,[pc,#260] ; [0x80e5a4] = 0x3e34
        0x0080e49e:    4942        BI      LDR      r1,[pc,#264] ; [0x80e5a8] = 0x80e744
        0x0080e4a0:    4842        BH      LDR      r0,[pc,#264] ; [0x80e5ac] = 0x207c00
        0x0080e4a2:    f44bf4fa    K...    BL       __aeabi_memcpy ; 0x59e9a
;;;321               Load$$RAM_DATA_ON$$RO$$Base,
;;;322               (unsigned int)&Image$$RAM_DATA_ON$$RO$$Length);
;;;323    
;;;324        //copy data on rw
;;;325        extern char Image$$RAM_DATA_ON$$RW$$Base[];
;;;326        extern char Load$$RAM_DATA_ON$$RW$$Base[];
;;;327        extern unsigned int Image$$RAM_DATA_ON$$RW$$Length;
;;;328    
;;;329        memcpy(Image$$RAM_DATA_ON$$RW$$Base,
        0x0080e4a6:    4a42        BJ      LDR      r2,[pc,#264] ; [0x80e5b0] = 0xa0
        0x0080e4a8:    4942        BI      LDR      r1,[pc,#264] ; [0x80e5b4] = 0x812578
        0x0080e4aa:    4843        CH      LDR      r0,[pc,#268] ; [0x80e5b8] = 0x20ba34
        0x0080e4ac:    f44bf4f5    K...    BL       __aeabi_memcpy ; 0x59e9a
;;;330               Load$$RAM_DATA_ON$$RW$$Base,
;;;331               (unsigned int)&Image$$RAM_DATA_ON$$RW$$Length);
;;;332    
;;;333        //clear data on zi
;;;334        extern char Image$$RAM_DATA_ON$$ZI$$Base[];
;;;335        extern unsigned int Image$$RAM_DATA_ON$$ZI$$Length;
;;;336    
;;;337        memset(Image$$RAM_DATA_ON$$ZI$$Base,
        0x0080e4b0:    4942        BI      LDR      r1,[pc,#264] ; [0x80e5bc] = 0x218
        0x0080e4b2:    4843        CH      LDR      r0,[pc,#268] ; [0x80e5c0] = 0x20bad4
        0x0080e4b4:    f44bf5b2    K...    BL       __aeabi_memclr ; 0x5a01c
;;;338               0,
;;;339               (unsigned int)&Image$$RAM_DATA_ON$$ZI$$Length);
;;;340    
;;;341        //copy cache ro
;;;342        extern char Image$$CACHE_DATA_ON$$RO$$Base[];
;;;343        extern char Load$$CACHE_DATA_ON$$RO$$Base[];
;;;344        extern unsigned int Image$$CACHE_DATA_ON$$RO$$Length;
;;;345    
;;;346        memcpy(Image$$CACHE_DATA_ON$$RO$$Base,
        0x0080e4b8:    e8bd4010    ...@    POP      {r4,lr}
        0x0080e4bc:    4a41        AJ      LDR      r2,[pc,#260] ; [0x80e5c4] = 0
        0x0080e4be:    4942        BI      LDR      r1,[pc,#264] ; [0x80e5c8] = 0x8126d8
        0x0080e4c0:    4842        BH      LDR      r0,[pc,#264] ; [0x80e5cc] = 0x21c000
        0x0080e4c2:    f44bb4ea    K...    B        __aeabi_memcpy ; 0x59e9a
    pre_main
;;;347               Load$$CACHE_DATA_ON$$RO$$Base,
;;;348               (unsigned int)&Image$$CACHE_DATA_ON$$RO$$Length);
;;;349    }
;;;350    
;;;351    APP_FLASH_TEXT_SECTION
;;;352    void SystemInit(void)
;;;353    {
;;;354        //init pre_main and main functions
;;;355        extern void pre_main(void);
;;;356        app_pre_main = (APP_MAIN_FUNC)pre_main;
;;;357        app_main = (APP_MAIN_FUNC)common_main;
;;;358    
;;;359        /******** update otp here**********/
;;;360        //ram config
;;;361        OTP->appDataSize = APP_GLOBAL_SIZE;
;;;362        OTP->heapDataONSize = HEAP_DATA_ON_SIZE;
;;;363        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;364    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;365        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
;;;366    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;367        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;368    #else
;;;369        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;370    #endif
;;;371    
;;;372    
;;;373        //flash config
;;;374        /*config enable flash block proect depending on flash layout and flash id*/
;;;375    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;376        OTP->bp_enable = 1;
;;;377    #else
;;;378        OTP->bp_enable = 0;
;;;379    #endif
;;;380        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
;;;381    
;;;382    
;;;383        //os config
;;;384        /*config enable check task stack overflow*/
;;;385    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;386        OTP->checkForStackOverflow = 1;
;;;387    #else
;;;388        OTP->checkForStackOverflow = 0;
;;;389    #endif
;;;390    
;;;391    
;;;392        //platform config
;;;393        /*config enable platform assert*/
;;;394    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;395        OTP->enableASSERT = 1;
;;;396    #else
;;;397        OTP->enableASSERT = 0;
;;;398    #endif
;;;399    
;;;400        /*Print all log in log buffer before entering DLPS */
;;;401    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;402        OTP->printAllLogBeforeEnterDLPS = 1;
;;;403    #else
;;;404        OTP->printAllLogBeforeEnterDLPS = 0;
;;;405    #endif
;;;406    
;;;407        /*config enable log or not*/
;;;408    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;409        OTP->logDisable = 0;
;;;410    #else
;;;411        OTP->logDisable = 1;
;;;412    #endif
;;;413    
;;;414        /*config enable swd pinmux*/
;;;415    #if (SWD_PINMUX_ENABLE == 1)
;;;416        OTP->SWD_ENABLE = 1;
;;;417    #else
;;;418        OTP->SWD_ENABLE = 0;
;;;419    #endif
;;;420    
;;;421        /*config enable watch dog in rom*/
;;;422    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;423        OTP->wdgEnableInRom = 1;
;;;424    #else
;;;425        OTP->wdgEnableInRom = 0;
;;;426    #endif
;;;427    
;;;428        /*config watch dog mode in rom, defualt reset all*/
;;;429        OTP->wdgMode = ROM_WATCH_DOG_MODE;
;;;430    
;;;431    
;;;432        //app config
;;;433        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
;;;434        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
;;;435        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
;;;436        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
;;;437    
;;;438        /*config bt stack parameters in rom*/
;;;439    #ifdef BT_STACK_CONFIG_ENABLE
;;;440        bt_stack_config_init();
;;;441    #endif
;;;442    
;;;443    //add more otp config here
;;;444    }
;;;445    
;;;446    APP_FLASH_TEXT_SECTION
;;;447    void pre_main(void)
;;;448    {
        0x0080e4c6:    b538        8.      PUSH     {r3-r5,lr}
;;;449        __disable_irq();
        0x0080e4c8:    b672        r.      CPSID    i
;;;450    
;;;451        ram_init();
        0x0080e4ca:    f7ffffe6    ....    BL       ram_init ; 0x80e49a
;;;452    
;;;453        load_overlay(OVERLAY_SCENARIO_BOOT_ONCE);
        0x0080e4ce:    2000        .       MOVS     r0,#0
        0x0080e4d0:    f5fcf336    ..6.    BL       load_overlay ; 0x20ab40
;;;454    
;;;455        setlocale(LC_ALL, "C");
        0x0080e4d4:    a13e        >.      ADR      r1,{pc}+0xfc ; 0x80e5d0
        0x0080e4d6:    201f        .       MOVS     r0,#0x1f
        0x0080e4d8:    f44bf48c    K...    BL       setlocale ; 0x59df4
;;;456    
;;;457        BOOT_PRINT_ERROR2("SDK Ver: %s, Build Time: %s",
        0x0080e4dc:    f04f5505    O..U    MOV      r5,#0x21400000
        0x0080e4e0:    a13c        <.      ADR      r1,{pc}+0xf4 ; 0x80e5d4
        0x0080e4e2:    4628        (F      MOV      r0,r5
        0x0080e4e4:    f7f9dcc1    ....    BL       trace_string ; 0x7e6a
        0x0080e4e8:    4604        .F      MOV      r4,r0
        0x0080e4ea:    a141        A.      ADR      r1,{pc}+0x106 ; 0x80e5f0
        0x0080e4ec:    4628        (F      MOV      r0,r5
        0x0080e4ee:    f7f9dcbc    ....    BL       trace_string ; 0x7e6a
        0x0080e4f2:    4603        .F      MOV      r3,r0
        0x0080e4f4:    2202        ."      MOVS     r2,#2
        0x0080e4f6:    4940        @I      LDR      r1,[pc,#256] ; [0x80e5f8] = 0x8800000
        0x0080e4f8:    4840        @H      LDR      r0,[pc,#256] ; [0x80e5fc] = 0x21100300
        0x0080e4fa:    9400        ..      STR      r4,[sp,#0]
        0x0080e4fc:    f7f9daaf    ....    BL       log_buffer ; 0x7a5e
;;;458                          TRACE_STRING(VERSION_BUILD_STR),
;;;459                          TRACE_STRING(BUILDING_TIME));
;;;460    
;;;461        AppUpdateVectorTable();
        0x0080e500:    f5fdf3f4    ....    BL       AppUpdateVectorTable ; 0x20bcec
;;;462    
;;;463        debug_monitor_enable();
        0x0080e504:    e8bd4038    ..8@    POP      {r3-r5,lr}
        0x0080e508:    e7b8        ..      B        debug_monitor_enable ; 0x80e47c
    SystemInit
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (356)
        0x0080e50a:    f2af0045    ..E.    ADR      r0,{pc}-0x43 ; 0x80e4c7
        0x0080e50e:    493c        <I      LDR      r1,[pc,#240] ; [0x80e600] = 0x200c38
;;;357        app_main = (APP_MAIN_FUNC)common_main;
        0x0080e510:    6008        .`      STR      r0,[r1,#0]
        0x0080e512:    493d        =I      LDR      r1,[pc,#244] ; [0x80e608] = 0x200c3c
        0x0080e514:    483b        ;H      LDR      r0,[pc,#236] ; [0x80e604] = 0x207ec9
;;;358    
;;;359        /******** update otp here**********/
;;;360        //ram config
;;;361        OTP->appDataSize = APP_GLOBAL_SIZE;
        0x0080e516:    6008        .`      STR      r0,[r1,#0]
        0x0080e518:    f44f1000    O...    MOV      r0,#0x200000
        0x0080e51c:    f44f410c    O..A    MOV      r1,#0x8c00
;;;362        OTP->heapDataONSize = HEAP_DATA_ON_SIZE;
        0x0080e520:    f8c01384    ....    STR      r1,[r0,#0x384]
        0x0080e524:    f44f41f0    O..A    MOV      r1,#0x7800
;;;363        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;364    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;365        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
        0x0080e528:    f8c01388    ....    STR      r1,[r0,#0x388]
        0x0080e52c:    4937        7I      LDR      r1,[pc,#220] ; [0x80e60c] = 0xa2aa0003
;;;366    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;367        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;368    #else
;;;369        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;370    #endif
;;;371    
;;;372    
;;;373        //flash config
;;;374        /*config enable flash block proect depending on flash layout and flash id*/
;;;375    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;376        OTP->bp_enable = 1;
;;;377    #else
;;;378        OTP->bp_enable = 0;
        0x0080e52e:    f8c013cc    ....    STR      r1,[r0,#0x3cc]
        0x0080e532:    f890134d    ..M.    LDRB     r1,[r0,#0x34d]
        0x0080e536:    f0210108    !...    BIC      r1,r1,#8
        0x0080e53a:    f880134d    ..M.    STRB     r1,[r0,#0x34d]
;;;379    #endif
;;;380        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
        0x0080e53e:    2106        .!      MOVS     r1,#6
        0x0080e540:    f880134f    ..O.    STRB     r1,[r0,#0x34f]
;;;381    
;;;382    
;;;383        //os config
;;;384        /*config enable check task stack overflow*/
;;;385    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;386        OTP->checkForStackOverflow = 1;
        0x0080e544:    f8901378    ..x.    LDRB     r1,[r0,#0x378]
;;;387    #else
;;;388        OTP->checkForStackOverflow = 0;
;;;389    #endif
;;;390    
;;;391    
;;;392        //platform config
;;;393        /*config enable platform assert*/
;;;394    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;395        OTP->enableASSERT = 1;
;;;396    #else
;;;397        OTP->enableASSERT = 0;
;;;398    #endif
;;;399    
;;;400        /*Print all log in log buffer before entering DLPS */
;;;401    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;402        OTP->printAllLogBeforeEnterDLPS = 1;
        0x0080e548:    f0410126    A.&.    ORR      r1,r1,#0x26
        0x0080e54c:    f8801378    ..x.    STRB     r1,[r0,#0x378]
;;;403    #else
;;;404        OTP->printAllLogBeforeEnterDLPS = 0;
;;;405    #endif
;;;406    
;;;407        /*config enable log or not*/
;;;408    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;409        OTP->logDisable = 0;
        0x0080e550:    f890139a    ....    LDRB     r1,[r0,#0x39a]
        0x0080e554:    f0210101    !...    BIC      r1,r1,#1
        0x0080e558:    f880139a    ....    STRB     r1,[r0,#0x39a]
;;;410    #else
;;;411        OTP->logDisable = 1;
;;;412    #endif
;;;413    
;;;414        /*config enable swd pinmux*/
;;;415    #if (SWD_PINMUX_ENABLE == 1)
;;;416        OTP->SWD_ENABLE = 1;
        0x0080e55c:    f8901334    ..4.    LDRB     r1,[r0,#0x334]
        0x0080e560:    f0410101    A...    ORR      r1,r1,#1
        0x0080e564:    f8801334    ..4.    STRB     r1,[r0,#0x334]
;;;417    #else
;;;418        OTP->SWD_ENABLE = 0;
;;;419    #endif
;;;420    
;;;421        /*config enable watch dog in rom*/
;;;422    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;423        OTP->wdgEnableInRom = 1;
;;;424    #else
;;;425        OTP->wdgEnableInRom = 0;
        0x0080e568:    f890137a    ..z.    LDRB     r1,[r0,#0x37a]
        0x0080e56c:    f0210110    !...    BIC      r1,r1,#0x10
;;;426    #endif
;;;427    
;;;428        /*config watch dog mode in rom, defualt reset all*/
;;;429        OTP->wdgMode = ROM_WATCH_DOG_MODE;
        0x0080e570:    f04101c0    A...    ORR      r1,r1,#0xc0
        0x0080e574:    f880137a    ..z.    STRB     r1,[r0,#0x37a]
;;;430    
;;;431    
;;;432        //app config
;;;433        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
        0x0080e578:    21b4        .!      MOVS     r1,#0xb4
        0x0080e57a:    f8801320    .. .    STRB     r1,[r0,#0x320]
;;;434        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
        0x0080e57e:    213c        <!      MOVS     r1,#0x3c
        0x0080e580:    f8801321    ..!.    STRB     r1,[r0,#0x321]
;;;435        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
        0x0080e584:    2164        d!      MOVS     r1,#0x64
        0x0080e586:    f8801322    ..".    STRB     r1,[r0,#0x322]
;;;436        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
        0x0080e58a:    21ff        .!      MOVS     r1,#0xff
        0x0080e58c:    f8801323    ..#.    STRB     r1,[r0,#0x323]
;;;437    
;;;438        /*config bt stack parameters in rom*/
;;;439    #ifdef BT_STACK_CONFIG_ENABLE
;;;440        bt_stack_config_init();
;;;441    #endif
;;;442    
;;;443    //add more otp config here
;;;444    }
        0x0080e590:    4770        pG      BX       lr
    $d
        0x0080e592:    0000        ..      DCW    0
        0x0080e594:    e000e00c    ....    DCD    3758153740
        0x0080e598:    e000edfc    ....    DCD    3758157308
        0x0080e59c:    01010000    ....    DCD    16842752
        0x0080e5a0:    e0001000    ....    DCD    3758100480
        0x0080e5a4:    00003e34    4>..    DCD    15924
        0x0080e5a8:    0080e744    D...    DCD    8447812
        0x0080e5ac:    00207c00    .| .    DCD    2128896
        0x0080e5b0:    000000a0    ....    DCD    160
        0x0080e5b4:    00812578    x%..    DCD    8463736
        0x0080e5b8:    0020ba34    4. .    DCD    2144820
        0x0080e5bc:    00000218    ....    DCD    536
        0x0080e5c0:    0020bad4    .. .    DCD    2144980
        0x0080e5c4:    00000000    ....    DCD    0
        0x0080e5c8:    008126d8    .&..    DCD    8464088
        0x0080e5cc:    0021c000    ..!.    DCD    2211840
        0x0080e5d0:    00000043    C...    DCD    67
        0x0080e5d4:    20697246    Fri     DCD    543781446
        0x0080e5d8:    20706553    Sep     DCD    544236883
        0x0080e5dc:    31203132    21 1    DCD    824193330
        0x0080e5e0:    31303a33    3:01    DCD    825244211
        0x0080e5e4:    2037313a    :17     DCD    540487994
        0x0080e5e8:    38313032    2018    DCD    942747698
        0x0080e5ec:    00000000    ....    DCD    0
        0x0080e5f0:    2e302e31    1.0.    DCD    774909489
        0x0080e5f4:    00302e32    2.0.    DCD    3157554
        0x0080e5f8:    08800000    ....    DCD    142606336
        0x0080e5fc:    21100300    ...!    DCD    554697472
        0x0080e600:    00200c38    8. .    DCD    2100280
        0x0080e604:    00207ec9    .~ .    DCD    2129609
        0x0080e608:    00200c3c    <. .    DCD    2100284
        0x0080e60c:    a2aa0003    ....    DCD    2729050115
    $d.realdata
    Region$$Table$$Base
        0x0080e610:    0080e650    P...    DCD    8447568
        0x0080e614:    00200000    .. .    DCD    2097152
        0x0080e618:    000000f4    ....    DCD    244
        0x0080e61c:    0080e444    D...    DCD    8447044
        0x0080e620:    0080e744    D...    DCD    8447812
        0x0080e624:    00207c00    .| .    DCD    2128896
        0x0080e628:    00003e34    4>..    DCD    15924
        0x0080e62c:    0080e444    D...    DCD    8447044
        0x0080e630:    00812578    x%..    DCD    8463736
        0x0080e634:    0020ba34    4. .    DCD    2144820
        0x0080e638:    000000a0    ....    DCD    160
        0x0080e63c:    0080e444    D...    DCD    8447044
        0x0080e640:    00812618    .&..    DCD    8463896
        0x0080e644:    0020bad4    .. .    DCD    2144980
        0x0080e648:    00000218    ....    DCD    536
        0x0080e64c:    0080e460    `...    DCD    8447072
    Region$$Table$$Limit

** Section #4 'RAM_VECTOR_TABLE' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 244 bytes (alignment 4)
    Address: 0x00200000

    0x200000:   00 38 20 00 01 e4 80 00 79 7e 20 00 79 7e 20 00    .8 .....y~ .y~ .
    0x200010:   79 7e 20 00 79 7e 20 00 79 7e 20 00 00 00 00 00    y~ .y~ .y~ .....
    0x200020:   00 00 00 00 00 00 00 00 00 00 00 00 79 7e 20 00    ............y~ .
    0x200030:   79 7e 20 00 00 00 00 00 79 7e 20 00 79 7e 20 00    y~ .....y~ .y~ .
    0x200040:   f7 91 20 00 79 7e 20 00 79 7e 20 00 79 7e 20 00    .. .y~ .y~ .y~ .
    0x200050:   79 7e 20 00 79 7e 20 00 79 7e 20 00 79 7e 20 00    y~ .y~ .y~ .y~ .
    0x200060:   79 7e 20 00 79 7e 20 00 79 7e 20 00 79 7e 20 00    y~ .y~ .y~ .y~ .
    0x200070:   79 7e 20 00 79 7e 20 00 79 7e 20 00 79 7e 20 00    y~ .y~ .y~ .y~ .
    0x200080:   79 7e 20 00 79 7e 20 00 79 7e 20 00 79 7e 20 00    y~ .y~ .y~ .y~ .
    0x200090:   79 7e 20 00 79 7e 20 00 79 7e 20 00 79 7e 20 00    y~ .y~ .y~ .y~ .
    0x2000a0:   79 7e 20 00 79 7e 20 00 1d 7c 20 00 69 7c 20 00    y~ .y~ ..| .i| .
    0x2000b0:   79 7e 20 00 b5 7c 20 00 f9 7c 20 00 79 7e 20 00    y~ ..| ..| .y~ .
    0x2000c0:   79 7e 20 00 79 7e 20 00 79 7e 20 00 79 7e 20 00    y~ .y~ .y~ .y~ .
    0x2000d0:   79 7e 20 00 79 7e 20 00 51 9d 20 00 79 7e 20 00    y~ .y~ .Q. .y~ .
    0x2000e0:   79 7e 20 00 79 7e 20 00 79 7e 20 00 79 7e 20 00    y~ .y~ .y~ .y~ .
    0x2000f0:   79 7e 20 00                                        y~ .

    __Vectors_End

** Section #5 'RAM_DATA_ON' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 15924 bytes (alignment 4)
    Address: 0x00207c00

    $t
    .ARM.Collect$$libinit$$00000000
    __rt_lib_init
        0x00207c00:    b51f        ..      PUSH     {r0-r4,lr}
    .ARM.Collect$$libinit$$00000001
    __rt_lib_init_fp_1
        0x00207c02:    f003f8e1    ....    BL       _fp_init ; 0x20adc8
    .ARM.Collect$$libinit$$00000004
    .ARM.Collect$$libinit$$0000000A
    .ARM.Collect$$libinit$$0000000C
    .ARM.Collect$$libinit$$0000000E
    .ARM.Collect$$libinit$$00000011
    .ARM.Collect$$libinit$$00000013
    .ARM.Collect$$libinit$$00000015
    .ARM.Collect$$libinit$$00000017
    .ARM.Collect$$libinit$$00000019
    .ARM.Collect$$libinit$$0000001B
    .ARM.Collect$$libinit$$0000001D
    .ARM.Collect$$libinit$$0000001F
    .ARM.Collect$$libinit$$00000021
    .ARM.Collect$$libinit$$00000023
    .ARM.Collect$$libinit$$00000025
    .ARM.Collect$$libinit$$0000002C
    .ARM.Collect$$libinit$$0000002E
    .ARM.Collect$$libinit$$00000030
    .ARM.Collect$$libinit$$00000032
    .ARM.Collect$$libinit$$00000033
    __rt_lib_init_alloca_1
    __rt_lib_init_argv_1
    __rt_lib_init_atexit_1
    __rt_lib_init_clock_1
    __rt_lib_init_cpp_1
    __rt_lib_init_exceptions_1
    __rt_lib_init_fp_trap_1
    __rt_lib_init_getenv_1
    __rt_lib_init_heap_1
    __rt_lib_init_lc_collate_1
    __rt_lib_init_lc_ctype_1
    __rt_lib_init_lc_monetary_1
    __rt_lib_init_lc_numeric_1
    __rt_lib_init_lc_time_1
    __rt_lib_init_preinit_1
    __rt_lib_init_rand_1
    __rt_lib_init_return
    __rt_lib_init_signal_1
    __rt_lib_init_stdio_1
    __rt_lib_init_user_alloc_1
        0x00207c06:    bd1f        ..      POP      {r0-r4,pc}
    .ARM.Collect$$rtentry$$00000000
    .ARM.Collect$$rtentry$$00000002
    .ARM.Collect$$rtentry$$00000004
    __rt_entry
    __rt_entry_presh_1
    __rt_entry_sh
        0x00207c08:    f000f93e    ..>.    BL       __user_setup_stackheap ; 0x207e88
        0x00207c0c:    4611        .F      MOV      r1,r2
    .ARM.Collect$$rtentry$$00000009
    .ARM.Collect$$rtentry$$0000000A
    __rt_entry_li
    __rt_entry_postsh_1
        0x00207c0e:    f7fffff7    ....    BL       __rt_lib_init ; 0x207c00
    .ARM.Collect$$rtentry$$0000000C
    .ARM.Collect$$rtentry$$0000000D
    __rt_entry_main
    __rt_entry_postli_1
        0x00207c12:    f001fb23    ..#.    BL       main ; 0x20925c
        0x00207c16:    f653f905    S...    BL       exit ; 0x5ae24
        0x00207c1a:    0000        ..      MOVS     r0,r0
    .ram.dataon.data
    GPIO_Group3_Handler
;;;537        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207c1c:    4847        GH      LDR      r0,[pc,#284] ; [0x207d3c] = 0x40001000
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (536)
        0x00207c1e:    b510        ..      PUSH     {r4,lr}
        0x00207c20:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207c22:    0720         .      LSLS     r0,r4,#28
        0x00207c24:    d501        ..      BPL      0x207c2a ; GPIO_Group3_Handler + 14
;;;537        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;538    
;;;539        //Check exact IRQ function
;;;540        if (GPIOIrqStatus & BIT3)
;;;541        {
;;;542            GPIO3_Handler();
        0x00207c26:    f000f927    ..'.    BL       ADC_Handler ; 0x207e78
;;;543        }
;;;544        if (GPIOIrqStatus & BIT7)
        0x00207c2a:    0620         .      LSLS     r0,r4,#24
        0x00207c2c:    d501        ..      BPL      0x207c32 ; GPIO_Group3_Handler + 22
;;;545        {
;;;546            GPIO7_Handler();
        0x00207c2e:    f000f923    ..#.    BL       ADC_Handler ; 0x207e78
;;;547        }
;;;548        if (GPIOIrqStatus & BIT11)
        0x00207c32:    0520         .      LSLS     r0,r4,#20
        0x00207c34:    d501        ..      BPL      0x207c3a ; GPIO_Group3_Handler + 30
;;;549        {
;;;550            GPIO11_Handler();
        0x00207c36:    f000f91f    ....    BL       ADC_Handler ; 0x207e78
;;;551        }
;;;552        if (GPIOIrqStatus & BIT15)
        0x00207c3a:    0420         .      LSLS     r0,r4,#16
        0x00207c3c:    d501        ..      BPL      0x207c42 ; GPIO_Group3_Handler + 38
;;;553        {
;;;554            GPIO15_Handler();
        0x00207c3e:    f000f91b    ....    BL       ADC_Handler ; 0x207e78
;;;555        }
;;;556        if (GPIOIrqStatus & BIT19)
        0x00207c42:    0320         .      LSLS     r0,r4,#12
        0x00207c44:    d501        ..      BPL      0x207c4a ; GPIO_Group3_Handler + 46
;;;557        {
;;;558            GPIO19_Handler();
        0x00207c46:    f000f917    ....    BL       ADC_Handler ; 0x207e78
;;;559        }
;;;560        if (GPIOIrqStatus & BIT23)
        0x00207c4a:    0220         .      LSLS     r0,r4,#8
        0x00207c4c:    d501        ..      BPL      0x207c52 ; GPIO_Group3_Handler + 54
;;;561        {
;;;562            GPIO23_Handler();
        0x00207c4e:    f000f913    ....    BL       ADC_Handler ; 0x207e78
;;;563        }
;;;564        if (GPIOIrqStatus & BIT27)
        0x00207c52:    0120         .      LSLS     r0,r4,#4
        0x00207c54:    d501        ..      BPL      0x207c5a ; GPIO_Group3_Handler + 62
;;;565        {
;;;566            GPIO27_Handler();
        0x00207c56:    f000f90f    ....    BL       ADC_Handler ; 0x207e78
;;;567        }
;;;568        if (GPIOIrqStatus & BIT31)
        0x00207c5a:    2c00        .,      CMP      r4,#0
        0x00207c5c:    da03        ..      BGE      0x207c66 ; GPIO_Group3_Handler + 74
;;;569        {
;;;570            GPIO31_Handler();
        0x00207c5e:    e8bd4010    ...@    POP      {r4,lr}
        0x00207c62:    f000b909    ....    B.W      ADC_Handler ; 0x207e78
;;;571        }
;;;572    }
        0x00207c66:    bd10        ..      POP      {r4,pc}
    GPIO_Group2_Handler
;;;573    /**
;;;574     * @brief  GPIO Group2 Handler
;;;575     * @param  none
;;;576     * @return none
;;;577      */
;;;578    DATA_RAM_FUNCTION void GPIO_Group2_Handler(void)
;;;579    {
;;;580        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207c68:    4834        4H      LDR      r0,[pc,#208] ; [0x207d3c] = 0x40001000
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (579)
        0x00207c6a:    b510        ..      PUSH     {r4,lr}
        0x00207c6c:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207c6e:    0760        `.      LSLS     r0,r4,#29
        0x00207c70:    d501        ..      BPL      0x207c76 ; GPIO_Group2_Handler + 14
;;;580        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;581    
;;;582        //Check exact IRQ function
;;;583        if (GPIOIrqStatus & BIT2)
;;;584        {
;;;585            GPIO2_Handler();
        0x00207c72:    f000f901    ....    BL       ADC_Handler ; 0x207e78
;;;586        }
;;;587        if (GPIOIrqStatus & BIT6)
        0x00207c76:    0660        `.      LSLS     r0,r4,#25
        0x00207c78:    d501        ..      BPL      0x207c7e ; GPIO_Group2_Handler + 22
;;;588        {
;;;589            GPIO6_Handler();
        0x00207c7a:    f000f8fd    ....    BL       ADC_Handler ; 0x207e78
;;;590        }
;;;591        if (GPIOIrqStatus & BIT10)
        0x00207c7e:    0560        `.      LSLS     r0,r4,#21
        0x00207c80:    d501        ..      BPL      0x207c86 ; GPIO_Group2_Handler + 30
;;;592        {
;;;593            GPIO10_Handler();
        0x00207c82:    f000f8f9    ....    BL       ADC_Handler ; 0x207e78
;;;594        }
;;;595        if (GPIOIrqStatus & BIT14)
        0x00207c86:    0460        `.      LSLS     r0,r4,#17
        0x00207c88:    d501        ..      BPL      0x207c8e ; GPIO_Group2_Handler + 38
;;;596        {
;;;597            GPIO14_Handler();
        0x00207c8a:    f000f8f5    ....    BL       ADC_Handler ; 0x207e78
;;;598        }
;;;599        if (GPIOIrqStatus & BIT18)
        0x00207c8e:    0360        `.      LSLS     r0,r4,#13
        0x00207c90:    d501        ..      BPL      0x207c96 ; GPIO_Group2_Handler + 46
;;;600        {
;;;601            GPIO18_Handler();
        0x00207c92:    f000f8f1    ....    BL       ADC_Handler ; 0x207e78
;;;602        }
;;;603        if (GPIOIrqStatus & BIT22)
        0x00207c96:    0260        `.      LSLS     r0,r4,#9
        0x00207c98:    d501        ..      BPL      0x207c9e ; GPIO_Group2_Handler + 54
;;;604        {
;;;605            GPIO22_Handler();
        0x00207c9a:    f000f8ed    ....    BL       ADC_Handler ; 0x207e78
;;;606        }
;;;607        if (GPIOIrqStatus & BIT26)
        0x00207c9e:    0160        `.      LSLS     r0,r4,#5
        0x00207ca0:    d501        ..      BPL      0x207ca6 ; GPIO_Group2_Handler + 62
;;;608        {
;;;609            GPIO26_Handler();
        0x00207ca2:    f000f8e9    ....    BL       ADC_Handler ; 0x207e78
;;;610        }
;;;611        if (GPIOIrqStatus & BIT30)
        0x00207ca6:    0060        `.      LSLS     r0,r4,#1
        0x00207ca8:    d503        ..      BPL      0x207cb2 ; GPIO_Group2_Handler + 74
;;;612        {
;;;613            GPIO30_Handler();
        0x00207caa:    e8bd4010    ...@    POP      {r4,lr}
        0x00207cae:    f000b8e3    ....    B.W      ADC_Handler ; 0x207e78
;;;614        }
;;;615    }
        0x00207cb2:    bd10        ..      POP      {r4,pc}
    GPIO_Group1_Handler
;;;616    /**
;;;617     * @brief  GPIO Group1 Handler
;;;618     * @param  none
;;;619     * @return none
;;;620      */
;;;621    DATA_RAM_FUNCTION void GPIO_Group1_Handler(void)
;;;622    {
;;;623        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207cb4:    4821        !H      LDR      r0,[pc,#132] ; [0x207d3c] = 0x40001000
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (622)
        0x00207cb6:    b510        ..      PUSH     {r4,lr}
        0x00207cb8:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207cba:    07a0        ..      LSLS     r0,r4,#30
        0x00207cbc:    d501        ..      BPL      0x207cc2 ; GPIO_Group1_Handler + 14
;;;623        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;624    
;;;625        //Check exact IRQ function
;;;626        if (GPIOIrqStatus & BIT1)
;;;627        {
;;;628            GPIO1_Handler();
        0x00207cbe:    f000f8db    ....    BL       ADC_Handler ; 0x207e78
;;;629        }
;;;630        if (GPIOIrqStatus & BIT9)
        0x00207cc2:    05a0        ..      LSLS     r0,r4,#22
        0x00207cc4:    d501        ..      BPL      0x207cca ; GPIO_Group1_Handler + 22
;;;631        {
;;;632            GPIO9_Handler();
        0x00207cc6:    f000f8d7    ....    BL       ADC_Handler ; 0x207e78
;;;633        }
;;;634        if (GPIOIrqStatus & BIT13)
        0x00207cca:    04a0        ..      LSLS     r0,r4,#18
        0x00207ccc:    d501        ..      BPL      0x207cd2 ; GPIO_Group1_Handler + 30
;;;635        {
;;;636            GPIO13_Handler();
        0x00207cce:    f000f8d3    ....    BL       ADC_Handler ; 0x207e78
;;;637        }
;;;638        if (GPIOIrqStatus & BIT17)
        0x00207cd2:    03a0        ..      LSLS     r0,r4,#14
        0x00207cd4:    d501        ..      BPL      0x207cda ; GPIO_Group1_Handler + 38
;;;639        {
;;;640            GPIO17_Handler();
        0x00207cd6:    f000f8cf    ....    BL       ADC_Handler ; 0x207e78
;;;641        }
;;;642        if (GPIOIrqStatus & BIT21)
        0x00207cda:    02a0        ..      LSLS     r0,r4,#10
        0x00207cdc:    d501        ..      BPL      0x207ce2 ; GPIO_Group1_Handler + 46
;;;643        {
;;;644            GPIO21_Handler();
        0x00207cde:    f000f8cb    ....    BL       ADC_Handler ; 0x207e78
;;;645        }
;;;646        if (GPIOIrqStatus & BIT25)
        0x00207ce2:    01a0        ..      LSLS     r0,r4,#6
        0x00207ce4:    d501        ..      BPL      0x207cea ; GPIO_Group1_Handler + 54
;;;647        {
;;;648            GPIO25_Handler();
        0x00207ce6:    f000f8c7    ....    BL       ADC_Handler ; 0x207e78
;;;649        }
;;;650        if (GPIOIrqStatus & BIT29)
        0x00207cea:    00a0        ..      LSLS     r0,r4,#2
        0x00207cec:    d503        ..      BPL      0x207cf6 ; GPIO_Group1_Handler + 66
;;;651        {
;;;652            GPIO29_Handler();
        0x00207cee:    e8bd4010    ...@    POP      {r4,lr}
        0x00207cf2:    f000b8c1    ....    B.W      ADC_Handler ; 0x207e78
;;;653        }
;;;654    }
        0x00207cf6:    bd10        ..      POP      {r4,pc}
    GPIO_Group0_Handler
;;;655    /**
;;;656     * @brief  GPIO Group0 Handler
;;;657     * @param  none
;;;658     * @return none
;;;659      */
;;;660    DATA_RAM_FUNCTION void GPIO_Group0_Handler(void)
;;;661    {
;;;662        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207cf8:    4810        .H      LDR      r0,[pc,#64] ; [0x207d3c] = 0x40001000
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (661)
        0x00207cfa:    b510        ..      PUSH     {r4,lr}
        0x00207cfc:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207cfe:    07e0        ..      LSLS     r0,r4,#31
        0x00207d00:    d001        ..      BEQ      0x207d06 ; GPIO_Group0_Handler + 14
;;;662        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;663    
;;;664        //Check exact IRQ function
;;;665        if (GPIOIrqStatus & BIT0)
;;;666        {
;;;667            GPIO0_Handler();
        0x00207d02:    f000f8b9    ....    BL       ADC_Handler ; 0x207e78
;;;668        }
;;;669        if (GPIOIrqStatus & BIT8)
        0x00207d06:    05e0        ..      LSLS     r0,r4,#23
        0x00207d08:    d501        ..      BPL      0x207d0e ; GPIO_Group0_Handler + 22
;;;670        {
;;;671            GPIO8_Handler();
        0x00207d0a:    f000f8b5    ....    BL       ADC_Handler ; 0x207e78
;;;672        }
;;;673        if (GPIOIrqStatus & BIT12)
        0x00207d0e:    04e0        ..      LSLS     r0,r4,#19
        0x00207d10:    d501        ..      BPL      0x207d16 ; GPIO_Group0_Handler + 30
;;;674        {
;;;675            GPIO12_Handler();
        0x00207d12:    f000f8b1    ....    BL       ADC_Handler ; 0x207e78
;;;676        }
;;;677        if (GPIOIrqStatus & BIT16)
        0x00207d16:    03e0        ..      LSLS     r0,r4,#15
        0x00207d18:    d501        ..      BPL      0x207d1e ; GPIO_Group0_Handler + 38
;;;678        {
;;;679            GPIO16_Handler();
        0x00207d1a:    f000f8ad    ....    BL       ADC_Handler ; 0x207e78
;;;680        }
;;;681        if (GPIOIrqStatus & BIT20)
        0x00207d1e:    02e0        ..      LSLS     r0,r4,#11
        0x00207d20:    d501        ..      BPL      0x207d26 ; GPIO_Group0_Handler + 46
;;;682        {
;;;683            GPIO20_Handler();
        0x00207d22:    f002fb85    ....    BL       GPIO20_Handler ; 0x20a430
;;;684        }
;;;685        if (GPIOIrqStatus & BIT24)
        0x00207d26:    01e0        ..      LSLS     r0,r4,#7
        0x00207d28:    d501        ..      BPL      0x207d2e ; GPIO_Group0_Handler + 54
;;;686        {
;;;687            GPIO24_Handler();
        0x00207d2a:    f000f8a5    ....    BL       ADC_Handler ; 0x207e78
;;;688        }
;;;689        if (GPIOIrqStatus & BIT28)
        0x00207d2e:    00e0        ..      LSLS     r0,r4,#3
        0x00207d30:    d503        ..      BPL      0x207d3a ; GPIO_Group0_Handler + 66
;;;690        {
;;;691            GPIO28_Handler();
        0x00207d32:    e8bd4010    ...@    POP      {r4,lr}
        0x00207d36:    f000b89f    ....    B.W      ADC_Handler ; 0x207e78
;;;692        }
;;;693    }
        0x00207d3a:    bd10        ..      POP      {r4,pc}
    $d
        0x00207d3c:    40001000    ...@    DCD    1073745920
    $t
    .ram.dataon.data
    DLPS_IO_ExitDlpsCb
;;; .\..\..\..\src\mcu\peripheral\rtl876x_io_dlps.c
;;;1957   {
        0x00207d40:    b530        0.      PUSH     {r4,r5,lr}
        0x00207d42:    4947        GI      LDR      r1,[pc,#284] ; [0x207e60] = 0x20bc30
        0x00207d44:    b085        ..      SUB      sp,sp,#0x14
;;; .\..\..\..\src\mcu\peripheral\rtl876x_io_dlps.c (127)
        0x00207d46:    2000        .       MOVS     r0,#0
        0x00207d48:    0082        ..      LSLS     r2,r0,#2
        0x00207d4a:    f1024280    ...B    ADD      r2,r2,#0x40000000
        0x00207d4e:    f8513020    Q. 0    LDR      r3,[r1,r0,LSL #2]
        0x00207d52:    f8c23280    ...2    STR      r3,[r2,#0x280]
        0x00207d56:    1c40        @.      ADDS     r0,r0,#1
        0x00207d58:    b2c0        ..      UXTB     r0,r0
        0x00207d5a:    280a        .(      CMP      r0,#0xa
        0x00207d5c:    d3f4        ..      BCC      0x207d48 ; DLPS_IO_ExitDlpsCb + 8
;;;128        {
;;;129            PINMUX->CFG[i] = Pinmux_StoreReg[i];
;;;130        }
;;;131    
;;;132        return;
;;;133    }
;;;134    #endif
;;;135    
;;;136    /********************************************** ********************************************************/
;;;137    /**************************************** [GPIO DLPS] **************************************************/
;;;138    /*******************************************************************************************************/
;;;139    /*******************************************************************************************************/
;;;140    #if USE_GPIO_DLPS
;;;141    
;;;142    __STATIC_INLINE void GPIO_DLPS_Enter(void);
;;;143    __STATIC_INLINE void GPIO_DLPS_Exit(void);
;;;144    
;;;145    uint32_t GPIO_StoreReg[9];         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;146    
;;;147    /**
;;;148      * @brief  GPIO enter dlps callback function(Save GPIO register values when system enter DLPS)
;;;149      * @param  None
;;;150      * @retval None
;;;151      */
;;;152    __STATIC_INLINE void GPIO_DLPS_Enter(void)
;;;153    {
;;;154        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;155        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;156    
;;;157        GPIO_StoreReg[0] = GPIO->DATAOUT;
;;;158        GPIO_StoreReg[1] = GPIO->DATADIR;
;;;159        GPIO_StoreReg[2] = GPIO->DATASRC;
;;;160        GPIO_StoreReg[3] = GPIO->INTEN;
;;;161        GPIO_StoreReg[4] = GPIO->INTMASK;
;;;162        GPIO_StoreReg[5] = GPIO->INTTYPE;
;;;163        GPIO_StoreReg[6] = GPIO->INTPOLARITY;
;;;164        GPIO_StoreReg[7] = GPIO->DEBOUNCE;
;;;165        GPIO_StoreReg[8] = *(__IO uint32_t *)(0x40000344UL);
;;;166    
;;;167        return;
;;;168    }
;;;169    
;;;170    /**
;;;171      * @brief  GPIO exit dlps callback function(Resume GPIO register values when system exit DLPS)
;;;172      * @param  None
;;;173      * @retval None
;;;174      */
;;;175    DATA_RAM_FUNCTION __STATIC_INLINE void GPIO_DLPS_Exit(void)
;;;176    {
;;;177        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;178        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;179    
;;;180        GPIO->DATADIR       = GPIO_StoreReg[1];
;;;181        GPIO->DATASRC       = GPIO_StoreReg[2];
;;;182        GPIO->INTMASK       = GPIO_StoreReg[4];
;;;183        GPIO->INTTYPE       = GPIO_StoreReg[5];
;;;184        GPIO->INTPOLARITY   = GPIO_StoreReg[6];
;;;185        GPIO->DEBOUNCE      = GPIO_StoreReg[7];
;;;186        GPIO->DATAOUT       = GPIO_StoreReg[0];
;;;187        GPIO->INTCLR        = ~(GPIO_StoreReg[1]);
;;;188        GPIO->INTEN         = GPIO_StoreReg[3];
;;;189        *(__IO uint32_t *)(0x40000344UL) = GPIO_StoreReg[8];
;;;190    
;;;191        return;
;;;192    }
;;;193    #endif  /* USE_GPIO_DLPS */
;;;194    
;;;195    
;;;196    /********************************************** ********************************************************/
;;;197    /**************************************** [KEYSCAN DLPS] ***********************************************/
;;;198    /*******************************************************************************************************/
;;;199    /*******************************************************************************************************/
;;;200    #if USE_KEYSCAN_DLPS
;;;201    __STATIC_INLINE void KeyScan_DLPS_Enter(void);
;;;202    __STATIC_INLINE void KeyScan_DLPS_Exit(void);
;;;203    
;;;204    uint32_t KeyScan_StoreReg[7];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;205    
;;;206    /**
;;;207      * @brief  KEYSCAN enter dlps callback function(Save KEYSCAN register values when system enter DLPS)
;;;208      * @param  None
;;;209      * @retval None
;;;210      */
;;;211    __STATIC_INLINE void KeyScan_DLPS_Enter(void)
;;;212    {
;;;213        /*Open 5M clock source*/
;;;214        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;215        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;216    
;;;217        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;218        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;219    
;;;220        KeyScan_StoreReg[0] = KEYSCAN->CLKDIV;               /* 0x00 */
;;;221        KeyScan_StoreReg[1] = KEYSCAN->TIMERCR;              /* 0x04 */
;;;222        KeyScan_StoreReg[2] = KEYSCAN->CR;                   /* 0x08 */
;;;223        KeyScan_StoreReg[3] = KEYSCAN->COLCR;                /* 0x0C */
;;;224        KeyScan_StoreReg[4] = KEYSCAN->ROWCR;                /* 0x10 */
;;;225        KeyScan_StoreReg[6] = KEYSCAN->INTMASK;              /* 0x18 */
;;;226    
;;;227        return;
;;;228    }
;;;229    
;;;230    /**
;;;231      * @brief  KEYSCAN exit dlps callback function(Resume KEYSCAN register values when system exit DLPS)
;;;232      * @param  None
;;;233      * @retval None
;;;234      */
;;;235    DATA_RAM_FUNCTION __STATIC_INLINE void KeyScan_DLPS_Exit(void)
;;;236    {
;;;237        /*Open 5M clock source*/
;;;238        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;239        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;240    
;;;241        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;242        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;243    
;;;244        /* Set FSM to idle state */
;;;245        KEYSCAN->CR &= ~BIT31;
;;;246        KEYSCAN->CLKDIV = KeyScan_StoreReg[0];
;;;247        KEYSCAN->CR = (KeyScan_StoreReg[2] & (~(BIT31)));
;;;248        KEYSCAN->TIMERCR = KeyScan_StoreReg[1];
;;;249        KEYSCAN->COLCR = KeyScan_StoreReg[3];
;;;250        KEYSCAN->ROWCR = KeyScan_StoreReg[4];
;;;251        KEYSCAN->INTMASK = KeyScan_StoreReg[6];
;;;252        KEYSCAN->CR |= (KeyScan_StoreReg[2] & ((BIT31)));
;;;253    
;;;254        return;
;;;255    }
;;;256    #endif /* USE_KEYSCAN_DLPS */
;;;257    
;;;258    
;;;259    /********************************************** ********************************************************/
;;;260    /**************************************** [QDEC DLPS] **************************************************/
;;;261    /*******************************************************************************************************/
;;;262    /*******************************************************************************************************/
;;;263    #if USE_QDECODER_DLPS
;;;264    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void);
;;;265    __STATIC_INLINE void QuadDecoder_DLPS_Exit(void);
;;;266    
;;;267    uint32_t QuadDecoder_StoreReg[5];  /*  This array should be placed in RAM ON/Buffer ON.    */
;;;268    
;;;269    /**
;;;270      * @brief  QDEC enter dlps callback function(Save QDEC register values when system enter DLPS)
;;;271      * @param  None
;;;272      * @retval None
;;;273      */
;;;274    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void)
;;;275    {
;;;276        /*Open 20M clock source*/
;;;277        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;278        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;279        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;280        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;281    
;;;282        QuadDecoder_StoreReg[0] = QDEC->REG_DIV;
;;;283        QuadDecoder_StoreReg[1] = QDEC->REG_CR_X;
;;;284        QuadDecoder_StoreReg[2] = QDEC->REG_CR_Y;
;;;285        QuadDecoder_StoreReg[3] = QDEC->REG_CR_Z;
;;;286        QuadDecoder_StoreReg[4] = QDEC->INT_MASK;
;;;287    
;;;288        return;
;;;289    }
;;;290    
;;;291    /**
;;;292      * @brief  QDEC exit dlps callback function(Resume QDEC register values when system exit DLPS)
;;;293      * @param  None
;;;294      * @retval None
;;;295      */
;;;296    DATA_RAM_FUNCTION __STATIC_INLINE void QuadDecoder_DLPS_Exit(void)
;;;297    {
;;;298        /*Open 20M clock source*/
;;;299        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;300        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;301        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;302        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;303    
;;;304        //clear flags
;;;305        QDEC->REG_DIV  = QuadDecoder_StoreReg[0];
;;;306        QDEC->REG_CR_X = QuadDecoder_StoreReg[1];
;;;307        QDEC->REG_CR_Y = QuadDecoder_StoreReg[2];
;;;308        QDEC->REG_CR_Z = QuadDecoder_StoreReg[3];
;;;309        QDEC->INT_MASK = QuadDecoder_StoreReg[4];
;;;310    
;;;311        return;
;;;312    }
;;;313    #endif
;;;314    
;;;315    /********************************************** ********************************************************/
;;;316    /**************************************** [SPI0 DLPS] **************************************************/
;;;317    /*******************************************************************************************************/
;;;318    /*******************************************************************************************************/
;;;319    #if USE_SPI0_DLPS
;;;320    __STATIC_INLINE void SPI0_DLPS_Enter(void);
;;;321    __STATIC_INLINE void SPI0_DLPS_Exit(void);
;;;322    
;;;323    uint32_t SPI0_StoreReg[13];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;324    
;;;325    /**
;;;326      * @brief  SPI0 enter dlps callback function(Save SPI0 register values when system enter DLPS)
;;;327      * @param  None
;;;328      * @retval None
;;;329      */
;;;330    __STATIC_INLINE void SPI0_DLPS_Enter(void)
;;;331    {
;;;332        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;333        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;334    
;;;335        SPI0_StoreReg[0] = SPI0->CTRLR0;
;;;336        SPI0_StoreReg[1] = SPI0->CTRLR1;
;;;337        SPI0_StoreReg[2] = SPI0->SSIENR;
;;;338        SPI0_StoreReg[3] = SPI0->SER;
;;;339        SPI0_StoreReg[4] = SPI0->BAUDR;
;;;340        SPI0_StoreReg[5] = SPI0->TXFTLR;
;;;341        SPI0_StoreReg[6] = SPI0->RXFTLR;
;;;342        SPI0_StoreReg[7] = SPI0->IMR;
;;;343        SPI0_StoreReg[8] = SPI0->DMACR;
;;;344        SPI0_StoreReg[9] = SPI0->DMATDLR;
;;;345        SPI0_StoreReg[10] = SPI0->DMARDLR;
;;;346        SPI0_StoreReg[11] = SPI0->RX_SAMPLE_DLY;
;;;347        SPI0_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;348    }
;;;349    
;;;350    /**
;;;351      * @brief  SPI0 exit dlps callback function(Resume SPI0 register values when system exit DLPS)
;;;352      * @param  None
;;;353      * @retval None
;;;354      */
;;;355    DATA_RAM_FUNCTION __STATIC_INLINE void SPI0_DLPS_Exit(void)
;;;356    {
;;;357        *(volatile uint32_t *)0x40000308 = SPI0_StoreReg[12];
;;;358        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;359        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;360    
;;;361        SPI0->CTRLR0 = SPI0_StoreReg[0];
;;;362        SPI0->CTRLR1 = SPI0_StoreReg[1];
;;;363        SPI0->SER = SPI0_StoreReg[3];
;;;364        SPI0->BAUDR = SPI0_StoreReg[4];
;;;365        SPI0->TXFTLR = SPI0_StoreReg[5];
;;;366        SPI0->RXFTLR = SPI0_StoreReg[6];
;;;367        SPI0->IMR = SPI0_StoreReg[7];
;;;368        SPI0->DMACR = SPI0_StoreReg[8];
;;;369        SPI0->DMATDLR = SPI0_StoreReg[9];
;;;370        SPI0->DMARDLR = SPI0_StoreReg[10];
;;;371        SPI0->RX_SAMPLE_DLY = SPI0_StoreReg[11];
;;;372    
;;;373        /* Enable the selected SPI peripheral */
;;;374        SPI0->SSIENR = SPI0_StoreReg[2];
;;;375    }
;;;376    #endif
;;;377    
;;;378    
;;;379    /********************************************** ********************************************************/
;;;380    /**************************************** [SPI1 DLPS] **************************************************/
;;;381    /*******************************************************************************************************/
;;;382    /*******************************************************************************************************/
;;;383    #if USE_SPI1_DLPS
;;;384    __STATIC_INLINE void SPI1_DLPS_Enter(void);
;;;385    __STATIC_INLINE void SPI1_DLPS_Exit(void);
;;;386    
;;;387    uint32_t SPI1_StoreReg[13];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;388    
;;;389    /**
;;;390      * @brief  SPI1 enter dlps callback function(Save SPI1 register values when system enter DLPS)
;;;391      * @param  None
;;;392      * @retval None
;;;393      */
;;;394    __STATIC_INLINE void SPI1_DLPS_Enter(void)
;;;395    {
;;;396        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;397        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;398    
;;;399        SPI1_StoreReg[0] = SPI1->CTRLR0;
;;;400        SPI1_StoreReg[1] = SPI1->CTRLR1;
;;;401        SPI1_StoreReg[2] = SPI1->SSIENR;
;;;402        SPI1_StoreReg[3] = SPI1->SER;
;;;403        SPI1_StoreReg[4] = SPI1->BAUDR;
;;;404        SPI1_StoreReg[5] = SPI1->TXFTLR;
;;;405        SPI1_StoreReg[6] = SPI1->RXFTLR;
;;;406        SPI1_StoreReg[7] = SPI1->IMR;
;;;407        SPI1_StoreReg[8] = SPI1->DMACR;
;;;408        SPI1_StoreReg[9] = SPI1->DMATDLR;
;;;409        SPI1_StoreReg[10] = SPI1->DMARDLR;
;;;410        SPI1_StoreReg[11] = SPI1->RX_SAMPLE_DLY;
;;;411        SPI1_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;412    }
;;;413    
;;;414    /**
;;;415      * @brief  SPI1 exit dlps callback function(Resume SPI1 register values when system exit DLPS)
;;;416      * @param  None
;;;417      * @retval None
;;;418      */
;;;419    DATA_RAM_FUNCTION __STATIC_INLINE void SPI1_DLPS_Exit(void)
;;;420    {
;;;421        *(volatile uint32_t *)0x40000308 = SPI1_StoreReg[12];
;;;422        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;423        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;424    
;;;425        SPI1->CTRLR0 = SPI1_StoreReg[0];
;;;426        SPI1->CTRLR1 = SPI1_StoreReg[1];
;;;427        SPI1->SER = SPI1_StoreReg[3];
;;;428        SPI1->BAUDR = SPI1_StoreReg[4];
;;;429        SPI1->TXFTLR = SPI1_StoreReg[5];
;;;430        SPI1->RXFTLR = SPI1_StoreReg[6];
;;;431        SPI1->IMR = SPI1_StoreReg[7];
;;;432        SPI1->DMACR = SPI1_StoreReg[8];
;;;433        SPI1->DMATDLR = SPI1_StoreReg[9];
;;;434        SPI1->DMARDLR = SPI1_StoreReg[10];
;;;435        SPI1->RX_SAMPLE_DLY = SPI1_StoreReg[11];
;;;436    
;;;437        /* Enable the selected SPI peripheral */
;;;438        SPI1->SSIENR = SPI1_StoreReg[2];
;;;439    }
;;;440    #endif
;;;441    
;;;442    /********************************************** ********************************************************/
;;;443    /**************************************** [SPI2W DLPS] **************************************************/
;;;444    /*******************************************************************************************************/
;;;445    /*******************************************************************************************************/
;;;446    #if USE_SPI2W_DLPS
;;;447    __STATIC_INLINE void SPI2W_DLPS_Enter(void);
;;;448    __STATIC_INLINE void SPI2W_DLPS_Exit(void);
;;;449    
;;;450    uint32_t SPI2W_StoreReg[1];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;451    
;;;452    /**
;;;453      * @brief  SPI2W enter dlps callback function(Save SPI2W register values when system enter DLPS)
;;;454      * @param  None
;;;455      * @retval None
;;;456      */
;;;457    __STATIC_INLINE void SPI2W_DLPS_Enter(void)
;;;458    {
;;;459        /*Open 20M clock source*/
;;;460        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;461        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;462    
;;;463        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;464        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;465    
;;;466        SPI2W_StoreReg[0] = SPI3WIRE->CFGR;
;;;467    }
;;;468    
;;;469    /**
;;;470      * @brief  SPI2W exit dlps callback function(Resume SPI2W register values when system exit DLPS)
;;;471      * @param  None
;;;472      * @retval None
;;;473      */
;;;474    DATA_RAM_FUNCTION __STATIC_INLINE void SPI2W_DLPS_Exit(void)
;;;475    {
;;;476        /*Open 20M clock source*/
;;;477        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;478        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;479    
;;;480        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;481        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;482    
;;;483        SPI3WIRE->CFGR = SPI2W_StoreReg[0];
;;;484    }
;;;485    #endif
;;;486    
;;;487    /********************************************** ********************************************************/
;;;488    /**************************************** [I2C0 DLPS] **************************************************/
;;;489    /*******************************************************************************************************/
;;;490    /*******************************************************************************************************/
;;;491    #if USE_I2C0_DLPS
;;;492    __STATIC_INLINE void I2C0_DLPS_Enter(void);
;;;493    __STATIC_INLINE void I2C0_DLPS_Exit(void);
;;;494    
;;;495    uint32_t I2C0_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;496    
;;;497    /**
;;;498      * @brief  I2C0 enter dlps callback function(Save I2C0 register values when system enter DLPS)
;;;499      * @param  None
;;;500      * @retval None
;;;501      */
;;;502    __STATIC_INLINE void I2C0_DLPS_Enter(void)
;;;503    {
;;;504        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;505        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;506    
;;;507        I2C0_StoreReg[0] = I2C0->IC_CON;
;;;508        I2C0_StoreReg[1] = I2C0->IC_TAR;
;;;509        I2C0_StoreReg[2] = I2C0->IC_SAR;
;;;510        I2C0_StoreReg[3] = I2C0->IC_HS_MADDR;
;;;511    
;;;512        I2C0_StoreReg[4] = I2C0->IC_SS_SCL_HCNT;
;;;513        I2C0_StoreReg[5] = I2C0->IC_SS_SCL_LCNT;
;;;514        I2C0_StoreReg[6] = I2C0->IC_FS_SCL_HCNT;
;;;515        I2C0_StoreReg[7] = I2C0->IC_FS_SCL_LCNT;
;;;516        I2C0_StoreReg[8] = I2C0->IC_HS_SCL_HCNT;
;;;517        I2C0_StoreReg[9] = I2C0->IC_HS_SCL_LCNT;
;;;518    
;;;519        I2C0_StoreReg[10] = I2C0->IC_INTR_MASK;
;;;520        I2C0_StoreReg[11] = I2C0->IC_RX_TL;
;;;521        I2C0_StoreReg[12] = I2C0->IC_TX_TL;
;;;522        I2C0_StoreReg[13] = I2C0->IC_ENABLE;
;;;523        I2C0_StoreReg[14] = I2C0->IC_SDA_HOLD;
;;;524        I2C0_StoreReg[15] = I2C0->IC_SLV_DATA_NACK_ONLY;
;;;525        I2C0_StoreReg[16] = I2C0->IC_DMA_CR;
;;;526        I2C0_StoreReg[17] = I2C0->IC_DMA_TDLR;
;;;527        I2C0_StoreReg[18] = I2C0->IC_DMA_RDLR;
;;;528    
;;;529        I2C0_StoreReg[19] = I2C0->IC_SDA_SETUP;
;;;530    }
;;;531    
;;;532    /**
;;;533      * @brief  I2C0 exit dlps callback function(Resume I2C0 register values when system exit DLPS)
;;;534      * @param  None
;;;535      * @retval None
;;;536      */
;;;537    DATA_RAM_FUNCTION __STATIC_INLINE void I2C0_DLPS_Exit(void)
;;;538    {
;;;539        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;540        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;541    
;;;542        I2C0->IC_CON = I2C0_StoreReg[0];
;;;543        I2C0->IC_TAR = I2C0_StoreReg[1];
;;;544        I2C0->IC_SAR = I2C0_StoreReg[2];
;;;545        I2C0->IC_HS_MADDR = I2C0_StoreReg[3];
;;;546    
;;;547        I2C0->IC_SS_SCL_HCNT = I2C0_StoreReg[4];
;;;548        I2C0->IC_SS_SCL_LCNT = I2C0_StoreReg[5];
;;;549        I2C0->IC_FS_SCL_HCNT = I2C0_StoreReg[6];
;;;550        I2C0->IC_FS_SCL_LCNT = I2C0_StoreReg[7];
;;;551        I2C0->IC_HS_SCL_HCNT = I2C0_StoreReg[8];
;;;552        I2C0->IC_HS_SCL_LCNT = I2C0_StoreReg[9];
;;;553    
;;;554        I2C0->IC_INTR_MASK = I2C0_StoreReg[10];
;;;555        I2C0->IC_RX_TL = I2C0_StoreReg[11];
;;;556        I2C0->IC_TX_TL = I2C0_StoreReg[12];
;;;557        I2C0->IC_SDA_HOLD = I2C0_StoreReg[14];
;;;558        I2C0->IC_SLV_DATA_NACK_ONLY = I2C0_StoreReg[15];
;;;559        I2C0->IC_DMA_CR = I2C0_StoreReg[16];
;;;560        I2C0->IC_DMA_TDLR = I2C0_StoreReg[17];
;;;561        I2C0->IC_DMA_RDLR = I2C0_StoreReg[18];
;;;562        I2C0->IC_SDA_SETUP = I2C0_StoreReg[19];
;;;563    
;;;564        I2C0->IC_ENABLE = I2C0_StoreReg[13];
;;;565    }
;;;566    #endif
;;;567    
;;;568    /********************************************** ********************************************************/
;;;569    /**************************************** [I2C1 DLPS] **************************************************/
;;;570    /*******************************************************************************************************/
;;;571    /*******************************************************************************************************/
;;;572    #if USE_I2C1_DLPS
;;;573    __STATIC_INLINE void I2C1_DLPS_Enter(void);
;;;574    __STATIC_INLINE void I2C1_DLPS_Exit(void);
;;;575    
;;;576    uint32_t I2C1_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;577    
;;;578    /**
;;;579      * @brief  I2C1 enter dlps callback function(Save I2C1 register values when system enter DLPS)
;;;580      * @param  None
;;;581      * @retval None
;;;582      */
;;;583    __STATIC_INLINE void I2C1_DLPS_Enter(void)
;;;584    {
;;;585        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;586        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;587    
;;;588        I2C1_StoreReg[0] = I2C1->IC_CON;
;;;589        I2C1_StoreReg[1] = I2C1->IC_TAR;
;;;590        I2C1_StoreReg[2] = I2C1->IC_SAR;
;;;591        I2C1_StoreReg[3] = I2C1->IC_HS_MADDR;
;;;592    
;;;593        I2C1_StoreReg[4] = I2C1->IC_SS_SCL_HCNT;
;;;594        I2C1_StoreReg[5] = I2C1->IC_SS_SCL_LCNT;
;;;595        I2C1_StoreReg[6] = I2C1->IC_FS_SCL_HCNT;
;;;596        I2C1_StoreReg[7] = I2C1->IC_FS_SCL_LCNT;
;;;597        I2C1_StoreReg[8] = I2C1->IC_HS_SCL_HCNT;
;;;598        I2C1_StoreReg[9] = I2C1->IC_HS_SCL_LCNT;
;;;599    
;;;600        I2C1_StoreReg[10] = I2C1->IC_INTR_MASK;
;;;601        I2C1_StoreReg[11] = I2C1->IC_RX_TL;
;;;602        I2C1_StoreReg[12] = I2C1->IC_TX_TL;
;;;603        I2C1_StoreReg[13] = I2C1->IC_ENABLE;
;;;604        I2C1_StoreReg[14] = I2C1->IC_SDA_HOLD;
;;;605        I2C1_StoreReg[15] = I2C1->IC_SLV_DATA_NACK_ONLY;
;;;606        I2C1_StoreReg[16] = I2C1->IC_DMA_CR;
;;;607        I2C1_StoreReg[17] = I2C1->IC_DMA_TDLR;
;;;608        I2C1_StoreReg[18] = I2C1->IC_DMA_RDLR;
;;;609    
;;;610        I2C1_StoreReg[19] = I2C1->IC_SDA_SETUP;
;;;611    }
;;;612    
;;;613    /**
;;;614      * @brief  I2C1 exit dlps callback function(Resume I2C1 register values when system exit DLPS)
;;;615      * @param  None
;;;616      * @retval None
;;;617      */
;;;618    DATA_RAM_FUNCTION __STATIC_INLINE void I2C1_DLPS_Exit(void)
;;;619    {
;;;620        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;621        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;622    
;;;623        I2C1->IC_CON = I2C1_StoreReg[0];
;;;624        I2C1->IC_TAR = I2C1_StoreReg[1];
;;;625        I2C1->IC_SAR = I2C1_StoreReg[2];
;;;626        I2C0->IC_HS_MADDR = I2C1_StoreReg[3];
;;;627    
;;;628        I2C1->IC_SS_SCL_HCNT = I2C1_StoreReg[4];
;;;629        I2C1->IC_SS_SCL_LCNT = I2C1_StoreReg[5];
;;;630        I2C1->IC_FS_SCL_HCNT = I2C1_StoreReg[6];
;;;631        I2C1->IC_FS_SCL_LCNT = I2C1_StoreReg[7];
;;;632        I2C1->IC_HS_SCL_HCNT = I2C1_StoreReg[8];
;;;633        I2C1->IC_HS_SCL_LCNT = I2C1_StoreReg[9];
;;;634    
;;;635        I2C1->IC_INTR_MASK = I2C1_StoreReg[10];
;;;636        I2C1->IC_RX_TL = I2C1_StoreReg[11];
;;;637        I2C1->IC_TX_TL = I2C1_StoreReg[12];
;;;638        I2C1->IC_SDA_HOLD = I2C1_StoreReg[14];
;;;639        I2C1->IC_SLV_DATA_NACK_ONLY = I2C1_StoreReg[15];
;;;640        I2C1->IC_DMA_CR = I2C1_StoreReg[16];
;;;641        I2C1->IC_DMA_TDLR = I2C1_StoreReg[17];
;;;642        I2C1->IC_DMA_RDLR = I2C1_StoreReg[18];
;;;643        I2C1->IC_SDA_SETUP = I2C1_StoreReg[19];
;;;644    
;;;645        I2C1->IC_ENABLE = I2C1_StoreReg[13];
;;;646    }
;;;647    #endif
;;;648    
;;;649    /********************************************** ********************************************************/
;;;650    /**************************************** [Timer & PWM DLPS] *******************************************/
;;;651    /*******************************************************************************************************/
;;;652    /*******************************************************************************************************/
;;;653    #if USE_TIM_DLPS
;;;654    #include "rtl876x_tim.h"
;;;655    __STATIC_INLINE void TIM_DLPS_Enter(void);
;;;656    __STATIC_INLINE void TIM_DLPS_Exit(void);
;;;657    
;;;658    uint32_t TIM_StoreReg[26];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;659    
;;;660    /* PWM, use with timer */
;;;661    uint32_t PWM0_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;662    
;;;663    uint32_t PWM1_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;664    
;;;665    /**
;;;666      * @brief  TIMER enter dlps callback function(Save TIMER register values when system enter DLPS)
;;;667      * @param  None
;;;668      * @retval None
;;;669      */
;;;670    __STATIC_INLINE void TIM_DLPS_Enter(void)
;;;671    {
;;;672        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;673        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;674    
;;;675        TIM_StoreReg[0] = TIM0->LoadCount;
;;;676        TIM_StoreReg[1] = TIM0->ControlReg;
;;;677        TIM_StoreReg[2] = TIMER0_LOAD_COUNT2;
;;;678    
;;;679        TIM_StoreReg[3] = TIM1->LoadCount;
;;;680        TIM_StoreReg[4] = TIM1->ControlReg;
;;;681        TIM_StoreReg[5] = TIMER1_LOAD_COUNT2;
;;;682    
;;;683        TIM_StoreReg[6] = TIM2->LoadCount;
;;;684        TIM_StoreReg[7] = TIM2->ControlReg;
;;;685        TIM_StoreReg[8] = TIMER2_LOAD_COUNT2;
;;;686    
;;;687        TIM_StoreReg[9] = TIM3->LoadCount;
;;;688        TIM_StoreReg[10] = TIM3->ControlReg;
;;;689        TIM_StoreReg[11] = TIMER3_LOAD_COUNT2;
;;;690    
;;;691        TIM_StoreReg[12] = TIM4->LoadCount;
;;;692        TIM_StoreReg[13] = TIM4->ControlReg;
;;;693        TIM_StoreReg[14] = TIMER4_LOAD_COUNT2;
;;;694    
;;;695        TIM_StoreReg[15] = TIM5->LoadCount;
;;;696        TIM_StoreReg[16] = TIM5->ControlReg;
;;;697        TIM_StoreReg[17] = TIMER5_LOAD_COUNT2;
;;;698    
;;;699        TIM_StoreReg[18] = TIM6->LoadCount;
;;;700        TIM_StoreReg[19] = TIM6->ControlReg;
;;;701        TIM_StoreReg[20] = TIMER6_LOAD_COUNT2;
;;;702    
;;;703        TIM_StoreReg[21] = TIM7->LoadCount;
;;;704        TIM_StoreReg[22] = TIM7->ControlReg;
;;;705        TIM_StoreReg[23] = TIMER7_LOAD_COUNT2;
;;;706    
;;;707        TIM_StoreReg[24] = *((volatile uint32_t *)0x4000035CUL);
;;;708        TIM_StoreReg[25] = *((volatile uint32_t *)0x40000360UL);
;;;709    
;;;710        PWM0_StoreReg = TIMER_PWM0_CR;
;;;711    
;;;712        PWM1_StoreReg = TIMER_PWM1_CR;
;;;713    }
;;;714    
;;;715    /**
;;;716      * @brief  TIMER exit dlps callback function(Resume TIMER register values when system exit DLPS)
;;;717      * @param  None
;;;718      * @retval None
;;;719      */
;;;720    DATA_RAM_FUNCTION __STATIC_INLINE void TIM_DLPS_Exit(void)
;;;721    {
;;;722        /* Enable timer IP clock and function */
;;;723        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;724        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;725    
;;;726        *((volatile uint32_t *)0x4000035CUL) = TIM_StoreReg[24];
;;;727        *((volatile uint32_t *)0x40000360UL) = TIM_StoreReg[25];
;;;728    
;;;729        TIM0->LoadCount = TIM_StoreReg[0];
;;;730        TIM0->ControlReg = TIM_StoreReg[1];
;;;731        TIMER0_LOAD_COUNT2 = TIM_StoreReg[2];
;;;732    
;;;733        TIM1->LoadCount = TIM_StoreReg[3];
;;;734        TIM1->ControlReg = TIM_StoreReg[4];
;;;735        TIMER1_LOAD_COUNT2 = TIM_StoreReg[5];
;;;736    
;;;737        TIM2->LoadCount = TIM_StoreReg[6];
;;;738        TIM2->ControlReg = TIM_StoreReg[7];
;;;739        TIMER2_LOAD_COUNT2 = TIM_StoreReg[8];
;;;740    
;;;741        TIM3->LoadCount = TIM_StoreReg[9];
;;;742        TIM3->ControlReg = TIM_StoreReg[10];
;;;743        TIMER3_LOAD_COUNT2 = TIM_StoreReg[11];
;;;744    
;;;745        TIM4->LoadCount = TIM_StoreReg[12];
;;;746        TIM4->ControlReg = TIM_StoreReg[13];
;;;747        TIMER4_LOAD_COUNT2 = TIM_StoreReg[14];
;;;748    
;;;749        TIM5->LoadCount = TIM_StoreReg[15];
;;;750        TIM5->ControlReg = TIM_StoreReg[16];
;;;751        TIMER5_LOAD_COUNT2 = TIM_StoreReg[17];
;;;752    
;;;753        TIM6->LoadCount = TIM_StoreReg[18];
;;;754        TIM6->ControlReg = TIM_StoreReg[19];
;;;755        TIMER6_LOAD_COUNT2 = TIM_StoreReg[20];
;;;756    
;;;757        TIM7->LoadCount = TIM_StoreReg[21];
;;;758        TIM7->ControlReg = TIM_StoreReg[22];
;;;759        TIMER7_LOAD_COUNT2 = TIM_StoreReg[23];
;;;760    
;;;761        TIMER_PWM0_CR = PWM0_StoreReg;
;;;762    
;;;763        TIMER_PWM1_CR = PWM1_StoreReg;
;;;764    }
;;;765    #endif  /* USE_TIM_DLPS */
;;;766    
;;;767    
;;;768    /********************************************** ********************************************************/
;;;769    /**************************************** [UART DLPS] **************************************************/
;;;770    /*******************************************************************************************************/
;;;771    /*******************************************************************************************************/
;;;772    #if USE_UART_DLPS
;;;773    #include "rtl876x_uart.h"
;;;774    
;;;775    __STATIC_INLINE void UART_DLPS_Enter(void);
;;;776    __STATIC_INLINE void UART_DLPS_Exit(void);
;;;777    
;;;778    uint32_t UART_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;779    
;;;780    /**
;;;781      * @brief  UART enter dlps callback function(Save UART register values when system enter DLPS)
;;;782      * @param  None
;;;783      * @retval None
;;;784      */
;;;785    __STATIC_INLINE void UART_DLPS_Enter(void)
;;;786    {
;;;787        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;788        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;789    
;;;790        //access DLH and DLL
;;;791        UART->LCR |= (1 << 7);
;;;792        UART_StoreReg[0] = UART->DLL;
;;;793        UART_StoreReg[1] = UART->DLH_INTCR;
;;;794        UART->LCR &= (~(1 << 7));
;;;795    
;;;796        //save other registers
;;;797        UART_StoreReg[2] = UART->DLH_INTCR;
;;;798        UART_StoreReg[4] = UART->LCR;
;;;799        UART_StoreReg[5] = UART->MCR;
;;;800        UART_StoreReg[6] = UART->SPR;
;;;801        UART_StoreReg[7] = UART->STSR;
;;;802        UART_StoreReg[8] = UART->RX_IDLE_INTTCR;
;;;803        UART_StoreReg[9] = UART->RXIDLE_INTCR;
;;;804        UART_StoreReg[10] = UART->MISCR;
;;;805    
;;;806        return;
;;;807    }
;;;808    
;;;809    /**
;;;810      * @brief  UART exit dlps callback function(Resume UART register values when system exit DLPS)
;;;811      * @param  None
;;;812      * @retval None
;;;813      */
;;;814    DATA_RAM_FUNCTION __STATIC_INLINE void UART_DLPS_Exit(void)
;;;815    {
;;;816        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;817        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;818    
;;;819        //access DLH and DLL
;;;820        UART->LCR |= (1 << 7);
;;;821        UART->DLL = UART_StoreReg[0];
;;;822        UART->DLH_INTCR =  UART_StoreReg[1];
;;;823        UART->LCR &= (~(1 << 7));
;;;824    
;;;825        //access other registers
;;;826        UART->INTID_FCR = (((UART_StoreReg[7] & BIT24) >> 21) | ((UART_StoreReg[7] & 0x7C000000) >> 18) |
;;;827                           (1));
;;;828        UART->LCR = UART_StoreReg[4];
;;;829        UART->MCR = UART_StoreReg[5];
;;;830        UART->SPR = UART_StoreReg[6];
;;;831        UART->STSR = UART_StoreReg[7];
;;;832        UART->DLH_INTCR = UART_StoreReg[2];
;;;833        UART->RX_IDLE_INTTCR = UART_StoreReg[8];
;;;834        UART->RXIDLE_INTCR = UART_StoreReg[9];
;;;835        UART->MISCR = UART_StoreReg[10];
;;;836    
;;;837        return;
;;;838    }
;;;839    #endif
;;;840    
;;;841    
;;;842    #if USE_UART1_DLPS
;;;843    
;;;844    __STATIC_INLINE void UART1_DLPS_Enter(void);
;;;845    __STATIC_INLINE void UART1_DLPS_Exit(void);
;;;846    
;;;847    uint32_t UART1_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;848    
;;;849    /**
;;;850      * @brief  UART1 enter dlps callback function(Save UART1 register values when system enter DLPS)
;;;851      * @param  None
;;;852      * @retval None
;;;853      */
;;;854    __STATIC_INLINE void UART1_DLPS_Enter(void)
;;;855    {
;;;856        //enable log uart peripheral & clock
;;;857        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;858        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;859    
;;;860        //access DLH and DLL
;;;861        UART1->LCR |= (1 << 7);
;;;862        UART1_StoreReg[0] = UART1->DLL;
;;;863        UART1_StoreReg[1] = UART1->DLH_INTCR;
;;;864        UART1->LCR &= (~(1 << 7));
;;;865    
;;;866        //save other registers
;;;867        UART1_StoreReg[2] = UART1->DLH_INTCR;
;;;868        UART1_StoreReg[4] = UART1->LCR;
;;;869        UART1_StoreReg[5] = UART1->MCR;
;;;870        UART1_StoreReg[6] = UART1->SPR;
;;;871        UART1_StoreReg[7] = UART1->STSR;
;;;872        UART1_StoreReg[8] = UART1->RX_IDLE_INTTCR;
;;;873        UART1_StoreReg[9] = UART1->RXIDLE_INTCR;
;;;874        UART1_StoreReg[10] = UART1->MISCR;
;;;875    
;;;876        return;
;;;877    }
;;;878    
;;;879    /**
;;;880      * @brief  UART1 exit dlps callback function(Resume UART1 register values when system exit DLPS)
;;;881      * @param  None
;;;882      * @retval None
;;;883      */
;;;884    DATA_RAM_FUNCTION __STATIC_INLINE void UART1_DLPS_Exit(void)
;;;885    {
;;;886        //enable log uart peripheral & clock
;;;887        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;888        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;889    
;;;890        //access DLH and DLL
;;;891        UART1->LCR |= (1 << 7);
;;;892        UART1->DLL = UART1_StoreReg[0];
;;;893        UART1->DLH_INTCR =  UART1_StoreReg[1];
;;;894        UART1->LCR &= (~(1 << 7));
;;;895    
;;;896        //access other registers
;;;897        UART1->INTID_FCR = (((UART1_StoreReg[7] & BIT24) >> 21) | ((UART1_StoreReg[7] & 0x7C000000)
;;;898                                                                   >> 18) | (1));
;;;899        UART1->LCR = UART1_StoreReg[4];
;;;900        UART1->MCR = UART1_StoreReg[5];
;;;901        UART1->SPR = UART1_StoreReg[6];
;;;902        UART1->STSR = UART1_StoreReg[7];
;;;903        UART1->DLH_INTCR = UART1_StoreReg[2];
;;;904        UART1->RX_IDLE_INTTCR = UART1_StoreReg[8];
;;;905        UART1->RXIDLE_INTCR = UART1_StoreReg[9];
;;;906        UART1->MISCR = UART1_StoreReg[10];
;;;907    
;;;908        return;
;;;909    }
;;;910    #endif
;;;911    
;;;912    #if USE_UART2_DLPS
;;;913    
;;;914    __STATIC_INLINE void UART2_DLPS_Enter(void);
;;;915    __STATIC_INLINE void UART2_DLPS_Exit(void);
;;;916    
;;;917    uint32_t UART2_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;918    
;;;919    /**
;;;920      * @brief  UART2 enter dlps callback function(Save UART2 register values when system enter DLPS)
;;;921      * @param  None
;;;922      * @retval None
;;;923      */
;;;924    __STATIC_INLINE void UART2_DLPS_Enter(void)
;;;925    {
;;;926        //enable log uart peripheral & clock
;;;927        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;928        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;929    
;;;930        //access DLH and DLL
;;;931        UART2->LCR |= (1 << 7);
;;;932        UART2_StoreReg[0] = UART2->DLL;
;;;933        UART2_StoreReg[1] = UART2->DLH_INTCR;
;;;934        UART2->LCR &= (~(1 << 7));
;;;935    
;;;936        //save other registers
;;;937        UART2_StoreReg[2] = UART2->DLH_INTCR;
;;;938        UART2_StoreReg[4] = UART2->LCR;
;;;939        UART2_StoreReg[5] = UART2->MCR;
;;;940        UART2_StoreReg[6] = UART2->SPR;
;;;941        UART2_StoreReg[7] = UART2->STSR;
;;;942        UART2_StoreReg[8] = UART2->RX_IDLE_INTTCR;
;;;943        UART2_StoreReg[9] = UART2->RXIDLE_INTCR;
;;;944        UART2_StoreReg[10] = UART2->MISCR;
;;;945    
;;;946        return;
;;;947    }
;;;948    
;;;949    /**
;;;950      * @brief  UART2 exit dlps callback function(Resume UART2 register values when system exit DLPS)
;;;951      * @param  None
;;;952      * @retval None
;;;953      */
;;;954    DATA_RAM_FUNCTION __STATIC_INLINE void UART2_DLPS_Exit(void)
;;;955    {
;;;956        //enable log uart peripheral & clock
;;;957        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;958        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;959    
;;;960        //access DLH and DLL
;;;961        UART2->LCR |= (1 << 7);
;;;962        UART2->DLL = UART2_StoreReg[0];
;;;963        UART2->DLH_INTCR =  UART2_StoreReg[1];
;;;964        UART2->LCR &= (~(1 << 7));
;;;965    
;;;966        //access other registers
;;;967        UART2->INTID_FCR = (((UART2_StoreReg[7] & BIT24) >> 21) | ((UART2_StoreReg[7] & 0x7C000000)
;;;968                                                                   >> 18) | (1));
;;;969        UART2->LCR = UART2_StoreReg[4];
;;;970        UART2->MCR = UART2_StoreReg[5];
;;;971        UART2->SPR = UART2_StoreReg[6];
;;;972        UART2->STSR = UART2_StoreReg[7];
;;;973        UART2->DLH_INTCR = UART2_StoreReg[2];
;;;974        UART2->RX_IDLE_INTTCR = UART2_StoreReg[8];
;;;975        UART2->RXIDLE_INTCR = UART2_StoreReg[9];
;;;976        UART2->MISCR = UART2_StoreReg[10];
;;;977    
;;;978        return;
;;;979    }
;;;980    #endif
;;;981    
;;;982    
;;;983    /********************************************** ********************************************************/
;;;984    /**************************************** [ADC DLPS] **************************************************/
;;;985    /*******************************************************************************************************/
;;;986    /*******************************************************************************************************/
;;;987    
;;;988    #if USE_ADC_DLPS
;;;989    __STATIC_INLINE void ADC_DLPS_Enter(void);
;;;990    __STATIC_INLINE void ADC_DLPS_Exit(void);
;;;991    
;;;992    uint32_t ADC_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;993    
;;;994    /**
;;;995      * @brief  ADC enter dlps callback function(Save ADC register values when system enter DLPS)
;;;996      * @param  None
;;;997      * @retval None
;;;998      */
;;;999    __STATIC_INLINE void ADC_DLPS_Enter(void)
;;;1000   {
;;;1001       /*Open 10M clock source*/
;;;1002       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1003       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1004   
;;;1005       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1006       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1007   
;;;1008       ADC_StoreReg[0] =  ADC->CR;          //0x04
;;;1009       ADC_StoreReg[1] =  ADC->SCHCR;       //0x08
;;;1010       ADC_StoreReg[2] =  ADC->INTCR;       //0x0C
;;;1011       ADC_StoreReg[3] =  ADC->SCHTAB0;     //0x10
;;;1012       ADC_StoreReg[4] =  ADC->SCHTAB1;     //0x14
;;;1013       ADC_StoreReg[5] =  ADC->SCHTAB2;     //0x18
;;;1014       ADC_StoreReg[6] =  ADC->SCHTAB3;     //0x1C
;;;1015       ADC_StoreReg[7] =  ADC->SCHTAB4;     //0x20
;;;1016       ADC_StoreReg[8] =  ADC->SCHTAB5;     //0x24
;;;1017       ADC_StoreReg[9] =  ADC->SCHTAB6;     //0x28
;;;1018       ADC_StoreReg[10] =  ADC->SCHTAB6;    //0x2C
;;;1019       ADC_StoreReg[11] =  ADC->PWRDLY;
;;;1020       ADC_StoreReg[12] =  ADC->DATCLK;
;;;1021       ADC_StoreReg[13] =  ADC->ANACTL;
;;;1022   
;;;1023       uint8_t reg_value = 0;
;;;1024       reg_value = btaon_fast_read_safe(0x110);
;;;1025       btaon_fast_write(0x110, reg_value & (~0x04));
;;;1026   
;;;1027       return;
;;;1028   }
;;;1029   
;;;1030   /**
;;;1031     * @brief  ADC exit dlps callback function(Resume ADC register values when system exit DLPS)
;;;1032     * @param  None
;;;1033     * @retval None
;;;1034     */
;;;1035   DATA_RAM_FUNCTION __STATIC_INLINE void ADC_DLPS_Exit(void)
;;;1036   {
;;;1037       /*Open 10M clock source*/
;;;1038       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1039       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1040   
;;;1041       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1042       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1043   
;;;1044   #if 0
;;;1045       //Todo
;;;1046       ADC->PWRDLY = ADC_StoreReg[10];
;;;1047       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1048       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1049       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1050       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1051       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1052       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1053       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1054       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1055       ADC->SCHCR = ADC_StoreReg[1];
;;;1056       ADC->INTCR = (ADC_StoreReg[2] & 0x1F);
;;;1057   #else
;;;1058       /*Disable all interrupt.*/
;;;1059       ADC->INTCR &= (~0x1f);
;;;1060   
;;;1061       /* Set power mode first */
;;;1062       ADC->PWRDLY = ADC_StoreReg[11];
;;;1063   
;;;1064       /* Disable schedule table */
;;;1065       ADC->SCHCR &= (~0xffff);
;;;1066   
;;;1067       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1068       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1069       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1070       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1071       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1072       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1073       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1074       ADC->SCHTAB7 = ADC_StoreReg[10];
;;;1075       ADC->SCHCR   = ADC_StoreReg[1];
;;;1076       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1077       ADC->DATCLK = ADC_StoreReg[12];
;;;1078       ADC->ANACTL = ADC_StoreReg[13];
;;;1079   
;;;1080       /*Clear ADC FIFO */
;;;1081       ADC->CR |= BIT26;
;;;1082       /* Clear all interrupt */
;;;1083       ADC->INTCR |= (0x1f << 8);
;;;1084   
;;;1085       /* Restore specify interrupt */
;;;1086       ADC->INTCR = ADC_StoreReg[2];
;;;1087   
;;;1088   #endif
;;;1089   
;;;1090       uint8_t reg_value = 0;
;;;1091       reg_value = btaon_fast_read_safe(0x110);
;;;1092       btaon_fast_write(0x110, reg_value | 0x04);
;;;1093   
;;;1094       return;
;;;1095   }
;;;1096   
;;;1097   #endif
;;;1098   
;;;1099   /********************************************** ********************************************************/
;;;1100   /**************************************** [IR DLPS] **************************************************/
;;;1101   /*******************************************************************************************************/
;;;1102   /*******************************************************************************************************/
;;;1103   
;;;1104   #if USE_IR_DLPS
;;;1105   __STATIC_INLINE void IR_DLPS_Enter(void);
;;;1106   __STATIC_INLINE void IR_DLPS_Exit(void);
;;;1107   
;;;1108   uint32_t IR_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1109   
;;;1110   /**
;;;1111     * @brief  IR enter dlps callback function(Save IR register values when system enter DLPS)
;;;1112     * @param  None
;;;1113     * @retval None
;;;1114     */
;;;1115   __STATIC_INLINE void IR_DLPS_Enter(void)
;;;1116   {
;;;1117       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1118       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1119   
;;;1120       IR_StoreReg[0] = IR->CLK_DIV;
;;;1121       IR_StoreReg[1] = IR->TX_CONFIG;
;;;1122       IR_StoreReg[2] = IR->RX_CONFIG;
;;;1123       IR_StoreReg[3] = IR->RX_CNT_INT_SEL;
;;;1124   
;;;1125   
;;;1126       return;
;;;1127   }
;;;1128   
;;;1129   /**
;;;1130     * @brief  IR exit dlps callback function(Resume IR register values when system exit DLPS)
;;;1131     * @param  None
;;;1132     * @retval None
;;;1133     */
;;;1134   DATA_RAM_FUNCTION __STATIC_INLINE void IR_DLPS_Exit(void)
;;;1135   {
;;;1136       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1137       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1138   
;;;1139       IR->CLK_DIV = IR_StoreReg[0];
;;;1140       if (IR_StoreReg[1] & BIT31)
;;;1141       {
;;;1142           /* RX MODE */
;;;1143           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1144           IR->RX_CONFIG  = IR_StoreReg[2];
;;;1145           IR->RX_CNT_INT_SEL  = IR_StoreReg[3];
;;;1146       }
;;;1147       else
;;;1148       {
;;;1149           /* TX MODE */
;;;1150           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1151           /* If IR TX mode is idle, must write one data firstly */
;;;1152           IR->TX_FIFO = 0;
;;;1153       }
;;;1154   
;;;1155       return;
;;;1156   }
;;;1157   
;;;1158   #endif
;;;1159   
;;;1160   /********************************************** ********************************************************/
;;;1161   /**************************************** [GDMA DLPS] **************************************************/
;;;1162   /*******************************************************************************************************/
;;;1163   /*******************************************************************************************************/
;;;1164   
;;;1165   #if USE_GDMA_DLPS
;;;1166   
;;;1167   __STATIC_INLINE void GDMA_DLPS_Enter(void);
;;;1168   __STATIC_INLINE void GDMA_DLPS_Exit(void);
;;;1169   uint32_t GDMA_StoreReg[7];         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1170   
;;;1171   #endif
;;;1172   
;;;1173   #if USE_GDMACHANNEL0_DLPS
;;;1174   uint32_t GDMAChannel0_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1175   #endif
;;;1176   
;;;1177   #if USE_GDMACHANNEL1_DLPS
;;;1178   uint32_t GDMAChannel1_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1179   #endif
;;;1180   
;;;1181   #if USE_GDMACHANNEL2_DLPS
;;;1182   uint32_t GDMAChannel2_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1183   #endif
;;;1184   
;;;1185   #if USE_GDMACHANNEL3_DLPS
;;;1186   uint32_t GDMAChannel3_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1187   #endif
;;;1188   
;;;1189   #if USE_GDMACHANNEL4_DLPS
;;;1190   uint32_t GDMAChannel4_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1191   #endif
;;;1192   
;;;1193   #if USE_GDMACHANNEL5_DLPS
;;;1194   uint32_t GDMAChannel5_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1195   #endif
;;;1196   
;;;1197   #if USE_GDMA_DLPS
;;;1198   /**
;;;1199     * @brief  GDMA enter dlps callback function(Save GDMA register values when system enter DLPS)
;;;1200     * @param  None
;;;1201     * @retval None
;;;1202     */
;;;1203   __STATIC_INLINE void GDMA_DLPS_Enter(void)
;;;1204   {
;;;1205       SYSBLKCTRL->u_210.SOC_FUNC_EN |= SYSBLK_GDMA0_EN_Msk;
;;;1206       PERIPH->PERI_CLK_CTRL |= (SYSBLK_ACTCK_GDMA0_EN_Msk | SYSBLK_SLPCK_GDMA0_EN_Msk);
;;;1207   
;;;1208       GDMA_StoreReg[0] = GDMA_BASE->DmaCfgReg;
;;;1209       GDMA_StoreReg[1] = GDMA_BASE->ChEnReg;
;;;1210       GDMA_StoreReg[2] = GDMA_BASE->MASK_TFR;
;;;1211       GDMA_StoreReg[3] = GDMA_BASE->MASK_BLOCK;
;;;1212       GDMA_StoreReg[4] = GDMA_BASE->MASK_SRC_TRAN;
;;;1213       GDMA_StoreReg[5] = GDMA_BASE->MASK_DST_TRAN;
;;;1214       GDMA_StoreReg[6] = GDMA_BASE->MASK_ERR;
;;;1215   
;;;1216   #if USE_GDMACHANNEL0_DLPS
;;;1217       GDMAChannel0_StoreReg[0] = GDMA_Channel0->SAR;
;;;1218       GDMAChannel0_StoreReg[1] = GDMA_Channel0->DAR;
;;;1219       GDMAChannel0_StoreReg[2] = GDMA_Channel0->CTL_LOW;
;;;1220       GDMAChannel0_StoreReg[3] = GDMA_Channel0->CTL_HIGH;
;;;1221       GDMAChannel0_StoreReg[4] = GDMA_Channel0->CFG_LOW;
;;;1222       GDMAChannel0_StoreReg[5] = GDMA_Channel0->CFG_HIGH;
;;;1223   #endif
;;;1224   #if USE_GDMACHANNEL1_DLPS
;;;1225       GDMAChannel1_StoreReg[0] = GDMA_Channel1->SAR;
;;;1226       GDMAChannel1_StoreReg[1] = GDMA_Channel1->DAR;
;;;1227       GDMAChannel1_StoreReg[2] = GDMA_Channel1->CTL_LOW;
;;;1228       GDMAChannel1_StoreReg[3] = GDMA_Channel1->CTL_HIGH;
;;;1229       GDMAChannel1_StoreReg[4] = GDMA_Channel1->CFG_LOW;
;;;1230       GDMAChannel1_StoreReg[5] = GDMA_Channel1->CFG_HIGH;
;;;1231   #endif
;;;1232   #if USE_GDMACHANNEL2_DLPS
;;;1233       GDMAChannel2_StoreReg[0] = GDMA_Channel2->SAR;
;;;1234       GDMAChannel2_StoreReg[1] = GDMA_Channel2->DAR;
;;;1235       GDMAChannel2_StoreReg[2] = GDMA_Channel2->CTL_LOW;
;;;1236       GDMAChannel2_StoreReg[3] = GDMA_Channel2->CTL_HIGH;
;;;1237       GDMAChannel2_StoreReg[4] = GDMA_Channel2->CFG_LOW;
;;;1238       GDMAChannel2_StoreReg[5] = GDMA_Channel2->CFG_HIGH;
;;;1239   #endif
;;;1240   #if USE_GDMACHANNEL3_DLPS
;;;1241       GDMAChannel3_StoreReg[0] = GDMA_Channel3->SAR;
;;;1242       GDMAChannel3_StoreReg[1] = GDMA_Channel3->DAR;
;;;1243       GDMAChannel3_StoreReg[2] = GDMA_Channel3->CTL_LOW;
;;;1244       GDMAChannel3_StoreReg[3] = GDMA_Channel3->CTL_HIGH;
;;;1245       GDMAChannel3_StoreReg[4] = GDMA_Channel3->CFG_LOW;
;;;1246       GDMAChannel3_StoreReg[5] = GDMA_Channel3->CFG_HIGH;
;;;1247   #endif
;;;1248   #if USE_GDMACHANNEL4_DLPS
;;;1249       GDMAChannel4_StoreReg[0] = GDMA_Channel4->SAR;
;;;1250       GDMAChannel4_StoreReg[1] = GDMA_Channel4->DAR;
;;;1251       GDMAChannel4_StoreReg[2] = GDMA_Channel4->CTL_LOW;
;;;1252       GDMAChannel4_StoreReg[3] = GDMA_Channel4->CTL_HIGH;
;;;1253       GDMAChannel4_StoreReg[4] = GDMA_Channel4->CFG_LOW;
;;;1254       GDMAChannel4_StoreReg[5] = GDMA_Channel4->CFG_HIGH;
;;;1255   #endif
;;;1256   #if USE_GDMACHANNEL5_DLPS
;;;1257       GDMAChannel5_StoreReg[0] = GDMA_Channel5->SAR;
;;;1258       GDMAChannel5_StoreReg[1] = GDMA_Channel5->DAR;
;;;1259       GDMAChannel5_StoreReg[2] = GDMA_Channel5->CTL_LOW;
;;;1260       GDMAChannel5_StoreReg[3] = GDMA_Channel5->CTL_HIGH;
;;;1261       GDMAChannel5_StoreReg[4] = GDMA_Channel5->CFG_LOW;
;;;1262       GDMAChannel5_StoreReg[5] = GDMA_Channel5->CFG_HIGH;
;;;1263   #endif
;;;1264   }
;;;1265   
;;;1266   /**
;;;1267     * @brief  GDMA exit dlps callback function(Resume GDMA register values when system exit DLPS)
;;;1268     * @param  None
;;;1269     * @retval None
;;;1270     */
;;;1271   DATA_RAM_FUNCTION __STATIC_INLINE void GDMA_DLPS_Exit(void)
;;;1272   {
;;;1273       SYSBLKCTRL->u_210.SOC_FUNC_EN |= SYSBLK_GDMA0_EN_Msk;
;;;1274       PERIPH->PERI_CLK_CTRL |= (SYSBLK_ACTCK_GDMA0_EN_Msk | SYSBLK_SLPCK_GDMA0_EN_Msk);
;;;1275   
;;;1276       /* Enable GDMA in DmaCfgReg*/
;;;1277       GDMA_BASE->DmaCfgReg = GDMA_StoreReg[0];
;;;1278   
;;;1279       /*----------clear pending all interrupts of GDMA channel-----------*/
;;;1280       GDMA_BASE->CLEAR_TFR = 0xff;
;;;1281       GDMA_BASE->CLEAR_BLOCK = 0xff;
;;;1282       GDMA_BASE->CLEAR_DST_TRAN = 0xff;
;;;1283       GDMA_BASE->CLEAR_SRC_TRAN = 0xff;
;;;1284       GDMA_BASE->CLEAR_ERR = 0xff;
;;;1285   
;;;1286       /*--------------------mask interrupt-------- -----------------*/
;;;1287       GDMA_BASE->MASK_TFR = (GDMA_StoreReg[2] | ((GDMA_StoreReg[2] & 0xff) << 8));
;;;1288       GDMA_BASE->MASK_BLOCK = (GDMA_StoreReg[3] | ((GDMA_StoreReg[3] & 0xff) << 8));
;;;1289       GDMA_BASE->MASK_SRC_TRAN = (GDMA_StoreReg[4] | ((GDMA_StoreReg[4] & 0xff) << 8));
;;;1290       GDMA_BASE->MASK_DST_TRAN = (GDMA_StoreReg[5] | ((GDMA_StoreReg[5] & 0xff) << 8));
;;;1291       GDMA_BASE->MASK_ERR = (GDMA_StoreReg[6] | ((GDMA_StoreReg[6] & 0xff) << 8));
;;;1292   
;;;1293   #if USE_GDMACHANNEL0_DLPS
;;;1294       GDMA_Channel0->SAR      = GDMAChannel0_StoreReg[0];
;;;1295       GDMA_Channel0->DAR      = GDMAChannel0_StoreReg[1];
;;;1296       GDMA_Channel0->CTL_LOW  = GDMAChannel0_StoreReg[2];
;;;1297       GDMA_Channel0->CTL_HIGH = GDMAChannel0_StoreReg[3];
;;;1298       GDMA_Channel0->CFG_LOW  = GDMAChannel0_StoreReg[4];
;;;1299       GDMA_Channel0->CFG_HIGH = GDMAChannel0_StoreReg[5];
;;;1300   #endif
;;;1301   #if USE_GDMACHANNEL1_DLPS
;;;1302       GDMA_Channel1->SAR      = GDMAChannel1_StoreReg[0];
;;;1303       GDMA_Channel1->DAR      = GDMAChannel1_StoreReg[1];
;;;1304       GDMA_Channel1->CTL_LOW  = GDMAChannel1_StoreReg[2];
;;;1305       GDMA_Channel1->CTL_HIGH = GDMAChannel1_StoreReg[3];
;;;1306       GDMA_Channel1->CFG_LOW  = GDMAChannel1_StoreReg[4];
;;;1307       GDMA_Channel1->CFG_HIGH = GDMAChannel1_StoreReg[5];
;;;1308   #endif
;;;1309   #if USE_GDMACHANNEL2_DLPS
;;;1310       GDMA_Channel2->SAR      = GDMAChannel2_StoreReg[0];
;;;1311       GDMA_Channel2->DAR      = GDMAChannel2_StoreReg[1];
;;;1312       GDMA_Channel2->CTL_LOW  = GDMAChannel2_StoreReg[2];
;;;1313       GDMA_Channel2->CTL_HIGH = GDMAChannel2_StoreReg[3];
;;;1314       GDMA_Channel2->CFG_LOW  = GDMAChannel2_StoreReg[4];
;;;1315       GDMA_Channel2->CFG_HIGH = GDMAChannel2_StoreReg[5];
;;;1316   #endif
;;;1317   #if USE_GDMACHANNEL3_DLPS
;;;1318       GDMA_Channel3->SAR      = GDMAChannel3_StoreReg[0];
;;;1319       GDMA_Channel3->DAR      = GDMAChannel3_StoreReg[1];
;;;1320       GDMA_Channel3->CTL_LOW  = GDMAChannel3_StoreReg[2];
;;;1321       GDMA_Channel3->CTL_HIGH = GDMAChannel3_StoreReg[3];
;;;1322       GDMA_Channel3->CFG_LOW  = GDMAChannel3_StoreReg[4];
;;;1323       GDMA_Channel3->CFG_HIGH = GDMAChannel3_StoreReg[5];
;;;1324   #endif
;;;1325   #if USE_GDMACHANNEL4_DLPS
;;;1326       GDMA_Channel4->SAR      = GDMAChannel4_StoreReg[0];
;;;1327       GDMA_Channel4->DAR      = GDMAChannel4_StoreReg[1];
;;;1328       GDMA_Channel4->CTL_LOW  = GDMAChannel4_StoreReg[2];
;;;1329       GDMA_Channel4->CTL_HIGH = GDMAChannel4_StoreReg[3];
;;;1330       GDMA_Channel4->CFG_LOW  = GDMAChannel4_StoreReg[4];
;;;1331       GDMA_Channel4->CFG_HIGH = GDMAChannel4_StoreReg[5];
;;;1332   #endif
;;;1333   #if USE_GDMACHANNEL5_DLPS
;;;1334       GDMA_Channel5->SAR      = GDMAChannel5_StoreReg[0];
;;;1335       GDMA_Channel5->DAR      = GDMAChannel5_StoreReg[1];
;;;1336       GDMA_Channel5->CTL_LOW  = GDMAChannel5_StoreReg[2];
;;;1337       GDMA_Channel5->CTL_HIGH = GDMAChannel5_StoreReg[3];
;;;1338       GDMA_Channel5->CFG_LOW  = GDMAChannel5_StoreReg[4];
;;;1339       GDMA_Channel5->CFG_HIGH = GDMAChannel5_StoreReg[5];
;;;1340   #endif
;;;1341   
;;;1342       /*----------clear pending all interrupts of GDMA channel before enable channel-----------*/
;;;1343       GDMA_BASE->CLEAR_TFR = 0x3f;
;;;1344       GDMA_BASE->CLEAR_BLOCK = 0x3f;
;;;1345       GDMA_BASE->CLEAR_DST_TRAN = 0x3f;
;;;1346       GDMA_BASE->CLEAR_SRC_TRAN = 0x3f;
;;;1347       GDMA_BASE->CLEAR_ERR = 0x3f;
;;;1348   
;;;1349       /* Enable the selected DMA Channelx */
;;;1350   //    GDMA_BASE->ChEnReg = GDMA_StoreReg[1];
;;;1351   }
;;;1352   #endif
;;;1353   
;;;1354   /********************************************** ********************************************************/
;;;1355   /**************************************** [LCD DLPS] ************************************************/
;;;1356   /*******************************************************************************************************/
;;;1357   /*******************************************************************************************************/
;;;1358   #if USE_LCD_DLPS
;;;1359   
;;;1360   uint32_t LCD_StoreReg[5];
;;;1361   
;;;1362   /**
;;;1363     * @brief  LCD enter dlps callback function(Save LCD register values when system enter DLPS)
;;;1364     * @param  None
;;;1365     * @retval None
;;;1366     */
;;;1367   __STATIC_INLINE void LCD_DLPS_Enter(void)
;;;1368   {
;;;1369       /* Enable LCD 8080 interface controller function */
;;;1370       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1371       /* Enable LCD 8080 interface controller clock */
;;;1372       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1373   
;;;1374       LCD_StoreReg[0] = *((volatile uint32_t *)0x400002A8UL) & (0x03 << 28);
;;;1375       LCD_StoreReg[1] = LCD->IMR;
;;;1376       LCD_StoreReg[2] = LCD->CTRL0;
;;;1377       LCD_StoreReg[3] = LCD->CTRL1;
;;;1378       LCD_StoreReg[4] = LCD->CFG;
;;;1379   
;;;1380   }
;;;1381   
;;;1382   /**
;;;1383     * @brief  LCD exit dlps callback function(Resume LCD register values when system exit DLPS)
;;;1384     * @param  None
;;;1385     * @retval None
;;;1386     */
;;;1387   DATA_RAM_FUNCTION __STATIC_INLINE void LCD_DLPS_Exit(void)
;;;1388   {
;;;1389       /* Enable LCD 8080 interface controller function */
;;;1390       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1391       /* Enable LCD 8080 interface controller clock */
;;;1392       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1393   
;;;1394       /* Restore Dedicated SDIO pin option */
;;;1395       *((volatile uint32_t *)0x400002A8UL) &= ~(0x03 << 28);
;;;1396       *((volatile uint32_t *)0x400002A8UL) |= LCD_StoreReg[0];
;;;1397   
;;;1398       /* Initialize LCD */
;;;1399   
;;;1400       LCD->IMR    = LCD_StoreReg[1];
;;;1401       LCD->CTRL1  = LCD_StoreReg[3];
;;;1402       LCD->CFG    = LCD_StoreReg[4];
;;;1403       LCD->CTRL0  = LCD_StoreReg[2];
;;;1404   }
;;;1405   #endif
;;;1406   
;;;1407   /********************************************** ********************************************************/
;;;1408   /**************************************** [I2S0 DLPS] **************************************************/
;;;1409   /*******************************************************************************************************/
;;;1410   /*******************************************************************************************************/
;;;1411   #if USE_I2S0_DLPS
;;;1412   
;;;1413   uint32_t I2S0_StoreReg[4];
;;;1414   
;;;1415   /**
;;;1416     * @brief  I2S0 enter dlps callback function(Save I2S0 register values when system enter DLPS)
;;;1417     * @param  None
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void I2S0_DLPS_Enter(void)
;;;1421   {
;;;1422       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1423   
;;;1424       I2S0_StoreReg[0] = I2S0->BCLK_DIV;
;;;1425       I2S0_StoreReg[1] = I2S0->CTRL0;
;;;1426       I2S0_StoreReg[2] = I2S0->CTRL1;
;;;1427       I2S0_StoreReg[3] = I2S0->DMA_TRDLR;
;;;1428   }
;;;1429   
;;;1430   /**
;;;1431     * @brief  I2S0 exit dlps callback function(Resume I2S0 register values when system exit DLPS)
;;;1432     * @param  None
;;;1433     * @retval None
;;;1434     */
;;;1435   DATA_RAM_FUNCTION __STATIC_INLINE void I2S0_DLPS_Exit(void)
;;;1436   {
;;;1437       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1438   
;;;1439       /* Reset I2S0 module */
;;;1440       I2S0->CTRL0 |= 1 << 0;
;;;1441       I2S0->CTRL0 &= ~(1 << 0);
;;;1442   
;;;1443       /* Initialize I2S0 */
;;;1444       I2S0->BCLK_DIV  = I2S0_StoreReg[0];
;;;1445       I2S0->CTRL1     = I2S0_StoreReg[2];
;;;1446       I2S0->DMA_TRDLR = I2S0_StoreReg[3];
;;;1447       I2S0->CTRL0     = I2S0_StoreReg[1];
;;;1448   }
;;;1449   #endif
;;;1450   
;;;1451   /********************************************** ********************************************************/
;;;1452   /**************************************** [I2S1 DLPS] **************************************************/
;;;1453   /*******************************************************************************************************/
;;;1454   /*******************************************************************************************************/
;;;1455   #if USE_I2S1_DLPS
;;;1456   
;;;1457   uint32_t I2S1_StoreReg[4];
;;;1458   
;;;1459   /**
;;;1460     * @brief  I2S1 enter dlps callback function(Save I2S1 register values when system enter DLPS)
;;;1461     * @param  None
;;;1462     * @retval None
;;;1463     */
;;;1464   __STATIC_INLINE void I2S1_DLPS_Enter(void)
;;;1465   {
;;;1466       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1467   
;;;1468       I2S1_StoreReg[0] = I2S1->BCLK_DIV;
;;;1469       I2S1_StoreReg[1] = I2S1->CTRL0;
;;;1470       I2S1_StoreReg[2] = I2S1->CTRL1;
;;;1471       I2S1_StoreReg[3] = I2S1->DMA_TRDLR;
;;;1472   }
;;;1473   
;;;1474   /**
;;;1475     * @brief  I2S1 exit dlps callback function(Resume I2S1 register values when system exit DLPS)
;;;1476     * @param  None
;;;1477     * @retval None
;;;1478     */
;;;1479   DATA_RAM_FUNCTION __STATIC_INLINE void I2S1_DLPS_Exit(void)
;;;1480   {
;;;1481       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1482   
;;;1483       /* Reset I2S1 module */
;;;1484       I2S1->CTRL0 |= 1 << 0;
;;;1485       I2S1->CTRL0 &= ~(1 << 0);
;;;1486   
;;;1487       /* Initialize I2S1 */
;;;1488       I2S1->BCLK_DIV  = I2S1_StoreReg[0];
;;;1489       I2S1->CTRL1     = I2S1_StoreReg[2];
;;;1490       I2S1->DMA_TRDLR = I2S1_StoreReg[3];
;;;1491       I2S1->CTRL0     = I2S1_StoreReg[1];
;;;1492   }
;;;1493   #endif
;;;1494   
;;;1495   /********************************************** ********************************************************/
;;;1496   /**************************************** [CODEC DLPS] ************************************************/
;;;1497   /*******************************************************************************************************/
;;;1498   /*******************************************************************************************************/
;;;1499   #if USE_CODEC_DLPS
;;;1500   
;;;1501   uint32_t CODEC_StoreReg[7];
;;;1502   
;;;1503   /**
;;;1504     * @brief  CODEC enter dlps callback function(Save CODEC register values when system enter DLPS)
;;;1505     * @param  None
;;;1506     * @retval None
;;;1507     */
;;;1508   __STATIC_INLINE void CODEC_DLPS_Enter(void)
;;;1509   {
;;;1510       /* Enable codec function and clock */
;;;1511       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1512   
;;;1513       CODEC_StoreReg[0] = CODEC->CR0;
;;;1514       CODEC_StoreReg[1] = CODEC->CR1;
;;;1515       CODEC_StoreReg[2] = CODEC->CR2;
;;;1516       CODEC_StoreReg[3] = CODEC->CLK_CTRL;
;;;1517       CODEC_StoreReg[4] = CODEC->I2S_CTRL;
;;;1518       CODEC_StoreReg[5] = CODEC->ADC_CTRL;
;;;1519       CODEC_StoreReg[6] = CODEC->DAC_CTRL;
;;;1520   }
;;;1521   
;;;1522   /**
;;;1523     * @brief  CODEC exit dlps callback function(Resume CODEC register values when system exit DLPS)
;;;1524     * @param  None
;;;1525     * @retval None
;;;1526     */
;;;1527   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_DLPS_Exit(void)
;;;1528   {
;;;1529       /* Enable codec function and clock */
;;;1530       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1531   
;;;1532       /* Initialize CODEC */
;;;1533       if ((CODEC_StoreReg[3] & 0x900) == 0x900)
;;;1534       {
;;;1535           /* Configure AMIC parameters */
;;;1536           CODEC->CR0 = CODEC_StoreReg[0];
;;;1537           CODEC->CR1 = CODEC_StoreReg[1];
;;;1538           CODEC->CR2 = CODEC_StoreReg[2];
;;;1539       }
;;;1540   
;;;1541       /*  Reset audio digital IP */
;;;1542       CODEC->AUDIO_CTRL = 0;
;;;1543       CODEC->AUDIO_CTRL = 1;
;;;1544   
;;;1545       CODEC->CLK_CTRL = CODEC_StoreReg[3];
;;;1546       CODEC->I2S_CTRL = CODEC_StoreReg[4];
;;;1547       CODEC->ADC_CTRL = CODEC_StoreReg[5];
;;;1548       CODEC->DAC_CTRL = CODEC_StoreReg[6];
;;;1549   }
;;;1550   #endif
;;;1551   
;;;1552   /********************************************** ********************************************************/
;;;1553   /**************************************** [CODEC_EQ1 DLPS] ************************************************/
;;;1554   /*******************************************************************************************************/
;;;1555   /*******************************************************************************************************/
;;;1556   #if USE_CODEC_EQ1_DLPS
;;;1557   
;;;1558   uint32_t CODEC_EQ1_StoreReg[5];
;;;1559   
;;;1560   /**
;;;1561     * @brief  CODEC_EQ1 enter dlps callback function(Save CODEC_EQ1 register values when system enter DLPS)
;;;1562     * @param  None
;;;1563     * @retval None
;;;1564     */
;;;1565   __STATIC_INLINE void CODEC_EQ1_DLPS_Enter(void)
;;;1566   {
;;;1567       /* Enable codec function and clock */
;;;1568       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1569   
;;;1570       CODEC_EQ1_StoreReg[0] = CODEC_EQ1->EQ_H0;
;;;1571       CODEC_EQ1_StoreReg[1] = CODEC_EQ1->EQ_B1;
;;;1572       CODEC_EQ1_StoreReg[2] = CODEC_EQ1->EQ_B2;
;;;1573       CODEC_EQ1_StoreReg[3] = CODEC_EQ1->EQ_A1;
;;;1574       CODEC_EQ1_StoreReg[4] = CODEC_EQ1->EQ_A2;
;;;1575   }
;;;1576   
;;;1577   /**
;;;1578     * @brief  CODEC_EQ1 exit dlps callback function(Resume CODEC_EQ1 register values when system exit DLPS)
;;;1579     * @param  None
;;;1580     * @retval None
;;;1581     */
;;;1582   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ1_DLPS_Exit(void)
;;;1583   {
;;;1584       /* Enable codec function and clock */
;;;1585       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1586   
;;;1587       CODEC_EQ1->EQ_H0 = CODEC_EQ1_StoreReg[0];
;;;1588       CODEC_EQ1->EQ_B1 = CODEC_EQ1_StoreReg[1];
;;;1589       CODEC_EQ1->EQ_B2 = CODEC_EQ1_StoreReg[2];
;;;1590       CODEC_EQ1->EQ_A1 = CODEC_EQ1_StoreReg[3];
;;;1591       CODEC_EQ1->EQ_A2 = CODEC_EQ1_StoreReg[4];
;;;1592   }
;;;1593   #endif
;;;1594   
;;;1595   /********************************************** ********************************************************/
;;;1596   /**************************************** [CODEC_EQ2 DLPS] ************************************************/
;;;1597   /*******************************************************************************************************/
;;;1598   /*******************************************************************************************************/
;;;1599   #if USE_CODEC_EQ2_DLPS
;;;1600   
;;;1601   uint32_t CODEC_EQ2_StoreReg[5];
;;;1602   
;;;1603   /**
;;;1604     * @brief  CODEC_EQ2 enter dlps callback function(Save CODEC_EQ2 register values when system enter DLPS)
;;;1605     * @param  None
;;;1606     * @retval None
;;;1607     */
;;;1608   __STATIC_INLINE void CODEC_EQ2_DLPS_Enter(void)
;;;1609   {
;;;1610       /* Enable codec function and clock */
;;;1611       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1612   
;;;1613       CODEC_EQ2_StoreReg[0] = CODEC_EQ2->EQ_H0;
;;;1614       CODEC_EQ2_StoreReg[1] = CODEC_EQ2->EQ_B1;
;;;1615       CODEC_EQ2_StoreReg[2] = CODEC_EQ2->EQ_B2;
;;;1616       CODEC_EQ2_StoreReg[3] = CODEC_EQ2->EQ_A1;
;;;1617       CODEC_EQ2_StoreReg[4] = CODEC_EQ2->EQ_A2;
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  CODEC_EQ2 exit dlps callback function(Resume CODEC_EQ2 register values when system exit DLPS)
;;;1622     * @param  None
;;;1623     * @retval None
;;;1624     */
;;;1625   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ2_DLPS_Exit(void)
;;;1626   {
;;;1627       /* Enable codec function and clock */
;;;1628       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1629   
;;;1630       CODEC_EQ2->EQ_H0 = CODEC_EQ2_StoreReg[0];
;;;1631       CODEC_EQ2->EQ_B1 = CODEC_EQ2_StoreReg[1];
;;;1632       CODEC_EQ2->EQ_B2 = CODEC_EQ2_StoreReg[2];
;;;1633       CODEC_EQ2->EQ_A1 = CODEC_EQ2_StoreReg[3];
;;;1634       CODEC_EQ2->EQ_A2 = CODEC_EQ2_StoreReg[4];
;;;1635   }
;;;1636   #endif
;;;1637   
;;;1638   /********************************************** ********************************************************/
;;;1639   /**************************************** [CODEC_EQ3 DLPS] ************************************************/
;;;1640   /*******************************************************************************************************/
;;;1641   /*******************************************************************************************************/
;;;1642   #if USE_CODEC_EQ3_DLPS
;;;1643   
;;;1644   uint32_t CODEC_EQ3_StoreReg[5];
;;;1645   
;;;1646   /**
;;;1647     * @brief  CODEC_EQ3 enter dlps callback function(Save CODEC_EQ3 register values when system enter DLPS)
;;;1648     * @param  None
;;;1649     * @retval None
;;;1650     */
;;;1651   __STATIC_INLINE void CODEC_EQ3_DLPS_Enter(void)
;;;1652   {
;;;1653       /* Enable codec function and clock */
;;;1654       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1655   
;;;1656       CODEC_EQ3_StoreReg[0] = CODEC_EQ3->EQ_H0;
;;;1657       CODEC_EQ3_StoreReg[1] = CODEC_EQ3->EQ_B1;
;;;1658       CODEC_EQ3_StoreReg[2] = CODEC_EQ3->EQ_B2;
;;;1659       CODEC_EQ3_StoreReg[3] = CODEC_EQ3->EQ_A1;
;;;1660       CODEC_EQ3_StoreReg[4] = CODEC_EQ3->EQ_A2;
;;;1661   }
;;;1662   
;;;1663   /**
;;;1664     * @brief  CODEC_EQ3 exit dlps callback function(Resume CODEC_EQ3 register values when system exit DLPS)
;;;1665     * @param  None
;;;1666     * @retval None
;;;1667     */
;;;1668   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ3_DLPS_Exit(void)
;;;1669   {
;;;1670       /* Enable codec function and clock */
;;;1671       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1672   
;;;1673       CODEC_EQ3->EQ_H0 = CODEC_EQ3_StoreReg[0];
;;;1674       CODEC_EQ3->EQ_B1 = CODEC_EQ3_StoreReg[1];
;;;1675       CODEC_EQ3->EQ_B2 = CODEC_EQ3_StoreReg[2];
;;;1676       CODEC_EQ3->EQ_A1 = CODEC_EQ3_StoreReg[3];
;;;1677       CODEC_EQ3->EQ_A2 = CODEC_EQ3_StoreReg[4];
;;;1678   }
;;;1679   #endif
;;;1680   
;;;1681   /********************************************** ********************************************************/
;;;1682   /**************************************** [CODEC_EQ4 DLPS] ************************************************/
;;;1683   /*******************************************************************************************************/
;;;1684   /*******************************************************************************************************/
;;;1685   #if USE_CODEC_EQ4_DLPS
;;;1686   
;;;1687   uint32_t CODEC_EQ4_StoreReg[5];
;;;1688   
;;;1689   /**
;;;1690     * @brief  CODEC_EQ4 enter dlps callback function(Save CODEC_EQ4 register values when system enter DLPS)
;;;1691     * @param  None
;;;1692     * @retval None
;;;1693     */
;;;1694   __STATIC_INLINE void CODEC_EQ4_DLPS_Enter(void)
;;;1695   {
;;;1696       /* Enable codec function and clock */
;;;1697       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1698   
;;;1699       CODEC_EQ4_StoreReg[0] = CODEC_EQ4->EQ_H0;
;;;1700       CODEC_EQ4_StoreReg[1] = CODEC_EQ4->EQ_B1;
;;;1701       CODEC_EQ4_StoreReg[2] = CODEC_EQ4->EQ_B2;
;;;1702       CODEC_EQ4_StoreReg[3] = CODEC_EQ4->EQ_A1;
;;;1703       CODEC_EQ4_StoreReg[4] = CODEC_EQ4->EQ_A2;
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  CODEC_EQ4 exit dlps callback function(Resume CODEC_EQ4 register values when system exit DLPS)
;;;1708     * @param  None
;;;1709     * @retval None
;;;1710     */
;;;1711   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ4_DLPS_Exit(void)
;;;1712   {
;;;1713       /* Enable codec function and clock */
;;;1714       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1715   
;;;1716       CODEC_EQ4->EQ_H0 = CODEC_EQ4_StoreReg[0];
;;;1717       CODEC_EQ4->EQ_B1 = CODEC_EQ4_StoreReg[1];
;;;1718       CODEC_EQ4->EQ_B2 = CODEC_EQ4_StoreReg[2];
;;;1719       CODEC_EQ4->EQ_A1 = CODEC_EQ4_StoreReg[3];
;;;1720       CODEC_EQ4->EQ_A2 = CODEC_EQ4_StoreReg[4];
;;;1721   }
;;;1722   #endif
;;;1723   
;;;1724   /********************************************** ********************************************************/
;;;1725   /**************************************** [CODEC_EQ5 DLPS] ************************************************/
;;;1726   /*******************************************************************************************************/
;;;1727   /*******************************************************************************************************/
;;;1728   #if USE_CODEC_EQ5_DLPS
;;;1729   
;;;1730   uint32_t CODEC_EQ5_StoreReg[5];
;;;1731   
;;;1732   /**
;;;1733     * @brief  CODEC_EQ5 enter dlps callback function(Save CODEC_EQ5 register values when system enter DLPS)
;;;1734     * @param  None
;;;1735     * @retval None
;;;1736     */
;;;1737   __STATIC_INLINE void CODEC_EQ5_DLPS_Enter(void)
;;;1738   {
;;;1739       /* Enable codec function and clock */
;;;1740       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1741   
;;;1742       CODEC_EQ5_StoreReg[0] = CODEC_EQ5->EQ_H0;
;;;1743       CODEC_EQ5_StoreReg[1] = CODEC_EQ5->EQ_B1;
;;;1744       CODEC_EQ5_StoreReg[2] = CODEC_EQ5->EQ_B2;
;;;1745       CODEC_EQ5_StoreReg[3] = CODEC_EQ5->EQ_A1;
;;;1746       CODEC_EQ5_StoreReg[4] = CODEC_EQ5->EQ_A2;
;;;1747   }
;;;1748   
;;;1749   /**
;;;1750     * @brief  CODEC_EQ5 exit dlps callback function(Resume CODEC_EQ5 register values when system exit DLPS)
;;;1751     * @param  None
;;;1752     * @retval None
;;;1753     */
;;;1754   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ5_DLPS_Exit(void)
;;;1755   {
;;;1756       /* Enable codec function and clock */
;;;1757       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1758   
;;;1759       CODEC_EQ5->EQ_H0 = CODEC_EQ5_StoreReg[0];
;;;1760       CODEC_EQ5->EQ_B1 = CODEC_EQ5_StoreReg[1];
;;;1761       CODEC_EQ5->EQ_B2 = CODEC_EQ5_StoreReg[2];
;;;1762       CODEC_EQ5->EQ_A1 = CODEC_EQ5_StoreReg[3];
;;;1763       CODEC_EQ5->EQ_A2 = CODEC_EQ5_StoreReg[4];
;;;1764   }
;;;1765   #endif
;;;1766   
;;;1767   /**
;;;1768     * @brief  Set Log and SWD pins to SW mode.
;;;1769     * @param  void.
;;;1770     * @retval void.
;;;1771     */
;;;1772   __STATIC_INLINE void Log_SWD_DLPS_Enter(void)
;;;1773   {
;;;1774       if (OTP->SWD_ENABLE)
;;;1775       {
;;;1776           Pad_Config(P1_0, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1777           Pad_Config(P1_1, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1778       }
;;;1779   
;;;1780       Pad_Config(OTP->logPin, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1781   
;;;1782   }
;;;1783   
;;;1784   /**
;;;1785     * @brief  Set Log and SWD pins to PINMUX mode.
;;;1786     * @param  void.
;;;1787     * @retval void.
;;;1788     */
;;;1789   DATA_RAM_FUNCTION __STATIC_INLINE void Log_SWD_DLPS_Exit(void)
;;;1790   {
;;;1791       Pad_Config(OTP->logPin, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00207d5e:    2400        .$      MOVS     r4,#0
        0x00207d60:    f44f1500    O...    MOV      r5,#0x200000
        0x00207d64:    9400        ..      STR      r4,[sp,#0]
        0x00207d66:    9401        ..      STR      r4,[sp,#4]
        0x00207d68:    f8950398    ....    LDRB     r0,[r5,#0x398]
        0x00207d6c:    2201        ."      MOVS     r2,#1
        0x00207d6e:    f000003f    ..?.    AND      r0,r0,#0x3f
        0x00207d72:    4623        #F      MOV      r3,r4
        0x00207d74:    4611        .F      MOV      r1,r2
        0x00207d76:    f5057566    ..fu    ADD      r5,r5,#0x398
        0x00207d7a:    f609fb2f    ../.    BL       Pad_Config ; 0x113dc
;;;1792   
;;;1793       if (OTP->SWD_ENABLE)
        0x00207d7e:    f8150c64    ..d.    LDRB     r0,[r5,#-0x64]
        0x00207d82:    07c0        ..      LSLS     r0,r0,#31
        0x00207d84:    d00f        ..      BEQ      0x207da6 ; DLPS_IO_ExitDlpsCb + 102
;;;1794       {
;;;1795           Pad_Config(P1_0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00207d86:    2301        .#      MOVS     r3,#1
        0x00207d88:    9400        ..      STR      r4,[sp,#0]
        0x00207d8a:    461a        .F      MOV      r2,r3
        0x00207d8c:    4619        .F      MOV      r1,r3
        0x00207d8e:    2008        .       MOVS     r0,#8
        0x00207d90:    9401        ..      STR      r4,[sp,#4]
        0x00207d92:    f609fb23    ..#.    BL       Pad_Config ; 0x113dc
;;;1796           Pad_Config(P1_1, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00207d96:    2301        .#      MOVS     r3,#1
        0x00207d98:    9400        ..      STR      r4,[sp,#0]
        0x00207d9a:    461a        .F      MOV      r2,r3
        0x00207d9c:    4619        .F      MOV      r1,r3
        0x00207d9e:    2009        .       MOVS     r0,#9
        0x00207da0:    9401        ..      STR      r4,[sp,#4]
        0x00207da2:    f609fb1b    ....    BL       Pad_Config ; 0x113dc
;;;1797       }
;;;1798   }
;;;1799   
;;;1800   /********************************************** ********************************************************/
;;;1801   /*********************************** [USER Exit DLPS CALLBACK FUCN] *****************************************/
;;;1802   /*******************************************************************************************************/
;;;1803   /*******************************************************************************************************/
;;;1804   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;1805   
;;;1806   DLPS_IO_ExitDlpsCB User_IO_ExitDlpsCB = NULL;
;;;1807   
;;;1808   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1809   
;;;1810   /********************************************** ********************************************************/
;;;1811   /*********************************** [USER Enter DLPS CALLBACK FUCN] *****************************************/
;;;1812   /*******************************************************************************************************/
;;;1813   /*******************************************************************************************************/
;;;1814   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1815   
;;;1816   DLPS_IO_EnterDlpsCB User_IO_EnterDlpsCB = NULL;
;;;1817   
;;;1818   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1819   
;;;1820   /********************************************** ********************************************************/
;;;1821   /*********************************** [Enter & Exit DLPS CALLBACK FUNC] *********************************/
;;;1822   /*******************************************************************************************************/
;;;1823   /*******************************************************************************************************/
;;;1824   #if USE_IO_DRIVER_DLPS
;;;1825   
;;;1826   /**
;;;1827     * @brief  IO enter dlps callback function
;;;1828     * @param  None
;;;1829     * @retval None
;;;1830     */
;;;1831   void DLPS_IO_EnterDlpsCb(void)
;;;1832   {
;;;1833       /* low stack do it instead */
;;;1834   //    Pad_ClearAllWakeupINT();
;;;1835   
;;;1836   //    DBG_DIRECT("DLPS_IO_EnterDlpsCb");
;;;1837       NVIC_DisableIRQ(System_IRQn);
;;;1838       CPU_DLPS_Enter();
;;;1839   
;;;1840       Pinmux_DLPS_Enter();
;;;1841   
;;;1842   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1843       if (User_IO_EnterDlpsCB)
;;;1844       {
;;;1845           User_IO_EnterDlpsCB();
;;;1846       }
;;;1847   #endif
;;;1848   
;;;1849   #if USE_I2C0_DLPS
;;;1850       I2C0_DLPS_Enter();
;;;1851   #endif
;;;1852   
;;;1853   #if USE_I2C1_DLPS
;;;1854       I2C1_DLPS_Enter();
;;;1855   #endif
;;;1856   
;;;1857   #if USE_TIM_DLPS
;;;1858       TIM_DLPS_Enter();
;;;1859   #endif
;;;1860   
;;;1861   #if USE_QDECODER_DLPS
;;;1862       QuadDecoder_DLPS_Enter();
;;;1863   #endif
;;;1864   
;;;1865   #if USE_IR_DLPS
;;;1866       IR_DLPS_Enter();
;;;1867   #endif
;;;1868   
;;;1869   #if USE_UART_DLPS
;;;1870       UART_DLPS_Enter();
;;;1871   #endif
;;;1872   
;;;1873   #if USE_UART1_DLPS
;;;1874       UART1_DLPS_Enter();
;;;1875   #endif
;;;1876   
;;;1877   #if USE_UART2_DLPS
;;;1878       UART2_DLPS_Enter();
;;;1879   #endif
;;;1880   
;;;1881   #if USE_SPI0_DLPS
;;;1882       SPI0_DLPS_Enter();
;;;1883   #endif
;;;1884   
;;;1885   #if USE_SPI1_DLPS
;;;1886       SPI1_DLPS_Enter();
;;;1887   #endif
;;;1888   
;;;1889   #if USE_SPI2W_DLPS
;;;1890       SPI2W_DLPS_Enter();
;;;1891   #endif
;;;1892   
;;;1893   #if USE_KEYSCAN_DLPS
;;;1894       KeyScan_DLPS_Enter();
;;;1895   #endif
;;;1896   
;;;1897   #if USE_GPIO_DLPS
;;;1898       GPIO_DLPS_Enter();
;;;1899   #endif
;;;1900   
;;;1901   #if USE_ADC_DLPS
;;;1902       ADC_DLPS_Enter();
;;;1903   #endif
;;;1904   
;;;1905   #if USE_LCD_DLPS
;;;1906       LCD_DLPS_Enter();
;;;1907   #endif
;;;1908   
;;;1909   #if USE_I2S0_DLPS
;;;1910       I2S0_DLPS_Enter();
;;;1911   #endif
;;;1912   
;;;1913   #if USE_I2S1_DLPS
;;;1914       I2S1_DLPS_Enter();
;;;1915   #endif
;;;1916   
;;;1917   #if USE_CODEC_DLPS
;;;1918       CODEC_DLPS_Enter();
;;;1919   #endif
;;;1920   
;;;1921   #if USE_CODEC_EQ1_DLPS
;;;1922       CODEC_EQ1_DLPS_Enter();
;;;1923   #endif
;;;1924   
;;;1925   #if USE_CODEC_EQ2_DLPS
;;;1926       CODEC_EQ2_DLPS_Enter();
;;;1927   #endif
;;;1928   
;;;1929   #if USE_CODEC_EQ3_DLPS
;;;1930       CODEC_EQ3_DLPS_Enter();
;;;1931   #endif
;;;1932   
;;;1933   #if USE_CODEC_EQ4_DLPS
;;;1934       CODEC_EQ4_DLPS_Enter();
;;;1935   #endif
;;;1936   
;;;1937   #if USE_CODEC_EQ5_DLPS
;;;1938       CODEC_EQ5_DLPS_Enter();
;;;1939   #endif
;;;1940   
;;;1941   #if USE_GDMA_DLPS
;;;1942       GDMA_DLPS_Enter();
;;;1943   #endif
;;;1944   
;;;1945       Log_SWD_DLPS_Enter();
;;;1946   
;;;1947   }
;;;1948   #endif  /* USE_IO_DRIVER_DLPS */
;;;1949   
;;;1950   #if USE_IO_DRIVER_DLPS
;;;1951   /**
;;;1952     * @brief  IO exit dlps callback function.
;;;1953     * @param  None
;;;1954     * @retval None
;;;1955     */
;;;1956   DATA_RAM_FUNCTION void DLPS_IO_ExitDlpsCb(void)
;;;1957   {
;;;1958   
;;;1959   //    DBG_BUFFER(TYPE_BUMBLEBEE3, SUBTYPE_FORMAT, MODULE_DLPS, LEVEL_INFO,
;;;1960   //               "DLPS_IO_ExitDlpsCb",0);
;;;1961   
;;;1962       Pinmux_DLPS_Exit();
;;;1963   
;;;1964       Log_SWD_DLPS_Exit();
;;;1965   
;;;1966   #if USE_I2C0_DLPS
;;;1967       I2C0_DLPS_Exit();
;;;1968   #endif
;;;1969   
;;;1970   #if USE_I2C1_DLPS
;;;1971       I2C1_DLPS_Exit();
;;;1972   #endif
;;;1973   
;;;1974   #if USE_TIM_DLPS
;;;1975       TIM_DLPS_Exit();
;;;1976   #endif
;;;1977   
;;;1978   #if USE_QDECODER_DLPS
;;;1979       QuadDecoder_DLPS_Exit();
;;;1980   #endif
;;;1981   
;;;1982   #if USE_IR_DLPS
;;;1983       IR_DLPS_Exit();
;;;1984   #endif
;;;1985   
;;;1986   #if USE_UART_DLPS
;;;1987       UART_DLPS_Exit();
;;;1988   #endif
;;;1989   
;;;1990   #if USE_UART1_DLPS
;;;1991       UART1_DLPS_Exit();
;;;1992   #endif
;;;1993   
;;;1994   #if USE_UART2_DLPS
;;;1995       UART2_DLPS_Exit();
;;;1996   #endif
;;;1997   
;;;1998   #if USE_SPI0_DLPS
;;;1999       SPI0_DLPS_Exit();
;;;2000   #endif
;;;2001   
;;;2002   #if USE_SPI1_DLPS
;;;2003       SPI1_DLPS_Exit();
;;;2004   #endif
;;;2005   
;;;2006   #if USE_SPI2W_DLPS
;;;2007       SPI2W_DLPS_Exit();
;;;2008   #endif
;;;2009   
;;;2010   #if USE_KEYSCAN_DLPS
;;;2011       KeyScan_DLPS_Exit();
;;;2012   #endif
;;;2013   
;;;2014   #if USE_GPIO_DLPS
;;;2015       GPIO_DLPS_Exit();
        0x00207da6:    f000f832    ..2.    BL       GPIO_DLPS_Exit ; 0x207e0e
;;;2016   #endif
;;;2017   
;;;2018   #if USE_ADC_DLPS
;;;2019       ADC_DLPS_Exit();
;;;2020   #endif
;;;2021   
;;;2022   #if USE_LCD_DLPS
;;;2023       LCD_DLPS_Exit();
;;;2024   #endif
;;;2025   
;;;2026   #if USE_I2S0_DLPS
;;;2027       I2S0_DLPS_Exit();
;;;2028   #endif
;;;2029   
;;;2030   #if USE_I2S1_DLPS
;;;2031       I2S1_DLPS_Exit();
;;;2032   #endif
;;;2033   
;;;2034   #if USE_CODEC_DLPS
;;;2035       CODEC_DLPS_Exit();
;;;2036   #endif
;;;2037   
;;;2038   #if USE_CODEC_EQ1_DLPS
;;;2039       CODEC_EQ1_DLPS_Exit();
;;;2040   #endif
;;;2041   
;;;2042   #if USE_CODEC_EQ2_DLPS
;;;2043       CODEC_EQ2_DLPS_Exit();
;;;2044   #endif
;;;2045   
;;;2046   #if USE_CODEC_EQ3_DLPS
;;;2047       CODEC_EQ3_DLPS_Exit();
;;;2048   #endif
;;;2049   
;;;2050   #if USE_CODEC_EQ4_DLPS
;;;2051       CODEC_EQ4_DLPS_Exit();
;;;2052   #endif
;;;2053   
;;;2054   #if USE_CODEC_EQ5_DLPS
;;;2055       CODEC_EQ5_DLPS_Exit();
;;;2056   #endif
;;;2057   
;;;2058   #if USE_GDMA_DLPS
;;;2059       GDMA_DLPS_Exit();
;;;2060   #endif
;;;2061   
;;;2062   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;2063       if (User_IO_ExitDlpsCB)
        0x00207daa:    4d2d        -M      LDR      r5,[pc,#180] ; [0x207e60] = 0x20bc30
        0x00207dac:    3d90        .=      SUBS     r5,r5,#0x90
        0x00207dae:    6868        hh      LDR      r0,[r5,#4]
        0x00207db0:    b100        ..      CBZ      r0,0x207db4 ; DLPS_IO_ExitDlpsCb + 116
;;;2064       {
;;;2065           User_IO_ExitDlpsCB();
        0x00207db2:    4780        .G      BLX      r0
;;;2066       }
;;;2067   #endif
;;;2068   
;;;2069       NVIC_InitTypeDef nvic_init_struct;
;;;2070       nvic_init_struct.NVIC_IRQChannel         = System_IRQn;
;;;2071       nvic_init_struct.NVIC_IRQChannelCmd      = (FunctionalState)ENABLE;
        0x00207db4:    2001        .       MOVS     r0,#1
        0x00207db6:    f88d0010    ....    STRB     r0,[sp,#0x10]
;;;2072       nvic_init_struct.NVIC_IRQChannelPriority = 3;
        0x00207dba:    2003        .       MOVS     r0,#3
;;;2073       NVIC_Init(&nvic_init_struct); //Enable SYSTEM_ON Interrupt
        0x00207dbc:    9003        ..      STR      r0,[sp,#0xc]
        0x00207dbe:    f88d4008    ...@    STRB     r4,[sp,#8]
        0x00207dc2:    a802        ..      ADD      r0,sp,#8
        0x00207dc4:    f609fa7c    ..|.    BL       NVIC_Init ; 0x112c0
        0x00207dc8:    4c25        %L      LDR      r4,[pc,#148] ; [0x207e60] = 0x20bc30
        0x00207dca:    3c84        .<      SUBS     r4,r4,#0x84
        0x00207dcc:    6863        ch      LDR      r3,[r4,#4]
        0x00207dce:    b123        #.      CBZ      r3,0x207dda ; DLPS_IO_ExitDlpsCb + 154
        0x00207dd0:    2201        ."      MOVS     r2,#1
        0x00207dd2:    4924        $I      LDR      r1,[pc,#144] ; [0x207e64] = 0x88003d8
        0x00207dd4:    4824        $H      LDR      r0,[pc,#144] ; [0x207e68] = 0x21100401
        0x00207dd6:    f5fffe42    ..B.    BL       log_buffer ; 0x7a5e
        0x00207dda:    2003        .       MOVS     r0,#3
        0x00207ddc:    f10022e0    ..."    ADD      r2,r0,#0xe000e000
        0x00207de0:    f8141020    .. .    LDRB     r1,[r4,r0,LSL #2]
        0x00207de4:    f8821400    ....    STRB     r1,[r2,#0x400]
        0x00207de8:    1c40        @.      ADDS     r0,r0,#1
        0x00207dea:    2820         (      CMP      r0,#0x20
        0x00207dec:    d3f6        ..      BCC      0x207ddc ; DLPS_IO_ExitDlpsCb + 156
        0x00207dee:    491f        .I      LDR      r1,[pc,#124] ; [0x207e6c] = 0xe000ed08
        0x00207df0:    f8d40080    ....    LDR      r0,[r4,#0x80]
        0x00207df4:    6008        .`      STR      r0,[r1,#0]
        0x00207df6:    491e        .I      LDR      r1,[pc,#120] ; [0x207e70] = 0x40006000
        0x00207df8:    6828        (h      LDR      r0,[r5,#0]
        0x00207dfa:    60c8        .`      STR      r0,[r1,#0xc]
        0x00207dfc:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x00207e00:    6820         h      LDR      r0,[r4,#0]
        0x00207e02:    f8c10100    ....    STR      r0,[r1,#0x100]
        0x00207e06:    f206f339    ..9.    BL       debug_monitor_enable ; 0x80e47c
;;;2074   
;;;2075       CPU_DLPS_Exit();
;;;2076   }
        0x00207e0a:    b005        ..      ADD      sp,sp,#0x14
        0x00207e0c:    bd30        0.      POP      {r4,r5,pc}
    GPIO_DLPS_Exit
        0x00207e0e:    b510        ..      PUSH     {r4,lr}
;;; .\..\..\..\src\mcu\peripheral\rtl876x_io_dlps.c (177)
        0x00207e10:    f04f4280    O..B    MOV      r2,#0x40000000
        0x00207e14:    f8d2021c    ....    LDR      r0,[r2,#0x21c]
        0x00207e18:    f4407080    @..p    ORR      r0,r0,#0x100
        0x00207e1c:    f8c2021c    ....    STR      r0,[r2,#0x21c]
;;;178        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
        0x00207e20:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x00207e24:    f0407040    @.@p    ORR      r0,r0,#0x3000000
        0x00207e28:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;179    
;;;180        GPIO->DATADIR       = GPIO_StoreReg[1];
        0x00207e2c:    480c        .H      LDR      r0,[pc,#48] ; [0x207e60] = 0x20bc30
        0x00207e2e:    4911        .I      LDR      r1,[pc,#68] ; [0x207e74] = 0x40001000
        0x00207e30:    3028        (0      ADDS     r0,r0,#0x28
        0x00207e32:    6843        Ch      LDR      r3,[r0,#4]
        0x00207e34:    604b        K`      STR      r3,[r1,#4]
;;;181        GPIO->DATASRC       = GPIO_StoreReg[2];
        0x00207e36:    6884        .h      LDR      r4,[r0,#8]
        0x00207e38:    608c        .`      STR      r4,[r1,#8]
;;;182        GPIO->INTMASK       = GPIO_StoreReg[4];
        0x00207e3a:    6904        .i      LDR      r4,[r0,#0x10]
        0x00207e3c:    634c        Lc      STR      r4,[r1,#0x34]
;;;183        GPIO->INTTYPE       = GPIO_StoreReg[5];
        0x00207e3e:    6944        Di      LDR      r4,[r0,#0x14]
        0x00207e40:    638c        .c      STR      r4,[r1,#0x38]
;;;184        GPIO->INTPOLARITY   = GPIO_StoreReg[6];
        0x00207e42:    6984        .i      LDR      r4,[r0,#0x18]
        0x00207e44:    63cc        .c      STR      r4,[r1,#0x3c]
;;;185        GPIO->DEBOUNCE      = GPIO_StoreReg[7];
        0x00207e46:    69c4        .i      LDR      r4,[r0,#0x1c]
        0x00207e48:    648c        .d      STR      r4,[r1,#0x48]
;;;186        GPIO->DATAOUT       = GPIO_StoreReg[0];
        0x00207e4a:    6804        .h      LDR      r4,[r0,#0]
        0x00207e4c:    600c        .`      STR      r4,[r1,#0]
;;;187        GPIO->INTCLR        = ~(GPIO_StoreReg[1]);
        0x00207e4e:    43db        .C      MVNS     r3,r3
        0x00207e50:    64cb        .d      STR      r3,[r1,#0x4c]
;;;188        GPIO->INTEN         = GPIO_StoreReg[3];
        0x00207e52:    68c3        .h      LDR      r3,[r0,#0xc]
        0x00207e54:    630b        .c      STR      r3,[r1,#0x30]
;;;189        *(__IO uint32_t *)(0x40000344UL) = GPIO_StoreReg[8];
        0x00207e56:    6a00        .j      LDR      r0,[r0,#0x20]
        0x00207e58:    f8c20344    ..D.    STR      r0,[r2,#0x344]
;;;190    
;;;191        return;
;;;192    }
        0x00207e5c:    bd10        ..      POP      {r4,pc}
    $d
        0x00207e5e:    0000        ..      DCW    0
        0x00207e60:    0020bc30    0. .    DCD    2145328
        0x00207e64:    088003d8    ....    DCD    142607320
        0x00207e68:    21100401    ...!    DCD    554697729
        0x00207e6c:    e000ed08    ....    DCD    3758157064
        0x00207e70:    40006000    .`.@    DCD    1073766400
        0x00207e74:    40001000    ...@    DCD    1073745920
    $t
    .text
    $v0
    ADC_Handler
    BTMAC_Handler
    BusFault_Handler
    DebugMon_Handler
    Default_Handler
    GDMA0_Channel0_Handler
    GDMA0_Channel1_Handler
    GDMA0_Channel2_Handler
    GDMA0_Channel3_Handler
    GDMA0_Channel4_Handler
    GDMA0_Channel5_Handler
    GPIO0_Handler
    GPIO10_Handler
    GPIO11_Handler
    GPIO12_Handler
    GPIO13_Handler
    GPIO14_Handler
    GPIO15_Handler
    GPIO16_Handler
    GPIO17_Handler
    GPIO18_Handler
    GPIO19_Handler
    GPIO1_Handler
    GPIO21_Handler
    GPIO22_Handler
    GPIO23_Handler
    GPIO24_Handler
    GPIO25_Handler
    GPIO26_Handler
    GPIO27_Handler
    GPIO28_Handler
    GPIO29_Handler
    GPIO2_Handler
    GPIO30_Handler
    GPIO31_Handler
    GPIO3_Handler
    GPIO4_Handler
    GPIO5_Handler
    GPIO6_Handler
    GPIO7_Handler
    GPIO8_Handler
    GPIO9_Handler
    HardFault_Handler
    I2C0_Handler
    I2C1_Handler
    I2S0_RX_Handler
    I2S0_TX_Handler
    I2S1_RX_Handler
    I2S1_TX_Handler
    IR_Handler
    LCD_Handler
    LPCOMP_Handler
    MemManage_Handler
    NMI_Handler
    PTA_Mailbox_Handler
    PendSV_Handler
    Peripheral_Handler
    Qdecode_Handler
    RTC_Handler
    SPI0_Handler
    SPI1_Handler
    SPI2W_Handler
    SPI_Flash_Handler
    SVC_Handler
    SysTick_Handler
    Timer2_Handler
    Timer3_Handler
    Timer4_7_Handler
    Timer4_Handler
    Timer5_Handler
    Timer6_Handler
    Timer7_Handler
    UART0_Handler
    UART1_Handler
    UART2_Handler
    UsageFault_Handler
    WDG_Handler
;;; ..\\..\\..\\src\\mcu\\rtl876x\\arm\\startup_rtl8762c.s
;;;276                    LDR    R0, =0x20000000
        0x00207e78:    f04f5000    O..P    MOV      r0,#0x20000000
;;;277                    LDR    R1, =DEFAULT_HANDLER_TXT
        0x00207e7c:    4910        .I      LDR      r1,[pc,#64] ; [0x207ec0] = 0x207e8a
;;;278                    MRS    R2, IPSR
        0x00207e7e:    f3ef8205    ....    MRS      r2,IPSR
;;;279                    LDR    R3, =log_direct
        0x00207e82:    4b10        .K      LDR      r3,[pc,#64] ; [0x207ec4] = 0x79b1
;;;280                    BLX    R3
        0x00207e84:    4798        .G      BLX      r3
;;;281                    B      .
        0x00207e86:    e7fe        ..      B        0x207e86 ; ADC_Handler + 14
    __user_setup_stackheap
;;;282    
;;;283                    ENDP
;;;284    
;;;285    
;;;286    ; User Initial Stack
;;;287                    EXPORT  __user_setup_stackheap
;;;288    __user_setup_stackheap PROC
;;;289                    BX      LR
        0x00207e88:    4770        pG      BX       lr
    $d
    DEFAULT_HANDLER_TXT
        0x00207e8a:    7245        Er      DCW    29253
        0x00207e8c:    21726f72    ror!    DCD    561147762
        0x00207e90:    656c5020     Ple    DCD    1701597216
        0x00207e94:    20657361    ase     DCD    543519585
        0x00207e98:    6c706d69    impl    DCD    1819307369
        0x00207e9c:    6e656d65    emen    DCD    1852140901
        0x00207ea0:    6f792074    t yo    DCD    1870209140
        0x00207ea4:    49207275    ur I    DCD    1226863221
        0x00207ea8:    48205253    SR H    DCD    1210077779
        0x00207eac:    6c646e61    andl    DCD    1818521185
        0x00207eb0:    66207265    er f    DCD    1713402469
        0x00207eb4:    4920726f    or I    DCD    1226863215
        0x00207eb8:    25205152    RQ %    DCD    622874962
        0x00207ebc:    000a2164    d!..    DCD    663908
        0x00207ec0:    00207e8a    .~ .    DCD    2129546
        0x00207ec4:    000079b1    .y..    DCD    31153
    $t
    .text
    common_main
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c
;;;253    {
        0x00207ec8:    b510        ..      PUSH     {r4,lr}
;;;254    //add common system code here before enter user defined main function
;;;255        OTP->run_in_app = 1;
        0x00207eca:    f44f1000    O...    MOV      r0,#0x200000
        0x00207ece:    f890139b    ....    LDRB     r1,[r0,#0x39b]
        0x00207ed2:    f0410180    A...    ORR      r1,r1,#0x80
        0x00207ed6:    f880139b    ....    STRB     r1,[r0,#0x39b]
;;;256    
;;;257    #if (RUN_APP_IN_HCIMODE_ENABLE == 0)
;;;258        if (OTP->stack_en)
        0x00207eda:    f89002dc    ....    LDRB     r0,[r0,#0x2dc]
        0x00207ede:    07c1        ..      LSLS     r1,r0,#31
;;;259        {
;;;260            DBG_DIRECT("In SoC Mode");
        0x00207ee0:    f04f5004    O..P    MOV      r0,#0x21000000
        0x00207ee4:    d003        ..      BEQ      0x207eee ; common_main + 38
        0x00207ee6:    a119        ..      ADR      r1,{pc}+0x66 ; 0x207f4c
        0x00207ee8:    f5fffd62    ..b.    BL       log_direct ; 0x79b0
        0x00207eec:    e006        ..      B        0x207efc ; common_main + 52
;;;261        }
;;;262        else
;;;263        {
;;;264            DBG_DIRECT("WARNING: In HCI Mode, will not run APP Task");
        0x00207eee:    a11a        ..      ADR      r1,{pc}+0x6a ; 0x207f58
        0x00207ef0:    f5fffd5e    ..^.    BL       log_direct ; 0x79b0
;;;265    		WDG_Disable();
        0x00207ef4:    f609fd25    ..%.    BL       WDG_Disable ; 0x11942
;;;266            os_sched_start();
        0x00207ef8:    f61efc63    ..c.    BL       os_sched_start ; 0x267c2
;;;267        }
;;;268    #endif
;;;269    
;;;270    #if (DEBUG_TASK_HANG_ENABLE == 1)
;;;271        extern void DebugTaskHang(void);  //defined in debug_platform.c
;;;272        DebugTaskHang();
;;;273    #endif
;;;274    
;;;275    #if (DEBUG_DLPS_ERROR_IN_APP_ENABLE == 1)
;;;276        void dlps_debug_swtimer_init(void);  //defined in debug_platform.c
;;;277        dlps_debug_swtimer_init();
;;;278    #endif
;;;279    
;;;280        extern int main(void);
;;;281        main();
        0x00207efc:    e8bd4010    ...@    POP      {r4,lr}
        0x00207f00:    f001b9ac    ....    B.W      main ; 0x20925c
    WDG_SystemReset
;;;282    }
;;;283    /**
;;;284     * @brief  Enable Debug Monitor Function (include NVIC Enable and DWT configuration)
;;;285     * @param  none
;;;286     * @return none
;;;287     */
;;;288    
;;;289    APP_FLASH_TEXT_SECTION
;;;290    void debug_monitor_enable(void)
;;;291    {
;;;292        //DBG_DIRECT("debug_monitor_enable");
;;;293    
;;;294        //set debug monitor priority
;;;295        NVIC_SetPriority(DebugMonitor_IRQn, 3);
;;;296    
;;;297        //enable exception and monitor control register
;;;298        CoreDebug->DEMCR |= CoreDebug_DEMCR_MON_EN_Msk | CoreDebug_DEMCR_TRCENA_Msk;
;;;299    
;;;300        //set DWT compare registers (max 4 comparators)
;;;301        //watch_point_0_setting(0x1000180C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_WRITE);
;;;302        //watch_point_1_setting(0x10000004, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;303        //watch_point_2_setting(0x10000008, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;304        //watch_point_3_setting(0x1000000C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;305    
;;;306        //enable DWT control register
;;;307        DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
;;;308    
;;;309        return;
;;;310    }
;;;311    
;;;312    APP_FLASH_TEXT_SECTION
;;;313    void ram_init(void)
;;;314    {
;;;315        //copy data on ro
;;;316        extern char Image$$RAM_DATA_ON$$RO$$Base[];
;;;317        extern char Load$$RAM_DATA_ON$$RO$$Base[];
;;;318        extern unsigned int Image$$RAM_DATA_ON$$RO$$Length;
;;;319    
;;;320        memcpy(Image$$RAM_DATA_ON$$RO$$Base,
;;;321               Load$$RAM_DATA_ON$$RO$$Base,
;;;322               (unsigned int)&Image$$RAM_DATA_ON$$RO$$Length);
;;;323    
;;;324        //copy data on rw
;;;325        extern char Image$$RAM_DATA_ON$$RW$$Base[];
;;;326        extern char Load$$RAM_DATA_ON$$RW$$Base[];
;;;327        extern unsigned int Image$$RAM_DATA_ON$$RW$$Length;
;;;328    
;;;329        memcpy(Image$$RAM_DATA_ON$$RW$$Base,
;;;330               Load$$RAM_DATA_ON$$RW$$Base,
;;;331               (unsigned int)&Image$$RAM_DATA_ON$$RW$$Length);
;;;332    
;;;333        //clear data on zi
;;;334        extern char Image$$RAM_DATA_ON$$ZI$$Base[];
;;;335        extern unsigned int Image$$RAM_DATA_ON$$ZI$$Length;
;;;336    
;;;337        memset(Image$$RAM_DATA_ON$$ZI$$Base,
;;;338               0,
;;;339               (unsigned int)&Image$$RAM_DATA_ON$$ZI$$Length);
;;;340    
;;;341        //copy cache ro
;;;342        extern char Image$$CACHE_DATA_ON$$RO$$Base[];
;;;343        extern char Load$$CACHE_DATA_ON$$RO$$Base[];
;;;344        extern unsigned int Image$$CACHE_DATA_ON$$RO$$Length;
;;;345    
;;;346        memcpy(Image$$CACHE_DATA_ON$$RO$$Base,
;;;347               Load$$CACHE_DATA_ON$$RO$$Base,
;;;348               (unsigned int)&Image$$CACHE_DATA_ON$$RO$$Length);
;;;349    }
;;;350    
;;;351    APP_FLASH_TEXT_SECTION
;;;352    void SystemInit(void)
;;;353    {
;;;354        //init pre_main and main functions
;;;355        extern void pre_main(void);
;;;356        app_pre_main = (APP_MAIN_FUNC)pre_main;
;;;357        app_main = (APP_MAIN_FUNC)common_main;
;;;358    
;;;359        /******** update otp here**********/
;;;360        //ram config
;;;361        OTP->appDataSize = APP_GLOBAL_SIZE;
;;;362        OTP->heapDataONSize = HEAP_DATA_ON_SIZE;
;;;363        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;364    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;365        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
;;;366    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;367        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;368    #else
;;;369        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;370    #endif
;;;371    
;;;372    
;;;373        //flash config
;;;374        /*config enable flash block proect depending on flash layout and flash id*/
;;;375    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;376        OTP->bp_enable = 1;
;;;377    #else
;;;378        OTP->bp_enable = 0;
;;;379    #endif
;;;380        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
;;;381    
;;;382    
;;;383        //os config
;;;384        /*config enable check task stack overflow*/
;;;385    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;386        OTP->checkForStackOverflow = 1;
;;;387    #else
;;;388        OTP->checkForStackOverflow = 0;
;;;389    #endif
;;;390    
;;;391    
;;;392        //platform config
;;;393        /*config enable platform assert*/
;;;394    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;395        OTP->enableASSERT = 1;
;;;396    #else
;;;397        OTP->enableASSERT = 0;
;;;398    #endif
;;;399    
;;;400        /*Print all log in log buffer before entering DLPS */
;;;401    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;402        OTP->printAllLogBeforeEnterDLPS = 1;
;;;403    #else
;;;404        OTP->printAllLogBeforeEnterDLPS = 0;
;;;405    #endif
;;;406    
;;;407        /*config enable log or not*/
;;;408    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;409        OTP->logDisable = 0;
;;;410    #else
;;;411        OTP->logDisable = 1;
;;;412    #endif
;;;413    
;;;414        /*config enable swd pinmux*/
;;;415    #if (SWD_PINMUX_ENABLE == 1)
;;;416        OTP->SWD_ENABLE = 1;
;;;417    #else
;;;418        OTP->SWD_ENABLE = 0;
;;;419    #endif
;;;420    
;;;421        /*config enable watch dog in rom*/
;;;422    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;423        OTP->wdgEnableInRom = 1;
;;;424    #else
;;;425        OTP->wdgEnableInRom = 0;
;;;426    #endif
;;;427    
;;;428        /*config watch dog mode in rom, defualt reset all*/
;;;429        OTP->wdgMode = ROM_WATCH_DOG_MODE;
;;;430    
;;;431    
;;;432        //app config
;;;433        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
;;;434        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
;;;435        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
;;;436        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
;;;437    
;;;438        /*config bt stack parameters in rom*/
;;;439    #ifdef BT_STACK_CONFIG_ENABLE
;;;440        bt_stack_config_init();
;;;441    #endif
;;;442    
;;;443    //add more otp config here
;;;444    }
;;;445    
;;;446    APP_FLASH_TEXT_SECTION
;;;447    void pre_main(void)
;;;448    {
;;;449        __disable_irq();
;;;450    
;;;451        ram_init();
;;;452    
;;;453        load_overlay(OVERLAY_SCENARIO_BOOT_ONCE);
;;;454    
;;;455        setlocale(LC_ALL, "C");
;;;456    
;;;457        BOOT_PRINT_ERROR2("SDK Ver: %s, Build Time: %s",
;;;458                          TRACE_STRING(VERSION_BUILD_STR),
;;;459                          TRACE_STRING(BUILDING_TIME));
;;;460    
;;;461        AppUpdateVectorTable();
;;;462    
;;;463        debug_monitor_enable();
;;;464    
;;;465        return;
;;;466    }
;;;467    /**
;;;468     * @brief  update vector table in app
;;;469     * @param  none
;;;470     * @return none
;;;471      */
;;;472    OVERLAY_SECTION_BOOT_ONCE
;;;473    static void AppUpdateVectorTable(void)
;;;474    {
;;;475        extern uint32_t Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;476        extern uint32_t Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;477        extern void Default_Handler(void);
;;;478        const char *SysException[] =
;;;479        {
;;;480            "InitialSP", "Reset", "NMI", "HardFault", "MemManage", "BusFault", "UsageFault", "Rsvd",
;;;481            "Rsvd", "Rsvd", "Rsvd", "SVC", "DebugMon", "Rsvd", "PendSV", "SysTick"
;;;482        };
;;;483        const char *ExtIrq[] =
;;;484        {
;;;485            "System", "WDG", "BTMAC", "TIM3", "TIM2", "Platform", "I2S0_TX", "I2S0_RX", "Timer4-7",
;;;486            "GPIO4", "GPIO5", "UART1", "UART0", "RTC", "SPI0", "SPI1", "I2C0", "I2C1", "ADC",
;;;487            "Peripheral", "GDMA0 Channel0", "GDMA0 Channel1", "GDMA0 Channel2", "GDMA0 Channel3",
;;;488            "GDMA0 Channel4", "GDMA0 Channel5", "GPIO_Group3", "GPIO_Group2", "IR", "GPIO_Group1",
;;;489            "GPIO_Group0", "UART2", "TIM4", "TIM5", "TIM6", "TIM7", "SPI_Flash", "Qdecode",
;;;490            "Keyscan", "SPI2W", "LPCOMP", "PTA_Mailbox", "SPORT1 TX", "SPORT1 RX", "LCD"
;;;491        };
;;;492    
;;;493        IRQ_Fun *pRamVector    = (IRQ_Fun *)VTOR_RAM_ADDR;
;;;494        IRQ_Fun *pAppVector    = (IRQ_Fun *)&Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;495        uint32_t AppVectorSize = (uint32_t)&Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;496        uint32_t i             = 0;
;;;497    
;;;498        if (SCB->VTOR != VTOR_RAM_ADDR)
;;;499        {
;;;500            RamVectorTableInit(VTOR_RAM_ADDR);
;;;501        }
;;;502    
;;;503        /* Update APP defined handlers */
;;;504        for (i = 0; i < AppVectorSize / 4; ++i)
;;;505        {
;;;506            if (i == 1) //skip reset_handler remap
;;;507            {
;;;508                continue;
;;;509            }
;;;510    
;;;511            if ((pAppVector[i] != Default_Handler) && (pAppVector[i] != 0))
;;;512            {
;;;513                if (i < System_VECTORn)
;;;514                {
;;;515                    OS_PRINT_WARN1("Warning! %s is updated by APP!", TRACE_STRING(SysException[i]));
;;;516                }
;;;517                else
;;;518                {
;;;519                    OS_PRINT_WARN1("Warning! ISR %s is updated by APP!",
;;;520                                   TRACE_STRING(ExtIrq[i - System_VECTORn]));
;;;521                }
;;;522    
;;;523                pRamVector[i] = pAppVector[i];
;;;524            }
;;;525        }
;;;526    
;;;527        __DMB();
;;;528        __DSB();
;;;529    }
;;;530    /**
;;;531     * @brief  GPIO Group3 Handler
;;;532     * @param  none
;;;533     * @return none
;;;534      */
;;;535    DATA_RAM_FUNCTION void GPIO_Group3_Handler(void)
;;;536    {
;;;537        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;538    
;;;539        //Check exact IRQ function
;;;540        if (GPIOIrqStatus & BIT3)
;;;541        {
;;;542            GPIO3_Handler();
;;;543        }
;;;544        if (GPIOIrqStatus & BIT7)
;;;545        {
;;;546            GPIO7_Handler();
;;;547        }
;;;548        if (GPIOIrqStatus & BIT11)
;;;549        {
;;;550            GPIO11_Handler();
;;;551        }
;;;552        if (GPIOIrqStatus & BIT15)
;;;553        {
;;;554            GPIO15_Handler();
;;;555        }
;;;556        if (GPIOIrqStatus & BIT19)
;;;557        {
;;;558            GPIO19_Handler();
;;;559        }
;;;560        if (GPIOIrqStatus & BIT23)
;;;561        {
;;;562            GPIO23_Handler();
;;;563        }
;;;564        if (GPIOIrqStatus & BIT27)
;;;565        {
;;;566            GPIO27_Handler();
;;;567        }
;;;568        if (GPIOIrqStatus & BIT31)
;;;569        {
;;;570            GPIO31_Handler();
;;;571        }
;;;572    }
;;;573    /**
;;;574     * @brief  GPIO Group2 Handler
;;;575     * @param  none
;;;576     * @return none
;;;577      */
;;;578    DATA_RAM_FUNCTION void GPIO_Group2_Handler(void)
;;;579    {
;;;580        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;581    
;;;582        //Check exact IRQ function
;;;583        if (GPIOIrqStatus & BIT2)
;;;584        {
;;;585            GPIO2_Handler();
;;;586        }
;;;587        if (GPIOIrqStatus & BIT6)
;;;588        {
;;;589            GPIO6_Handler();
;;;590        }
;;;591        if (GPIOIrqStatus & BIT10)
;;;592        {
;;;593            GPIO10_Handler();
;;;594        }
;;;595        if (GPIOIrqStatus & BIT14)
;;;596        {
;;;597            GPIO14_Handler();
;;;598        }
;;;599        if (GPIOIrqStatus & BIT18)
;;;600        {
;;;601            GPIO18_Handler();
;;;602        }
;;;603        if (GPIOIrqStatus & BIT22)
;;;604        {
;;;605            GPIO22_Handler();
;;;606        }
;;;607        if (GPIOIrqStatus & BIT26)
;;;608        {
;;;609            GPIO26_Handler();
;;;610        }
;;;611        if (GPIOIrqStatus & BIT30)
;;;612        {
;;;613            GPIO30_Handler();
;;;614        }
;;;615    }
;;;616    /**
;;;617     * @brief  GPIO Group1 Handler
;;;618     * @param  none
;;;619     * @return none
;;;620      */
;;;621    DATA_RAM_FUNCTION void GPIO_Group1_Handler(void)
;;;622    {
;;;623        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;624    
;;;625        //Check exact IRQ function
;;;626        if (GPIOIrqStatus & BIT1)
;;;627        {
;;;628            GPIO1_Handler();
;;;629        }
;;;630        if (GPIOIrqStatus & BIT9)
;;;631        {
;;;632            GPIO9_Handler();
;;;633        }
;;;634        if (GPIOIrqStatus & BIT13)
;;;635        {
;;;636            GPIO13_Handler();
;;;637        }
;;;638        if (GPIOIrqStatus & BIT17)
;;;639        {
;;;640            GPIO17_Handler();
;;;641        }
;;;642        if (GPIOIrqStatus & BIT21)
;;;643        {
;;;644            GPIO21_Handler();
;;;645        }
;;;646        if (GPIOIrqStatus & BIT25)
;;;647        {
;;;648            GPIO25_Handler();
;;;649        }
;;;650        if (GPIOIrqStatus & BIT29)
;;;651        {
;;;652            GPIO29_Handler();
;;;653        }
;;;654    }
;;;655    /**
;;;656     * @brief  GPIO Group0 Handler
;;;657     * @param  none
;;;658     * @return none
;;;659      */
;;;660    DATA_RAM_FUNCTION void GPIO_Group0_Handler(void)
;;;661    {
;;;662        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;663    
;;;664        //Check exact IRQ function
;;;665        if (GPIOIrqStatus & BIT0)
;;;666        {
;;;667            GPIO0_Handler();
;;;668        }
;;;669        if (GPIOIrqStatus & BIT8)
;;;670        {
;;;671            GPIO8_Handler();
;;;672        }
;;;673        if (GPIOIrqStatus & BIT12)
;;;674        {
;;;675            GPIO12_Handler();
;;;676        }
;;;677        if (GPIOIrqStatus & BIT16)
;;;678        {
;;;679            GPIO16_Handler();
;;;680        }
;;;681        if (GPIOIrqStatus & BIT20)
;;;682        {
;;;683            GPIO20_Handler();
;;;684        }
;;;685        if (GPIOIrqStatus & BIT24)
;;;686        {
;;;687            GPIO24_Handler();
;;;688        }
;;;689        if (GPIOIrqStatus & BIT28)
;;;690        {
;;;691            GPIO28_Handler();
;;;692        }
;;;693    }
;;;694    
;;;695    void WDG_SystemReset(T_WDG_MODE wdg_mode, T_SW_RESET_REASON reset_reason)
;;;696    {
;;;697        uint32_t parm = wdg_mode | (reset_reason << 8);
        0x00207f04:    ea402101    @..!    ORR      r1,r0,r1,LSL #8
;;;698        SystemCall(SYSTEM_CALL_WDG_RESET, parm);
        0x00207f08:    2001        .       MOVS     r0,#1
        0x00207f0a:    f5ffb9c9    ....    B        SystemCall ; 0x72a0
    flash_try_high_speed
;;;699    }
;;;700    
;;;701    /**
;;;702     * @brief  flash try to switch to high speed bit mode
;;;703     * @note  switch back to 1 bit mode, if flash switch to high speed bit mode fail
;;;704     * @param  bit_mode config bit mode @ref T_FLASH_MODE
;;;705     * @retval 0 fail
;;;706     * @retval 1 success
;;;707      */
;;;708    uint32_t flash_try_high_speed(T_FLASH_MODE bit_mode)
;;;709    {
        0x00207f0e:    b510        ..      PUSH     {r4,lr}
;;;710        uint32_t result = 0;
;;;711        OTP->bit_mode = bit_mode;
        0x00207f10:    f44f1400    O...    MOV      r4,#0x200000
        0x00207f14:    2200        ."      MOVS     r2,#0
        0x00207f16:    f894134c    ..L.    LDRB     r1,[r4,#0x34c]
        0x00207f1a:    f3600101    `...    BFI      r1,r0,#0,#2
        0x00207f1e:    f884134c    ..L.    STRB     r1,[r4,#0x34c]
;;;712        result = flash_ioctl(flash_ioctrl_try_high_speed, 0, 0);
        0x00207f22:    4611        .F      MOV      r1,r2
        0x00207f24:    f2450002    E...    MOV      r0,#0x5002
        0x00207f28:    f604f8a3    ....    BL       flash_ioctl ; 0xc072
;;;713        //if try fail, set back OTP->bit_mode to one bit mode
;;;714        if (!result)
        0x00207f2c:    2800        .(      CMP      r0,#0
        0x00207f2e:    d105        ..      BNE      0x207f3c ; flash_try_high_speed + 46
;;;715        {
;;;716            OTP->bit_mode = FLASH_MODE_1BIT;
        0x00207f30:    f894134c    ..L.    LDRB     r1,[r4,#0x34c]
        0x00207f34:    f0210103    !...    BIC      r1,r1,#3
        0x00207f38:    f884134c    ..L.    STRB     r1,[r4,#0x34c]
;;;717        }
;;;718        return result;
;;;719    }
        0x00207f3c:    bd10        ..      POP      {r4,pc}
    app_cb0_wdg_reset
        0x00207f3e:    4a11        .J      LDR      r2,[pc,#68] ; [0x207f84] = 0x20bad4
        0x00207f40:    6812        .h      LDR      r2,[r2,#0]
;;;720    
;;;721    void app_cb0_wdg_reset(T_WDG_MODE wdg_mode, T_SW_RESET_REASON reset_reason)
;;;722    {
        0x00207f42:    2a00        .*      CMP      r2,#0
        0x00207f44:    d000        ..      BEQ      0x207f48 ; app_cb0_wdg_reset + 10
;;;723        if (user_wdg_cb)
;;;724        {
;;;725            if (user_wdg_cb(wdg_mode, reset_reason))
        0x00207f46:    4710        .G      BX       r2
;;;726            {
;;;727                return;
;;;728            }
;;;729        }
;;;730    
;;;731        //do something necessary before watch dog reset
;;;732    }
        0x00207f48:    4770        pG      BX       lr
    $d
        0x00207f4a:    0000        ..      DCW    0
        0x00207f4c:    53206e49    In S    DCD    1394634313
        0x00207f50:    4d20436f    oC M    DCD    1293960047
        0x00207f54:    0065646f    ode.    DCD    6644847
        0x00207f58:    4e524157    WARN    DCD    1314013527
        0x00207f5c:    3a474e49    ING:    DCD    977751625
        0x00207f60:    206e4920     In     DCD    544098592
        0x00207f64:    20494348    HCI     DCD    541672264
        0x00207f68:    65646f4d    Mode    DCD    1701080909
        0x00207f6c:    6977202c    , wi    DCD    1769414700
        0x00207f70:    6e206c6c    ll n    DCD    1847618668
        0x00207f74:    7220746f    ot r    DCD    1914729583
        0x00207f78:    41206e75    un A    DCD    1092644469
        0x00207f7c:    54205050    PP T    DCD    1411403856
        0x00207f80:    006b7361    ask.    DCD    7041889
        0x00207f84:    0020bad4    .. .    DCD    2144980
    $t
    .text
    hids_set_parameter
;;; .\..\..\..\src\ble\profile\server\hids_kb.c
;;;542    {
        0x00207f88:    b570        p.      PUSH     {r4-r6,lr}
        0x00207f8a:    4613        .F      MOV      r3,r2
        0x00207f8c:    460a        .F      MOV      r2,r1
;;;543        bool ret = true;
        0x00207f8e:    2401        .$      MOVS     r4,#1
        0x00207f90:    498d        .I      LDR      r1,[pc,#564] ; [0x2081c8] = 0x20bad8
;;;544    
;;;545        switch (param_type)
        0x00207f92:    280b        .(      CMP      r0,#0xb
        0x00207f94:    d215        ..      BCS      0x207fc2 ; hids_set_parameter + 58
        0x00207f96:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x00207f9a:    0614        ..      DCW    1556
        0x00207f9c:    15151515    ....    DCD    353703189
        0x00207fa0:    0c151509    ....    DCD    202708233
        0x00207fa4:    0011        ..      DCW    17
    $t
;;;546        {
;;;547        case HID_PROTOCOL_MODE:
;;;548            {
;;;549                hid_protocol_mode = (T_HID_PROTOCOL_MODE) * ((uint8_t *)value_ptr);
        0x00207fa6:    7818        .x      LDRB     r0,[r3,#0]
        0x00207fa8:    7008        .p      STRB     r0,[r1,#0]
;;;550            }
;;;551            break;
        0x00207faa:    e00b        ..      B        0x207fc4 ; hids_set_parameter + 60
;;;552    
;;;553        case HID_REPORT_INPUT:
;;;554            break;
;;;555    
;;;556        case HID_REPORT_OUTPUT:
;;;557            break;
;;;558    
;;;559        case HID_REPORT_FEATURE:
;;;560            break;
;;;561    
;;;562        case HID_REPORT_MAP:
;;;563            break;
;;;564    
;;;565        case HID_EXTERNAL_REPORT_REFER:
;;;566            {
;;;567                external_report_refer = *(uint16_t *)value_ptr;
        0x00207fac:    8818        ..      LDRH     r0,[r3,#0]
        0x00207fae:    8048        H.      STRH     r0,[r1,#2]
;;;568            }
;;;569            break;
        0x00207fb0:    e008        ..      B        0x207fc4 ; hids_set_parameter + 60
;;;570    
;;;571        case HID_BOOT_KB_IN_REPORT:
;;;572            break;
;;;573    
;;;574        case HID_BOOT_KB_OUT_REPORT:
;;;575            break;
;;;576    
;;;577        case HID_INFO:
;;;578            {
;;;579                memcpy((void *)&hid_info, value_ptr, length);
        0x00207fb2:    4619        .F      MOV      r1,r3
        0x00207fb4:    4885        .H      LDR      r0,[pc,#532] ; [0x2081cc] = 0x20ba36
        0x00207fb6:    f651ff70    Q.p.    BL       __aeabi_memcpy ; 0x59e9a
;;;580            }
;;;581            break;
        0x00207fba:    e003        ..      B        0x207fc4 ; hids_set_parameter + 60
;;;582    
;;;583        case HID_CONTROL_POINT:
;;;584            hid_suspand_mode = *((uint8_t *)value_ptr);
        0x00207fbc:    7818        .x      LDRB     r0,[r3,#0]
        0x00207fbe:    7048        Hp      STRB     r0,[r1,#1]
;;;585            break;
        0x00207fc0:    e000        ..      B        0x207fc4 ; hids_set_parameter + 60
;;;586    
;;;587        default:
;;;588            ret = false;
        0x00207fc2:    2400        .$      MOVS     r4,#0
;;;589            break;
;;;590        }
;;;591        return ret;
        0x00207fc4:    4620         F      MOV      r0,r4
;;;592    }
        0x00207fc6:    bd70        p.      POP      {r4-r6,pc}
    hids_attr_read_cb
;;;593    
;;;594    
;;;595    static T_APP_RESULT hids_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id,
;;;596                                          uint16_t attrib_index,
;;;597                                          uint16_t offset, uint16_t *p_length, uint8_t **pp_value)
;;;598    {
        0x00207fc8:    b5f0        ..      PUSH     {r4-r7,lr}
        0x00207fca:    b087        ..      SUB      sp,sp,#0x1c
        0x00207fcc:    460b        .F      MOV      r3,r1
        0x00207fce:    4601        .F      MOV      r1,r0
        0x00207fd0:    e9dd540c    ...T    LDRD     r5,r4,[sp,#0x30]
        0x00207fd4:    2702        .'      MOVS     r7,#2
;;;599        T_APP_RESULT cause = APP_RESULT_SUCCESS;
        0x00207fd6:    2000        .       MOVS     r0,#0
;;;600        T_HID_CALLBACK_DATA callback_data;
;;;601        callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
;;;602        callback_data.conn_id = conn_id;
        0x00207fd8:    f88d1000    ....    STRB     r1,[sp,#0]
        0x00207fdc:    4e7a        zN      LDR      r6,[pc,#488] ; [0x2081c8] = 0x20bad8
;;;603    
;;;604        callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x00207fde:    f88d7001    ...p    STRB     r7,[sp,#1]
;;;605    
;;;606        switch (attrib_index)
        0x00207fe2:    2a0f        .*      CMP      r2,#0xf
        0x00207fe4:    d026        &.      BEQ      0x208034 ; hids_attr_read_cb + 108
        0x00207fe6:    dc0d        ..      BGT      0x208004 ; hids_attr_read_cb + 60
        0x00207fe8:    2a08        .*      CMP      r2,#8
        0x00207fea:    d004        ..      BEQ      0x207ff6 ; hids_attr_read_cb + 46
        0x00207fec:    dc05        ..      BGT      0x207ffa ; hids_attr_read_cb + 50
        0x00207fee:    2a02        .*      CMP      r2,#2
        0x00207ff0:    d013        ..      BEQ      0x20801a ; hids_attr_read_cb + 82
        0x00207ff2:    2a04        .*      CMP      r2,#4
        0x00207ff4:    d10e        ..      BNE      0x208014 ; hids_attr_read_cb + 76
        0x00207ff6:    b007        ..      ADD      sp,sp,#0x1c
        0x00207ff8:    bdf0        ..      POP      {r4-r7,pc}
        0x00207ffa:    2a0b        .*      CMP      r2,#0xb
        0x00207ffc:    d0fb        ..      BEQ      0x207ff6 ; hids_attr_read_cb + 46
        0x00207ffe:    2a0e        .*      CMP      r2,#0xe
        0x00208000:    d108        ..      BNE      0x208014 ; hids_attr_read_cb + 76
        0x00208002:    e013        ..      B        0x20802c ; hids_attr_read_cb + 100
        0x00208004:    2a11        .*      CMP      r2,#0x11
        0x00208006:    d0f6        ..      BEQ      0x207ff6 ; hids_attr_read_cb + 46
        0x00208008:    2a14        .*      CMP      r2,#0x14
        0x0020800a:    d0f4        ..      BEQ      0x207ff6 ; hids_attr_read_cb + 46
        0x0020800c:    2a16        .*      CMP      r2,#0x16
        0x0020800e:    d01d        ..      BEQ      0x20804c ; hids_attr_read_cb + 132
        0x00208010:    2a18        .*      CMP      r2,#0x18
        0x00208012:    d0f0        ..      BEQ      0x207ff6 ; hids_attr_read_cb + 46
;;;607        {
;;;608        default:
;;;609            cause = APP_RESULT_ATTR_NOT_FOUND;
        0x00208014:    f240400a    @..@    MOV      r0,#0x40a
        0x00208018:    e7ed        ..      B        0x207ff6 ; hids_attr_read_cb + 46
;;;610            break;
;;;611    
;;;612        case GATT_SVC_HID_PROTOCOL_MODE_INDEX:
;;;613            callback_data.msg_data.read_value_index = GATT_SVC_HID_PROTOCOL_MODE_INDEX;
        0x0020801a:    f88d7004    ...p    STRB     r7,[sp,#4]
;;;614            cause = pfn_hids_cb(service_id, (void *)&callback_data);
        0x0020801e:    6872        rh      LDR      r2,[r6,#4]
        0x00208020:    4669        iF      MOV      r1,sp
        0x00208022:    4618        .F      MOV      r0,r3
        0x00208024:    4790        .G      BLX      r2
;;;615            *pp_value = (uint8_t *)&hid_protocol_mode;
;;;616            *p_length = sizeof(hid_protocol_mode);
        0x00208026:    2101        .!      MOVS     r1,#1
;;;617            break;
        0x00208028:    6026        &`      STR      r6,[r4,#0]
        0x0020802a:    e019        ..      B        0x208060 ; hids_attr_read_cb + 152
;;;618    
;;;619        case GATT_SVC_HID_REPORT_INPUT_INDEX:
;;;620            break;
;;;621    
;;;622        case GATT_SVC_HID_REPORT_OUTPUT_INDEX:
;;;623            break;
;;;624    
;;;625        case GATT_SVC_HID_REPORT_FEATURE_INDEX:
;;;626            break;
;;;627    
;;;628        case GATT_SVC_HID_REPORT_MAP_INDEX:
;;;629            *pp_value = (uint8_t *)hids_report_descriptor;
        0x0020802c:    4968        hI      LDR      r1,[pc,#416] ; [0x2081d0] = 0x20aed4
;;;630            *p_length = sizeof(hids_report_descriptor);
        0x0020802e:    6021        !`      STR      r1,[r4,#0]
        0x00208030:    2193        .!      MOVS     r1,#0x93
;;;631            break;
        0x00208032:    e015        ..      B        0x208060 ; hids_attr_read_cb + 152
;;;632    
;;;633        case GATT_SVC_HID_EXTERNAL_REPORT_REFER_INDEX:
;;;634            callback_data.msg_data.read_value_index = GATT_SVC_HID_EXTERNAL_REPORT_REFER_INDEX;
        0x00208034:    200f        .       MOVS     r0,#0xf
        0x00208036:    f88d0004    ....    STRB     r0,[sp,#4]
;;;635            cause = pfn_hids_cb(service_id, (void *)&callback_data);
        0x0020803a:    6872        rh      LDR      r2,[r6,#4]
        0x0020803c:    4669        iF      MOV      r1,sp
        0x0020803e:    4618        .F      MOV      r0,r3
        0x00208040:    4790        .G      BLX      r2
;;;636            *pp_value = (uint8_t *)&external_report_refer;
        0x00208042:    4961        aI      LDR      r1,[pc,#388] ; [0x2081c8] = 0x20bad8
        0x00208044:    1c89        ..      ADDS     r1,r1,#2
;;;637            *p_length = sizeof(external_report_refer);
        0x00208046:    6021        !`      STR      r1,[r4,#0]
        0x00208048:    802f        /.      STRH     r7,[r5,#0]
        0x0020804a:    e7d4        ..      B        0x207ff6 ; hids_attr_read_cb + 46
;;;638            break;
;;;639    
;;;640        case GATT_SVC_HID_BOOT_KB_IN_REPORT_INDEX:
;;;641            break;
;;;642    
;;;643        case GATT_SVC_HID_BOOT_KB_OUT_REPORT_INDEX:
;;;644            break;
;;;645    
;;;646        case GATT_SVC_HID_INFO_INDEX:
;;;647            callback_data.msg_data.read_value_index = GATT_SVC_HID_INFO_INDEX;
        0x0020804c:    2016        .       MOVS     r0,#0x16
        0x0020804e:    f88d0004    ....    STRB     r0,[sp,#4]
;;;648            cause = pfn_hids_cb(service_id, (void *)&callback_data);
        0x00208052:    6872        rh      LDR      r2,[r6,#4]
        0x00208054:    4669        iF      MOV      r1,sp
        0x00208056:    4618        .F      MOV      r0,r3
        0x00208058:    4790        .G      BLX      r2
;;;649            *pp_value = (uint8_t *)&hid_info;
        0x0020805a:    495c        \I      LDR      r1,[pc,#368] ; [0x2081cc] = 0x20ba36
;;;650            *p_length = sizeof(hid_info);
        0x0020805c:    6021        !`      STR      r1,[r4,#0]
        0x0020805e:    2104        .!      MOVS     r1,#4
        0x00208060:    8029        ).      STRH     r1,[r5,#0]
;;;651            break;
;;;652    
;;;653        case GATT_SVC_HID_CONTROL_POINT_INDEX:
;;;654            break;
;;;655        }
;;;656    
;;;657        return cause;
;;;658    }
        0x00208062:    e7c8        ..      B        0x207ff6 ; hids_attr_read_cb + 46
    hids_attr_write_cb
;;;659    
;;;660    
;;;661    static T_APP_RESULT hids_attr_write_cb(uint8_t conn_id, T_SERVER_ID service_id,
;;;662                                           uint16_t attrib_index, T_WRITE_TYPE write_type,
;;;663                                           uint16_t length, uint8_t *p_value, P_FUN_WRITE_IND_POST_PROC *p_write_ind_post_proc)
;;;664    {
        0x00208064:    b570        p.      PUSH     {r4-r6,lr}
        0x00208066:    b086        ..      SUB      sp,sp,#0x18
        0x00208068:    460d        .F      MOV      r5,r1
        0x0020806a:    e9dd100a    ....    LDRD     r1,r0,[sp,#0x28]
        0x0020806e:    2400        .$      MOVS     r4,#0
        0x00208070:    2603        .&      MOVS     r6,#3
        0x00208072:    f88d6001    ...`    STRB     r6,[sp,#1]
;;; .\..\..\..\src\ble\profile\server\hids_kb.c (664)
        0x00208076:    b158        X.      CBZ      r0,0x208090 ; hids_attr_write_cb + 44
        0x00208078:    2a0e        .*      CMP      r2,#0xe
        0x0020807a:    d02e        ..      BEQ      0x2080da ; hids_attr_write_cb + 118
        0x0020807c:    dc0c        ..      BGT      0x208098 ; hids_attr_write_cb + 52
        0x0020807e:    2a02        .*      CMP      r2,#2
        0x00208080:    d015        ..      BEQ      0x2080ae ; hids_attr_write_cb + 74
        0x00208082:    2a04        .*      CMP      r2,#4
        0x00208084:    d029        ).      BEQ      0x2080da ; hids_attr_write_cb + 118
        0x00208086:    2a08        .*      CMP      r2,#8
        0x00208088:    d01f        ..      BEQ      0x2080ca ; hids_attr_write_cb + 102
        0x0020808a:    2a0b        .*      CMP      r2,#0xb
        0x0020808c:    d10c        ..      BNE      0x2080a8 ; hids_attr_write_cb + 68
        0x0020808e:    e024        $.      B        0x2080da ; hids_attr_write_cb + 118
;;;665        T_APP_RESULT cause  = APP_RESULT_SUCCESS;
;;;666        T_HID_CALLBACK_DATA callback_data;
;;;667        callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
;;;668    
;;;669        if (!p_value)
;;;670        {
;;;671            cause = APP_RESULT_INVALID_PDU;
        0x00208090:    f2404004    @..@    MOV      r0,#0x404
        0x00208094:    b006        ..      ADD      sp,sp,#0x18
        0x00208096:    bd70        p.      POP      {r4-r6,pc}
;;;672            return cause;
;;;673        }
;;;674    
;;;675        switch (attrib_index)
        0x00208098:    2a11        .*      CMP      r2,#0x11
        0x0020809a:    d01e        ..      BEQ      0x2080da ; hids_attr_write_cb + 118
        0x0020809c:    2a14        .*      CMP      r2,#0x14
        0x0020809e:    d01c        ..      BEQ      0x2080da ; hids_attr_write_cb + 118
        0x002080a0:    2a16        .*      CMP      r2,#0x16
        0x002080a2:    d01a        ..      BEQ      0x2080da ; hids_attr_write_cb + 118
        0x002080a4:    2a18        .*      CMP      r2,#0x18
        0x002080a6:    d018        ..      BEQ      0x2080da ; hids_attr_write_cb + 118
;;;676        {
;;;677        default:
;;;678            cause = APP_RESULT_ATTR_NOT_FOUND;
        0x002080a8:    f240440a    @..D    MOV      r4,#0x40a
;;;679            break;
        0x002080ac:    e015        ..      B        0x2080da ; hids_attr_write_cb + 118
;;;680    
;;;681        case GATT_SVC_HID_PROTOCOL_MODE_INDEX:
;;;682            callback_data.msg_data.read_value_index = GATT_SVC_HID_PROTOCOL_MODE_INDEX;
        0x002080ae:    2202        ."      MOVS     r2,#2
        0x002080b0:    f88d2004    ...     STRB     r2,[sp,#4]
;;;683            callback_data.msg_data.write_msg.write_type = write_type;
        0x002080b4:    f88d3008    ...0    STRB     r3,[sp,#8]
;;;684            callback_data.msg_data.write_msg.write_parameter.protocol_mode = *p_value;
        0x002080b8:    7802        .x      LDRB     r2,[r0,#0]
        0x002080ba:    f88d200c    ...     STRB     r2,[sp,#0xc]
;;;685            hids_set_parameter(HID_PROTOCOL_MODE, length, p_value);
        0x002080be:    4602        .F      MOV      r2,r0
        0x002080c0:    b2c9        ..      UXTB     r1,r1
        0x002080c2:    2001        .       MOVS     r0,#1
        0x002080c4:    f7ffff60    ..`.    BL       hids_set_parameter ; 0x207f88
;;;686            break;
        0x002080c8:    e007        ..      B        0x2080da ; hids_attr_write_cb + 118
;;;687    
;;;688        case GATT_SVC_HID_REPORT_INPUT_INDEX:
;;;689            break;
;;;690    
;;;691        case GATT_SVC_HID_REPORT_OUTPUT_INDEX:
;;;692            callback_data.msg_data.read_value_index = GATT_SVC_HID_REPORT_OUTPUT_INDEX;
        0x002080ca:    2108        .!      MOVS     r1,#8
        0x002080cc:    f88d1004    ....    STRB     r1,[sp,#4]
;;;693            callback_data.msg_data.write_msg.write_type = write_type;
        0x002080d0:    f88d3008    ...0    STRB     r3,[sp,#8]
;;;694            callback_data.msg_data.write_msg.write_parameter.output = *p_value;
        0x002080d4:    7800        .x      LDRB     r0,[r0,#0]
        0x002080d6:    f88d000c    ....    STRB     r0,[sp,#0xc]
;;;695            break;
;;;696    
;;;697        case GATT_SVC_HID_REPORT_FEATURE_INDEX:
;;;698            break;
;;;699    
;;;700        case GATT_SVC_HID_REPORT_MAP_INDEX:
;;;701            break;
;;;702    
;;;703        case GATT_SVC_HID_BOOT_KB_IN_REPORT_INDEX:
;;;704            break;
;;;705    
;;;706        case GATT_SVC_HID_BOOT_KB_OUT_REPORT_INDEX:
;;;707            break;
;;;708    
;;;709        case GATT_SVC_HID_INFO_INDEX:
;;;710            break;
;;;711    
;;;712        case GATT_SVC_HID_CONTROL_POINT_INDEX:
;;;713            break;
;;;714        }
;;;715    
;;;716        if (pfn_hids_cb && (cause == APP_RESULT_SUCCESS))
        0x002080da:    483b        ;H      LDR      r0,[pc,#236] ; [0x2081c8] = 0x20bad8
        0x002080dc:    6842        Bh      LDR      r2,[r0,#4]
        0x002080de:    b11a        ..      CBZ      r2,0x2080e8 ; hids_attr_write_cb + 132
        0x002080e0:    b914        ..      CBNZ     r4,0x2080e8 ; hids_attr_write_cb + 132
;;;717        {
;;;718            pfn_hids_cb(service_id, (void *)&callback_data);
        0x002080e2:    4669        iF      MOV      r1,sp
        0x002080e4:    4628        (F      MOV      r0,r5
        0x002080e6:    4790        .G      BLX      r2
;;;719        }
;;;720    
;;;721        return cause;
        0x002080e8:    4620         F      MOV      r0,r4
;;;722    
;;;723    }
        0x002080ea:    e7d3        ..      B        0x208094 ; hids_attr_write_cb + 48
    hids_cccd_update_cb
;;;724    
;;;725    void hids_cccd_update_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t index, uint16_t ccc_bits)
;;;726    {
        0x002080ec:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x002080f0:    b088        ..      SUB      sp,sp,#0x20
        0x002080f2:    461c        .F      MOV      r4,r3
;;;727        bool cause = true;
        0x002080f4:    2501        .%      MOVS     r5,#1
;;;728        T_HID_CALLBACK_DATA callback_data;
;;;729        callback_data.conn_id = conn_id;
        0x002080f6:    f88d0004    ....    STRB     r0,[sp,#4]
        0x002080fa:    9300        ..      STR      r3,[sp,#0]
        0x002080fc:    4616        .F      MOV      r6,r2
        0x002080fe:    4688        .F      MOV      r8,r1
        0x00208100:    4613        .F      MOV      r3,r2
;;;730        callback_data.msg_type = SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION;
        0x00208102:    462f        /F      MOV      r7,r5
        0x00208104:    f88d5005    ...P    STRB     r5,[sp,#5]
;;;731    
;;;732        PROFILE_PRINT_INFO2("hids_cccd_update_cb index = %d ccc_bits %x", index, ccc_bits);
        0x00208108:    2202        ."      MOVS     r2,#2
        0x0020810a:    4932        2I      LDR      r1,[pc,#200] ; [0x2081d4] = 0x880006c
        0x0020810c:    4832        2H      LDR      r0,[pc,#200] ; [0x2081d8] = 0x21103302
        0x0020810e:    f5fffca6    ....    BL       log_buffer ; 0x7a5e
        0x00208112:    2000        .       MOVS     r0,#0
;;;733    
;;;734        switch (index)
        0x00208114:    2e05        ..      CMP      r6,#5
        0x00208116:    d003        ..      BEQ      0x208120 ; hids_cccd_update_cb + 52
        0x00208118:    2e12        ..      CMP      r6,#0x12
        0x0020811a:    d003        ..      BEQ      0x208124 ; hids_cccd_update_cb + 56
;;;735        {
;;;736        default:
;;;737            cause = false;
        0x0020811c:    2500        .%      MOVS     r5,#0
;;;738            break;
        0x0020811e:    e00b        ..      B        0x208138 ; hids_cccd_update_cb + 76
;;;739    
;;;740        case GATT_SVC_HID_REPORT_INPUT_CCCD_INDEX:
;;;741            {
;;;742                callback_data.msg_data.not_ind_data.index = GATT_SVC_HID_REPORT_INPUT_CCCD_INDEX;
        0x00208120:    2105        .!      MOVS     r1,#5
        0x00208122:    e000        ..      B        0x208126 ; hids_cccd_update_cb + 58
        0x00208124:    2112        .!      MOVS     r1,#0x12
        0x00208126:    f88d1018    ....    STRB     r1,[sp,#0x18]
;;;743                if (ccc_bits & GATT_PDU_TYPE_NOTIFICATION)
        0x0020812a:    07e1        ..      LSLS     r1,r4,#31
        0x0020812c:    d002        ..      BEQ      0x208134 ; hids_cccd_update_cb + 72
;;;744                {
;;;745                    callback_data.msg_data.not_ind_data.value = NOTIFY_ENABLE;
;;;746                }
;;;747                else
;;;748                {
;;;749                    callback_data.msg_data.not_ind_data.value = NOTIFY_DISABLE;
;;;750                }
;;;751                break;
;;;752            }
;;;753    
;;;754        case GATT_SVC_HID_BOOT_KB_IN_REPORT_CCCD_INDEX:
;;;755            {
;;;756                callback_data.msg_data.not_ind_data.index = GATT_SVC_HID_BOOT_KB_IN_REPORT_CCCD_INDEX;
;;;757                if (ccc_bits & GATT_PDU_TYPE_NOTIFICATION)
;;;758                {
;;;759                    callback_data.msg_data.not_ind_data.value = NOTIFY_ENABLE;
        0x0020812e:    f88d0019    ....    STRB     r0,[sp,#0x19]
        0x00208132:    e001        ..      B        0x208138 ; hids_cccd_update_cb + 76
;;;760                }
;;;761                else
;;;762                {
;;;763                    callback_data.msg_data.not_ind_data.value = NOTIFY_DISABLE;
        0x00208134:    f88d7019    ...p    STRB     r7,[sp,#0x19]
;;;764                }
;;;765                break;
;;;766            }
;;;767    
;;;768        }
;;;769    
;;;770        if (pfn_hids_cb && (cause == true))
        0x00208138:    4823        #H      LDR      r0,[pc,#140] ; [0x2081c8] = 0x20bad8
        0x0020813a:    6842        Bh      LDR      r2,[r0,#4]
        0x0020813c:    2a00        .*      CMP      r2,#0
        0x0020813e:    d004        ..      BEQ      0x20814a ; hids_cccd_update_cb + 94
        0x00208140:    2d00        .-      CMP      r5,#0
        0x00208142:    d002        ..      BEQ      0x20814a ; hids_cccd_update_cb + 94
;;;771        {
;;;772            pfn_hids_cb(service_id, (void *)&callback_data);
        0x00208144:    a901        ..      ADD      r1,sp,#4
        0x00208146:    4640        @F      MOV      r0,r8
        0x00208148:    4790        .G      BLX      r2
;;;773        }
;;;774    
;;;775        return;
;;;776    }
        0x0020814a:    b008        ..      ADD      sp,sp,#0x20
        0x0020814c:    e8bd81f0    ....    POP      {r4-r8,pc}
    hids_send_report
;;;777    
;;;778    
;;;779    /**
;;;780     * @brief       Send HIDS notification data .
;;;781     *
;;;782     *
;;;783     * @param[in]   conn_id  Connection id.
;;;784     * @param[in]   service_id  Service id.
;;;785     * @param[in]   index  hids characteristic index.
;;;786     * @param[in]   p_data report value pointer.
;;;787     * @param[in]   data_len length of report data.
;;;788     * @return Operation result.
;;;789     * @retval true Operation success.
;;;790     * @retval false Operation failure.
;;;791     *
;;;792     * <b>Example usage</b>
;;;793     * \code{.c}
;;;794        void test(void)
;;;795        {
;;;796            uint8_t conn_id = 0;
;;;797            T_SERVER_ID service_id = hids_id;
;;;798            uint8_t hid_report_input[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09};
;;;799            hids_send_report(conn_id, service_id, GATT_SVC_HID_REPORT_INPUT_INDEX, hid_report_input, sizeof(hid_report_input));
;;;800        }
;;;801     * \endcode
;;;802     */
;;;803    bool hids_send_report(uint8_t conn_id, T_SERVER_ID service_id, uint16_t index, uint8_t *p_data,
;;;804                          uint16_t data_len)
;;;805    {
        0x00208150:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x00208154:    460f        .F      MOV      r7,r1
        0x00208156:    9c08        ..      LDR      r4,[sp,#0x20]
        0x00208158:    491e        .I      LDR      r1,[pc,#120] ; [0x2081d4] = 0x880006c
;;; .\..\..\..\src\ble\profile\server\hids_kb.c (805)
        0x0020815a:    461d        .F      MOV      r5,r3
        0x0020815c:    4616        .F      MOV      r6,r2
        0x0020815e:    4680        .F      MOV      r8,r0
;;;806        PROFILE_PRINT_INFO1("hids_send_report data_len %d", data_len);
        0x00208160:    4623        #F      MOV      r3,r4
        0x00208162:    2201        ."      MOVS     r2,#1
        0x00208164:    3130        01      ADDS     r1,r1,#0x30
        0x00208166:    481c        .H      LDR      r0,[pc,#112] ; [0x2081d8] = 0x21103302
        0x00208168:    f5fffc79    ..y.    BL       log_buffer ; 0x7a5e
;;;807        return server_send_data(conn_id, service_id, index, p_data, data_len, GATT_PDU_TYPE_NOTIFICATION);
        0x0020816c:    2001        .       MOVS     r0,#1
        0x0020816e:    e9cd4000    ...@    STRD     r4,r0,[sp,#0]
        0x00208172:    462b        +F      MOV      r3,r5
        0x00208174:    4632        2F      MOV      r2,r6
        0x00208176:    4639        9F      MOV      r1,r7
        0x00208178:    4640        @F      MOV      r0,r8
        0x0020817a:    f647fb13    G...    BL       server_send_data ; 0x4f7a4
;;;808    }
        0x0020817e:    e8bd81fc    ....    POP      {r2-r8,pc}
    hids_add_service
;;;809    
;;;810    
;;;811    
;;;812    uint16_t hids_attr_tbl_len = sizeof(hids_attr_tbl);
;;;813    
;;;814    const T_FUN_GATT_SERVICE_CBS hids_cbs =
;;;815    {
;;;816        hids_attr_read_cb,      // Read callback function pointer
;;;817        hids_attr_write_cb,     // Write callback function pointer
;;;818        hids_cccd_update_cb,    // Authorization callback function pointer
;;;819    };
;;;820    
;;;821    /**
;;;822      * @brief       Add HID service to the BLE stack database.
;;;823      *
;;;824      *
;;;825      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;826      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;827      * @retval 0xFF Operation failure.
;;;828      * @retval Others Service id assigned by stack.
;;;829      *
;;;830      * <b>Example usage</b>
;;;831      * \code{.c}
;;;832         void profile_init()
;;;833         {
;;;834             server_init(1);
;;;835             hids_id = hids_add_service(app_handle_profile_message);
;;;836         }
;;;837      * \endcode
;;;838      */
;;;839    T_SERVER_ID hids_add_service(void *p_func)
;;;840    {
        0x00208182:    b53e        >.      PUSH     {r1-r5,lr}
        0x00208184:    4604        .F      MOV      r4,r0
;;;841        T_SERVER_ID service_id;
;;;842        if (false == server_add_service(&service_id, (uint8_t *)hids_attr_tbl, hids_attr_tbl_len, hids_cbs))
        0x00208186:    4815        .H      LDR      r0,[pc,#84] ; [0x2081dc] = 0x20b254
        0x00208188:    e9d01211    ....    LDRD     r1,r2,[r0,#0x44]
        0x0020818c:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x00208190:    6c03        .l      LDR      r3,[r0,#0x40]
        0x00208192:    480e        .H      LDR      r0,[pc,#56] ; [0x2081cc] = 0x20ba36
        0x00208194:    490e        .I      LDR      r1,[pc,#56] ; [0x2081d0] = 0x20aed4
        0x00208196:    1e80        ..      SUBS     r0,r0,#2
        0x00208198:    3194        .1      ADDS     r1,r1,#0x94
        0x0020819a:    8802        ..      LDRH     r2,[r0,#0]
        0x0020819c:    a802        ..      ADD      r0,sp,#8
        0x0020819e:    f647fa66    G.f.    BL       server_add_service ; 0x4f66e
        0x002081a2:    b958        X.      CBNZ     r0,0x2081bc ; hids_add_service + 58
;;;843        {
;;;844            PROFILE_PRINT_ERROR1("hids_add_service: ServiceId %d", service_id);
        0x002081a4:    490b        .I      LDR      r1,[pc,#44] ; [0x2081d4] = 0x880006c
        0x002081a6:    480c        .H      LDR      r0,[pc,#48] ; [0x2081d8] = 0x21103302
        0x002081a8:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x002081ac:    2201        ."      MOVS     r2,#1
        0x002081ae:    3150        P1      ADDS     r1,r1,#0x50
        0x002081b0:    1e80        ..      SUBS     r0,r0,#2
        0x002081b2:    f5fffc54    ..T.    BL       log_buffer ; 0x7a5e
;;;845            service_id = 0xff;
        0x002081b6:    20ff        .       MOVS     r0,#0xff
        0x002081b8:    f88d0008    ....    STRB     r0,[sp,#8]
;;;846        }
;;;847    
;;;848        pfn_hids_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x002081bc:    4802        .H      LDR      r0,[pc,#8] ; [0x2081c8] = 0x20bad8
;;;849        return service_id;
        0x002081be:    6044        D`      STR      r4,[r0,#4]
        0x002081c0:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;850    }
        0x002081c4:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x002081c6:    0000        ..      DCW    0
        0x002081c8:    0020bad8    .. .    DCD    2144984
        0x002081cc:    0020ba36    6. .    DCD    2144822
        0x002081d0:    0020aed4    .. .    DCD    2141908
        0x002081d4:    0880006c    l...    DCD    142606444
        0x002081d8:    21103302    .3.!    DCD    554709762
        0x002081dc:    0020b254    T. .    DCD    2142804
    $t
    .text
    bas_set_parameter
;;; .\..\..\..\src\ble\profile\server\bas.c
;;;137    {
        0x002081e0:    b510        ..      PUSH     {r4,lr}
        0x002081e2:    2401        .$      MOVS     r4,#1
        0x002081e4:    2801        .(      CMP      r0,#1
;;; .\..\..\..\src\ble\profile\server\bas.c (137)
        0x002081e6:    d006        ..      BEQ      0x2081f6 ; bas_set_parameter + 22
;;;138        bool ret = true;
;;;139    
;;;140        switch (param_type)
;;;141        {
;;;142        default:
;;;143            {
;;;144                ret = false;
        0x002081e8:    2400        .$      MOVS     r4,#0
;;;145                PROFILE_PRINT_ERROR0("bas_set_parameter failed");
        0x002081ea:    4622        "F      MOV      r2,r4
        0x002081ec:    4953        SI      LDR      r1,[pc,#332] ; [0x20833c] = 0x88000e0
        0x002081ee:    4854        TH      LDR      r0,[pc,#336] ; [0x208340] = 0x21103300
        0x002081f0:    f5fffc35    ..5.    BL       log_buffer ; 0x7a5e
;;;146            }
;;;147            break;
        0x002081f4:    e006        ..      B        0x208204 ; bas_set_parameter + 36
;;;148    
;;;149        case BAS_PARAM_BATTERY_LEVEL:
;;;150            {
;;;151                if (length != sizeof(uint8_t))
        0x002081f6:    2901        .)      CMP      r1,#1
        0x002081f8:    d001        ..      BEQ      0x2081fe ; bas_set_parameter + 30
;;;152                {
;;;153                    ret = false;
        0x002081fa:    2400        .$      MOVS     r4,#0
        0x002081fc:    e002        ..      B        0x208204 ; bas_set_parameter + 36
;;;154                }
;;;155                else
;;;156                {
;;;157                    battery_level = p_value[0];
        0x002081fe:    4951        QI      LDR      r1,[pc,#324] ; [0x208344] = 0x20bae0
        0x00208200:    7810        .x      LDRB     r0,[r2,#0]
        0x00208202:    7008        .p      STRB     r0,[r1,#0]
;;;158                }
;;;159            }
;;;160            break;
;;;161        }
;;;162    
;;;163        return ret;
        0x00208204:    4620         F      MOV      r0,r4
;;;164    }
        0x00208206:    bd10        ..      POP      {r4,pc}
    bas_battery_level_value_notify
;;;165    
;;;166    /**
;;;167     * @brief       Send notify battery level notification data .
;;;168     *
;;;169     * @param[in]   conn_id  Connection id.
;;;170     * @param[in]   service_id  Service id.
;;;171     * @param[in]   battery_level  Battery level value.
;;;172     * @return Operation result.
;;;173     * @retval true Operation success.
;;;174     * @retval false Operation failure.
;;;175     *
;;;176     * <b>Example usage</b>
;;;177     * \code{.c}
;;;178        void test(void)
;;;179        {
;;;180            uint8_t battery_level = 90;
;;;181            bas_battery_level_value_notify(conn_id, bas_id, battery_level);
;;;182        }
;;;183     * \endcode
;;;184     */
;;;185    bool bas_battery_level_value_notify(uint8_t conn_id, uint8_t service_id, uint8_t battery_level)
;;;186    {
        0x00208208:    b507        ..      PUSH     {r0-r2,lr}
        0x0020820a:    b082        ..      SUB      sp,sp,#8
;;;187        return server_send_data(conn_id, service_id, GATT_SVC_BAS_BATTERY_LEVEL_INDEX, &battery_level,
        0x0020820c:    2300        .#      MOVS     r3,#0
        0x0020820e:    2201        ."      MOVS     r2,#1
        0x00208210:    e9cd2300    ...#    STRD     r2,r3,[sp,#0]
        0x00208214:    ab04        ..      ADD      r3,sp,#0x10
        0x00208216:    2202        ."      MOVS     r2,#2
        0x00208218:    f647fac4    G...    BL       server_send_data ; 0x4f7a4
;;;188                                sizeof(battery_level), GATT_PDU_TYPE_ANY);
;;;189    }
        0x0020821c:    b005        ..      ADD      sp,sp,#0x14
        0x0020821e:    bd00        ..      POP      {pc}
    bas_battery_level_value_read_confirm
;;;190    
;;;191    /**
;;;192     * @brief       Confirm for read battery level value request.
;;;193     *
;;;194     * @param[in]   conn_id  Callback when service attribute was read/write.
;;;195     * @param[in]   service_id  Callback when service attribute was read/write.
;;;196     * @param[in]   battery_level  Callback when service attribute was read/write.
;;;197     * @return Operation result.
;;;198     * @retval true Operation success.
;;;199     * @retval false Operation failure.
;;;200     *
;;;201     * <b>Example usage</b>
;;;202     * \code{.c}
;;;203        void test(void)
;;;204        {
;;;205            uint8_t battery_level = 90;
;;;206            bas_battery_level_value_read_confirm(conn_id, bas_id, battery_level);
;;;207        }
;;;208     * \endcode
;;;209     */
;;;210    bool bas_battery_level_value_read_confirm(uint8_t conn_id, uint8_t service_id,
;;;211                                              uint8_t battery_level)
;;;212    {
        0x00208220:    b507        ..      PUSH     {r0-r2,lr}
        0x00208222:    4b48        HK      LDR      r3,[pc,#288] ; [0x208344] = 0x20bae0
;;; .\..\..\..\src\ble\profile\server\bas.c (212)
        0x00208224:    b082        ..      SUB      sp,sp,#8
        0x00208226:    785a        Zx      LDRB     r2,[r3,#1]
        0x00208228:    b14a        J.      CBZ      r2,0x20823e ; bas_battery_level_value_read_confirm + 30
;;;213        if (bas_read_battery_level_pending == true)
;;;214        {
;;;215            bas_read_battery_level_pending = false;
        0x0020822a:    2200        ."      MOVS     r2,#0
        0x0020822c:    705a        Zp      STRB     r2,[r3,#1]
;;;216            return server_attr_read_confirm(conn_id, service_id, GATT_SVC_BAS_BATTERY_LEVEL_INDEX,
        0x0020822e:    2301        .#      MOVS     r3,#1
        0x00208230:    e9cd3200    ...2    STRD     r3,r2,[sp,#0]
        0x00208234:    ab04        ..      ADD      r3,sp,#0x10
        0x00208236:    2202        ."      MOVS     r2,#2
        0x00208238:    f647fa2b    G.+.    BL       server_attr_read_confirm ; 0x4f692
        0x0020823c:    e7ee        ..      B        0x20821c ; bas_battery_level_value_notify + 20
;;;217                                            &battery_level, sizeof(battery_level), APP_RESULT_SUCCESS);
;;;218        }
;;;219        else
;;;220        {
;;;221            return false;
        0x0020823e:    2000        .       MOVS     r0,#0
;;;222        }
;;;223    }
        0x00208240:    e7ec        ..      B        0x20821c ; bas_battery_level_value_notify + 20
    bas_attr_read_cb
;;;224    
;;;225    /**
;;;226     * @brief read characteristic data from service.
;;;227     *
;;;228     * @param conn_id           Connection ID.
;;;229     * @param service_id        ServiceID to be read.
;;;230     * @param attrib_index      Attribute index of getting characteristic data.
;;;231     * @param offset            Offset of characteritic to be read.
;;;232     * @param p_length          Length of getting characteristic data.
;;;233     * @param pp_value          Pointer to pointer of characteristic value to be read.
;;;234     * @return T_APP_RESULT
;;;235    */
;;;236    T_APP_RESULT bas_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t attrib_index,
;;;237                                  uint16_t offset, uint16_t *p_length, uint8_t **pp_value)
;;;238    {
        0x00208242:    e92d43f8    -..C    PUSH     {r3-r9,lr}
        0x00208246:    4605        .F      MOV      r5,r0
        0x00208248:    e9dd6708    ...g    LDRD     r6,r7,[sp,#0x20]
        0x0020824c:    2000        .       MOVS     r0,#0
        0x0020824e:    8030        0.      STRH     r0,[r6,#0]
        0x00208250:    4688        .F      MOV      r8,r1
        0x00208252:    9300        ..      STR      r3,[sp,#0]
        0x00208254:    4939        9I      LDR      r1,[pc,#228] ; [0x20833c] = 0x88000e0
        0x00208256:    483a        :H      LDR      r0,[pc,#232] ; [0x208340] = 0x21103300
        0x00208258:    4614        .F      MOV      r4,r2
;;;239        T_APP_RESULT cause = APP_RESULT_SUCCESS;
;;;240        *p_length = 0;
;;;241    
;;;242        PROFILE_PRINT_INFO2("bas_attr_read_cb attrib_index = %d offset %x", attrib_index, offset);
        0x0020825a:    4613        .F      MOV      r3,r2
        0x0020825c:    2202        ."      MOVS     r2,#2
        0x0020825e:    311c        .1      ADDS     r1,r1,#0x1c
        0x00208260:    1c80        ..      ADDS     r0,r0,#2
        0x00208262:    f5fffbfc    ....    BL       log_buffer ; 0x7a5e
;;;243    
;;;244        switch (attrib_index)
        0x00208266:    2c02        .,      CMP      r4,#2
        0x00208268:    d00a        ..      BEQ      0x208280 ; bas_attr_read_cb + 62
;;;245        {
;;;246        default:
;;;247            {
;;;248                PROFILE_PRINT_ERROR1("bas_attr_read_cb attrib_index = %d not found", attrib_index);
        0x0020826a:    4934        4I      LDR      r1,[pc,#208] ; [0x20833c] = 0x88000e0
        0x0020826c:    4623        #F      MOV      r3,r4
        0x0020826e:    2201        ."      MOVS     r2,#1
        0x00208270:    314c        L1      ADDS     r1,r1,#0x4c
        0x00208272:    4833        3H      LDR      r0,[pc,#204] ; [0x208340] = 0x21103300
        0x00208274:    f5fffbf3    ....    BL       log_buffer ; 0x7a5e
;;;249                cause  = APP_RESULT_ATTR_NOT_FOUND;
        0x00208278:    f240400a    @..@    MOV      r0,#0x40a
        0x0020827c:    e8bd83f8    ....    POP      {r3-r9,pc}
;;;250            }
;;;251            break;
;;;252    
;;;253        case GATT_SVC_BAS_BATTERY_LEVEL_INDEX:
;;;254            {
;;;255                T_BAS_CALLBACK_DATA callback_data;
;;;256                callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x00208280:    2002        .       MOVS     r0,#2
        0x00208282:    f88d0001    ....    STRB     r0,[sp,#1]
;;;257                callback_data.conn_id = conn_id;
        0x00208286:    f88d5000    ...P    STRB     r5,[sp,#0]
        0x0020828a:    4d2e        .M      LDR      r5,[pc,#184] ; [0x208344] = 0x20bae0
;;;258                callback_data.msg_data.read_value_index = BAS_READ_BATTERY_LEVEL;
        0x0020828c:    2401        .$      MOVS     r4,#1
        0x0020828e:    f88d4002    ...@    STRB     r4,[sp,#2]
;;;259                cause = pfn_bas_cb(service_id, (void *)&callback_data);
        0x00208292:    686a        jh      LDR      r2,[r5,#4]
        0x00208294:    4669        iF      MOV      r1,sp
        0x00208296:    4640        @F      MOV      r0,r8
        0x00208298:    4790        .G      BLX      r2
;;;260                if (cause == APP_RESULT_PENDING)
        0x0020829a:    f5a06150    ..Pa    SUB      r1,r0,#0xd00
        0x0020829e:    3901        .9      SUBS     r1,#1
        0x002082a0:    d100        ..      BNE      0x2082a4 ; bas_attr_read_cb + 98
;;;261                {
;;;262                    bas_read_battery_level_pending = true;
        0x002082a2:    706c        lp      STRB     r4,[r5,#1]
;;;263                }
;;;264    
;;;265                *pp_value = &battery_level;
;;;266                *p_length = sizeof(battery_level);
        0x002082a4:    603d        =`      STR      r5,[r7,#0]
        0x002082a6:    8034        4.      STRH     r4,[r6,#0]
;;;267            }
;;;268            break;
;;;269        }
;;;270        return (cause);
;;;271    }
        0x002082a8:    e7e8        ..      B        0x20827c ; bas_attr_read_cb + 58
    bas_cccd_update_cb
;;;272    
;;;273    /**
;;;274     * @brief update CCCD bits from stack.
;;;275     *
;;;276     * @param conn_id           Connection ID.
;;;277     * @param service_id        Service ID.
;;;278     * @param index             Attribute index of characteristic data.
;;;279     * @param ccc_bits          CCCD bits from stack.
;;;280     * @return None
;;;281    */
;;;282    void bas_cccd_update_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t index, uint16_t ccc_bits)
;;;283    {
        0x002082aa:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x002082ae:    2601        .&      MOVS     r6,#1
        0x002082b0:    f88d6005    ...`    STRB     r6,[sp,#5]
        0x002082b4:    4688        .F      MOV      r8,r1
        0x002082b6:    f88d0004    ....    STRB     r0,[sp,#4]
        0x002082ba:    461d        .F      MOV      r5,r3
        0x002082bc:    9300        ..      STR      r3,[sp,#0]
        0x002082be:    491f        .I      LDR      r1,[pc,#124] ; [0x20833c] = 0x88000e0
        0x002082c0:    481f        .H      LDR      r0,[pc,#124] ; [0x208340] = 0x21103300
        0x002082c2:    4617        .F      MOV      r7,r2
        0x002082c4:    4613        .F      MOV      r3,r2
;;;284        T_BAS_CALLBACK_DATA callback_data;
;;;285        callback_data.msg_type = SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION;
;;;286        callback_data.conn_id = conn_id;
;;;287        bool handle = true;
        0x002082c6:    4634        4F      MOV      r4,r6
;;;288        PROFILE_PRINT_INFO2("bas_cccd_update_cb index = %d ccc_bits %x", index, ccc_bits);
        0x002082c8:    2202        ."      MOVS     r2,#2
        0x002082ca:    317c        |1      ADDS     r1,r1,#0x7c
        0x002082cc:    1c80        ..      ADDS     r0,r0,#2
        0x002082ce:    f5fffbc6    ....    BL       log_buffer ; 0x7a5e
;;;289    
;;;290        switch (index)
        0x002082d2:    2f03        ./      CMP      r7,#3
        0x002082d4:    d00b        ..      BEQ      0x2082ee ; bas_cccd_update_cb + 68
;;;291        {
;;;292        case GATT_SVC_BAS_CHAR_CCCD_INDEX:
;;;293            {
;;;294                if (ccc_bits & GATT_CLIENT_CHAR_CONFIG_NOTIFY)
;;;295                {
;;;296                    callback_data.msg_data.notification_indification_index = BAS_NOTIFY_BATTERY_LEVEL_ENABLE;
;;;297                }
;;;298                else
;;;299                {
;;;300                    callback_data.msg_data.notification_indification_index = BAS_NOTIFY_BATTERY_LEVEL_DISABLE;
;;;301                }
;;;302                break;
;;;303            }
;;;304        default:
;;;305            {
;;;306                handle = false;
        0x002082d6:    2400        .$      MOVS     r4,#0
;;;307                break;
;;;308            }
;;;309    
;;;310        }
;;;311    
;;;312        if (pfn_bas_cb && (handle == true))
        0x002082d8:    481a        .H      LDR      r0,[pc,#104] ; [0x208344] = 0x20bae0
        0x002082da:    6842        Bh      LDR      r2,[r0,#4]
        0x002082dc:    2a00        .*      CMP      r2,#0
        0x002082de:    d004        ..      BEQ      0x2082ea ; bas_cccd_update_cb + 64
        0x002082e0:    2c00        .,      CMP      r4,#0
        0x002082e2:    d002        ..      BEQ      0x2082ea ; bas_cccd_update_cb + 64
;;;313        {
;;;314            pfn_bas_cb(service_id, (void *)&callback_data);
        0x002082e4:    a901        ..      ADD      r1,sp,#4
        0x002082e6:    4640        @F      MOV      r0,r8
        0x002082e8:    4790        .G      BLX      r2
;;;315        }
;;;316    
;;;317        return;
;;;318    }
        0x002082ea:    e8bd81fc    ....    POP      {r2-r8,pc}
        0x002082ee:    07e8        ..      LSLS     r0,r5,#31
        0x002082f0:    d002        ..      BEQ      0x2082f8 ; bas_cccd_update_cb + 78
        0x002082f2:    f88d6006    ...`    STRB     r6,[sp,#6]
        0x002082f6:    e7ef        ..      B        0x2082d8 ; bas_cccd_update_cb + 46
        0x002082f8:    2002        .       MOVS     r0,#2
        0x002082fa:    f88d0006    ....    STRB     r0,[sp,#6]
        0x002082fe:    e7eb        ..      B        0x2082d8 ; bas_cccd_update_cb + 46
    bas_add_service
;;;319    
;;;320    /**
;;;321     * @brief BAS Service Callbacks.
;;;322    */
;;;323    const T_FUN_GATT_SERVICE_CBS bas_cbs =
;;;324    {
;;;325        bas_attr_read_cb,  // Read callback function pointer
;;;326        NULL, // Write callback function pointer
;;;327        bas_cccd_update_cb  // CCCD update callback function pointer
;;;328    };
;;;329    
;;;330    /**
;;;331      * @brief       Add battery service to the BLE stack database.
;;;332      *
;;;333      *
;;;334      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;335      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;336      * @retval 0xFF Operation failure.
;;;337      * @retval Others Service id assigned by stack.
;;;338      *
;;;339      * <b>Example usage</b>
;;;340      * \code{.c}
;;;341         void profile_init()
;;;342         {
;;;343             server_init(1);
;;;344             bas_id = bas_add_service(app_handle_profile_message);
;;;345         }
;;;346      * \endcode
;;;347      */
;;;348    T_SERVER_ID bas_add_service(void *p_func)
;;;349    {
        0x00208300:    b53e        >.      PUSH     {r1-r5,lr}
        0x00208302:    4604        .F      MOV      r4,r0
;;;350        T_SERVER_ID service_id;
;;;351        if (false == server_add_service(&service_id,
        0x00208304:    4810        .H      LDR      r0,[pc,#64] ; [0x208348] = 0x20b2a0
        0x00208306:    e9d0121d    ....    LDRD     r1,r2,[r0,#0x74]
        0x0020830a:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0020830e:    4601        .F      MOV      r1,r0
        0x00208310:    6f03        .o      LDR      r3,[r0,#0x70]
        0x00208312:    2270        p"      MOVS     r2,#0x70
        0x00208314:    a802        ..      ADD      r0,sp,#8
        0x00208316:    f647f9aa    G...    BL       server_add_service ; 0x4f66e
        0x0020831a:    b950        P.      CBNZ     r0,0x208332 ; bas_add_service + 50
;;;352                                        (uint8_t *)bas_attr_tbl,
;;;353                                        bas_attr_tbl_size,
;;;354                                        bas_cbs))
;;;355        {
;;;356            PROFILE_PRINT_ERROR1("bas_add_service: service_id %d", service_id);
        0x0020831c:    4907        .I      LDR      r1,[pc,#28] ; [0x20833c] = 0x88000e0
        0x0020831e:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x00208322:    2201        ."      MOVS     r2,#1
        0x00208324:    31ac        .1      ADDS     r1,r1,#0xac
        0x00208326:    4806        .H      LDR      r0,[pc,#24] ; [0x208340] = 0x21103300
        0x00208328:    f5fffb99    ....    BL       log_buffer ; 0x7a5e
;;;357            service_id = 0xff;
        0x0020832c:    20ff        .       MOVS     r0,#0xff
        0x0020832e:    f88d0008    ....    STRB     r0,[sp,#8]
;;;358        }
;;;359        pfn_bas_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x00208332:    4804        .H      LDR      r0,[pc,#16] ; [0x208344] = 0x20bae0
;;;360        return service_id;
        0x00208334:    6044        D`      STR      r4,[r0,#4]
        0x00208336:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;361    }
        0x0020833a:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0020833c:    088000e0    ....    DCD    142606560
        0x00208340:    21103300    .3.!    DCD    554709760
        0x00208344:    0020bae0    .. .    DCD    2144992
        0x00208348:    0020b2a0    .. .    DCD    2142880
    $t
    .text
    dis_set_parameter
;;; .\..\..\..\src\ble\profile\server\dis.c
;;;422    {
        0x0020834c:    b570        p.      PUSH     {r4-r6,lr}
        0x0020834e:    4613        .F      MOV      r3,r2
;;;423        bool ret = true;
        0x00208350:    2401        .$      MOVS     r4,#1
        0x00208352:    4a9a        .J      LDR      r2,[pc,#616] ; [0x2085bc] = 0x20bae8
;;;424    
;;;425        switch (param_type)
        0x00208354:    2809        .(      CMP      r0,#9
        0x00208356:    d206        ..      BCS      0x208366 ; dis_set_parameter + 26
        0x00208358:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x0020835c:    2a21150c    ..!*    DCD    706811148
        0x00208360:    4c453c33    3<EL    DCD    1279605811
        0x00208364:    0056        V.      DCW    86
    $t
;;;426        {
;;;427        default:
;;;428            ret = false;
        0x00208366:    2400        .$      MOVS     r4,#0
        0x00208368:    4622        "F      MOV      r2,r4
        0x0020836a:    4995        .I      LDR      r1,[pc,#596] ; [0x2085c0] = 0x88001b0
        0x0020836c:    4895        .H      LDR      r0,[pc,#596] ; [0x2085c4] = 0x21103300
        0x0020836e:    f5fffb76    ..v.    BL       log_buffer ; 0x7a5e
;;;429            break;
        0x00208372:    e012        ..      B        0x20839a ; dis_set_parameter + 78
;;;430    
;;;431    #if DIS_CHAR_MANUFACTURER_NAME_SUPPORT
;;;432        case DIS_PARAM_MANUFACTURER_NAME:
;;;433            if (length > DIS_CHAR_MANUFACTURER_NAME_STR_MAX_LENGTH)
        0x00208374:    2914        .)      CMP      r1,#0x14
        0x00208376:    d900        ..      BLS      0x20837a ; dis_set_parameter + 46
;;;434            {
;;;435                length = DIS_CHAR_MANUFACTURER_NAME_STR_MAX_LENGTH;
        0x00208378:    2114        .!      MOVS     r1,#0x14
;;;436            }
;;;437            dis_manufacturer_name_len = length;
        0x0020837a:    7011        .p      STRB     r1,[r2,#0]
;;;438            memcpy(dis_manufacturer_name, p_value, length);
        0x0020837c:    488f        .H      LDR      r0,[pc,#572] ; [0x2085bc] = 0x20bae8
        0x0020837e:    460a        .F      MOV      r2,r1
        0x00208380:    4619        .F      MOV      r1,r3
        0x00208382:    300c        .0      ADDS     r0,r0,#0xc
;;;439            break;
        0x00208384:    e007        ..      B        0x208396 ; dis_set_parameter + 74
;;;440    #endif
;;;441    
;;;442    #if DIS_CHAR_MODEL_NUMBER_SUPPORT
;;;443        case DIS_PARAM_MODEL_NUMBER:
;;;444            if (length > DIS_CHAR_MODEL_NUMBER_STR_MAX_LENGTH)
        0x00208386:    2914        .)      CMP      r1,#0x14
        0x00208388:    d900        ..      BLS      0x20838c ; dis_set_parameter + 64
;;;445            {
;;;446                length = DIS_CHAR_MODEL_NUMBER_STR_MAX_LENGTH;
        0x0020838a:    2114        .!      MOVS     r1,#0x14
;;;447            }
;;;448            dis_model_number_len = length;
        0x0020838c:    7051        Qp      STRB     r1,[r2,#1]
;;;449            memcpy(dis_model_number, p_value, length);
        0x0020838e:    488b        .H      LDR      r0,[pc,#556] ; [0x2085bc] = 0x20bae8
        0x00208390:    460a        .F      MOV      r2,r1
        0x00208392:    4619        .F      MOV      r1,r3
        0x00208394:    3020         0      ADDS     r0,r0,#0x20
        0x00208396:    f651fd80    Q...    BL       __aeabi_memcpy ; 0x59e9a
        0x0020839a:    4620         F      MOV      r0,r4
        0x0020839c:    bd70        p.      POP      {r4-r6,pc}
;;;450            break;
;;;451    #endif
;;;452    
;;;453    #if DIS_CHAR_SERIAL_NUMBER_SUPPORT
;;;454        case DIS_PARAM_SERIAL_NUMBER:
;;;455            if (length > DIS_CHAR_SERIAL_NUMBER_STR_MAX_LENGTH)
        0x0020839e:    2914        .)      CMP      r1,#0x14
        0x002083a0:    d900        ..      BLS      0x2083a4 ; dis_set_parameter + 88
;;;456            {
;;;457                length = DIS_CHAR_SERIAL_NUMBER_STR_MAX_LENGTH;
        0x002083a2:    2114        .!      MOVS     r1,#0x14
;;;458            }
;;;459            dis_serial_number_len = length;
        0x002083a4:    7091        .p      STRB     r1,[r2,#2]
;;;460            memcpy(dis_serial_number, p_value, length);
        0x002083a6:    4885        .H      LDR      r0,[pc,#532] ; [0x2085bc] = 0x20bae8
        0x002083a8:    460a        .F      MOV      r2,r1
        0x002083aa:    4619        .F      MOV      r1,r3
        0x002083ac:    3034        40      ADDS     r0,r0,#0x34
;;;461    
;;;462            break;
        0x002083ae:    e7f2        ..      B        0x208396 ; dis_set_parameter + 74
;;;463    #endif
;;;464    
;;;465    #if DIS_CHAR_HARDWARE_REVISION_SUPPORT
;;;466        case DIS_PARAM_HARDWARE_REVISION:
;;;467            if (length > DIS_CHAR_HARDWARE_REVISION_STR_MAX_LENGTH)
        0x002083b0:    2914        .)      CMP      r1,#0x14
        0x002083b2:    d900        ..      BLS      0x2083b6 ; dis_set_parameter + 106
;;;468            {
;;;469                length = DIS_CHAR_HARDWARE_REVISION_STR_MAX_LENGTH;
        0x002083b4:    2114        .!      MOVS     r1,#0x14
;;;470            }
;;;471            dis_hardware_rev_len = length;
        0x002083b6:    70d1        .p      STRB     r1,[r2,#3]
;;;472            memcpy(dis_hardware_rev, p_value, length);
        0x002083b8:    4880        .H      LDR      r0,[pc,#512] ; [0x2085bc] = 0x20bae8
        0x002083ba:    460a        .F      MOV      r2,r1
        0x002083bc:    4619        .F      MOV      r1,r3
        0x002083be:    3048        H0      ADDS     r0,r0,#0x48
;;;473            break;
        0x002083c0:    e7e9        ..      B        0x208396 ; dis_set_parameter + 74
;;;474    #endif
;;;475    
;;;476    #if DIS_CHAR_FIRMWARE_REVISION_SUPPORT
;;;477        case DIS_PARAM_FIRMWARE_REVISION:
;;;478            if (length > DIS_CHAR_FIRMWARE_REVISION_STR_MAX_LENGTH)
        0x002083c2:    2914        .)      CMP      r1,#0x14
        0x002083c4:    d900        ..      BLS      0x2083c8 ; dis_set_parameter + 124
;;;479            {
;;;480                length = DIS_CHAR_FIRMWARE_REVISION_STR_MAX_LENGTH;
        0x002083c6:    2114        .!      MOVS     r1,#0x14
;;;481            }
;;;482            dis_firmware_rev_len = length;
        0x002083c8:    7111        .q      STRB     r1,[r2,#4]
;;;483            memcpy(dis_firmware_rev, p_value, length);
        0x002083ca:    487c        |H      LDR      r0,[pc,#496] ; [0x2085bc] = 0x20bae8
        0x002083cc:    460a        .F      MOV      r2,r1
        0x002083ce:    4619        .F      MOV      r1,r3
        0x002083d0:    305c        \0      ADDS     r0,r0,#0x5c
;;;484            break;
        0x002083d2:    e7e0        ..      B        0x208396 ; dis_set_parameter + 74
;;;485    #endif
;;;486    
;;;487    #if DIS_CHAR_SOFTWARE_REVISION_SUPPORT
;;;488        case DIS_PARAM_SOFTWARE_REVISION:
;;;489            if (length > DIS_CHAR_SOFTWARE_REVISION_STR_MAX_LENGTH)
        0x002083d4:    2914        .)      CMP      r1,#0x14
        0x002083d6:    d900        ..      BLS      0x2083da ; dis_set_parameter + 142
;;;490            {
;;;491                length = DIS_CHAR_SOFTWARE_REVISION_STR_MAX_LENGTH;
        0x002083d8:    2114        .!      MOVS     r1,#0x14
;;;492            }
;;;493            dis_software_rev_len = length;
        0x002083da:    7151        Qq      STRB     r1,[r2,#5]
;;;494            memcpy(dis_software_rev, p_value, length);
        0x002083dc:    4877        wH      LDR      r0,[pc,#476] ; [0x2085bc] = 0x20bae8
        0x002083de:    460a        .F      MOV      r2,r1
        0x002083e0:    4619        .F      MOV      r1,r3
        0x002083e2:    3070        p0      ADDS     r0,r0,#0x70
;;;495            break;
        0x002083e4:    e7d7        ..      B        0x208396 ; dis_set_parameter + 74
;;;496    #endif
;;;497    
;;;498    #if DIS_CHAR_SYSTEM_ID_SUPPORT
;;;499        case DIS_PARAM_SYSTEM_ID:
;;;500            if (length > DIS_SYSTEM_ID_LENGTH)
        0x002083e6:    2908        .)      CMP      r1,#8
        0x002083e8:    d900        ..      BLS      0x2083ec ; dis_set_parameter + 160
;;;501            {
;;;502                length = DIS_SYSTEM_ID_LENGTH;
        0x002083ea:    2108        .!      MOVS     r1,#8
;;;503            }
;;;504            memcpy(dis_system_id, p_value, length);
        0x002083ec:    460a        .F      MOV      r2,r1
        0x002083ee:    4619        .F      MOV      r1,r3
        0x002083f0:    4875        uH      LDR      r0,[pc,#468] ; [0x2085c8] = 0x20ba42
;;;505            break;
        0x002083f2:    e7d0        ..      B        0x208396 ; dis_set_parameter + 74
;;;506    #endif
;;;507    
;;;508    #if DIS_CHAR_IEEE_CERTIF_DATA_LIST_SUPPORT
;;;509        case DIS_PARAM_IEEE_DATA_LIST:
;;;510            if (length > DIS_CHAR_IEEE_CERTIF_DATA_LIST_MAX_LENGTH)
        0x002083f4:    291e        .)      CMP      r1,#0x1e
        0x002083f6:    d900        ..      BLS      0x2083fa ; dis_set_parameter + 174
;;;511            {
;;;512                length = DIS_CHAR_IEEE_CERTIF_DATA_LIST_MAX_LENGTH;
        0x002083f8:    211e        .!      MOVS     r1,#0x1e
;;;513            }
;;;514            dis_ieee_data_list_len = length;
        0x002083fa:    4873        sH      LDR      r0,[pc,#460] ; [0x2085c8] = 0x20ba42
        0x002083fc:    460a        .F      MOV      r2,r1
        0x002083fe:    3808        .8      SUBS     r0,r0,#8
        0x00208400:    7001        .p      STRB     r1,[r0,#0]
;;;515            memcpy(dis_ieee_data_list, p_value, length);
        0x00208402:    4619        .F      MOV      r1,r3
        0x00208404:    3010        .0      ADDS     r0,r0,#0x10
;;;516            break;
        0x00208406:    e7c6        ..      B        0x208396 ; dis_set_parameter + 74
;;;517    #endif
;;;518    
;;;519    #if DIS_CHAR_PNP_ID_SUPPORT
;;;520        case DIS_PARAM_PNP_ID:
;;;521            if (length > DIS_PNP_ID_LENGTH)
        0x00208408:    2907        .)      CMP      r1,#7
        0x0020840a:    d900        ..      BLS      0x20840e ; dis_set_parameter + 194
;;;522            {
;;;523                length = DIS_PNP_ID_LENGTH;
        0x0020840c:    2107        .!      MOVS     r1,#7
;;;524            }
;;;525            memcpy(dis_pnp_id, p_value, length);
        0x0020840e:    486e        nH      LDR      r0,[pc,#440] ; [0x2085c8] = 0x20ba42
        0x00208410:    460a        .F      MOV      r2,r1
        0x00208412:    4619        .F      MOV      r1,r3
        0x00208414:    1fc0        ..      SUBS     r0,r0,#7
;;;526            break;
        0x00208416:    e7be        ..      B        0x208396 ; dis_set_parameter + 74
    dis_attr_read_cb
;;;527    #endif
;;;528        }
;;;529    
;;;530        if (!ret)
;;;531        {
;;;532            PROFILE_PRINT_ERROR0("DIS parameter set failed");
;;;533        }
;;;534    
;;;535        return ret;
;;;536    }
;;;537    
;;;538    /**
;;;539     * @brief Read characteristic data from service.
;;;540     *
;;;541     * @param[in]   conn_id  Connection id.
;;;542     * @param[in] service_id            ServiceID to be read.
;;;543     * @param[in] attrib_index          Attribute index of getting characteristic data.
;;;544     * @param[in] offset                offset of characteritic to be read.
;;;545     * @param[in,out] length_ptr            length of getting characteristic data.
;;;546     * @param[in,out] pp_value              pointer to pointer of characteristic value to be read.
;;;547     * @return T_APP_RESULT
;;;548    */
;;;549    T_APP_RESULT dis_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t attrib_index,
;;;550                                  uint16_t offset, uint16_t *length_ptr, uint8_t **pp_value)
;;;551    {
        0x00208418:    e92d47fc    -..G    PUSH     {r2-r10,lr}
        0x0020841c:    4692        .F      MOV      r10,r2
        0x0020841e:    e9dd450a    ...E    LDRD     r4,r5,[sp,#0x28]
        0x00208422:    460a        .F      MOV      r2,r1
;;;552        T_DIS_CALLBACK_DATA callback_data;
;;;553        T_APP_RESULT  cause  = APP_RESULT_SUCCESS;
        0x00208424:    2600        .&      MOVS     r6,#0
;;;554        *length_ptr = 0;
        0x00208426:    8026        &.      STRH     r6,[r4,#0]
;;;555        callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x00208428:    2102        .!      MOVS     r1,#2
        0x0020842a:    f88d1004    ....    STRB     r1,[sp,#4]
;;;556        callback_data.conn_id = conn_id;
        0x0020842e:    f88d0005    ....    STRB     r0,[sp,#5]
;;;557    
;;;558        switch (attrib_index)
        0x00208432:    f1aa0002    ....    SUB      r0,r10,#2
        0x00208436:    2708        .'      MOVS     r7,#8
        0x00208438:    f8df8180    ....    LDR      r8,[pc,#384] ; [0x2085bc] = 0x20bae8
        0x0020843c:    f04f0907    O...    MOV      r9,#7
        0x00208440:    2811        .(      CMP      r0,#0x11
        0x00208442:    d20a        ..      BCS      0x20845a ; dis_attr_read_cb + 66
        0x00208444:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x00208448:    098c091e    ....    DCD    160172318
        0x0020844c:    0949092c    ,.I.    DCD    155781420
        0x00208450:    0957093b    ;.W.    DCD    156698939
        0x00208454:    09650913    ..e.    DCD    157616403
        0x00208458:    0072        r.      DCW    114
    $t
;;;559        {
;;;560        default:
;;;561            PROFILE_PRINT_ERROR1("dis_attr_read_cb: attrib_index %d", attrib_index);
        0x0020845a:    4959        YI      LDR      r1,[pc,#356] ; [0x2085c0] = 0x88001b0
        0x0020845c:    4653        SF      MOV      r3,r10
        0x0020845e:    2201        ."      MOVS     r2,#1
        0x00208460:    311c        .1      ADDS     r1,r1,#0x1c
        0x00208462:    4858        XH      LDR      r0,[pc,#352] ; [0x2085c4] = 0x21103300
        0x00208464:    f5fffafb    ....    BL       log_buffer ; 0x7a5e
;;;562            cause = APP_RESULT_ATTR_NOT_FOUND;
        0x00208468:    f240460a    @..F    MOV      r6,#0x40a
;;;563            break;
        0x0020846c:    e06b        k.      B        0x208546 ; dis_attr_read_cb + 302
;;;564    
;;;565    #if DIS_CHAR_SYSTEM_ID_SUPPORT
;;;566        case GATT_SVC_DIS_SYSTEM_ID_INDEX:
;;;567            callback_data.msg_data.read_value_index = DIS_READ_SYSTEM_ID_INDEX;
        0x0020846e:    f88d9006    ....    STRB     r9,[sp,#6]
;;;568            pfn_dis_cb(service_id, (void *)&callback_data);
        0x00208472:    4610        .F      MOV      r0,r2
        0x00208474:    f8d82008    ...     LDR      r2,[r8,#8]
        0x00208478:    a901        ..      ADD      r1,sp,#4
        0x0020847a:    4790        .G      BLX      r2
;;;569            *pp_value    = (uint8_t *)&dis_system_id;
        0x0020847c:    4852        RH      LDR      r0,[pc,#328] ; [0x2085c8] = 0x20ba42
;;;570            *length_ptr = sizeof(dis_system_id);
        0x0020847e:    6028        (`      STR      r0,[r5,#0]
        0x00208480:    8027        '.      STRH     r7,[r4,#0]
;;;571            break;
        0x00208482:    e060        `.      B        0x208546 ; dis_attr_read_cb + 302
;;;572    #endif
;;;573    
;;;574    #if DIS_CHAR_MANUFACTURER_NAME_SUPPORT
;;;575        case GATT_SVC_DIS_MANU_NAME_INDEX:
;;;576            callback_data.msg_data.read_value_index = DIS_READ_MANU_NAME_INDEX;
        0x00208484:    2001        .       MOVS     r0,#1
        0x00208486:    f88d0006    ....    STRB     r0,[sp,#6]
;;;577            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0020848a:    4610        .F      MOV      r0,r2
        0x0020848c:    f8d82008    ...     LDR      r2,[r8,#8]
        0x00208490:    a901        ..      ADD      r1,sp,#4
        0x00208492:    4790        .G      BLX      r2
;;;578            *pp_value    = (uint8_t *)&dis_manufacturer_name;
        0x00208494:    4849        IH      LDR      r0,[pc,#292] ; [0x2085bc] = 0x20bae8
        0x00208496:    300c        .0      ADDS     r0,r0,#0xc
;;;579            *length_ptr = dis_manufacturer_name_len;
        0x00208498:    6028        (`      STR      r0,[r5,#0]
        0x0020849a:    f8980000    ....    LDRB     r0,[r8,#0]
;;;580            break;
        0x0020849e:    e00c        ..      B        0x2084ba ; dis_attr_read_cb + 162
;;;581    #endif
;;;582    
;;;583    #if DIS_CHAR_SERIAL_NUMBER_SUPPORT
;;;584        case GATT_SVC_DIS_SERIAL_NUM_INDEX:
;;;585            callback_data.msg_data.read_value_index = DIS_READ_SERIAL_NUM_INDEX;
        0x002084a0:    2003        .       MOVS     r0,#3
        0x002084a2:    f88d0006    ....    STRB     r0,[sp,#6]
;;;586            pfn_dis_cb(service_id, (void *)&callback_data);
        0x002084a6:    4610        .F      MOV      r0,r2
        0x002084a8:    f8d82008    ...     LDR      r2,[r8,#8]
        0x002084ac:    a901        ..      ADD      r1,sp,#4
        0x002084ae:    4790        .G      BLX      r2
;;;587            *pp_value    = (uint8_t *)&dis_serial_number;
        0x002084b0:    4842        BH      LDR      r0,[pc,#264] ; [0x2085bc] = 0x20bae8
        0x002084b2:    3034        40      ADDS     r0,r0,#0x34
;;;588            *length_ptr = dis_serial_number_len;
        0x002084b4:    6028        (`      STR      r0,[r5,#0]
        0x002084b6:    f8980002    ....    LDRB     r0,[r8,#2]
        0x002084ba:    8020         .      STRH     r0,[r4,#0]
        0x002084bc:    e043        C.      B        0x208546 ; dis_attr_read_cb + 302
;;;589            break;
;;;590    #endif
;;;591    
;;;592    #if DIS_CHAR_FIRMWARE_REVISION_SUPPORT
;;;593        case GATT_SVC_DIS_FIRMWARE_REV_INDEX:
;;;594            callback_data.msg_data.read_value_index = DIS_READ_FIRMWARE_REV_INDEX;
        0x002084be:    2005        .       MOVS     r0,#5
        0x002084c0:    f88d0006    ....    STRB     r0,[sp,#6]
;;;595            pfn_dis_cb(service_id, (void *)&callback_data);
        0x002084c4:    4610        .F      MOV      r0,r2
        0x002084c6:    f8d82008    ...     LDR      r2,[r8,#8]
        0x002084ca:    a901        ..      ADD      r1,sp,#4
        0x002084cc:    4790        .G      BLX      r2
;;;596            *pp_value    = (uint8_t *)&dis_firmware_rev;
        0x002084ce:    483b        ;H      LDR      r0,[pc,#236] ; [0x2085bc] = 0x20bae8
        0x002084d0:    305c        \0      ADDS     r0,r0,#0x5c
;;;597            *length_ptr = dis_firmware_rev_len;
        0x002084d2:    6028        (`      STR      r0,[r5,#0]
        0x002084d4:    f8980004    ....    LDRB     r0,[r8,#4]
;;;598            break;
        0x002084d8:    e7ef        ..      B        0x2084ba ; dis_attr_read_cb + 162
;;;599    #endif
;;;600    
;;;601    #if DIS_CHAR_HARDWARE_REVISION_SUPPORT
;;;602        case GATT_SVC_DIS_HARDWARE_REV_INDEX:
;;;603            callback_data.msg_data.read_value_index = DIS_READ_HARDWARE_REV_INDEX;
        0x002084da:    2004        .       MOVS     r0,#4
        0x002084dc:    f88d0006    ....    STRB     r0,[sp,#6]
;;;604            pfn_dis_cb(service_id, (void *)&callback_data);
        0x002084e0:    4610        .F      MOV      r0,r2
        0x002084e2:    f8d82008    ...     LDR      r2,[r8,#8]
        0x002084e6:    a901        ..      ADD      r1,sp,#4
        0x002084e8:    4790        .G      BLX      r2
;;;605            *pp_value    = (uint8_t *)&dis_hardware_rev;
        0x002084ea:    4834        4H      LDR      r0,[pc,#208] ; [0x2085bc] = 0x20bae8
        0x002084ec:    3048        H0      ADDS     r0,r0,#0x48
;;;606            *length_ptr = dis_hardware_rev_len;
        0x002084ee:    6028        (`      STR      r0,[r5,#0]
        0x002084f0:    f8980003    ....    LDRB     r0,[r8,#3]
;;;607            break;
        0x002084f4:    e7e1        ..      B        0x2084ba ; dis_attr_read_cb + 162
;;;608    #endif
;;;609    
;;;610    #if DIS_CHAR_SOFTWARE_REVISION_SUPPORT
;;;611        case GATT_SVC_DIS_SOFTWARE_REV_INDEX:
;;;612            callback_data.msg_data.read_value_index = DIS_READ_SOFTWARE_REV_INDEX;
        0x002084f6:    2006        .       MOVS     r0,#6
        0x002084f8:    f88d0006    ....    STRB     r0,[sp,#6]
;;;613            pfn_dis_cb(service_id, (void *)&callback_data);
        0x002084fc:    4610        .F      MOV      r0,r2
        0x002084fe:    f8d82008    ...     LDR      r2,[r8,#8]
        0x00208502:    a901        ..      ADD      r1,sp,#4
        0x00208504:    4790        .G      BLX      r2
;;;614            *pp_value    = (uint8_t *)&dis_software_rev;
        0x00208506:    482d        -H      LDR      r0,[pc,#180] ; [0x2085bc] = 0x20bae8
        0x00208508:    3070        p0      ADDS     r0,r0,#0x70
;;;615            *length_ptr = dis_software_rev_len;
        0x0020850a:    6028        (`      STR      r0,[r5,#0]
        0x0020850c:    f8980005    ....    LDRB     r0,[r8,#5]
;;;616            break;
        0x00208510:    e7d3        ..      B        0x2084ba ; dis_attr_read_cb + 162
;;;617    #endif
;;;618    
;;;619    #if DIS_CHAR_IEEE_CERTIF_DATA_LIST_SUPPORT
;;;620        case GATT_SVC_DIS_IEEE_CERT_STR_INDEX:
;;;621            callback_data.msg_data.read_value_index = DIS_READ_IEEE_CERT_STR_INDEX;
        0x00208512:    f88d7006    ...p    STRB     r7,[sp,#6]
;;;622            pfn_dis_cb(service_id, (void *)&callback_data);
        0x00208516:    4610        .F      MOV      r0,r2
        0x00208518:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0020851c:    a901        ..      ADD      r1,sp,#4
        0x0020851e:    4790        .G      BLX      r2
;;;623            *pp_value    = (uint8_t *)&dis_ieee_data_list;
        0x00208520:    4829        )H      LDR      r0,[pc,#164] ; [0x2085c8] = 0x20ba42
        0x00208522:    3008        .0      ADDS     r0,r0,#8
;;;624            *length_ptr = dis_ieee_data_list_len;
        0x00208524:    6028        (`      STR      r0,[r5,#0]
        0x00208526:    3810        .8      SUBS     r0,r0,#0x10
        0x00208528:    7800        .x      LDRB     r0,[r0,#0]
;;;625            break;
        0x0020852a:    e7c6        ..      B        0x2084ba ; dis_attr_read_cb + 162
;;;626    #endif
;;;627    
;;;628    #if DIS_CHAR_PNP_ID_SUPPORT
;;;629        case GATT_SVC_DIS_PNP_ID_INDEX:
;;;630            callback_data.msg_data.read_value_index = DIS_READ_PNP_ID_INDEX;
        0x0020852c:    2009        .       MOVS     r0,#9
        0x0020852e:    f88d0006    ....    STRB     r0,[sp,#6]
;;;631            pfn_dis_cb(service_id, (void *)&callback_data);
        0x00208532:    4610        .F      MOV      r0,r2
        0x00208534:    f8d82008    ...     LDR      r2,[r8,#8]
        0x00208538:    a901        ..      ADD      r1,sp,#4
        0x0020853a:    4790        .G      BLX      r2
;;;632            *pp_value    = (uint8_t *)&dis_pnp_id;
        0x0020853c:    4822        "H      LDR      r0,[pc,#136] ; [0x2085c8] = 0x20ba42
        0x0020853e:    1fc0        ..      SUBS     r0,r0,#7
;;;633            *length_ptr = sizeof(dis_pnp_id);
        0x00208540:    6028        (`      STR      r0,[r5,#0]
        0x00208542:    f8a49000    ....    STRH     r9,[r4,#0]
        0x00208546:    8820         .      LDRH     r0,[r4,#0]
        0x00208548:    9000        ..      STR      r0,[sp,#0]
        0x0020854a:    491d        .I      LDR      r1,[pc,#116] ; [0x2085c0] = 0x88001b0
        0x0020854c:    481d        .H      LDR      r0,[pc,#116] ; [0x2085c4] = 0x21103300
        0x0020854e:    4653        SF      MOV      r3,r10
        0x00208550:    2202        ."      MOVS     r2,#2
        0x00208552:    3144        D1      ADDS     r1,r1,#0x44
        0x00208554:    1c80        ..      ADDS     r0,r0,#2
        0x00208556:    f5fffa82    ....    BL       log_buffer ; 0x7a5e
        0x0020855a:    4630        0F      MOV      r0,r6
        0x0020855c:    e8bd87fc    ....    POP      {r2-r10,pc}
;;;634            break;
;;;635    #endif
;;;636    
;;;637    #if DIS_CHAR_MODEL_NUMBER_SUPPORT
;;;638        case GATT_SVC_DIS_MODEL_NUM_INDEX:
;;;639            callback_data.msg_data.read_value_index = DIS_READ_MODEL_NUM_INDEX;
        0x00208560:    f88d1006    ....    STRB     r1,[sp,#6]
;;;640            pfn_dis_cb(service_id, (void *)&callback_data);
        0x00208564:    4610        .F      MOV      r0,r2
        0x00208566:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0020856a:    a901        ..      ADD      r1,sp,#4
        0x0020856c:    4790        .G      BLX      r2
;;;641            *pp_value    = (uint8_t *)&dis_model_number;
        0x0020856e:    4813        .H      LDR      r0,[pc,#76] ; [0x2085bc] = 0x20bae8
        0x00208570:    3020         0      ADDS     r0,r0,#0x20
;;;642            *length_ptr = dis_model_number_len;
        0x00208572:    6028        (`      STR      r0,[r5,#0]
        0x00208574:    f8980001    ....    LDRB     r0,[r8,#1]
;;;643            break;
        0x00208578:    e79f        ..      B        0x2084ba ; dis_attr_read_cb + 162
    dis_add_service
;;;644    #endif
;;;645    
;;;646        }
;;;647    
;;;648        PROFILE_PRINT_INFO2("dis_attr_read_cb: attrib_index %d, *length_ptr %d",
;;;649                            attrib_index,
;;;650                            *length_ptr);
;;;651        return (cause);
;;;652    }
;;;653    
;;;654    const T_FUN_GATT_SERVICE_CBS dis_cbs =
;;;655    {
;;;656        dis_attr_read_cb,  // Read callback function pointer
;;;657        NULL, // Write callback function pointer
;;;658        NULL  // Authorization callback function pointer
;;;659    };
;;;660    
;;;661    /**
;;;662      * @brief Add device information service to the BLE stack database.
;;;663      *
;;;664      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;665      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;666      * @retval 0xFF Operation failure.
;;;667      * @retval others Service id assigned by stack.
;;;668      *
;;;669      * <b>Example usage</b>
;;;670      * \code{.c}
;;;671        void profile_init()
;;;672        {
;;;673            server_init(1);
;;;674            dis_id = dis_add_service(app_handle_profile_message);
;;;675        }
;;;676      * \endcode
;;;677      */
;;;678    T_SERVER_ID dis_add_service(void *p_func)
;;;679    {
        0x0020857a:    b53e        >.      PUSH     {r1-r5,lr}
        0x0020857c:    4604        .F      MOV      r4,r0
;;;680        T_SERVER_ID service_id;
;;;681        if (false == server_add_service(&service_id,
        0x0020857e:    4813        .H      LDR      r0,[pc,#76] ; [0x2085cc] = 0x20b51c
        0x00208580:    e9d01206    ....    LDRD     r1,r2,[r0,#0x18]
        0x00208584:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x00208588:    f5a07100    ...q    SUB      r1,r0,#0x200
        0x0020858c:    6943        Ci      LDR      r3,[r0,#0x14]
        0x0020858e:    f44f7205    O..r    MOV      r2,#0x214
        0x00208592:    a802        ..      ADD      r0,sp,#8
        0x00208594:    f647f86b    G.k.    BL       server_add_service ; 0x4f66e
        0x00208598:    b950        P.      CBNZ     r0,0x2085b0 ; dis_add_service + 54
;;;682                                        (uint8_t *)dis_attr_tbl,
;;;683                                        dis_attr_tbl_size,
;;;684                                        dis_cbs))
;;;685        {
;;;686            PROFILE_PRINT_ERROR1("dis_add_service: service_id %d", service_id);
        0x0020859a:    4909        .I      LDR      r1,[pc,#36] ; [0x2085c0] = 0x88001b0
        0x0020859c:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x002085a0:    2201        ."      MOVS     r2,#1
        0x002085a2:    317c        |1      ADDS     r1,r1,#0x7c
        0x002085a4:    4807        .H      LDR      r0,[pc,#28] ; [0x2085c4] = 0x21103300
        0x002085a6:    f5fffa5a    ..Z.    BL       log_buffer ; 0x7a5e
;;;687            service_id = 0xff;
        0x002085aa:    20ff        .       MOVS     r0,#0xff
        0x002085ac:    f88d0008    ....    STRB     r0,[sp,#8]
;;;688        }
;;;689        pfn_dis_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x002085b0:    4802        .H      LDR      r0,[pc,#8] ; [0x2085bc] = 0x20bae8
;;;690        return service_id;
        0x002085b2:    6084        .`      STR      r4,[r0,#8]
        0x002085b4:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;691    }
        0x002085b8:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x002085ba:    0000        ..      DCW    0
        0x002085bc:    0020bae8    .. .    DCD    2145000
        0x002085c0:    088001b0    ....    DCD    142606768
        0x002085c4:    21103300    .3.!    DCD    554709760
        0x002085c8:    0020ba42    B. .    DCD    2144834
        0x002085cc:    0020b51c    .. .    DCD    2143516
    $t
    .text
    ota_attr_write_cb
;;; ..\..\..\src\app\keyboard\ota_service.c
;;;322    {
        0x002085d0:    e92d41ff    -..A    PUSH     {r0-r8,lr}
        0x002085d4:    4ca2        .L      LDR      r4,[pc,#648] ; [0x208860] = 0x20bb6c
;;; ..\..\..\src\app\keyboard\ota_service.c (322)
        0x002085d6:    e9dd300a    ...0    LDRD     r3,r0,[sp,#0x28]
        0x002085da:    460e        .F      MOV      r6,r1
        0x002085dc:    2500        .%      MOVS     r5,#0
        0x002085de:    2703        .'      MOVS     r7,#3
        0x002085e0:    6824        $h      LDR      r4,[r4,#0]
        0x002085e2:    f240410d    @..A    MOV      r1,#0x40d
        0x002085e6:    2a02        .*      CMP      r2,#2
        0x002085e8:    d012        ..      BEQ      0x208610 ; ota_attr_write_cb + 64
        0x002085ea:    f04f0c02    O...    MOV      r12,#2
        0x002085ee:    2a10        .*      CMP      r2,#0x10
        0x002085f0:    d017        ..      BEQ      0x208622 ; ota_attr_write_cb + 82
        0x002085f2:    2a0c        .*      CMP      r2,#0xc
        0x002085f4:    d02c        ,.      BEQ      0x208650 ; ota_attr_write_cb + 128
        0x002085f6:    9300        ..      STR      r3,[sp,#0]
        0x002085f8:    4613        .F      MOV      r3,r2
        0x002085fa:    2202        ."      MOVS     r2,#2
        0x002085fc:    4999        .I      LDR      r1,[pc,#612] ; [0x208864] = 0x8800250
        0x002085fe:    489a        .H      LDR      r0,[pc,#616] ; [0x208868] = 0x21103302
        0x00208600:    f5fffa2d    ..-.    BL       log_buffer ; 0x7a5e
        0x00208604:    f240450a    @..E    MOV      r5,#0x40a
        0x00208608:    b004        ..      ADD      sp,sp,#0x10
        0x0020860a:    4628        (F      MOV      r0,r5
        0x0020860c:    e8bd81f0    ....    POP      {r4-r8,pc}
;;;323        TOTA_CALLBACK_DATA callback_data;
;;;324        T_APP_RESULT  wCause = APP_RESULT_SUCCESS;
;;;325    
;;;326        if (BLE_SERVICE_CHAR_OTA_INDEX == attrib_index)
;;;327        {
;;;328            /* Make sure written value size is valid. */
;;;329            if ((length != sizeof(uint8_t)) || (p_value == NULL))
        0x00208610:    2b01        .+      CMP      r3,#1
        0x00208612:    d12d        -.      BNE      0x208670 ; ota_attr_write_cb + 160
        0x00208614:    b360        `.      CBZ      r0,0x208670 ; ota_attr_write_cb + 160
;;;330            {
;;;331                wCause  = APP_RESULT_INVALID_VALUE_SIZE;
;;;332            }
;;;333            else
;;;334            {
;;;335                /* Notify Application. */
;;;336                callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
        0x00208616:    f88d7004    ...p    STRB     r7,[sp,#4]
;;;337                callback_data.msg_data.write.opcode = OTA_WRITE_CHAR_VAL;
        0x0020861a:    2101        .!      MOVS     r1,#1
        0x0020861c:    f88d1006    ....    STRB     r1,[sp,#6]
;;;338                callback_data.msg_data.write.u.value = p_value[0];
;;;339    
;;;340                if (pfnOTAExtendedCB)
        0x00208620:    e01d        ..      B        0x20865e ; ota_attr_write_cb + 142
;;;341                {
;;;342                    pfnOTAExtendedCB(service_id, (void *)&callback_data);
;;;343                }
;;;344            }
;;;345        }
;;;346        else if (BLE_SERVICE_CHAR_IMAGE_COUNT_INDEX == attrib_index)
;;;347        {
;;;348            /* Make sure written value size is valid. */
;;;349            if ((length != OTA_UPDATE_IMAGE_INFO_LEN) || (p_value == NULL))
        0x00208622:    2b05        .+      CMP      r3,#5
        0x00208624:    d124        $.      BNE      0x208670 ; ota_attr_write_cb + 160
        0x00208626:    b318        ..      CBZ      r0,0x208670 ; ota_attr_write_cb + 160
;;;350            {
;;;351                wCause  = APP_RESULT_INVALID_VALUE_SIZE;
;;;352            }
;;;353            else
;;;354            {
;;;355                /* Notify Application. */
;;;356                callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
        0x00208628:    f88d7004    ...p    STRB     r7,[sp,#4]
;;;357                callback_data.msg_data.write.opcode = OTA_WRITE_IMAGE_COUNT_VAL;
        0x0020862c:    f88dc006    ....    STRB     r12,[sp,#6]
;;;358                callback_data.msg_data.write.u.update_image_info.image_count = p_value[0];
        0x00208630:    7801        .x      LDRB     r1,[r0,#0]
        0x00208632:    f88d1008    ....    STRB     r1,[sp,#8]
;;;359                callback_data.msg_data.write.u.update_image_info.update_patch_version = CHAR2SHORT(&p_value[1]);
        0x00208636:    7841        Ax      LDRB     r1,[r0,#1]
        0x00208638:    7882        .x      LDRB     r2,[r0,#2]
        0x0020863a:    eb012102    ...!    ADD      r1,r1,r2,LSL #8
        0x0020863e:    f8ad100a    ....    STRH     r1,[sp,#0xa]
;;;360                callback_data.msg_data.write.u.update_image_info.update_app_version = CHAR2SHORT(&p_value[3]);
        0x00208642:    78c1        .x      LDRB     r1,[r0,#3]
        0x00208644:    7900        .y      LDRB     r0,[r0,#4]
        0x00208646:    eb012000    ...     ADD      r0,r1,r0,LSL #8
        0x0020864a:    f8ad000c    ....    STRH     r0,[sp,#0xc]
;;;361    
;;;362                if (pfnOTAExtendedCB)
        0x0020864e:    e009        ..      B        0x208664 ; ota_attr_write_cb + 148
;;;363                {
;;;364                    pfnOTAExtendedCB(service_id, (void *)&callback_data);
;;;365                }
;;;366            }
;;;367        }
;;;368        else if (BLE_SERVICE_CHAR_TEST_MODE_INDEX == attrib_index)
;;;369        {
;;;370            /* Make sure written value size is valid. */
;;;371            if ((length != sizeof(uint8_t)) || (p_value == NULL))
        0x00208650:    2b01        .+      CMP      r3,#1
        0x00208652:    d10d        ..      BNE      0x208670 ; ota_attr_write_cb + 160
        0x00208654:    b160        `.      CBZ      r0,0x208670 ; ota_attr_write_cb + 160
;;;372            {
;;;373                wCause  = APP_RESULT_INVALID_VALUE_SIZE;
;;;374            }
;;;375            else
;;;376            {
;;;377                /* Notify Application. */
;;;378                callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
        0x00208656:    f88d7004    ...p    STRB     r7,[sp,#4]
;;;379                callback_data.msg_data.write.opcode = OTA_WRITE_TEST_MODE_CHAR_VAL;
        0x0020865a:    f88dc006    ....    STRB     r12,[sp,#6]
        0x0020865e:    7800        .x      LDRB     r0,[r0,#0]
        0x00208660:    f88d0008    ....    STRB     r0,[sp,#8]
        0x00208664:    2c00        .,      CMP      r4,#0
        0x00208666:    d0cf        ..      BEQ      0x208608 ; ota_attr_write_cb + 56
;;;380                callback_data.msg_data.write.u.value = p_value[0];
;;;381    
;;;382                if (pfnOTAExtendedCB)
;;;383                {
;;;384                    pfnOTAExtendedCB(service_id, (void *)&callback_data);
        0x00208668:    a901        ..      ADD      r1,sp,#4
        0x0020866a:    4630        0F      MOV      r0,r6
        0x0020866c:    47a0        .G      BLX      r4
        0x0020866e:    e7cb        ..      B        0x208608 ; ota_attr_write_cb + 56
        0x00208670:    460d        .F      MOV      r5,r1
        0x00208672:    e7c9        ..      B        0x208608 ; ota_attr_write_cb + 56
    ota_attr_read_cb
;;;385                }
;;;386            }
;;;387        }
;;;388        else
;;;389        {
;;;390            PROFILE_PRINT_INFO2("--> OTA_AttrWrite Error  iAttribIndex = 0x%x wLength=%d",
;;;391                                attrib_index,
;;;392                                length);
;;;393            wCause = APP_RESULT_ATTR_NOT_FOUND;
;;;394        }
;;;395        return wCause;
;;;396    
;;;397    }
;;;398    
;;;399    
;;;400    #if SUPPORT_OTA_BANK_SWITCH
;;;401    #define MULTI_IMG 1
;;;402    #else
;;;403    #define MULTI_IMG 0
;;;404    #endif
;;;405    extern uint8_t mode;
;;;406    typedef struct _T_DFU_DEVICE_INFO
;;;407    {
;;;408        uint8_t ictype;
;;;409        uint8_t ota_version;
;;;410        uint8_t secure_version;
;;;411    
;;;412        union
;;;413        {
;;;414            uint8_t value;
;;;415            struct
;;;416            {
;;;417                uint8_t buffercheck: 1; // 1:support,  0:don't support
;;;418                uint8_t aesflg: 1;      // 1:aes encrypt when ota,  0:not encrypt
;;;419                uint8_t aesmode: 1;     // 1:all data is encrypted, 0:only encrypt 16byte
;;;420                //uint8_t verify_algo: 1; // 1:sha256,   0:crc
;;;421                uint8_t copy_img: 1;    //1:support ,0:don't support
;;;422                uint8_t multi_img: 1;   //1:support(update multi img at a time) ,0:don't support(one img at a time)
;;;423                uint8_t rsvd: 3;
;;;424            };
;;;425        } mode;
;;;426    
;;;427        uint16_t maxbuffersize;
;;;428        uint16_t res;
;;;429    
;;;430        uint32_t img_indicator;
;;;431    } T_DFU_DEVICE_INFO, * P_DFU_DEVICE_INFO;
;;;432    
;;;433    //#define SUPPORT_BANK_SWITCH
;;;434    /**
;;;435     * @brief read characteristic data from service.
;;;436     *
;;;437     * @param ServiceId          ServiceID of characteristic data.
;;;438     * @param iAttribIndex       Attribute index of getting characteristic data.
;;;439     * @param iOffset            Used for Blob Read.
;;;440     * @param piLength           length of getting characteristic data.
;;;441     * @param ppValue            data got from service.
;;;442     * @return Profile procedure result
;;;443    */
;;;444    T_APP_RESULT ota_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t attrib_index,
;;;445                                  uint16_t offset, uint16_t *p_length, uint8_t **pp_value)
;;;446    {
        0x00208674:    e92d5ffc    -.._    PUSH     {r2-r12,lr}
        0x00208678:    4f7b        {O      LDR      r7,[pc,#492] ; [0x208868] = 0x21103302
;;; ..\..\..\src\app\keyboard\ota_service.c (446)
        0x0020867a:    e9dd540c    ...T    LDRD     r5,r4,[sp,#0x30]
;;;447        T_APP_RESULT  wCause = APP_RESULT_SUCCESS;
        0x0020867e:    f04f0800    O...    MOV      r8,#0
        0x00208682:    f2427a92    B..z    MOV      r10,#0x2792
        0x00208686:    f2427b93    B..{    MOV      r11,#0x2793
;;;448    
;;;449        switch (attrib_index)
        0x0020868a:    2a0a        .*      CMP      r2,#0xa
        0x0020868c:    d064        d.      BEQ      0x208758 ; ota_attr_read_cb + 228
        0x0020868e:    dc09        ..      BGT      0x2086a4 ; ota_attr_read_cb + 48
        0x00208690:    4e73        sN      LDR      r6,[pc,#460] ; [0x208860] = 0x20bb6c
        0x00208692:    2a04        .*      CMP      r2,#4
        0x00208694:    d016        ..      BEQ      0x2086c4 ; ota_attr_read_cb + 80
        0x00208696:    f04f0904    O...    MOV      r9,#4
        0x0020869a:    2a06        .*      CMP      r2,#6
        0x0020869c:    d02c        ,.      BEQ      0x2086f8 ; ota_attr_read_cb + 132
        0x0020869e:    2a08        .*      CMP      r2,#8
        0x002086a0:    d106        ..      BNE      0x2086b0 ; ota_attr_read_cb + 60
        0x002086a2:    e040        @.      B        0x208726 ; ota_attr_read_cb + 178
        0x002086a4:    f2427090    B..p    MOV      r0,#0x2790
        0x002086a8:    2a0e        .*      CMP      r2,#0xe
        0x002086aa:    d058        X.      BEQ      0x20875e ; ota_attr_read_cb + 234
        0x002086ac:    2a12        .*      CMP      r2,#0x12
        0x002086ae:    d078        x.      BEQ      0x2087a2 ; ota_attr_read_cb + 302
;;;450        {
;;;451        default:
;;;452            PROFILE_PRINT_INFO1("<-- OTA_AttrRead, Attr not found, index=%d", attrib_index);
        0x002086b0:    496c        lI      LDR      r1,[pc,#432] ; [0x208864] = 0x8800250
        0x002086b2:    4613        .F      MOV      r3,r2
        0x002086b4:    2201        ."      MOVS     r2,#1
        0x002086b6:    313c        <1      ADDS     r1,r1,#0x3c
        0x002086b8:    4638        8F      MOV      r0,r7
        0x002086ba:    f5fff9d0    ....    BL       log_buffer ; 0x7a5e
;;;453            wCause  = APP_RESULT_ATTR_NOT_FOUND;
        0x002086be:    f240480a    @..H    MOV      r8,#0x40a
;;;454            break;
        0x002086c2:    e049        I.      B        0x208758 ; ota_attr_read_cb + 228
;;;455        case BLE_SERVICE_CHAR_MAC_ADDRESS_INDEX:
;;;456            {
;;;457                gap_get_param(GAP_PARAM_BD_ADDR, mac_addr);
        0x002086c4:    4966        fI      LDR      r1,[pc,#408] ; [0x208860] = 0x20bb6c
        0x002086c6:    f44f7000    O..p    MOV      r0,#0x200
        0x002086ca:    310c        .1      ADDS     r1,r1,#0xc
        0x002086cc:    f643fcb3    C...    BL       gap_get_param ; 0x4c036
        0x002086d0:    4a63        cJ      LDR      r2,[pc,#396] ; [0x208860] = 0x20bb6c
        0x002086d2:    2000        .       MOVS     r0,#0
        0x002086d4:    4669        iF      MOV      r1,sp
        0x002086d6:    320c        .2      ADDS     r2,r2,#0xc
        0x002086d8:    f1c00305    ....    RSB      r3,r0,#5
        0x002086dc:    5cd3        .\      LDRB     r3,[r2,r3]
        0x002086de:    540b        .T      STRB     r3,[r1,r0]
        0x002086e0:    1c40        @.      ADDS     r0,r0,#1
;;;458                uint8_t addr[6];
;;;459                for (int i = 0; i < 6; i++)
        0x002086e2:    2806        .(      CMP      r0,#6
        0x002086e4:    dbf8        ..      BLT      0x2086d8 ; ota_attr_read_cb + 100
;;;460                {
;;;461                    addr[i] = mac_addr[5 - i];
;;;462                }
;;;463                memcpy(mac_addr, addr, 6);
        0x002086e6:    9800        ..      LDR      r0,[sp,#0]
        0x002086e8:    60f0        .`      STR      r0,[r6,#0xc]
        0x002086ea:    f8bd0004    ....    LDRH     r0,[sp,#4]
        0x002086ee:    8230        0.      STRH     r0,[r6,#0x10]
;;;464                *pp_value  = (uint8_t *)mac_addr;
;;;465                *p_length = sizeof(mac_addr);
        0x002086f0:    2006        .       MOVS     r0,#6
        0x002086f2:    6022        "`      STR      r2,[r4,#0]
        0x002086f4:    8028        (.      STRH     r0,[r5,#0]
        0x002086f6:    e02f        /.      B        0x208758 ; ota_attr_read_cb + 228
;;;466            }
;;;467            break;
;;;468        case BLE_SERVICE_CHAR_PATCH_INDEX:
;;;469            {
;;;470                T_IMG_HEADER_FORMAT *p_header;
;;;471                uint32_t addr = get_header_addr_by_img_id(RomPatch);
        0x002086f8:    4650        PF      MOV      r0,r10
        0x002086fa:    f604f873    ..s.    BL       get_header_addr_by_img_id ; 0xc7e4
        0x002086fe:    4959        YI      LDR      r1,[pc,#356] ; [0x208864] = 0x8800250
        0x00208700:    4682        .F      MOV      r10,r0
;;;472                PROFILE_PRINT_INFO1("patch_addr = %x", addr);
        0x00208702:    4603        .F      MOV      r3,r0
        0x00208704:    2201        ."      MOVS     r2,#1
        0x00208706:    316c        l1      ADDS     r1,r1,#0x6c
        0x00208708:    4638        8F      MOV      r0,r7
        0x0020870a:    f5fff9a8    ....    BL       log_buffer ; 0x7a5e
        0x0020870e:    4955        UI      LDR      r1,[pc,#340] ; [0x208864] = 0x8800250
;;;473                p_header = (T_IMG_HEADER_FORMAT *)addr;
;;;474    
;;;475                patch_version = p_header->git_ver.ver_info.version;
        0x00208710:    f8da3060    ..`0    LDR      r3,[r10,#0x60]
;;;476    
;;;477                PROFILE_PRINT_INFO1("patch_version = %x", patch_version);
        0x00208714:    2201        ."      MOVS     r2,#1
        0x00208716:    3180        .1      ADDS     r1,r1,#0x80
        0x00208718:    4638        8F      MOV      r0,r7
        0x0020871a:    6073        s`      STR      r3,[r6,#4]
        0x0020871c:    f5fff99f    ....    BL       log_buffer ; 0x7a5e
;;;478                *pp_value  = (uint8_t *)&patch_version;
        0x00208720:    484f        OH      LDR      r0,[pc,#316] ; [0x208860] = 0x20bb6c
        0x00208722:    1d00        ..      ADDS     r0,r0,#4
;;;479                *p_length = sizeof(patch_version);
;;;480            }
;;;481            break;
        0x00208724:    e015        ..      B        0x208752 ; ota_attr_read_cb + 222
;;;482    
;;;483        case BLE_SERVICE_CHAR_APP_VERSION_INDEX:
;;;484            {
;;;485                T_IMG_HEADER_FORMAT *p_header;
;;;486                uint32_t addr = get_header_addr_by_img_id(AppPatch);
        0x00208726:    4658        XF      MOV      r0,r11
        0x00208728:    f604f85c    ..\.    BL       get_header_addr_by_img_id ; 0xc7e4
        0x0020872c:    494d        MI      LDR      r1,[pc,#308] ; [0x208864] = 0x8800250
        0x0020872e:    4682        .F      MOV      r10,r0
;;;487                PROFILE_PRINT_INFO1("app_addr = %x", addr);
        0x00208730:    4603        .F      MOV      r3,r0
        0x00208732:    2201        ."      MOVS     r2,#1
        0x00208734:    3198        .1      ADDS     r1,r1,#0x98
        0x00208736:    4638        8F      MOV      r0,r7
        0x00208738:    f5fff991    ....    BL       log_buffer ; 0x7a5e
        0x0020873c:    4949        II      LDR      r1,[pc,#292] ; [0x208864] = 0x8800250
;;;488                p_header = (T_IMG_HEADER_FORMAT *)addr;
;;;489    
;;;490    //        uint32_t _version_major: 4;     //!< major version
;;;491    //        uint32_t _version_minor: 8;     //!< minor version
;;;492    //        uint32_t _version_revision: 15; //!< revision version
;;;493    //        uint32_t _version_reserve: 5;   //!< reserved
;;;494    
;;;495                app_version = p_header->git_ver.ver_info.version;
        0x0020873e:    f8da3060    ..`0    LDR      r3,[r10,#0x60]
;;;496    
;;;497                PROFILE_PRINT_INFO1("app_version = %x", app_version);
        0x00208742:    2201        ."      MOVS     r2,#1
        0x00208744:    31ac        .1      ADDS     r1,r1,#0xac
        0x00208746:    4638        8F      MOV      r0,r7
        0x00208748:    60b3        .`      STR      r3,[r6,#8]
        0x0020874a:    f5fff988    ....    BL       log_buffer ; 0x7a5e
;;;498                *pp_value  = (uint8_t *)&app_version;
        0x0020874e:    4844        DH      LDR      r0,[pc,#272] ; [0x208860] = 0x20bb6c
        0x00208750:    3008        .0      ADDS     r0,r0,#8
        0x00208752:    6020         `      STR      r0,[r4,#0]
        0x00208754:    f8a59000    ....    STRH     r9,[r5,#0]
        0x00208758:    4640        @F      MOV      r0,r8
        0x0020875a:    e8bd9ffc    ....    POP      {r2-r12,pc}
;;;499                *p_length = sizeof(app_version);
;;;500            }
;;;501            break;
;;;502    
;;;503        case BLE_SERVICE_CHAR_PATCH_EXTENSION_INDEX:        //not used in bee2
;;;504            {
;;;505    
;;;506            }
;;;507            break;
;;;508        case BLE_SERVICE_CHAR_DEVICE_INFO_INDEX:
;;;509            {
;;;510                static T_DFU_DEVICE_INFO DeviceInfo;
;;;511                T_IMG_HEADER_FORMAT *p_header;
;;;512                uint32_t addr = get_header_addr_by_img_id(OTA);
        0x0020875e:    f604f841    ..A.    BL       get_header_addr_by_img_id ; 0xc7e4
        0x00208762:    4e3f        ?N      LDR      r6,[pc,#252] ; [0x208860] = 0x20bb6c
        0x00208764:    7841        Ax      LDRB     r1,[r0,#1]
        0x00208766:    3614        .6      ADDS     r6,r6,#0x14
        0x00208768:    4603        .F      MOV      r3,r0
;;;513                p_header = (T_IMG_HEADER_FORMAT *)addr;
;;;514                DeviceInfo.secure_version = p_header->ctrl_header.secure_version;
        0x0020876a:    70b1        .p      STRB     r1,[r6,#2]
;;;515    
;;;516                DeviceInfo.ictype = 5;
        0x0020876c:    2105        .!      MOVS     r1,#5
        0x0020876e:    7031        1p      STRB     r1,[r6,#0]
;;;517                DeviceInfo.ota_version = 0x1;
        0x00208770:    2101        .!      MOVS     r1,#1
        0x00208772:    7071        qp      STRB     r1,[r6,#1]
;;;518                DeviceInfo.secure_version = p_header->ctrl_header.secure_version;
        0x00208774:    7840        @x      LDRB     r0,[r0,#1]
        0x00208776:    70b0        .p      STRB     r0,[r6,#2]
;;;519                DeviceInfo.mode.buffercheck = 1;
        0x00208778:    78f0        .x      LDRB     r0,[r6,#3]
        0x0020877a:    460a        .F      MOV      r2,r1
;;;520                DeviceInfo.mode.aesflg = 1;
;;;521                DeviceInfo.mode.aesmode = 1;
;;;522                // DeviceInfo.mode.verify_algo = 0;//crc    need to delete this feature;
;;;523                DeviceInfo.mode.copy_img = 0;
        0x0020877c:    f0200018     ...    BIC      r0,r0,#0x18
;;;524                DeviceInfo.mode.multi_img = MULTI_IMG;
        0x00208780:    f0400007    @...    ORR      r0,r0,#7
        0x00208784:    70f0        .p      STRB     r0,[r6,#3]
;;;525                DeviceInfo.maxbuffersize = 2048;
        0x00208786:    02c8        ..      LSLS     r0,r1,#11
        0x00208788:    4936        6I      LDR      r1,[pc,#216] ; [0x208864] = 0x8800250
        0x0020878a:    80b0        ..      STRH     r0,[r6,#4]
;;;526                PROFILE_PRINT_INFO1("otaheader_addr = %x", addr);
        0x0020878c:    31c0        .1      ADDS     r1,r1,#0xc0
        0x0020878e:    4638        8F      MOV      r0,r7
        0x00208790:    f5fff965    ..e.    BL       log_buffer ; 0x7a5e
;;;527    #if SUPPORT_OTA_BANK_SWITCH
;;;528                if ((addr & 0xffffff) == OTA_BANK0_ADDR)
;;;529                {
;;;530                    DeviceInfo.img_indicator = IMAGE_LOCATION_BANK0 << (OTA_HEADER * 2) | IMAGE_LOCATION_BANK0 <<
;;;531                                               (ROM_PATCH * 2) | IMAGE_LOCATION_BANK0 <<
;;;532                                               (APP_IMG * 2);
;;;533                }
;;;534                else
;;;535                {
;;;536                    DeviceInfo.img_indicator = IMAGE_LOCATION_BANK1 << (OTA_HEADER * 2) | IMAGE_LOCATION_BANK1 <<
;;;537                                               (ROM_PATCH * 2) | IMAGE_LOCATION_BANK1 <<
;;;538                                               (APP_IMG * 2);
;;;539                }
;;;540    #else
;;;541                DeviceInfo.img_indicator = IMAGE_FIX_BANK_EXIST << (OTA_HEADER * 2) | IMAGE_FIX_BANK_EXIST <<
        0x00208794:    f44f6073    O.s`    MOV      r0,#0xf30
;;;542                                           (ROM_PATCH * 2) | IMAGE_FIX_BANK_EXIST <<
;;;543                                           (APP_IMG * 2);
;;;544    #endif
;;;545                *pp_value  = (uint8_t *)&DeviceInfo;
        0x00208798:    60b0        .`      STR      r0,[r6,#8]
;;;546                *p_length = sizeof(T_DFU_DEVICE_INFO);
        0x0020879a:    200c        .       MOVS     r0,#0xc
;;;547            }
;;;548            break;
        0x0020879c:    6026        &`      STR      r6,[r4,#0]
        0x0020879e:    e7a9        ..      B        0x2086f4 ; ota_attr_read_cb + 128
        0x002087a0:    e7ff        ..      B        0x2087a2 ; ota_attr_read_cb + 302
;;;549        case BLE_SERVICE_CHAR_IMAGE_VERSION_INDEX:
;;;550            {
;;;551                T_IMG_HEADER_FORMAT *p_imgheader;
;;;552                T_OTA_HEADER_FORMAT *p_otaheader;
;;;553                static uint32_t version[5];
;;;554    
;;;555    
;;;556                uint32_t addr = get_header_addr_by_img_id(OTA);
        0x002087a2:    f604f81f    ....    BL       get_header_addr_by_img_id ; 0xc7e4
        0x002087a6:    492f        /I      LDR      r1,[pc,#188] ; [0x208864] = 0x8800250
        0x002087a8:    4606        .F      MOV      r6,r0
;;;557                PROFILE_PRINT_INFO1("otaheader_addr = %x", addr);
        0x002087aa:    4603        .F      MOV      r3,r0
        0x002087ac:    2201        ."      MOVS     r2,#1
        0x002087ae:    31d8        .1      ADDS     r1,r1,#0xd8
        0x002087b0:    4638        8F      MOV      r0,r7
        0x002087b2:    f5fff954    ..T.    BL       log_buffer ; 0x7a5e
;;;558                p_otaheader = (T_OTA_HEADER_FORMAT *)addr;
;;;559    
;;;560                version[0] = p_otaheader->ver_val;
        0x002087b6:    f8d63194    ...1    LDR      r3,[r6,#0x194]
        0x002087ba:    4e29        )N      LDR      r6,[pc,#164] ; [0x208860] = 0x20bb6c
        0x002087bc:    4929        )I      LDR      r1,[pc,#164] ; [0x208864] = 0x8800250
        0x002087be:    3620         6      ADDS     r6,r6,#0x20
;;;561    
;;;562                PROFILE_PRINT_INFO1("otaheader_version = %x", version[0]);
        0x002087c0:    2201        ."      MOVS     r2,#1
        0x002087c2:    31f0        .1      ADDS     r1,r1,#0xf0
        0x002087c4:    4638        8F      MOV      r0,r7
        0x002087c6:    6033        3`      STR      r3,[r6,#0]
        0x002087c8:    f5fff949    ..I.    BL       log_buffer ; 0x7a5e
;;;563    
;;;564                addr = get_header_addr_by_img_id(RomPatch);
        0x002087cc:    4650        PF      MOV      r0,r10
        0x002087ce:    f604f809    ....    BL       get_header_addr_by_img_id ; 0xc7e4
        0x002087d2:    4681        .F      MOV      r9,r0
;;;565                PROFILE_PRINT_INFO1("patch_addr = %x", addr);
        0x002087d4:    4603        .F      MOV      r3,r0
        0x002087d6:    2201        ."      MOVS     r2,#1
        0x002087d8:    4924        $I      LDR      r1,[pc,#144] ; [0x20886c] = 0x880035c
        0x002087da:    4638        8F      MOV      r0,r7
        0x002087dc:    f5fff93f    ..?.    BL       log_buffer ; 0x7a5e
        0x002087e0:    4922        "I      LDR      r1,[pc,#136] ; [0x20886c] = 0x880035c
;;;566                p_imgheader = (T_IMG_HEADER_FORMAT *)addr;
;;;567    
;;;568                version[1] = p_imgheader->git_ver.ver_info.version;
        0x002087e2:    f8d93060    ..`0    LDR      r3,[r9,#0x60]
;;;569    
;;;570                PROFILE_PRINT_INFO1("patch_version = %x", version[1]);
        0x002087e6:    2201        ."      MOVS     r2,#1
        0x002087e8:    3114        .1      ADDS     r1,r1,#0x14
        0x002087ea:    4638        8F      MOV      r0,r7
        0x002087ec:    6073        s`      STR      r3,[r6,#4]
        0x002087ee:    f5fff936    ..6.    BL       log_buffer ; 0x7a5e
;;;571    
;;;572                addr = get_header_addr_by_img_id(AppPatch);
        0x002087f2:    4658        XF      MOV      r0,r11
        0x002087f4:    f603fff6    ....    BL       get_header_addr_by_img_id ; 0xc7e4
        0x002087f8:    491c        .I      LDR      r1,[pc,#112] ; [0x20886c] = 0x880035c
        0x002087fa:    4681        .F      MOV      r9,r0
;;;573                PROFILE_PRINT_INFO1("app_addr = %x", addr);
        0x002087fc:    4603        .F      MOV      r3,r0
        0x002087fe:    2201        ."      MOVS     r2,#1
        0x00208800:    312c        ,1      ADDS     r1,r1,#0x2c
        0x00208802:    4638        8F      MOV      r0,r7
        0x00208804:    f5fff92b    ..+.    BL       log_buffer ; 0x7a5e
        0x00208808:    4918        .I      LDR      r1,[pc,#96] ; [0x20886c] = 0x880035c
;;;574                p_imgheader = (T_IMG_HEADER_FORMAT *)addr;
;;;575    
;;;576                version[2] = p_imgheader->git_ver.ver_info.version;
        0x0020880a:    f8d93060    ..`0    LDR      r3,[r9,#0x60]
;;;577    
;;;578                PROFILE_PRINT_INFO1("app_version = %x", version[2]);
        0x0020880e:    2201        ."      MOVS     r2,#1
        0x00208810:    3140        @1      ADDS     r1,r1,#0x40
        0x00208812:    4638        8F      MOV      r0,r7
        0x00208814:    60b3        .`      STR      r3,[r6,#8]
        0x00208816:    f5fff922    ..".    BL       log_buffer ; 0x7a5e
;;;579    
;;;580    //            uint32_t addr = get_header_addr_by_img_id(OTA);
;;;581    //            PROFILE_PRINT_INFO1("active Bank Addr  = %x", addr);
;;;582    
;;;583    //            T_OTA_HEADER_FORMAT *p_ota_header;
;;;584    //            p_ota_header = (T_OTA_HEADER_FORMAT *)addr;
;;;585    //            PROFILE_PRINT_INFO1("ota_header_addr = %x", addr);
;;;586    //            DeviceInfo.ota_header_version = p_ota_header->ver_val;
;;;587    
;;;588    //            addr = get_header_addr_by_img_id(AppData1);
;;;589    //            p_header = (T_IMG_HEADER_FORMAT *)addr;
;;;590    //            PROFILE_PRINT_INFO1("appdata0_addr = %x", addr);
;;;591    
;;;592    //            DeviceInfo.app_data0_version = p_header->git_ver.ver_info.version;;
;;;593    
;;;594                *pp_value  = (uint8_t *)version;
;;;595                *p_length = 8;
        0x0020881a:    2008        .       MOVS     r0,#8
;;;596    
;;;597            }
;;;598            break;
        0x0020881c:    6026        &`      STR      r6,[r4,#0]
        0x0020881e:    e769        i.      B        0x2086f4 ; ota_attr_read_cb + 128
    ota_add_service
;;;599        }
;;;600        return (wCause);
;;;601    }
;;;602    
;;;603    
;;;604    /**
;;;605     * @brief OTA ble Service Callbacks.
;;;606    */
;;;607    const T_FUN_GATT_SERVICE_CBS OTAServiceCBs =
;;;608    {
;;;609        ota_attr_read_cb,   // Read callback function pointer
;;;610        ota_attr_write_cb,  // Write callback function pointer
;;;611        NULL                    // CCCD update callback function pointer
;;;612    };
;;;613    
;;;614    /**
;;;615     * @brief  add OTA ble service to application.
;;;616     *
;;;617     * @param  pFunc          pointer of app callback function called by profile.
;;;618     * @return service ID auto generated by profile layer.
;;;619     * @retval ServiceId
;;;620    */
;;;621    uint8_t ota_add_service(void *pFunc)
;;;622    {
        0x00208820:    b53e        >.      PUSH     {r1-r5,lr}
        0x00208822:    4604        .F      MOV      r4,r0
;;;623        uint8_t ServiceId;
;;;624        if (false == server_add_service(&ServiceId,
        0x00208824:    4812        .H      LDR      r0,[pc,#72] ; [0x208870] = 0x20b74c
        0x00208826:    e9d01206    ....    LDRD     r1,r2,[r0,#0x18]
        0x0020882a:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0020882e:    f5a07100    ...q    SUB      r1,r0,#0x200
        0x00208832:    6943        Ci      LDR      r3,[r0,#0x14]
        0x00208834:    f44f7205    O..r    MOV      r2,#0x214
        0x00208838:    a802        ..      ADD      r0,sp,#8
        0x0020883a:    f646ff18    F...    BL       server_add_service ; 0x4f66e
        0x0020883e:    b120         .      CBZ      r0,0x20884a ; ota_add_service + 42
        0x00208840:    4807        .H      LDR      r0,[pc,#28] ; [0x208860] = 0x20bb6c
        0x00208842:    6004        .`      STR      r4,[r0,#0]
        0x00208844:    f89d0008    ....    LDRB     r0,[sp,#8]
        0x00208848:    bd3e        >.      POP      {r1-r5,pc}
;;;625                                        (uint8_t *)gattOtaServiceTable,
;;;626                                        sizeof(gattOtaServiceTable),
;;;627                                        OTAServiceCBs))
;;;628        {
;;;629            PROFILE_PRINT_ERROR1("OTAService_AddService: ServiceId %d", ServiceId);
        0x0020884a:    4908        .I      LDR      r1,[pc,#32] ; [0x20886c] = 0x880035c
        0x0020884c:    4806        .H      LDR      r0,[pc,#24] ; [0x208868] = 0x21103302
        0x0020884e:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x00208852:    2201        ."      MOVS     r2,#1
        0x00208854:    3154        T1      ADDS     r1,r1,#0x54
        0x00208856:    1e80        ..      SUBS     r0,r0,#2
        0x00208858:    f5fff901    ....    BL       log_buffer ; 0x7a5e
;;;630            ServiceId = 0xff;
        0x0020885c:    20ff        .       MOVS     r0,#0xff
;;;631            return ServiceId;
;;;632        }
;;;633        pfnOTAExtendedCB = (P_FUN_SERVER_GENERAL_CB)pFunc;
;;;634        return ServiceId;
;;;635    }
        0x0020885e:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x00208860:    0020bb6c    l. .    DCD    2145132
        0x00208864:    08800250    P...    DCD    142606928
        0x00208868:    21103302    .3.!    DCD    554709762
        0x0020886c:    0880035c    \...    DCD    142607196
        0x00208870:    0020b74c    L. .    DCD    2144076
    $t
    .text
    DLPS_IO_EnterDlpsCb
;;; .\..\..\..\src\mcu\peripheral\rtl876x_io_dlps.c
;;;1832   {
        0x00208874:    b57c        |.      PUSH     {r2-r6,lr}
;;; ..\..\..\inc\platform\cmsis\core_cm4.h
;;;1659       NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
        0x00208876:    2400        .$      MOVS     r4,#0
        0x00208878:    f04f20e0    O..     MOV      r0,#0xe000e000
        0x0020887c:    2101        .!      MOVS     r1,#1
        0x0020887e:    f8c01180    ....    STR      r1,[r0,#0x180]
;;; .\..\..\..\src\mcu\peripheral\rtl876x_io_dlps.c
;;;51         CPU_StoreReg[0] = NVIC->ISER[0];
        0x00208882:    f8d02100    ...!    LDR      r2,[r0,#0x100]
        0x00208886:    493e        >I      LDR      r1,[pc,#248] ; [0x208980] = 0x20bbac
;;;52         CPU_StoreReg[1] = NVIC->ISPR[0];
        0x00208888:    600a        .`      STR      r2,[r1,#0]
        0x0020888a:    f8d02200    ..."    LDR      r2,[r0,#0x200]
;;;53         CPU_StoreReg[2] = NVIC->IABR[0];
        0x0020888e:    604a        J`      STR      r2,[r1,#4]
        0x00208890:    f8d00300    ....    LDR      r0,[r0,#0x300]
;;;54     
;;;55         //The priority of system on interrupt is 0 at first DLPS ENTER CB, so store and restore is skipped
;;;56         for (i = 3; i < 32; ++i)  //skip System_IRQn, WDG_IRQn, BTMAC_IRQn which are handled in rom
        0x00208894:    6088        .`      STR      r0,[r1,#8]
        0x00208896:    2003        .       MOVS     r0,#3
;;;57         {
;;;58             CPU_StoreReg[i] = NVIC->IP[i];
        0x00208898:    f10022e0    ..."    ADD      r2,r0,#0xe000e000
        0x0020889c:    f8922400    ...$    LDRB     r2,[r2,#0x400]
        0x002088a0:    f8412020    A.      STR      r2,[r1,r0,LSL #2]
        0x002088a4:    1c40        @.      ADDS     r0,r0,#1
;;; .\..\..\..\src\mcu\peripheral\rtl876x_io_dlps.c (56)
        0x002088a6:    2820         (      CMP      r0,#0x20
        0x002088a8:    d3f6        ..      BCC      0x208898 ; DLPS_IO_EnterDlpsCb + 36
;;;57         {
;;;58             CPU_StoreReg[i] = NVIC->IP[i];
;;;59         }
;;;60     
;;;61         CPU_StoreReg[32] = SCB->VTOR;
        0x002088aa:    4836        6H      LDR      r0,[pc,#216] ; [0x208984] = 0xe000ed08
        0x002088ac:    6800        .h      LDR      r0,[r0,#0]
;;;62         /* Save Vendor register */
;;;63         PeriIntStoreReg = PERIPHINT->EN;
        0x002088ae:    f8c10080    ....    STR      r0,[r1,#0x80]
        0x002088b2:    4835        5H      LDR      r0,[pc,#212] ; [0x208988] = 0x40006000
        0x002088b4:    68c0        .h      LDR      r0,[r0,#0xc]
        0x002088b6:    4b32        2K      LDR      r3,[pc,#200] ; [0x208980] = 0x20bbac
        0x002088b8:    3b0c        .;      SUBS     r3,r3,#0xc
;;;64     
;;;65         return;
;;;66     }
;;;67     
;;;68     /**
;;;69       * @brief  CPU exit dlps callback function(Resume CPU register values when system exit DLPS)
;;;70       * @param  None
;;;71       * @retval None
;;;72       */
;;;73     DATA_RAM_FUNCTION __STATIC_INLINE  void CPU_DLPS_Exit(void)
;;;74     {
;;;75         //NVIC restore
;;;76         uint32_t i;
;;;77     
;;;78         //Don't restore NVIC pending register, but report warning
;;;79         //NVIC->ISPR[0] = CPU_StoreReg[1];
;;;80         if (CPU_StoreReg[1])
;;;81         {
;;;82             DLPS_PRINT_WARN1("miss interrupt: pending register: 0x%x", CPU_StoreReg[1]);
;;;83         }
;;;84     //    NVIC->IABR[0] = CPU_StoreReg[2];
;;;85     
;;;86         //The priority of system on interrupt is 0 at first DLPS ENTER CB, so store and restore is skipped
;;;87         for (i = 3; i < 32; ++i) //skip System_IRQn, WDG_IRQn, BTMAC_IRQn which are handled in rom
;;;88         {
;;;89             NVIC->IP[i] = CPU_StoreReg[i];
;;;90         }
;;;91     
;;;92         SCB->VTOR = CPU_StoreReg[32];
;;;93         PERIPHINT->EN = PeriIntStoreReg;
;;;94         NVIC->ISER[0] = CPU_StoreReg[0];
;;;95     
;;;96         void debug_monitor_enable(void);
;;;97         debug_monitor_enable();
;;;98         return;
;;;99     }
;;;100    
;;;101    /**
;;;102      * @brief  PINMUX enter dlps callback function(Save PINMUX register values when system enter DLPS)
;;;103      * @param  None
;;;104      * @retval None
;;;105      */
;;;106    __STATIC_INLINE  void Pinmux_DLPS_Enter(void)
;;;107    {
;;;108        uint8_t i = 0;
;;;109    
;;;110        for (i = 0; i < 10; i++)
;;;111        {
;;;112            Pinmux_StoreReg[i] = PINMUX->CFG[i];
        0x002088ba:    f1030190    ....    ADD      r1,r3,#0x90
;;; .\..\..\..\src\mcu\peripheral\rtl876x_io_dlps.c (108)
        0x002088be:    6018        .`      STR      r0,[r3,#0]
        0x002088c0:    2000        .       MOVS     r0,#0
;;;109    
;;;110        for (i = 0; i < 10; i++)
;;;111        {
;;;112            Pinmux_StoreReg[i] = PINMUX->CFG[i];
        0x002088c2:    0082        ..      LSLS     r2,r0,#2
        0x002088c4:    f1024280    ...B    ADD      r2,r2,#0x40000000
        0x002088c8:    f8d22280    ..."    LDR      r2,[r2,#0x280]
        0x002088cc:    f8412020    A.      STR      r2,[r1,r0,LSL #2]
        0x002088d0:    1c40        @.      ADDS     r0,r0,#1
;;; .\..\..\..\src\mcu\peripheral\rtl876x_io_dlps.c (110)
        0x002088d2:    b2c0        ..      UXTB     r0,r0
;;; .\..\..\..\src\mcu\peripheral\rtl876x_io_dlps.c (110)
        0x002088d4:    280a        .(      CMP      r0,#0xa
        0x002088d6:    d3f4        ..      BCC      0x2088c2 ; DLPS_IO_EnterDlpsCb + 78
;;;111        {
;;;112            Pinmux_StoreReg[i] = PINMUX->CFG[i];
;;;113        }
;;;114    
;;;115        return;
;;;116    }
;;;117    
;;;118    /**
;;;119      * @brief  PINMUX exit dlps callback function(Resume PINMUX register values when system exit DLPS)
;;;120      * @param  None
;;;121      * @retval None
;;;122      */
;;;123    DATA_RAM_FUNCTION __STATIC_INLINE  void Pinmux_DLPS_Exit(void)
;;;124    {
;;;125        uint8_t i;
;;;126    
;;;127        for (i = 0; i < 10; i++)
;;;128        {
;;;129            PINMUX->CFG[i] = Pinmux_StoreReg[i];
;;;130        }
;;;131    
;;;132        return;
;;;133    }
;;;134    #endif
;;;135    
;;;136    /********************************************** ********************************************************/
;;;137    /**************************************** [GPIO DLPS] **************************************************/
;;;138    /*******************************************************************************************************/
;;;139    /*******************************************************************************************************/
;;;140    #if USE_GPIO_DLPS
;;;141    
;;;142    __STATIC_INLINE void GPIO_DLPS_Enter(void);
;;;143    __STATIC_INLINE void GPIO_DLPS_Exit(void);
;;;144    
;;;145    uint32_t GPIO_StoreReg[9];         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;146    
;;;147    /**
;;;148      * @brief  GPIO enter dlps callback function(Save GPIO register values when system enter DLPS)
;;;149      * @param  None
;;;150      * @retval None
;;;151      */
;;;152    __STATIC_INLINE void GPIO_DLPS_Enter(void)
;;;153    {
;;;154        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;155        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;156    
;;;157        GPIO_StoreReg[0] = GPIO->DATAOUT;
;;;158        GPIO_StoreReg[1] = GPIO->DATADIR;
;;;159        GPIO_StoreReg[2] = GPIO->DATASRC;
;;;160        GPIO_StoreReg[3] = GPIO->INTEN;
;;;161        GPIO_StoreReg[4] = GPIO->INTMASK;
;;;162        GPIO_StoreReg[5] = GPIO->INTTYPE;
;;;163        GPIO_StoreReg[6] = GPIO->INTPOLARITY;
;;;164        GPIO_StoreReg[7] = GPIO->DEBOUNCE;
;;;165        GPIO_StoreReg[8] = *(__IO uint32_t *)(0x40000344UL);
;;;166    
;;;167        return;
;;;168    }
;;;169    
;;;170    /**
;;;171      * @brief  GPIO exit dlps callback function(Resume GPIO register values when system exit DLPS)
;;;172      * @param  None
;;;173      * @retval None
;;;174      */
;;;175    DATA_RAM_FUNCTION __STATIC_INLINE void GPIO_DLPS_Exit(void)
;;;176    {
;;;177        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;178        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;179    
;;;180        GPIO->DATADIR       = GPIO_StoreReg[1];
;;;181        GPIO->DATASRC       = GPIO_StoreReg[2];
;;;182        GPIO->INTMASK       = GPIO_StoreReg[4];
;;;183        GPIO->INTTYPE       = GPIO_StoreReg[5];
;;;184        GPIO->INTPOLARITY   = GPIO_StoreReg[6];
;;;185        GPIO->DEBOUNCE      = GPIO_StoreReg[7];
;;;186        GPIO->DATAOUT       = GPIO_StoreReg[0];
;;;187        GPIO->INTCLR        = ~(GPIO_StoreReg[1]);
;;;188        GPIO->INTEN         = GPIO_StoreReg[3];
;;;189        *(__IO uint32_t *)(0x40000344UL) = GPIO_StoreReg[8];
;;;190    
;;;191        return;
;;;192    }
;;;193    #endif  /* USE_GPIO_DLPS */
;;;194    
;;;195    
;;;196    /********************************************** ********************************************************/
;;;197    /**************************************** [KEYSCAN DLPS] ***********************************************/
;;;198    /*******************************************************************************************************/
;;;199    /*******************************************************************************************************/
;;;200    #if USE_KEYSCAN_DLPS
;;;201    __STATIC_INLINE void KeyScan_DLPS_Enter(void);
;;;202    __STATIC_INLINE void KeyScan_DLPS_Exit(void);
;;;203    
;;;204    uint32_t KeyScan_StoreReg[7];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;205    
;;;206    /**
;;;207      * @brief  KEYSCAN enter dlps callback function(Save KEYSCAN register values when system enter DLPS)
;;;208      * @param  None
;;;209      * @retval None
;;;210      */
;;;211    __STATIC_INLINE void KeyScan_DLPS_Enter(void)
;;;212    {
;;;213        /*Open 5M clock source*/
;;;214        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;215        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;216    
;;;217        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;218        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;219    
;;;220        KeyScan_StoreReg[0] = KEYSCAN->CLKDIV;               /* 0x00 */
;;;221        KeyScan_StoreReg[1] = KEYSCAN->TIMERCR;              /* 0x04 */
;;;222        KeyScan_StoreReg[2] = KEYSCAN->CR;                   /* 0x08 */
;;;223        KeyScan_StoreReg[3] = KEYSCAN->COLCR;                /* 0x0C */
;;;224        KeyScan_StoreReg[4] = KEYSCAN->ROWCR;                /* 0x10 */
;;;225        KeyScan_StoreReg[6] = KEYSCAN->INTMASK;              /* 0x18 */
;;;226    
;;;227        return;
;;;228    }
;;;229    
;;;230    /**
;;;231      * @brief  KEYSCAN exit dlps callback function(Resume KEYSCAN register values when system exit DLPS)
;;;232      * @param  None
;;;233      * @retval None
;;;234      */
;;;235    DATA_RAM_FUNCTION __STATIC_INLINE void KeyScan_DLPS_Exit(void)
;;;236    {
;;;237        /*Open 5M clock source*/
;;;238        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;239        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;240    
;;;241        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;242        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;243    
;;;244        /* Set FSM to idle state */
;;;245        KEYSCAN->CR &= ~BIT31;
;;;246        KEYSCAN->CLKDIV = KeyScan_StoreReg[0];
;;;247        KEYSCAN->CR = (KeyScan_StoreReg[2] & (~(BIT31)));
;;;248        KEYSCAN->TIMERCR = KeyScan_StoreReg[1];
;;;249        KEYSCAN->COLCR = KeyScan_StoreReg[3];
;;;250        KEYSCAN->ROWCR = KeyScan_StoreReg[4];
;;;251        KEYSCAN->INTMASK = KeyScan_StoreReg[6];
;;;252        KEYSCAN->CR |= (KeyScan_StoreReg[2] & ((BIT31)));
;;;253    
;;;254        return;
;;;255    }
;;;256    #endif /* USE_KEYSCAN_DLPS */
;;;257    
;;;258    
;;;259    /********************************************** ********************************************************/
;;;260    /**************************************** [QDEC DLPS] **************************************************/
;;;261    /*******************************************************************************************************/
;;;262    /*******************************************************************************************************/
;;;263    #if USE_QDECODER_DLPS
;;;264    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void);
;;;265    __STATIC_INLINE void QuadDecoder_DLPS_Exit(void);
;;;266    
;;;267    uint32_t QuadDecoder_StoreReg[5];  /*  This array should be placed in RAM ON/Buffer ON.    */
;;;268    
;;;269    /**
;;;270      * @brief  QDEC enter dlps callback function(Save QDEC register values when system enter DLPS)
;;;271      * @param  None
;;;272      * @retval None
;;;273      */
;;;274    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void)
;;;275    {
;;;276        /*Open 20M clock source*/
;;;277        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;278        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;279        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;280        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;281    
;;;282        QuadDecoder_StoreReg[0] = QDEC->REG_DIV;
;;;283        QuadDecoder_StoreReg[1] = QDEC->REG_CR_X;
;;;284        QuadDecoder_StoreReg[2] = QDEC->REG_CR_Y;
;;;285        QuadDecoder_StoreReg[3] = QDEC->REG_CR_Z;
;;;286        QuadDecoder_StoreReg[4] = QDEC->INT_MASK;
;;;287    
;;;288        return;
;;;289    }
;;;290    
;;;291    /**
;;;292      * @brief  QDEC exit dlps callback function(Resume QDEC register values when system exit DLPS)
;;;293      * @param  None
;;;294      * @retval None
;;;295      */
;;;296    DATA_RAM_FUNCTION __STATIC_INLINE void QuadDecoder_DLPS_Exit(void)
;;;297    {
;;;298        /*Open 20M clock source*/
;;;299        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;300        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;301        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;302        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;303    
;;;304        //clear flags
;;;305        QDEC->REG_DIV  = QuadDecoder_StoreReg[0];
;;;306        QDEC->REG_CR_X = QuadDecoder_StoreReg[1];
;;;307        QDEC->REG_CR_Y = QuadDecoder_StoreReg[2];
;;;308        QDEC->REG_CR_Z = QuadDecoder_StoreReg[3];
;;;309        QDEC->INT_MASK = QuadDecoder_StoreReg[4];
;;;310    
;;;311        return;
;;;312    }
;;;313    #endif
;;;314    
;;;315    /********************************************** ********************************************************/
;;;316    /**************************************** [SPI0 DLPS] **************************************************/
;;;317    /*******************************************************************************************************/
;;;318    /*******************************************************************************************************/
;;;319    #if USE_SPI0_DLPS
;;;320    __STATIC_INLINE void SPI0_DLPS_Enter(void);
;;;321    __STATIC_INLINE void SPI0_DLPS_Exit(void);
;;;322    
;;;323    uint32_t SPI0_StoreReg[13];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;324    
;;;325    /**
;;;326      * @brief  SPI0 enter dlps callback function(Save SPI0 register values when system enter DLPS)
;;;327      * @param  None
;;;328      * @retval None
;;;329      */
;;;330    __STATIC_INLINE void SPI0_DLPS_Enter(void)
;;;331    {
;;;332        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;333        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;334    
;;;335        SPI0_StoreReg[0] = SPI0->CTRLR0;
;;;336        SPI0_StoreReg[1] = SPI0->CTRLR1;
;;;337        SPI0_StoreReg[2] = SPI0->SSIENR;
;;;338        SPI0_StoreReg[3] = SPI0->SER;
;;;339        SPI0_StoreReg[4] = SPI0->BAUDR;
;;;340        SPI0_StoreReg[5] = SPI0->TXFTLR;
;;;341        SPI0_StoreReg[6] = SPI0->RXFTLR;
;;;342        SPI0_StoreReg[7] = SPI0->IMR;
;;;343        SPI0_StoreReg[8] = SPI0->DMACR;
;;;344        SPI0_StoreReg[9] = SPI0->DMATDLR;
;;;345        SPI0_StoreReg[10] = SPI0->DMARDLR;
;;;346        SPI0_StoreReg[11] = SPI0->RX_SAMPLE_DLY;
;;;347        SPI0_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;348    }
;;;349    
;;;350    /**
;;;351      * @brief  SPI0 exit dlps callback function(Resume SPI0 register values when system exit DLPS)
;;;352      * @param  None
;;;353      * @retval None
;;;354      */
;;;355    DATA_RAM_FUNCTION __STATIC_INLINE void SPI0_DLPS_Exit(void)
;;;356    {
;;;357        *(volatile uint32_t *)0x40000308 = SPI0_StoreReg[12];
;;;358        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;359        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;360    
;;;361        SPI0->CTRLR0 = SPI0_StoreReg[0];
;;;362        SPI0->CTRLR1 = SPI0_StoreReg[1];
;;;363        SPI0->SER = SPI0_StoreReg[3];
;;;364        SPI0->BAUDR = SPI0_StoreReg[4];
;;;365        SPI0->TXFTLR = SPI0_StoreReg[5];
;;;366        SPI0->RXFTLR = SPI0_StoreReg[6];
;;;367        SPI0->IMR = SPI0_StoreReg[7];
;;;368        SPI0->DMACR = SPI0_StoreReg[8];
;;;369        SPI0->DMATDLR = SPI0_StoreReg[9];
;;;370        SPI0->DMARDLR = SPI0_StoreReg[10];
;;;371        SPI0->RX_SAMPLE_DLY = SPI0_StoreReg[11];
;;;372    
;;;373        /* Enable the selected SPI peripheral */
;;;374        SPI0->SSIENR = SPI0_StoreReg[2];
;;;375    }
;;;376    #endif
;;;377    
;;;378    
;;;379    /********************************************** ********************************************************/
;;;380    /**************************************** [SPI1 DLPS] **************************************************/
;;;381    /*******************************************************************************************************/
;;;382    /*******************************************************************************************************/
;;;383    #if USE_SPI1_DLPS
;;;384    __STATIC_INLINE void SPI1_DLPS_Enter(void);
;;;385    __STATIC_INLINE void SPI1_DLPS_Exit(void);
;;;386    
;;;387    uint32_t SPI1_StoreReg[13];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;388    
;;;389    /**
;;;390      * @brief  SPI1 enter dlps callback function(Save SPI1 register values when system enter DLPS)
;;;391      * @param  None
;;;392      * @retval None
;;;393      */
;;;394    __STATIC_INLINE void SPI1_DLPS_Enter(void)
;;;395    {
;;;396        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;397        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;398    
;;;399        SPI1_StoreReg[0] = SPI1->CTRLR0;
;;;400        SPI1_StoreReg[1] = SPI1->CTRLR1;
;;;401        SPI1_StoreReg[2] = SPI1->SSIENR;
;;;402        SPI1_StoreReg[3] = SPI1->SER;
;;;403        SPI1_StoreReg[4] = SPI1->BAUDR;
;;;404        SPI1_StoreReg[5] = SPI1->TXFTLR;
;;;405        SPI1_StoreReg[6] = SPI1->RXFTLR;
;;;406        SPI1_StoreReg[7] = SPI1->IMR;
;;;407        SPI1_StoreReg[8] = SPI1->DMACR;
;;;408        SPI1_StoreReg[9] = SPI1->DMATDLR;
;;;409        SPI1_StoreReg[10] = SPI1->DMARDLR;
;;;410        SPI1_StoreReg[11] = SPI1->RX_SAMPLE_DLY;
;;;411        SPI1_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;412    }
;;;413    
;;;414    /**
;;;415      * @brief  SPI1 exit dlps callback function(Resume SPI1 register values when system exit DLPS)
;;;416      * @param  None
;;;417      * @retval None
;;;418      */
;;;419    DATA_RAM_FUNCTION __STATIC_INLINE void SPI1_DLPS_Exit(void)
;;;420    {
;;;421        *(volatile uint32_t *)0x40000308 = SPI1_StoreReg[12];
;;;422        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;423        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;424    
;;;425        SPI1->CTRLR0 = SPI1_StoreReg[0];
;;;426        SPI1->CTRLR1 = SPI1_StoreReg[1];
;;;427        SPI1->SER = SPI1_StoreReg[3];
;;;428        SPI1->BAUDR = SPI1_StoreReg[4];
;;;429        SPI1->TXFTLR = SPI1_StoreReg[5];
;;;430        SPI1->RXFTLR = SPI1_StoreReg[6];
;;;431        SPI1->IMR = SPI1_StoreReg[7];
;;;432        SPI1->DMACR = SPI1_StoreReg[8];
;;;433        SPI1->DMATDLR = SPI1_StoreReg[9];
;;;434        SPI1->DMARDLR = SPI1_StoreReg[10];
;;;435        SPI1->RX_SAMPLE_DLY = SPI1_StoreReg[11];
;;;436    
;;;437        /* Enable the selected SPI peripheral */
;;;438        SPI1->SSIENR = SPI1_StoreReg[2];
;;;439    }
;;;440    #endif
;;;441    
;;;442    /********************************************** ********************************************************/
;;;443    /**************************************** [SPI2W DLPS] **************************************************/
;;;444    /*******************************************************************************************************/
;;;445    /*******************************************************************************************************/
;;;446    #if USE_SPI2W_DLPS
;;;447    __STATIC_INLINE void SPI2W_DLPS_Enter(void);
;;;448    __STATIC_INLINE void SPI2W_DLPS_Exit(void);
;;;449    
;;;450    uint32_t SPI2W_StoreReg[1];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;451    
;;;452    /**
;;;453      * @brief  SPI2W enter dlps callback function(Save SPI2W register values when system enter DLPS)
;;;454      * @param  None
;;;455      * @retval None
;;;456      */
;;;457    __STATIC_INLINE void SPI2W_DLPS_Enter(void)
;;;458    {
;;;459        /*Open 20M clock source*/
;;;460        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;461        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;462    
;;;463        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;464        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;465    
;;;466        SPI2W_StoreReg[0] = SPI3WIRE->CFGR;
;;;467    }
;;;468    
;;;469    /**
;;;470      * @brief  SPI2W exit dlps callback function(Resume SPI2W register values when system exit DLPS)
;;;471      * @param  None
;;;472      * @retval None
;;;473      */
;;;474    DATA_RAM_FUNCTION __STATIC_INLINE void SPI2W_DLPS_Exit(void)
;;;475    {
;;;476        /*Open 20M clock source*/
;;;477        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;478        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;479    
;;;480        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;481        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;482    
;;;483        SPI3WIRE->CFGR = SPI2W_StoreReg[0];
;;;484    }
;;;485    #endif
;;;486    
;;;487    /********************************************** ********************************************************/
;;;488    /**************************************** [I2C0 DLPS] **************************************************/
;;;489    /*******************************************************************************************************/
;;;490    /*******************************************************************************************************/
;;;491    #if USE_I2C0_DLPS
;;;492    __STATIC_INLINE void I2C0_DLPS_Enter(void);
;;;493    __STATIC_INLINE void I2C0_DLPS_Exit(void);
;;;494    
;;;495    uint32_t I2C0_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;496    
;;;497    /**
;;;498      * @brief  I2C0 enter dlps callback function(Save I2C0 register values when system enter DLPS)
;;;499      * @param  None
;;;500      * @retval None
;;;501      */
;;;502    __STATIC_INLINE void I2C0_DLPS_Enter(void)
;;;503    {
;;;504        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;505        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;506    
;;;507        I2C0_StoreReg[0] = I2C0->IC_CON;
;;;508        I2C0_StoreReg[1] = I2C0->IC_TAR;
;;;509        I2C0_StoreReg[2] = I2C0->IC_SAR;
;;;510        I2C0_StoreReg[3] = I2C0->IC_HS_MADDR;
;;;511    
;;;512        I2C0_StoreReg[4] = I2C0->IC_SS_SCL_HCNT;
;;;513        I2C0_StoreReg[5] = I2C0->IC_SS_SCL_LCNT;
;;;514        I2C0_StoreReg[6] = I2C0->IC_FS_SCL_HCNT;
;;;515        I2C0_StoreReg[7] = I2C0->IC_FS_SCL_LCNT;
;;;516        I2C0_StoreReg[8] = I2C0->IC_HS_SCL_HCNT;
;;;517        I2C0_StoreReg[9] = I2C0->IC_HS_SCL_LCNT;
;;;518    
;;;519        I2C0_StoreReg[10] = I2C0->IC_INTR_MASK;
;;;520        I2C0_StoreReg[11] = I2C0->IC_RX_TL;
;;;521        I2C0_StoreReg[12] = I2C0->IC_TX_TL;
;;;522        I2C0_StoreReg[13] = I2C0->IC_ENABLE;
;;;523        I2C0_StoreReg[14] = I2C0->IC_SDA_HOLD;
;;;524        I2C0_StoreReg[15] = I2C0->IC_SLV_DATA_NACK_ONLY;
;;;525        I2C0_StoreReg[16] = I2C0->IC_DMA_CR;
;;;526        I2C0_StoreReg[17] = I2C0->IC_DMA_TDLR;
;;;527        I2C0_StoreReg[18] = I2C0->IC_DMA_RDLR;
;;;528    
;;;529        I2C0_StoreReg[19] = I2C0->IC_SDA_SETUP;
;;;530    }
;;;531    
;;;532    /**
;;;533      * @brief  I2C0 exit dlps callback function(Resume I2C0 register values when system exit DLPS)
;;;534      * @param  None
;;;535      * @retval None
;;;536      */
;;;537    DATA_RAM_FUNCTION __STATIC_INLINE void I2C0_DLPS_Exit(void)
;;;538    {
;;;539        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;540        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;541    
;;;542        I2C0->IC_CON = I2C0_StoreReg[0];
;;;543        I2C0->IC_TAR = I2C0_StoreReg[1];
;;;544        I2C0->IC_SAR = I2C0_StoreReg[2];
;;;545        I2C0->IC_HS_MADDR = I2C0_StoreReg[3];
;;;546    
;;;547        I2C0->IC_SS_SCL_HCNT = I2C0_StoreReg[4];
;;;548        I2C0->IC_SS_SCL_LCNT = I2C0_StoreReg[5];
;;;549        I2C0->IC_FS_SCL_HCNT = I2C0_StoreReg[6];
;;;550        I2C0->IC_FS_SCL_LCNT = I2C0_StoreReg[7];
;;;551        I2C0->IC_HS_SCL_HCNT = I2C0_StoreReg[8];
;;;552        I2C0->IC_HS_SCL_LCNT = I2C0_StoreReg[9];
;;;553    
;;;554        I2C0->IC_INTR_MASK = I2C0_StoreReg[10];
;;;555        I2C0->IC_RX_TL = I2C0_StoreReg[11];
;;;556        I2C0->IC_TX_TL = I2C0_StoreReg[12];
;;;557        I2C0->IC_SDA_HOLD = I2C0_StoreReg[14];
;;;558        I2C0->IC_SLV_DATA_NACK_ONLY = I2C0_StoreReg[15];
;;;559        I2C0->IC_DMA_CR = I2C0_StoreReg[16];
;;;560        I2C0->IC_DMA_TDLR = I2C0_StoreReg[17];
;;;561        I2C0->IC_DMA_RDLR = I2C0_StoreReg[18];
;;;562        I2C0->IC_SDA_SETUP = I2C0_StoreReg[19];
;;;563    
;;;564        I2C0->IC_ENABLE = I2C0_StoreReg[13];
;;;565    }
;;;566    #endif
;;;567    
;;;568    /********************************************** ********************************************************/
;;;569    /**************************************** [I2C1 DLPS] **************************************************/
;;;570    /*******************************************************************************************************/
;;;571    /*******************************************************************************************************/
;;;572    #if USE_I2C1_DLPS
;;;573    __STATIC_INLINE void I2C1_DLPS_Enter(void);
;;;574    __STATIC_INLINE void I2C1_DLPS_Exit(void);
;;;575    
;;;576    uint32_t I2C1_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;577    
;;;578    /**
;;;579      * @brief  I2C1 enter dlps callback function(Save I2C1 register values when system enter DLPS)
;;;580      * @param  None
;;;581      * @retval None
;;;582      */
;;;583    __STATIC_INLINE void I2C1_DLPS_Enter(void)
;;;584    {
;;;585        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;586        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;587    
;;;588        I2C1_StoreReg[0] = I2C1->IC_CON;
;;;589        I2C1_StoreReg[1] = I2C1->IC_TAR;
;;;590        I2C1_StoreReg[2] = I2C1->IC_SAR;
;;;591        I2C1_StoreReg[3] = I2C1->IC_HS_MADDR;
;;;592    
;;;593        I2C1_StoreReg[4] = I2C1->IC_SS_SCL_HCNT;
;;;594        I2C1_StoreReg[5] = I2C1->IC_SS_SCL_LCNT;
;;;595        I2C1_StoreReg[6] = I2C1->IC_FS_SCL_HCNT;
;;;596        I2C1_StoreReg[7] = I2C1->IC_FS_SCL_LCNT;
;;;597        I2C1_StoreReg[8] = I2C1->IC_HS_SCL_HCNT;
;;;598        I2C1_StoreReg[9] = I2C1->IC_HS_SCL_LCNT;
;;;599    
;;;600        I2C1_StoreReg[10] = I2C1->IC_INTR_MASK;
;;;601        I2C1_StoreReg[11] = I2C1->IC_RX_TL;
;;;602        I2C1_StoreReg[12] = I2C1->IC_TX_TL;
;;;603        I2C1_StoreReg[13] = I2C1->IC_ENABLE;
;;;604        I2C1_StoreReg[14] = I2C1->IC_SDA_HOLD;
;;;605        I2C1_StoreReg[15] = I2C1->IC_SLV_DATA_NACK_ONLY;
;;;606        I2C1_StoreReg[16] = I2C1->IC_DMA_CR;
;;;607        I2C1_StoreReg[17] = I2C1->IC_DMA_TDLR;
;;;608        I2C1_StoreReg[18] = I2C1->IC_DMA_RDLR;
;;;609    
;;;610        I2C1_StoreReg[19] = I2C1->IC_SDA_SETUP;
;;;611    }
;;;612    
;;;613    /**
;;;614      * @brief  I2C1 exit dlps callback function(Resume I2C1 register values when system exit DLPS)
;;;615      * @param  None
;;;616      * @retval None
;;;617      */
;;;618    DATA_RAM_FUNCTION __STATIC_INLINE void I2C1_DLPS_Exit(void)
;;;619    {
;;;620        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;621        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;622    
;;;623        I2C1->IC_CON = I2C1_StoreReg[0];
;;;624        I2C1->IC_TAR = I2C1_StoreReg[1];
;;;625        I2C1->IC_SAR = I2C1_StoreReg[2];
;;;626        I2C0->IC_HS_MADDR = I2C1_StoreReg[3];
;;;627    
;;;628        I2C1->IC_SS_SCL_HCNT = I2C1_StoreReg[4];
;;;629        I2C1->IC_SS_SCL_LCNT = I2C1_StoreReg[5];
;;;630        I2C1->IC_FS_SCL_HCNT = I2C1_StoreReg[6];
;;;631        I2C1->IC_FS_SCL_LCNT = I2C1_StoreReg[7];
;;;632        I2C1->IC_HS_SCL_HCNT = I2C1_StoreReg[8];
;;;633        I2C1->IC_HS_SCL_LCNT = I2C1_StoreReg[9];
;;;634    
;;;635        I2C1->IC_INTR_MASK = I2C1_StoreReg[10];
;;;636        I2C1->IC_RX_TL = I2C1_StoreReg[11];
;;;637        I2C1->IC_TX_TL = I2C1_StoreReg[12];
;;;638        I2C1->IC_SDA_HOLD = I2C1_StoreReg[14];
;;;639        I2C1->IC_SLV_DATA_NACK_ONLY = I2C1_StoreReg[15];
;;;640        I2C1->IC_DMA_CR = I2C1_StoreReg[16];
;;;641        I2C1->IC_DMA_TDLR = I2C1_StoreReg[17];
;;;642        I2C1->IC_DMA_RDLR = I2C1_StoreReg[18];
;;;643        I2C1->IC_SDA_SETUP = I2C1_StoreReg[19];
;;;644    
;;;645        I2C1->IC_ENABLE = I2C1_StoreReg[13];
;;;646    }
;;;647    #endif
;;;648    
;;;649    /********************************************** ********************************************************/
;;;650    /**************************************** [Timer & PWM DLPS] *******************************************/
;;;651    /*******************************************************************************************************/
;;;652    /*******************************************************************************************************/
;;;653    #if USE_TIM_DLPS
;;;654    #include "rtl876x_tim.h"
;;;655    __STATIC_INLINE void TIM_DLPS_Enter(void);
;;;656    __STATIC_INLINE void TIM_DLPS_Exit(void);
;;;657    
;;;658    uint32_t TIM_StoreReg[26];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;659    
;;;660    /* PWM, use with timer */
;;;661    uint32_t PWM0_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;662    
;;;663    uint32_t PWM1_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;664    
;;;665    /**
;;;666      * @brief  TIMER enter dlps callback function(Save TIMER register values when system enter DLPS)
;;;667      * @param  None
;;;668      * @retval None
;;;669      */
;;;670    __STATIC_INLINE void TIM_DLPS_Enter(void)
;;;671    {
;;;672        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;673        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;674    
;;;675        TIM_StoreReg[0] = TIM0->LoadCount;
;;;676        TIM_StoreReg[1] = TIM0->ControlReg;
;;;677        TIM_StoreReg[2] = TIMER0_LOAD_COUNT2;
;;;678    
;;;679        TIM_StoreReg[3] = TIM1->LoadCount;
;;;680        TIM_StoreReg[4] = TIM1->ControlReg;
;;;681        TIM_StoreReg[5] = TIMER1_LOAD_COUNT2;
;;;682    
;;;683        TIM_StoreReg[6] = TIM2->LoadCount;
;;;684        TIM_StoreReg[7] = TIM2->ControlReg;
;;;685        TIM_StoreReg[8] = TIMER2_LOAD_COUNT2;
;;;686    
;;;687        TIM_StoreReg[9] = TIM3->LoadCount;
;;;688        TIM_StoreReg[10] = TIM3->ControlReg;
;;;689        TIM_StoreReg[11] = TIMER3_LOAD_COUNT2;
;;;690    
;;;691        TIM_StoreReg[12] = TIM4->LoadCount;
;;;692        TIM_StoreReg[13] = TIM4->ControlReg;
;;;693        TIM_StoreReg[14] = TIMER4_LOAD_COUNT2;
;;;694    
;;;695        TIM_StoreReg[15] = TIM5->LoadCount;
;;;696        TIM_StoreReg[16] = TIM5->ControlReg;
;;;697        TIM_StoreReg[17] = TIMER5_LOAD_COUNT2;
;;;698    
;;;699        TIM_StoreReg[18] = TIM6->LoadCount;
;;;700        TIM_StoreReg[19] = TIM6->ControlReg;
;;;701        TIM_StoreReg[20] = TIMER6_LOAD_COUNT2;
;;;702    
;;;703        TIM_StoreReg[21] = TIM7->LoadCount;
;;;704        TIM_StoreReg[22] = TIM7->ControlReg;
;;;705        TIM_StoreReg[23] = TIMER7_LOAD_COUNT2;
;;;706    
;;;707        TIM_StoreReg[24] = *((volatile uint32_t *)0x4000035CUL);
;;;708        TIM_StoreReg[25] = *((volatile uint32_t *)0x40000360UL);
;;;709    
;;;710        PWM0_StoreReg = TIMER_PWM0_CR;
;;;711    
;;;712        PWM1_StoreReg = TIMER_PWM1_CR;
;;;713    }
;;;714    
;;;715    /**
;;;716      * @brief  TIMER exit dlps callback function(Resume TIMER register values when system exit DLPS)
;;;717      * @param  None
;;;718      * @retval None
;;;719      */
;;;720    DATA_RAM_FUNCTION __STATIC_INLINE void TIM_DLPS_Exit(void)
;;;721    {
;;;722        /* Enable timer IP clock and function */
;;;723        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;724        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;725    
;;;726        *((volatile uint32_t *)0x4000035CUL) = TIM_StoreReg[24];
;;;727        *((volatile uint32_t *)0x40000360UL) = TIM_StoreReg[25];
;;;728    
;;;729        TIM0->LoadCount = TIM_StoreReg[0];
;;;730        TIM0->ControlReg = TIM_StoreReg[1];
;;;731        TIMER0_LOAD_COUNT2 = TIM_StoreReg[2];
;;;732    
;;;733        TIM1->LoadCount = TIM_StoreReg[3];
;;;734        TIM1->ControlReg = TIM_StoreReg[4];
;;;735        TIMER1_LOAD_COUNT2 = TIM_StoreReg[5];
;;;736    
;;;737        TIM2->LoadCount = TIM_StoreReg[6];
;;;738        TIM2->ControlReg = TIM_StoreReg[7];
;;;739        TIMER2_LOAD_COUNT2 = TIM_StoreReg[8];
;;;740    
;;;741        TIM3->LoadCount = TIM_StoreReg[9];
;;;742        TIM3->ControlReg = TIM_StoreReg[10];
;;;743        TIMER3_LOAD_COUNT2 = TIM_StoreReg[11];
;;;744    
;;;745        TIM4->LoadCount = TIM_StoreReg[12];
;;;746        TIM4->ControlReg = TIM_StoreReg[13];
;;;747        TIMER4_LOAD_COUNT2 = TIM_StoreReg[14];
;;;748    
;;;749        TIM5->LoadCount = TIM_StoreReg[15];
;;;750        TIM5->ControlReg = TIM_StoreReg[16];
;;;751        TIMER5_LOAD_COUNT2 = TIM_StoreReg[17];
;;;752    
;;;753        TIM6->LoadCount = TIM_StoreReg[18];
;;;754        TIM6->ControlReg = TIM_StoreReg[19];
;;;755        TIMER6_LOAD_COUNT2 = TIM_StoreReg[20];
;;;756    
;;;757        TIM7->LoadCount = TIM_StoreReg[21];
;;;758        TIM7->ControlReg = TIM_StoreReg[22];
;;;759        TIMER7_LOAD_COUNT2 = TIM_StoreReg[23];
;;;760    
;;;761        TIMER_PWM0_CR = PWM0_StoreReg;
;;;762    
;;;763        TIMER_PWM1_CR = PWM1_StoreReg;
;;;764    }
;;;765    #endif  /* USE_TIM_DLPS */
;;;766    
;;;767    
;;;768    /********************************************** ********************************************************/
;;;769    /**************************************** [UART DLPS] **************************************************/
;;;770    /*******************************************************************************************************/
;;;771    /*******************************************************************************************************/
;;;772    #if USE_UART_DLPS
;;;773    #include "rtl876x_uart.h"
;;;774    
;;;775    __STATIC_INLINE void UART_DLPS_Enter(void);
;;;776    __STATIC_INLINE void UART_DLPS_Exit(void);
;;;777    
;;;778    uint32_t UART_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;779    
;;;780    /**
;;;781      * @brief  UART enter dlps callback function(Save UART register values when system enter DLPS)
;;;782      * @param  None
;;;783      * @retval None
;;;784      */
;;;785    __STATIC_INLINE void UART_DLPS_Enter(void)
;;;786    {
;;;787        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;788        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;789    
;;;790        //access DLH and DLL
;;;791        UART->LCR |= (1 << 7);
;;;792        UART_StoreReg[0] = UART->DLL;
;;;793        UART_StoreReg[1] = UART->DLH_INTCR;
;;;794        UART->LCR &= (~(1 << 7));
;;;795    
;;;796        //save other registers
;;;797        UART_StoreReg[2] = UART->DLH_INTCR;
;;;798        UART_StoreReg[4] = UART->LCR;
;;;799        UART_StoreReg[5] = UART->MCR;
;;;800        UART_StoreReg[6] = UART->SPR;
;;;801        UART_StoreReg[7] = UART->STSR;
;;;802        UART_StoreReg[8] = UART->RX_IDLE_INTTCR;
;;;803        UART_StoreReg[9] = UART->RXIDLE_INTCR;
;;;804        UART_StoreReg[10] = UART->MISCR;
;;;805    
;;;806        return;
;;;807    }
;;;808    
;;;809    /**
;;;810      * @brief  UART exit dlps callback function(Resume UART register values when system exit DLPS)
;;;811      * @param  None
;;;812      * @retval None
;;;813      */
;;;814    DATA_RAM_FUNCTION __STATIC_INLINE void UART_DLPS_Exit(void)
;;;815    {
;;;816        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;817        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;818    
;;;819        //access DLH and DLL
;;;820        UART->LCR |= (1 << 7);
;;;821        UART->DLL = UART_StoreReg[0];
;;;822        UART->DLH_INTCR =  UART_StoreReg[1];
;;;823        UART->LCR &= (~(1 << 7));
;;;824    
;;;825        //access other registers
;;;826        UART->INTID_FCR = (((UART_StoreReg[7] & BIT24) >> 21) | ((UART_StoreReg[7] & 0x7C000000) >> 18) |
;;;827                           (1));
;;;828        UART->LCR = UART_StoreReg[4];
;;;829        UART->MCR = UART_StoreReg[5];
;;;830        UART->SPR = UART_StoreReg[6];
;;;831        UART->STSR = UART_StoreReg[7];
;;;832        UART->DLH_INTCR = UART_StoreReg[2];
;;;833        UART->RX_IDLE_INTTCR = UART_StoreReg[8];
;;;834        UART->RXIDLE_INTCR = UART_StoreReg[9];
;;;835        UART->MISCR = UART_StoreReg[10];
;;;836    
;;;837        return;
;;;838    }
;;;839    #endif
;;;840    
;;;841    
;;;842    #if USE_UART1_DLPS
;;;843    
;;;844    __STATIC_INLINE void UART1_DLPS_Enter(void);
;;;845    __STATIC_INLINE void UART1_DLPS_Exit(void);
;;;846    
;;;847    uint32_t UART1_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;848    
;;;849    /**
;;;850      * @brief  UART1 enter dlps callback function(Save UART1 register values when system enter DLPS)
;;;851      * @param  None
;;;852      * @retval None
;;;853      */
;;;854    __STATIC_INLINE void UART1_DLPS_Enter(void)
;;;855    {
;;;856        //enable log uart peripheral & clock
;;;857        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;858        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;859    
;;;860        //access DLH and DLL
;;;861        UART1->LCR |= (1 << 7);
;;;862        UART1_StoreReg[0] = UART1->DLL;
;;;863        UART1_StoreReg[1] = UART1->DLH_INTCR;
;;;864        UART1->LCR &= (~(1 << 7));
;;;865    
;;;866        //save other registers
;;;867        UART1_StoreReg[2] = UART1->DLH_INTCR;
;;;868        UART1_StoreReg[4] = UART1->LCR;
;;;869        UART1_StoreReg[5] = UART1->MCR;
;;;870        UART1_StoreReg[6] = UART1->SPR;
;;;871        UART1_StoreReg[7] = UART1->STSR;
;;;872        UART1_StoreReg[8] = UART1->RX_IDLE_INTTCR;
;;;873        UART1_StoreReg[9] = UART1->RXIDLE_INTCR;
;;;874        UART1_StoreReg[10] = UART1->MISCR;
;;;875    
;;;876        return;
;;;877    }
;;;878    
;;;879    /**
;;;880      * @brief  UART1 exit dlps callback function(Resume UART1 register values when system exit DLPS)
;;;881      * @param  None
;;;882      * @retval None
;;;883      */
;;;884    DATA_RAM_FUNCTION __STATIC_INLINE void UART1_DLPS_Exit(void)
;;;885    {
;;;886        //enable log uart peripheral & clock
;;;887        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;888        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;889    
;;;890        //access DLH and DLL
;;;891        UART1->LCR |= (1 << 7);
;;;892        UART1->DLL = UART1_StoreReg[0];
;;;893        UART1->DLH_INTCR =  UART1_StoreReg[1];
;;;894        UART1->LCR &= (~(1 << 7));
;;;895    
;;;896        //access other registers
;;;897        UART1->INTID_FCR = (((UART1_StoreReg[7] & BIT24) >> 21) | ((UART1_StoreReg[7] & 0x7C000000)
;;;898                                                                   >> 18) | (1));
;;;899        UART1->LCR = UART1_StoreReg[4];
;;;900        UART1->MCR = UART1_StoreReg[5];
;;;901        UART1->SPR = UART1_StoreReg[6];
;;;902        UART1->STSR = UART1_StoreReg[7];
;;;903        UART1->DLH_INTCR = UART1_StoreReg[2];
;;;904        UART1->RX_IDLE_INTTCR = UART1_StoreReg[8];
;;;905        UART1->RXIDLE_INTCR = UART1_StoreReg[9];
;;;906        UART1->MISCR = UART1_StoreReg[10];
;;;907    
;;;908        return;
;;;909    }
;;;910    #endif
;;;911    
;;;912    #if USE_UART2_DLPS
;;;913    
;;;914    __STATIC_INLINE void UART2_DLPS_Enter(void);
;;;915    __STATIC_INLINE void UART2_DLPS_Exit(void);
;;;916    
;;;917    uint32_t UART2_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;918    
;;;919    /**
;;;920      * @brief  UART2 enter dlps callback function(Save UART2 register values when system enter DLPS)
;;;921      * @param  None
;;;922      * @retval None
;;;923      */
;;;924    __STATIC_INLINE void UART2_DLPS_Enter(void)
;;;925    {
;;;926        //enable log uart peripheral & clock
;;;927        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;928        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;929    
;;;930        //access DLH and DLL
;;;931        UART2->LCR |= (1 << 7);
;;;932        UART2_StoreReg[0] = UART2->DLL;
;;;933        UART2_StoreReg[1] = UART2->DLH_INTCR;
;;;934        UART2->LCR &= (~(1 << 7));
;;;935    
;;;936        //save other registers
;;;937        UART2_StoreReg[2] = UART2->DLH_INTCR;
;;;938        UART2_StoreReg[4] = UART2->LCR;
;;;939        UART2_StoreReg[5] = UART2->MCR;
;;;940        UART2_StoreReg[6] = UART2->SPR;
;;;941        UART2_StoreReg[7] = UART2->STSR;
;;;942        UART2_StoreReg[8] = UART2->RX_IDLE_INTTCR;
;;;943        UART2_StoreReg[9] = UART2->RXIDLE_INTCR;
;;;944        UART2_StoreReg[10] = UART2->MISCR;
;;;945    
;;;946        return;
;;;947    }
;;;948    
;;;949    /**
;;;950      * @brief  UART2 exit dlps callback function(Resume UART2 register values when system exit DLPS)
;;;951      * @param  None
;;;952      * @retval None
;;;953      */
;;;954    DATA_RAM_FUNCTION __STATIC_INLINE void UART2_DLPS_Exit(void)
;;;955    {
;;;956        //enable log uart peripheral & clock
;;;957        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;958        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;959    
;;;960        //access DLH and DLL
;;;961        UART2->LCR |= (1 << 7);
;;;962        UART2->DLL = UART2_StoreReg[0];
;;;963        UART2->DLH_INTCR =  UART2_StoreReg[1];
;;;964        UART2->LCR &= (~(1 << 7));
;;;965    
;;;966        //access other registers
;;;967        UART2->INTID_FCR = (((UART2_StoreReg[7] & BIT24) >> 21) | ((UART2_StoreReg[7] & 0x7C000000)
;;;968                                                                   >> 18) | (1));
;;;969        UART2->LCR = UART2_StoreReg[4];
;;;970        UART2->MCR = UART2_StoreReg[5];
;;;971        UART2->SPR = UART2_StoreReg[6];
;;;972        UART2->STSR = UART2_StoreReg[7];
;;;973        UART2->DLH_INTCR = UART2_StoreReg[2];
;;;974        UART2->RX_IDLE_INTTCR = UART2_StoreReg[8];
;;;975        UART2->RXIDLE_INTCR = UART2_StoreReg[9];
;;;976        UART2->MISCR = UART2_StoreReg[10];
;;;977    
;;;978        return;
;;;979    }
;;;980    #endif
;;;981    
;;;982    
;;;983    /********************************************** ********************************************************/
;;;984    /**************************************** [ADC DLPS] **************************************************/
;;;985    /*******************************************************************************************************/
;;;986    /*******************************************************************************************************/
;;;987    
;;;988    #if USE_ADC_DLPS
;;;989    __STATIC_INLINE void ADC_DLPS_Enter(void);
;;;990    __STATIC_INLINE void ADC_DLPS_Exit(void);
;;;991    
;;;992    uint32_t ADC_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;993    
;;;994    /**
;;;995      * @brief  ADC enter dlps callback function(Save ADC register values when system enter DLPS)
;;;996      * @param  None
;;;997      * @retval None
;;;998      */
;;;999    __STATIC_INLINE void ADC_DLPS_Enter(void)
;;;1000   {
;;;1001       /*Open 10M clock source*/
;;;1002       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1003       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1004   
;;;1005       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1006       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1007   
;;;1008       ADC_StoreReg[0] =  ADC->CR;          //0x04
;;;1009       ADC_StoreReg[1] =  ADC->SCHCR;       //0x08
;;;1010       ADC_StoreReg[2] =  ADC->INTCR;       //0x0C
;;;1011       ADC_StoreReg[3] =  ADC->SCHTAB0;     //0x10
;;;1012       ADC_StoreReg[4] =  ADC->SCHTAB1;     //0x14
;;;1013       ADC_StoreReg[5] =  ADC->SCHTAB2;     //0x18
;;;1014       ADC_StoreReg[6] =  ADC->SCHTAB3;     //0x1C
;;;1015       ADC_StoreReg[7] =  ADC->SCHTAB4;     //0x20
;;;1016       ADC_StoreReg[8] =  ADC->SCHTAB5;     //0x24
;;;1017       ADC_StoreReg[9] =  ADC->SCHTAB6;     //0x28
;;;1018       ADC_StoreReg[10] =  ADC->SCHTAB6;    //0x2C
;;;1019       ADC_StoreReg[11] =  ADC->PWRDLY;
;;;1020       ADC_StoreReg[12] =  ADC->DATCLK;
;;;1021       ADC_StoreReg[13] =  ADC->ANACTL;
;;;1022   
;;;1023       uint8_t reg_value = 0;
;;;1024       reg_value = btaon_fast_read_safe(0x110);
;;;1025       btaon_fast_write(0x110, reg_value & (~0x04));
;;;1026   
;;;1027       return;
;;;1028   }
;;;1029   
;;;1030   /**
;;;1031     * @brief  ADC exit dlps callback function(Resume ADC register values when system exit DLPS)
;;;1032     * @param  None
;;;1033     * @retval None
;;;1034     */
;;;1035   DATA_RAM_FUNCTION __STATIC_INLINE void ADC_DLPS_Exit(void)
;;;1036   {
;;;1037       /*Open 10M clock source*/
;;;1038       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1039       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1040   
;;;1041       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1042       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1043   
;;;1044   #if 0
;;;1045       //Todo
;;;1046       ADC->PWRDLY = ADC_StoreReg[10];
;;;1047       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1048       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1049       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1050       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1051       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1052       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1053       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1054       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1055       ADC->SCHCR = ADC_StoreReg[1];
;;;1056       ADC->INTCR = (ADC_StoreReg[2] & 0x1F);
;;;1057   #else
;;;1058       /*Disable all interrupt.*/
;;;1059       ADC->INTCR &= (~0x1f);
;;;1060   
;;;1061       /* Set power mode first */
;;;1062       ADC->PWRDLY = ADC_StoreReg[11];
;;;1063   
;;;1064       /* Disable schedule table */
;;;1065       ADC->SCHCR &= (~0xffff);
;;;1066   
;;;1067       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1068       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1069       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1070       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1071       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1072       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1073       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1074       ADC->SCHTAB7 = ADC_StoreReg[10];
;;;1075       ADC->SCHCR   = ADC_StoreReg[1];
;;;1076       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1077       ADC->DATCLK = ADC_StoreReg[12];
;;;1078       ADC->ANACTL = ADC_StoreReg[13];
;;;1079   
;;;1080       /*Clear ADC FIFO */
;;;1081       ADC->CR |= BIT26;
;;;1082       /* Clear all interrupt */
;;;1083       ADC->INTCR |= (0x1f << 8);
;;;1084   
;;;1085       /* Restore specify interrupt */
;;;1086       ADC->INTCR = ADC_StoreReg[2];
;;;1087   
;;;1088   #endif
;;;1089   
;;;1090       uint8_t reg_value = 0;
;;;1091       reg_value = btaon_fast_read_safe(0x110);
;;;1092       btaon_fast_write(0x110, reg_value | 0x04);
;;;1093   
;;;1094       return;
;;;1095   }
;;;1096   
;;;1097   #endif
;;;1098   
;;;1099   /********************************************** ********************************************************/
;;;1100   /**************************************** [IR DLPS] **************************************************/
;;;1101   /*******************************************************************************************************/
;;;1102   /*******************************************************************************************************/
;;;1103   
;;;1104   #if USE_IR_DLPS
;;;1105   __STATIC_INLINE void IR_DLPS_Enter(void);
;;;1106   __STATIC_INLINE void IR_DLPS_Exit(void);
;;;1107   
;;;1108   uint32_t IR_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1109   
;;;1110   /**
;;;1111     * @brief  IR enter dlps callback function(Save IR register values when system enter DLPS)
;;;1112     * @param  None
;;;1113     * @retval None
;;;1114     */
;;;1115   __STATIC_INLINE void IR_DLPS_Enter(void)
;;;1116   {
;;;1117       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1118       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1119   
;;;1120       IR_StoreReg[0] = IR->CLK_DIV;
;;;1121       IR_StoreReg[1] = IR->TX_CONFIG;
;;;1122       IR_StoreReg[2] = IR->RX_CONFIG;
;;;1123       IR_StoreReg[3] = IR->RX_CNT_INT_SEL;
;;;1124   
;;;1125   
;;;1126       return;
;;;1127   }
;;;1128   
;;;1129   /**
;;;1130     * @brief  IR exit dlps callback function(Resume IR register values when system exit DLPS)
;;;1131     * @param  None
;;;1132     * @retval None
;;;1133     */
;;;1134   DATA_RAM_FUNCTION __STATIC_INLINE void IR_DLPS_Exit(void)
;;;1135   {
;;;1136       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1137       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1138   
;;;1139       IR->CLK_DIV = IR_StoreReg[0];
;;;1140       if (IR_StoreReg[1] & BIT31)
;;;1141       {
;;;1142           /* RX MODE */
;;;1143           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1144           IR->RX_CONFIG  = IR_StoreReg[2];
;;;1145           IR->RX_CNT_INT_SEL  = IR_StoreReg[3];
;;;1146       }
;;;1147       else
;;;1148       {
;;;1149           /* TX MODE */
;;;1150           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1151           /* If IR TX mode is idle, must write one data firstly */
;;;1152           IR->TX_FIFO = 0;
;;;1153       }
;;;1154   
;;;1155       return;
;;;1156   }
;;;1157   
;;;1158   #endif
;;;1159   
;;;1160   /********************************************** ********************************************************/
;;;1161   /**************************************** [GDMA DLPS] **************************************************/
;;;1162   /*******************************************************************************************************/
;;;1163   /*******************************************************************************************************/
;;;1164   
;;;1165   #if USE_GDMA_DLPS
;;;1166   
;;;1167   __STATIC_INLINE void GDMA_DLPS_Enter(void);
;;;1168   __STATIC_INLINE void GDMA_DLPS_Exit(void);
;;;1169   uint32_t GDMA_StoreReg[7];         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1170   
;;;1171   #endif
;;;1172   
;;;1173   #if USE_GDMACHANNEL0_DLPS
;;;1174   uint32_t GDMAChannel0_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1175   #endif
;;;1176   
;;;1177   #if USE_GDMACHANNEL1_DLPS
;;;1178   uint32_t GDMAChannel1_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1179   #endif
;;;1180   
;;;1181   #if USE_GDMACHANNEL2_DLPS
;;;1182   uint32_t GDMAChannel2_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1183   #endif
;;;1184   
;;;1185   #if USE_GDMACHANNEL3_DLPS
;;;1186   uint32_t GDMAChannel3_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1187   #endif
;;;1188   
;;;1189   #if USE_GDMACHANNEL4_DLPS
;;;1190   uint32_t GDMAChannel4_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1191   #endif
;;;1192   
;;;1193   #if USE_GDMACHANNEL5_DLPS
;;;1194   uint32_t GDMAChannel5_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1195   #endif
;;;1196   
;;;1197   #if USE_GDMA_DLPS
;;;1198   /**
;;;1199     * @brief  GDMA enter dlps callback function(Save GDMA register values when system enter DLPS)
;;;1200     * @param  None
;;;1201     * @retval None
;;;1202     */
;;;1203   __STATIC_INLINE void GDMA_DLPS_Enter(void)
;;;1204   {
;;;1205       SYSBLKCTRL->u_210.SOC_FUNC_EN |= SYSBLK_GDMA0_EN_Msk;
;;;1206       PERIPH->PERI_CLK_CTRL |= (SYSBLK_ACTCK_GDMA0_EN_Msk | SYSBLK_SLPCK_GDMA0_EN_Msk);
;;;1207   
;;;1208       GDMA_StoreReg[0] = GDMA_BASE->DmaCfgReg;
;;;1209       GDMA_StoreReg[1] = GDMA_BASE->ChEnReg;
;;;1210       GDMA_StoreReg[2] = GDMA_BASE->MASK_TFR;
;;;1211       GDMA_StoreReg[3] = GDMA_BASE->MASK_BLOCK;
;;;1212       GDMA_StoreReg[4] = GDMA_BASE->MASK_SRC_TRAN;
;;;1213       GDMA_StoreReg[5] = GDMA_BASE->MASK_DST_TRAN;
;;;1214       GDMA_StoreReg[6] = GDMA_BASE->MASK_ERR;
;;;1215   
;;;1216   #if USE_GDMACHANNEL0_DLPS
;;;1217       GDMAChannel0_StoreReg[0] = GDMA_Channel0->SAR;
;;;1218       GDMAChannel0_StoreReg[1] = GDMA_Channel0->DAR;
;;;1219       GDMAChannel0_StoreReg[2] = GDMA_Channel0->CTL_LOW;
;;;1220       GDMAChannel0_StoreReg[3] = GDMA_Channel0->CTL_HIGH;
;;;1221       GDMAChannel0_StoreReg[4] = GDMA_Channel0->CFG_LOW;
;;;1222       GDMAChannel0_StoreReg[5] = GDMA_Channel0->CFG_HIGH;
;;;1223   #endif
;;;1224   #if USE_GDMACHANNEL1_DLPS
;;;1225       GDMAChannel1_StoreReg[0] = GDMA_Channel1->SAR;
;;;1226       GDMAChannel1_StoreReg[1] = GDMA_Channel1->DAR;
;;;1227       GDMAChannel1_StoreReg[2] = GDMA_Channel1->CTL_LOW;
;;;1228       GDMAChannel1_StoreReg[3] = GDMA_Channel1->CTL_HIGH;
;;;1229       GDMAChannel1_StoreReg[4] = GDMA_Channel1->CFG_LOW;
;;;1230       GDMAChannel1_StoreReg[5] = GDMA_Channel1->CFG_HIGH;
;;;1231   #endif
;;;1232   #if USE_GDMACHANNEL2_DLPS
;;;1233       GDMAChannel2_StoreReg[0] = GDMA_Channel2->SAR;
;;;1234       GDMAChannel2_StoreReg[1] = GDMA_Channel2->DAR;
;;;1235       GDMAChannel2_StoreReg[2] = GDMA_Channel2->CTL_LOW;
;;;1236       GDMAChannel2_StoreReg[3] = GDMA_Channel2->CTL_HIGH;
;;;1237       GDMAChannel2_StoreReg[4] = GDMA_Channel2->CFG_LOW;
;;;1238       GDMAChannel2_StoreReg[5] = GDMA_Channel2->CFG_HIGH;
;;;1239   #endif
;;;1240   #if USE_GDMACHANNEL3_DLPS
;;;1241       GDMAChannel3_StoreReg[0] = GDMA_Channel3->SAR;
;;;1242       GDMAChannel3_StoreReg[1] = GDMA_Channel3->DAR;
;;;1243       GDMAChannel3_StoreReg[2] = GDMA_Channel3->CTL_LOW;
;;;1244       GDMAChannel3_StoreReg[3] = GDMA_Channel3->CTL_HIGH;
;;;1245       GDMAChannel3_StoreReg[4] = GDMA_Channel3->CFG_LOW;
;;;1246       GDMAChannel3_StoreReg[5] = GDMA_Channel3->CFG_HIGH;
;;;1247   #endif
;;;1248   #if USE_GDMACHANNEL4_DLPS
;;;1249       GDMAChannel4_StoreReg[0] = GDMA_Channel4->SAR;
;;;1250       GDMAChannel4_StoreReg[1] = GDMA_Channel4->DAR;
;;;1251       GDMAChannel4_StoreReg[2] = GDMA_Channel4->CTL_LOW;
;;;1252       GDMAChannel4_StoreReg[3] = GDMA_Channel4->CTL_HIGH;
;;;1253       GDMAChannel4_StoreReg[4] = GDMA_Channel4->CFG_LOW;
;;;1254       GDMAChannel4_StoreReg[5] = GDMA_Channel4->CFG_HIGH;
;;;1255   #endif
;;;1256   #if USE_GDMACHANNEL5_DLPS
;;;1257       GDMAChannel5_StoreReg[0] = GDMA_Channel5->SAR;
;;;1258       GDMAChannel5_StoreReg[1] = GDMA_Channel5->DAR;
;;;1259       GDMAChannel5_StoreReg[2] = GDMA_Channel5->CTL_LOW;
;;;1260       GDMAChannel5_StoreReg[3] = GDMA_Channel5->CTL_HIGH;
;;;1261       GDMAChannel5_StoreReg[4] = GDMA_Channel5->CFG_LOW;
;;;1262       GDMAChannel5_StoreReg[5] = GDMA_Channel5->CFG_HIGH;
;;;1263   #endif
;;;1264   }
;;;1265   
;;;1266   /**
;;;1267     * @brief  GDMA exit dlps callback function(Resume GDMA register values when system exit DLPS)
;;;1268     * @param  None
;;;1269     * @retval None
;;;1270     */
;;;1271   DATA_RAM_FUNCTION __STATIC_INLINE void GDMA_DLPS_Exit(void)
;;;1272   {
;;;1273       SYSBLKCTRL->u_210.SOC_FUNC_EN |= SYSBLK_GDMA0_EN_Msk;
;;;1274       PERIPH->PERI_CLK_CTRL |= (SYSBLK_ACTCK_GDMA0_EN_Msk | SYSBLK_SLPCK_GDMA0_EN_Msk);
;;;1275   
;;;1276       /* Enable GDMA in DmaCfgReg*/
;;;1277       GDMA_BASE->DmaCfgReg = GDMA_StoreReg[0];
;;;1278   
;;;1279       /*----------clear pending all interrupts of GDMA channel-----------*/
;;;1280       GDMA_BASE->CLEAR_TFR = 0xff;
;;;1281       GDMA_BASE->CLEAR_BLOCK = 0xff;
;;;1282       GDMA_BASE->CLEAR_DST_TRAN = 0xff;
;;;1283       GDMA_BASE->CLEAR_SRC_TRAN = 0xff;
;;;1284       GDMA_BASE->CLEAR_ERR = 0xff;
;;;1285   
;;;1286       /*--------------------mask interrupt-------- -----------------*/
;;;1287       GDMA_BASE->MASK_TFR = (GDMA_StoreReg[2] | ((GDMA_StoreReg[2] & 0xff) << 8));
;;;1288       GDMA_BASE->MASK_BLOCK = (GDMA_StoreReg[3] | ((GDMA_StoreReg[3] & 0xff) << 8));
;;;1289       GDMA_BASE->MASK_SRC_TRAN = (GDMA_StoreReg[4] | ((GDMA_StoreReg[4] & 0xff) << 8));
;;;1290       GDMA_BASE->MASK_DST_TRAN = (GDMA_StoreReg[5] | ((GDMA_StoreReg[5] & 0xff) << 8));
;;;1291       GDMA_BASE->MASK_ERR = (GDMA_StoreReg[6] | ((GDMA_StoreReg[6] & 0xff) << 8));
;;;1292   
;;;1293   #if USE_GDMACHANNEL0_DLPS
;;;1294       GDMA_Channel0->SAR      = GDMAChannel0_StoreReg[0];
;;;1295       GDMA_Channel0->DAR      = GDMAChannel0_StoreReg[1];
;;;1296       GDMA_Channel0->CTL_LOW  = GDMAChannel0_StoreReg[2];
;;;1297       GDMA_Channel0->CTL_HIGH = GDMAChannel0_StoreReg[3];
;;;1298       GDMA_Channel0->CFG_LOW  = GDMAChannel0_StoreReg[4];
;;;1299       GDMA_Channel0->CFG_HIGH = GDMAChannel0_StoreReg[5];
;;;1300   #endif
;;;1301   #if USE_GDMACHANNEL1_DLPS
;;;1302       GDMA_Channel1->SAR      = GDMAChannel1_StoreReg[0];
;;;1303       GDMA_Channel1->DAR      = GDMAChannel1_StoreReg[1];
;;;1304       GDMA_Channel1->CTL_LOW  = GDMAChannel1_StoreReg[2];
;;;1305       GDMA_Channel1->CTL_HIGH = GDMAChannel1_StoreReg[3];
;;;1306       GDMA_Channel1->CFG_LOW  = GDMAChannel1_StoreReg[4];
;;;1307       GDMA_Channel1->CFG_HIGH = GDMAChannel1_StoreReg[5];
;;;1308   #endif
;;;1309   #if USE_GDMACHANNEL2_DLPS
;;;1310       GDMA_Channel2->SAR      = GDMAChannel2_StoreReg[0];
;;;1311       GDMA_Channel2->DAR      = GDMAChannel2_StoreReg[1];
;;;1312       GDMA_Channel2->CTL_LOW  = GDMAChannel2_StoreReg[2];
;;;1313       GDMA_Channel2->CTL_HIGH = GDMAChannel2_StoreReg[3];
;;;1314       GDMA_Channel2->CFG_LOW  = GDMAChannel2_StoreReg[4];
;;;1315       GDMA_Channel2->CFG_HIGH = GDMAChannel2_StoreReg[5];
;;;1316   #endif
;;;1317   #if USE_GDMACHANNEL3_DLPS
;;;1318       GDMA_Channel3->SAR      = GDMAChannel3_StoreReg[0];
;;;1319       GDMA_Channel3->DAR      = GDMAChannel3_StoreReg[1];
;;;1320       GDMA_Channel3->CTL_LOW  = GDMAChannel3_StoreReg[2];
;;;1321       GDMA_Channel3->CTL_HIGH = GDMAChannel3_StoreReg[3];
;;;1322       GDMA_Channel3->CFG_LOW  = GDMAChannel3_StoreReg[4];
;;;1323       GDMA_Channel3->CFG_HIGH = GDMAChannel3_StoreReg[5];
;;;1324   #endif
;;;1325   #if USE_GDMACHANNEL4_DLPS
;;;1326       GDMA_Channel4->SAR      = GDMAChannel4_StoreReg[0];
;;;1327       GDMA_Channel4->DAR      = GDMAChannel4_StoreReg[1];
;;;1328       GDMA_Channel4->CTL_LOW  = GDMAChannel4_StoreReg[2];
;;;1329       GDMA_Channel4->CTL_HIGH = GDMAChannel4_StoreReg[3];
;;;1330       GDMA_Channel4->CFG_LOW  = GDMAChannel4_StoreReg[4];
;;;1331       GDMA_Channel4->CFG_HIGH = GDMAChannel4_StoreReg[5];
;;;1332   #endif
;;;1333   #if USE_GDMACHANNEL5_DLPS
;;;1334       GDMA_Channel5->SAR      = GDMAChannel5_StoreReg[0];
;;;1335       GDMA_Channel5->DAR      = GDMAChannel5_StoreReg[1];
;;;1336       GDMA_Channel5->CTL_LOW  = GDMAChannel5_StoreReg[2];
;;;1337       GDMA_Channel5->CTL_HIGH = GDMAChannel5_StoreReg[3];
;;;1338       GDMA_Channel5->CFG_LOW  = GDMAChannel5_StoreReg[4];
;;;1339       GDMA_Channel5->CFG_HIGH = GDMAChannel5_StoreReg[5];
;;;1340   #endif
;;;1341   
;;;1342       /*----------clear pending all interrupts of GDMA channel before enable channel-----------*/
;;;1343       GDMA_BASE->CLEAR_TFR = 0x3f;
;;;1344       GDMA_BASE->CLEAR_BLOCK = 0x3f;
;;;1345       GDMA_BASE->CLEAR_DST_TRAN = 0x3f;
;;;1346       GDMA_BASE->CLEAR_SRC_TRAN = 0x3f;
;;;1347       GDMA_BASE->CLEAR_ERR = 0x3f;
;;;1348   
;;;1349       /* Enable the selected DMA Channelx */
;;;1350   //    GDMA_BASE->ChEnReg = GDMA_StoreReg[1];
;;;1351   }
;;;1352   #endif
;;;1353   
;;;1354   /********************************************** ********************************************************/
;;;1355   /**************************************** [LCD DLPS] ************************************************/
;;;1356   /*******************************************************************************************************/
;;;1357   /*******************************************************************************************************/
;;;1358   #if USE_LCD_DLPS
;;;1359   
;;;1360   uint32_t LCD_StoreReg[5];
;;;1361   
;;;1362   /**
;;;1363     * @brief  LCD enter dlps callback function(Save LCD register values when system enter DLPS)
;;;1364     * @param  None
;;;1365     * @retval None
;;;1366     */
;;;1367   __STATIC_INLINE void LCD_DLPS_Enter(void)
;;;1368   {
;;;1369       /* Enable LCD 8080 interface controller function */
;;;1370       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1371       /* Enable LCD 8080 interface controller clock */
;;;1372       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1373   
;;;1374       LCD_StoreReg[0] = *((volatile uint32_t *)0x400002A8UL) & (0x03 << 28);
;;;1375       LCD_StoreReg[1] = LCD->IMR;
;;;1376       LCD_StoreReg[2] = LCD->CTRL0;
;;;1377       LCD_StoreReg[3] = LCD->CTRL1;
;;;1378       LCD_StoreReg[4] = LCD->CFG;
;;;1379   
;;;1380   }
;;;1381   
;;;1382   /**
;;;1383     * @brief  LCD exit dlps callback function(Resume LCD register values when system exit DLPS)
;;;1384     * @param  None
;;;1385     * @retval None
;;;1386     */
;;;1387   DATA_RAM_FUNCTION __STATIC_INLINE void LCD_DLPS_Exit(void)
;;;1388   {
;;;1389       /* Enable LCD 8080 interface controller function */
;;;1390       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1391       /* Enable LCD 8080 interface controller clock */
;;;1392       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1393   
;;;1394       /* Restore Dedicated SDIO pin option */
;;;1395       *((volatile uint32_t *)0x400002A8UL) &= ~(0x03 << 28);
;;;1396       *((volatile uint32_t *)0x400002A8UL) |= LCD_StoreReg[0];
;;;1397   
;;;1398       /* Initialize LCD */
;;;1399   
;;;1400       LCD->IMR    = LCD_StoreReg[1];
;;;1401       LCD->CTRL1  = LCD_StoreReg[3];
;;;1402       LCD->CFG    = LCD_StoreReg[4];
;;;1403       LCD->CTRL0  = LCD_StoreReg[2];
;;;1404   }
;;;1405   #endif
;;;1406   
;;;1407   /********************************************** ********************************************************/
;;;1408   /**************************************** [I2S0 DLPS] **************************************************/
;;;1409   /*******************************************************************************************************/
;;;1410   /*******************************************************************************************************/
;;;1411   #if USE_I2S0_DLPS
;;;1412   
;;;1413   uint32_t I2S0_StoreReg[4];
;;;1414   
;;;1415   /**
;;;1416     * @brief  I2S0 enter dlps callback function(Save I2S0 register values when system enter DLPS)
;;;1417     * @param  None
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void I2S0_DLPS_Enter(void)
;;;1421   {
;;;1422       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1423   
;;;1424       I2S0_StoreReg[0] = I2S0->BCLK_DIV;
;;;1425       I2S0_StoreReg[1] = I2S0->CTRL0;
;;;1426       I2S0_StoreReg[2] = I2S0->CTRL1;
;;;1427       I2S0_StoreReg[3] = I2S0->DMA_TRDLR;
;;;1428   }
;;;1429   
;;;1430   /**
;;;1431     * @brief  I2S0 exit dlps callback function(Resume I2S0 register values when system exit DLPS)
;;;1432     * @param  None
;;;1433     * @retval None
;;;1434     */
;;;1435   DATA_RAM_FUNCTION __STATIC_INLINE void I2S0_DLPS_Exit(void)
;;;1436   {
;;;1437       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1438   
;;;1439       /* Reset I2S0 module */
;;;1440       I2S0->CTRL0 |= 1 << 0;
;;;1441       I2S0->CTRL0 &= ~(1 << 0);
;;;1442   
;;;1443       /* Initialize I2S0 */
;;;1444       I2S0->BCLK_DIV  = I2S0_StoreReg[0];
;;;1445       I2S0->CTRL1     = I2S0_StoreReg[2];
;;;1446       I2S0->DMA_TRDLR = I2S0_StoreReg[3];
;;;1447       I2S0->CTRL0     = I2S0_StoreReg[1];
;;;1448   }
;;;1449   #endif
;;;1450   
;;;1451   /********************************************** ********************************************************/
;;;1452   /**************************************** [I2S1 DLPS] **************************************************/
;;;1453   /*******************************************************************************************************/
;;;1454   /*******************************************************************************************************/
;;;1455   #if USE_I2S1_DLPS
;;;1456   
;;;1457   uint32_t I2S1_StoreReg[4];
;;;1458   
;;;1459   /**
;;;1460     * @brief  I2S1 enter dlps callback function(Save I2S1 register values when system enter DLPS)
;;;1461     * @param  None
;;;1462     * @retval None
;;;1463     */
;;;1464   __STATIC_INLINE void I2S1_DLPS_Enter(void)
;;;1465   {
;;;1466       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1467   
;;;1468       I2S1_StoreReg[0] = I2S1->BCLK_DIV;
;;;1469       I2S1_StoreReg[1] = I2S1->CTRL0;
;;;1470       I2S1_StoreReg[2] = I2S1->CTRL1;
;;;1471       I2S1_StoreReg[3] = I2S1->DMA_TRDLR;
;;;1472   }
;;;1473   
;;;1474   /**
;;;1475     * @brief  I2S1 exit dlps callback function(Resume I2S1 register values when system exit DLPS)
;;;1476     * @param  None
;;;1477     * @retval None
;;;1478     */
;;;1479   DATA_RAM_FUNCTION __STATIC_INLINE void I2S1_DLPS_Exit(void)
;;;1480   {
;;;1481       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1482   
;;;1483       /* Reset I2S1 module */
;;;1484       I2S1->CTRL0 |= 1 << 0;
;;;1485       I2S1->CTRL0 &= ~(1 << 0);
;;;1486   
;;;1487       /* Initialize I2S1 */
;;;1488       I2S1->BCLK_DIV  = I2S1_StoreReg[0];
;;;1489       I2S1->CTRL1     = I2S1_StoreReg[2];
;;;1490       I2S1->DMA_TRDLR = I2S1_StoreReg[3];
;;;1491       I2S1->CTRL0     = I2S1_StoreReg[1];
;;;1492   }
;;;1493   #endif
;;;1494   
;;;1495   /********************************************** ********************************************************/
;;;1496   /**************************************** [CODEC DLPS] ************************************************/
;;;1497   /*******************************************************************************************************/
;;;1498   /*******************************************************************************************************/
;;;1499   #if USE_CODEC_DLPS
;;;1500   
;;;1501   uint32_t CODEC_StoreReg[7];
;;;1502   
;;;1503   /**
;;;1504     * @brief  CODEC enter dlps callback function(Save CODEC register values when system enter DLPS)
;;;1505     * @param  None
;;;1506     * @retval None
;;;1507     */
;;;1508   __STATIC_INLINE void CODEC_DLPS_Enter(void)
;;;1509   {
;;;1510       /* Enable codec function and clock */
;;;1511       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1512   
;;;1513       CODEC_StoreReg[0] = CODEC->CR0;
;;;1514       CODEC_StoreReg[1] = CODEC->CR1;
;;;1515       CODEC_StoreReg[2] = CODEC->CR2;
;;;1516       CODEC_StoreReg[3] = CODEC->CLK_CTRL;
;;;1517       CODEC_StoreReg[4] = CODEC->I2S_CTRL;
;;;1518       CODEC_StoreReg[5] = CODEC->ADC_CTRL;
;;;1519       CODEC_StoreReg[6] = CODEC->DAC_CTRL;
;;;1520   }
;;;1521   
;;;1522   /**
;;;1523     * @brief  CODEC exit dlps callback function(Resume CODEC register values when system exit DLPS)
;;;1524     * @param  None
;;;1525     * @retval None
;;;1526     */
;;;1527   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_DLPS_Exit(void)
;;;1528   {
;;;1529       /* Enable codec function and clock */
;;;1530       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1531   
;;;1532       /* Initialize CODEC */
;;;1533       if ((CODEC_StoreReg[3] & 0x900) == 0x900)
;;;1534       {
;;;1535           /* Configure AMIC parameters */
;;;1536           CODEC->CR0 = CODEC_StoreReg[0];
;;;1537           CODEC->CR1 = CODEC_StoreReg[1];
;;;1538           CODEC->CR2 = CODEC_StoreReg[2];
;;;1539       }
;;;1540   
;;;1541       /*  Reset audio digital IP */
;;;1542       CODEC->AUDIO_CTRL = 0;
;;;1543       CODEC->AUDIO_CTRL = 1;
;;;1544   
;;;1545       CODEC->CLK_CTRL = CODEC_StoreReg[3];
;;;1546       CODEC->I2S_CTRL = CODEC_StoreReg[4];
;;;1547       CODEC->ADC_CTRL = CODEC_StoreReg[5];
;;;1548       CODEC->DAC_CTRL = CODEC_StoreReg[6];
;;;1549   }
;;;1550   #endif
;;;1551   
;;;1552   /********************************************** ********************************************************/
;;;1553   /**************************************** [CODEC_EQ1 DLPS] ************************************************/
;;;1554   /*******************************************************************************************************/
;;;1555   /*******************************************************************************************************/
;;;1556   #if USE_CODEC_EQ1_DLPS
;;;1557   
;;;1558   uint32_t CODEC_EQ1_StoreReg[5];
;;;1559   
;;;1560   /**
;;;1561     * @brief  CODEC_EQ1 enter dlps callback function(Save CODEC_EQ1 register values when system enter DLPS)
;;;1562     * @param  None
;;;1563     * @retval None
;;;1564     */
;;;1565   __STATIC_INLINE void CODEC_EQ1_DLPS_Enter(void)
;;;1566   {
;;;1567       /* Enable codec function and clock */
;;;1568       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1569   
;;;1570       CODEC_EQ1_StoreReg[0] = CODEC_EQ1->EQ_H0;
;;;1571       CODEC_EQ1_StoreReg[1] = CODEC_EQ1->EQ_B1;
;;;1572       CODEC_EQ1_StoreReg[2] = CODEC_EQ1->EQ_B2;
;;;1573       CODEC_EQ1_StoreReg[3] = CODEC_EQ1->EQ_A1;
;;;1574       CODEC_EQ1_StoreReg[4] = CODEC_EQ1->EQ_A2;
;;;1575   }
;;;1576   
;;;1577   /**
;;;1578     * @brief  CODEC_EQ1 exit dlps callback function(Resume CODEC_EQ1 register values when system exit DLPS)
;;;1579     * @param  None
;;;1580     * @retval None
;;;1581     */
;;;1582   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ1_DLPS_Exit(void)
;;;1583   {
;;;1584       /* Enable codec function and clock */
;;;1585       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1586   
;;;1587       CODEC_EQ1->EQ_H0 = CODEC_EQ1_StoreReg[0];
;;;1588       CODEC_EQ1->EQ_B1 = CODEC_EQ1_StoreReg[1];
;;;1589       CODEC_EQ1->EQ_B2 = CODEC_EQ1_StoreReg[2];
;;;1590       CODEC_EQ1->EQ_A1 = CODEC_EQ1_StoreReg[3];
;;;1591       CODEC_EQ1->EQ_A2 = CODEC_EQ1_StoreReg[4];
;;;1592   }
;;;1593   #endif
;;;1594   
;;;1595   /********************************************** ********************************************************/
;;;1596   /**************************************** [CODEC_EQ2 DLPS] ************************************************/
;;;1597   /*******************************************************************************************************/
;;;1598   /*******************************************************************************************************/
;;;1599   #if USE_CODEC_EQ2_DLPS
;;;1600   
;;;1601   uint32_t CODEC_EQ2_StoreReg[5];
;;;1602   
;;;1603   /**
;;;1604     * @brief  CODEC_EQ2 enter dlps callback function(Save CODEC_EQ2 register values when system enter DLPS)
;;;1605     * @param  None
;;;1606     * @retval None
;;;1607     */
;;;1608   __STATIC_INLINE void CODEC_EQ2_DLPS_Enter(void)
;;;1609   {
;;;1610       /* Enable codec function and clock */
;;;1611       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1612   
;;;1613       CODEC_EQ2_StoreReg[0] = CODEC_EQ2->EQ_H0;
;;;1614       CODEC_EQ2_StoreReg[1] = CODEC_EQ2->EQ_B1;
;;;1615       CODEC_EQ2_StoreReg[2] = CODEC_EQ2->EQ_B2;
;;;1616       CODEC_EQ2_StoreReg[3] = CODEC_EQ2->EQ_A1;
;;;1617       CODEC_EQ2_StoreReg[4] = CODEC_EQ2->EQ_A2;
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  CODEC_EQ2 exit dlps callback function(Resume CODEC_EQ2 register values when system exit DLPS)
;;;1622     * @param  None
;;;1623     * @retval None
;;;1624     */
;;;1625   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ2_DLPS_Exit(void)
;;;1626   {
;;;1627       /* Enable codec function and clock */
;;;1628       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1629   
;;;1630       CODEC_EQ2->EQ_H0 = CODEC_EQ2_StoreReg[0];
;;;1631       CODEC_EQ2->EQ_B1 = CODEC_EQ2_StoreReg[1];
;;;1632       CODEC_EQ2->EQ_B2 = CODEC_EQ2_StoreReg[2];
;;;1633       CODEC_EQ2->EQ_A1 = CODEC_EQ2_StoreReg[3];
;;;1634       CODEC_EQ2->EQ_A2 = CODEC_EQ2_StoreReg[4];
;;;1635   }
;;;1636   #endif
;;;1637   
;;;1638   /********************************************** ********************************************************/
;;;1639   /**************************************** [CODEC_EQ3 DLPS] ************************************************/
;;;1640   /*******************************************************************************************************/
;;;1641   /*******************************************************************************************************/
;;;1642   #if USE_CODEC_EQ3_DLPS
;;;1643   
;;;1644   uint32_t CODEC_EQ3_StoreReg[5];
;;;1645   
;;;1646   /**
;;;1647     * @brief  CODEC_EQ3 enter dlps callback function(Save CODEC_EQ3 register values when system enter DLPS)
;;;1648     * @param  None
;;;1649     * @retval None
;;;1650     */
;;;1651   __STATIC_INLINE void CODEC_EQ3_DLPS_Enter(void)
;;;1652   {
;;;1653       /* Enable codec function and clock */
;;;1654       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1655   
;;;1656       CODEC_EQ3_StoreReg[0] = CODEC_EQ3->EQ_H0;
;;;1657       CODEC_EQ3_StoreReg[1] = CODEC_EQ3->EQ_B1;
;;;1658       CODEC_EQ3_StoreReg[2] = CODEC_EQ3->EQ_B2;
;;;1659       CODEC_EQ3_StoreReg[3] = CODEC_EQ3->EQ_A1;
;;;1660       CODEC_EQ3_StoreReg[4] = CODEC_EQ3->EQ_A2;
;;;1661   }
;;;1662   
;;;1663   /**
;;;1664     * @brief  CODEC_EQ3 exit dlps callback function(Resume CODEC_EQ3 register values when system exit DLPS)
;;;1665     * @param  None
;;;1666     * @retval None
;;;1667     */
;;;1668   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ3_DLPS_Exit(void)
;;;1669   {
;;;1670       /* Enable codec function and clock */
;;;1671       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1672   
;;;1673       CODEC_EQ3->EQ_H0 = CODEC_EQ3_StoreReg[0];
;;;1674       CODEC_EQ3->EQ_B1 = CODEC_EQ3_StoreReg[1];
;;;1675       CODEC_EQ3->EQ_B2 = CODEC_EQ3_StoreReg[2];
;;;1676       CODEC_EQ3->EQ_A1 = CODEC_EQ3_StoreReg[3];
;;;1677       CODEC_EQ3->EQ_A2 = CODEC_EQ3_StoreReg[4];
;;;1678   }
;;;1679   #endif
;;;1680   
;;;1681   /********************************************** ********************************************************/
;;;1682   /**************************************** [CODEC_EQ4 DLPS] ************************************************/
;;;1683   /*******************************************************************************************************/
;;;1684   /*******************************************************************************************************/
;;;1685   #if USE_CODEC_EQ4_DLPS
;;;1686   
;;;1687   uint32_t CODEC_EQ4_StoreReg[5];
;;;1688   
;;;1689   /**
;;;1690     * @brief  CODEC_EQ4 enter dlps callback function(Save CODEC_EQ4 register values when system enter DLPS)
;;;1691     * @param  None
;;;1692     * @retval None
;;;1693     */
;;;1694   __STATIC_INLINE void CODEC_EQ4_DLPS_Enter(void)
;;;1695   {
;;;1696       /* Enable codec function and clock */
;;;1697       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1698   
;;;1699       CODEC_EQ4_StoreReg[0] = CODEC_EQ4->EQ_H0;
;;;1700       CODEC_EQ4_StoreReg[1] = CODEC_EQ4->EQ_B1;
;;;1701       CODEC_EQ4_StoreReg[2] = CODEC_EQ4->EQ_B2;
;;;1702       CODEC_EQ4_StoreReg[3] = CODEC_EQ4->EQ_A1;
;;;1703       CODEC_EQ4_StoreReg[4] = CODEC_EQ4->EQ_A2;
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  CODEC_EQ4 exit dlps callback function(Resume CODEC_EQ4 register values when system exit DLPS)
;;;1708     * @param  None
;;;1709     * @retval None
;;;1710     */
;;;1711   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ4_DLPS_Exit(void)
;;;1712   {
;;;1713       /* Enable codec function and clock */
;;;1714       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1715   
;;;1716       CODEC_EQ4->EQ_H0 = CODEC_EQ4_StoreReg[0];
;;;1717       CODEC_EQ4->EQ_B1 = CODEC_EQ4_StoreReg[1];
;;;1718       CODEC_EQ4->EQ_B2 = CODEC_EQ4_StoreReg[2];
;;;1719       CODEC_EQ4->EQ_A1 = CODEC_EQ4_StoreReg[3];
;;;1720       CODEC_EQ4->EQ_A2 = CODEC_EQ4_StoreReg[4];
;;;1721   }
;;;1722   #endif
;;;1723   
;;;1724   /********************************************** ********************************************************/
;;;1725   /**************************************** [CODEC_EQ5 DLPS] ************************************************/
;;;1726   /*******************************************************************************************************/
;;;1727   /*******************************************************************************************************/
;;;1728   #if USE_CODEC_EQ5_DLPS
;;;1729   
;;;1730   uint32_t CODEC_EQ5_StoreReg[5];
;;;1731   
;;;1732   /**
;;;1733     * @brief  CODEC_EQ5 enter dlps callback function(Save CODEC_EQ5 register values when system enter DLPS)
;;;1734     * @param  None
;;;1735     * @retval None
;;;1736     */
;;;1737   __STATIC_INLINE void CODEC_EQ5_DLPS_Enter(void)
;;;1738   {
;;;1739       /* Enable codec function and clock */
;;;1740       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1741   
;;;1742       CODEC_EQ5_StoreReg[0] = CODEC_EQ5->EQ_H0;
;;;1743       CODEC_EQ5_StoreReg[1] = CODEC_EQ5->EQ_B1;
;;;1744       CODEC_EQ5_StoreReg[2] = CODEC_EQ5->EQ_B2;
;;;1745       CODEC_EQ5_StoreReg[3] = CODEC_EQ5->EQ_A1;
;;;1746       CODEC_EQ5_StoreReg[4] = CODEC_EQ5->EQ_A2;
;;;1747   }
;;;1748   
;;;1749   /**
;;;1750     * @brief  CODEC_EQ5 exit dlps callback function(Resume CODEC_EQ5 register values when system exit DLPS)
;;;1751     * @param  None
;;;1752     * @retval None
;;;1753     */
;;;1754   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ5_DLPS_Exit(void)
;;;1755   {
;;;1756       /* Enable codec function and clock */
;;;1757       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1758   
;;;1759       CODEC_EQ5->EQ_H0 = CODEC_EQ5_StoreReg[0];
;;;1760       CODEC_EQ5->EQ_B1 = CODEC_EQ5_StoreReg[1];
;;;1761       CODEC_EQ5->EQ_B2 = CODEC_EQ5_StoreReg[2];
;;;1762       CODEC_EQ5->EQ_A1 = CODEC_EQ5_StoreReg[3];
;;;1763       CODEC_EQ5->EQ_A2 = CODEC_EQ5_StoreReg[4];
;;;1764   }
;;;1765   #endif
;;;1766   
;;;1767   /**
;;;1768     * @brief  Set Log and SWD pins to SW mode.
;;;1769     * @param  void.
;;;1770     * @retval void.
;;;1771     */
;;;1772   __STATIC_INLINE void Log_SWD_DLPS_Enter(void)
;;;1773   {
;;;1774       if (OTP->SWD_ENABLE)
;;;1775       {
;;;1776           Pad_Config(P1_0, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1777           Pad_Config(P1_1, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1778       }
;;;1779   
;;;1780       Pad_Config(OTP->logPin, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1781   
;;;1782   }
;;;1783   
;;;1784   /**
;;;1785     * @brief  Set Log and SWD pins to PINMUX mode.
;;;1786     * @param  void.
;;;1787     * @retval void.
;;;1788     */
;;;1789   DATA_RAM_FUNCTION __STATIC_INLINE void Log_SWD_DLPS_Exit(void)
;;;1790   {
;;;1791       Pad_Config(OTP->logPin, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1792   
;;;1793       if (OTP->SWD_ENABLE)
;;;1794       {
;;;1795           Pad_Config(P1_0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1796           Pad_Config(P1_1, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1797       }
;;;1798   }
;;;1799   
;;;1800   /********************************************** ********************************************************/
;;;1801   /*********************************** [USER Exit DLPS CALLBACK FUCN] *****************************************/
;;;1802   /*******************************************************************************************************/
;;;1803   /*******************************************************************************************************/
;;;1804   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;1805   
;;;1806   DLPS_IO_ExitDlpsCB User_IO_ExitDlpsCB = NULL;
;;;1807   
;;;1808   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1809   
;;;1810   /********************************************** ********************************************************/
;;;1811   /*********************************** [USER Enter DLPS CALLBACK FUCN] *****************************************/
;;;1812   /*******************************************************************************************************/
;;;1813   /*******************************************************************************************************/
;;;1814   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1815   
;;;1816   DLPS_IO_EnterDlpsCB User_IO_EnterDlpsCB = NULL;
;;;1817   
;;;1818   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1819   
;;;1820   /********************************************** ********************************************************/
;;;1821   /*********************************** [Enter & Exit DLPS CALLBACK FUNC] *********************************/
;;;1822   /*******************************************************************************************************/
;;;1823   /*******************************************************************************************************/
;;;1824   #if USE_IO_DRIVER_DLPS
;;;1825   
;;;1826   /**
;;;1827     * @brief  IO enter dlps callback function
;;;1828     * @param  None
;;;1829     * @retval None
;;;1830     */
;;;1831   void DLPS_IO_EnterDlpsCb(void)
;;;1832   {
;;;1833       /* low stack do it instead */
;;;1834   //    Pad_ClearAllWakeupINT();
;;;1835   
;;;1836   //    DBG_DIRECT("DLPS_IO_EnterDlpsCb");
;;;1837       NVIC_DisableIRQ(System_IRQn);
;;;1838       CPU_DLPS_Enter();
;;;1839   
;;;1840       Pinmux_DLPS_Enter();
;;;1841   
;;;1842   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1843       if (User_IO_EnterDlpsCB)
        0x002088d8:    6898        .h      LDR      r0,[r3,#8]
        0x002088da:    b100        ..      CBZ      r0,0x2088de ; DLPS_IO_EnterDlpsCb + 106
;;;1844       {
;;;1845           User_IO_EnterDlpsCB();
        0x002088dc:    4780        .G      BLX      r0
;;; .\..\..\..\src\mcu\peripheral\rtl876x_io_dlps.c (154)
        0x002088de:    f04f4280    O..B    MOV      r2,#0x40000000
        0x002088e2:    f8d2021c    ....    LDR      r0,[r2,#0x21c]
        0x002088e6:    f4407080    @..p    ORR      r0,r0,#0x100
        0x002088ea:    f8c2021c    ....    STR      r0,[r2,#0x21c]
;;;155        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
        0x002088ee:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x002088f2:    f0407040    @.@p    ORR      r0,r0,#0x3000000
        0x002088f6:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;156    
;;;157        GPIO_StoreReg[0] = GPIO->DATAOUT;
        0x002088fa:    4924        $I      LDR      r1,[pc,#144] ; [0x20898c] = 0x40001000
        0x002088fc:    680b        .h      LDR      r3,[r1,#0]
        0x002088fe:    4820         H      LDR      r0,[pc,#128] ; [0x208980] = 0x20bbac
        0x00208900:    30ac        .0      ADDS     r0,r0,#0xac
;;;158        GPIO_StoreReg[1] = GPIO->DATADIR;
        0x00208902:    6003        .`      STR      r3,[r0,#0]
        0x00208904:    684b        Kh      LDR      r3,[r1,#4]
;;;159        GPIO_StoreReg[2] = GPIO->DATASRC;
        0x00208906:    6043        C`      STR      r3,[r0,#4]
        0x00208908:    688b        .h      LDR      r3,[r1,#8]
;;;160        GPIO_StoreReg[3] = GPIO->INTEN;
        0x0020890a:    6083        .`      STR      r3,[r0,#8]
        0x0020890c:    6b0b        .k      LDR      r3,[r1,#0x30]
;;;161        GPIO_StoreReg[4] = GPIO->INTMASK;
        0x0020890e:    60c3        .`      STR      r3,[r0,#0xc]
        0x00208910:    6b4b        Kk      LDR      r3,[r1,#0x34]
;;;162        GPIO_StoreReg[5] = GPIO->INTTYPE;
        0x00208912:    6103        .a      STR      r3,[r0,#0x10]
        0x00208914:    6b8b        .k      LDR      r3,[r1,#0x38]
;;;163        GPIO_StoreReg[6] = GPIO->INTPOLARITY;
        0x00208916:    6143        Ca      STR      r3,[r0,#0x14]
        0x00208918:    6bcb        .k      LDR      r3,[r1,#0x3c]
;;;164        GPIO_StoreReg[7] = GPIO->DEBOUNCE;
        0x0020891a:    6183        .a      STR      r3,[r0,#0x18]
        0x0020891c:    6c89        .l      LDR      r1,[r1,#0x48]
;;;165        GPIO_StoreReg[8] = *(__IO uint32_t *)(0x40000344UL);
        0x0020891e:    61c1        .a      STR      r1,[r0,#0x1c]
        0x00208920:    f8d21344    ..D.    LDR      r1,[r2,#0x344]
;;;166    
;;;167        return;
;;;168    }
;;;169    
;;;170    /**
;;;171      * @brief  GPIO exit dlps callback function(Resume GPIO register values when system exit DLPS)
;;;172      * @param  None
;;;173      * @retval None
;;;174      */
;;;175    DATA_RAM_FUNCTION __STATIC_INLINE void GPIO_DLPS_Exit(void)
;;;176    {
;;;177        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;178        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;179    
;;;180        GPIO->DATADIR       = GPIO_StoreReg[1];
;;;181        GPIO->DATASRC       = GPIO_StoreReg[2];
;;;182        GPIO->INTMASK       = GPIO_StoreReg[4];
;;;183        GPIO->INTTYPE       = GPIO_StoreReg[5];
;;;184        GPIO->INTPOLARITY   = GPIO_StoreReg[6];
;;;185        GPIO->DEBOUNCE      = GPIO_StoreReg[7];
;;;186        GPIO->DATAOUT       = GPIO_StoreReg[0];
;;;187        GPIO->INTCLR        = ~(GPIO_StoreReg[1]);
;;;188        GPIO->INTEN         = GPIO_StoreReg[3];
;;;189        *(__IO uint32_t *)(0x40000344UL) = GPIO_StoreReg[8];
;;;190    
;;;191        return;
;;;192    }
;;;193    #endif  /* USE_GPIO_DLPS */
;;;194    
;;;195    
;;;196    /********************************************** ********************************************************/
;;;197    /**************************************** [KEYSCAN DLPS] ***********************************************/
;;;198    /*******************************************************************************************************/
;;;199    /*******************************************************************************************************/
;;;200    #if USE_KEYSCAN_DLPS
;;;201    __STATIC_INLINE void KeyScan_DLPS_Enter(void);
;;;202    __STATIC_INLINE void KeyScan_DLPS_Exit(void);
;;;203    
;;;204    uint32_t KeyScan_StoreReg[7];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;205    
;;;206    /**
;;;207      * @brief  KEYSCAN enter dlps callback function(Save KEYSCAN register values when system enter DLPS)
;;;208      * @param  None
;;;209      * @retval None
;;;210      */
;;;211    __STATIC_INLINE void KeyScan_DLPS_Enter(void)
;;;212    {
;;;213        /*Open 5M clock source*/
;;;214        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;215        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;216    
;;;217        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;218        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;219    
;;;220        KeyScan_StoreReg[0] = KEYSCAN->CLKDIV;               /* 0x00 */
;;;221        KeyScan_StoreReg[1] = KEYSCAN->TIMERCR;              /* 0x04 */
;;;222        KeyScan_StoreReg[2] = KEYSCAN->CR;                   /* 0x08 */
;;;223        KeyScan_StoreReg[3] = KEYSCAN->COLCR;                /* 0x0C */
;;;224        KeyScan_StoreReg[4] = KEYSCAN->ROWCR;                /* 0x10 */
;;;225        KeyScan_StoreReg[6] = KEYSCAN->INTMASK;              /* 0x18 */
;;;226    
;;;227        return;
;;;228    }
;;;229    
;;;230    /**
;;;231      * @brief  KEYSCAN exit dlps callback function(Resume KEYSCAN register values when system exit DLPS)
;;;232      * @param  None
;;;233      * @retval None
;;;234      */
;;;235    DATA_RAM_FUNCTION __STATIC_INLINE void KeyScan_DLPS_Exit(void)
;;;236    {
;;;237        /*Open 5M clock source*/
;;;238        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;239        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;240    
;;;241        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;242        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;243    
;;;244        /* Set FSM to idle state */
;;;245        KEYSCAN->CR &= ~BIT31;
;;;246        KEYSCAN->CLKDIV = KeyScan_StoreReg[0];
;;;247        KEYSCAN->CR = (KeyScan_StoreReg[2] & (~(BIT31)));
;;;248        KEYSCAN->TIMERCR = KeyScan_StoreReg[1];
;;;249        KEYSCAN->COLCR = KeyScan_StoreReg[3];
;;;250        KEYSCAN->ROWCR = KeyScan_StoreReg[4];
;;;251        KEYSCAN->INTMASK = KeyScan_StoreReg[6];
;;;252        KEYSCAN->CR |= (KeyScan_StoreReg[2] & ((BIT31)));
;;;253    
;;;254        return;
;;;255    }
;;;256    #endif /* USE_KEYSCAN_DLPS */
;;;257    
;;;258    
;;;259    /********************************************** ********************************************************/
;;;260    /**************************************** [QDEC DLPS] **************************************************/
;;;261    /*******************************************************************************************************/
;;;262    /*******************************************************************************************************/
;;;263    #if USE_QDECODER_DLPS
;;;264    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void);
;;;265    __STATIC_INLINE void QuadDecoder_DLPS_Exit(void);
;;;266    
;;;267    uint32_t QuadDecoder_StoreReg[5];  /*  This array should be placed in RAM ON/Buffer ON.    */
;;;268    
;;;269    /**
;;;270      * @brief  QDEC enter dlps callback function(Save QDEC register values when system enter DLPS)
;;;271      * @param  None
;;;272      * @retval None
;;;273      */
;;;274    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void)
;;;275    {
;;;276        /*Open 20M clock source*/
;;;277        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;278        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;279        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;280        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;281    
;;;282        QuadDecoder_StoreReg[0] = QDEC->REG_DIV;
;;;283        QuadDecoder_StoreReg[1] = QDEC->REG_CR_X;
;;;284        QuadDecoder_StoreReg[2] = QDEC->REG_CR_Y;
;;;285        QuadDecoder_StoreReg[3] = QDEC->REG_CR_Z;
;;;286        QuadDecoder_StoreReg[4] = QDEC->INT_MASK;
;;;287    
;;;288        return;
;;;289    }
;;;290    
;;;291    /**
;;;292      * @brief  QDEC exit dlps callback function(Resume QDEC register values when system exit DLPS)
;;;293      * @param  None
;;;294      * @retval None
;;;295      */
;;;296    DATA_RAM_FUNCTION __STATIC_INLINE void QuadDecoder_DLPS_Exit(void)
;;;297    {
;;;298        /*Open 20M clock source*/
;;;299        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;300        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;301        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;302        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;303    
;;;304        //clear flags
;;;305        QDEC->REG_DIV  = QuadDecoder_StoreReg[0];
;;;306        QDEC->REG_CR_X = QuadDecoder_StoreReg[1];
;;;307        QDEC->REG_CR_Y = QuadDecoder_StoreReg[2];
;;;308        QDEC->REG_CR_Z = QuadDecoder_StoreReg[3];
;;;309        QDEC->INT_MASK = QuadDecoder_StoreReg[4];
;;;310    
;;;311        return;
;;;312    }
;;;313    #endif
;;;314    
;;;315    /********************************************** ********************************************************/
;;;316    /**************************************** [SPI0 DLPS] **************************************************/
;;;317    /*******************************************************************************************************/
;;;318    /*******************************************************************************************************/
;;;319    #if USE_SPI0_DLPS
;;;320    __STATIC_INLINE void SPI0_DLPS_Enter(void);
;;;321    __STATIC_INLINE void SPI0_DLPS_Exit(void);
;;;322    
;;;323    uint32_t SPI0_StoreReg[13];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;324    
;;;325    /**
;;;326      * @brief  SPI0 enter dlps callback function(Save SPI0 register values when system enter DLPS)
;;;327      * @param  None
;;;328      * @retval None
;;;329      */
;;;330    __STATIC_INLINE void SPI0_DLPS_Enter(void)
;;;331    {
;;;332        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;333        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;334    
;;;335        SPI0_StoreReg[0] = SPI0->CTRLR0;
;;;336        SPI0_StoreReg[1] = SPI0->CTRLR1;
;;;337        SPI0_StoreReg[2] = SPI0->SSIENR;
;;;338        SPI0_StoreReg[3] = SPI0->SER;
;;;339        SPI0_StoreReg[4] = SPI0->BAUDR;
;;;340        SPI0_StoreReg[5] = SPI0->TXFTLR;
;;;341        SPI0_StoreReg[6] = SPI0->RXFTLR;
;;;342        SPI0_StoreReg[7] = SPI0->IMR;
;;;343        SPI0_StoreReg[8] = SPI0->DMACR;
;;;344        SPI0_StoreReg[9] = SPI0->DMATDLR;
;;;345        SPI0_StoreReg[10] = SPI0->DMARDLR;
;;;346        SPI0_StoreReg[11] = SPI0->RX_SAMPLE_DLY;
;;;347        SPI0_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;348    }
;;;349    
;;;350    /**
;;;351      * @brief  SPI0 exit dlps callback function(Resume SPI0 register values when system exit DLPS)
;;;352      * @param  None
;;;353      * @retval None
;;;354      */
;;;355    DATA_RAM_FUNCTION __STATIC_INLINE void SPI0_DLPS_Exit(void)
;;;356    {
;;;357        *(volatile uint32_t *)0x40000308 = SPI0_StoreReg[12];
;;;358        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;359        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;360    
;;;361        SPI0->CTRLR0 = SPI0_StoreReg[0];
;;;362        SPI0->CTRLR1 = SPI0_StoreReg[1];
;;;363        SPI0->SER = SPI0_StoreReg[3];
;;;364        SPI0->BAUDR = SPI0_StoreReg[4];
;;;365        SPI0->TXFTLR = SPI0_StoreReg[5];
;;;366        SPI0->RXFTLR = SPI0_StoreReg[6];
;;;367        SPI0->IMR = SPI0_StoreReg[7];
;;;368        SPI0->DMACR = SPI0_StoreReg[8];
;;;369        SPI0->DMATDLR = SPI0_StoreReg[9];
;;;370        SPI0->DMARDLR = SPI0_StoreReg[10];
;;;371        SPI0->RX_SAMPLE_DLY = SPI0_StoreReg[11];
;;;372    
;;;373        /* Enable the selected SPI peripheral */
;;;374        SPI0->SSIENR = SPI0_StoreReg[2];
;;;375    }
;;;376    #endif
;;;377    
;;;378    
;;;379    /********************************************** ********************************************************/
;;;380    /**************************************** [SPI1 DLPS] **************************************************/
;;;381    /*******************************************************************************************************/
;;;382    /*******************************************************************************************************/
;;;383    #if USE_SPI1_DLPS
;;;384    __STATIC_INLINE void SPI1_DLPS_Enter(void);
;;;385    __STATIC_INLINE void SPI1_DLPS_Exit(void);
;;;386    
;;;387    uint32_t SPI1_StoreReg[13];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;388    
;;;389    /**
;;;390      * @brief  SPI1 enter dlps callback function(Save SPI1 register values when system enter DLPS)
;;;391      * @param  None
;;;392      * @retval None
;;;393      */
;;;394    __STATIC_INLINE void SPI1_DLPS_Enter(void)
;;;395    {
;;;396        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;397        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;398    
;;;399        SPI1_StoreReg[0] = SPI1->CTRLR0;
;;;400        SPI1_StoreReg[1] = SPI1->CTRLR1;
;;;401        SPI1_StoreReg[2] = SPI1->SSIENR;
;;;402        SPI1_StoreReg[3] = SPI1->SER;
;;;403        SPI1_StoreReg[4] = SPI1->BAUDR;
;;;404        SPI1_StoreReg[5] = SPI1->TXFTLR;
;;;405        SPI1_StoreReg[6] = SPI1->RXFTLR;
;;;406        SPI1_StoreReg[7] = SPI1->IMR;
;;;407        SPI1_StoreReg[8] = SPI1->DMACR;
;;;408        SPI1_StoreReg[9] = SPI1->DMATDLR;
;;;409        SPI1_StoreReg[10] = SPI1->DMARDLR;
;;;410        SPI1_StoreReg[11] = SPI1->RX_SAMPLE_DLY;
;;;411        SPI1_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;412    }
;;;413    
;;;414    /**
;;;415      * @brief  SPI1 exit dlps callback function(Resume SPI1 register values when system exit DLPS)
;;;416      * @param  None
;;;417      * @retval None
;;;418      */
;;;419    DATA_RAM_FUNCTION __STATIC_INLINE void SPI1_DLPS_Exit(void)
;;;420    {
;;;421        *(volatile uint32_t *)0x40000308 = SPI1_StoreReg[12];
;;;422        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;423        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;424    
;;;425        SPI1->CTRLR0 = SPI1_StoreReg[0];
;;;426        SPI1->CTRLR1 = SPI1_StoreReg[1];
;;;427        SPI1->SER = SPI1_StoreReg[3];
;;;428        SPI1->BAUDR = SPI1_StoreReg[4];
;;;429        SPI1->TXFTLR = SPI1_StoreReg[5];
;;;430        SPI1->RXFTLR = SPI1_StoreReg[6];
;;;431        SPI1->IMR = SPI1_StoreReg[7];
;;;432        SPI1->DMACR = SPI1_StoreReg[8];
;;;433        SPI1->DMATDLR = SPI1_StoreReg[9];
;;;434        SPI1->DMARDLR = SPI1_StoreReg[10];
;;;435        SPI1->RX_SAMPLE_DLY = SPI1_StoreReg[11];
;;;436    
;;;437        /* Enable the selected SPI peripheral */
;;;438        SPI1->SSIENR = SPI1_StoreReg[2];
;;;439    }
;;;440    #endif
;;;441    
;;;442    /********************************************** ********************************************************/
;;;443    /**************************************** [SPI2W DLPS] **************************************************/
;;;444    /*******************************************************************************************************/
;;;445    /*******************************************************************************************************/
;;;446    #if USE_SPI2W_DLPS
;;;447    __STATIC_INLINE void SPI2W_DLPS_Enter(void);
;;;448    __STATIC_INLINE void SPI2W_DLPS_Exit(void);
;;;449    
;;;450    uint32_t SPI2W_StoreReg[1];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;451    
;;;452    /**
;;;453      * @brief  SPI2W enter dlps callback function(Save SPI2W register values when system enter DLPS)
;;;454      * @param  None
;;;455      * @retval None
;;;456      */
;;;457    __STATIC_INLINE void SPI2W_DLPS_Enter(void)
;;;458    {
;;;459        /*Open 20M clock source*/
;;;460        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;461        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;462    
;;;463        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;464        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;465    
;;;466        SPI2W_StoreReg[0] = SPI3WIRE->CFGR;
;;;467    }
;;;468    
;;;469    /**
;;;470      * @brief  SPI2W exit dlps callback function(Resume SPI2W register values when system exit DLPS)
;;;471      * @param  None
;;;472      * @retval None
;;;473      */
;;;474    DATA_RAM_FUNCTION __STATIC_INLINE void SPI2W_DLPS_Exit(void)
;;;475    {
;;;476        /*Open 20M clock source*/
;;;477        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;478        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;479    
;;;480        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;481        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;482    
;;;483        SPI3WIRE->CFGR = SPI2W_StoreReg[0];
;;;484    }
;;;485    #endif
;;;486    
;;;487    /********************************************** ********************************************************/
;;;488    /**************************************** [I2C0 DLPS] **************************************************/
;;;489    /*******************************************************************************************************/
;;;490    /*******************************************************************************************************/
;;;491    #if USE_I2C0_DLPS
;;;492    __STATIC_INLINE void I2C0_DLPS_Enter(void);
;;;493    __STATIC_INLINE void I2C0_DLPS_Exit(void);
;;;494    
;;;495    uint32_t I2C0_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;496    
;;;497    /**
;;;498      * @brief  I2C0 enter dlps callback function(Save I2C0 register values when system enter DLPS)
;;;499      * @param  None
;;;500      * @retval None
;;;501      */
;;;502    __STATIC_INLINE void I2C0_DLPS_Enter(void)
;;;503    {
;;;504        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;505        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;506    
;;;507        I2C0_StoreReg[0] = I2C0->IC_CON;
;;;508        I2C0_StoreReg[1] = I2C0->IC_TAR;
;;;509        I2C0_StoreReg[2] = I2C0->IC_SAR;
;;;510        I2C0_StoreReg[3] = I2C0->IC_HS_MADDR;
;;;511    
;;;512        I2C0_StoreReg[4] = I2C0->IC_SS_SCL_HCNT;
;;;513        I2C0_StoreReg[5] = I2C0->IC_SS_SCL_LCNT;
;;;514        I2C0_StoreReg[6] = I2C0->IC_FS_SCL_HCNT;
;;;515        I2C0_StoreReg[7] = I2C0->IC_FS_SCL_LCNT;
;;;516        I2C0_StoreReg[8] = I2C0->IC_HS_SCL_HCNT;
;;;517        I2C0_StoreReg[9] = I2C0->IC_HS_SCL_LCNT;
;;;518    
;;;519        I2C0_StoreReg[10] = I2C0->IC_INTR_MASK;
;;;520        I2C0_StoreReg[11] = I2C0->IC_RX_TL;
;;;521        I2C0_StoreReg[12] = I2C0->IC_TX_TL;
;;;522        I2C0_StoreReg[13] = I2C0->IC_ENABLE;
;;;523        I2C0_StoreReg[14] = I2C0->IC_SDA_HOLD;
;;;524        I2C0_StoreReg[15] = I2C0->IC_SLV_DATA_NACK_ONLY;
;;;525        I2C0_StoreReg[16] = I2C0->IC_DMA_CR;
;;;526        I2C0_StoreReg[17] = I2C0->IC_DMA_TDLR;
;;;527        I2C0_StoreReg[18] = I2C0->IC_DMA_RDLR;
;;;528    
;;;529        I2C0_StoreReg[19] = I2C0->IC_SDA_SETUP;
;;;530    }
;;;531    
;;;532    /**
;;;533      * @brief  I2C0 exit dlps callback function(Resume I2C0 register values when system exit DLPS)
;;;534      * @param  None
;;;535      * @retval None
;;;536      */
;;;537    DATA_RAM_FUNCTION __STATIC_INLINE void I2C0_DLPS_Exit(void)
;;;538    {
;;;539        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;540        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;541    
;;;542        I2C0->IC_CON = I2C0_StoreReg[0];
;;;543        I2C0->IC_TAR = I2C0_StoreReg[1];
;;;544        I2C0->IC_SAR = I2C0_StoreReg[2];
;;;545        I2C0->IC_HS_MADDR = I2C0_StoreReg[3];
;;;546    
;;;547        I2C0->IC_SS_SCL_HCNT = I2C0_StoreReg[4];
;;;548        I2C0->IC_SS_SCL_LCNT = I2C0_StoreReg[5];
;;;549        I2C0->IC_FS_SCL_HCNT = I2C0_StoreReg[6];
;;;550        I2C0->IC_FS_SCL_LCNT = I2C0_StoreReg[7];
;;;551        I2C0->IC_HS_SCL_HCNT = I2C0_StoreReg[8];
;;;552        I2C0->IC_HS_SCL_LCNT = I2C0_StoreReg[9];
;;;553    
;;;554        I2C0->IC_INTR_MASK = I2C0_StoreReg[10];
;;;555        I2C0->IC_RX_TL = I2C0_StoreReg[11];
;;;556        I2C0->IC_TX_TL = I2C0_StoreReg[12];
;;;557        I2C0->IC_SDA_HOLD = I2C0_StoreReg[14];
;;;558        I2C0->IC_SLV_DATA_NACK_ONLY = I2C0_StoreReg[15];
;;;559        I2C0->IC_DMA_CR = I2C0_StoreReg[16];
;;;560        I2C0->IC_DMA_TDLR = I2C0_StoreReg[17];
;;;561        I2C0->IC_DMA_RDLR = I2C0_StoreReg[18];
;;;562        I2C0->IC_SDA_SETUP = I2C0_StoreReg[19];
;;;563    
;;;564        I2C0->IC_ENABLE = I2C0_StoreReg[13];
;;;565    }
;;;566    #endif
;;;567    
;;;568    /********************************************** ********************************************************/
;;;569    /**************************************** [I2C1 DLPS] **************************************************/
;;;570    /*******************************************************************************************************/
;;;571    /*******************************************************************************************************/
;;;572    #if USE_I2C1_DLPS
;;;573    __STATIC_INLINE void I2C1_DLPS_Enter(void);
;;;574    __STATIC_INLINE void I2C1_DLPS_Exit(void);
;;;575    
;;;576    uint32_t I2C1_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;577    
;;;578    /**
;;;579      * @brief  I2C1 enter dlps callback function(Save I2C1 register values when system enter DLPS)
;;;580      * @param  None
;;;581      * @retval None
;;;582      */
;;;583    __STATIC_INLINE void I2C1_DLPS_Enter(void)
;;;584    {
;;;585        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;586        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;587    
;;;588        I2C1_StoreReg[0] = I2C1->IC_CON;
;;;589        I2C1_StoreReg[1] = I2C1->IC_TAR;
;;;590        I2C1_StoreReg[2] = I2C1->IC_SAR;
;;;591        I2C1_StoreReg[3] = I2C1->IC_HS_MADDR;
;;;592    
;;;593        I2C1_StoreReg[4] = I2C1->IC_SS_SCL_HCNT;
;;;594        I2C1_StoreReg[5] = I2C1->IC_SS_SCL_LCNT;
;;;595        I2C1_StoreReg[6] = I2C1->IC_FS_SCL_HCNT;
;;;596        I2C1_StoreReg[7] = I2C1->IC_FS_SCL_LCNT;
;;;597        I2C1_StoreReg[8] = I2C1->IC_HS_SCL_HCNT;
;;;598        I2C1_StoreReg[9] = I2C1->IC_HS_SCL_LCNT;
;;;599    
;;;600        I2C1_StoreReg[10] = I2C1->IC_INTR_MASK;
;;;601        I2C1_StoreReg[11] = I2C1->IC_RX_TL;
;;;602        I2C1_StoreReg[12] = I2C1->IC_TX_TL;
;;;603        I2C1_StoreReg[13] = I2C1->IC_ENABLE;
;;;604        I2C1_StoreReg[14] = I2C1->IC_SDA_HOLD;
;;;605        I2C1_StoreReg[15] = I2C1->IC_SLV_DATA_NACK_ONLY;
;;;606        I2C1_StoreReg[16] = I2C1->IC_DMA_CR;
;;;607        I2C1_StoreReg[17] = I2C1->IC_DMA_TDLR;
;;;608        I2C1_StoreReg[18] = I2C1->IC_DMA_RDLR;
;;;609    
;;;610        I2C1_StoreReg[19] = I2C1->IC_SDA_SETUP;
;;;611    }
;;;612    
;;;613    /**
;;;614      * @brief  I2C1 exit dlps callback function(Resume I2C1 register values when system exit DLPS)
;;;615      * @param  None
;;;616      * @retval None
;;;617      */
;;;618    DATA_RAM_FUNCTION __STATIC_INLINE void I2C1_DLPS_Exit(void)
;;;619    {
;;;620        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;621        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;622    
;;;623        I2C1->IC_CON = I2C1_StoreReg[0];
;;;624        I2C1->IC_TAR = I2C1_StoreReg[1];
;;;625        I2C1->IC_SAR = I2C1_StoreReg[2];
;;;626        I2C0->IC_HS_MADDR = I2C1_StoreReg[3];
;;;627    
;;;628        I2C1->IC_SS_SCL_HCNT = I2C1_StoreReg[4];
;;;629        I2C1->IC_SS_SCL_LCNT = I2C1_StoreReg[5];
;;;630        I2C1->IC_FS_SCL_HCNT = I2C1_StoreReg[6];
;;;631        I2C1->IC_FS_SCL_LCNT = I2C1_StoreReg[7];
;;;632        I2C1->IC_HS_SCL_HCNT = I2C1_StoreReg[8];
;;;633        I2C1->IC_HS_SCL_LCNT = I2C1_StoreReg[9];
;;;634    
;;;635        I2C1->IC_INTR_MASK = I2C1_StoreReg[10];
;;;636        I2C1->IC_RX_TL = I2C1_StoreReg[11];
;;;637        I2C1->IC_TX_TL = I2C1_StoreReg[12];
;;;638        I2C1->IC_SDA_HOLD = I2C1_StoreReg[14];
;;;639        I2C1->IC_SLV_DATA_NACK_ONLY = I2C1_StoreReg[15];
;;;640        I2C1->IC_DMA_CR = I2C1_StoreReg[16];
;;;641        I2C1->IC_DMA_TDLR = I2C1_StoreReg[17];
;;;642        I2C1->IC_DMA_RDLR = I2C1_StoreReg[18];
;;;643        I2C1->IC_SDA_SETUP = I2C1_StoreReg[19];
;;;644    
;;;645        I2C1->IC_ENABLE = I2C1_StoreReg[13];
;;;646    }
;;;647    #endif
;;;648    
;;;649    /********************************************** ********************************************************/
;;;650    /**************************************** [Timer & PWM DLPS] *******************************************/
;;;651    /*******************************************************************************************************/
;;;652    /*******************************************************************************************************/
;;;653    #if USE_TIM_DLPS
;;;654    #include "rtl876x_tim.h"
;;;655    __STATIC_INLINE void TIM_DLPS_Enter(void);
;;;656    __STATIC_INLINE void TIM_DLPS_Exit(void);
;;;657    
;;;658    uint32_t TIM_StoreReg[26];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;659    
;;;660    /* PWM, use with timer */
;;;661    uint32_t PWM0_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;662    
;;;663    uint32_t PWM1_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;664    
;;;665    /**
;;;666      * @brief  TIMER enter dlps callback function(Save TIMER register values when system enter DLPS)
;;;667      * @param  None
;;;668      * @retval None
;;;669      */
;;;670    __STATIC_INLINE void TIM_DLPS_Enter(void)
;;;671    {
;;;672        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;673        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;674    
;;;675        TIM_StoreReg[0] = TIM0->LoadCount;
;;;676        TIM_StoreReg[1] = TIM0->ControlReg;
;;;677        TIM_StoreReg[2] = TIMER0_LOAD_COUNT2;
;;;678    
;;;679        TIM_StoreReg[3] = TIM1->LoadCount;
;;;680        TIM_StoreReg[4] = TIM1->ControlReg;
;;;681        TIM_StoreReg[5] = TIMER1_LOAD_COUNT2;
;;;682    
;;;683        TIM_StoreReg[6] = TIM2->LoadCount;
;;;684        TIM_StoreReg[7] = TIM2->ControlReg;
;;;685        TIM_StoreReg[8] = TIMER2_LOAD_COUNT2;
;;;686    
;;;687        TIM_StoreReg[9] = TIM3->LoadCount;
;;;688        TIM_StoreReg[10] = TIM3->ControlReg;
;;;689        TIM_StoreReg[11] = TIMER3_LOAD_COUNT2;
;;;690    
;;;691        TIM_StoreReg[12] = TIM4->LoadCount;
;;;692        TIM_StoreReg[13] = TIM4->ControlReg;
;;;693        TIM_StoreReg[14] = TIMER4_LOAD_COUNT2;
;;;694    
;;;695        TIM_StoreReg[15] = TIM5->LoadCount;
;;;696        TIM_StoreReg[16] = TIM5->ControlReg;
;;;697        TIM_StoreReg[17] = TIMER5_LOAD_COUNT2;
;;;698    
;;;699        TIM_StoreReg[18] = TIM6->LoadCount;
;;;700        TIM_StoreReg[19] = TIM6->ControlReg;
;;;701        TIM_StoreReg[20] = TIMER6_LOAD_COUNT2;
;;;702    
;;;703        TIM_StoreReg[21] = TIM7->LoadCount;
;;;704        TIM_StoreReg[22] = TIM7->ControlReg;
;;;705        TIM_StoreReg[23] = TIMER7_LOAD_COUNT2;
;;;706    
;;;707        TIM_StoreReg[24] = *((volatile uint32_t *)0x4000035CUL);
;;;708        TIM_StoreReg[25] = *((volatile uint32_t *)0x40000360UL);
;;;709    
;;;710        PWM0_StoreReg = TIMER_PWM0_CR;
;;;711    
;;;712        PWM1_StoreReg = TIMER_PWM1_CR;
;;;713    }
;;;714    
;;;715    /**
;;;716      * @brief  TIMER exit dlps callback function(Resume TIMER register values when system exit DLPS)
;;;717      * @param  None
;;;718      * @retval None
;;;719      */
;;;720    DATA_RAM_FUNCTION __STATIC_INLINE void TIM_DLPS_Exit(void)
;;;721    {
;;;722        /* Enable timer IP clock and function */
;;;723        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;724        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;725    
;;;726        *((volatile uint32_t *)0x4000035CUL) = TIM_StoreReg[24];
;;;727        *((volatile uint32_t *)0x40000360UL) = TIM_StoreReg[25];
;;;728    
;;;729        TIM0->LoadCount = TIM_StoreReg[0];
;;;730        TIM0->ControlReg = TIM_StoreReg[1];
;;;731        TIMER0_LOAD_COUNT2 = TIM_StoreReg[2];
;;;732    
;;;733        TIM1->LoadCount = TIM_StoreReg[3];
;;;734        TIM1->ControlReg = TIM_StoreReg[4];
;;;735        TIMER1_LOAD_COUNT2 = TIM_StoreReg[5];
;;;736    
;;;737        TIM2->LoadCount = TIM_StoreReg[6];
;;;738        TIM2->ControlReg = TIM_StoreReg[7];
;;;739        TIMER2_LOAD_COUNT2 = TIM_StoreReg[8];
;;;740    
;;;741        TIM3->LoadCount = TIM_StoreReg[9];
;;;742        TIM3->ControlReg = TIM_StoreReg[10];
;;;743        TIMER3_LOAD_COUNT2 = TIM_StoreReg[11];
;;;744    
;;;745        TIM4->LoadCount = TIM_StoreReg[12];
;;;746        TIM4->ControlReg = TIM_StoreReg[13];
;;;747        TIMER4_LOAD_COUNT2 = TIM_StoreReg[14];
;;;748    
;;;749        TIM5->LoadCount = TIM_StoreReg[15];
;;;750        TIM5->ControlReg = TIM_StoreReg[16];
;;;751        TIMER5_LOAD_COUNT2 = TIM_StoreReg[17];
;;;752    
;;;753        TIM6->LoadCount = TIM_StoreReg[18];
;;;754        TIM6->ControlReg = TIM_StoreReg[19];
;;;755        TIMER6_LOAD_COUNT2 = TIM_StoreReg[20];
;;;756    
;;;757        TIM7->LoadCount = TIM_StoreReg[21];
;;;758        TIM7->ControlReg = TIM_StoreReg[22];
;;;759        TIMER7_LOAD_COUNT2 = TIM_StoreReg[23];
;;;760    
;;;761        TIMER_PWM0_CR = PWM0_StoreReg;
;;;762    
;;;763        TIMER_PWM1_CR = PWM1_StoreReg;
;;;764    }
;;;765    #endif  /* USE_TIM_DLPS */
;;;766    
;;;767    
;;;768    /********************************************** ********************************************************/
;;;769    /**************************************** [UART DLPS] **************************************************/
;;;770    /*******************************************************************************************************/
;;;771    /*******************************************************************************************************/
;;;772    #if USE_UART_DLPS
;;;773    #include "rtl876x_uart.h"
;;;774    
;;;775    __STATIC_INLINE void UART_DLPS_Enter(void);
;;;776    __STATIC_INLINE void UART_DLPS_Exit(void);
;;;777    
;;;778    uint32_t UART_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;779    
;;;780    /**
;;;781      * @brief  UART enter dlps callback function(Save UART register values when system enter DLPS)
;;;782      * @param  None
;;;783      * @retval None
;;;784      */
;;;785    __STATIC_INLINE void UART_DLPS_Enter(void)
;;;786    {
;;;787        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;788        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;789    
;;;790        //access DLH and DLL
;;;791        UART->LCR |= (1 << 7);
;;;792        UART_StoreReg[0] = UART->DLL;
;;;793        UART_StoreReg[1] = UART->DLH_INTCR;
;;;794        UART->LCR &= (~(1 << 7));
;;;795    
;;;796        //save other registers
;;;797        UART_StoreReg[2] = UART->DLH_INTCR;
;;;798        UART_StoreReg[4] = UART->LCR;
;;;799        UART_StoreReg[5] = UART->MCR;
;;;800        UART_StoreReg[6] = UART->SPR;
;;;801        UART_StoreReg[7] = UART->STSR;
;;;802        UART_StoreReg[8] = UART->RX_IDLE_INTTCR;
;;;803        UART_StoreReg[9] = UART->RXIDLE_INTCR;
;;;804        UART_StoreReg[10] = UART->MISCR;
;;;805    
;;;806        return;
;;;807    }
;;;808    
;;;809    /**
;;;810      * @brief  UART exit dlps callback function(Resume UART register values when system exit DLPS)
;;;811      * @param  None
;;;812      * @retval None
;;;813      */
;;;814    DATA_RAM_FUNCTION __STATIC_INLINE void UART_DLPS_Exit(void)
;;;815    {
;;;816        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;817        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;818    
;;;819        //access DLH and DLL
;;;820        UART->LCR |= (1 << 7);
;;;821        UART->DLL = UART_StoreReg[0];
;;;822        UART->DLH_INTCR =  UART_StoreReg[1];
;;;823        UART->LCR &= (~(1 << 7));
;;;824    
;;;825        //access other registers
;;;826        UART->INTID_FCR = (((UART_StoreReg[7] & BIT24) >> 21) | ((UART_StoreReg[7] & 0x7C000000) >> 18) |
;;;827                           (1));
;;;828        UART->LCR = UART_StoreReg[4];
;;;829        UART->MCR = UART_StoreReg[5];
;;;830        UART->SPR = UART_StoreReg[6];
;;;831        UART->STSR = UART_StoreReg[7];
;;;832        UART->DLH_INTCR = UART_StoreReg[2];
;;;833        UART->RX_IDLE_INTTCR = UART_StoreReg[8];
;;;834        UART->RXIDLE_INTCR = UART_StoreReg[9];
;;;835        UART->MISCR = UART_StoreReg[10];
;;;836    
;;;837        return;
;;;838    }
;;;839    #endif
;;;840    
;;;841    
;;;842    #if USE_UART1_DLPS
;;;843    
;;;844    __STATIC_INLINE void UART1_DLPS_Enter(void);
;;;845    __STATIC_INLINE void UART1_DLPS_Exit(void);
;;;846    
;;;847    uint32_t UART1_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;848    
;;;849    /**
;;;850      * @brief  UART1 enter dlps callback function(Save UART1 register values when system enter DLPS)
;;;851      * @param  None
;;;852      * @retval None
;;;853      */
;;;854    __STATIC_INLINE void UART1_DLPS_Enter(void)
;;;855    {
;;;856        //enable log uart peripheral & clock
;;;857        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;858        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;859    
;;;860        //access DLH and DLL
;;;861        UART1->LCR |= (1 << 7);
;;;862        UART1_StoreReg[0] = UART1->DLL;
;;;863        UART1_StoreReg[1] = UART1->DLH_INTCR;
;;;864        UART1->LCR &= (~(1 << 7));
;;;865    
;;;866        //save other registers
;;;867        UART1_StoreReg[2] = UART1->DLH_INTCR;
;;;868        UART1_StoreReg[4] = UART1->LCR;
;;;869        UART1_StoreReg[5] = UART1->MCR;
;;;870        UART1_StoreReg[6] = UART1->SPR;
;;;871        UART1_StoreReg[7] = UART1->STSR;
;;;872        UART1_StoreReg[8] = UART1->RX_IDLE_INTTCR;
;;;873        UART1_StoreReg[9] = UART1->RXIDLE_INTCR;
;;;874        UART1_StoreReg[10] = UART1->MISCR;
;;;875    
;;;876        return;
;;;877    }
;;;878    
;;;879    /**
;;;880      * @brief  UART1 exit dlps callback function(Resume UART1 register values when system exit DLPS)
;;;881      * @param  None
;;;882      * @retval None
;;;883      */
;;;884    DATA_RAM_FUNCTION __STATIC_INLINE void UART1_DLPS_Exit(void)
;;;885    {
;;;886        //enable log uart peripheral & clock
;;;887        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;888        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;889    
;;;890        //access DLH and DLL
;;;891        UART1->LCR |= (1 << 7);
;;;892        UART1->DLL = UART1_StoreReg[0];
;;;893        UART1->DLH_INTCR =  UART1_StoreReg[1];
;;;894        UART1->LCR &= (~(1 << 7));
;;;895    
;;;896        //access other registers
;;;897        UART1->INTID_FCR = (((UART1_StoreReg[7] & BIT24) >> 21) | ((UART1_StoreReg[7] & 0x7C000000)
;;;898                                                                   >> 18) | (1));
;;;899        UART1->LCR = UART1_StoreReg[4];
;;;900        UART1->MCR = UART1_StoreReg[5];
;;;901        UART1->SPR = UART1_StoreReg[6];
;;;902        UART1->STSR = UART1_StoreReg[7];
;;;903        UART1->DLH_INTCR = UART1_StoreReg[2];
;;;904        UART1->RX_IDLE_INTTCR = UART1_StoreReg[8];
;;;905        UART1->RXIDLE_INTCR = UART1_StoreReg[9];
;;;906        UART1->MISCR = UART1_StoreReg[10];
;;;907    
;;;908        return;
;;;909    }
;;;910    #endif
;;;911    
;;;912    #if USE_UART2_DLPS
;;;913    
;;;914    __STATIC_INLINE void UART2_DLPS_Enter(void);
;;;915    __STATIC_INLINE void UART2_DLPS_Exit(void);
;;;916    
;;;917    uint32_t UART2_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;918    
;;;919    /**
;;;920      * @brief  UART2 enter dlps callback function(Save UART2 register values when system enter DLPS)
;;;921      * @param  None
;;;922      * @retval None
;;;923      */
;;;924    __STATIC_INLINE void UART2_DLPS_Enter(void)
;;;925    {
;;;926        //enable log uart peripheral & clock
;;;927        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;928        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;929    
;;;930        //access DLH and DLL
;;;931        UART2->LCR |= (1 << 7);
;;;932        UART2_StoreReg[0] = UART2->DLL;
;;;933        UART2_StoreReg[1] = UART2->DLH_INTCR;
;;;934        UART2->LCR &= (~(1 << 7));
;;;935    
;;;936        //save other registers
;;;937        UART2_StoreReg[2] = UART2->DLH_INTCR;
;;;938        UART2_StoreReg[4] = UART2->LCR;
;;;939        UART2_StoreReg[5] = UART2->MCR;
;;;940        UART2_StoreReg[6] = UART2->SPR;
;;;941        UART2_StoreReg[7] = UART2->STSR;
;;;942        UART2_StoreReg[8] = UART2->RX_IDLE_INTTCR;
;;;943        UART2_StoreReg[9] = UART2->RXIDLE_INTCR;
;;;944        UART2_StoreReg[10] = UART2->MISCR;
;;;945    
;;;946        return;
;;;947    }
;;;948    
;;;949    /**
;;;950      * @brief  UART2 exit dlps callback function(Resume UART2 register values when system exit DLPS)
;;;951      * @param  None
;;;952      * @retval None
;;;953      */
;;;954    DATA_RAM_FUNCTION __STATIC_INLINE void UART2_DLPS_Exit(void)
;;;955    {
;;;956        //enable log uart peripheral & clock
;;;957        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;958        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;959    
;;;960        //access DLH and DLL
;;;961        UART2->LCR |= (1 << 7);
;;;962        UART2->DLL = UART2_StoreReg[0];
;;;963        UART2->DLH_INTCR =  UART2_StoreReg[1];
;;;964        UART2->LCR &= (~(1 << 7));
;;;965    
;;;966        //access other registers
;;;967        UART2->INTID_FCR = (((UART2_StoreReg[7] & BIT24) >> 21) | ((UART2_StoreReg[7] & 0x7C000000)
;;;968                                                                   >> 18) | (1));
;;;969        UART2->LCR = UART2_StoreReg[4];
;;;970        UART2->MCR = UART2_StoreReg[5];
;;;971        UART2->SPR = UART2_StoreReg[6];
;;;972        UART2->STSR = UART2_StoreReg[7];
;;;973        UART2->DLH_INTCR = UART2_StoreReg[2];
;;;974        UART2->RX_IDLE_INTTCR = UART2_StoreReg[8];
;;;975        UART2->RXIDLE_INTCR = UART2_StoreReg[9];
;;;976        UART2->MISCR = UART2_StoreReg[10];
;;;977    
;;;978        return;
;;;979    }
;;;980    #endif
;;;981    
;;;982    
;;;983    /********************************************** ********************************************************/
;;;984    /**************************************** [ADC DLPS] **************************************************/
;;;985    /*******************************************************************************************************/
;;;986    /*******************************************************************************************************/
;;;987    
;;;988    #if USE_ADC_DLPS
;;;989    __STATIC_INLINE void ADC_DLPS_Enter(void);
;;;990    __STATIC_INLINE void ADC_DLPS_Exit(void);
;;;991    
;;;992    uint32_t ADC_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;993    
;;;994    /**
;;;995      * @brief  ADC enter dlps callback function(Save ADC register values when system enter DLPS)
;;;996      * @param  None
;;;997      * @retval None
;;;998      */
;;;999    __STATIC_INLINE void ADC_DLPS_Enter(void)
;;;1000   {
;;;1001       /*Open 10M clock source*/
;;;1002       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1003       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1004   
;;;1005       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1006       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1007   
;;;1008       ADC_StoreReg[0] =  ADC->CR;          //0x04
;;;1009       ADC_StoreReg[1] =  ADC->SCHCR;       //0x08
;;;1010       ADC_StoreReg[2] =  ADC->INTCR;       //0x0C
;;;1011       ADC_StoreReg[3] =  ADC->SCHTAB0;     //0x10
;;;1012       ADC_StoreReg[4] =  ADC->SCHTAB1;     //0x14
;;;1013       ADC_StoreReg[5] =  ADC->SCHTAB2;     //0x18
;;;1014       ADC_StoreReg[6] =  ADC->SCHTAB3;     //0x1C
;;;1015       ADC_StoreReg[7] =  ADC->SCHTAB4;     //0x20
;;;1016       ADC_StoreReg[8] =  ADC->SCHTAB5;     //0x24
;;;1017       ADC_StoreReg[9] =  ADC->SCHTAB6;     //0x28
;;;1018       ADC_StoreReg[10] =  ADC->SCHTAB6;    //0x2C
;;;1019       ADC_StoreReg[11] =  ADC->PWRDLY;
;;;1020       ADC_StoreReg[12] =  ADC->DATCLK;
;;;1021       ADC_StoreReg[13] =  ADC->ANACTL;
;;;1022   
;;;1023       uint8_t reg_value = 0;
;;;1024       reg_value = btaon_fast_read_safe(0x110);
;;;1025       btaon_fast_write(0x110, reg_value & (~0x04));
;;;1026   
;;;1027       return;
;;;1028   }
;;;1029   
;;;1030   /**
;;;1031     * @brief  ADC exit dlps callback function(Resume ADC register values when system exit DLPS)
;;;1032     * @param  None
;;;1033     * @retval None
;;;1034     */
;;;1035   DATA_RAM_FUNCTION __STATIC_INLINE void ADC_DLPS_Exit(void)
;;;1036   {
;;;1037       /*Open 10M clock source*/
;;;1038       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1039       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1040   
;;;1041       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1042       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1043   
;;;1044   #if 0
;;;1045       //Todo
;;;1046       ADC->PWRDLY = ADC_StoreReg[10];
;;;1047       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1048       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1049       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1050       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1051       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1052       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1053       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1054       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1055       ADC->SCHCR = ADC_StoreReg[1];
;;;1056       ADC->INTCR = (ADC_StoreReg[2] & 0x1F);
;;;1057   #else
;;;1058       /*Disable all interrupt.*/
;;;1059       ADC->INTCR &= (~0x1f);
;;;1060   
;;;1061       /* Set power mode first */
;;;1062       ADC->PWRDLY = ADC_StoreReg[11];
;;;1063   
;;;1064       /* Disable schedule table */
;;;1065       ADC->SCHCR &= (~0xffff);
;;;1066   
;;;1067       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1068       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1069       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1070       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1071       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1072       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1073       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1074       ADC->SCHTAB7 = ADC_StoreReg[10];
;;;1075       ADC->SCHCR   = ADC_StoreReg[1];
;;;1076       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1077       ADC->DATCLK = ADC_StoreReg[12];
;;;1078       ADC->ANACTL = ADC_StoreReg[13];
;;;1079   
;;;1080       /*Clear ADC FIFO */
;;;1081       ADC->CR |= BIT26;
;;;1082       /* Clear all interrupt */
;;;1083       ADC->INTCR |= (0x1f << 8);
;;;1084   
;;;1085       /* Restore specify interrupt */
;;;1086       ADC->INTCR = ADC_StoreReg[2];
;;;1087   
;;;1088   #endif
;;;1089   
;;;1090       uint8_t reg_value = 0;
;;;1091       reg_value = btaon_fast_read_safe(0x110);
;;;1092       btaon_fast_write(0x110, reg_value | 0x04);
;;;1093   
;;;1094       return;
;;;1095   }
;;;1096   
;;;1097   #endif
;;;1098   
;;;1099   /********************************************** ********************************************************/
;;;1100   /**************************************** [IR DLPS] **************************************************/
;;;1101   /*******************************************************************************************************/
;;;1102   /*******************************************************************************************************/
;;;1103   
;;;1104   #if USE_IR_DLPS
;;;1105   __STATIC_INLINE void IR_DLPS_Enter(void);
;;;1106   __STATIC_INLINE void IR_DLPS_Exit(void);
;;;1107   
;;;1108   uint32_t IR_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1109   
;;;1110   /**
;;;1111     * @brief  IR enter dlps callback function(Save IR register values when system enter DLPS)
;;;1112     * @param  None
;;;1113     * @retval None
;;;1114     */
;;;1115   __STATIC_INLINE void IR_DLPS_Enter(void)
;;;1116   {
;;;1117       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1118       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1119   
;;;1120       IR_StoreReg[0] = IR->CLK_DIV;
;;;1121       IR_StoreReg[1] = IR->TX_CONFIG;
;;;1122       IR_StoreReg[2] = IR->RX_CONFIG;
;;;1123       IR_StoreReg[3] = IR->RX_CNT_INT_SEL;
;;;1124   
;;;1125   
;;;1126       return;
;;;1127   }
;;;1128   
;;;1129   /**
;;;1130     * @brief  IR exit dlps callback function(Resume IR register values when system exit DLPS)
;;;1131     * @param  None
;;;1132     * @retval None
;;;1133     */
;;;1134   DATA_RAM_FUNCTION __STATIC_INLINE void IR_DLPS_Exit(void)
;;;1135   {
;;;1136       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1137       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1138   
;;;1139       IR->CLK_DIV = IR_StoreReg[0];
;;;1140       if (IR_StoreReg[1] & BIT31)
;;;1141       {
;;;1142           /* RX MODE */
;;;1143           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1144           IR->RX_CONFIG  = IR_StoreReg[2];
;;;1145           IR->RX_CNT_INT_SEL  = IR_StoreReg[3];
;;;1146       }
;;;1147       else
;;;1148       {
;;;1149           /* TX MODE */
;;;1150           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1151           /* If IR TX mode is idle, must write one data firstly */
;;;1152           IR->TX_FIFO = 0;
;;;1153       }
;;;1154   
;;;1155       return;
;;;1156   }
;;;1157   
;;;1158   #endif
;;;1159   
;;;1160   /********************************************** ********************************************************/
;;;1161   /**************************************** [GDMA DLPS] **************************************************/
;;;1162   /*******************************************************************************************************/
;;;1163   /*******************************************************************************************************/
;;;1164   
;;;1165   #if USE_GDMA_DLPS
;;;1166   
;;;1167   __STATIC_INLINE void GDMA_DLPS_Enter(void);
;;;1168   __STATIC_INLINE void GDMA_DLPS_Exit(void);
;;;1169   uint32_t GDMA_StoreReg[7];         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1170   
;;;1171   #endif
;;;1172   
;;;1173   #if USE_GDMACHANNEL0_DLPS
;;;1174   uint32_t GDMAChannel0_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1175   #endif
;;;1176   
;;;1177   #if USE_GDMACHANNEL1_DLPS
;;;1178   uint32_t GDMAChannel1_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1179   #endif
;;;1180   
;;;1181   #if USE_GDMACHANNEL2_DLPS
;;;1182   uint32_t GDMAChannel2_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1183   #endif
;;;1184   
;;;1185   #if USE_GDMACHANNEL3_DLPS
;;;1186   uint32_t GDMAChannel3_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1187   #endif
;;;1188   
;;;1189   #if USE_GDMACHANNEL4_DLPS
;;;1190   uint32_t GDMAChannel4_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1191   #endif
;;;1192   
;;;1193   #if USE_GDMACHANNEL5_DLPS
;;;1194   uint32_t GDMAChannel5_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1195   #endif
;;;1196   
;;;1197   #if USE_GDMA_DLPS
;;;1198   /**
;;;1199     * @brief  GDMA enter dlps callback function(Save GDMA register values when system enter DLPS)
;;;1200     * @param  None
;;;1201     * @retval None
;;;1202     */
;;;1203   __STATIC_INLINE void GDMA_DLPS_Enter(void)
;;;1204   {
;;;1205       SYSBLKCTRL->u_210.SOC_FUNC_EN |= SYSBLK_GDMA0_EN_Msk;
;;;1206       PERIPH->PERI_CLK_CTRL |= (SYSBLK_ACTCK_GDMA0_EN_Msk | SYSBLK_SLPCK_GDMA0_EN_Msk);
;;;1207   
;;;1208       GDMA_StoreReg[0] = GDMA_BASE->DmaCfgReg;
;;;1209       GDMA_StoreReg[1] = GDMA_BASE->ChEnReg;
;;;1210       GDMA_StoreReg[2] = GDMA_BASE->MASK_TFR;
;;;1211       GDMA_StoreReg[3] = GDMA_BASE->MASK_BLOCK;
;;;1212       GDMA_StoreReg[4] = GDMA_BASE->MASK_SRC_TRAN;
;;;1213       GDMA_StoreReg[5] = GDMA_BASE->MASK_DST_TRAN;
;;;1214       GDMA_StoreReg[6] = GDMA_BASE->MASK_ERR;
;;;1215   
;;;1216   #if USE_GDMACHANNEL0_DLPS
;;;1217       GDMAChannel0_StoreReg[0] = GDMA_Channel0->SAR;
;;;1218       GDMAChannel0_StoreReg[1] = GDMA_Channel0->DAR;
;;;1219       GDMAChannel0_StoreReg[2] = GDMA_Channel0->CTL_LOW;
;;;1220       GDMAChannel0_StoreReg[3] = GDMA_Channel0->CTL_HIGH;
;;;1221       GDMAChannel0_StoreReg[4] = GDMA_Channel0->CFG_LOW;
;;;1222       GDMAChannel0_StoreReg[5] = GDMA_Channel0->CFG_HIGH;
;;;1223   #endif
;;;1224   #if USE_GDMACHANNEL1_DLPS
;;;1225       GDMAChannel1_StoreReg[0] = GDMA_Channel1->SAR;
;;;1226       GDMAChannel1_StoreReg[1] = GDMA_Channel1->DAR;
;;;1227       GDMAChannel1_StoreReg[2] = GDMA_Channel1->CTL_LOW;
;;;1228       GDMAChannel1_StoreReg[3] = GDMA_Channel1->CTL_HIGH;
;;;1229       GDMAChannel1_StoreReg[4] = GDMA_Channel1->CFG_LOW;
;;;1230       GDMAChannel1_StoreReg[5] = GDMA_Channel1->CFG_HIGH;
;;;1231   #endif
;;;1232   #if USE_GDMACHANNEL2_DLPS
;;;1233       GDMAChannel2_StoreReg[0] = GDMA_Channel2->SAR;
;;;1234       GDMAChannel2_StoreReg[1] = GDMA_Channel2->DAR;
;;;1235       GDMAChannel2_StoreReg[2] = GDMA_Channel2->CTL_LOW;
;;;1236       GDMAChannel2_StoreReg[3] = GDMA_Channel2->CTL_HIGH;
;;;1237       GDMAChannel2_StoreReg[4] = GDMA_Channel2->CFG_LOW;
;;;1238       GDMAChannel2_StoreReg[5] = GDMA_Channel2->CFG_HIGH;
;;;1239   #endif
;;;1240   #if USE_GDMACHANNEL3_DLPS
;;;1241       GDMAChannel3_StoreReg[0] = GDMA_Channel3->SAR;
;;;1242       GDMAChannel3_StoreReg[1] = GDMA_Channel3->DAR;
;;;1243       GDMAChannel3_StoreReg[2] = GDMA_Channel3->CTL_LOW;
;;;1244       GDMAChannel3_StoreReg[3] = GDMA_Channel3->CTL_HIGH;
;;;1245       GDMAChannel3_StoreReg[4] = GDMA_Channel3->CFG_LOW;
;;;1246       GDMAChannel3_StoreReg[5] = GDMA_Channel3->CFG_HIGH;
;;;1247   #endif
;;;1248   #if USE_GDMACHANNEL4_DLPS
;;;1249       GDMAChannel4_StoreReg[0] = GDMA_Channel4->SAR;
;;;1250       GDMAChannel4_StoreReg[1] = GDMA_Channel4->DAR;
;;;1251       GDMAChannel4_StoreReg[2] = GDMA_Channel4->CTL_LOW;
;;;1252       GDMAChannel4_StoreReg[3] = GDMA_Channel4->CTL_HIGH;
;;;1253       GDMAChannel4_StoreReg[4] = GDMA_Channel4->CFG_LOW;
;;;1254       GDMAChannel4_StoreReg[5] = GDMA_Channel4->CFG_HIGH;
;;;1255   #endif
;;;1256   #if USE_GDMACHANNEL5_DLPS
;;;1257       GDMAChannel5_StoreReg[0] = GDMA_Channel5->SAR;
;;;1258       GDMAChannel5_StoreReg[1] = GDMA_Channel5->DAR;
;;;1259       GDMAChannel5_StoreReg[2] = GDMA_Channel5->CTL_LOW;
;;;1260       GDMAChannel5_StoreReg[3] = GDMA_Channel5->CTL_HIGH;
;;;1261       GDMAChannel5_StoreReg[4] = GDMA_Channel5->CFG_LOW;
;;;1262       GDMAChannel5_StoreReg[5] = GDMA_Channel5->CFG_HIGH;
;;;1263   #endif
;;;1264   }
;;;1265   
;;;1266   /**
;;;1267     * @brief  GDMA exit dlps callback function(Resume GDMA register values when system exit DLPS)
;;;1268     * @param  None
;;;1269     * @retval None
;;;1270     */
;;;1271   DATA_RAM_FUNCTION __STATIC_INLINE void GDMA_DLPS_Exit(void)
;;;1272   {
;;;1273       SYSBLKCTRL->u_210.SOC_FUNC_EN |= SYSBLK_GDMA0_EN_Msk;
;;;1274       PERIPH->PERI_CLK_CTRL |= (SYSBLK_ACTCK_GDMA0_EN_Msk | SYSBLK_SLPCK_GDMA0_EN_Msk);
;;;1275   
;;;1276       /* Enable GDMA in DmaCfgReg*/
;;;1277       GDMA_BASE->DmaCfgReg = GDMA_StoreReg[0];
;;;1278   
;;;1279       /*----------clear pending all interrupts of GDMA channel-----------*/
;;;1280       GDMA_BASE->CLEAR_TFR = 0xff;
;;;1281       GDMA_BASE->CLEAR_BLOCK = 0xff;
;;;1282       GDMA_BASE->CLEAR_DST_TRAN = 0xff;
;;;1283       GDMA_BASE->CLEAR_SRC_TRAN = 0xff;
;;;1284       GDMA_BASE->CLEAR_ERR = 0xff;
;;;1285   
;;;1286       /*--------------------mask interrupt-------- -----------------*/
;;;1287       GDMA_BASE->MASK_TFR = (GDMA_StoreReg[2] | ((GDMA_StoreReg[2] & 0xff) << 8));
;;;1288       GDMA_BASE->MASK_BLOCK = (GDMA_StoreReg[3] | ((GDMA_StoreReg[3] & 0xff) << 8));
;;;1289       GDMA_BASE->MASK_SRC_TRAN = (GDMA_StoreReg[4] | ((GDMA_StoreReg[4] & 0xff) << 8));
;;;1290       GDMA_BASE->MASK_DST_TRAN = (GDMA_StoreReg[5] | ((GDMA_StoreReg[5] & 0xff) << 8));
;;;1291       GDMA_BASE->MASK_ERR = (GDMA_StoreReg[6] | ((GDMA_StoreReg[6] & 0xff) << 8));
;;;1292   
;;;1293   #if USE_GDMACHANNEL0_DLPS
;;;1294       GDMA_Channel0->SAR      = GDMAChannel0_StoreReg[0];
;;;1295       GDMA_Channel0->DAR      = GDMAChannel0_StoreReg[1];
;;;1296       GDMA_Channel0->CTL_LOW  = GDMAChannel0_StoreReg[2];
;;;1297       GDMA_Channel0->CTL_HIGH = GDMAChannel0_StoreReg[3];
;;;1298       GDMA_Channel0->CFG_LOW  = GDMAChannel0_StoreReg[4];
;;;1299       GDMA_Channel0->CFG_HIGH = GDMAChannel0_StoreReg[5];
;;;1300   #endif
;;;1301   #if USE_GDMACHANNEL1_DLPS
;;;1302       GDMA_Channel1->SAR      = GDMAChannel1_StoreReg[0];
;;;1303       GDMA_Channel1->DAR      = GDMAChannel1_StoreReg[1];
;;;1304       GDMA_Channel1->CTL_LOW  = GDMAChannel1_StoreReg[2];
;;;1305       GDMA_Channel1->CTL_HIGH = GDMAChannel1_StoreReg[3];
;;;1306       GDMA_Channel1->CFG_LOW  = GDMAChannel1_StoreReg[4];
;;;1307       GDMA_Channel1->CFG_HIGH = GDMAChannel1_StoreReg[5];
;;;1308   #endif
;;;1309   #if USE_GDMACHANNEL2_DLPS
;;;1310       GDMA_Channel2->SAR      = GDMAChannel2_StoreReg[0];
;;;1311       GDMA_Channel2->DAR      = GDMAChannel2_StoreReg[1];
;;;1312       GDMA_Channel2->CTL_LOW  = GDMAChannel2_StoreReg[2];
;;;1313       GDMA_Channel2->CTL_HIGH = GDMAChannel2_StoreReg[3];
;;;1314       GDMA_Channel2->CFG_LOW  = GDMAChannel2_StoreReg[4];
;;;1315       GDMA_Channel2->CFG_HIGH = GDMAChannel2_StoreReg[5];
;;;1316   #endif
;;;1317   #if USE_GDMACHANNEL3_DLPS
;;;1318       GDMA_Channel3->SAR      = GDMAChannel3_StoreReg[0];
;;;1319       GDMA_Channel3->DAR      = GDMAChannel3_StoreReg[1];
;;;1320       GDMA_Channel3->CTL_LOW  = GDMAChannel3_StoreReg[2];
;;;1321       GDMA_Channel3->CTL_HIGH = GDMAChannel3_StoreReg[3];
;;;1322       GDMA_Channel3->CFG_LOW  = GDMAChannel3_StoreReg[4];
;;;1323       GDMA_Channel3->CFG_HIGH = GDMAChannel3_StoreReg[5];
;;;1324   #endif
;;;1325   #if USE_GDMACHANNEL4_DLPS
;;;1326       GDMA_Channel4->SAR      = GDMAChannel4_StoreReg[0];
;;;1327       GDMA_Channel4->DAR      = GDMAChannel4_StoreReg[1];
;;;1328       GDMA_Channel4->CTL_LOW  = GDMAChannel4_StoreReg[2];
;;;1329       GDMA_Channel4->CTL_HIGH = GDMAChannel4_StoreReg[3];
;;;1330       GDMA_Channel4->CFG_LOW  = GDMAChannel4_StoreReg[4];
;;;1331       GDMA_Channel4->CFG_HIGH = GDMAChannel4_StoreReg[5];
;;;1332   #endif
;;;1333   #if USE_GDMACHANNEL5_DLPS
;;;1334       GDMA_Channel5->SAR      = GDMAChannel5_StoreReg[0];
;;;1335       GDMA_Channel5->DAR      = GDMAChannel5_StoreReg[1];
;;;1336       GDMA_Channel5->CTL_LOW  = GDMAChannel5_StoreReg[2];
;;;1337       GDMA_Channel5->CTL_HIGH = GDMAChannel5_StoreReg[3];
;;;1338       GDMA_Channel5->CFG_LOW  = GDMAChannel5_StoreReg[4];
;;;1339       GDMA_Channel5->CFG_HIGH = GDMAChannel5_StoreReg[5];
;;;1340   #endif
;;;1341   
;;;1342       /*----------clear pending all interrupts of GDMA channel before enable channel-----------*/
;;;1343       GDMA_BASE->CLEAR_TFR = 0x3f;
;;;1344       GDMA_BASE->CLEAR_BLOCK = 0x3f;
;;;1345       GDMA_BASE->CLEAR_DST_TRAN = 0x3f;
;;;1346       GDMA_BASE->CLEAR_SRC_TRAN = 0x3f;
;;;1347       GDMA_BASE->CLEAR_ERR = 0x3f;
;;;1348   
;;;1349       /* Enable the selected DMA Channelx */
;;;1350   //    GDMA_BASE->ChEnReg = GDMA_StoreReg[1];
;;;1351   }
;;;1352   #endif
;;;1353   
;;;1354   /********************************************** ********************************************************/
;;;1355   /**************************************** [LCD DLPS] ************************************************/
;;;1356   /*******************************************************************************************************/
;;;1357   /*******************************************************************************************************/
;;;1358   #if USE_LCD_DLPS
;;;1359   
;;;1360   uint32_t LCD_StoreReg[5];
;;;1361   
;;;1362   /**
;;;1363     * @brief  LCD enter dlps callback function(Save LCD register values when system enter DLPS)
;;;1364     * @param  None
;;;1365     * @retval None
;;;1366     */
;;;1367   __STATIC_INLINE void LCD_DLPS_Enter(void)
;;;1368   {
;;;1369       /* Enable LCD 8080 interface controller function */
;;;1370       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1371       /* Enable LCD 8080 interface controller clock */
;;;1372       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1373   
;;;1374       LCD_StoreReg[0] = *((volatile uint32_t *)0x400002A8UL) & (0x03 << 28);
;;;1375       LCD_StoreReg[1] = LCD->IMR;
;;;1376       LCD_StoreReg[2] = LCD->CTRL0;
;;;1377       LCD_StoreReg[3] = LCD->CTRL1;
;;;1378       LCD_StoreReg[4] = LCD->CFG;
;;;1379   
;;;1380   }
;;;1381   
;;;1382   /**
;;;1383     * @brief  LCD exit dlps callback function(Resume LCD register values when system exit DLPS)
;;;1384     * @param  None
;;;1385     * @retval None
;;;1386     */
;;;1387   DATA_RAM_FUNCTION __STATIC_INLINE void LCD_DLPS_Exit(void)
;;;1388   {
;;;1389       /* Enable LCD 8080 interface controller function */
;;;1390       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1391       /* Enable LCD 8080 interface controller clock */
;;;1392       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1393   
;;;1394       /* Restore Dedicated SDIO pin option */
;;;1395       *((volatile uint32_t *)0x400002A8UL) &= ~(0x03 << 28);
;;;1396       *((volatile uint32_t *)0x400002A8UL) |= LCD_StoreReg[0];
;;;1397   
;;;1398       /* Initialize LCD */
;;;1399   
;;;1400       LCD->IMR    = LCD_StoreReg[1];
;;;1401       LCD->CTRL1  = LCD_StoreReg[3];
;;;1402       LCD->CFG    = LCD_StoreReg[4];
;;;1403       LCD->CTRL0  = LCD_StoreReg[2];
;;;1404   }
;;;1405   #endif
;;;1406   
;;;1407   /********************************************** ********************************************************/
;;;1408   /**************************************** [I2S0 DLPS] **************************************************/
;;;1409   /*******************************************************************************************************/
;;;1410   /*******************************************************************************************************/
;;;1411   #if USE_I2S0_DLPS
;;;1412   
;;;1413   uint32_t I2S0_StoreReg[4];
;;;1414   
;;;1415   /**
;;;1416     * @brief  I2S0 enter dlps callback function(Save I2S0 register values when system enter DLPS)
;;;1417     * @param  None
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void I2S0_DLPS_Enter(void)
;;;1421   {
;;;1422       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1423   
;;;1424       I2S0_StoreReg[0] = I2S0->BCLK_DIV;
;;;1425       I2S0_StoreReg[1] = I2S0->CTRL0;
;;;1426       I2S0_StoreReg[2] = I2S0->CTRL1;
;;;1427       I2S0_StoreReg[3] = I2S0->DMA_TRDLR;
;;;1428   }
;;;1429   
;;;1430   /**
;;;1431     * @brief  I2S0 exit dlps callback function(Resume I2S0 register values when system exit DLPS)
;;;1432     * @param  None
;;;1433     * @retval None
;;;1434     */
;;;1435   DATA_RAM_FUNCTION __STATIC_INLINE void I2S0_DLPS_Exit(void)
;;;1436   {
;;;1437       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1438   
;;;1439       /* Reset I2S0 module */
;;;1440       I2S0->CTRL0 |= 1 << 0;
;;;1441       I2S0->CTRL0 &= ~(1 << 0);
;;;1442   
;;;1443       /* Initialize I2S0 */
;;;1444       I2S0->BCLK_DIV  = I2S0_StoreReg[0];
;;;1445       I2S0->CTRL1     = I2S0_StoreReg[2];
;;;1446       I2S0->DMA_TRDLR = I2S0_StoreReg[3];
;;;1447       I2S0->CTRL0     = I2S0_StoreReg[1];
;;;1448   }
;;;1449   #endif
;;;1450   
;;;1451   /********************************************** ********************************************************/
;;;1452   /**************************************** [I2S1 DLPS] **************************************************/
;;;1453   /*******************************************************************************************************/
;;;1454   /*******************************************************************************************************/
;;;1455   #if USE_I2S1_DLPS
;;;1456   
;;;1457   uint32_t I2S1_StoreReg[4];
;;;1458   
;;;1459   /**
;;;1460     * @brief  I2S1 enter dlps callback function(Save I2S1 register values when system enter DLPS)
;;;1461     * @param  None
;;;1462     * @retval None
;;;1463     */
;;;1464   __STATIC_INLINE void I2S1_DLPS_Enter(void)
;;;1465   {
;;;1466       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1467   
;;;1468       I2S1_StoreReg[0] = I2S1->BCLK_DIV;
;;;1469       I2S1_StoreReg[1] = I2S1->CTRL0;
;;;1470       I2S1_StoreReg[2] = I2S1->CTRL1;
;;;1471       I2S1_StoreReg[3] = I2S1->DMA_TRDLR;
;;;1472   }
;;;1473   
;;;1474   /**
;;;1475     * @brief  I2S1 exit dlps callback function(Resume I2S1 register values when system exit DLPS)
;;;1476     * @param  None
;;;1477     * @retval None
;;;1478     */
;;;1479   DATA_RAM_FUNCTION __STATIC_INLINE void I2S1_DLPS_Exit(void)
;;;1480   {
;;;1481       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1482   
;;;1483       /* Reset I2S1 module */
;;;1484       I2S1->CTRL0 |= 1 << 0;
;;;1485       I2S1->CTRL0 &= ~(1 << 0);
;;;1486   
;;;1487       /* Initialize I2S1 */
;;;1488       I2S1->BCLK_DIV  = I2S1_StoreReg[0];
;;;1489       I2S1->CTRL1     = I2S1_StoreReg[2];
;;;1490       I2S1->DMA_TRDLR = I2S1_StoreReg[3];
;;;1491       I2S1->CTRL0     = I2S1_StoreReg[1];
;;;1492   }
;;;1493   #endif
;;;1494   
;;;1495   /********************************************** ********************************************************/
;;;1496   /**************************************** [CODEC DLPS] ************************************************/
;;;1497   /*******************************************************************************************************/
;;;1498   /*******************************************************************************************************/
;;;1499   #if USE_CODEC_DLPS
;;;1500   
;;;1501   uint32_t CODEC_StoreReg[7];
;;;1502   
;;;1503   /**
;;;1504     * @brief  CODEC enter dlps callback function(Save CODEC register values when system enter DLPS)
;;;1505     * @param  None
;;;1506     * @retval None
;;;1507     */
;;;1508   __STATIC_INLINE void CODEC_DLPS_Enter(void)
;;;1509   {
;;;1510       /* Enable codec function and clock */
;;;1511       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1512   
;;;1513       CODEC_StoreReg[0] = CODEC->CR0;
;;;1514       CODEC_StoreReg[1] = CODEC->CR1;
;;;1515       CODEC_StoreReg[2] = CODEC->CR2;
;;;1516       CODEC_StoreReg[3] = CODEC->CLK_CTRL;
;;;1517       CODEC_StoreReg[4] = CODEC->I2S_CTRL;
;;;1518       CODEC_StoreReg[5] = CODEC->ADC_CTRL;
;;;1519       CODEC_StoreReg[6] = CODEC->DAC_CTRL;
;;;1520   }
;;;1521   
;;;1522   /**
;;;1523     * @brief  CODEC exit dlps callback function(Resume CODEC register values when system exit DLPS)
;;;1524     * @param  None
;;;1525     * @retval None
;;;1526     */
;;;1527   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_DLPS_Exit(void)
;;;1528   {
;;;1529       /* Enable codec function and clock */
;;;1530       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1531   
;;;1532       /* Initialize CODEC */
;;;1533       if ((CODEC_StoreReg[3] & 0x900) == 0x900)
;;;1534       {
;;;1535           /* Configure AMIC parameters */
;;;1536           CODEC->CR0 = CODEC_StoreReg[0];
;;;1537           CODEC->CR1 = CODEC_StoreReg[1];
;;;1538           CODEC->CR2 = CODEC_StoreReg[2];
;;;1539       }
;;;1540   
;;;1541       /*  Reset audio digital IP */
;;;1542       CODEC->AUDIO_CTRL = 0;
;;;1543       CODEC->AUDIO_CTRL = 1;
;;;1544   
;;;1545       CODEC->CLK_CTRL = CODEC_StoreReg[3];
;;;1546       CODEC->I2S_CTRL = CODEC_StoreReg[4];
;;;1547       CODEC->ADC_CTRL = CODEC_StoreReg[5];
;;;1548       CODEC->DAC_CTRL = CODEC_StoreReg[6];
;;;1549   }
;;;1550   #endif
;;;1551   
;;;1552   /********************************************** ********************************************************/
;;;1553   /**************************************** [CODEC_EQ1 DLPS] ************************************************/
;;;1554   /*******************************************************************************************************/
;;;1555   /*******************************************************************************************************/
;;;1556   #if USE_CODEC_EQ1_DLPS
;;;1557   
;;;1558   uint32_t CODEC_EQ1_StoreReg[5];
;;;1559   
;;;1560   /**
;;;1561     * @brief  CODEC_EQ1 enter dlps callback function(Save CODEC_EQ1 register values when system enter DLPS)
;;;1562     * @param  None
;;;1563     * @retval None
;;;1564     */
;;;1565   __STATIC_INLINE void CODEC_EQ1_DLPS_Enter(void)
;;;1566   {
;;;1567       /* Enable codec function and clock */
;;;1568       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1569   
;;;1570       CODEC_EQ1_StoreReg[0] = CODEC_EQ1->EQ_H0;
;;;1571       CODEC_EQ1_StoreReg[1] = CODEC_EQ1->EQ_B1;
;;;1572       CODEC_EQ1_StoreReg[2] = CODEC_EQ1->EQ_B2;
;;;1573       CODEC_EQ1_StoreReg[3] = CODEC_EQ1->EQ_A1;
;;;1574       CODEC_EQ1_StoreReg[4] = CODEC_EQ1->EQ_A2;
;;;1575   }
;;;1576   
;;;1577   /**
;;;1578     * @brief  CODEC_EQ1 exit dlps callback function(Resume CODEC_EQ1 register values when system exit DLPS)
;;;1579     * @param  None
;;;1580     * @retval None
;;;1581     */
;;;1582   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ1_DLPS_Exit(void)
;;;1583   {
;;;1584       /* Enable codec function and clock */
;;;1585       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1586   
;;;1587       CODEC_EQ1->EQ_H0 = CODEC_EQ1_StoreReg[0];
;;;1588       CODEC_EQ1->EQ_B1 = CODEC_EQ1_StoreReg[1];
;;;1589       CODEC_EQ1->EQ_B2 = CODEC_EQ1_StoreReg[2];
;;;1590       CODEC_EQ1->EQ_A1 = CODEC_EQ1_StoreReg[3];
;;;1591       CODEC_EQ1->EQ_A2 = CODEC_EQ1_StoreReg[4];
;;;1592   }
;;;1593   #endif
;;;1594   
;;;1595   /********************************************** ********************************************************/
;;;1596   /**************************************** [CODEC_EQ2 DLPS] ************************************************/
;;;1597   /*******************************************************************************************************/
;;;1598   /*******************************************************************************************************/
;;;1599   #if USE_CODEC_EQ2_DLPS
;;;1600   
;;;1601   uint32_t CODEC_EQ2_StoreReg[5];
;;;1602   
;;;1603   /**
;;;1604     * @brief  CODEC_EQ2 enter dlps callback function(Save CODEC_EQ2 register values when system enter DLPS)
;;;1605     * @param  None
;;;1606     * @retval None
;;;1607     */
;;;1608   __STATIC_INLINE void CODEC_EQ2_DLPS_Enter(void)
;;;1609   {
;;;1610       /* Enable codec function and clock */
;;;1611       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1612   
;;;1613       CODEC_EQ2_StoreReg[0] = CODEC_EQ2->EQ_H0;
;;;1614       CODEC_EQ2_StoreReg[1] = CODEC_EQ2->EQ_B1;
;;;1615       CODEC_EQ2_StoreReg[2] = CODEC_EQ2->EQ_B2;
;;;1616       CODEC_EQ2_StoreReg[3] = CODEC_EQ2->EQ_A1;
;;;1617       CODEC_EQ2_StoreReg[4] = CODEC_EQ2->EQ_A2;
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  CODEC_EQ2 exit dlps callback function(Resume CODEC_EQ2 register values when system exit DLPS)
;;;1622     * @param  None
;;;1623     * @retval None
;;;1624     */
;;;1625   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ2_DLPS_Exit(void)
;;;1626   {
;;;1627       /* Enable codec function and clock */
;;;1628       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1629   
;;;1630       CODEC_EQ2->EQ_H0 = CODEC_EQ2_StoreReg[0];
;;;1631       CODEC_EQ2->EQ_B1 = CODEC_EQ2_StoreReg[1];
;;;1632       CODEC_EQ2->EQ_B2 = CODEC_EQ2_StoreReg[2];
;;;1633       CODEC_EQ2->EQ_A1 = CODEC_EQ2_StoreReg[3];
;;;1634       CODEC_EQ2->EQ_A2 = CODEC_EQ2_StoreReg[4];
;;;1635   }
;;;1636   #endif
;;;1637   
;;;1638   /********************************************** ********************************************************/
;;;1639   /**************************************** [CODEC_EQ3 DLPS] ************************************************/
;;;1640   /*******************************************************************************************************/
;;;1641   /*******************************************************************************************************/
;;;1642   #if USE_CODEC_EQ3_DLPS
;;;1643   
;;;1644   uint32_t CODEC_EQ3_StoreReg[5];
;;;1645   
;;;1646   /**
;;;1647     * @brief  CODEC_EQ3 enter dlps callback function(Save CODEC_EQ3 register values when system enter DLPS)
;;;1648     * @param  None
;;;1649     * @retval None
;;;1650     */
;;;1651   __STATIC_INLINE void CODEC_EQ3_DLPS_Enter(void)
;;;1652   {
;;;1653       /* Enable codec function and clock */
;;;1654       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1655   
;;;1656       CODEC_EQ3_StoreReg[0] = CODEC_EQ3->EQ_H0;
;;;1657       CODEC_EQ3_StoreReg[1] = CODEC_EQ3->EQ_B1;
;;;1658       CODEC_EQ3_StoreReg[2] = CODEC_EQ3->EQ_B2;
;;;1659       CODEC_EQ3_StoreReg[3] = CODEC_EQ3->EQ_A1;
;;;1660       CODEC_EQ3_StoreReg[4] = CODEC_EQ3->EQ_A2;
;;;1661   }
;;;1662   
;;;1663   /**
;;;1664     * @brief  CODEC_EQ3 exit dlps callback function(Resume CODEC_EQ3 register values when system exit DLPS)
;;;1665     * @param  None
;;;1666     * @retval None
;;;1667     */
;;;1668   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ3_DLPS_Exit(void)
;;;1669   {
;;;1670       /* Enable codec function and clock */
;;;1671       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1672   
;;;1673       CODEC_EQ3->EQ_H0 = CODEC_EQ3_StoreReg[0];
;;;1674       CODEC_EQ3->EQ_B1 = CODEC_EQ3_StoreReg[1];
;;;1675       CODEC_EQ3->EQ_B2 = CODEC_EQ3_StoreReg[2];
;;;1676       CODEC_EQ3->EQ_A1 = CODEC_EQ3_StoreReg[3];
;;;1677       CODEC_EQ3->EQ_A2 = CODEC_EQ3_StoreReg[4];
;;;1678   }
;;;1679   #endif
;;;1680   
;;;1681   /********************************************** ********************************************************/
;;;1682   /**************************************** [CODEC_EQ4 DLPS] ************************************************/
;;;1683   /*******************************************************************************************************/
;;;1684   /*******************************************************************************************************/
;;;1685   #if USE_CODEC_EQ4_DLPS
;;;1686   
;;;1687   uint32_t CODEC_EQ4_StoreReg[5];
;;;1688   
;;;1689   /**
;;;1690     * @brief  CODEC_EQ4 enter dlps callback function(Save CODEC_EQ4 register values when system enter DLPS)
;;;1691     * @param  None
;;;1692     * @retval None
;;;1693     */
;;;1694   __STATIC_INLINE void CODEC_EQ4_DLPS_Enter(void)
;;;1695   {
;;;1696       /* Enable codec function and clock */
;;;1697       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1698   
;;;1699       CODEC_EQ4_StoreReg[0] = CODEC_EQ4->EQ_H0;
;;;1700       CODEC_EQ4_StoreReg[1] = CODEC_EQ4->EQ_B1;
;;;1701       CODEC_EQ4_StoreReg[2] = CODEC_EQ4->EQ_B2;
;;;1702       CODEC_EQ4_StoreReg[3] = CODEC_EQ4->EQ_A1;
;;;1703       CODEC_EQ4_StoreReg[4] = CODEC_EQ4->EQ_A2;
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  CODEC_EQ4 exit dlps callback function(Resume CODEC_EQ4 register values when system exit DLPS)
;;;1708     * @param  None
;;;1709     * @retval None
;;;1710     */
;;;1711   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ4_DLPS_Exit(void)
;;;1712   {
;;;1713       /* Enable codec function and clock */
;;;1714       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1715   
;;;1716       CODEC_EQ4->EQ_H0 = CODEC_EQ4_StoreReg[0];
;;;1717       CODEC_EQ4->EQ_B1 = CODEC_EQ4_StoreReg[1];
;;;1718       CODEC_EQ4->EQ_B2 = CODEC_EQ4_StoreReg[2];
;;;1719       CODEC_EQ4->EQ_A1 = CODEC_EQ4_StoreReg[3];
;;;1720       CODEC_EQ4->EQ_A2 = CODEC_EQ4_StoreReg[4];
;;;1721   }
;;;1722   #endif
;;;1723   
;;;1724   /********************************************** ********************************************************/
;;;1725   /**************************************** [CODEC_EQ5 DLPS] ************************************************/
;;;1726   /*******************************************************************************************************/
;;;1727   /*******************************************************************************************************/
;;;1728   #if USE_CODEC_EQ5_DLPS
;;;1729   
;;;1730   uint32_t CODEC_EQ5_StoreReg[5];
;;;1731   
;;;1732   /**
;;;1733     * @brief  CODEC_EQ5 enter dlps callback function(Save CODEC_EQ5 register values when system enter DLPS)
;;;1734     * @param  None
;;;1735     * @retval None
;;;1736     */
;;;1737   __STATIC_INLINE void CODEC_EQ5_DLPS_Enter(void)
;;;1738   {
;;;1739       /* Enable codec function and clock */
;;;1740       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1741   
;;;1742       CODEC_EQ5_StoreReg[0] = CODEC_EQ5->EQ_H0;
;;;1743       CODEC_EQ5_StoreReg[1] = CODEC_EQ5->EQ_B1;
;;;1744       CODEC_EQ5_StoreReg[2] = CODEC_EQ5->EQ_B2;
;;;1745       CODEC_EQ5_StoreReg[3] = CODEC_EQ5->EQ_A1;
;;;1746       CODEC_EQ5_StoreReg[4] = CODEC_EQ5->EQ_A2;
;;;1747   }
;;;1748   
;;;1749   /**
;;;1750     * @brief  CODEC_EQ5 exit dlps callback function(Resume CODEC_EQ5 register values when system exit DLPS)
;;;1751     * @param  None
;;;1752     * @retval None
;;;1753     */
;;;1754   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ5_DLPS_Exit(void)
;;;1755   {
;;;1756       /* Enable codec function and clock */
;;;1757       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1758   
;;;1759       CODEC_EQ5->EQ_H0 = CODEC_EQ5_StoreReg[0];
;;;1760       CODEC_EQ5->EQ_B1 = CODEC_EQ5_StoreReg[1];
;;;1761       CODEC_EQ5->EQ_B2 = CODEC_EQ5_StoreReg[2];
;;;1762       CODEC_EQ5->EQ_A1 = CODEC_EQ5_StoreReg[3];
;;;1763       CODEC_EQ5->EQ_A2 = CODEC_EQ5_StoreReg[4];
;;;1764   }
;;;1765   #endif
;;;1766   
;;;1767   /**
;;;1768     * @brief  Set Log and SWD pins to SW mode.
;;;1769     * @param  void.
;;;1770     * @retval void.
;;;1771     */
;;;1772   __STATIC_INLINE void Log_SWD_DLPS_Enter(void)
;;;1773   {
;;;1774       if (OTP->SWD_ENABLE)
        0x00208924:    1255        U.      ASRS     r5,r2,#9
        0x00208926:    6201        .b      STR      r1,[r0,#0x20]
        0x00208928:    f8950334    ..4.    LDRB     r0,[r5,#0x334]
        0x0020892c:    07c0        ..      LSLS     r0,r0,#31
        0x0020892e:    d00f        ..      BEQ      0x208950 ; DLPS_IO_EnterDlpsCb + 220
;;;1775       {
;;;1776           Pad_Config(P1_0, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00208930:    9400        ..      STR      r4,[sp,#0]
        0x00208932:    2302        .#      MOVS     r3,#2
        0x00208934:    2201        ."      MOVS     r2,#1
        0x00208936:    2100        .!      MOVS     r1,#0
        0x00208938:    2008        .       MOVS     r0,#8
        0x0020893a:    9401        ..      STR      r4,[sp,#4]
        0x0020893c:    f608fd4e    ..N.    BL       Pad_Config ; 0x113dc
;;;1777           Pad_Config(P1_1, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00208940:    9400        ..      STR      r4,[sp,#0]
        0x00208942:    2302        .#      MOVS     r3,#2
        0x00208944:    2201        ."      MOVS     r2,#1
        0x00208946:    2100        .!      MOVS     r1,#0
        0x00208948:    2009        .       MOVS     r0,#9
        0x0020894a:    9401        ..      STR      r4,[sp,#4]
        0x0020894c:    f608fd46    ..F.    BL       Pad_Config ; 0x113dc
;;;1778       }
;;;1779   
;;;1780       Pad_Config(OTP->logPin, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00208950:    9400        ..      STR      r4,[sp,#0]
        0x00208952:    9401        ..      STR      r4,[sp,#4]
        0x00208954:    f8950398    ....    LDRB     r0,[r5,#0x398]
        0x00208958:    2301        .#      MOVS     r3,#1
        0x0020895a:    f000003f    ..?.    AND      r0,r0,#0x3f
        0x0020895e:    461a        .F      MOV      r2,r3
        0x00208960:    2100        .!      MOVS     r1,#0
        0x00208962:    f608fd3b    ..;.    BL       Pad_Config ; 0x113dc
;;;1781   
;;;1782   }
;;;1783   
;;;1784   /**
;;;1785     * @brief  Set Log and SWD pins to PINMUX mode.
;;;1786     * @param  void.
;;;1787     * @retval void.
;;;1788     */
;;;1789   DATA_RAM_FUNCTION __STATIC_INLINE void Log_SWD_DLPS_Exit(void)
;;;1790   {
;;;1791       Pad_Config(OTP->logPin, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1792   
;;;1793       if (OTP->SWD_ENABLE)
;;;1794       {
;;;1795           Pad_Config(P1_0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1796           Pad_Config(P1_1, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1797       }
;;;1798   }
;;;1799   
;;;1800   /********************************************** ********************************************************/
;;;1801   /*********************************** [USER Exit DLPS CALLBACK FUCN] *****************************************/
;;;1802   /*******************************************************************************************************/
;;;1803   /*******************************************************************************************************/
;;;1804   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;1805   
;;;1806   DLPS_IO_ExitDlpsCB User_IO_ExitDlpsCB = NULL;
;;;1807   
;;;1808   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1809   
;;;1810   /********************************************** ********************************************************/
;;;1811   /*********************************** [USER Enter DLPS CALLBACK FUCN] *****************************************/
;;;1812   /*******************************************************************************************************/
;;;1813   /*******************************************************************************************************/
;;;1814   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1815   
;;;1816   DLPS_IO_EnterDlpsCB User_IO_EnterDlpsCB = NULL;
;;;1817   
;;;1818   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1819   
;;;1820   /********************************************** ********************************************************/
;;;1821   /*********************************** [Enter & Exit DLPS CALLBACK FUNC] *********************************/
;;;1822   /*******************************************************************************************************/
;;;1823   /*******************************************************************************************************/
;;;1824   #if USE_IO_DRIVER_DLPS
;;;1825   
;;;1826   /**
;;;1827     * @brief  IO enter dlps callback function
;;;1828     * @param  None
;;;1829     * @retval None
;;;1830     */
;;;1831   void DLPS_IO_EnterDlpsCb(void)
;;;1832   {
;;;1833       /* low stack do it instead */
;;;1834   //    Pad_ClearAllWakeupINT();
;;;1835   
;;;1836   //    DBG_DIRECT("DLPS_IO_EnterDlpsCb");
;;;1837       NVIC_DisableIRQ(System_IRQn);
;;;1838       CPU_DLPS_Enter();
;;;1839   
;;;1840       Pinmux_DLPS_Enter();
;;;1841   
;;;1842   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1843       if (User_IO_EnterDlpsCB)
;;;1844       {
;;;1845           User_IO_EnterDlpsCB();
;;;1846       }
;;;1847   #endif
;;;1848   
;;;1849   #if USE_I2C0_DLPS
;;;1850       I2C0_DLPS_Enter();
;;;1851   #endif
;;;1852   
;;;1853   #if USE_I2C1_DLPS
;;;1854       I2C1_DLPS_Enter();
;;;1855   #endif
;;;1856   
;;;1857   #if USE_TIM_DLPS
;;;1858       TIM_DLPS_Enter();
;;;1859   #endif
;;;1860   
;;;1861   #if USE_QDECODER_DLPS
;;;1862       QuadDecoder_DLPS_Enter();
;;;1863   #endif
;;;1864   
;;;1865   #if USE_IR_DLPS
;;;1866       IR_DLPS_Enter();
;;;1867   #endif
;;;1868   
;;;1869   #if USE_UART_DLPS
;;;1870       UART_DLPS_Enter();
;;;1871   #endif
;;;1872   
;;;1873   #if USE_UART1_DLPS
;;;1874       UART1_DLPS_Enter();
;;;1875   #endif
;;;1876   
;;;1877   #if USE_UART2_DLPS
;;;1878       UART2_DLPS_Enter();
;;;1879   #endif
;;;1880   
;;;1881   #if USE_SPI0_DLPS
;;;1882       SPI0_DLPS_Enter();
;;;1883   #endif
;;;1884   
;;;1885   #if USE_SPI1_DLPS
;;;1886       SPI1_DLPS_Enter();
;;;1887   #endif
;;;1888   
;;;1889   #if USE_SPI2W_DLPS
;;;1890       SPI2W_DLPS_Enter();
;;;1891   #endif
;;;1892   
;;;1893   #if USE_KEYSCAN_DLPS
;;;1894       KeyScan_DLPS_Enter();
;;;1895   #endif
;;;1896   
;;;1897   #if USE_GPIO_DLPS
;;;1898       GPIO_DLPS_Enter();
;;;1899   #endif
;;;1900   
;;;1901   #if USE_ADC_DLPS
;;;1902       ADC_DLPS_Enter();
;;;1903   #endif
;;;1904   
;;;1905   #if USE_LCD_DLPS
;;;1906       LCD_DLPS_Enter();
;;;1907   #endif
;;;1908   
;;;1909   #if USE_I2S0_DLPS
;;;1910       I2S0_DLPS_Enter();
;;;1911   #endif
;;;1912   
;;;1913   #if USE_I2S1_DLPS
;;;1914       I2S1_DLPS_Enter();
;;;1915   #endif
;;;1916   
;;;1917   #if USE_CODEC_DLPS
;;;1918       CODEC_DLPS_Enter();
;;;1919   #endif
;;;1920   
;;;1921   #if USE_CODEC_EQ1_DLPS
;;;1922       CODEC_EQ1_DLPS_Enter();
;;;1923   #endif
;;;1924   
;;;1925   #if USE_CODEC_EQ2_DLPS
;;;1926       CODEC_EQ2_DLPS_Enter();
;;;1927   #endif
;;;1928   
;;;1929   #if USE_CODEC_EQ3_DLPS
;;;1930       CODEC_EQ3_DLPS_Enter();
;;;1931   #endif
;;;1932   
;;;1933   #if USE_CODEC_EQ4_DLPS
;;;1934       CODEC_EQ4_DLPS_Enter();
;;;1935   #endif
;;;1936   
;;;1937   #if USE_CODEC_EQ5_DLPS
;;;1938       CODEC_EQ5_DLPS_Enter();
;;;1939   #endif
;;;1940   
;;;1941   #if USE_GDMA_DLPS
;;;1942       GDMA_DLPS_Enter();
;;;1943   #endif
;;;1944   
;;;1945       Log_SWD_DLPS_Enter();
;;;1946   
;;;1947   }
        0x00208966:    bd7c        |.      POP      {r2-r6,pc}
    DLPS_IORegister
;;;1948   #endif  /* USE_IO_DRIVER_DLPS */
;;;1949   
;;;1950   #if USE_IO_DRIVER_DLPS
;;;1951   /**
;;;1952     * @brief  IO exit dlps callback function.
;;;1953     * @param  None
;;;1954     * @retval None
;;;1955     */
;;;1956   DATA_RAM_FUNCTION void DLPS_IO_ExitDlpsCb(void)
;;;1957   {
;;;1958   
;;;1959   //    DBG_BUFFER(TYPE_BUMBLEBEE3, SUBTYPE_FORMAT, MODULE_DLPS, LEVEL_INFO,
;;;1960   //               "DLPS_IO_ExitDlpsCb",0);
;;;1961   
;;;1962       Pinmux_DLPS_Exit();
;;;1963   
;;;1964       Log_SWD_DLPS_Exit();
;;;1965   
;;;1966   #if USE_I2C0_DLPS
;;;1967       I2C0_DLPS_Exit();
;;;1968   #endif
;;;1969   
;;;1970   #if USE_I2C1_DLPS
;;;1971       I2C1_DLPS_Exit();
;;;1972   #endif
;;;1973   
;;;1974   #if USE_TIM_DLPS
;;;1975       TIM_DLPS_Exit();
;;;1976   #endif
;;;1977   
;;;1978   #if USE_QDECODER_DLPS
;;;1979       QuadDecoder_DLPS_Exit();
;;;1980   #endif
;;;1981   
;;;1982   #if USE_IR_DLPS
;;;1983       IR_DLPS_Exit();
;;;1984   #endif
;;;1985   
;;;1986   #if USE_UART_DLPS
;;;1987       UART_DLPS_Exit();
;;;1988   #endif
;;;1989   
;;;1990   #if USE_UART1_DLPS
;;;1991       UART1_DLPS_Exit();
;;;1992   #endif
;;;1993   
;;;1994   #if USE_UART2_DLPS
;;;1995       UART2_DLPS_Exit();
;;;1996   #endif
;;;1997   
;;;1998   #if USE_SPI0_DLPS
;;;1999       SPI0_DLPS_Exit();
;;;2000   #endif
;;;2001   
;;;2002   #if USE_SPI1_DLPS
;;;2003       SPI1_DLPS_Exit();
;;;2004   #endif
;;;2005   
;;;2006   #if USE_SPI2W_DLPS
;;;2007       SPI2W_DLPS_Exit();
;;;2008   #endif
;;;2009   
;;;2010   #if USE_KEYSCAN_DLPS
;;;2011       KeyScan_DLPS_Exit();
;;;2012   #endif
;;;2013   
;;;2014   #if USE_GPIO_DLPS
;;;2015       GPIO_DLPS_Exit();
;;;2016   #endif
;;;2017   
;;;2018   #if USE_ADC_DLPS
;;;2019       ADC_DLPS_Exit();
;;;2020   #endif
;;;2021   
;;;2022   #if USE_LCD_DLPS
;;;2023       LCD_DLPS_Exit();
;;;2024   #endif
;;;2025   
;;;2026   #if USE_I2S0_DLPS
;;;2027       I2S0_DLPS_Exit();
;;;2028   #endif
;;;2029   
;;;2030   #if USE_I2S1_DLPS
;;;2031       I2S1_DLPS_Exit();
;;;2032   #endif
;;;2033   
;;;2034   #if USE_CODEC_DLPS
;;;2035       CODEC_DLPS_Exit();
;;;2036   #endif
;;;2037   
;;;2038   #if USE_CODEC_EQ1_DLPS
;;;2039       CODEC_EQ1_DLPS_Exit();
;;;2040   #endif
;;;2041   
;;;2042   #if USE_CODEC_EQ2_DLPS
;;;2043       CODEC_EQ2_DLPS_Exit();
;;;2044   #endif
;;;2045   
;;;2046   #if USE_CODEC_EQ3_DLPS
;;;2047       CODEC_EQ3_DLPS_Exit();
;;;2048   #endif
;;;2049   
;;;2050   #if USE_CODEC_EQ4_DLPS
;;;2051       CODEC_EQ4_DLPS_Exit();
;;;2052   #endif
;;;2053   
;;;2054   #if USE_CODEC_EQ5_DLPS
;;;2055       CODEC_EQ5_DLPS_Exit();
;;;2056   #endif
;;;2057   
;;;2058   #if USE_GDMA_DLPS
;;;2059       GDMA_DLPS_Exit();
;;;2060   #endif
;;;2061   
;;;2062   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;2063       if (User_IO_ExitDlpsCB)
;;;2064       {
;;;2065           User_IO_ExitDlpsCB();
;;;2066       }
;;;2067   #endif
;;;2068   
;;;2069       NVIC_InitTypeDef nvic_init_struct;
;;;2070       nvic_init_struct.NVIC_IRQChannel         = System_IRQn;
;;;2071       nvic_init_struct.NVIC_IRQChannelCmd      = (FunctionalState)ENABLE;
;;;2072       nvic_init_struct.NVIC_IRQChannelPriority = 3;
;;;2073       NVIC_Init(&nvic_init_struct); //Enable SYSTEM_ON Interrupt
;;;2074   
;;;2075       CPU_DLPS_Exit();
;;;2076   }
;;;2077   
;;;2078   /**
;;;2079     * @brief  register IO DLPS callback function
;;;2080     * @param  None
;;;2081     * @retval None
;;;2082     */
;;;2083   void DLPS_IORegister(void)
;;;2084   {
        0x00208968:    b510        ..      PUSH     {r4,lr}
;;;2085       dlps_hw_control_cb_reg(DLPS_IO_EnterDlpsCb, DLPS_ENTER);
        0x0020896a:    2100        .!      MOVS     r1,#0
        0x0020896c:    f2af00fb    ....    ADR      r0,{pc}-0xf7 ; 0x208875
        0x00208970:    f5fffebd    ....    BL       dlps_hw_control_cb_reg ; 0x86ee
;;;2086       dlps_hw_control_cb_reg(DLPS_IO_ExitDlpsCb, DLPS_EXIT4_BT_READY);
        0x00208974:    e8bd4010    ...@    POP      {r4,lr}
        0x00208978:    2104        .!      MOVS     r1,#4
        0x0020897a:    4805        .H      LDR      r0,[pc,#20] ; [0x208990] = 0x207d41
        0x0020897c:    f5ffbeb7    ....    B        dlps_hw_control_cb_reg ; 0x86ee
    $d
        0x00208980:    0020bbac    .. .    DCD    2145196
        0x00208984:    e000ed08    ....    DCD    3758157064
        0x00208988:    40006000    .`.@    DCD    1073766400
        0x0020898c:    40001000    ...@    DCD    1073745920
        0x00208990:    00207d41    A} .    DCD    2129217
    $t
    .text
    RCC_PeriphClockCmd
;;; .\..\..\..\src\mcu\peripheral\rtl876x_rcc.c
;;;66     {
        0x00208994:    b5f0        ..      PUSH     {r4-r7,lr}
        0x00208996:    f44f7790    O..w    MOV      r7,#0x120
        0x0020899a:    067b        {.      LSLS     r3,r7,#25
;;;67         /* Check the parameters */
;;;68         assert_param(IS_APB_PERIPH(APBPeriph));
;;;69         assert_param(IS_APB_PERIPH_CLOCK(APBPeriph_Clock));
;;;70         assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;71     
;;;72         uint32_t apbRegOff = ((APBPeriph & (0x03 << 26)) >> 26);
        0x0020899c:    f3c06681    ...f    UBFX     r6,r0,#26,#2
;;;73         uint32_t clkRegOff = ((APBPeriph_Clock & (0x03 << 29)) >> 29);
        0x002089a0:    f3c17541    ..Au    UBFX     r5,r1,#29,#2
        0x002089a4:    f44f7ea0    O..~    MOV      lr,#0x140
        0x002089a8:    ea400401    @...    ORR      r4,r0,r1
;;;74     
;;;75         /*Open clock gating first*/
;;;76         if (NewState == ENABLE)
        0x002089ac:    2a01        .*      CMP      r2,#1
        0x002089ae:    d006        ..      BEQ      0x2089be ; RCC_PeriphClockCmd + 42
        0x002089b0:    42b9        .B      CMP      r1,r7
        0x002089b2:    d06f        o.      BEQ      0x208a94 ; RCC_PeriphClockCmd + 256
        0x002089b4:    4571        qE      CMP      r1,lr
        0x002089b6:    d06d        m.      BEQ      0x208a94 ; RCC_PeriphClockCmd + 256
        0x002089b8:    2910        .)      CMP      r1,#0x10
        0x002089ba:    d06b        k.      BEQ      0x208a94 ; RCC_PeriphClockCmd + 256
        0x002089bc:    e04b        K.      B        0x208a56 ; RCC_PeriphClockCmd + 194
;;;77         {
;;;78             if (APBPeriph_Clock == APBPeriph_KEYSCAN_CLOCK)
        0x002089be:    f1a14cc0    ...L    SUB      r12,r1,#0x60000000
        0x002089c2:    f1bc0c40    ..@.    SUBS     r12,r12,#0x40
        0x002089c6:    d018        ..      BEQ      0x2089fa ; RCC_PeriphClockCmd + 102
        0x002089c8:    f1b14fc2    ...O    CMP      r1,#0x61000000
        0x002089cc:    d020         .      BEQ      0x208a10 ; RCC_PeriphClockCmd + 124
        0x002089ce:    f1a14cc0    ...L    SUB      r12,r1,#0x60000000
        0x002089d2:    f1bc0c10    ....    SUBS     r12,r12,#0x10
        0x002089d6:    d003        ..      BEQ      0x2089e0 ; RCC_PeriphClockCmd + 76
        0x002089d8:    f8dfc2f0    ....    LDR      r12,[pc,#752] ; [0x208ccc] = 0x60010000
        0x002089dc:    4561        aE      CMP      r1,r12
        0x002089de:    d124        $.      BNE      0x208a2a ; RCC_PeriphClockCmd + 150
        0x002089e0:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x002089e4:    f04c6c80    L..l    ORR      r12,r12,#0x4000000
        0x002089e8:    f8c3c20c    ....    STR      r12,[r3,#0x20c]
        0x002089ec:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x002089f0:    f04c6c00    L..l    ORR      r12,r12,#0x8000000
        0x002089f4:    f8c3c20c    ....    STR      r12,[r3,#0x20c]
        0x002089f8:    e027        '.      B        0x208a4a ; RCC_PeriphClockCmd + 182
;;;79             {
;;;80                 /*Open 5M clock source*/
;;;81                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
        0x002089fa:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x002089fe:    f04c6c80    L..l    ORR      r12,r12,#0x4000000
        0x00208a02:    f8c3c20c    ....    STR      r12,[r3,#0x20c]
;;;82                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
        0x00208a06:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x00208a0a:    f04c5c00    L..\    ORR      r12,r12,#0x20000000
        0x00208a0e:    e7f1        ..      B        0x2089f4 ; RCC_PeriphClockCmd + 96
;;;83             }
;;;84             else if (APBPeriph_Clock == APBPeriph_ADC_CLOCK)
;;;85             {
;;;86                 /*Open 10M clock source*/
;;;87                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
        0x00208a10:    f8d3420c    ...B    LDR      r4,[r3,#0x20c]
        0x00208a14:    f0446480    D..d    ORR      r4,r4,#0x4000000
        0x00208a18:    f8c3420c    ...B    STR      r4,[r3,#0x20c]
;;;88                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
        0x00208a1c:    f8d3420c    ...B    LDR      r4,[r3,#0x20c]
        0x00208a20:    f0445480    D..T    ORR      r4,r4,#0x10000000
        0x00208a24:    f8c3420c    ...B    STR      r4,[r3,#0x20c]
        0x00208a28:    e015        ..      B        0x208a56 ; RCC_PeriphClockCmd + 194
;;;89             }
;;;90             else if ((APBPeriph_Clock == APBPeriph_QDEC_CLOCK) || (APBPeriph_Clock == APBPeriph_SPI2W_CLOCK))
;;;91             {
;;;92                 /*Open 20M clock source*/
;;;93                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;94                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;95             }
;;;96             else if (APBPeriph_Clock == APBPeriph_TIMER_CLOCK)
        0x00208a2a:    f8dfc2a4    ....    LDR      r12,[pc,#676] ; [0x208cd0] = 0x20004000
        0x00208a2e:    4561        aE      CMP      r1,r12
        0x00208a30:    d10b        ..      BNE      0x208a4a ; RCC_PeriphClockCmd + 182
;;;97             {
;;;98                 /* Enable TIM0~1 fixed 40M */
;;;99                 CLK_SOURCE_REG_2 |= BIT9;
        0x00208a32:    f8d3c360    ..`.    LDR      r12,[r3,#0x360]
        0x00208a36:    f44c7c00    L..|    ORR      r12,r12,#0x200
        0x00208a3a:    f8c3c360    ..`.    STR      r12,[r3,#0x360]
;;;100                /* enable TIM2~7 ICG*/
;;;101                CLK_SOURCE_REG_0 |= BIT4;
        0x00208a3e:    f8d3c348    ..H.    LDR      r12,[r3,#0x348]
        0x00208a42:    f04c0c10    L...    ORR      r12,r12,#0x10
        0x00208a46:    f8c3c348    ..H.    STR      r12,[r3,#0x348]
;;;102            }
;;;103        }
;;;104    
;;;105        /* Special register handle */
;;;106        if (NewState == ENABLE)
;;;107        {
;;;108            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
        0x00208a4a:    42b9        .B      CMP      r1,r7
        0x00208a4c:    d01d        ..      BEQ      0x208a8a ; RCC_PeriphClockCmd + 246
        0x00208a4e:    4571        qE      CMP      r1,lr
        0x00208a50:    d01b        ..      BEQ      0x208a8a ; RCC_PeriphClockCmd + 246
;;;109                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
        0x00208a52:    2910        .)      CMP      r1,#0x10
        0x00208a54:    d019        ..      BEQ      0x208a8a ; RCC_PeriphClockCmd + 246
;;;110            {
;;;111                SYSBLKCTRL->u_220 |= APBPeriph | APBPeriph_Clock;
;;;112                return;
;;;113            }
;;;114        }
;;;115        else
;;;116        {
;;;117            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
;;;118                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
;;;119            {
;;;120                SYSBLKCTRL->u_220 &= ~(APBPeriph | APBPeriph_Clock);
;;;121                return;
;;;122            }
;;;123        }
;;;124    
;;;125        /* clear flag */
;;;126        APBPeriph &= (~(0x03 << 26));
        0x00208a56:    f0206340     .@c    BIC      r3,r0,#0xc000000
;;;127        APBPeriph_Clock &= (~(0x03 << 29));
        0x00208a5a:    f02140c0    !..@    BIC      r0,r1,#0x60000000
        0x00208a5e:    ea4f0186    O...    LSL      r1,r6,#2
        0x00208a62:    f1014180    ...A    ADD      r1,r1,#0x40000000
;;;128    
;;;129        if (NewState == ENABLE)
        0x00208a66:    2a01        .*      CMP      r2,#1
        0x00208a68:    f8d12210    ..."    LDR      r2,[r1,#0x210]
        0x00208a6c:    d018        ..      BEQ      0x208aa0 ; RCC_PeriphClockCmd + 268
;;;130        {
;;;131            //enable peripheral
;;;132            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) |= APBPeriph;
;;;133            //enable peripheral clock
;;;134            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= APBPeriph_Clock;
;;;135            //enable peripheral clock in sleep mode
;;;136            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= (APBPeriph_Clock << 1);
;;;137        }
;;;138        else
;;;139        {
;;;140            //disable peripheral
;;;141            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) &= (~APBPeriph);
        0x00208a6e:    439a        .C      BICS     r2,r2,r3
;;;142            //disable peripheral clock
;;;143            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~APBPeriph_Clock);
        0x00208a70:    f8c12210    ..."    STR      r2,[r1,#0x210]
        0x00208a74:    00a9        ..      LSLS     r1,r5,#2
        0x00208a76:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x00208a7a:    f8d1222c    ..,"    LDR      r2,[r1,#0x22c]
        0x00208a7e:    4382        .C      BICS     r2,r2,r0
;;;144            //disable peripheral clock in sleep mode
;;;145            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~(APBPeriph_Clock << 1));
        0x00208a80:    ea220040    ".@.    BIC      r0,r2,r0,LSL #1
        0x00208a84:    f8c1022c    ..,.    STR      r0,[r1,#0x22c]
;;;146        }
;;;147    
;;;148        return;
;;;149    }
        0x00208a88:    bdf0        ..      POP      {r4-r7,pc}
        0x00208a8a:    f8d30220    .. .    LDR      r0,[r3,#0x220]
        0x00208a8e:    4320         C      ORRS     r0,r0,r4
        0x00208a90:    e003        ..      B        0x208a9a ; RCC_PeriphClockCmd + 262
        0x00208a92:    e7ff        ..      B        0x208a94 ; RCC_PeriphClockCmd + 256
        0x00208a94:    f8d30220    .. .    LDR      r0,[r3,#0x220]
        0x00208a98:    43a0        .C      BICS     r0,r0,r4
        0x00208a9a:    f8c30220    .. .    STR      r0,[r3,#0x220]
        0x00208a9e:    bdf0        ..      POP      {r4-r7,pc}
        0x00208aa0:    431a        .C      ORRS     r2,r2,r3
        0x00208aa2:    f8c12210    ..."    STR      r2,[r1,#0x210]
        0x00208aa6:    00a9        ..      LSLS     r1,r5,#2
        0x00208aa8:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x00208aac:    f8d1222c    ..,"    LDR      r2,[r1,#0x22c]
        0x00208ab0:    4302        .C      ORRS     r2,r2,r0
        0x00208ab2:    ea420040    B.@.    ORR      r0,r2,r0,LSL #1
        0x00208ab6:    e7e5        ..      B        0x208a84 ; RCC_PeriphClockCmd + 240
    RCC_SPIClkDivConfig
;;;150    
;;;151    /**
;;;152      * @brief  SPI clock divider config.
;;;153      * @param  SPIx: where x can be 0 or 1 to select the SPI peripheral.
;;;154      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;155      *      this parameter can be one of the following values:
;;;156      *     @arg SPI_CLOCK_DIV_1
;;;157      *     @arg SPI_CLOCK_DIV_2
;;;158      *     @arg SPI_CLOCK_DIV_4
;;;159      *     @arg SPI_CLOCK_DIV_8
;;;160      * @retval None
;;;161      */
;;;162    void RCC_SPIClkDivConfig(SPI_TypeDef *SPIx, uint16_t ClockDiv)
;;;163    {
;;;164        assert_param(IS_SPI_DIV(ClockDiv));
;;;165    
;;;166        /* Config I2C clock divider */
;;;167        if (SPIx == SPI0)
        0x00208ab8:    4b86        .K      LDR      r3,[pc,#536] ; [0x208cd4] = 0x40013000
        0x00208aba:    f04f4280    O..B    MOV      r2,#0x40000000
        0x00208abe:    4298        .B      CMP      r0,r3
;;; .\..\..\..\src\mcu\peripheral\rtl876x_rcc.c (163)
        0x00208ac0:    d116        ..      BNE      0x208af0 ; RCC_SPIClkDivConfig + 56
;;;164        assert_param(IS_SPI_DIV(ClockDiv));
;;;165    
;;;166        /* Config I2C clock divider */
;;;167        if (SPIx == SPI0)
;;;168        {
;;;169            /* disable clock first */
;;;170            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_SPI0_EN_Msk;
        0x00208ac2:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x00208ac6:    f4203080     ..0    BIC      r0,r0,#0x10000
        0x00208aca:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;171            //platform_delay_us(1);
;;;172    
;;;173            CLK_SOURCE_REG_1 &= ~(0x03 << 19);
        0x00208ace:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00208ad2:    f42010c0     ...    BIC      r0,r0,#0x180000
        0x00208ad6:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;174            CLK_SOURCE_REG_1 |= (ClockDiv << 19);
        0x00208ada:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00208ade:    ea4040c1    @..@    ORR      r0,r0,r1,LSL #19
        0x00208ae2:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;175    
;;;176            //platform_delay_us(1);
;;;177            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_SPI0_EN_Msk;
        0x00208ae6:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x00208aea:    f4403080    @..0    ORR      r0,r0,#0x10000
        0x00208aee:    e018        ..      B        0x208b22 ; RCC_SPIClkDivConfig + 106
;;;178        }
;;;179        else if (SPIx == SPI1)
        0x00208af0:    4b79        yK      LDR      r3,[pc,#484] ; [0x208cd8] = 0x40013400
        0x00208af2:    4298        .B      CMP      r0,r3
        0x00208af4:    d117        ..      BNE      0x208b26 ; RCC_SPIClkDivConfig + 110
;;;180        {
;;;181            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_SPI1_EN_Msk;
        0x00208af6:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x00208afa:    f4202080     ..     BIC      r0,r0,#0x40000
        0x00208afe:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;182            //platform_delay_us(1);
;;;183    
;;;184            CLK_SOURCE_REG_1 &= ~(0x03 << 21);
        0x00208b02:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00208b06:    f42000c0     ...    BIC      r0,r0,#0x600000
        0x00208b0a:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;185            CLK_SOURCE_REG_1 |= (ClockDiv << 21);
        0x00208b0e:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00208b12:    ea405041    @.AP    ORR      r0,r0,r1,LSL #21
        0x00208b16:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;186    
;;;187            //platform_delay_us(1);
;;;188            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_SPI1_EN_Msk;
        0x00208b1a:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x00208b1e:    f4402080    @..     ORR      r0,r0,#0x40000
        0x00208b22:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;189        }
;;;190        return;
;;;191    }
        0x00208b26:    4770        pG      BX       lr
    RCC_I2CClkDivConfig
;;;192    
;;;193    /**
;;;194      * @brief  I2C clock divider config.
;;;195      * @param  I2Cx: where x can be 0 or 1 to select the I2C peripheral.
;;;196      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;197      *      this parameter can be one of the following values:
;;;198      *     @arg I2C_CLOCK_DIV_1
;;;199      *     @arg I2C_CLOCK_DIV_2
;;;200      *     @arg I2C_CLOCK_DIV_4
;;;201      *     @arg I2C_CLOCK_DIV_8
;;;202      * @retval None
;;;203      */
;;;204    void RCC_I2CClkDivConfig(I2C_TypeDef *I2Cx, uint16_t ClockDiv)
;;;205    {
;;;206        assert_param(IS_I2C_DIV(ClockDiv));
;;;207    
;;;208        /* Config I2C clock divider */
;;;209        if (I2Cx == I2C0)
        0x00208b28:    4b6c        lK      LDR      r3,[pc,#432] ; [0x208cdc] = 0x40015000
        0x00208b2a:    049a        ..      LSLS     r2,r3,#18
        0x00208b2c:    4298        .B      CMP      r0,r3
;;; .\..\..\..\src\mcu\peripheral\rtl876x_rcc.c (205)
        0x00208b2e:    d116        ..      BNE      0x208b5e ; RCC_I2CClkDivConfig + 54
;;;206        assert_param(IS_I2C_DIV(ClockDiv));
;;;207    
;;;208        /* Config I2C clock divider */
;;;209        if (I2Cx == I2C0)
;;;210        {
;;;211            /* disable clock first */
;;;212            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 &= ~SYSBLK_ACTCK_I2C0_EN_Msk;
        0x00208b30:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x00208b34:    f0200001     ...    BIC      r0,r0,#1
        0x00208b38:    f8c20238    ..8.    STR      r0,[r2,#0x238]
;;;213            //platform_delay_us(1);
;;;214    
;;;215            CLK_SOURCE_REG_1 &= ~(0x03 << 15);
        0x00208b3c:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00208b40:    f42030c0     ..0    BIC      r0,r0,#0x18000
        0x00208b44:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;216            CLK_SOURCE_REG_1 |= (ClockDiv << 15);
        0x00208b48:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00208b4c:    ea4030c1    @..0    ORR      r0,r0,r1,LSL #15
        0x00208b50:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;217    
;;;218            //platform_delay_us(1);
;;;219            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= SYSBLK_ACTCK_I2C0_EN_Msk;
        0x00208b54:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x00208b58:    f0400001    @...    ORR      r0,r0,#1
        0x00208b5c:    e018        ..      B        0x208b90 ; RCC_I2CClkDivConfig + 104
;;;220        }
;;;221        else if (I2Cx == I2C1)
        0x00208b5e:    4b60        `K      LDR      r3,[pc,#384] ; [0x208ce0] = 0x40015400
        0x00208b60:    4298        .B      CMP      r0,r3
        0x00208b62:    d117        ..      BNE      0x208b94 ; RCC_I2CClkDivConfig + 108
;;;222        {
;;;223            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 &= ~SYSBLK_ACTCK_I2C1_EN_Msk;
        0x00208b64:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x00208b68:    f0200004     ...    BIC      r0,r0,#4
        0x00208b6c:    f8c20238    ..8.    STR      r0,[r2,#0x238]
;;;224            //platform_delay_us(1);
;;;225    
;;;226            CLK_SOURCE_REG_1 &= ~(0x03 << 17);
        0x00208b70:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00208b74:    f42020c0     ..     BIC      r0,r0,#0x60000
        0x00208b78:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;227            CLK_SOURCE_REG_1 |= (ClockDiv << 17);
        0x00208b7c:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00208b80:    ea404041    @.A@    ORR      r0,r0,r1,LSL #17
        0x00208b84:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;228    
;;;229            //platform_delay_us(1);
;;;230            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= SYSBLK_ACTCK_I2C1_EN_Msk;
        0x00208b88:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x00208b8c:    f0400004    @...    ORR      r0,r0,#4
        0x00208b90:    f8c20238    ..8.    STR      r0,[r2,#0x238]
;;;231        }
;;;232    
;;;233        return;
;;;234    }
        0x00208b94:    4770        pG      BX       lr
    RCC_UARTClkDivConfig
        0x00208b96:    4b53        SK      LDR      r3,[pc,#332] ; [0x208ce4] = 0x40012000
        0x00208b98:    045a        Z.      LSLS     r2,r3,#17
        0x00208b9a:    4298        .B      CMP      r0,r3
;;;235    
;;;236    /**
;;;237      * @brief  UART clock divider config.
;;;238      * @param  UARTx: selected UART peripheral.
;;;239      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;240      *      this parameter can be one of the following values:
;;;241      *     @arg UART_CLOCK_DIV_1
;;;242      *     @arg UART_CLOCK_DIV_2
;;;243      *     @arg UART_CLOCK_DIV_4
;;;244      *     @arg UART_CLOCK_DIV_16
;;;245      * @retval None
;;;246      */
;;;247    void RCC_UARTClkDivConfig(UART_TypeDef *UARTx, uint16_t ClockDiv)
;;;248    {
        0x00208b9c:    d118        ..      BNE      0x208bd0 ; RCC_UARTClkDivConfig + 58
;;;249        assert_param(IS_UART_DIV(ClockDiv));
;;;250    
;;;251        /* Config UART clock divider */
;;;252        if (UARTx == UART)
;;;253        {
;;;254            /* disable clock first */
;;;255            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_UART0DATA_EN_Msk;
        0x00208b9e:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x00208ba2:    f0200001     ...    BIC      r0,r0,#1
        0x00208ba6:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;256            //platform_delay_us(1);
;;;257    
;;;258            CLK_SOURCE_REG_1 &= ~(0x03 << 9);
        0x00208baa:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00208bae:    f42060c0     ..`    BIC      r0,r0,#0x600
        0x00208bb2:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;259            CLK_SOURCE_REG_1 |= (ClockDiv << 9);
        0x00208bb6:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00208bba:    ea402041    @.A     ORR      r0,r0,r1,LSL #9
        0x00208bbe:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;260    
;;;261            //platform_delay_us(1);
;;;262            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_UART0DATA_EN_Msk;
        0x00208bc2:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x00208bc6:    f0400001    @...    ORR      r0,r0,#1
        0x00208bca:    f8c20234    ..4.    STR      r0,[r2,#0x234]
        0x00208bce:    4770        pG      BX       lr
;;;263        }
;;;264        else if (UARTx == UART1)
        0x00208bd0:    4b45        EK      LDR      r3,[pc,#276] ; [0x208ce8] = 0x40011000
        0x00208bd2:    4298        .B      CMP      r0,r3
        0x00208bd4:    d1fb        ..      BNE      0x208bce ; RCC_UARTClkDivConfig + 56
;;;265        {
;;;266            SYSBLKCTRL->u_230.CLK_CTRL &= ~SYSBLK_ACTCK_LOGUART_EN_Msk;
        0x00208bd6:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x00208bda:    f4205080     ..P    BIC      r0,r0,#0x1000
        0x00208bde:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;267            //platform_delay_us(1);
;;;268    
;;;269            CLK_SOURCE_REG_1 &= ~(0x03 << 11);
        0x00208be2:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00208be6:    f42050c0     ..P    BIC      r0,r0,#0x1800
        0x00208bea:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;270            CLK_SOURCE_REG_1 |= (ClockDiv << 11);
        0x00208bee:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x00208bf2:    ea4020c1    @..     ORR      r0,r0,r1,LSL #11
        0x00208bf6:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;271    
;;;272            //platform_delay_us(1);
;;;273            SYSBLKCTRL->u_230.CLK_CTRL |= SYSBLK_ACTCK_LOGUART_EN_Msk;
        0x00208bfa:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x00208bfe:    f4405080    @..P    ORR      r0,r0,#0x1000
        0x00208c02:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;274        }
;;;275    
;;;276        return;
;;;277    }
        0x00208c06:    4770        pG      BX       lr
    RCC_PeriClockConfig
;;;278    
;;;279    /**
;;;280      * @brief  Enables or disables the APB peripheral clock.
;;;281      * @param  APBPeriph_Clock: specifies the APB peripheral clock config.
;;;282      *      this parameter can be one of the following values(must be the same with APBPeriph):
;;;283      *     @arg APBPeriph_TIMER_CLOCK
;;;284      *     @arg APBPeriph_GDMA_CLOCK
;;;285      *     @arg APBPeriph_SPI2W_CLOCK
;;;286      *     @arg APBPeriph_KEYSCAN_CLOCK
;;;287      *     @arg APBPeriph_QDEC_CLOCK
;;;288      *     @arg APBPeriph_I2C1_CLOCK
;;;289      *     @arg APBPeriph_I2C0_CLOCK
;;;290      *     @arg APBPeriph_IR_CLOCK
;;;291      *     @arg APBPeriph_SPI1_CLOCK
;;;292      *     @arg APBPeriph_SPI0_CLOCK
;;;293      *     @arg APBPeriph_UART0_CLOCK
;;;294      *     @arg APBPeriph_UART1_CLOCK
;;;295      *     @arg APBPeriph_UART2_CLOCK
;;;296      *     @arg APBPeriph_GPIO_CLOCK
;;;297      *     @arg APBPeriph_ADC_CLOCK
;;;298      *     @arg APBPeriph_I2S0_CLOCK
;;;299      *     @arg APBPeriph_I2S1_CLOCK
;;;300      *     @arg APBPeriph_CODEC_CLOCK
;;;301      * @param  NewState: new state of the specified peripheral clock.
;;;302      *   This parameter can be: ENABLE or DISABLE.
;;;303      * @retval None
;;;304      */
;;;305    void RCC_PeriClockConfig(uint32_t APBPeriph_Clock, FunctionalState NewState)
;;;306    {
        0x00208c08:    b530        0.      PUSH     {r4,r5,lr}
        0x00208c0a:    f44f74a0    O..t    MOV      r4,#0x140
        0x00208c0e:    0623        #.      LSLS     r3,r4,#24
        0x00208c10:    f3c07241    ..Ar    UBFX     r2,r0,#29,#2
        0x00208c14:    f44f7590    O..u    MOV      r5,#0x120
        0x00208c18:    2901        .)      CMP      r1,#1
;;; .\..\..\..\src\mcu\peripheral\rtl876x_rcc.c (306)
        0x00208c1a:    d006        ..      BEQ      0x208c2a ; RCC_PeriClockConfig + 34
        0x00208c1c:    42a8        .B      CMP      r0,r5
        0x00208c1e:    d01e        ..      BEQ      0x208c5e ; RCC_PeriClockConfig + 86
        0x00208c20:    42a0        .B      CMP      r0,r4
        0x00208c22:    d01c        ..      BEQ      0x208c5e ; RCC_PeriClockConfig + 86
        0x00208c24:    2810        .(      CMP      r0,#0x10
        0x00208c26:    d01a        ..      BEQ      0x208c5e ; RCC_PeriClockConfig + 86
        0x00208c28:    e005        ..      B        0x208c36 ; RCC_PeriClockConfig + 46
;;;307        /* Check the parameters */
;;;308        assert_param(IS_APB_PERIPH_CLOCK(APBPeriph_Clock));
;;;309        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;310    
;;;311        uint32_t clkRegOff = ((APBPeriph_Clock & (0x03 << 29)) >> 29);
;;;312    
;;;313        /* Special register handle */
;;;314        if (NewState == ENABLE)
;;;315        {
;;;316            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
        0x00208c2a:    42a8        .B      CMP      r0,r5
        0x00208c2c:    d013        ..      BEQ      0x208c56 ; RCC_PeriClockConfig + 78
        0x00208c2e:    42a0        .B      CMP      r0,r4
        0x00208c30:    d011        ..      BEQ      0x208c56 ; RCC_PeriClockConfig + 78
;;;317                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
        0x00208c32:    2810        .(      CMP      r0,#0x10
        0x00208c34:    d00f        ..      BEQ      0x208c56 ; RCC_PeriClockConfig + 78
        0x00208c36:    2901        .)      CMP      r1,#1
        0x00208c38:    ea4f0182    O...    LSL      r1,r2,#2
        0x00208c3c:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x00208c40:    f02040c0     ..@    BIC      r0,r0,#0x60000000
        0x00208c44:    f8d1222c    ..,"    LDR      r2,[r1,#0x22c]
        0x00208c48:    d00f        ..      BEQ      0x208c6a ; RCC_PeriClockConfig + 98
        0x00208c4a:    4382        .C      BICS     r2,r2,r0
        0x00208c4c:    ea220040    ".@.    BIC      r0,r2,r0,LSL #1
        0x00208c50:    f8c1022c    ..,.    STR      r0,[r1,#0x22c]
        0x00208c54:    bd30        0.      POP      {r4,r5,pc}
;;;318            {
;;;319                SYSBLKCTRL->u_220 |= APBPeriph_Clock;
        0x00208c56:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x00208c5a:    4301        .C      ORRS     r1,r1,r0
;;;320                return;
        0x00208c5c:    e002        ..      B        0x208c64 ; RCC_PeriClockConfig + 92
;;;321            }
;;;322        }
;;;323        else
;;;324        {
;;;325            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
;;;326                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
;;;327            {
;;;328                SYSBLKCTRL->u_220 &= ~(APBPeriph_Clock);
        0x00208c5e:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x00208c62:    4381        .C      BICS     r1,r1,r0
        0x00208c64:    f8c31220    .. .    STR      r1,[r3,#0x220]
        0x00208c68:    bd30        0.      POP      {r4,r5,pc}
;;;329                return;
;;;330            }
;;;331        }
;;;332    
;;;333        APBPeriph_Clock &= (~(0x03 << 29));
;;;334    
;;;335        if (NewState == ENABLE)
;;;336        {
;;;337            //enable peripheral clock
;;;338            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= APBPeriph_Clock;
        0x00208c6a:    4302        .C      ORRS     r2,r2,r0
;;;339            //enable peripheral clock in sleep mode
;;;340            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= (APBPeriph_Clock << 1);
        0x00208c6c:    ea420040    B.@.    ORR      r0,r2,r0,LSL #1
        0x00208c70:    e7ee        ..      B        0x208c50 ; RCC_PeriClockConfig + 72
    RCC_PeriFunctionConfig
        0x00208c72:    f3c06281    ...b    UBFX     r2,r0,#26,#2
        0x00208c76:    f04f4380    O..C    MOV      r3,#0x40000000
        0x00208c7a:    2901        .)      CMP      r1,#1
;;;341        }
;;;342        else
;;;343        {
;;;344            //disable peripheral clock
;;;345            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~APBPeriph_Clock);
;;;346            //disable peripheral clock in sleep mode
;;;347            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~(APBPeriph_Clock << 1));
;;;348        }
;;;349    
;;;350        return;
;;;351    }
;;;352    
;;;353    /**
;;;354      * @brief  Enables or disables the APB peripheral clock.
;;;355      * @param  APBPeriph: specifies the APB peripheral to gates its clock.
;;;356      *      this parameter can be one of the following values:
;;;357      *     @arg APBPeriph_TIMER
;;;358      *     @arg APBPeriph_GDMA
;;;359      *     @arg APBPeriph_LCD
;;;360      *     @arg APBPeriph_SPI2W
;;;361      *     @arg APBPeriph_KEYSCAN
;;;362      *     @arg APBPeriph_QDEC
;;;363      *     @arg APBPeriph_I2C1
;;;364      *     @arg APBPeriph_I2C0
;;;365      *     @arg APBPeriph_IR
;;;366      *     @arg APBPeriph_SPI1
;;;367      *     @arg APBPeriph_SPI0
;;;368      *     @arg APBPeriph_UART0
;;;369      *     @arg APBPeriph_UART1
;;;370      *     @arg APBPeriph_UART2
;;;371      *     @arg APBPeriph_GPIO
;;;372      *     @arg APBPeriph_ADC
;;;373      *     @arg APBPeriph_I2S0
;;;374      *     @arg APBPeriph_I2S1
;;;375      *     @arg APBPeriph_CODEC
;;;376      * @param  NewState: new state of the specified peripheral clock.
;;;377      *   This parameter can be: ENABLE or DISABLE.
;;;378      * @retval None
;;;379      */
;;;380    void RCC_PeriFunctionConfig(uint32_t APBPeriph, FunctionalState NewState)
;;;381    {
        0x00208c7c:    d006        ..      BEQ      0x208c8c ; RCC_PeriFunctionConfig + 26
        0x00208c7e:    2802        .(      CMP      r0,#2
        0x00208c80:    d01c        ..      BEQ      0x208cbc ; RCC_PeriFunctionConfig + 74
        0x00208c82:    2804        .(      CMP      r0,#4
        0x00208c84:    d01a        ..      BEQ      0x208cbc ; RCC_PeriFunctionConfig + 74
        0x00208c86:    2801        .(      CMP      r0,#1
        0x00208c88:    d018        ..      BEQ      0x208cbc ; RCC_PeriFunctionConfig + 74
        0x00208c8a:    e005        ..      B        0x208c98 ; RCC_PeriFunctionConfig + 38
;;;382        /* Check the parameters */
;;;383        assert_param(IS_APB_PERIPH(APBPeriph));
;;;384        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;385    
;;;386        uint32_t apbRegOff = ((APBPeriph & (0x03 << 26)) >> 26);
;;;387    
;;;388        /* Special register handle */
;;;389        if (NewState == ENABLE)
;;;390        {
;;;391            if ((APBPeriph == APBPeriph_I2S0) || ((APBPeriph == APBPeriph_I2S1)) ||
        0x00208c8c:    2802        .(      CMP      r0,#2
        0x00208c8e:    d011        ..      BEQ      0x208cb4 ; RCC_PeriFunctionConfig + 66
        0x00208c90:    2804        .(      CMP      r0,#4
        0x00208c92:    d00f        ..      BEQ      0x208cb4 ; RCC_PeriFunctionConfig + 66
;;;392                (APBPeriph == APBPeriph_CODEC))
        0x00208c94:    2801        .(      CMP      r0,#1
        0x00208c96:    d00d        ..      BEQ      0x208cb4 ; RCC_PeriFunctionConfig + 66
        0x00208c98:    2901        .)      CMP      r1,#1
        0x00208c9a:    ea4f0182    O...    LSL      r1,r2,#2
        0x00208c9e:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x00208ca2:    f0206040     .@`    BIC      r0,r0,#0xc000000
        0x00208ca6:    f8d12210    ..."    LDR      r2,[r1,#0x210]
        0x00208caa:    d00d        ..      BEQ      0x208cc8 ; RCC_PeriFunctionConfig + 86
        0x00208cac:    4382        .C      BICS     r2,r2,r0
        0x00208cae:    f8c12210    ..."    STR      r2,[r1,#0x210]
        0x00208cb2:    4770        pG      BX       lr
;;;393            {
;;;394                SYSBLKCTRL->u_220 |= APBPeriph;
        0x00208cb4:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x00208cb8:    4301        .C      ORRS     r1,r1,r0
;;;395                return;
        0x00208cba:    e002        ..      B        0x208cc2 ; RCC_PeriFunctionConfig + 80
;;;396            }
;;;397        }
;;;398        else
;;;399        {
;;;400            if ((APBPeriph == APBPeriph_I2S0) || ((APBPeriph == APBPeriph_I2S1)) ||
;;;401                (APBPeriph == APBPeriph_CODEC))
;;;402            {
;;;403                SYSBLKCTRL->u_220 &= ~(APBPeriph);
        0x00208cbc:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x00208cc0:    4381        .C      BICS     r1,r1,r0
        0x00208cc2:    f8c31220    .. .    STR      r1,[r3,#0x220]
        0x00208cc6:    4770        pG      BX       lr
;;;404                return;
;;;405            }
;;;406        }
;;;407    
;;;408        /* clear flag */
;;;409        APBPeriph &= (~(0x03 << 26));
;;;410    
;;;411        if (NewState == ENABLE)
;;;412        {
;;;413            //enable peripheral
;;;414            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) |= APBPeriph;
        0x00208cc8:    4302        .C      ORRS     r2,r2,r0
        0x00208cca:    e7f0        ..      B        0x208cae ; RCC_PeriFunctionConfig + 60
    $d
        0x00208ccc:    60010000    ...`    DCD    1610678272
        0x00208cd0:    20004000    .@.     DCD    536887296
        0x00208cd4:    40013000    .0.@    DCD    1073819648
        0x00208cd8:    40013400    .4.@    DCD    1073820672
        0x00208cdc:    40015000    .P.@    DCD    1073827840
        0x00208ce0:    40015400    .T.@    DCD    1073828864
        0x00208ce4:    40012000    . .@    DCD    1073815552
        0x00208ce8:    40011000    ...@    DCD    1073811456
    $t
    .text
    GPIO_DeInit
;;; .\..\..\..\src\mcu\peripheral\rtl876x_gpio.c
;;;33         RCC_PeriphClockCmd(APBPeriph_GPIO, APBPeriph_GPIO_CLOCK, DISABLE);
        0x00208cec:    2200        ."      MOVS     r2,#0
        0x00208cee:    f04f5104    O..Q    MOV      r1,#0x21000000
        0x00208cf2:    485d        ]H      LDR      r0,[pc,#372] ; [0x208e68] = 0xc000100
        0x00208cf4:    f7ffbe4e    ..N.    B.W      RCC_PeriphClockCmd ; 0x208994
    GPIO_Init
;;;34     }
;;;35     
;;;36     /**
;;;37       * @brief  Initializes the GPIO peripheral according to the specified
;;;38       *         parameters in the GPIO_InitStruct.
;;;39       * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
;;;40       *         contains the configuration information for the specified GPIO peripheral.
;;;41       * @retval None
;;;42       */
;;;43     void GPIO_Init(GPIO_InitTypeDef *GPIO_InitStruct)
;;;44     {
;;;45         /* Check the parameters */
;;;46         assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;47         assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;48         assert_param(IS_GPIOIT_LEVEL_TYPE(GPIO_InitStruct->GPIO_ITTrigger));
;;;49         assert_param(IS_GPIOIT_POLARITY_TYPE(GPIO_InitStruct->GPIO_ITPolarity));
;;;50         assert_param(IS_GPIOIT_DEBOUNCE_TYPE(GPIO_InitStruct->GPIO_ITDebounce));
;;;51     
;;;52         /* GPIO configure */
;;;53         if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT)
        0x00208cf8:    7903        .y      LDRB     r3,[r0,#4]
        0x00208cfa:    495c        \I      LDR      r1,[pc,#368] ; [0x208e6c] = 0x40001000
        0x00208cfc:    2b01        .+      CMP      r3,#1
        0x00208cfe:    6802        .h      LDR      r2,[r0,#0]
        0x00208d00:    684b        Kh      LDR      r3,[r1,#4]
;;; .\..\..\..\src\mcu\peripheral\rtl876x_gpio.c (44)
        0x00208d02:    d030        0.      BEQ      0x208d66 ; GPIO_Init + 110
;;;45         /* Check the parameters */
;;;46         assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;47         assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;48         assert_param(IS_GPIOIT_LEVEL_TYPE(GPIO_InitStruct->GPIO_ITTrigger));
;;;49         assert_param(IS_GPIOIT_POLARITY_TYPE(GPIO_InitStruct->GPIO_ITPolarity));
;;;50         assert_param(IS_GPIOIT_DEBOUNCE_TYPE(GPIO_InitStruct->GPIO_ITDebounce));
;;;51     
;;;52         /* GPIO configure */
;;;53         if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT)
;;;54         {
;;;55             GPIO->DATADIR |= GPIO_InitStruct->GPIO_Pin;
;;;56     
;;;57             if (GPIO_InitStruct->GPIO_ControlMode == GPIO_SOFTWARE_MODE)
;;;58             {
;;;59                 /* Config GPIO control software mode */
;;;60                 GPIO->DATASRC &= (~GPIO_InitStruct->GPIO_Pin);
;;;61             }
;;;62             else
;;;63             {
;;;64                 /* Config GPIO hardware control mode */
;;;65                 GPIO->DATASRC |= (GPIO_InitStruct->GPIO_Pin);
;;;66             }
;;;67     
;;;68         }
;;;69         else
;;;70         {
;;;71             /*Configure GPIO input mode */
;;;72             GPIO->DATADIR = GPIO->DATADIR & (~GPIO_InitStruct->GPIO_Pin);
        0x00208d04:    4393        .C      BICS     r3,r3,r2
        0x00208d06:    604b        K`      STR      r3,[r1,#4]
;;;73     
;;;74             if (GPIO_InitStruct->GPIO_ITCmd == ENABLE)
        0x00208d08:    7942        By      LDRB     r2,[r0,#5]
        0x00208d0a:    2a01        .*      CMP      r2,#1
        0x00208d0c:    d12a        *.      BNE      0x208d64 ; GPIO_Init + 108
;;;75             {
;;;76     
;;;77                 GPIO->INTMASK = ~GPIO_Pin_All;
        0x00208d0e:    2200        ."      MOVS     r2,#0
        0x00208d10:    634a        Jc      STR      r2,[r1,#0x34]
;;;78     
;;;79                 /* configure GPIO interrupt trigger type */
;;;80                 if (GPIO_InitStruct->GPIO_ITTrigger == GPIO_INT_Trigger_LEVEL)
        0x00208d12:    7982        .y      LDRB     r2,[r0,#6]
        0x00208d14:    b38a        ..      CBZ      r2,0x208d7a ; GPIO_Init + 130
;;;81                 {
;;;82                     GPIO->INTTYPE = GPIO->INTTYPE & (~GPIO_InitStruct->GPIO_Pin);
;;;83     
;;;84                     /* Level-sensitive synchronization enable register */
;;;85                     GPIO->LSSYNC |= GPIO_InitStruct->GPIO_Pin;
;;;86                 }
;;;87                 else if (GPIO_InitStruct->GPIO_ITTrigger == GPIO_INT_Trigger_EDGE)
        0x00208d16:    2a01        .*      CMP      r2,#1
        0x00208d18:    d03d        =.      BEQ      0x208d96 ; GPIO_Init + 158
;;;88                 {
;;;89                     GPIO->INTTYPE = (GPIO->INTTYPE & (~GPIO_InitStruct->GPIO_Pin))
;;;90                                     | GPIO_InitStruct->GPIO_Pin;
;;;91                 }
;;;92                 else
;;;93                 {
;;;94                     GPIO->INTBOTHEDGE |= GPIO_InitStruct->GPIO_Pin;
        0x00208d1a:    6e8a        .n      LDR      r2,[r1,#0x68]
        0x00208d1c:    6803        .h      LDR      r3,[r0,#0]
        0x00208d1e:    431a        .C      ORRS     r2,r2,r3
        0x00208d20:    668a        .f      STR      r2,[r1,#0x68]
;;;95                 }
;;;96     
;;;97                 /* configure Interrupt polarity register */
;;;98                 if (GPIO_InitStruct->GPIO_ITPolarity == GPIO_INT_POLARITY_ACTIVE_LOW)
        0x00208d22:    79c2        .y      LDRB     r2,[r0,#7]
        0x00208d24:    b352        R.      CBZ      r2,0x208d7c ; GPIO_Init + 132
;;;99                 {
;;;100                    GPIO->INTPOLARITY = GPIO->INTPOLARITY & (~GPIO_InitStruct->GPIO_Pin);
;;;101                }
;;;102                else
;;;103                {
;;;104                    GPIO->INTPOLARITY = (GPIO->INTPOLARITY & (~GPIO_InitStruct->GPIO_Pin))
        0x00208d26:    6bcb        .k      LDR      r3,[r1,#0x3c]
        0x00208d28:    6802        .h      LDR      r2,[r0,#0]
        0x00208d2a:    4393        .C      BICS     r3,r3,r2
        0x00208d2c:    4313        .C      ORRS     r3,r3,r2
        0x00208d2e:    63cb        .c      STR      r3,[r1,#0x3c]
;;;105                                        | GPIO_InitStruct->GPIO_Pin;
;;;106                }
;;;107                /* Configure Debounce enable register */
;;;108                if (GPIO_InitStruct->GPIO_ITDebounce == GPIO_INT_DEBOUNCE_DISABLE)
        0x00208d30:    7a02        .z      LDRB     r2,[r0,#8]
        0x00208d32:    b37a        z.      CBZ      r2,0x208d94 ; GPIO_Init + 156
;;;109                {
;;;110                    GPIO->DEBOUNCE = GPIO->DEBOUNCE & (~GPIO_InitStruct->GPIO_Pin);
;;;111                }
;;;112                else
;;;113                {
;;;114                    GPIO->DEBOUNCE = (GPIO->DEBOUNCE & (~GPIO_InitStruct->GPIO_Pin))
        0x00208d34:    6c8b        .l      LDR      r3,[r1,#0x48]
        0x00208d36:    6802        .h      LDR      r2,[r0,#0]
        0x00208d38:    4393        .C      BICS     r3,r3,r2
        0x00208d3a:    4313        .C      ORRS     r3,r3,r2
        0x00208d3c:    648b        .d      STR      r3,[r1,#0x48]
;;;115                                     | GPIO_InitStruct->GPIO_Pin;
;;;116    
;;;117    #ifdef _IS_ASIC_
;;;118                    /* Config debounce time , default debounce DIV is 14*/
;;;119                    GPIO_DBCLK_DIV = (((0xd) << 8) | (1 << 12));
;;;120                    GPIO_DBCLK_DIV |= ((((GPIO_InitStruct->GPIO_DebounceTime) * (GPIO_CLOCK_SOURCE_KHZ) >>
;;;121                                         (14)) - 1) & 0xff);
;;;122    #else
;;;123                    /* Config debounce time , default debounce DIV is 13*/
;;;124                    GPIO_DBCLK_DIV = (((0x3) << 10) | (1 << 12));
        0x00208d3e:    f04f4180    O..A    MOV      r1,#0x40000000
        0x00208d42:    f44f52e0    O..R    MOV      r2,#0x1c00
        0x00208d46:    f8c12344    ..D#    STR      r2,[r1,#0x344]
;;;125                    GPIO_DBCLK_DIV |= ((((GPIO_InitStruct->GPIO_DebounceTime) * (GPIO_CLOCK_SOURCE_KHZ) >>
        0x00208d4a:    f8d12344    ..D#    LDR      r2,[r1,#0x344]
        0x00208d4e:    68c0        .h      LDR      r0,[r0,#0xc]
        0x00208d50:    f6446320    D. c    MOV      r3,#0x4e20
        0x00208d54:    4358        XC      MULS     r0,r3,r0
        0x00208d56:    23ff        .#      MOVS     r3,#0xff
        0x00208d58:    eb033050    ..P0    ADD      r0,r3,r0,LSR #13
        0x00208d5c:    b2c0        ..      UXTB     r0,r0
        0x00208d5e:    4302        .C      ORRS     r2,r2,r0
        0x00208d60:    f8c12344    ..D#    STR      r2,[r1,#0x344]
;;;126                                         (13)) - 1) & 0xff);
;;;127    #endif
;;;128                }
;;;129    
;;;130                /* Configure Interrupt enable register */
;;;131                //GPIO->INTEN |= GPIO_InitStruct->GPIO_Pin;
;;;132            }
;;;133        }
;;;134    }
        0x00208d64:    4770        pG      BX       lr
        0x00208d66:    4313        .C      ORRS     r3,r3,r2
        0x00208d68:    604b        K`      STR      r3,[r1,#4]
        0x00208d6a:    7a42        Bz      LDRB     r2,[r0,#9]
        0x00208d6c:    2a00        .*      CMP      r2,#0
        0x00208d6e:    688a        .h      LDR      r2,[r1,#8]
        0x00208d70:    6800        .h      LDR      r0,[r0,#0]
        0x00208d72:    d004        ..      BEQ      0x208d7e ; GPIO_Init + 134
        0x00208d74:    4302        .C      ORRS     r2,r2,r0
        0x00208d76:    608a        .`      STR      r2,[r1,#8]
        0x00208d78:    4770        pG      BX       lr
        0x00208d7a:    e002        ..      B        0x208d82 ; GPIO_Init + 138
        0x00208d7c:    e011        ..      B        0x208da2 ; GPIO_Init + 170
        0x00208d7e:    4382        .C      BICS     r2,r2,r0
        0x00208d80:    e7f9        ..      B        0x208d76 ; GPIO_Init + 126
        0x00208d82:    6b8a        .k      LDR      r2,[r1,#0x38]
        0x00208d84:    6803        .h      LDR      r3,[r0,#0]
        0x00208d86:    439a        .C      BICS     r2,r2,r3
        0x00208d88:    638a        .c      STR      r2,[r1,#0x38]
        0x00208d8a:    6e0a        .n      LDR      r2,[r1,#0x60]
        0x00208d8c:    6803        .h      LDR      r3,[r0,#0]
        0x00208d8e:    431a        .C      ORRS     r2,r2,r3
        0x00208d90:    660a        .f      STR      r2,[r1,#0x60]
        0x00208d92:    e7c6        ..      B        0x208d22 ; GPIO_Init + 42
        0x00208d94:    e00a        ..      B        0x208dac ; GPIO_Init + 180
        0x00208d96:    6b8b        .k      LDR      r3,[r1,#0x38]
        0x00208d98:    6802        .h      LDR      r2,[r0,#0]
        0x00208d9a:    4393        .C      BICS     r3,r3,r2
        0x00208d9c:    4313        .C      ORRS     r3,r3,r2
        0x00208d9e:    638b        .c      STR      r3,[r1,#0x38]
        0x00208da0:    e7bf        ..      B        0x208d22 ; GPIO_Init + 42
        0x00208da2:    6bca        .k      LDR      r2,[r1,#0x3c]
        0x00208da4:    6803        .h      LDR      r3,[r0,#0]
        0x00208da6:    439a        .C      BICS     r2,r2,r3
        0x00208da8:    63ca        .c      STR      r2,[r1,#0x3c]
        0x00208daa:    e7c1        ..      B        0x208d30 ; GPIO_Init + 56
        0x00208dac:    6c8a        .l      LDR      r2,[r1,#0x48]
        0x00208dae:    6800        .h      LDR      r0,[r0,#0]
        0x00208db0:    4382        .C      BICS     r2,r2,r0
        0x00208db2:    648a        .d      STR      r2,[r1,#0x48]
        0x00208db4:    e7e0        ..      B        0x208d78 ; GPIO_Init + 128
    GPIO_StructInit
;;;135    
;;;136    /**
;;;137      * @brief    Fills each GPIO_InitStruct member with its default value.
;;;138      * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will
;;;139      *    be initialized.
;;;140      * @retval None
;;;141      */
;;;142    void GPIO_StructInit(GPIO_InitTypeDef *GPIO_InitStruct)
;;;143    {
;;;144        /* Reset GPIO init structure parameters values */
;;;145        GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
        0x00208db6:    f04f31ff    O..1    MOV      r1,#0xffffffff
;;;146        GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
        0x00208dba:    6001        .`      STR      r1,[r0,#0]
        0x00208dbc:    2100        .!      MOVS     r1,#0
        0x00208dbe:    7101        .q      STRB     r1,[r0,#4]
;;;147        GPIO_InitStruct->GPIO_ITCmd = DISABLE;
        0x00208dc0:    7141        Aq      STRB     r1,[r0,#5]
;;;148        GPIO_InitStruct->GPIO_ITTrigger = GPIO_INT_Trigger_LEVEL;
        0x00208dc2:    7181        .q      STRB     r1,[r0,#6]
;;;149        GPIO_InitStruct->GPIO_ITPolarity = GPIO_INT_POLARITY_ACTIVE_LOW;
        0x00208dc4:    71c1        .q      STRB     r1,[r0,#7]
;;;150        GPIO_InitStruct->GPIO_ITDebounce = GPIO_INT_DEBOUNCE_DISABLE;
        0x00208dc6:    7201        .r      STRB     r1,[r0,#8]
;;;151        GPIO_InitStruct->GPIO_ControlMode = GPIO_SOFTWARE_MODE;
        0x00208dc8:    7241        Ar      STRB     r1,[r0,#9]
;;;152        GPIO_InitStruct->GPIO_DebounceTime = 20;                 /* ms , can be 1~64 ms */
        0x00208dca:    2114        .!      MOVS     r1,#0x14
        0x00208dcc:    60c1        .`      STR      r1,[r0,#0xc]
;;;153    }
        0x00208dce:    e7d3        ..      B        0x208d78 ; GPIO_Init + 128
    GPIO_INTConfig
;;;154    
;;;155    /**
;;;156      * @brief enable the specified GPIO interrupt.
;;;157      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;158      * @retval None
;;;159      */
;;;160    void GPIO_INTConfig(uint32_t GPIO_Pin, FunctionalState NewState)
;;;161    {
;;;162        /* Check the parameters */
;;;163        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;164        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;165    
;;;166        if (NewState != DISABLE)
;;;167        {
;;;168            /* Enable the selected GPIO pin interrupts */
;;;169            GPIO->INTEN |= GPIO_Pin;
        0x00208dd0:    4a26        &J      LDR      r2,[pc,#152] ; [0x208e6c] = 0x40001000
        0x00208dd2:    2900        .)      CMP      r1,#0
        0x00208dd4:    6b11        .k      LDR      r1,[r2,#0x30]
;;; .\..\..\..\src\mcu\peripheral\rtl876x_gpio.c (161)
        0x00208dd6:    d001        ..      BEQ      0x208ddc ; GPIO_INTConfig + 12
;;;162        /* Check the parameters */
;;;163        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;164        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;165    
;;;166        if (NewState != DISABLE)
;;;167        {
;;;168            /* Enable the selected GPIO pin interrupts */
;;;169            GPIO->INTEN |= GPIO_Pin;
        0x00208dd8:    4301        .C      ORRS     r1,r1,r0
        0x00208dda:    e000        ..      B        0x208dde ; GPIO_INTConfig + 14
        0x00208ddc:    4381        .C      BICS     r1,r1,r0
        0x00208dde:    6311        .c      STR      r1,[r2,#0x30]
;;;170        }
;;;171        else
;;;172        {
;;;173            /* Disable the selected GPIO pin interrupts */
;;;174            GPIO->INTEN &= ~GPIO_Pin;
;;;175        }
;;;176    }
        0x00208de0:    e7ca        ..      B        0x208d78 ; GPIO_Init + 128
    GPIO_ClearINTPendingBit
;;;177    
;;;178    /**
;;;179      * @brief clear the specified GPIO interrupt.
;;;180      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;181      * @retval None
;;;182      */
;;;183    void GPIO_ClearINTPendingBit(uint32_t GPIO_Pin)
;;;184    {
;;;185        /* Check the parameters */
;;;186        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;187    
;;;188        GPIO->INTCLR = GPIO_Pin;
        0x00208de2:    4922        "I      LDR      r1,[pc,#136] ; [0x208e6c] = 0x40001000
        0x00208de4:    64c8        .d      STR      r0,[r1,#0x4c]
;;;189    }
        0x00208de6:    e7c7        ..      B        0x208d78 ; GPIO_Init + 128
    GPIO_MaskINTConfig
;;;190    
;;;191    /**
;;;192      * @brief mask the specified GPIO interrupt.
;;;193      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;194      * @retval None
;;;195      */
;;;196    void GPIO_MaskINTConfig(uint32_t GPIO_Pin, FunctionalState NewState)
;;;197    {
;;;198        /* Check the parameters */
;;;199        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;200        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;201    
;;;202        if (NewState != DISABLE)
;;;203        {
;;;204            GPIO->INTMASK |= GPIO_Pin;
        0x00208de8:    4a20         J      LDR      r2,[pc,#128] ; [0x208e6c] = 0x40001000
        0x00208dea:    2900        .)      CMP      r1,#0
        0x00208dec:    6b51        Qk      LDR      r1,[r2,#0x34]
;;; .\..\..\..\src\mcu\peripheral\rtl876x_gpio.c (197)
        0x00208dee:    d001        ..      BEQ      0x208df4 ; GPIO_MaskINTConfig + 12
;;;198        /* Check the parameters */
;;;199        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;200        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;201    
;;;202        if (NewState != DISABLE)
;;;203        {
;;;204            GPIO->INTMASK |= GPIO_Pin;
        0x00208df0:    4301        .C      ORRS     r1,r1,r0
        0x00208df2:    e000        ..      B        0x208df6 ; GPIO_MaskINTConfig + 14
        0x00208df4:    4381        .C      BICS     r1,r1,r0
        0x00208df6:    6351        Qc      STR      r1,[r2,#0x34]
;;;205        }
;;;206        else
;;;207        {
;;;208            GPIO->INTMASK &= ~(GPIO_Pin);
;;;209        }
;;;210    }
        0x00208df8:    e7be        ..      B        0x208d78 ; GPIO_Init + 128
    GPIO_GetPin
        0x00208dfa:    2101        .!      MOVS     r1,#1
        0x00208dfc:    281e        .(      CMP      r0,#0x1e
;;;211    
;;;212    /**
;;;213      * @brief get the specified GPIO pin.
;;;214      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;215      * @retval  GPIO pin for GPIO initialization.
;;;216      */
;;;217    uint32_t GPIO_GetPin(uint8_t Pin_num)
;;;218    {
        0x00208dfe:    d90e        ..      BLS      0x208e1e ; GPIO_GetPin + 36
;;;219        /* Check the parameters */
;;;220        assert_param(IS_PIN_NUM(Pin_num));
;;;221    
;;;222        if (Pin_num <= P3_6)
;;;223        {
;;;224            return  BIT(Pin_num);
;;;225        }
;;;226        else if ((Pin_num <= P4_3) && (Pin_num >= P4_0))
        0x00208e00:    f1a00220    .. .    SUB      r2,r0,#0x20
        0x00208e04:    2a03        .*      CMP      r2,#3
        0x00208e06:    d801        ..      BHI      0x208e0c ; GPIO_GetPin + 18
        0x00208e08:    1f00        ..      SUBS     r0,r0,#4
;;;227        {
;;;228            return BIT(Pin_num - 4);
        0x00208e0a:    e008        ..      B        0x208e1e ; GPIO_GetPin + 36
;;;229        }
;;;230        else if ((Pin_num == H_0) || (Pin_num == H_1) || (Pin_num == H_2))
        0x00208e0c:    2824        $(      CMP      r0,#0x24
        0x00208e0e:    d005        ..      BEQ      0x208e1c ; GPIO_GetPin + 34
        0x00208e10:    2825        %(      CMP      r0,#0x25
        0x00208e12:    d003        ..      BEQ      0x208e1c ; GPIO_GetPin + 34
        0x00208e14:    2826        &(      CMP      r0,#0x26
        0x00208e16:    d001        ..      BEQ      0x208e1c ; GPIO_GetPin + 34
        0x00208e18:    20ff        .       MOVS     r0,#0xff
        0x00208e1a:    e7ad        ..      B        0x208d78 ; GPIO_Init + 128
        0x00208e1c:    380b        .8      SUBS     r0,r0,#0xb
;;;231        {
;;;232            return BIT(Pin_num - 11);
        0x00208e1e:    fa01f000    ....    LSL      r0,r1,r0
;;;233        }
;;;234    
;;;235        return 0xFF;
;;;236    }
        0x00208e22:    e7a9        ..      B        0x208d78 ; GPIO_Init + 128
    GPIO_GetNum
;;;237    
;;;238    /**
;;;239      * @brief get the specified GPIO pin number.
;;;240      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;241      * @retval  GPIO pin number.
;;;242      */
;;;243    uint8_t GPIO_GetNum(uint8_t Pin_num)
;;;244    {
;;;245        /* Check the parameters */
;;;246        assert_param(IS_PIN_NUM(Pin_num));
;;;247    
;;;248        if (Pin_num <= P3_6)
        0x00208e24:    281e        .(      CMP      r0,#0x1e
;;; .\..\..\..\src\mcu\peripheral\rtl876x_gpio.c (244)
        0x00208e26:    d9a7        ..      BLS      0x208d78 ; GPIO_Init + 128
;;;245        /* Check the parameters */
;;;246        assert_param(IS_PIN_NUM(Pin_num));
;;;247    
;;;248        if (Pin_num <= P3_6)
;;;249        {
;;;250            return (Pin_num);
;;;251        }
;;;252        else if ((Pin_num <= P4_3) && (Pin_num >= P4_0))
        0x00208e28:    f1a00120    .. .    SUB      r1,r0,#0x20
        0x00208e2c:    2903        .)      CMP      r1,#3
        0x00208e2e:    d801        ..      BHI      0x208e34 ; GPIO_GetNum + 16
        0x00208e30:    1f00        ..      SUBS     r0,r0,#4
;;;253        {
;;;254            return (Pin_num - 4);
        0x00208e32:    e008        ..      B        0x208e46 ; GPIO_GetNum + 34
;;;255        }
;;;256        else if ((Pin_num == H_0) || (Pin_num == H_1) || (Pin_num == H_2))
        0x00208e34:    2824        $(      CMP      r0,#0x24
        0x00208e36:    d005        ..      BEQ      0x208e44 ; GPIO_GetNum + 32
        0x00208e38:    2825        %(      CMP      r0,#0x25
        0x00208e3a:    d003        ..      BEQ      0x208e44 ; GPIO_GetNum + 32
        0x00208e3c:    2826        &(      CMP      r0,#0x26
        0x00208e3e:    d001        ..      BEQ      0x208e44 ; GPIO_GetNum + 32
        0x00208e40:    20ff        .       MOVS     r0,#0xff
        0x00208e42:    e799        ..      B        0x208d78 ; GPIO_Init + 128
        0x00208e44:    380b        .8      SUBS     r0,r0,#0xb
;;;257        {
;;;258            return (Pin_num - 11);
        0x00208e46:    b2c0        ..      UXTB     r0,r0
;;;259        }
;;;260    
;;;261        return 0xFF;
;;;262    }
        0x00208e48:    e796        ..      B        0x208d78 ; GPIO_Init + 128
    GPIO_DBClkCmd
        0x00208e4a:    f04f4180    O..A    MOV      r1,#0x40000000
        0x00208e4e:    2800        .(      CMP      r0,#0
        0x00208e50:    f8d10344    ..D.    LDR      r0,[r1,#0x344]
;;;263    
;;;264    /**
;;;265      * @brief get the specified GPIO pin number.
;;;266      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;267      * @retval  GPIO pin number.
;;;268      */
;;;269    void GPIO_DBClkCmd(FunctionalState NewState)
;;;270    {
        0x00208e54:    d002        ..      BEQ      0x208e5c ; GPIO_DBClkCmd + 18
;;;271        if (NewState != DISABLE)
;;;272        {
;;;273            GPIO_DBCLK_DIV |= BIT12;
        0x00208e56:    f4405080    @..P    ORR      r0,r0,#0x1000
        0x00208e5a:    e001        ..      B        0x208e60 ; GPIO_DBClkCmd + 22
        0x00208e5c:    f4205080     ..P    BIC      r0,r0,#0x1000
        0x00208e60:    f8c10344    ..D.    STR      r0,[r1,#0x344]
;;;274        }
;;;275        else
;;;276        {
;;;277            GPIO_DBCLK_DIV &= ~BIT12;
;;;278        }
;;;279    }
        0x00208e64:    e788        ..      B        0x208d78 ; GPIO_Init + 128
    $d
        0x00208e66:    0000        ..      DCW    0
        0x00208e68:    0c000100    ....    DCD    201326848
        0x00208e6c:    40001000    ...@    DCD    1073745920
    $t
    .text
    KeyScan_Init
;;; .\..\..\..\src\mcu\peripheral\rtl876x_keyscan.c
;;;28     {
        0x00208e70:    b530        0.      PUSH     {r4,r5,lr}
;;;29         assert_param(IS_KeyScan_PERIPH(KeyScan));
;;;30         assert_param(IS_KEYSCAN_ROW_NUM(KeyScan_InitStruct->rowSize));
;;;31         assert_param(IS_KEYSCAN_COL_NUM(KeyScan_InitStruct->colSize));
;;;32         assert_param(IS_KEYSCAN_DEBOUNCE_EN(KeyScan_InitStruct->debounceEn));
;;;33         assert_param(IS_KEYSCAN_DETECT_MODE(KeyScan_InitStruct->detectMode));
;;;34         assert_param(IS_KEYSCAN_FIFO_OVR_CTRL(KeyScan_InitStruct->fifoOvrCtrl));
;;;35         assert_param(IS_KEYSCAN_MAX_SCAN_DATA(KeyScan_InitStruct->maxScanData));
;;;36     
;;;37         /* Set FSM to idle state */
;;;38         KeyScan->CR &= ~BIT31;
        0x00208e72:    6882        .h      LDR      r2,[r0,#8]
        0x00208e74:    f0224200    "..B    BIC      r2,r2,#0x80000000
        0x00208e78:    6082        .`      STR      r2,[r0,#8]
;;;39     
;;;40         /* Mask all keyscan interrupt */
;;;41         KeyScan->INTMASK |= 0x1f;
        0x00208e7a:    6982        .i      LDR      r2,[r0,#0x18]
        0x00208e7c:    f042021f    B...    ORR      r2,r2,#0x1f
        0x00208e80:    6182        .a      STR      r2,[r0,#0x18]
;;;42     
;;;43         /* clock divider config */
;;;44         KeyScan->CLKDIV &= ~((0x3FF << 8) | 0x1F);
        0x00208e82:    6802        .h      LDR      r2,[r0,#0]
        0x00208e84:    4b53        SK      LDR      r3,[pc,#332] ; [0x208fd4] = 0xfffc00e0
        0x00208e86:    401a        .@      ANDS     r2,r2,r3
        0x00208e88:    6002        .`      STR      r2,[r0,#0]
;;;45         KeyScan->CLKDIV |= ((KeyScan_InitStruct->clockdiv << 8)\
        0x00208e8a:    6802        .h      LDR      r2,[r0,#0]
        0x00208e8c:    f891302e    ...0    LDRB     r3,[r1,#0x2e]
        0x00208e90:    431a        .C      ORRS     r2,r2,r3
        0x00208e92:    8d8b        ..      LDRH     r3,[r1,#0x2c]
        0x00208e94:    ea422203    B.."    ORR      r2,r2,r3,LSL #8
        0x00208e98:    6002        .`      STR      r2,[r0,#0]
;;;46                             | (KeyScan_InitStruct->delayclk));
;;;47     
;;;48         /* Config scan mode and detect mode*/
;;;49         KeyScan->CR = (KeyScan_InitStruct-> scanmode | KeyScan_InitStruct-> detectMode |
        0x00208e9a:    69cb        .i      LDR      r3,[r1,#0x1c]
        0x00208e9c:    6a8a        .j      LDR      r2,[r1,#0x28]
        0x00208e9e:    431a        .C      ORRS     r2,r2,r3
        0x00208ea0:    6a0b        .j      LDR      r3,[r1,#0x20]
        0x00208ea2:    431a        .C      ORRS     r2,r2,r3
        0x00208ea4:    6082        .`      STR      r2,[r0,#8]
;;;50                        KeyScan_InitStruct->fifoOvrCtrl);
;;;51         /* fifo threshol setting */
;;;52         KeyScan->CR |= (KeyScan_InitStruct ->fifotriggerlevel << 5);
        0x00208ea6:    6882        .h      LDR      r2,[r0,#8]
        0x00208ea8:    8e0b        ..      LDRH     r3,[r1,#0x30]
        0x00208eaa:    ea421243    B.C.    ORR      r2,r2,r3,LSL #5
        0x00208eae:    6082        .`      STR      r2,[r0,#8]
;;;53         /* key limit setting */
;;;54         KeyScan->CR |= (KeyScan_InitStruct ->keylimit << 23);
        0x00208eb0:    6882        .h      LDR      r2,[r0,#8]
        0x00208eb2:    f8913034    ..40    LDRB     r3,[r1,#0x34]
        0x00208eb6:    ea4252c3    B..R    ORR      r2,r2,r3,LSL #23
        0x00208eba:    6082        .`      STR      r2,[r0,#8]
;;;55     
;;;56         /* time config */
;;;57         KeyScan->TIMERCR = ((KeyScan_InitStruct ->debounceEn)\
        0x00208ebc:    694b        Ki      LDR      r3,[r1,#0x14]
        0x00208ebe:    68ca        .h      LDR      r2,[r1,#0xc]
        0x00208ec0:    431a        .C      ORRS     r2,r2,r3
        0x00208ec2:    690b        .i      LDR      r3,[r1,#0x10]
        0x00208ec4:    431a        .C      ORRS     r2,r2,r3
        0x00208ec6:    6042        B`      STR      r2,[r0,#4]
;;;58                             | (KeyScan_InitStruct->detecttimerEn)\
;;;59                             | (KeyScan_InitStruct->scantimerEn));
;;;60         /* time count config */
;;;61         KeyScan->TIMERCR |= ((KeyScan_InitStruct->debouncecnt << 18)\
        0x00208ec8:    6842        Bh      LDR      r2,[r0,#4]
        0x00208eca:    f8913033    ..30    LDRB     r3,[r1,#0x33]
        0x00208ece:    894c        L.      LDRH     r4,[r1,#0xa]
        0x00208ed0:    431a        .C      ORRS     r2,r2,r3
        0x00208ed2:    f8913032    ..20    LDRB     r3,[r1,#0x32]
        0x00208ed6:    049b        ..      LSLS     r3,r3,#18
        0x00208ed8:    ea432344    C.D#    ORR      r3,r3,r4,LSL #9
        0x00208edc:    431a        .C      ORRS     r2,r2,r3
        0x00208ede:    6042        B`      STR      r2,[r0,#4]
;;;62                              | (KeyScan_InitStruct->scanInterval << 9)\
;;;63                              | (KeyScan_InitStruct->releasecnt));
;;;64     
;;;65         /* Set col map, config which col to work */
;;;66         KeyScan->COLCR = ((((1 << KeyScan_InitStruct->colSize) - 1) << 8) \
        0x00208ee0:    884a        J.      LDRH     r2,[r1,#2]
        0x00208ee2:    2501        .%      MOVS     r5,#1
        0x00208ee4:    fa05f302    ....    LSL      r3,r5,r2
        0x00208ee8:    021c        ..      LSLS     r4,r3,#8
        0x00208eea:    1e52        R.      SUBS     r2,r2,#1
        0x00208eec:    f5a47480    ...t    SUB      r4,r4,#0x100
        0x00208ef0:    4314        .C      ORRS     r4,r4,r2
        0x00208ef2:    60c4        .`      STR      r4,[r0,#0xc]
;;;67                           | (KeyScan_InitStruct->colSize - 1));
;;;68     
;;;69         /* Set col map, config which col to work */
;;;70         KeyScan->ROWCR = ((KeyScan_InitStruct->rowSize - 1) << 16\
        0x00208ef4:    8809        ..      LDRH     r1,[r1,#0]
        0x00208ef6:    fa05f301    ....    LSL      r3,r5,r1
        0x00208efa:    1e49        I.      SUBS     r1,r1,#1
        0x00208efc:    1e5b        [.      SUBS     r3,r3,#1
        0x00208efe:    ea434101    C..A    ORR      r1,r3,r1,LSL #16
        0x00208f02:    6101        .a      STR      r1,[r0,#0x10]
;;;71                           | ((1 << KeyScan_InitStruct->rowSize) - 1));
;;;72     
;;;73         /* clear all interrupt status and status flag */
;;;74         KeyScan->INTCLR |= 0xff;
        0x00208f04:    69c1        .i      LDR      r1,[r0,#0x1c]
        0x00208f06:    f04101ff    A...    ORR      r1,r1,#0xff
        0x00208f0a:    61c1        .a      STR      r1,[r0,#0x1c]
;;;75         /* Unmask all keyscan interrupt */
;;;76         KeyScan->INTMASK &= ~0x1f;
        0x00208f0c:    6981        .i      LDR      r1,[r0,#0x18]
        0x00208f0e:    f021011f    !...    BIC      r1,r1,#0x1f
        0x00208f12:    6181        .a      STR      r1,[r0,#0x18]
;;;77     
;;;78         return;
;;;79     }
        0x00208f14:    bd30        0.      POP      {r4,r5,pc}
    KeyScan_DeInit
;;;80     
;;;81     /**
;;;82       * @brief  Deinitializes the Keyscan peripheral registers to their default reset values(turn off keyscan clock).
;;;83       * @param  KeyScan: selected KeyScan peripheral.
;;;84       * @retval None
;;;85       */
;;;86     void KeyScan_DeInit(KEYSCAN_TypeDef *KeyScan)
;;;87     {
;;;88         /* Check the parameters */
;;;89         assert_param(IS_KeyScan_PERIPH(KeyScan));
;;;90     
;;;91         RCC_PeriphClockCmd(APBPeriph_KEYSCAN, APBPeriph_KEYSCAN_CLOCK, DISABLE);
        0x00208f16:    2200        ."      MOVS     r2,#0
        0x00208f18:    492f        /I      LDR      r1,[pc,#188] ; [0x208fd8] = 0x60000040
        0x00208f1a:    4830        0H      LDR      r0,[pc,#192] ; [0x208fdc] = 0x8080000
        0x00208f1c:    f7ffbd3a    ..:.    B.W      RCC_PeriphClockCmd ; 0x208994
    KeyScan_StructInit
;;;92     
;;;93         return;
;;;94     }
;;;95     
;;;96     
;;;97     /**
;;;98       * @brief  Fills each I2C_InitStruct member with its default value.
;;;99       * @param  KeyScan_InitStruct: pointer to an KEYSCAN_InitTypeDef structure which will be initialized.
;;;100      * @retval None
;;;101      */
;;;102    void KeyScan_StructInit(KEYSCAN_InitTypeDef *KeyScan_InitStruct)
;;;103    {
;;;104        KeyScan_InitStruct->colSize          = 2;
        0x00208f20:    2102        .!      MOVS     r1,#2
;;; .\..\..\..\src\mcu\peripheral\rtl876x_keyscan.c (103)
        0x00208f22:    b510        ..      PUSH     {r4,lr}
;;;104        KeyScan_InitStruct->colSize          = 2;
        0x00208f24:    8041        A.      STRH     r1,[r0,#2]
;;;105        KeyScan_InitStruct->rowSize          = 2;
        0x00208f26:    8001        ..      STRH     r1,[r0,#0]
        0x00208f28:    070b        ..      LSLS     r3,r1,#28
;;;106    
;;;107        KeyScan_InitStruct->scanmode         = KeyScan_Auto_Scan_Mode;
        0x00208f2a:    074a        J.      LSLS     r2,r1,#29
;;;108        KeyScan_InitStruct->detectMode       = KeyScan_Detect_Mode_Level;
;;;109        KeyScan_InitStruct->clockdiv         = 0x1f8;
        0x00208f2c:    61c3        .a      STR      r3,[r0,#0x1c]
        0x00208f2e:    f44f71fc    O..q    MOV      r1,#0x1f8
        0x00208f32:    6282        .b      STR      r2,[r0,#0x28]
        0x00208f34:    8581        ..      STRH     r1,[r0,#0x2c]
;;;110        KeyScan_InitStruct->delayclk         = 0x01;
        0x00208f36:    2101        .!      MOVS     r1,#1
        0x00208f38:    f880102e    ....    STRB     r1,[r0,#0x2e]
;;;111        KeyScan_InitStruct->fifotriggerlevel = 1;
        0x00208f3c:    8601        ..      STRH     r1,[r0,#0x30]
;;;112        KeyScan_InitStruct->fifoOvrCtrl      = KeyScan_FIFO_OVR_CTRL_DIS_LAST;
        0x00208f3e:    070c        ..      LSLS     r4,r1,#28
;;;113    
;;;114        KeyScan_InitStruct->debounceEn       = KeyScan_Debounce_Enable;
        0x00208f40:    6204        .b      STR      r4,[r0,#0x20]
        0x00208f42:    07cc        ..      LSLS     r4,r1,#31
        0x00208f44:    60c4        .`      STR      r4,[r0,#0xc]
        0x00208f46:    e9c02304    ...#    STRD     r2,r3,[r0,#0x10]
;;;115        KeyScan_InitStruct->scantimerEn      = KeyScan_ScanInterval_Enable;
;;;116        KeyScan_InitStruct->detecttimerEn    = KeyScan_Release_Detect_Enable;
;;;117    
;;;118        KeyScan_InitStruct->scanInterval     = 0x10;
        0x00208f4a:    2210        ."      MOVS     r2,#0x10
        0x00208f4c:    8142        B.      STRH     r2,[r0,#0xa]
;;;119        KeyScan_InitStruct->debouncecnt      = 0x10;
        0x00208f4e:    f8802032    ..2     STRB     r2,[r0,#0x32]
;;;120        KeyScan_InitStruct->releasecnt       = 0x1;
        0x00208f52:    f8801033    ..3.    STRB     r1,[r0,#0x33]
;;;121    
;;;122        KeyScan_InitStruct->keylimit         = 0x03;
        0x00208f56:    2103        .!      MOVS     r1,#3
        0x00208f58:    f8801034    ..4.    STRB     r1,[r0,#0x34]
;;;123    
;;;124    
;;;125        return;
;;;126    }
        0x00208f5c:    bd10        ..      POP      {r4,pc}
    KeyScan_INTConfig
        0x00208f5e:    2a01        .*      CMP      r2,#1
        0x00208f60:    6882        .h      LDR      r2,[r0,#8]
;;;127    
;;;128    /**
;;;129      * @brief  Enables or disables the specified KeyScan interrupts.
;;;130      * @param  KeyScan: selected KeyScan peripheral.
;;;131      * @param  KeyScan_IT: specifies the KeyScan interrupts sources to be enabled or disabled.
;;;132      *   This parameter can be any combination of the following values:
;;;133      *     @arg KEYSCAN_INT_TIMEOUT: KeyScan timeout interrupt mask
;;;134      *     @arg KEYSCAN_INT_OVER_THRESHOLD: Kescan FIFO data over threshold interrupt mask
;;;135      *     @arg KEYSCAN_INT_SCAN_END: KeyScan scan end interrupt mask
;;;136      * @param  NewState: new state of the specified KeyScan interrupts.
;;;137      *   This parameter can be: ENABLE or DISABLE.
;;;138      * @retval None
;;;139      */
;;;140    void KeyScan_INTConfig(KEYSCAN_TypeDef *KeyScan, uint32_t KeyScan_IT, FunctionalState newState)
;;;141    {
        0x00208f62:    d002        ..      BEQ      0x208f6a ; KeyScan_INTConfig + 12
        0x00208f64:    438a        .C      BICS     r2,r2,r1
;;;142        /* Check the parameters */
;;;143        assert_param(IS_KeyScan_PERIPH(KeyScan));
;;;144        assert_param(IS_FUNCTIONAL_STATE(newState));
;;;145        assert_param(IS_KEYSCAN_CONFIG_IT(KeyScan_IT));
;;;146    
;;;147        if (newState == ENABLE)
;;;148        {
;;;149            /* Enable the selected KeyScan interrupts */
;;;150            KeyScan->CR |= KeyScan_IT;
        0x00208f66:    6082        .`      STR      r2,[r0,#8]
        0x00208f68:    4770        pG      BX       lr
        0x00208f6a:    430a        .C      ORRS     r2,r2,r1
        0x00208f6c:    e7fb        ..      B        0x208f66 ; KeyScan_INTConfig + 8
    KeyScan_INTMask
        0x00208f6e:    2a01        .*      CMP      r2,#1
        0x00208f70:    6982        .i      LDR      r2,[r0,#0x18]
;;;151        }
;;;152        else
;;;153        {
;;;154            /* Disable the selected KeyScan interrupts */
;;;155            KeyScan->CR &= (uint32_t)~KeyScan_IT;
;;;156        }
;;;157    }
;;;158    
;;;159    /**
;;;160      * @brief  Enables or disables the specified KeyScan interrupts mask.
;;;161      * @param  KeyScan: selected KeyScan peripheral.
;;;162      * @param  NewState: new state of the specified KeyScan interrupts mask.
;;;163      *   This parameter can be: ENABLE or DISABLE.
;;;164      * @retval None
;;;165      */
;;;166    void KeyScan_INTMask(KEYSCAN_TypeDef *KeyScan, uint32_t KeyScan_IT, FunctionalState newState)
;;;167    {
        0x00208f72:    d002        ..      BEQ      0x208f7a ; KeyScan_INTMask + 12
        0x00208f74:    438a        .C      BICS     r2,r2,r1
;;;168        /* Check the parameters */
;;;169        assert_param(IS_KeyScan_PERIPH(KeyScan));
;;;170        assert_param(IS_FUNCTIONAL_STATE(newState));
;;;171    
;;;172        if (newState == ENABLE)
;;;173        {
;;;174            /* mask KeyScan interrupts */
;;;175            KeyScan->INTMASK |= KeyScan_IT;
        0x00208f76:    6182        .a      STR      r2,[r0,#0x18]
        0x00208f78:    4770        pG      BX       lr
        0x00208f7a:    430a        .C      ORRS     r2,r2,r1
        0x00208f7c:    e7fb        ..      B        0x208f76 ; KeyScan_INTMask + 8
    KeyScan_Read
;;;176        }
;;;177        else
;;;178        {
;;;179            /* enable KeyScan interrupts */
;;;180            KeyScan->INTMASK &= (~KeyScan_IT);
;;;181        }
;;;182    }
;;;183    
;;;184    /**
;;;185      * @brief  Read data from keyscan FIFO.
;;;186      * @param  KeyScan: selected KeyScan peripheral.
;;;187      * @param[out]  outBuf: buffer to save data read from KeyScan FIFO.
;;;188      * @param  count: number of data to be read.
;;;189      * @retval None
;;;190      */
;;;191    void KeyScan_Read(KEYSCAN_TypeDef *KeyScan, uint16_t *outBuf, uint16_t count)
;;;192    {
        0x00208f7e:    b510        ..      PUSH     {r4,lr}
        0x00208f80:    2300        .#      MOVS     r3,#0
        0x00208f82:    e004        ..      B        0x208f8e ; KeyScan_Read + 16
        0x00208f84:    6944        Di      LDR      r4,[r0,#0x14]
        0x00208f86:    1c5b        [.      ADDS     r3,r3,#1
        0x00208f88:    f8214b02    !..K    STRH     r4,[r1],#2
;;;193        /* Check the parameters */
;;;194        assert_param(IS_KeyScan_PERIPH(KeyScan));
;;;195    
;;;196        uint16_t i = 0;
;;;197    
;;;198        for (i = 0; i < count; i++)
        0x00208f8c:    b29b        ..      UXTH     r3,r3
        0x00208f8e:    4293        .B      CMP      r3,r2
        0x00208f90:    d3f8        ..      BCC      0x208f84 ; KeyScan_Read + 6
;;;199        {
;;;200            *outBuf++ = (uint16_t)KeyScan->FIFODATA;
;;;201        }
;;;202    
;;;203        return;
;;;204    }
        0x00208f92:    bd10        ..      POP      {r4,pc}
    KeyScan_Cmd
;;;205    
;;;206    /**
;;;207      * @brief  Enables or disables the KeyScan peripheral.
;;;208      * @param  KeyScan: selected KeyScan peripheral.
;;;209      * @param  NewState: new state of the KeyScan peripheral.
;;;210      *   This parameter can be: ENABLE or DISABLE.
;;;211      * @retval None
;;;212      */
;;;213    void KeyScan_Cmd(KEYSCAN_TypeDef *KeyScan, FunctionalState NewState)
;;;214    {
;;;215        /* Check the parameters */
;;;216        assert_param(IS_KeyScan_PERIPH(KeyScan));
;;;217        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;218    
;;;219        if (NewState != DISABLE)
        0x00208f94:    2900        .)      CMP      r1,#0
        0x00208f96:    6881        .h      LDR      r1,[r0,#8]
;;; .\..\..\..\src\mcu\peripheral\rtl876x_keyscan.c (214)
        0x00208f98:    d002        ..      BEQ      0x208fa0 ; KeyScan_Cmd + 12
;;;215        /* Check the parameters */
;;;216        assert_param(IS_KeyScan_PERIPH(KeyScan));
;;;217        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;218    
;;;219        if (NewState != DISABLE)
;;;220        {
;;;221            /* Enable the selected I2C peripheral */
;;;222            KeyScan->CR |= BIT31;
        0x00208f9a:    f0414100    A..A    ORR      r1,r1,#0x80000000
        0x00208f9e:    e001        ..      B        0x208fa4 ; KeyScan_Cmd + 16
        0x00208fa0:    f0214100    !..A    BIC      r1,r1,#0x80000000
        0x00208fa4:    6081        .`      STR      r1,[r0,#8]
;;;223        }
;;;224        else
;;;225        {
;;;226            /* Disable the selected I2C peripheral */
;;;227            KeyScan->CR &= ~BIT31;
;;;228        }
;;;229    }
        0x00208fa6:    4770        pG      BX       lr
    KeyScan_FilterDataConfig
;;;230    
;;;231    /**
;;;232      * @brief  Set filter data.
;;;233      * @param  KeyScan: selected KeyScan peripheral.
;;;234      * @param  data: config the data to be filtered.
;;;235      *   This parameter should not be more than 9 bits
;;;236      * @retval none.
;;;237      */
;;;238    void KeyScan_FilterDataConfig(KEYSCAN_TypeDef *KeyScan, uint16_t data, FunctionalState NewState)
;;;239    {
;;;240        /* Check the parameters */
;;;241        assert_param(IS_KeyScan_PERIPH(KeyScan));
;;;242    
;;;243        if (NewState == ENABLE)
        0x00208fa8:    2a01        .*      CMP      r2,#1
;;;244        {
;;;245            KeyScan->CR &= ~BIT21;
;;;246    
;;;247            KeyScan->CR &= ~(0x1ff << 12);
        0x00208faa:    4b0d        .K      LDR      r3,[pc,#52] ; [0x208fe0] = 0xffe00fff
        0x00208fac:    6882        .h      LDR      r2,[r0,#8]
;;;248            KeyScan->CR |= ((data & 0x1ff) << 12);
        0x00208fae:    f3c10108    ....    UBFX     r1,r1,#0,#9
;;;249    
;;;250            KeyScan->CR |= BIT21;
;;;251        }
;;;252        else
;;;253        {
;;;254            KeyScan->CR &= ~BIT21;
        0x00208fb2:    f4221200    "...    BIC      r2,r2,#0x200000
        0x00208fb6:    6082        .`      STR      r2,[r0,#8]
;;;255    
;;;256            KeyScan->CR &= ~(0x1ff << 12);
        0x00208fb8:    6882        .h      LDR      r2,[r0,#8]
        0x00208fba:    ea020203    ....    AND      r2,r2,r3
        0x00208fbe:    6082        .`      STR      r2,[r0,#8]
;;;257            KeyScan->CR |= ((data & 0x1ff) << 12);
        0x00208fc0:    6882        .h      LDR      r2,[r0,#8]
        0x00208fc2:    ea423101    B..1    ORR      r1,r2,r1,LSL #12
        0x00208fc6:    d103        ..      BNE      0x208fd0 ; KeyScan_FilterDataConfig + 40
        0x00208fc8:    6081        .`      STR      r1,[r0,#8]
        0x00208fca:    6881        .h      LDR      r1,[r0,#8]
        0x00208fcc:    f4411100    A...    ORR      r1,r1,#0x200000
        0x00208fd0:    6081        .`      STR      r1,[r0,#8]
;;;258        }
;;;259    
;;;260        return;
;;;261    }
        0x00208fd2:    4770        pG      BX       lr
    $d
        0x00208fd4:    fffc00e0    ....    DCD    4294705376
        0x00208fd8:    60000040    @..`    DCD    1610612800
        0x00208fdc:    08080000    ....    DCD    134742016
        0x00208fe0:    ffe00fff    ....    DCD    4292874239
    $t
    .text
    app_le_gap_init
;;; ..\..\..\src\app\keyboard\main.c
;;;97     {
        0x00208fe4:    b510        ..      PUSH     {r4,lr}
        0x00208fe6:    b09c        ..      SUB      sp,sp,#0x70
;;;98         /* Device name and device appearance */
;;;99         uint8_t  device_name[GAP_DEVICE_NAME_LEN] = "BLE_KEYBOARD";
        0x00208fe8:    2228        ("      MOVS     r2,#0x28
        0x00208fea:    49a6        .I      LDR      r1,[pc,#664] ; [0x209284] = 0x20b788
        0x00208fec:    4668        hF      MOV      r0,sp
        0x00208fee:    f650ffdb    P...    BL       __aeabi_memcpy4 ; 0x59fa8
;;;100        uint16_t appearance = GAP_GATT_APPEARANCE_KEYBOARD;
        0x00208ff2:    f24030c1    @..0    MOV      r0,#0x3c1
        0x00208ff6:    f8ad0064    ..d.    STRH     r0,[sp,#0x64]
;;;101        uint8_t  slave_init_mtu_req = false;
        0x00208ffa:    2000        .       MOVS     r0,#0
        0x00208ffc:    2107        .!      MOVS     r1,#7
        0x00208ffe:    900b        ..      STR      r0,[sp,#0x2c]
        0x00209000:    f88d1040    ..@.    STRB     r1,[sp,#0x40]
        0x00209004:    2120         !      MOVS     r1,#0x20
        0x00209006:    f88d0034    ..4.    STRB     r0,[sp,#0x34]
;;;102    
;;;103    
;;;104        /* Advertising parameters */
;;;105        uint8_t  adv_evt_type = GAP_ADTYPE_ADV_IND;
;;;106        uint8_t  adv_direct_type = GAP_REMOTE_ADDR_LE_PUBLIC;
;;;107        uint8_t  adv_direct_addr[GAP_BD_ADDR_LEN] = {0};
;;;108        uint8_t  adv_chann_map = GAP_ADVCHAN_ALL;
;;;109        uint8_t  adv_filter_policy = GAP_ADV_FILTER_ANY;
        0x0020900a:    f88d0030    ..0.    STRB     r0,[sp,#0x30]
        0x0020900e:    f8ad1048    ..H.    STRH     r1,[sp,#0x48]
;;;110        uint16_t adv_int_min = DEFAULT_ADVERTISING_INTERVAL_MIN;
        0x00209012:    f8ad1044    ..D.    STRH     r1,[sp,#0x44]
;;;111        uint16_t adv_int_max = DEFAULT_ADVERTISING_INTERVAL_MIN;
;;;112    
;;;113        /* GAP Bond Manager parameters */
;;;114        uint8_t  auth_pair_mode = GAP_PAIRING_MODE_PAIRABLE;
        0x00209016:    2101        .!      MOVS     r1,#1
        0x00209018:    f88d1068    ..h.    STRB     r1,[sp,#0x68]
        0x0020901c:    f64033b8    @..3    MOV      r3,#0xbb8
        0x00209020:    240a        .$      MOVS     r4,#0xa
        0x00209022:    f88d0038    ..8.    STRB     r0,[sp,#0x38]
        0x00209026:    2105        .!      MOVS     r1,#5
        0x00209028:    fbb3f3f4    ....    UDIV     r3,r3,r4
;;;115        uint16_t auth_flags = GAP_AUTHEN_BIT_BONDING_FLAG | GAP_AUTHEN_BIT_MITM_FLAG;
;;;116        uint8_t  auth_io_cap = GAP_IO_CAP_KEYBOARD_ONLY;
        0x0020902c:    2202        ."      MOVS     r2,#2
        0x0020902e:    f88d003c    ..<.    STRB     r0,[sp,#0x3c]
        0x00209032:    f8ad106c    ..l.    STRH     r1,[sp,#0x6c]
        0x00209036:    f88d204c    ..L     STRB     r2,[sp,#0x4c]
        0x0020903a:    900a        ..      STR      r0,[sp,#0x28]
;;;117        uint8_t  auth_oob = false;
        0x0020903c:    f88d0050    ..P.    STRB     r0,[sp,#0x50]
;;;118        uint8_t  auth_use_fix_passkey = false;
        0x00209040:    f88d0054    ..T.    STRB     r0,[sp,#0x54]
;;;119        uint32_t auth_fix_passkey = 0;
;;;120    
;;;121        uint8_t  auth_sec_req_enable = false;
        0x00209044:    9016        ..      STR      r0,[sp,#0x58]
        0x00209046:    f88d005c    ..\.    STRB     r0,[sp,#0x5c]
;;;122        uint16_t auth_sec_req_flags = GAP_AUTHEN_BIT_BONDING_FLAG | GAP_AUTHEN_BIT_MITM_FLAG;
        0x0020904a:    f8ad1060    ..`.    STRH     r1,[sp,#0x60]
;;;123    
;;;124        uint16_t conn_interval_min   = 6;
        0x0020904e:    2006        .       MOVS     r0,#6
;;;125        uint16_t conn_interval_max   = 16;
        0x00209050:    2110        .!      MOVS     r1,#0x10
;;;126        uint16_t slave_latency       = 20;
        0x00209052:    2214        ."      MOVS     r2,#0x14
;;;127        uint16_t supervision_timeout = 3000;
;;;128    
;;;129        gaps_set_peripheral_preferred_conn_param(conn_interval_min, conn_interval_max,
        0x00209054:    f648fc72    H.r.    BL       gaps_set_peripheral_preferred_conn_param ; 0x5193c
;;;130                                                 slave_latency, supervision_timeout / 10);
;;;131    
;;;132        /* Set device name and device appearance */
;;;133        le_set_gap_param(GAP_PARAM_DEVICE_NAME, GAP_DEVICE_NAME_LEN, device_name);
        0x00209058:    466a        jF      MOV      r2,sp
        0x0020905a:    2128        (!      MOVS     r1,#0x28
        0x0020905c:    f2402022    @."     MOV      r0,#0x222
        0x00209060:    f643fdf2    C...    BL       le_set_gap_param ; 0x4cc48
;;;134        le_set_gap_param(GAP_PARAM_APPEARANCE, sizeof(appearance), &appearance);
        0x00209064:    aa19        ..      ADD      r2,sp,#0x64
        0x00209066:    2102        .!      MOVS     r1,#2
        0x00209068:    f2402021    @.!     MOV      r0,#0x221
        0x0020906c:    f643fdec    C...    BL       le_set_gap_param ; 0x4cc48
;;;135        le_set_gap_param(GAP_PARAM_SLAVE_INIT_GATT_MTU_REQ, sizeof(slave_init_mtu_req),
        0x00209070:    aa0d        ..      ADD      r2,sp,#0x34
        0x00209072:    2101        .!      MOVS     r1,#1
        0x00209074:    f2402023    @.#     MOV      r0,#0x223
        0x00209078:    f643fde6    C...    BL       le_set_gap_param ; 0x4cc48
;;;136                         &slave_init_mtu_req);
;;;137    
;;;138        /* Set advertising parameters */
;;;139        le_adv_set_param(GAP_PARAM_ADV_EVENT_TYPE, sizeof(adv_evt_type), &adv_evt_type);
        0x0020907c:    aa0e        ..      ADD      r2,sp,#0x38
        0x0020907e:    2101        .!      MOVS     r1,#1
        0x00209080:    f2402063    @.c     MOV      r0,#0x263
        0x00209084:    f648ff04    H...    BL       le_adv_set_param ; 0x51e90
;;;140        le_adv_set_param(GAP_PARAM_ADV_DIRECT_ADDR_TYPE, sizeof(adv_direct_type), &adv_direct_type);
        0x00209088:    aa0f        ..      ADD      r2,sp,#0x3c
        0x0020908a:    2101        .!      MOVS     r1,#1
        0x0020908c:    f44f7019    O..p    MOV      r0,#0x264
        0x00209090:    f648fefe    H...    BL       le_adv_set_param ; 0x51e90
;;;141        le_adv_set_param(GAP_PARAM_ADV_DIRECT_ADDR, sizeof(adv_direct_addr), adv_direct_addr);
        0x00209094:    aa0a        ..      ADD      r2,sp,#0x28
        0x00209096:    2106        .!      MOVS     r1,#6
        0x00209098:    f2402065    @.e     MOV      r0,#0x265
        0x0020909c:    f648fef8    H...    BL       le_adv_set_param ; 0x51e90
;;;142        le_adv_set_param(GAP_PARAM_ADV_CHANNEL_MAP, sizeof(adv_chann_map), &adv_chann_map);
        0x002090a0:    aa10        ..      ADD      r2,sp,#0x40
        0x002090a2:    2101        .!      MOVS     r1,#1
        0x002090a4:    f2402066    @.f     MOV      r0,#0x266
        0x002090a8:    f648fef2    H...    BL       le_adv_set_param ; 0x51e90
;;;143        le_adv_set_param(GAP_PARAM_ADV_FILTER_POLICY, sizeof(adv_filter_policy), &adv_filter_policy);
        0x002090ac:    aa0c        ..      ADD      r2,sp,#0x30
        0x002090ae:    2101        .!      MOVS     r1,#1
        0x002090b0:    f2402067    @.g     MOV      r0,#0x267
        0x002090b4:    f648feec    H...    BL       le_adv_set_param ; 0x51e90
;;;144        le_adv_set_param(GAP_PARAM_ADV_INTERVAL_MIN, sizeof(adv_int_min), &adv_int_min);
        0x002090b8:    aa11        ..      ADD      r2,sp,#0x44
        0x002090ba:    2102        .!      MOVS     r1,#2
        0x002090bc:    f44f701a    O..p    MOV      r0,#0x268
        0x002090c0:    f648fee6    H...    BL       le_adv_set_param ; 0x51e90
;;;145        le_adv_set_param(GAP_PARAM_ADV_INTERVAL_MAX, sizeof(adv_int_max), &adv_int_max);
        0x002090c4:    aa12        ..      ADD      r2,sp,#0x48
        0x002090c6:    2102        .!      MOVS     r1,#2
        0x002090c8:    f2402069    @.i     MOV      r0,#0x269
        0x002090cc:    f648fee0    H...    BL       le_adv_set_param ; 0x51e90
;;;146        le_adv_set_param(GAP_PARAM_ADV_DATA, sizeof(adv_data), (void *)adv_data);
        0x002090d0:    4a6c        lJ      LDR      r2,[pc,#432] ; [0x209284] = 0x20b788
        0x002090d2:    2115        .!      MOVS     r1,#0x15
        0x002090d4:    3a18        .:      SUBS     r2,r2,#0x18
        0x002090d6:    f2402061    @.a     MOV      r0,#0x261
        0x002090da:    f648fed9    H...    BL       le_adv_set_param ; 0x51e90
;;;147        le_adv_set_param(GAP_PARAM_SCAN_RSP_DATA, sizeof(scan_rsp_data), (void *)scan_rsp_data);
        0x002090de:    4a69        iJ      LDR      r2,[pc,#420] ; [0x209284] = 0x20b788
        0x002090e0:    2104        .!      MOVS     r1,#4
        0x002090e2:    3a1c        .:      SUBS     r2,r2,#0x1c
        0x002090e4:    f2402062    @.b     MOV      r0,#0x262
        0x002090e8:    f648fed2    H...    BL       le_adv_set_param ; 0x51e90
;;;148    
;;;149        /* Setup the GAP Bond Manager */
;;;150        gap_set_param(GAP_PARAM_BOND_PAIRING_MODE, sizeof(auth_pair_mode), &auth_pair_mode);
        0x002090ec:    aa1a        ..      ADD      r2,sp,#0x68
        0x002090ee:    2101        .!      MOVS     r1,#1
        0x002090f0:    f2402002    @..     MOV      r0,#0x202
        0x002090f4:    f642ff59    B.Y.    BL       gap_set_param ; 0x4bfaa
;;;151        gap_set_param(GAP_PARAM_BOND_AUTHEN_REQUIREMENTS_FLAGS, sizeof(auth_flags), &auth_flags);
        0x002090f8:    aa1b        ..      ADD      r2,sp,#0x6c
        0x002090fa:    2102        .!      MOVS     r1,#2
        0x002090fc:    f2402003    @..     MOV      r0,#0x203
        0x00209100:    f642ff53    B.S.    BL       gap_set_param ; 0x4bfaa
;;;152        gap_set_param(GAP_PARAM_BOND_IO_CAPABILITIES, sizeof(auth_io_cap), &auth_io_cap);
        0x00209104:    aa13        ..      ADD      r2,sp,#0x4c
        0x00209106:    2101        .!      MOVS     r1,#1
        0x00209108:    f44f7001    O..p    MOV      r0,#0x204
        0x0020910c:    f642ff4d    B.M.    BL       gap_set_param ; 0x4bfaa
;;;153        gap_set_param(GAP_PARAM_BOND_OOB_ENABLED, sizeof(auth_oob), &auth_oob);
        0x00209110:    aa14        ..      ADD      r2,sp,#0x50
        0x00209112:    2101        .!      MOVS     r1,#1
        0x00209114:    f2402005    @..     MOV      r0,#0x205
        0x00209118:    f642ff47    B.G.    BL       gap_set_param ; 0x4bfaa
;;;154        le_bond_set_param(GAP_PARAM_BOND_FIXED_PASSKEY, sizeof(auth_fix_passkey), &auth_fix_passkey);
        0x0020911c:    aa16        ..      ADD      r2,sp,#0x58
        0x0020911e:    2104        .!      MOVS     r1,#4
        0x00209120:    f2402011    @..     MOV      r0,#0x211
        0x00209124:    f643f863    C.c.    BL       le_bond_set_param ; 0x4c1ee
;;;155        le_bond_set_param(GAP_PARAM_BOND_FIXED_PASSKEY_ENABLE, sizeof(auth_use_fix_passkey),
        0x00209128:    aa15        ..      ADD      r2,sp,#0x54
        0x0020912a:    2101        .!      MOVS     r1,#1
        0x0020912c:    f2402012    @..     MOV      r0,#0x212
        0x00209130:    f643f85d    C.].    BL       le_bond_set_param ; 0x4c1ee
;;;156                          &auth_use_fix_passkey);
;;;157        le_bond_set_param(GAP_PARAM_BOND_SEC_REQ_ENABLE, sizeof(auth_sec_req_enable), &auth_sec_req_enable);
        0x00209134:    aa17        ..      ADD      r2,sp,#0x5c
        0x00209136:    2101        .!      MOVS     r1,#1
        0x00209138:    f2402013    @..     MOV      r0,#0x213
        0x0020913c:    f643f857    C.W.    BL       le_bond_set_param ; 0x4c1ee
;;;158        le_bond_set_param(GAP_PARAM_BOND_SEC_REQ_REQUIREMENT, sizeof(auth_sec_req_flags),
        0x00209140:    aa18        ..      ADD      r2,sp,#0x60
        0x00209142:    2102        .!      MOVS     r1,#2
        0x00209144:    f44f7005    O..p    MOV      r0,#0x214
        0x00209148:    f643f851    C.Q.    BL       le_bond_set_param ; 0x4c1ee
;;;159                          &auth_sec_req_flags);
;;;160    
;;;161        /* register gap message callback */
;;;162        le_register_app_cb(app_gap_callback);
        0x0020914c:    484e        NH      LDR      r0,[pc,#312] ; [0x209288] = 0x20986d
        0x0020914e:    f643fd78    C.x.    BL       le_register_app_cb ; 0x4cc42
;;;163    
;;;164    }
        0x00209152:    b01c        ..      ADD      sp,sp,#0x70
        0x00209154:    bd10        ..      POP      {r4,pc}
    app_le_profile_init
;;;165    
;;;166    /**
;;;167     * @brief  Add GATT services and register callbacks
;;;168     * @return void
;;;169     */
;;;170    void app_le_profile_init(void)
;;;171    {
        0x00209156:    b510        ..      PUSH     {r4,lr}
;;;172        server_init(4);
        0x00209158:    2004        .       MOVS     r0,#4
        0x0020915a:    f646f9d3    F...    BL       server_init ; 0x4f504
;;;173        hid_srv_id = hids_add_service(app_profile_callback);
        0x0020915e:    484b        KH      LDR      r0,[pc,#300] ; [0x20928c] = 0x209929
        0x00209160:    f7fff80f    ....    BL       hids_add_service ; 0x208182
        0x00209164:    494a        JI      LDR      r1,[pc,#296] ; [0x209290] = 0x20bc8d
        0x00209166:    7008        .p      STRB     r0,[r1,#0]
;;;174        bas_srv_id = bas_add_service(app_profile_callback);
        0x00209168:    4848        HH      LDR      r0,[pc,#288] ; [0x20928c] = 0x209929
        0x0020916a:    f7fff8c9    ....    BL       bas_add_service ; 0x208300
        0x0020916e:    4949        II      LDR      r1,[pc,#292] ; [0x209294] = 0x20bc8e
        0x00209170:    7008        .p      STRB     r0,[r1,#0]
;;;175        dis_srv_id = dis_add_service(app_profile_callback);
        0x00209172:    4846        FH      LDR      r0,[pc,#280] ; [0x20928c] = 0x209929
        0x00209174:    f7fffa01    ....    BL       dis_add_service ; 0x20857a
        0x00209178:    4947        GI      LDR      r1,[pc,#284] ; [0x209298] = 0x20bc91
        0x0020917a:    7008        .p      STRB     r0,[r1,#0]
;;;176        ota_srv_id = ota_add_service(app_profile_callback);
        0x0020917c:    4843        CH      LDR      r0,[pc,#268] ; [0x20928c] = 0x209929
        0x0020917e:    f7fffb4f    ..O.    BL       ota_add_service ; 0x208820
        0x00209182:    4946        FI      LDR      r1,[pc,#280] ; [0x20929c] = 0x20bc8f
        0x00209184:    7008        .p      STRB     r0,[r1,#0]
;;;177    
;;;178        server_register_app_cb(app_profile_callback);
        0x00209186:    e8bd4010    ...@    POP      {r4,lr}
        0x0020918a:    4840        @H      LDR      r0,[pc,#256] ; [0x20928c] = 0x209929
        0x0020918c:    f646b9d3    F...    B        server_register_app_cb ; 0x4f536
    board_init
;;;179    
;;;180    }
;;;181    
;;;182    /**
;;;183     * @brief    Contains the initialization of pinmux settings and pad settings
;;;184     * @note     All the pinmux settings and pad settings shall be initiated in this function,
;;;185     *           but if legacy driver is used, the initialization of pinmux setting and pad setting
;;;186     *           should be peformed with the IO initializing.
;;;187     * @return   void
;;;188     */
;;;189    void board_init(void)
;;;190    {
        0x00209190:    b510        ..      PUSH     {r4,lr}
;;;191        keyscan_init_data();
        0x00209192:    f000fdce    ....    BL       keyscan_init_data ; 0x209d32
;;;192        keyscan_pinmux_config();
        0x00209196:    f000fcb8    ....    BL       keyscan_pinmux_config ; 0x209b0a
;;;193        gpio_button_pinmux_config();
        0x0020919a:    f001f883    ....    BL       gpio_button_pinmux_config ; 0x20a2a4
;;;194    
;;;195        keyscan_pad_config();
        0x0020919e:    f000fc71    ..q.    BL       keyscan_pad_config ; 0x209a84
;;;196        gpio_button_pad_config();
        0x002091a2:    e8bd4010    ...@    POP      {r4,lr}
        0x002091a6:    f001b881    ....    B.W      gpio_button_pad_config ; 0x20a2ac
    driver_init
;;;197    }
;;;198    
;;;199    /**
;;;200     * @brief    Contains the initialization of peripherals
;;;201     * @note     Both new architecture driver and legacy driver initialization method can be used
;;;202     * @return   void
;;;203     */
;;;204    void driver_init(void)
;;;205    {
        0x002091aa:    b510        ..      PUSH     {r4,lr}
;;;206        keyscan_init_driver(KeyScan_Debounce_Enable);
        0x002091ac:    f04f4000    O..@    MOV      r0,#0x80000000
        0x002091b0:    f000fd5f    .._.    BL       keyscan_init_driver ; 0x209c72
;;;207        keyscan_nvic_config();
        0x002091b4:    f000fdb0    ....    BL       keyscan_nvic_config ; 0x209d18
;;;208        keyscan_init_timer();
        0x002091b8:    f000fe7f    ....    BL       keyscan_init_timer ; 0x209eba
;;;209    
;;;210        keyboard_button_init();
        0x002091bc:    f001f89e    ....    BL       keyboard_button_init ; 0x20a2fc
;;;211        longpress_timer_init();
        0x002091c0:    f001f915    ....    BL       longpress_timer_init ; 0x20a3ee
;;;212    
;;;213        adv_led_timer_init();
        0x002091c4:    f001fa15    ....    BL       adv_led_timer_init ; 0x20a5f2
;;;214        keyboard_led_init();
        0x002091c8:    f001fa5f    .._.    BL       keyboard_led_init ; 0x20a68a
;;;215    
;;;216        connection_param_updata_timer_init();
        0x002091cc:    e8bd4010    ...@    POP      {r4,lr}
        0x002091d0:    f001bb25    ..%.    B.W      connection_param_updata_timer_init ; 0x20a81e
    keyboard_enter_dlps
;;;217    }
;;;218    
;;;219    /**
;;;220    * @brief  keyboard enter dlps callback function
;;;221    * @param  No parameter.
;;;222    * @return void
;;;223    */
;;;224    void keyboard_enter_dlps(void)
;;;225    {
        0x002091d4:    b510        ..      PUSH     {r4,lr}
;;;226        keyscan_enter_dlps_config();
        0x002091d6:    f000fce4    ....    BL       keyscan_enter_dlps_config ; 0x209ba2
;;;227    
;;;228        gpio_button_enter_dlps_config();
        0x002091da:    e8bd4010    ...@    POP      {r4,lr}
        0x002091de:    f001b877    ..w.    B.W      gpio_button_enter_dlps_config ; 0x20a2d0
    keyboard_exit_dlps
;;;229    }
;;;230    
;;;231    /**
;;;232    * @brief   keyboard exit dlps callback function
;;;233    * @param   No parameter.
;;;234    * @return  void
;;;235    */
;;;236    void keyboard_exit_dlps(void)
;;;237    {
        0x002091e2:    b510        ..      PUSH     {r4,lr}
;;;238        keyscan_exit_dlps_config();
        0x002091e4:    f000fd8c    ....    BL       keyscan_exit_dlps_config ; 0x209d00
;;;239    
;;;240        gpio_button_exit_dlps_config();
        0x002091e8:    e8bd4010    ...@    POP      {r4,lr}
        0x002091ec:    f001b87b    ..{.    B.W      gpio_button_exit_dlps_config ; 0x20a2e6
    keyboard_enter_dlps_check
;;;241    }
;;;242    
;;;243    /**
;;;244     * @brief    keyboard_enter_dlps_check
;;;245     * @note     APP register this callback for dlps check
;;;246     */
;;;247    bool keyboard_enter_dlps_check(void)
;;;248    {
;;;249        /*Here, check following condition to judge whether enter dlps or not*/
;;;250        return keyscan_global_data.is_allowed_to_enter_dlps;
        0x002091f0:    482b        +H      LDR      r0,[pc,#172] ; [0x2092a0] = 0x20bc98
        0x002091f2:    7840        @x      LDRB     r0,[r0,#1]
;;;251    }
        0x002091f4:    4770        pG      BX       lr
    System_Handler
;;;252    
;;;253    /**
;;;254     * @brief    System_Handler
;;;255     * @note     Wake up by pad will trigger this interrupt
;;;256     * @return   void
;;;257     */
;;;258    void System_Handler(void)
;;;259    {
        0x002091f6:    b570        p.      PUSH     {r4-r6,lr}
;;; ..\..\..\inc\platform\cmsis\core_cm4.h
;;;1659       NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
        0x002091f8:    f04f25e0    O..%    MOV      r5,#0xe000e000
        0x002091fc:    2401        .$      MOVS     r4,#1
        0x002091fe:    f8c54180    ...A    STR      r4,[r5,#0x180]
;;; ..\..\..\src\app\keyboard\main.c
;;;263        tmpVal = btaon_fast_read_safe(0x2b);
        0x00209202:    202b        +       MOVS     r0,#0x2b
        0x00209204:    f635fdfe    5...    BL       btaon_fast_read_safe ; 0x3ee04
;;;264    
;;;265        if (tmpVal & BIT7)
        0x00209208:    0601        ..      LSLS     r1,r0,#24
        0x0020920a:    d508        ..      BPL      0x20921e ; System_Handler + 40
;;;266        {
;;;267            /* pad signal wake up event */
;;;268            btaon_fast_write_safe(0x2b, (tmpVal | BIT7));
        0x0020920c:    f0400180    @...    ORR      r1,r0,#0x80
        0x00209210:    202b        +       MOVS     r0,#0x2b
        0x00209212:    f635fe18    5...    BL       btaon_fast_write_safe ; 0x3ee46
;;;269            handle_pair_button_wakeup();
        0x00209216:    f001f96b    ..k.    BL       handle_pair_button_wakeup ; 0x20a4f0
;;;270            handle_keyscan_wakeup();
        0x0020921a:    f000fe6e    ..n.    BL       handle_keyscan_wakeup ; 0x209efa
;;; ..\..\..\inc\platform\cmsis\core_cm4.h
;;;1700       NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) &
        0x0020921e:    f8c54280    ...B    STR      r4,[r5,#0x280]
;;; ..\..\..\src\app\keyboard\main.c
;;;274    }
        0x00209222:    bd70        p.      POP      {r4-r6,pc}
    pwr_mgr_init
;;;275    
;;;276    /**
;;;277     * @brief    Contains the power mode settings
;;;278     * @return   void
;;;279     */
;;;280    void pwr_mgr_init(void)
;;;281    {
        0x00209224:    b510        ..      PUSH     {r4,lr}
;;;282        if (false == dlps_check_cb_reg(keyboard_enter_dlps_check))
        0x00209226:    f2af0037    ..7.    ADR      r0,{pc}-0x35 ; 0x2091f1
        0x0020922a:    f5fff9e8    ....    BL       dlps_check_cb_reg ; 0x85fe
        0x0020922e:    b920         .      CBNZ     r0,0x20923a ; pwr_mgr_init + 22
;;;283        {
;;;284            APP_PRINT_INFO0("keyboard_enter_dlps_check reg fail!");
        0x00209230:    2200        ."      MOVS     r2,#0
        0x00209232:    491c        .I      LDR      r1,[pc,#112] ; [0x2092a4] = 0x8800404
        0x00209234:    481c        .H      LDR      r0,[pc,#112] ; [0x2092a8] = 0x21103002
        0x00209236:    f5fefc12    ....    BL       log_buffer ; 0x7a5e
;;;285        }
;;;286        DLPS_IORegUserDlpsEnterCb(keyboard_enter_dlps);
        0x0020923a:    f2af0067    ..g.    ADR      r0,{pc}-0x65 ; 0x2091d5
;;; ..\..\..\inc\peripheral\rtl876x_io_dlps.h
;;;88         User_IO_EnterDlpsCB = func;
        0x0020923e:    491b        .I      LDR      r1,[pc,#108] ; [0x2092ac] = 0x20bba8
;;; ..\..\..\src\app\keyboard\main.c
;;;287        DLPS_IORegUserDlpsExitCb(keyboard_exit_dlps);
        0x00209240:    6008        .`      STR      r0,[r1,#0]
        0x00209242:    f2af0061    ..a.    ADR      r0,{pc}-0x5f ; 0x2091e3
;;; ..\..\..\inc\peripheral\rtl876x_io_dlps.h
;;;72         User_IO_ExitDlpsCB = func;
        0x00209246:    491a        .I      LDR      r1,[pc,#104] ; [0x2092b0] = 0x20bba4
;;; ..\..\..\src\app\keyboard\main.c
;;;288        DLPS_IORegister();
        0x00209248:    6008        .`      STR      r0,[r1,#0]
        0x0020924a:    f7fffb8d    ....    BL       DLPS_IORegister ; 0x208968
;;;289    
;;;290        lps_mode_set(LPM_DLPS_MODE);
        0x0020924e:    e8bd4010    ...@    POP      {r4,lr}
        0x00209252:    2002        .       MOVS     r0,#2
        0x00209254:    f5ffbb03    ....    B        lps_mode_set ; 0x885e
    task_init
;;;291    }
;;;292    
;;;293    /**
;;;294     * @brief    Contains the initialization of all tasks
;;;295     * @note     There is only one task in BLE Peripheral APP, thus only one APP task is init here
;;;296     * @return   void
;;;297     */
;;;298    void task_init(void)
;;;299    {
;;;300        app_task_init();
        0x00209258:    f000b869    ..i.    B.W      app_task_init ; 0x20932e
    main
;;;301    }
;;;302    
;;;303    /**
;;;304     * @brief    Entry of APP code
;;;305     * @return   int (To avoid compile warning)
;;;306     */
;;;307    int main(void)
;;;308    {
        0x0020925c:    b510        ..      PUSH     {r4,lr}
;;;309        board_init();
        0x0020925e:    f7ffff97    ....    BL       board_init ; 0x209190
;;;310        le_gap_init(1);
        0x00209262:    2001        .       MOVS     r0,#1
        0x00209264:    f643fcaa    C...    BL       le_gap_init ; 0x4cbbc
;;;311        gap_lib_init();
        0x00209268:    f001fcb4    ....    BL       gap_lib_init ; 0x20abd4
;;;312        app_le_gap_init();
        0x0020926c:    f7fffeba    ....    BL       app_le_gap_init ; 0x208fe4
;;;313        app_le_profile_init();
        0x00209270:    f7ffff71    ..q.    BL       app_le_profile_init ; 0x209156
;;;314        pwr_mgr_init();
        0x00209274:    f7ffffd6    ....    BL       pwr_mgr_init ; 0x209224
        0x00209278:    f000f859    ..Y.    BL       app_task_init ; 0x20932e
;;;315        task_init();
;;;316        os_sched_start();
        0x0020927c:    f61dfaa1    ....    BL       os_sched_start ; 0x267c2
;;;317    
;;;318        return 0;
        0x00209280:    2000        .       MOVS     r0,#0
;;;319    }
        0x00209282:    bd10        ..      POP      {r4,pc}
    $d
        0x00209284:    0020b788    .. .    DCD    2144136
        0x00209288:    0020986d    m. .    DCD    2136173
        0x0020928c:    00209929    ). .    DCD    2136361
        0x00209290:    0020bc8d    .. .    DCD    2145421
        0x00209294:    0020bc8e    .. .    DCD    2145422
        0x00209298:    0020bc91    .. .    DCD    2145425
        0x0020929c:    0020bc8f    .. .    DCD    2145423
        0x002092a0:    0020bc98    .. .    DCD    2145432
        0x002092a4:    08800404    ....    DCD    142607364
        0x002092a8:    21103002    .0.!    DCD    554708994
        0x002092ac:    0020bba8    .. .    DCD    2145192
        0x002092b0:    0020bba4    .. .    DCD    2145188
    $t
    .text
    app_main_task
;;; ..\..\..\src\app\keyboard\app_task.c
;;;89     {
        0x002092b4:    b51f        ..      PUSH     {r0-r4,lr}
;;;90         uint8_t event;
;;;91         os_msg_queue_create(&io_queue_handle, MAX_NUMBER_OF_IO_MESSAGE, sizeof(T_IO_MSG));
        0x002092b6:    205b        [       MOVS     r0,#0x5b
        0x002092b8:    9000        ..      STR      r0,[sp,#0]
        0x002092ba:    4b38        8K      LDR      r3,[pc,#224] ; [0x20939c] = 0x20b7c8
        0x002092bc:    2208        ."      MOVS     r2,#8
        0x002092be:    2120         !      MOVS     r1,#0x20
        0x002092c0:    4837        7H      LDR      r0,[pc,#220] ; [0x2093a0] = 0x20bc84
        0x002092c2:    f61cfe17    ....    BL       os_msg_queue_create_intern ; 0x25ef4
;;;92         os_msg_queue_create(&evt_queue_handle, MAX_NUMBER_OF_EVENT_MESSAGE, sizeof(uint8_t));
        0x002092c6:    205c        \       MOVS     r0,#0x5c
        0x002092c8:    9000        ..      STR      r0,[sp,#0]
        0x002092ca:    4835        5H      LDR      r0,[pc,#212] ; [0x2093a0] = 0x20bc84
        0x002092cc:    4b33        3K      LDR      r3,[pc,#204] ; [0x20939c] = 0x20b7c8
        0x002092ce:    2201        ."      MOVS     r2,#1
        0x002092d0:    2140        @!      MOVS     r1,#0x40
        0x002092d2:    1f00        ..      SUBS     r0,r0,#4
        0x002092d4:    f61cfe0e    ....    BL       os_msg_queue_create_intern ; 0x25ef4
;;;93     
;;;94         gap_start_bt_stack(evt_queue_handle, io_queue_handle, MAX_NUMBER_OF_GAP_MESSAGE);
        0x002092d8:    4c31        1L      LDR      r4,[pc,#196] ; [0x2093a0] = 0x20bc84
        0x002092da:    2220         "      MOVS     r2,#0x20
        0x002092dc:    3c08        .<      SUBS     r4,r4,#8
        0x002092de:    e9d40101    ....    LDRD     r0,r1,[r4,#4]
        0x002092e2:    f642fdc2    B...    BL       gap_start_bt_stack ; 0x4be6a
;;;95     
;;;96         extern void driver_init(void);
;;;97         driver_init();
        0x002092e6:    f7ffff60    ..`.    BL       driver_init ; 0x2091aa
;;;98         while (true)
;;;99         {
;;;100            if (os_msg_recv(evt_queue_handle, &event, 0xFFFFFFFF) == true)
        0x002092ea:    2564        d%      MOVS     r5,#0x64
        0x002092ec:    f04f37ff    O..7    MOV      r7,#0xffffffff
        0x002092f0:    2669        i&      MOVS     r6,#0x69
        0x002092f2:    9500        ..      STR      r5,[sp,#0]
        0x002092f4:    4b29        )K      LDR      r3,[pc,#164] ; [0x20939c] = 0x20b7c8
        0x002092f6:    463a        :F      MOV      r2,r7
        0x002092f8:    a903        ..      ADD      r1,sp,#0xc
        0x002092fa:    6860        `h      LDR      r0,[r4,#4]
        0x002092fc:    f61cfea2    ....    BL       os_msg_recv_intern ; 0x26044
        0x00209300:    2800        .(      CMP      r0,#0
        0x00209302:    d0f6        ..      BEQ      0x2092f2 ; app_main_task + 62
;;;101            {
;;;102                if (event == EVENT_IO_TO_APP)
        0x00209304:    f89d000c    ....    LDRB     r0,[sp,#0xc]
        0x00209308:    2802        .(      CMP      r0,#2
        0x0020930a:    d002        ..      BEQ      0x209312 ; app_main_task + 94
        0x0020930c:    f642fe1a    B...    BL       gap_handle_msg ; 0x4bf44
        0x00209310:    e7ef        ..      B        0x2092f2 ; app_main_task + 62
;;;103                {
;;;104                    T_IO_MSG io_msg;
;;;105                    if (os_msg_recv(io_queue_handle, &io_msg, 0) == true)
        0x00209312:    9600        ..      STR      r6,[sp,#0]
        0x00209314:    4b21        !K      LDR      r3,[pc,#132] ; [0x20939c] = 0x20b7c8
        0x00209316:    2200        ."      MOVS     r2,#0
        0x00209318:    a901        ..      ADD      r1,sp,#4
        0x0020931a:    68a0        .h      LDR      r0,[r4,#8]
        0x0020931c:    f61cfe92    ....    BL       os_msg_recv_intern ; 0x26044
        0x00209320:    2800        .(      CMP      r0,#0
        0x00209322:    d0e6        ..      BEQ      0x2092f2 ; app_main_task + 62
        0x00209324:    e9dd0101    ....    LDRD     r0,r1,[sp,#4]
;;;106                    {
;;;107                        app_handle_io_msg(io_msg);
        0x00209328:    f000fa4c    ..L.    BL       app_handle_io_msg ; 0x2097c4
        0x0020932c:    e7e1        ..      B        0x2092f2 ; app_main_task + 62
    app_task_init
        0x0020932e:    b51c        ..      PUSH     {r2-r4,lr}
;;; ..\..\..\src\app\keyboard\app_task.c (62)
        0x00209330:    2101        .!      MOVS     r1,#1
        0x00209332:    0288        ..      LSLS     r0,r1,#10
        0x00209334:    2300        .#      MOVS     r3,#0
        0x00209336:    f2af0283    ....    ADR      r2,{pc}-0x81 ; 0x2092b5
        0x0020933a:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0020933e:    4818        .H      LDR      r0,[pc,#96] ; [0x2093a0] = 0x20bc84
        0x00209340:    a118        ..      ADR      r1,{pc}+0x64 ; 0x2093a4
        0x00209342:    3808        .8      SUBS     r0,r0,#8
        0x00209344:    f61dfb44    ..D.    BL       os_task_create ; 0x269d0
;;;63                        APP_TASK_PRIORITY);
;;;64     }
        0x00209348:    bd1c        ..      POP      {r2-r4,pc}
    app_send_msg_to_apptask
;;;65     
;;;66     bool app_send_msg_to_apptask(T_IO_MSG *p_msg)
;;;67     {
        0x0020934a:    b57c        |.      PUSH     {r2-r6,lr}
;;;68         uint8_t event = EVENT_IO_TO_APP;
        0x0020934c:    2202        ."      MOVS     r2,#2
        0x0020934e:    f88d2004    ...     STRB     r2,[sp,#4]
;;;69     
;;;70         if (os_msg_send(io_queue_handle, p_msg, 0) == false)
        0x00209352:    4c13        .L      LDR      r4,[pc,#76] ; [0x2093a0] = 0x20bc84
        0x00209354:    2246        F"      MOVS     r2,#0x46
        0x00209356:    4b11        .K      LDR      r3,[pc,#68] ; [0x20939c] = 0x20b7c8
        0x00209358:    9200        ..      STR      r2,[sp,#0]
        0x0020935a:    3c08        .<      SUBS     r4,r4,#8
        0x0020935c:    4601        .F      MOV      r1,r0
        0x0020935e:    3b18        .;      SUBS     r3,r3,#0x18
        0x00209360:    2200        ."      MOVS     r2,#0
        0x00209362:    68a0        .h      LDR      r0,[r4,#8]
        0x00209364:    f61cfe3e    ..>.    BL       os_msg_send_intern ; 0x25fe4
        0x00209368:    4d0f        .M      LDR      r5,[pc,#60] ; [0x2093a8] = 0x21103000
        0x0020936a:    b158        X.      CBZ      r0,0x209384 ; app_send_msg_to_apptask + 58
        0x0020936c:    204b        K       MOVS     r0,#0x4b
        0x0020936e:    4b0b        .K      LDR      r3,[pc,#44] ; [0x20939c] = 0x20b7c8
        0x00209370:    9000        ..      STR      r0,[sp,#0]
        0x00209372:    3b18        .;      SUBS     r3,r3,#0x18
        0x00209374:    2200        ."      MOVS     r2,#0
        0x00209376:    a901        ..      ADD      r1,sp,#4
        0x00209378:    6860        `h      LDR      r0,[r4,#4]
        0x0020937a:    f61cfe33    ..3.    BL       os_msg_send_intern ; 0x25fe4
        0x0020937e:    b120         .      CBZ      r0,0x20938a ; app_send_msg_to_apptask + 64
        0x00209380:    2001        .       MOVS     r0,#1
        0x00209382:    bd7c        |.      POP      {r2-r6,pc}
;;;71         {
;;;72             APP_PRINT_ERROR0("send_io_msg_to_app fail");
        0x00209384:    2200        ."      MOVS     r2,#0
        0x00209386:    4909        .I      LDR      r1,[pc,#36] ; [0x2093ac] = 0x880042c
;;;73             return false;
        0x00209388:    e002        ..      B        0x209390 ; app_send_msg_to_apptask + 70
;;;74         }
;;;75         if (os_msg_send(evt_queue_handle, &event, 0) == false)
;;;76         {
;;;77             APP_PRINT_ERROR0("send_evt_msg_to_app fail");
        0x0020938a:    4908        .I      LDR      r1,[pc,#32] ; [0x2093ac] = 0x880042c
        0x0020938c:    2200        ."      MOVS     r2,#0
        0x0020938e:    311c        .1      ADDS     r1,r1,#0x1c
        0x00209390:    4628        (F      MOV      r0,r5
        0x00209392:    f5fefb64    ..d.    BL       log_buffer ; 0x7a5e
;;;78             return false;
        0x00209396:    2000        .       MOVS     r0,#0
;;;79         }
;;;80         return true;
;;;81     }
        0x00209398:    bd7c        |.      POP      {r2-r6,pc}
    $d
        0x0020939a:    0000        ..      DCW    0
        0x0020939c:    0020b7c8    .. .    DCD    2144200
        0x002093a0:    0020bc84    .. .    DCD    2145412
        0x002093a4:    00707061    app.    DCD    7368801
        0x002093a8:    21103000    .0.!    DCD    554708992
        0x002093ac:    0880042c    ,...    DCD    142607404
    $t
    .text
    app_handle_authen_state_evt
;;; ..\..\..\src\app\keyboard\keyboard_app.c
;;;273    {
        0x002093b0:    b5f8        ..      PUSH     {r3-r7,lr}
        0x002093b2:    4efc        .N      LDR      r6,[pc,#1008] ; [0x2097a4] = 0x21103002
;;; ..\..\..\src\app\keyboard\keyboard_app.c (273)
        0x002093b4:    4615        .F      MOV      r5,r2
        0x002093b6:    460c        .F      MOV      r4,r1
;;;274        APP_PRINT_INFO2("app_handle_authen_state_evt:conn_id %d, cause 0x%x", conn_id, cause);
        0x002093b8:    4603        .F      MOV      r3,r0
        0x002093ba:    9200        ..      STR      r2,[sp,#0]
        0x002093bc:    2202        ."      MOVS     r2,#2
        0x002093be:    49f8        .I      LDR      r1,[pc,#992] ; [0x2097a0] = 0x88006a4
        0x002093c0:    4630        0F      MOV      r0,r6
        0x002093c2:    f5fefb4c    ..L.    BL       log_buffer ; 0x7a5e
;;;275    
;;;276        switch (new_state)
        0x002093c6:    b154        T.      CBZ      r4,0x2093de ; app_handle_authen_state_evt + 46
        0x002093c8:    2c01        .,      CMP      r4,#1
        0x002093ca:    d00c        ..      BEQ      0x2093e6 ; app_handle_authen_state_evt + 54
        0x002093cc:    2201        ."      MOVS     r2,#1
        0x002093ce:    b001        ..      ADD      sp,sp,#4
        0x002093d0:    4623        #F      MOV      r3,r4
        0x002093d2:    1eb0        ..      SUBS     r0,r6,#2
        0x002093d4:    e8bd40f0    ...@    POP      {r4-r7,lr}
        0x002093d8:    49f3        .I      LDR      r1,[pc,#972] ; [0x2097a8] = 0x88007a8
        0x002093da:    f5febb40    ..@.    B        log_buffer ; 0x7a5e
;;;277        {
;;;278        case GAP_AUTHEN_STATE_STARTED:
;;;279            {
;;;280                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
        0x002093de:    49f0        .I      LDR      r1,[pc,#960] ; [0x2097a0] = 0x88006a4
        0x002093e0:    2200        ."      MOVS     r2,#0
        0x002093e2:    3138        81      ADDS     r1,r1,#0x38
;;;281            }
;;;282            break;
        0x002093e4:    e004        ..      B        0x2093f0 ; app_handle_authen_state_evt + 64
        0x002093e6:    f04f0200    O...    MOV      r2,#0
;;;283    
;;;284        case GAP_AUTHEN_STATE_COMPLETE:
;;;285            {
;;;286                if (cause == GAP_SUCCESS)
        0x002093ea:    b135        5.      CBZ      r5,0x2093fa ; app_handle_authen_state_evt + 74
        0x002093ec:    49ee        .I      LDR      r1,[pc,#952] ; [0x2097a8] = 0x88007a8
        0x002093ee:    3948        H9      SUBS     r1,r1,#0x48
        0x002093f0:    4630        0F      MOV      r0,r6
        0x002093f2:    e8bd40f8    ...@    POP      {r3-r7,lr}
        0x002093f6:    f5febb32    ..2.    B        log_buffer ; 0x7a5e
;;;287                {
;;;288                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
        0x002093fa:    49e9        .I      LDR      r1,[pc,#932] ; [0x2097a0] = 0x88006a4
        0x002093fc:    4630        0F      MOV      r0,r6
        0x002093fe:    3174        t1      ADDS     r1,r1,#0x74
        0x00209400:    f5fefb2d    ..-.    BL       log_buffer ; 0x7a5e
;;;289                    if (resolv_list_exist == false)
        0x00209404:    48e9        .H      LDR      r0,[pc,#932] ; [0x2097ac] = 0x20bc88
        0x00209406:    7900        .y      LDRB     r0,[r0,#4]
        0x00209408:    2800        .(      CMP      r0,#0
        0x0020940a:    d10a        ..      BNE      0x209422 ; app_handle_authen_state_evt + 114
;;;290                    {
;;;291                        T_LE_KEY_ENTRY *p_entry;
;;;292                        p_entry = le_get_high_priority_bond();
        0x0020940c:    f646ff98    F...    BL       le_get_high_priority_bond ; 0x50340
;;;293                        if ((p_entry != NULL) && (p_entry->is_used))
        0x00209410:    2800        .(      CMP      r0,#0
        0x00209412:    d006        ..      BEQ      0x209422 ; app_handle_authen_state_evt + 114
        0x00209414:    7801        .x      LDRB     r1,[r0,#0]
        0x00209416:    2900        .)      CMP      r1,#0
        0x00209418:    d003        ..      BEQ      0x209422 ; app_handle_authen_state_evt + 114
;;;294                        {
;;;295                            privacy_add_device(p_entry);
        0x0020941a:    e8bd40f8    ...@    POP      {r3-r7,lr}
        0x0020941e:    f001bac3    ....    B.W      privacy_add_device ; 0x20a9a8
;;;296                        }
;;;297                    }
;;;298                }
;;;299                else
;;;300                {
;;;301                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;302                }
;;;303            }
;;;304            break;
;;;305    
;;;306        default:
;;;307            {
;;;308                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;309            }
;;;310            break;
;;;311        }
;;;312    }
        0x00209422:    bdf8        ..      POP      {r3-r7,pc}
    app_handle_conn_param_update_evt
;;;313    
;;;314    /**
;;;315     * @brief    Handle msg GAP_MSG_LE_CONN_MTU_INFO
;;;316     * @note     This msg is used to inform APP that exchange mtu procedure is completed.
;;;317     * @param[in] conn_id Connection ID
;;;318     * @param[in] mtu_size  New mtu size
;;;319     * @return   void
;;;320     */
;;;321    void app_handle_conn_mtu_info_evt(uint8_t conn_id, uint16_t mtu_size)
;;;322    {
;;;323        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
;;;324    }
;;;325    
;;;326    /**
;;;327     * @brief    Handle msg GAP_MSG_LE_CONN_PARAM_UPDATE
;;;328     * @note     All the connection parameter update change  events are pre-handled in this function.
;;;329     * @param[in] conn_id Connection ID
;;;330     * @param[in] status  New update state
;;;331     * @param[in] cause Use this cause when status is GAP_CONN_PARAM_UPDATE_STATUS_FAIL
;;;332     * @return   void
;;;333     */
;;;334    void app_handle_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;335    {
        0x00209424:    b530        0.      PUSH     {r4,r5,lr}
        0x00209426:    4cdf        .L      LDR      r4,[pc,#892] ; [0x2097a4] = 0x21103002
;;; ..\..\..\src\app\keyboard\keyboard_app.c (335)
        0x00209428:    b085        ..      SUB      sp,sp,#0x14
        0x0020942a:    4605        .F      MOV      r5,r0
        0x0020942c:    b159        Y.      CBZ      r1,0x209446 ; app_handle_conn_param_update_evt + 34
;;;336        switch (status)
        0x0020942e:    2901        .)      CMP      r1,#1
        0x00209430:    d045        E.      BEQ      0x2094be ; app_handle_conn_param_update_evt + 154
        0x00209432:    2902        .)      CMP      r1,#2
        0x00209434:    d138        8.      BNE      0x2094a8 ; app_handle_conn_param_update_evt + 132
        0x00209436:    b005        ..      ADD      sp,sp,#0x14
        0x00209438:    4620         F      MOV      r0,r4
        0x0020943a:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x0020943e:    2200        ."      MOVS     r2,#0
        0x00209440:    49db        .I      LDR      r1,[pc,#876] ; [0x2097b0] = 0x8800928
        0x00209442:    f5febb0c    ....    B        log_buffer ; 0x7a5e
;;;337        {
;;;338        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;339            {
;;;340                uint16_t conn_interval;
;;;341                uint16_t conn_slave_latency;
;;;342                uint16_t conn_supervision_timeout;
;;;343    
;;;344                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
        0x00209446:    4602        .F      MOV      r2,r0
        0x00209448:    a904        ..      ADD      r1,sp,#0x10
        0x0020944a:    f2402072    @.r     MOV      r0,#0x272
        0x0020944e:    f644fb16    D...    BL       le_get_conn_param ; 0x4da7e
;;;345                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
        0x00209452:    462a        *F      MOV      r2,r5
        0x00209454:    a903        ..      ADD      r1,sp,#0xc
        0x00209456:    f2402073    @.s     MOV      r0,#0x273
        0x0020945a:    f644fb10    D...    BL       le_get_conn_param ; 0x4da7e
;;;346                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
        0x0020945e:    462a        *F      MOV      r2,r5
        0x00209460:    a902        ..      ADD      r1,sp,#8
        0x00209462:    f44f701d    O..p    MOV      r0,#0x274
        0x00209466:    f644fb0a    D...    BL       le_get_conn_param ; 0x4da7e
;;;347                APP_PRINT_INFO3("app_handle_conn_param_update_evt update success:conn_interval 0x%x, conn_slave_latency 0x%x, conn_supervision_timeout 0x%x",
        0x0020946a:    f8bd1008    ....    LDRH     r1,[sp,#8]
        0x0020946e:    f8bd000c    ....    LDRH     r0,[sp,#0xc]
        0x00209472:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x00209476:    49cc        .I      LDR      r1,[pc,#816] ; [0x2097a8] = 0x88007a8
        0x00209478:    f8bd3010    ...0    LDRH     r3,[sp,#0x10]
        0x0020947c:    2203        ."      MOVS     r2,#3
        0x0020947e:    3170        p1      ADDS     r1,r1,#0x70
        0x00209480:    4620         F      MOV      r0,r4
        0x00209482:    f5fefaec    ....    BL       log_buffer ; 0x7a5e
;;;348                                conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;349                if (((conn_slave_latency + 1) * conn_interval < 16) || (conn_slave_latency == 0))
        0x00209486:    f8bd000c    ....    LDRH     r0,[sp,#0xc]
        0x0020948a:    f8bd2010    ...     LDRH     r2,[sp,#0x10]
        0x0020948e:    1c41        A.      ADDS     r1,r0,#1
        0x00209490:    4351        QC      MULS     r1,r2,r1
        0x00209492:    2910        .)      CMP      r1,#0x10
        0x00209494:    db0a        ..      BLT      0x2094ac ; app_handle_conn_param_update_evt + 136
        0x00209496:    b148        H.      CBZ      r0,0x2094ac ; app_handle_conn_param_update_evt + 136
        0x00209498:    49c5        .I      LDR      r1,[pc,#788] ; [0x2097b0] = 0x8800928
        0x0020949a:    2200        ."      MOVS     r2,#0
        0x0020949c:    3968        h9      SUBS     r1,r1,#0x68
        0x0020949e:    4620         F      MOV      r0,r4
        0x002094a0:    f5fefadd    ....    BL       log_buffer ; 0x7a5e
        0x002094a4:    f001f9c9    ....    BL       stop_con_update_timer ; 0x20a83a
        0x002094a8:    b005        ..      ADD      sp,sp,#0x14
        0x002094aa:    bd30        0.      POP      {r4,r5,pc}
;;;350                {
;;;351                    APP_PRINT_INFO0("reupdate the connection parameter");
        0x002094ac:    49c0        .I      LDR      r1,[pc,#768] ; [0x2097b0] = 0x8800928
        0x002094ae:    2200        ."      MOVS     r2,#0
        0x002094b0:    3990        .9      SUBS     r1,r1,#0x90
        0x002094b2:    4620         F      MOV      r0,r4
        0x002094b4:    f5fefad3    ....    BL       log_buffer ; 0x7a5e
;;;352                    start_con_update_timer();
        0x002094b8:    f001f9c7    ....    BL       start_con_update_timer ; 0x20a84a
        0x002094bc:    e7f4        ..      B        0x2094a8 ; app_handle_conn_param_update_evt + 132
;;;353                }
;;;354                else
;;;355                {
;;;356                    APP_PRINT_INFO0("stop update the connection parameter");
;;;357                    stop_con_update_timer();
;;;358                }
;;;359            }
;;;360            break;
;;;361    
;;;362        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;363            {
;;;364                APP_PRINT_ERROR1("app_handle_conn_param_update_evt update failed: cause 0x%x", cause);
        0x002094be:    b005        ..      ADD      sp,sp,#0x14
        0x002094c0:    49bb        .I      LDR      r1,[pc,#748] ; [0x2097b0] = 0x8800928
        0x002094c2:    4613        .F      MOV      r3,r2
        0x002094c4:    48b7        .H      LDR      r0,[pc,#732] ; [0x2097a4] = 0x21103002
        0x002094c6:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x002094ca:    2201        ."      MOVS     r2,#1
        0x002094cc:    3940        @9      SUBS     r1,r1,#0x40
        0x002094ce:    1e80        ..      SUBS     r0,r0,#2
        0x002094d0:    f5febac5    ....    B        log_buffer ; 0x7a5e
    app_handle_conn_mtu_info_evt
        0x002094d4:    b508        ..      PUSH     {r3,lr}
        0x002094d6:    4603        .F      MOV      r3,r0
        0x002094d8:    9100        ..      STR      r1,[sp,#0]
        0x002094da:    49b3        .I      LDR      r1,[pc,#716] ; [0x2097a8] = 0x88007a8
        0x002094dc:    2202        ."      MOVS     r2,#2
        0x002094de:    3134        41      ADDS     r1,r1,#0x34
        0x002094e0:    48b0        .H      LDR      r0,[pc,#704] ; [0x2097a4] = 0x21103002
        0x002094e2:    f5fefabc    ....    BL       log_buffer ; 0x7a5e
        0x002094e6:    bd08        ..      POP      {r3,pc}
    app_handle_conn_state_evt
;;; ..\..\..\src\app\keyboard\keyboard_app.c (199)
        0x002094e8:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x002094ec:    4eaf        .N      LDR      r6,[pc,#700] ; [0x2097ac] = 0x20bc88
;;; ..\..\..\src\app\keyboard\keyboard_app.c (199)
        0x002094ee:    4607        .F      MOV      r7,r0
        0x002094f0:    b086        ..      SUB      sp,sp,#0x18
        0x002094f2:    7870        px      LDRB     r0,[r6,#1]
        0x002094f4:    460d        .F      MOV      r5,r1
        0x002094f6:    e9cd0500    ....    STRD     r0,r5,[sp,#0]
        0x002094fa:    f8df82a8    ....    LDR      r8,[pc,#680] ; [0x2097a4] = 0x21103002
        0x002094fe:    4614        .F      MOV      r4,r2
;;;200        APP_PRINT_INFO4("app_handle_conn_state_evt: conn_id %d old_state %d new_state %d, disc_cause 0x%x",
        0x00209500:    9202        ..      STR      r2,[sp,#8]
        0x00209502:    463b        ;F      MOV      r3,r7
        0x00209504:    2204        ."      MOVS     r2,#4
        0x00209506:    49ab        .I      LDR      r1,[pc,#684] ; [0x2097b4] = 0x8800594
        0x00209508:    4640        @F      MOV      r0,r8
        0x0020950a:    f5fefaa8    ....    BL       log_buffer ; 0x7a5e
;;;201                        conn_id, gap_conn_state, new_state, disc_cause);
;;;202        switch (new_state)
        0x0020950e:    b115        ..      CBZ      r5,0x209516 ; app_handle_conn_state_evt + 46
        0x00209510:    2d02        .-      CMP      r5,#2
        0x00209512:    d159        Y.      BNE      0x2095c8 ; app_handle_conn_state_evt + 224
        0x00209514:    e033        3.      B        0x20957e ; app_handle_conn_state_evt + 150
;;;203        {
;;;204        case GAP_CONN_STATE_DISCONNECTED:
;;;205            {
;;;206                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
        0x00209516:    f5a47080    ...p    SUB      r0,r4,#0x100
        0x0020951a:    3813        .8      SUBS     r0,r0,#0x13
        0x0020951c:    d00a        ..      BEQ      0x209534 ; app_handle_conn_state_evt + 76
;;;207                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
        0x0020951e:    f5b47f8b    ....    CMP      r4,#0x116
        0x00209522:    d007        ..      BEQ      0x209534 ; app_handle_conn_state_evt + 76
;;;208                {
;;;209                    APP_PRINT_ERROR1("app_handle_conn_state_evt: connection lost cause 0x%x", disc_cause);
        0x00209524:    49a3        .I      LDR      r1,[pc,#652] ; [0x2097b4] = 0x8800594
        0x00209526:    489f        .H      LDR      r0,[pc,#636] ; [0x2097a4] = 0x21103002
        0x00209528:    4623        #F      MOV      r3,r4
        0x0020952a:    2201        ."      MOVS     r2,#1
        0x0020952c:    3154        T1      ADDS     r1,r1,#0x54
        0x0020952e:    1e80        ..      SUBS     r0,r0,#2
        0x00209530:    f5fefa95    ....    BL       log_buffer ; 0x7a5e
;;;210                }
;;;211    
;;;212                stop_con_update_timer();
        0x00209534:    f001f981    ....    BL       stop_con_update_timer ; 0x20a83a
        0x00209538:    489f        .H      LDR      r0,[pc,#636] ; [0x2097b8] = 0x20bcc4
;;;213                report_cccd_enable = false;
        0x0020953a:    2400        .$      MOVS     r4,#0
        0x0020953c:    70f4        .p      STRB     r4,[r6,#3]
;;;214                passkey.enable_input = false;
        0x0020953e:    7144        Dq      STRB     r4,[r0,#5]
;;;215    
;;;216                if (switch_into_ota_pending)
        0x00209540:    78b0        .x      LDRB     r0,[r6,#2]
        0x00209542:    b130        0.      CBZ      r0,0x209552 ; app_handle_conn_state_evt + 106
;;;217                {
;;;218                    switch_into_ota_pending = false;
        0x00209544:    70b4        .p      STRB     r4,[r6,#2]
;;;219                    dfu_switch_to_ota_mode();
        0x00209546:    f63efac6    >...    BL       dfu_switch_to_ota_mode ; 0x47ad6
;;;220                    WDG_SystemReset(RESET_ALL_EXCEPT_AON, DFU_SWITCH_TO_OTA);
        0x0020954a:    21d2        .!      MOVS     r1,#0xd2
        0x0020954c:    2001        .       MOVS     r0,#1
        0x0020954e:    f7fefcd9    ....    BL       WDG_SystemReset ; 0x207f04
;;;221                }
;;;222    
;;;223                if (resolv_list_exist == false)
        0x00209552:    7930        0y      LDRB     r0,[r6,#4]
        0x00209554:    4f99        .O      LDR      r7,[pc,#612] ; [0x2097bc] = 0x20bccc
        0x00209556:    b178        x.      CBZ      r0,0x209578 ; app_handle_conn_state_evt + 144
;;;224                {
;;;225                    start_pair_adv = true;
;;;226                }
;;;227    
;;;228                if (start_pair_adv)
        0x00209558:    7838        8x      LDRB     r0,[r7,#0]
        0x0020955a:    b3a8        ..      CBZ      r0,0x2095c8 ; app_handle_conn_state_evt + 224
;;;229                {
;;;230                    APP_PRINT_INFO0("disconnect and start adv");
        0x0020955c:    4990        .I      LDR      r1,[pc,#576] ; [0x2097a0] = 0x88006a4
        0x0020955e:    2200        ."      MOVS     r2,#0
        0x00209560:    3980        .9      SUBS     r1,r1,#0x80
        0x00209562:    4640        @F      MOV      r0,r8
        0x00209564:    f5fefa7b    ..{.    BL       log_buffer ; 0x7a5e
;;;231                    start_pair_adv = false;
        0x00209568:    703c        <p      STRB     r4,[r7,#0]
;;;232                    keyboard_start_adv(ADV_UNDIRECT_PAIRING);
        0x0020956a:    2002        .       MOVS     r0,#2
        0x0020956c:    f001f8c6    ....    BL       keyboard_start_adv ; 0x20a6fc
;;;233                    start_adv_led_timer(false);
        0x00209570:    2000        .       MOVS     r0,#0
        0x00209572:    f001f84d    ..M.    BL       start_adv_led_timer ; 0x20a610
        0x00209576:    e027        '.      B        0x2095c8 ; app_handle_conn_state_evt + 224
        0x00209578:    2001        .       MOVS     r0,#1
        0x0020957a:    7038        8p      STRB     r0,[r7,#0]
        0x0020957c:    e7ee        ..      B        0x20955c ; app_handle_conn_state_evt + 116
;;;234                }
;;;235    
;;;236            }
;;;237            break;
;;;238    
;;;239        case GAP_CONN_STATE_CONNECTED:
;;;240            {
;;;241                keyboard_con_id = conn_id;
        0x0020957e:    7237        7r      STRB     r7,[r6,#8]
;;;242                uint16_t conn_interval;
;;;243                uint16_t conn_latency;
;;;244                uint16_t conn_supervision_timeout;
;;;245    
;;;246                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
        0x00209580:    463a        :F      MOV      r2,r7
        0x00209582:    a904        ..      ADD      r1,sp,#0x10
        0x00209584:    f2402072    @.r     MOV      r0,#0x272
        0x00209588:    f644fa79    D.y.    BL       le_get_conn_param ; 0x4da7e
;;;247                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_latency, conn_id);
        0x0020958c:    463a        :F      MOV      r2,r7
        0x0020958e:    a903        ..      ADD      r1,sp,#0xc
        0x00209590:    f2402073    @.s     MOV      r0,#0x273
        0x00209594:    f644fa73    D.s.    BL       le_get_conn_param ; 0x4da7e
;;;248                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
        0x00209598:    463a        :F      MOV      r2,r7
        0x0020959a:    a902        ..      ADD      r1,sp,#8
        0x0020959c:    f44f701d    O..p    MOV      r0,#0x274
        0x002095a0:    f644fa6d    D.m.    BL       le_get_conn_param ; 0x4da7e
;;;249                APP_PRINT_INFO3("GAP_CONN_STATE_CONNECTED: conn_interval 0x%x, conn_latency 0x%x, conn_supervision_timeout 0x%x",
        0x002095a4:    f8bd1008    ....    LDRH     r1,[sp,#8]
        0x002095a8:    f8bd000c    ....    LDRH     r0,[sp,#0xc]
        0x002095ac:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x002095b0:    497b        {I      LDR      r1,[pc,#492] ; [0x2097a0] = 0x88006a4
        0x002095b2:    f8bd3010    ...0    LDRH     r3,[sp,#0x10]
        0x002095b6:    2203        ."      MOVS     r2,#3
        0x002095b8:    3964        d9      SUBS     r1,r1,#0x64
        0x002095ba:    4640        @F      MOV      r0,r8
        0x002095bc:    f5fefa4f    ..O.    BL       log_buffer ; 0x7a5e
;;;250                                conn_interval, conn_latency, conn_supervision_timeout);
;;;251    
;;;252                stop_adv_led_timer();
        0x002095c0:    f001f840    ..@.    BL       stop_adv_led_timer ; 0x20a644
;;;253                start_con_update_timer();
        0x002095c4:    f001f941    ..A.    BL       start_con_update_timer ; 0x20a84a
;;;254            }
;;;255            break;
;;;256    
;;;257        default:
;;;258            break;
;;;259        }
;;;260        gap_conn_state = new_state;
        0x002095c8:    7075        up      STRB     r5,[r6,#1]
;;;261    }
        0x002095ca:    b006        ..      ADD      sp,sp,#0x18
        0x002095cc:    e8bd81f0    ....    POP      {r4-r8,pc}
    app_handle_dev_state_evt
        0x002095d0:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x002095d4:    b2c4        ..      UXTB     r4,r0
;;; ..\..\..\src\app\keyboard\keyboard_app.c (150)
        0x002095d6:    f3c40581    ....    UBFX     r5,r4,#2,#2
        0x002095da:    e9cd5100    ...Q    STRD     r5,r1,[sp,#0]
        0x002095de:    4975        uI      LDR      r1,[pc,#468] ; [0x2097b4] = 0x8800594
        0x002095e0:    f8df81c0    ....    LDR      r8,[pc,#448] ; [0x2097a4] = 0x21103002
        0x002095e4:    f0040601    ....    AND      r6,r4,#1
        0x002095e8:    4633        3F      MOV      r3,r6
        0x002095ea:    2203        ."      MOVS     r2,#3
        0x002095ec:    39b4        .9      SUBS     r1,r1,#0xb4
        0x002095ee:    4640        @F      MOV      r0,r8
        0x002095f0:    f5fefa35    ..5.    BL       log_buffer ; 0x7a5e
;;;151                        new_state.gap_init_state, new_state.gap_adv_state, cause);
;;;152        if (gap_dev_state.gap_init_state != new_state.gap_init_state)
        0x002095f4:    4f6d        mO      LDR      r7,[pc,#436] ; [0x2097ac] = 0x20bc88
        0x002095f6:    7838        8x      LDRB     r0,[r7,#0]
        0x002095f8:    f0000001    ....    AND      r0,r0,#1
        0x002095fc:    42b0        .B      CMP      r0,r6
        0x002095fe:    d00a        ..      BEQ      0x209616 ; app_handle_dev_state_evt + 70
;;;153        {
;;;154            if (new_state.gap_init_state == GAP_INIT_STATE_STACK_READY)
        0x00209600:    07e0        ..      LSLS     r0,r4,#31
        0x00209602:    d008        ..      BEQ      0x209616 ; app_handle_dev_state_evt + 70
;;;155            {
;;;156                APP_PRINT_INFO0("GAP stack ready");
        0x00209604:    496b        kI      LDR      r1,[pc,#428] ; [0x2097b4] = 0x8800594
        0x00209606:    2200        ."      MOVS     r2,#0
        0x00209608:    396c        l9      SUBS     r1,r1,#0x6c
        0x0020960a:    4640        @F      MOV      r0,r8
        0x0020960c:    f5fefa27    ..'.    BL       log_buffer ; 0x7a5e
;;;157                privacy_init(true);
        0x00209610:    2001        .       MOVS     r0,#1
        0x00209612:    f001fa48    ..H.    BL       privacy_init ; 0x20aaa6
;;;158            }
;;;159        }
;;;160    
;;;161        if (gap_dev_state.gap_adv_state != new_state.gap_adv_state)
        0x00209616:    7838        8x      LDRB     r0,[r7,#0]
        0x00209618:    f3c00081    ....    UBFX     r0,r0,#2,#2
        0x0020961c:    42a8        .B      CMP      r0,r5
        0x0020961e:    d022        ".      BEQ      0x209666 ; app_handle_dev_state_evt + 150
;;;162        {
;;;163            if (new_state.gap_adv_state == GAP_ADV_STATE_IDLE)
        0x00209620:    f0140f0c    ....    TST      r4,#0xc
        0x00209624:    d002        ..      BEQ      0x20962c ; app_handle_dev_state_evt + 92
        0x00209626:    2d02        .-      CMP      r5,#2
        0x00209628:    d017        ..      BEQ      0x20965a ; app_handle_dev_state_evt + 138
        0x0020962a:    e01c        ..      B        0x209666 ; app_handle_dev_state_evt + 150
;;;164            {
;;;165                if (new_state.gap_adv_sub_state == GAP_ADV_TO_IDLE_CAUSE_CONN)
        0x0020962c:    07a0        ..      LSLS     r0,r4,#30
        0x0020962e:    f04f0200    O...    MOV      r2,#0
        0x00209632:    d502        ..      BPL      0x20963a ; app_handle_dev_state_evt + 106
;;;166                {
;;;167                    APP_PRINT_INFO0("GAP adv stoped: because connection created");
        0x00209634:    495f        _I      LDR      r1,[pc,#380] ; [0x2097b4] = 0x8800594
        0x00209636:    3958        X9      SUBS     r1,r1,#0x58
        0x00209638:    e012        ..      B        0x209660 ; app_handle_dev_state_evt + 144
;;;168                }
;;;169                else
;;;170                {
;;;171                    APP_PRINT_INFO0("GAP adv stoped");
        0x0020963a:    495e        ^I      LDR      r1,[pc,#376] ; [0x2097b4] = 0x8800594
        0x0020963c:    4640        @F      MOV      r0,r8
        0x0020963e:    3928        (9      SUBS     r1,r1,#0x28
        0x00209640:    f5fefa0d    ....    BL       log_buffer ; 0x7a5e
;;;172                    if (start_pair_adv)
        0x00209644:    485d        ]H      LDR      r0,[pc,#372] ; [0x2097bc] = 0x20bccc
        0x00209646:    7801        .x      LDRB     r1,[r0,#0]
        0x00209648:    b169        i.      CBZ      r1,0x209666 ; app_handle_dev_state_evt + 150
;;;173                    {
;;;174                        start_pair_adv = false;
        0x0020964a:    2100        .!      MOVS     r1,#0
        0x0020964c:    7001        .p      STRB     r1,[r0,#0]
;;;175                        le_privacy_set_addr_resolution(false);
        0x0020964e:    4608        .F      MOV      r0,r1
        0x00209650:    f648fad1    H...    BL       le_privacy_set_addr_resolution ; 0x51bf6
;;;176                        le_bond_clear_all_keys();//maybe move this to privacy_handle_le_privacy_resolution_status_info
        0x00209654:    f642fd7c    B.|.    BL       le_bond_clear_all_keys ; 0x4c150
        0x00209658:    e005        ..      B        0x209666 ; app_handle_dev_state_evt + 150
;;;177                    }
;;;178                }
;;;179            }
;;;180            else if (new_state.gap_adv_state == GAP_ADV_STATE_ADVERTISING)
;;;181            {
;;;182                APP_PRINT_INFO0("GAP adv start");
        0x0020965a:    4956        VI      LDR      r1,[pc,#344] ; [0x2097b4] = 0x8800594
        0x0020965c:    2200        ."      MOVS     r2,#0
        0x0020965e:    3914        .9      SUBS     r1,r1,#0x14
        0x00209660:    4640        @F      MOV      r0,r8
        0x00209662:    f5fef9fc    ....    BL       log_buffer ; 0x7a5e
;;;183            }
;;;184        }
;;;185    
;;;186        gap_dev_state = new_state;
        0x00209666:    4851        QH      LDR      r0,[pc,#324] ; [0x2097ac] = 0x20bc88
        0x00209668:    7004        .p      STRB     r4,[r0,#0]
;;;187    }
        0x0020966a:    e8bd81fc    ....    POP      {r2-r8,pc}
    app_handle_gap_msg
;;;188    
;;;189    /**
;;;190     * @brief    Handle msg GAP_MSG_LE_CONN_STATE_CHANGE
;;;191     * @note     All the gap conn state events are pre-handled in this function.
;;;192     *           Then the event handling function shall be called according to the new_state
;;;193     * @param[in] conn_id Connection ID
;;;194     * @param[in] new_state  New gap connection state
;;;195     * @param[in] disc_cause Use this cause when new_state is GAP_CONN_STATE_DISCONNECTED
;;;196     * @return   void
;;;197     */
;;;198    void app_handle_conn_state_evt(uint8_t conn_id, T_GAP_CONN_STATE new_state, uint16_t disc_cause)
;;;199    {
;;;200        APP_PRINT_INFO4("app_handle_conn_state_evt: conn_id %d old_state %d new_state %d, disc_cause 0x%x",
;;;201                        conn_id, gap_conn_state, new_state, disc_cause);
;;;202        switch (new_state)
;;;203        {
;;;204        case GAP_CONN_STATE_DISCONNECTED:
;;;205            {
;;;206                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
;;;207                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
;;;208                {
;;;209                    APP_PRINT_ERROR1("app_handle_conn_state_evt: connection lost cause 0x%x", disc_cause);
;;;210                }
;;;211    
;;;212                stop_con_update_timer();
;;;213                report_cccd_enable = false;
;;;214                passkey.enable_input = false;
;;;215    
;;;216                if (switch_into_ota_pending)
;;;217                {
;;;218                    switch_into_ota_pending = false;
;;;219                    dfu_switch_to_ota_mode();
;;;220                    WDG_SystemReset(RESET_ALL_EXCEPT_AON, DFU_SWITCH_TO_OTA);
;;;221                }
;;;222    
;;;223                if (resolv_list_exist == false)
;;;224                {
;;;225                    start_pair_adv = true;
;;;226                }
;;;227    
;;;228                if (start_pair_adv)
;;;229                {
;;;230                    APP_PRINT_INFO0("disconnect and start adv");
;;;231                    start_pair_adv = false;
;;;232                    keyboard_start_adv(ADV_UNDIRECT_PAIRING);
;;;233                    start_adv_led_timer(false);
;;;234                }
;;;235    
;;;236            }
;;;237            break;
;;;238    
;;;239        case GAP_CONN_STATE_CONNECTED:
;;;240            {
;;;241                keyboard_con_id = conn_id;
;;;242                uint16_t conn_interval;
;;;243                uint16_t conn_latency;
;;;244                uint16_t conn_supervision_timeout;
;;;245    
;;;246                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;247                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_latency, conn_id);
;;;248                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;249                APP_PRINT_INFO3("GAP_CONN_STATE_CONNECTED: conn_interval 0x%x, conn_latency 0x%x, conn_supervision_timeout 0x%x",
;;;250                                conn_interval, conn_latency, conn_supervision_timeout);
;;;251    
;;;252                stop_adv_led_timer();
;;;253                start_con_update_timer();
;;;254            }
;;;255            break;
;;;256    
;;;257        default:
;;;258            break;
;;;259        }
;;;260        gap_conn_state = new_state;
;;;261    }
;;;262    
;;;263    /**
;;;264     * @brief    Handle msg GAP_MSG_LE_AUTHEN_STATE_CHANGE
;;;265     * @note     All the gap authentication state events are pre-handled in this function.
;;;266     *           Then the event handling function shall be called according to the new_state
;;;267     * @param[in] conn_id Connection ID
;;;268     * @param[in] new_state  New authentication state
;;;269     * @param[in] cause Use this cause when new_state is GAP_AUTHEN_STATE_COMPLETE
;;;270     * @return   void
;;;271     */
;;;272    void app_handle_authen_state_evt(uint8_t conn_id, uint8_t new_state, uint16_t cause)
;;;273    {
;;;274        APP_PRINT_INFO2("app_handle_authen_state_evt:conn_id %d, cause 0x%x", conn_id, cause);
;;;275    
;;;276        switch (new_state)
;;;277        {
;;;278        case GAP_AUTHEN_STATE_STARTED:
;;;279            {
;;;280                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
;;;281            }
;;;282            break;
;;;283    
;;;284        case GAP_AUTHEN_STATE_COMPLETE:
;;;285            {
;;;286                if (cause == GAP_SUCCESS)
;;;287                {
;;;288                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
;;;289                    if (resolv_list_exist == false)
;;;290                    {
;;;291                        T_LE_KEY_ENTRY *p_entry;
;;;292                        p_entry = le_get_high_priority_bond();
;;;293                        if ((p_entry != NULL) && (p_entry->is_used))
;;;294                        {
;;;295                            privacy_add_device(p_entry);
;;;296                        }
;;;297                    }
;;;298                }
;;;299                else
;;;300                {
;;;301                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;302                }
;;;303            }
;;;304            break;
;;;305    
;;;306        default:
;;;307            {
;;;308                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;309            }
;;;310            break;
;;;311        }
;;;312    }
;;;313    
;;;314    /**
;;;315     * @brief    Handle msg GAP_MSG_LE_CONN_MTU_INFO
;;;316     * @note     This msg is used to inform APP that exchange mtu procedure is completed.
;;;317     * @param[in] conn_id Connection ID
;;;318     * @param[in] mtu_size  New mtu size
;;;319     * @return   void
;;;320     */
;;;321    void app_handle_conn_mtu_info_evt(uint8_t conn_id, uint16_t mtu_size)
;;;322    {
;;;323        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
;;;324    }
;;;325    
;;;326    /**
;;;327     * @brief    Handle msg GAP_MSG_LE_CONN_PARAM_UPDATE
;;;328     * @note     All the connection parameter update change  events are pre-handled in this function.
;;;329     * @param[in] conn_id Connection ID
;;;330     * @param[in] status  New update state
;;;331     * @param[in] cause Use this cause when status is GAP_CONN_PARAM_UPDATE_STATUS_FAIL
;;;332     * @return   void
;;;333     */
;;;334    void app_handle_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;335    {
;;;336        switch (status)
;;;337        {
;;;338        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;339            {
;;;340                uint16_t conn_interval;
;;;341                uint16_t conn_slave_latency;
;;;342                uint16_t conn_supervision_timeout;
;;;343    
;;;344                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;345                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
;;;346                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;347                APP_PRINT_INFO3("app_handle_conn_param_update_evt update success:conn_interval 0x%x, conn_slave_latency 0x%x, conn_supervision_timeout 0x%x",
;;;348                                conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;349                if (((conn_slave_latency + 1) * conn_interval < 16) || (conn_slave_latency == 0))
;;;350                {
;;;351                    APP_PRINT_INFO0("reupdate the connection parameter");
;;;352                    start_con_update_timer();
;;;353                }
;;;354                else
;;;355                {
;;;356                    APP_PRINT_INFO0("stop update the connection parameter");
;;;357                    stop_con_update_timer();
;;;358                }
;;;359            }
;;;360            break;
;;;361    
;;;362        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;363            {
;;;364                APP_PRINT_ERROR1("app_handle_conn_param_update_evt update failed: cause 0x%x", cause);
;;;365            }
;;;366            break;
;;;367    
;;;368        case GAP_CONN_PARAM_UPDATE_STATUS_PENDING:
;;;369            {
;;;370                APP_PRINT_INFO0("app_handle_conn_param_update_evt update pending.");
;;;371            }
;;;372            break;
;;;373    
;;;374        default:
;;;375            break;
;;;376        }
;;;377    }
;;;378    
;;;379    /**
;;;380     * @brief    All the BT GAP MSG are pre-handled in this function.
;;;381     * @note     Then the event handling function shall be called according to the
;;;382     *           subtype of T_IO_MSG
;;;383     * @param[in] p_gap_msg Pointer to GAP msg
;;;384     * @return   void
;;;385     */
;;;386    void app_handle_gap_msg(T_IO_MSG *p_gap_msg)
;;;387    {
        0x0020966e:    b57f        ..      PUSH     {r0-r6,lr}
        0x00209670:    4605        .F      MOV      r5,r0
;;;388        T_LE_GAP_MSG gap_msg;
;;;389        uint8_t conn_id;
;;;390        memcpy(&gap_msg, &p_gap_msg->u.param, sizeof(p_gap_msg->u.param));
;;;391    
;;;392        APP_PRINT_TRACE1("app_handle_gap_msg: subtype %d", p_gap_msg->subtype);
        0x00209672:    8843        C.      LDRH     r3,[r0,#2]
        0x00209674:    6844        Dh      LDR      r4,[r0,#4]
        0x00209676:    494e        NI      LDR      r1,[pc,#312] ; [0x2097b0] = 0x8800928
        0x00209678:    484a        JH      LDR      r0,[pc,#296] ; [0x2097a4] = 0x21103002
        0x0020967a:    2201        ."      MOVS     r2,#1
        0x0020967c:    3134        41      ADDS     r1,r1,#0x34
        0x0020967e:    1c40        @.      ADDS     r0,r0,#1
        0x00209680:    f5fef9ed    ....    BL       log_buffer ; 0x7a5e
;;;393        switch (p_gap_msg->subtype)
        0x00209684:    886b        k.      LDRH     r3,[r5,#2]
        0x00209686:    2000        .       MOVS     r0,#0
        0x00209688:    4d46        FM      LDR      r5,[pc,#280] ; [0x2097a4] = 0x21103002
        0x0020968a:    2b0b        .+      CMP      r3,#0xb
        0x0020968c:    d27d        }.      BCS      0x20978a ; app_handle_gap_msg + 284
        0x0020968e:    e8dff003    ....    TBB      [pc,r3]
    $d
        0x00209692:    067c        |.      DCW    1660
        0x00209694:    22141a0c    ..."    DCD    571742732
        0x00209698:    49665b37    7[fI    DCD    1231444791
        0x0020969c:    002a        *.      DCW    42
    $t
;;;394        {
;;;395        case GAP_MSG_LE_DEV_STATE_CHANGE:
;;;396            {
;;;397                app_handle_dev_state_evt(gap_msg.msg_data.gap_dev_state_change.new_state,
        0x0020969e:    b004        ..      ADD      sp,sp,#0x10
        0x002096a0:    4620         F      MOV      r0,r4
        0x002096a2:    0c21        !.      LSRS     r1,r4,#16
        0x002096a4:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x002096a8:    e792        ..      B        app_handle_dev_state_evt ; 0x2095d0
        0x002096aa:    b004        ..      ADD      sp,sp,#0x10
        0x002096ac:    0c22        ".      LSRS     r2,r4,#16
        0x002096ae:    f3c42107    ...!    UBFX     r1,r4,#8,#8
        0x002096b2:    b2e0        ..      UXTB     r0,r4
;;;398                                         gap_msg.msg_data.gap_dev_state_change.cause);
;;;399            }
;;;400            break;
;;;401    
;;;402        case GAP_MSG_LE_CONN_STATE_CHANGE:
;;;403            {
;;;404                app_handle_conn_state_evt(gap_msg.msg_data.gap_conn_state_change.conn_id,
        0x002096b4:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x002096b8:    e716        ..      B        app_handle_conn_state_evt ; 0x2094e8
        0x002096ba:    b004        ..      ADD      sp,sp,#0x10
        0x002096bc:    0c21        !.      LSRS     r1,r4,#16
        0x002096be:    b2e0        ..      UXTB     r0,r4
;;;405                                          (T_GAP_CONN_STATE)gap_msg.msg_data.gap_conn_state_change.new_state,
;;;406                                          gap_msg.msg_data.gap_conn_state_change.disc_cause);
;;;407            }
;;;408            break;
;;;409    
;;;410        case GAP_MSG_LE_CONN_MTU_INFO:
;;;411            {
;;;412                app_handle_conn_mtu_info_evt(gap_msg.msg_data.gap_conn_mtu_info.conn_id,
        0x002096c0:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x002096c4:    e706        ..      B        app_handle_conn_mtu_info_evt ; 0x2094d4
        0x002096c6:    b004        ..      ADD      sp,sp,#0x10
        0x002096c8:    0c22        ".      LSRS     r2,r4,#16
        0x002096ca:    f3c42107    ...!    UBFX     r1,r4,#8,#8
        0x002096ce:    b2e0        ..      UXTB     r0,r4
;;;413                                             gap_msg.msg_data.gap_conn_mtu_info.mtu_size);
;;;414            }
;;;415            break;
;;;416    
;;;417        case GAP_MSG_LE_CONN_PARAM_UPDATE:
;;;418            {
;;;419                app_handle_conn_param_update_evt(gap_msg.msg_data.gap_conn_param_update.conn_id,
        0x002096d0:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x002096d4:    e6a6        ..      B        app_handle_conn_param_update_evt ; 0x209424
        0x002096d6:    b004        ..      ADD      sp,sp,#0x10
        0x002096d8:    0c22        ".      LSRS     r2,r4,#16
        0x002096da:    f3c42107    ...!    UBFX     r1,r4,#8,#8
        0x002096de:    b2e0        ..      UXTB     r0,r4
;;;420                                                 gap_msg.msg_data.gap_conn_param_update.status,
;;;421                                                 gap_msg.msg_data.gap_conn_param_update.cause);
;;;422            }
;;;423            break;
;;;424    
;;;425        case GAP_MSG_LE_AUTHEN_STATE_CHANGE:
;;;426            {
;;;427                app_handle_authen_state_evt(gap_msg.msg_data.gap_authen_state.conn_id,
        0x002096e0:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x002096e4:    e664        d.      B        app_handle_authen_state_evt ; 0x2093b0
        0x002096e6:    b2e0        ..      UXTB     r0,r4
;;;428                                            gap_msg.msg_data.gap_authen_state.new_state,
;;;429                                            gap_msg.msg_data.gap_authen_state.status);
;;;430            }
;;;431            break;
;;;432    
;;;433        case GAP_MSG_LE_BOND_JUST_WORK:
;;;434            {
;;;435                conn_id = gap_msg.msg_data.gap_bond_just_work_conf.conn_id;
;;;436                le_bond_just_work_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x002096e8:    2101        .!      MOVS     r1,#1
        0x002096ea:    f001fad0    ....    BL       le_bond_just_work_confirm ; 0x20ac8e
;;;437                APP_PRINT_INFO0("GAP_MSG_LE_BOND_JUST_WORK");
        0x002096ee:    b004        ..      ADD      sp,sp,#0x10
        0x002096f0:    4628        (F      MOV      r0,r5
        0x002096f2:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x002096f6:    492e        .I      LDR      r1,[pc,#184] ; [0x2097b0] = 0x8800928
        0x002096f8:    2200        ."      MOVS     r2,#0
        0x002096fa:    3154        T1      ADDS     r1,r1,#0x54
        0x002096fc:    f5feb9af    ....    B        log_buffer ; 0x7a5e
;;;438            }
;;;439            break;
;;;440    
;;;441        case GAP_MSG_LE_BOND_PASSKEY_DISPLAY:
;;;442            {
;;;443                uint32_t display_value = 0;
        0x00209700:    b2e4        ..      UXTB     r4,r4
;;;444                conn_id = gap_msg.msg_data.gap_bond_passkey_display.conn_id;
;;;445                le_bond_get_display_key(conn_id, &display_value);
        0x00209702:    9000        ..      STR      r0,[sp,#0]
        0x00209704:    4669        iF      MOV      r1,sp
        0x00209706:    4620         F      MOV      r0,r4
        0x00209708:    f642fe6f    B.o.    BL       le_bond_get_display_key ; 0x4c3ea
;;;446                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_DISPLAY:passkey %d", display_value);
        0x0020970c:    4928        (I      LDR      r1,[pc,#160] ; [0x2097b0] = 0x8800928
        0x0020970e:    2201        ."      MOVS     r2,#1
        0x00209710:    3174        t1      ADDS     r1,r1,#0x74
        0x00209712:    4628        (F      MOV      r0,r5
        0x00209714:    9b00        ..      LDR      r3,[sp,#0]
        0x00209716:    f5fef9a2    ....    BL       log_buffer ; 0x7a5e
;;;447                le_bond_passkey_display_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x0020971a:    2101        .!      MOVS     r1,#1
        0x0020971c:    4620         F      MOV      r0,r4
        0x0020971e:    f642fea9    B...    BL       le_bond_passkey_display_confirm ; 0x4c474
        0x00209722:    bd7f        ..      POP      {r0-r6,pc}
;;;448            }
;;;449            break;
;;;450    
;;;451        case GAP_MSG_LE_BOND_USER_CONFIRMATION:
;;;452            {
;;;453                uint32_t display_value = 0;
        0x00209724:    b2e4        ..      UXTB     r4,r4
;;;454                conn_id = gap_msg.msg_data.gap_bond_user_conf.conn_id;
;;;455                le_bond_get_display_key(conn_id, &display_value);
        0x00209726:    9000        ..      STR      r0,[sp,#0]
        0x00209728:    4669        iF      MOV      r1,sp
        0x0020972a:    4620         F      MOV      r0,r4
        0x0020972c:    f642fe5d    B.].    BL       le_bond_get_display_key ; 0x4c3ea
;;;456                APP_PRINT_INFO1("GAP_MSG_LE_BOND_USER_CONFIRMATION: passkey %d", display_value);
        0x00209730:    491f        .I      LDR      r1,[pc,#124] ; [0x2097b0] = 0x8800928
        0x00209732:    2201        ."      MOVS     r2,#1
        0x00209734:    31a4        .1      ADDS     r1,r1,#0xa4
        0x00209736:    4628        (F      MOV      r0,r5
        0x00209738:    9b00        ..      LDR      r3,[sp,#0]
        0x0020973a:    f5fef990    ....    BL       log_buffer ; 0x7a5e
;;;457                le_bond_user_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x0020973e:    2101        .!      MOVS     r1,#1
        0x00209740:    4620         F      MOV      r0,r4
        0x00209742:    f642fe67    B.g.    BL       le_bond_user_confirm ; 0x4c414
        0x00209746:    bd7f        ..      POP      {r0-r6,pc}
;;;458            }
;;;459            break;
;;;460    
;;;461        case GAP_MSG_LE_BOND_PASSKEY_INPUT:
;;;462            {
;;;463                conn_id = gap_msg.msg_data.gap_bond_passkey_input.conn_id;
;;;464                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d", conn_id);
        0x00209748:    4919        .I      LDR      r1,[pc,#100] ; [0x2097b0] = 0x8800928
        0x0020974a:    b2e3        ..      UXTB     r3,r4
        0x0020974c:    2201        ."      MOVS     r2,#1
        0x0020974e:    31d8        .1      ADDS     r1,r1,#0xd8
        0x00209750:    4628        (F      MOV      r0,r5
        0x00209752:    f5fef984    ....    BL       log_buffer ; 0x7a5e
;;;465                passkey.enable_input = true;
        0x00209756:    4918        .I      LDR      r1,[pc,#96] ; [0x2097b8] = 0x20bcc4
        0x00209758:    2001        .       MOVS     r0,#1
        0x0020975a:    7148        Hq      STRB     r0,[r1,#5]
        0x0020975c:    bd7f        ..      POP      {r0-r6,pc}
;;;466            }
;;;467            break;
;;;468    
;;;469        case GAP_MSG_LE_BOND_OOB_INPUT:
;;;470            {
;;;471                uint8_t oob_data[GAP_OOB_LEN] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        0x0020975e:    9000        ..      STR      r0,[sp,#0]
        0x00209760:    9001        ..      STR      r0,[sp,#4]
        0x00209762:    9002        ..      STR      r0,[sp,#8]
        0x00209764:    9003        ..      STR      r0,[sp,#0xc]
        0x00209766:    b2e4        ..      UXTB     r4,r4
;;;472                conn_id = gap_msg.msg_data.gap_bond_oob_input.conn_id;
;;;473                APP_PRINT_INFO0("GAP_MSG_LE_BOND_OOB_INPUT");
        0x00209768:    2200        ."      MOVS     r2,#0
        0x0020976a:    4915        .I      LDR      r1,[pc,#84] ; [0x2097c0] = 0x8800a30
        0x0020976c:    4628        (F      MOV      r0,r5
        0x0020976e:    f5fef976    ..v.    BL       log_buffer ; 0x7a5e
;;;474                le_bond_set_param(GAP_PARAM_BOND_OOB_DATA, GAP_OOB_LEN, oob_data);
        0x00209772:    466a        jF      MOV      r2,sp
        0x00209774:    2110        .!      MOVS     r1,#0x10
        0x00209776:    f44f7004    O..p    MOV      r0,#0x210
        0x0020977a:    f642fd38    B.8.    BL       le_bond_set_param ; 0x4c1ee
;;;475                le_bond_oob_input_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x0020977e:    2101        .!      MOVS     r1,#1
        0x00209780:    4620         F      MOV      r0,r4
        0x00209782:    f642fe18    B...    BL       le_bond_oob_input_confirm ; 0x4c3b6
        0x00209786:    bd7f        ..      POP      {r0-r6,pc}
        0x00209788:    e7ff        ..      B        0x20978a ; app_handle_gap_msg + 284
;;;476            }
;;;477            break;
;;;478    
;;;479        default:
;;;480            APP_PRINT_ERROR1("app_handle_gap_msg: unknown subtype %d", p_gap_msg->subtype);
        0x0020978a:    b004        ..      ADD      sp,sp,#0x10
        0x0020978c:    490c        .I      LDR      r1,[pc,#48] ; [0x2097c0] = 0x8800a30
        0x0020978e:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00209792:    4804        .H      LDR      r0,[pc,#16] ; [0x2097a4] = 0x21103002
        0x00209794:    2201        ."      MOVS     r2,#1
        0x00209796:    3120         1      ADDS     r1,r1,#0x20
        0x00209798:    1e80        ..      SUBS     r0,r0,#2
        0x0020979a:    f5feb960    ..`.    B        log_buffer ; 0x7a5e
    $d
        0x0020979e:    0000        ..      DCW    0
        0x002097a0:    088006a4    ....    DCD    142608036
        0x002097a4:    21103002    .0.!    DCD    554708994
        0x002097a8:    088007a8    ....    DCD    142608296
        0x002097ac:    0020bc88    .. .    DCD    2145416
        0x002097b0:    08800928    (...    DCD    142608680
        0x002097b4:    08800594    ....    DCD    142607764
        0x002097b8:    0020bcc4    .. .    DCD    2145476
        0x002097bc:    0020bccc    .. .    DCD    2145484
        0x002097c0:    08800a30    0...    DCD    142608944
    $t
    app_handle_io_msg
;;; ..\..\..\src\app\keyboard\keyboard_app.c (81)
        0x002097c4:    e92d41f3    -..A    PUSH     {r0,r1,r4-r8,lr}
        0x002097c8:    f8bd0000    ....    LDRH     r0,[sp,#0]
;;; ..\..\..\src\app\keyboard\keyboard_app.c (81)
        0x002097cc:    b140        @.      CBZ      r0,0x2097e0 ; app_handle_io_msg + 28
;;;82         uint16_t msg_type = io_msg.type;
;;;83     
;;;84         switch (msg_type)
        0x002097ce:    2801        .(      CMP      r0,#1
        0x002097d0:    d00a        ..      BEQ      0x2097e8 ; app_handle_io_msg + 36
        0x002097d2:    280b        .(      CMP      r0,#0xb
        0x002097d4:    d103        ..      BNE      0x2097de ; app_handle_io_msg + 26
        0x002097d6:    e9dd0100    ....    LDRD     r0,r1,[sp,#0]
        0x002097da:    f000fe82    ....    BL       handle_pair_button_event ; 0x20a4e2
        0x002097de:    e744        D.      B        0x20966a ; app_handle_dev_state_evt + 154
;;;85         {
;;;86         case IO_MSG_TYPE_BT_STATUS:
;;;87             {
;;;88                 app_handle_gap_msg(&io_msg);
        0x002097e0:    4668        hF      MOV      r0,sp
        0x002097e2:    f7ffff44    ..D.    BL       app_handle_gap_msg ; 0x20966e
        0x002097e6:    e740        @.      B        0x20966a ; app_handle_dev_state_evt + 154
;;;89             }
;;;90             break;
;;;91         case IO_MSG_TYPE_GPIO:
;;;92             {
;;;93                 handle_pair_button_event(io_msg);
;;;94             }
;;;95             break;
;;;96         case IO_MSG_TYPE_KEYSCAN:
;;;97             {
;;;98                 if (io_msg.subtype == IO_MSG_KEYSCAN_RX_PKT)
        0x002097e8:    f8bd1002    ....    LDRH     r1,[sp,#2]
        0x002097ec:    4d9d        .M      LDR      r5,[pc,#628] ; [0x209a64] = 0x20bcc4
        0x002097ee:    489e        .H      LDR      r0,[pc,#632] ; [0x209a68] = 0x21103002
        0x002097f0:    4c9e        .L      LDR      r4,[pc,#632] ; [0x209a6c] = 0x20bc88
        0x002097f2:    2901        .)      CMP      r1,#1
        0x002097f4:    d00e        ..      BEQ      0x209814 ; app_handle_io_msg + 80
;;;99                 {
;;;100                    T_KEYSCAN_FIFIO_DATA *p_key_data = io_msg.u.buf;
;;;101                    APP_PRINT_INFO0("KeyScan MSG, Sub type Scan end.");
;;;102                    if (passkey.enable_input)
;;;103                    {
;;;104                        keyboard_handle_pair_event(p_key_data);
;;;105                    }
;;;106                    else if (report_cccd_enable)
;;;107                    {
;;;108                        keyboard_handle_press_event(p_key_data);
;;;109                    }
;;;110                    else
;;;111                    {
;;;112                        if (gap_conn_state == GAP_CONN_STATE_DISCONNECTED && \
;;;113                            gap_dev_state.gap_adv_state == GAP_ADV_STATE_IDLE)
;;;114                        {
;;;115                            APP_PRINT_INFO1("keyscan trigger adv, resolv_list_exist = %d", resolv_list_exist);
;;;116                            if (resolv_list_exist)
;;;117                            {
;;;118                                keyboard_start_adv(ADV_RECONECT);
;;;119                                start_adv_led_timer(true);
;;;120                            }
;;;121                        }
;;;122                    }
;;;123                }
;;;124                else if (io_msg.subtype == IO_MSG_KEYSCAN_ALLKEYRELEASE)
        0x002097f6:    2903        .)      CMP      r1,#3
        0x002097f8:    d1f1        ..      BNE      0x2097de ; app_handle_io_msg + 26
;;;125                {
;;;126                    APP_PRINT_INFO0("KeyScan MSG, Sub type All realse.");
        0x002097fa:    2200        ."      MOVS     r2,#0
        0x002097fc:    499c        .I      LDR      r1,[pc,#624] ; [0x209a70] = 0x88004b8
        0x002097fe:    f5fef92e    ....    BL       log_buffer ; 0x7a5e
;;;127                    if (passkey.enable_input == false && report_cccd_enable)
        0x00209802:    7968        hy      LDRB     r0,[r5,#5]
        0x00209804:    2800        .(      CMP      r0,#0
        0x00209806:    d1ea        ..      BNE      0x2097de ; app_handle_io_msg + 26
        0x00209808:    78e0        .x      LDRB     r0,[r4,#3]
        0x0020980a:    2800        .(      CMP      r0,#0
        0x0020980c:    d0e7        ..      BEQ      0x2097de ; app_handle_io_msg + 26
;;;128                    {
;;;129                        keyboard_handle_release_event();
        0x0020980e:    f000fd2a    ..*.    BL       keyboard_handle_release_event ; 0x20a266
;;;130                    }
;;;131                }
;;;132    
;;;133            }
;;;134            break;
;;;135        default:
;;;136            break;
;;;137        }
;;;138    }
        0x00209812:    e72a        *.      B        0x20966a ; app_handle_dev_state_evt + 154
        0x00209814:    4996        .I      LDR      r1,[pc,#600] ; [0x209a70] = 0x88004b8
        0x00209816:    2200        ."      MOVS     r2,#0
        0x00209818:    3954        T9      SUBS     r1,r1,#0x54
        0x0020981a:    4606        .F      MOV      r6,r0
        0x0020981c:    9f01        ..      LDR      r7,[sp,#4]
        0x0020981e:    f5fef91e    ....    BL       log_buffer ; 0x7a5e
        0x00209822:    7968        hy      LDRB     r0,[r5,#5]
        0x00209824:    b118        ..      CBZ      r0,0x20982e ; app_handle_io_msg + 106
        0x00209826:    4638        8F      MOV      r0,r7
        0x00209828:    f000fc04    ....    BL       keyboard_handle_pair_event ; 0x20a034
        0x0020982c:    e71d        ..      B        0x20966a ; app_handle_dev_state_evt + 154
        0x0020982e:    78e0        .x      LDRB     r0,[r4,#3]
        0x00209830:    b118        ..      CBZ      r0,0x20983a ; app_handle_io_msg + 118
        0x00209832:    4638        8F      MOV      r0,r7
        0x00209834:    f000fcc9    ....    BL       keyboard_handle_press_event ; 0x20a1ca
        0x00209838:    e717        ..      B        0x20966a ; app_handle_dev_state_evt + 154
        0x0020983a:    7860        `x      LDRB     r0,[r4,#1]
        0x0020983c:    2800        .(      CMP      r0,#0
        0x0020983e:    d1ce        ..      BNE      0x2097de ; app_handle_io_msg + 26
        0x00209840:    488a        .H      LDR      r0,[pc,#552] ; [0x209a6c] = 0x20bc88
        0x00209842:    7800        .x      LDRB     r0,[r0,#0]
        0x00209844:    f0100f0c    ....    TST      r0,#0xc
        0x00209848:    d1c9        ..      BNE      0x2097de ; app_handle_io_msg + 26
        0x0020984a:    4989        .I      LDR      r1,[pc,#548] ; [0x209a70] = 0x88004b8
        0x0020984c:    7923        #y      LDRB     r3,[r4,#4]
        0x0020984e:    2201        ."      MOVS     r2,#1
        0x00209850:    3930        09      SUBS     r1,r1,#0x30
        0x00209852:    4630        0F      MOV      r0,r6
        0x00209854:    f5fef903    ....    BL       log_buffer ; 0x7a5e
        0x00209858:    7920         y      LDRB     r0,[r4,#4]
        0x0020985a:    2800        .(      CMP      r0,#0
        0x0020985c:    d0bf        ..      BEQ      0x2097de ; app_handle_io_msg + 26
        0x0020985e:    2001        .       MOVS     r0,#1
        0x00209860:    f000ff4c    ..L.    BL       keyboard_start_adv ; 0x20a6fc
        0x00209864:    2001        .       MOVS     r0,#1
        0x00209866:    f000fed3    ....    BL       start_adv_led_timer ; 0x20a610
        0x0020986a:    e6fe        ..      B        0x20966a ; app_handle_dev_state_evt + 154
    app_gap_callback
;;;139    
;;;140    /**
;;;141     * @brief    Handle msg GAP_MSG_LE_DEV_STATE_CHANGE
;;;142     * @note     All the gap device state events are pre-handled in this function.
;;;143     *           Then the event handling function shall be called according to the new_state
;;;144     * @param[in] new_state  New gap device state
;;;145     * @param[in] cause GAP device state change cause
;;;146     * @return   void
;;;147     */
;;;148    void app_handle_dev_state_evt(T_GAP_DEV_STATE new_state, uint16_t cause)
;;;149    {
;;;150        APP_PRINT_INFO3("app_handle_dev_state_evt: init state %d, adv state %d, cause 0x%x",
;;;151                        new_state.gap_init_state, new_state.gap_adv_state, cause);
;;;152        if (gap_dev_state.gap_init_state != new_state.gap_init_state)
;;;153        {
;;;154            if (new_state.gap_init_state == GAP_INIT_STATE_STACK_READY)
;;;155            {
;;;156                APP_PRINT_INFO0("GAP stack ready");
;;;157                privacy_init(true);
;;;158            }
;;;159        }
;;;160    
;;;161        if (gap_dev_state.gap_adv_state != new_state.gap_adv_state)
;;;162        {
;;;163            if (new_state.gap_adv_state == GAP_ADV_STATE_IDLE)
;;;164            {
;;;165                if (new_state.gap_adv_sub_state == GAP_ADV_TO_IDLE_CAUSE_CONN)
;;;166                {
;;;167                    APP_PRINT_INFO0("GAP adv stoped: because connection created");
;;;168                }
;;;169                else
;;;170                {
;;;171                    APP_PRINT_INFO0("GAP adv stoped");
;;;172                    if (start_pair_adv)
;;;173                    {
;;;174                        start_pair_adv = false;
;;;175                        le_privacy_set_addr_resolution(false);
;;;176                        le_bond_clear_all_keys();//maybe move this to privacy_handle_le_privacy_resolution_status_info
;;;177                    }
;;;178                }
;;;179            }
;;;180            else if (new_state.gap_adv_state == GAP_ADV_STATE_ADVERTISING)
;;;181            {
;;;182                APP_PRINT_INFO0("GAP adv start");
;;;183            }
;;;184        }
;;;185    
;;;186        gap_dev_state = new_state;
;;;187    }
;;;188    
;;;189    /**
;;;190     * @brief    Handle msg GAP_MSG_LE_CONN_STATE_CHANGE
;;;191     * @note     All the gap conn state events are pre-handled in this function.
;;;192     *           Then the event handling function shall be called according to the new_state
;;;193     * @param[in] conn_id Connection ID
;;;194     * @param[in] new_state  New gap connection state
;;;195     * @param[in] disc_cause Use this cause when new_state is GAP_CONN_STATE_DISCONNECTED
;;;196     * @return   void
;;;197     */
;;;198    void app_handle_conn_state_evt(uint8_t conn_id, T_GAP_CONN_STATE new_state, uint16_t disc_cause)
;;;199    {
;;;200        APP_PRINT_INFO4("app_handle_conn_state_evt: conn_id %d old_state %d new_state %d, disc_cause 0x%x",
;;;201                        conn_id, gap_conn_state, new_state, disc_cause);
;;;202        switch (new_state)
;;;203        {
;;;204        case GAP_CONN_STATE_DISCONNECTED:
;;;205            {
;;;206                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
;;;207                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
;;;208                {
;;;209                    APP_PRINT_ERROR1("app_handle_conn_state_evt: connection lost cause 0x%x", disc_cause);
;;;210                }
;;;211    
;;;212                stop_con_update_timer();
;;;213                report_cccd_enable = false;
;;;214                passkey.enable_input = false;
;;;215    
;;;216                if (switch_into_ota_pending)
;;;217                {
;;;218                    switch_into_ota_pending = false;
;;;219                    dfu_switch_to_ota_mode();
;;;220                    WDG_SystemReset(RESET_ALL_EXCEPT_AON, DFU_SWITCH_TO_OTA);
;;;221                }
;;;222    
;;;223                if (resolv_list_exist == false)
;;;224                {
;;;225                    start_pair_adv = true;
;;;226                }
;;;227    
;;;228                if (start_pair_adv)
;;;229                {
;;;230                    APP_PRINT_INFO0("disconnect and start adv");
;;;231                    start_pair_adv = false;
;;;232                    keyboard_start_adv(ADV_UNDIRECT_PAIRING);
;;;233                    start_adv_led_timer(false);
;;;234                }
;;;235    
;;;236            }
;;;237            break;
;;;238    
;;;239        case GAP_CONN_STATE_CONNECTED:
;;;240            {
;;;241                keyboard_con_id = conn_id;
;;;242                uint16_t conn_interval;
;;;243                uint16_t conn_latency;
;;;244                uint16_t conn_supervision_timeout;
;;;245    
;;;246                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;247                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_latency, conn_id);
;;;248                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;249                APP_PRINT_INFO3("GAP_CONN_STATE_CONNECTED: conn_interval 0x%x, conn_latency 0x%x, conn_supervision_timeout 0x%x",
;;;250                                conn_interval, conn_latency, conn_supervision_timeout);
;;;251    
;;;252                stop_adv_led_timer();
;;;253                start_con_update_timer();
;;;254            }
;;;255            break;
;;;256    
;;;257        default:
;;;258            break;
;;;259        }
;;;260        gap_conn_state = new_state;
;;;261    }
;;;262    
;;;263    /**
;;;264     * @brief    Handle msg GAP_MSG_LE_AUTHEN_STATE_CHANGE
;;;265     * @note     All the gap authentication state events are pre-handled in this function.
;;;266     *           Then the event handling function shall be called according to the new_state
;;;267     * @param[in] conn_id Connection ID
;;;268     * @param[in] new_state  New authentication state
;;;269     * @param[in] cause Use this cause when new_state is GAP_AUTHEN_STATE_COMPLETE
;;;270     * @return   void
;;;271     */
;;;272    void app_handle_authen_state_evt(uint8_t conn_id, uint8_t new_state, uint16_t cause)
;;;273    {
;;;274        APP_PRINT_INFO2("app_handle_authen_state_evt:conn_id %d, cause 0x%x", conn_id, cause);
;;;275    
;;;276        switch (new_state)
;;;277        {
;;;278        case GAP_AUTHEN_STATE_STARTED:
;;;279            {
;;;280                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
;;;281            }
;;;282            break;
;;;283    
;;;284        case GAP_AUTHEN_STATE_COMPLETE:
;;;285            {
;;;286                if (cause == GAP_SUCCESS)
;;;287                {
;;;288                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
;;;289                    if (resolv_list_exist == false)
;;;290                    {
;;;291                        T_LE_KEY_ENTRY *p_entry;
;;;292                        p_entry = le_get_high_priority_bond();
;;;293                        if ((p_entry != NULL) && (p_entry->is_used))
;;;294                        {
;;;295                            privacy_add_device(p_entry);
;;;296                        }
;;;297                    }
;;;298                }
;;;299                else
;;;300                {
;;;301                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;302                }
;;;303            }
;;;304            break;
;;;305    
;;;306        default:
;;;307            {
;;;308                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;309            }
;;;310            break;
;;;311        }
;;;312    }
;;;313    
;;;314    /**
;;;315     * @brief    Handle msg GAP_MSG_LE_CONN_MTU_INFO
;;;316     * @note     This msg is used to inform APP that exchange mtu procedure is completed.
;;;317     * @param[in] conn_id Connection ID
;;;318     * @param[in] mtu_size  New mtu size
;;;319     * @return   void
;;;320     */
;;;321    void app_handle_conn_mtu_info_evt(uint8_t conn_id, uint16_t mtu_size)
;;;322    {
;;;323        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
;;;324    }
;;;325    
;;;326    /**
;;;327     * @brief    Handle msg GAP_MSG_LE_CONN_PARAM_UPDATE
;;;328     * @note     All the connection parameter update change  events are pre-handled in this function.
;;;329     * @param[in] conn_id Connection ID
;;;330     * @param[in] status  New update state
;;;331     * @param[in] cause Use this cause when status is GAP_CONN_PARAM_UPDATE_STATUS_FAIL
;;;332     * @return   void
;;;333     */
;;;334    void app_handle_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;335    {
;;;336        switch (status)
;;;337        {
;;;338        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;339            {
;;;340                uint16_t conn_interval;
;;;341                uint16_t conn_slave_latency;
;;;342                uint16_t conn_supervision_timeout;
;;;343    
;;;344                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;345                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
;;;346                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;347                APP_PRINT_INFO3("app_handle_conn_param_update_evt update success:conn_interval 0x%x, conn_slave_latency 0x%x, conn_supervision_timeout 0x%x",
;;;348                                conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;349                if (((conn_slave_latency + 1) * conn_interval < 16) || (conn_slave_latency == 0))
;;;350                {
;;;351                    APP_PRINT_INFO0("reupdate the connection parameter");
;;;352                    start_con_update_timer();
;;;353                }
;;;354                else
;;;355                {
;;;356                    APP_PRINT_INFO0("stop update the connection parameter");
;;;357                    stop_con_update_timer();
;;;358                }
;;;359            }
;;;360            break;
;;;361    
;;;362        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;363            {
;;;364                APP_PRINT_ERROR1("app_handle_conn_param_update_evt update failed: cause 0x%x", cause);
;;;365            }
;;;366            break;
;;;367    
;;;368        case GAP_CONN_PARAM_UPDATE_STATUS_PENDING:
;;;369            {
;;;370                APP_PRINT_INFO0("app_handle_conn_param_update_evt update pending.");
;;;371            }
;;;372            break;
;;;373    
;;;374        default:
;;;375            break;
;;;376        }
;;;377    }
;;;378    
;;;379    /**
;;;380     * @brief    All the BT GAP MSG are pre-handled in this function.
;;;381     * @note     Then the event handling function shall be called according to the
;;;382     *           subtype of T_IO_MSG
;;;383     * @param[in] p_gap_msg Pointer to GAP msg
;;;384     * @return   void
;;;385     */
;;;386    void app_handle_gap_msg(T_IO_MSG *p_gap_msg)
;;;387    {
;;;388        T_LE_GAP_MSG gap_msg;
;;;389        uint8_t conn_id;
;;;390        memcpy(&gap_msg, &p_gap_msg->u.param, sizeof(p_gap_msg->u.param));
;;;391    
;;;392        APP_PRINT_TRACE1("app_handle_gap_msg: subtype %d", p_gap_msg->subtype);
;;;393        switch (p_gap_msg->subtype)
;;;394        {
;;;395        case GAP_MSG_LE_DEV_STATE_CHANGE:
;;;396            {
;;;397                app_handle_dev_state_evt(gap_msg.msg_data.gap_dev_state_change.new_state,
;;;398                                         gap_msg.msg_data.gap_dev_state_change.cause);
;;;399            }
;;;400            break;
;;;401    
;;;402        case GAP_MSG_LE_CONN_STATE_CHANGE:
;;;403            {
;;;404                app_handle_conn_state_evt(gap_msg.msg_data.gap_conn_state_change.conn_id,
;;;405                                          (T_GAP_CONN_STATE)gap_msg.msg_data.gap_conn_state_change.new_state,
;;;406                                          gap_msg.msg_data.gap_conn_state_change.disc_cause);
;;;407            }
;;;408            break;
;;;409    
;;;410        case GAP_MSG_LE_CONN_MTU_INFO:
;;;411            {
;;;412                app_handle_conn_mtu_info_evt(gap_msg.msg_data.gap_conn_mtu_info.conn_id,
;;;413                                             gap_msg.msg_data.gap_conn_mtu_info.mtu_size);
;;;414            }
;;;415            break;
;;;416    
;;;417        case GAP_MSG_LE_CONN_PARAM_UPDATE:
;;;418            {
;;;419                app_handle_conn_param_update_evt(gap_msg.msg_data.gap_conn_param_update.conn_id,
;;;420                                                 gap_msg.msg_data.gap_conn_param_update.status,
;;;421                                                 gap_msg.msg_data.gap_conn_param_update.cause);
;;;422            }
;;;423            break;
;;;424    
;;;425        case GAP_MSG_LE_AUTHEN_STATE_CHANGE:
;;;426            {
;;;427                app_handle_authen_state_evt(gap_msg.msg_data.gap_authen_state.conn_id,
;;;428                                            gap_msg.msg_data.gap_authen_state.new_state,
;;;429                                            gap_msg.msg_data.gap_authen_state.status);
;;;430            }
;;;431            break;
;;;432    
;;;433        case GAP_MSG_LE_BOND_JUST_WORK:
;;;434            {
;;;435                conn_id = gap_msg.msg_data.gap_bond_just_work_conf.conn_id;
;;;436                le_bond_just_work_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;437                APP_PRINT_INFO0("GAP_MSG_LE_BOND_JUST_WORK");
;;;438            }
;;;439            break;
;;;440    
;;;441        case GAP_MSG_LE_BOND_PASSKEY_DISPLAY:
;;;442            {
;;;443                uint32_t display_value = 0;
;;;444                conn_id = gap_msg.msg_data.gap_bond_passkey_display.conn_id;
;;;445                le_bond_get_display_key(conn_id, &display_value);
;;;446                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_DISPLAY:passkey %d", display_value);
;;;447                le_bond_passkey_display_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;448            }
;;;449            break;
;;;450    
;;;451        case GAP_MSG_LE_BOND_USER_CONFIRMATION:
;;;452            {
;;;453                uint32_t display_value = 0;
;;;454                conn_id = gap_msg.msg_data.gap_bond_user_conf.conn_id;
;;;455                le_bond_get_display_key(conn_id, &display_value);
;;;456                APP_PRINT_INFO1("GAP_MSG_LE_BOND_USER_CONFIRMATION: passkey %d", display_value);
;;;457                le_bond_user_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;458            }
;;;459            break;
;;;460    
;;;461        case GAP_MSG_LE_BOND_PASSKEY_INPUT:
;;;462            {
;;;463                conn_id = gap_msg.msg_data.gap_bond_passkey_input.conn_id;
;;;464                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d", conn_id);
;;;465                passkey.enable_input = true;
;;;466            }
;;;467            break;
;;;468    
;;;469        case GAP_MSG_LE_BOND_OOB_INPUT:
;;;470            {
;;;471                uint8_t oob_data[GAP_OOB_LEN] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
;;;472                conn_id = gap_msg.msg_data.gap_bond_oob_input.conn_id;
;;;473                APP_PRINT_INFO0("GAP_MSG_LE_BOND_OOB_INPUT");
;;;474                le_bond_set_param(GAP_PARAM_BOND_OOB_DATA, GAP_OOB_LEN, oob_data);
;;;475                le_bond_oob_input_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;476            }
;;;477            break;
;;;478    
;;;479        default:
;;;480            APP_PRINT_ERROR1("app_handle_gap_msg: unknown subtype %d", p_gap_msg->subtype);
;;;481            break;
;;;482        }
;;;483    }
;;;484    /** @} */ /* End of group PERIPH_GAP_MSG */
;;;485    
;;;486    /** @defgroup  PERIPH_GAP_CALLBACK GAP Callback Event Handler
;;;487        * @brief Handle GAP callback event
;;;488        * @{
;;;489        */
;;;490    /**
;;;491      * @brief Callback for gap le to notify app
;;;492      * @param[in] cb_type callback msy type @ref GAP_LE_MSG_Types.
;;;493      * @param[in] p_cb_data point to callback data @ref T_LE_CB_DATA.
;;;494      * @retval result @ref T_APP_RESULT
;;;495      */
;;;496    T_APP_RESULT app_gap_callback(uint8_t cb_type, void *p_cb_data)
;;;497    {
        0x0020986c:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x00209870:    2600        .&      MOVS     r6,#0
        0x00209872:    4f7d        }O      LDR      r7,[pc,#500] ; [0x209a68] = 0x21103002
;;; ..\..\..\src\app\keyboard\keyboard_app.c (497)
        0x00209874:    4605        .F      MOV      r5,r0
        0x00209876:    460c        .F      MOV      r4,r1
        0x00209878:    2801        .(      CMP      r0,#1
        0x0020987a:    d010        ..      BEQ      0x20989e ; app_gap_callback + 50
;;;498        T_APP_RESULT result = APP_RESULT_SUCCESS;
;;;499        T_LE_CB_DATA *p_data = (T_LE_CB_DATA *)p_cb_data;
;;;500    
;;;501        switch (cb_type)
        0x0020987c:    2d14        .-      CMP      r5,#0x14
        0x0020987e:    d002        ..      BEQ      0x209886 ; app_gap_callback + 26
        0x00209880:    2d20         -      CMP      r5,#0x20
        0x00209882:    d147        G.      BNE      0x209914 ; app_gap_callback + 168
        0x00209884:    e039        9.      B        0x2098fa ; app_gap_callback + 142
;;;502        {
;;;503        case GAP_MSG_LE_DATA_LEN_CHANGE_INFO:
;;;504            APP_PRINT_INFO3("GAP_MSG_LE_DATA_LEN_CHANGE_INFO: conn_id %d, tx octets 0x%x, max_tx_time 0x%x",
        0x00209886:    6808        .h      LDR      r0,[r1,#0]
        0x00209888:    8882        ..      LDRH     r2,[r0,#4]
        0x0020988a:    8841        A.      LDRH     r1,[r0,#2]
        0x0020988c:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x00209890:    7803        .x      LDRB     r3,[r0,#0]
        0x00209892:    2203        ."      MOVS     r2,#3
        0x00209894:    4977        wI      LDR      r1,[pc,#476] ; [0x209a74] = 0x8800a7c
        0x00209896:    4638        8F      MOV      r0,r7
        0x00209898:    f5fef8e1    ....    BL       log_buffer ; 0x7a5e
;;;505                            p_data->p_le_data_len_change_info->conn_id,
;;;506                            p_data->p_le_data_len_change_info->max_tx_octets,
;;;507                            p_data->p_le_data_len_change_info->max_tx_time);
;;;508            break;
        0x0020989c:    e042        B.      B        0x209924 ; app_gap_callback + 184
;;;509    
;;;510        case GAP_MSG_LE_MODIFY_WHITE_LIST:
;;;511            APP_PRINT_INFO2("GAP_MSG_LE_MODIFY_WHITE_LIST: operation %d, cause 0x%x",
        0x0020989e:    6820         h      LDR      r0,[r4,#0]
        0x002098a0:    2202        ."      MOVS     r2,#2
        0x002098a2:    8841        A.      LDRH     r1,[r0,#2]
        0x002098a4:    9100        ..      STR      r1,[sp,#0]
        0x002098a6:    4973        sI      LDR      r1,[pc,#460] ; [0x209a74] = 0x8800a7c
        0x002098a8:    7803        .x      LDRB     r3,[r0,#0]
        0x002098aa:    3154        T1      ADDS     r1,r1,#0x54
        0x002098ac:    4638        8F      MOV      r0,r7
        0x002098ae:    f5fef8d6    ....    BL       log_buffer ; 0x7a5e
;;;512                            p_data->p_le_modify_white_list_rsp->operation,
;;;513                            p_data->p_le_modify_white_list_rsp->cause);
;;;514            if (p_data->p_le_modify_white_list_rsp->operation == GAP_WHITE_LIST_OP_CLEAR)
        0x002098b2:    6820         h      LDR      r0,[r4,#0]
        0x002098b4:    7800        .x      LDRB     r0,[r0,#0]
        0x002098b6:    b9f8        ..      CBNZ     r0,0x2098f8 ; app_gap_callback + 140
;;;515            {
;;;516                if (gap_conn_state == GAP_CONN_STATE_DISCONNECTED)
        0x002098b8:    496c        lI      LDR      r1,[pc,#432] ; [0x209a6c] = 0x20bc88
        0x002098ba:    7848        Hx      LDRB     r0,[r1,#1]
        0x002098bc:    b110        ..      CBZ      r0,0x2098c4 ; app_gap_callback + 88
        0x002098be:    2802        .(      CMP      r0,#2
        0x002098c0:    d014        ..      BEQ      0x2098ec ; app_gap_callback + 128
        0x002098c2:    e02f        /.      B        0x209924 ; app_gap_callback + 184
;;;517                {
;;;518                    if (gap_dev_state.gap_adv_state == GAP_ADV_STATE_IDLE)
        0x002098c4:    4869        iH      LDR      r0,[pc,#420] ; [0x209a6c] = 0x20bc88
        0x002098c6:    7800        .x      LDRB     r0,[r0,#0]
        0x002098c8:    f0100f0c    ....    TST      r0,#0xc
        0x002098cc:    d004        ..      BEQ      0x2098d8 ; app_gap_callback + 108
        0x002098ce:    f3c00081    ....    UBFX     r0,r0,#2,#2
        0x002098d2:    2802        .(      CMP      r0,#2
        0x002098d4:    d007        ..      BEQ      0x2098e6 ; app_gap_callback + 122
        0x002098d6:    e025        %.      B        0x209924 ; app_gap_callback + 184
;;;519                    {
;;;520                        keyboard_start_adv(ADV_UNDIRECT_PAIRING);
        0x002098d8:    2002        .       MOVS     r0,#2
        0x002098da:    f000ff0f    ....    BL       keyboard_start_adv ; 0x20a6fc
;;;521                        start_adv_led_timer(false);
        0x002098de:    2000        .       MOVS     r0,#0
        0x002098e0:    f000fe96    ....    BL       start_adv_led_timer ; 0x20a610
        0x002098e4:    e01e        ..      B        0x209924 ; app_gap_callback + 184
;;;522                    }
;;;523                    else if (gap_dev_state.gap_adv_state == GAP_ADV_STATE_ADVERTISING)
;;;524                    {
;;;525                        reset_adv_count();
        0x002098e6:    f000fec1    ....    BL       reset_adv_count ; 0x20a66c
        0x002098ea:    e01b        ..      B        0x209924 ; app_gap_callback + 184
;;;526                    }
;;;527                }
;;;528                else if (gap_conn_state == GAP_CONN_STATE_CONNECTED)
;;;529                {
;;;530                    le_disconnect(keyboard_con_id);
        0x002098ec:    7a08        .z      LDRB     r0,[r1,#8]
        0x002098ee:    f644f999    D...    BL       le_disconnect ; 0x4dc24
;;;531                    start_pair_adv = true;
        0x002098f2:    4961        aI      LDR      r1,[pc,#388] ; [0x209a78] = 0x20bccc
        0x002098f4:    2001        .       MOVS     r0,#1
        0x002098f6:    7008        .p      STRB     r0,[r1,#0]
        0x002098f8:    e014        ..      B        0x209924 ; app_gap_callback + 184
;;;532                }
;;;533            }
;;;534            break;
;;;535    
;;;536        case GAP_MSG_LE_BOND_MODIFY_INFO:
;;;537            APP_PRINT_INFO1("GAP_MSG_LE_BOND_MODIFY_INFO: type 0x%x",
        0x002098fa:    6820         h      LDR      r0,[r4,#0]
        0x002098fc:    495d        ]I      LDR      r1,[pc,#372] ; [0x209a74] = 0x8800a7c
        0x002098fe:    2201        ."      MOVS     r2,#1
        0x00209900:    7803        .x      LDRB     r3,[r0,#0]
        0x00209902:    3190        .1      ADDS     r1,r1,#0x90
        0x00209904:    4638        8F      MOV      r0,r7
        0x00209906:    f5fef8aa    ....    BL       log_buffer ; 0x7a5e
;;;538                            p_data->p_le_bond_modify_info->type);
;;;539            privacy_handle_bond_modify_msg(p_data->p_le_bond_modify_info->type,
        0x0020990a:    6820         h      LDR      r0,[r4,#0]
        0x0020990c:    6841        Ah      LDR      r1,[r0,#4]
        0x0020990e:    7800        .x      LDRB     r0,[r0,#0]
        0x00209910:    f001f8e3    ....    BL       privacy_handle_bond_modify_msg ; 0x20aada
;;;540                                           p_data->p_le_bond_modify_info->p_entry);
;;;541        default:
;;;542            APP_PRINT_ERROR1("app_gap_callback: unhandled cb_type 0x%x", cb_type);
        0x00209914:    4957        WI      LDR      r1,[pc,#348] ; [0x209a74] = 0x8800a7c
        0x00209916:    4854        TH      LDR      r0,[pc,#336] ; [0x209a68] = 0x21103002
        0x00209918:    462b        +F      MOV      r3,r5
        0x0020991a:    2201        ."      MOVS     r2,#1
        0x0020991c:    31bc        .1      ADDS     r1,r1,#0xbc
        0x0020991e:    1e80        ..      SUBS     r0,r0,#2
        0x00209920:    f5fef89d    ....    BL       log_buffer ; 0x7a5e
;;;543            break;
;;;544        }
;;;545        return result;
        0x00209924:    4630        0F      MOV      r0,r6
;;;546    }
        0x00209926:    e6a0        ..      B        0x20966a ; app_handle_dev_state_evt + 154
    app_profile_callback
;;;547    /** @} */ /* End of group PERIPH_GAP_CALLBACK */
;;;548    
;;;549    /** @defgroup  PERIPH_SEVER_CALLBACK Profile Server Callback Event Handler
;;;550        * @brief Handle profile server callback event
;;;551        * @{
;;;552        */
;;;553    /**
;;;554        * @brief    All the BT Profile service callback events are handled in this function
;;;555        * @note     Then the event handling function shall be called according to the
;;;556        *           service_id
;;;557        * @param    service_id  Profile service ID
;;;558        * @param    p_data      Pointer to callback data
;;;559        * @return   T_APP_RESULT, which indicates the function call is successful or not
;;;560        * @retval   APP_RESULT_SUCCESS  Function run successfully
;;;561        * @retval   others              Function run failed, and return number indicates the reason
;;;562        */
;;;563    T_APP_RESULT app_profile_callback(T_SERVER_ID service_id, void *p_data)
;;;564    {
        0x00209928:    e92d41ff    -..A    PUSH     {r0-r8,lr}
        0x0020992c:    4602        .F      MOV      r2,r0
        0x0020992e:    2700        .'      MOVS     r7,#0
        0x00209930:    484d        MH      LDR      r0,[pc,#308] ; [0x209a68] = 0x21103002
        0x00209932:    2aff        .*      CMP      r2,#0xff
;;; ..\..\..\src\app\keyboard\keyboard_app.c (564)
        0x00209934:    d00b        ..      BEQ      0x20994e ; app_profile_callback + 38
        0x00209936:    4d4d        MM      LDR      r5,[pc,#308] ; [0x209a6c] = 0x20bc88
        0x00209938:    2601        .&      MOVS     r6,#1
        0x0020993a:    796b        ky      LDRB     r3,[r5,#5]
        0x0020993c:    429a        .B      CMP      r2,r3
        0x0020993e:    d150        P.      BNE      0x2099e2 ; app_profile_callback + 186
        0x00209940:    460c        .F      MOV      r4,r1
        0x00209942:    7849        Ix      LDRB     r1,[r1,#1]
        0x00209944:    2901        .)      CMP      r1,#1
        0x00209946:    d026        &.      BEQ      0x209996 ; app_profile_callback + 110
        0x00209948:    2903        .)      CMP      r1,#3
        0x0020994a:    d12b        +.      BNE      0x2099a4 ; app_profile_callback + 124
        0x0020994c:    e02d        -.      B        0x2099aa ; app_profile_callback + 130
;;;565        T_APP_RESULT app_result = APP_RESULT_SUCCESS;
;;;566        if (service_id == SERVICE_PROFILE_GENERAL_ID)
;;;567        {
;;;568            T_SERVER_APP_CB_DATA *p_param = (T_SERVER_APP_CB_DATA *)p_data;
        0x0020994e:    460c        .F      MOV      r4,r1
;;;569            switch (p_param->eventId)
        0x00209950:    7809        .x      LDRB     r1,[r1,#0]
        0x00209952:    b111        ..      CBZ      r1,0x20995a ; app_profile_callback + 50
        0x00209954:    2901        .)      CMP      r1,#1
        0x00209956:    d125        %.      BNE      0x2099a4 ; app_profile_callback + 124
        0x00209958:    e004        ..      B        0x209964 ; app_profile_callback + 60
;;;570            {
;;;571            case PROFILE_EVT_SRV_REG_COMPLETE:// srv register result event.
;;;572                APP_PRINT_INFO1("PROFILE_EVT_SRV_REG_COMPLETE: result %d",
        0x0020995a:    4946        FI      LDR      r1,[pc,#280] ; [0x209a74] = 0x8800a7c
        0x0020995c:    2201        ."      MOVS     r2,#1
        0x0020995e:    78a3        .x      LDRB     r3,[r4,#2]
        0x00209960:    31e8        .1      ADDS     r1,r1,#0xe8
;;;573                                p_param->event_data.service_reg_result);
;;;574                break;
        0x00209962:    e02c        ,.      B        0x2099be ; app_profile_callback + 150
;;;575    
;;;576            case PROFILE_EVT_SEND_DATA_COMPLETE:
;;;577                APP_PRINT_INFO5("PROFILE_EVT_SEND_DATA_COMPLETE: conn_id %d, cause 0x%x, service_id %d, attrib_idx 0x%x, credits %d",
        0x00209964:    8921        !.      LDRH     r1,[r4,#8]
        0x00209966:    8865        e.      LDRH     r5,[r4,#2]
        0x00209968:    88e3        ..      LDRH     r3,[r4,#6]
        0x0020996a:    7962        by      LDRB     r2,[r4,#5]
        0x0020996c:    e88d002e    ....    STM      sp,{r1-r3,r5}
        0x00209970:    7923        #y      LDRB     r3,[r4,#4]
        0x00209972:    2205        ."      MOVS     r2,#5
        0x00209974:    4941        AI      LDR      r1,[pc,#260] ; [0x209a7c] = 0x8800b90
        0x00209976:    4605        .F      MOV      r5,r0
        0x00209978:    f5fef871    ..q.    BL       log_buffer ; 0x7a5e
;;;578                                p_param->event_data.send_data_result.conn_id,
;;;579                                p_param->event_data.send_data_result.cause,
;;;580                                p_param->event_data.send_data_result.service_id,
;;;581                                p_param->event_data.send_data_result.attrib_idx,
;;;582                                p_param->event_data.send_data_result.credits);
;;;583                if (p_param->event_data.send_data_result.cause == GAP_SUCCESS)
        0x0020997c:    8920         .      LDRH     r0,[r4,#8]
        0x0020997e:    f04f0200    O...    MOV      r2,#0
        0x00209982:    b120         .      CBZ      r0,0x20998e ; app_profile_callback + 102
        0x00209984:    493d        =I      LDR      r1,[pc,#244] ; [0x209a7c] = 0x8800b90
        0x00209986:    4838        8H      LDR      r0,[pc,#224] ; [0x209a68] = 0x21103002
        0x00209988:    3194        .1      ADDS     r1,r1,#0x94
        0x0020998a:    1e80        ..      SUBS     r0,r0,#2
        0x0020998c:    e03e        >.      B        0x209a0c ; app_profile_callback + 228
;;;584                {
;;;585                    APP_PRINT_INFO0("PROFILE_EVT_SEND_DATA_COMPLETE success");
        0x0020998e:    493b        ;I      LDR      r1,[pc,#236] ; [0x209a7c] = 0x8800b90
        0x00209990:    4628        (F      MOV      r0,r5
        0x00209992:    3168        h1      ADDS     r1,r1,#0x68
        0x00209994:    e03a        :.      B        0x209a0c ; app_profile_callback + 228
;;;586                }
;;;587                else
;;;588                {
;;;589                    APP_PRINT_ERROR0("PROFILE_EVT_SEND_DATA_COMPLETE failed");
;;;590                }
;;;591                break;
;;;592    
;;;593            default:
;;;594                break;
;;;595            }
;;;596        }
;;;597        else  if (service_id == hid_srv_id)
;;;598        {
;;;599            T_HID_CALLBACK_DATA *p_hid_cb_data = (T_HID_CALLBACK_DATA *)p_data;
;;;600    
;;;601            switch (p_hid_cb_data->msg_type)
;;;602            {
;;;603            case SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION:
;;;604                {
;;;605                    switch (p_hid_cb_data->msg_data.not_ind_data.index)
        0x00209996:    7d20         }      LDRB     r0,[r4,#0x14]
        0x00209998:    2805        .(      CMP      r0,#5
        0x0020999a:    d160        `.      BNE      0x209a5e ; app_profile_callback + 310
;;;606                    {
;;;607                    case GATT_SVC_HID_REPORT_INPUT_CCCD_INDEX:
;;;608                        {
;;;609                            if (p_hid_cb_data->msg_data.not_ind_data.value == NOTIFY_ENABLE)
        0x0020999c:    7d60        `}      LDRB     r0,[r4,#0x15]
        0x0020999e:    b110        ..      CBZ      r0,0x2099a6 ; app_profile_callback + 126
        0x002099a0:    2000        .       MOVS     r0,#0
        0x002099a2:    70e8        .p      STRB     r0,[r5,#3]
        0x002099a4:    e05b        [.      B        0x209a5e ; app_profile_callback + 310
;;;610                            {
;;;611                                report_cccd_enable = true;
        0x002099a6:    70ee        .p      STRB     r6,[r5,#3]
        0x002099a8:    e059        Y.      B        0x209a5e ; app_profile_callback + 310
;;;612                            }
;;;613                            else
;;;614                            {
;;;615                                report_cccd_enable = false;
;;;616                            }
;;;617                        }
;;;618                        break;
;;;619                    case GATT_SVC_HID_BOOT_KB_IN_REPORT_CCCD_INDEX:
;;;620                        {
;;;621    
;;;622                        }
;;;623                        break;
;;;624                    default:
;;;625                        break;
;;;626                    }
;;;627                }
;;;628                break;
;;;629            case SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE:
;;;630                {
;;;631                    switch (p_hid_cb_data->msg_data.read_value_index)
        0x002099aa:    7921        !y      LDRB     r1,[r4,#4]
        0x002099ac:    2902        .)      CMP      r1,#2
        0x002099ae:    d002        ..      BEQ      0x2099b6 ; app_profile_callback + 142
        0x002099b0:    2908        .)      CMP      r1,#8
        0x002099b2:    d154        T.      BNE      0x209a5e ; app_profile_callback + 310
        0x002099b4:    e006        ..      B        0x2099c4 ; app_profile_callback + 156
;;;632                    {
;;;633                    case GATT_SVC_HID_PROTOCOL_MODE_INDEX:
;;;634                        {
;;;635                            APP_PRINT_INFO1("HID_WRITE_PROTOCOL MODE %d\n",
        0x002099b6:    4931        1I      LDR      r1,[pc,#196] ; [0x209a7c] = 0x8800b90
        0x002099b8:    7b23        #{      LDRB     r3,[r4,#0xc]
        0x002099ba:    2201        ."      MOVS     r2,#1
        0x002099bc:    31c0        .1      ADDS     r1,r1,#0xc0
        0x002099be:    f5fef84e    ..N.    BL       log_buffer ; 0x7a5e
        0x002099c2:    e04c        L.      B        0x209a5e ; app_profile_callback + 310
;;;636                                            p_hid_cb_data->msg_data.write_msg.write_parameter.protocol_mode);
;;;637                            break;
;;;638                        }
;;;639                    case GATT_SVC_HID_REPORT_OUTPUT_INDEX:
;;;640                        {
;;;641                            //callback data definition need to modify.
;;;642                            APP_PRINT_INFO1("HID_OUTPUT value %d\n", p_hid_cb_data->msg_data.write_msg.write_parameter.output);
        0x002099c4:    492d        -I      LDR      r1,[pc,#180] ; [0x209a7c] = 0x8800b90
        0x002099c6:    7b23        #{      LDRB     r3,[r4,#0xc]
        0x002099c8:    2201        ."      MOVS     r2,#1
        0x002099ca:    31e0        .1      ADDS     r1,r1,#0xe0
        0x002099cc:    f5fef847    ..G.    BL       log_buffer ; 0x7a5e
;;;643                            if (p_hid_cb_data->msg_data.write_msg.write_parameter.output & 0x02)
        0x002099d0:    7b20         {      LDRB     r0,[r4,#0xc]
        0x002099d2:    0780        ..      LSLS     r0,r0,#30
        0x002099d4:    d502        ..      BPL      0x2099dc ; app_profile_callback + 180
;;;644                            {
;;;645                                capslock_led_on();
        0x002099d6:    f000fe6c    ..l.    BL       capslock_led_on ; 0x20a6b2
        0x002099da:    e040        @.      B        0x209a5e ; app_profile_callback + 310
;;;646                            }
;;;647                            else
;;;648                            {
;;;649                                capslock_led_off();
        0x002099dc:    f000fe74    ..t.    BL       capslock_led_off ; 0x20a6c8
        0x002099e0:    e03d        =.      B        0x209a5e ; app_profile_callback + 310
;;;650                            }
;;;651                            break;
;;;652                        }
;;;653                    default:
;;;654                        break;
;;;655                    }
;;;656                }
;;;657                break;
;;;658            default:
;;;659                break;
;;;660            }
;;;661        }
;;;662        else if (service_id == bas_srv_id)
        0x002099e2:    79ab        .y      LDRB     r3,[r5,#6]
        0x002099e4:    429a        .B      CMP      r2,r3
        0x002099e6:    d125        %.      BNE      0x209a34 ; app_profile_callback + 268
;;;663        {
;;;664            T_BAS_CALLBACK_DATA *p_bas_cb_data = (T_BAS_CALLBACK_DATA *)p_data;
;;;665            switch (p_bas_cb_data->msg_type)
        0x002099e8:    784a        Jx      LDRB     r2,[r1,#1]
        0x002099ea:    2a01        .*      CMP      r2,#1
        0x002099ec:    d002        ..      BEQ      0x2099f4 ; app_profile_callback + 204
        0x002099ee:    2a02        .*      CMP      r2,#2
        0x002099f0:    d135        5.      BNE      0x209a5e ; app_profile_callback + 310
        0x002099f2:    e00e        ..      B        0x209a12 ; app_profile_callback + 234
;;;666            {
;;;667            case SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION:
;;;668                {
;;;669                    switch (p_bas_cb_data->msg_data.notification_indification_index)
        0x002099f4:    7889        .x      LDRB     r1,[r1,#2]
        0x002099f6:    2901        .)      CMP      r1,#1
        0x002099f8:    d002        ..      BEQ      0x209a00 ; app_profile_callback + 216
        0x002099fa:    2902        .)      CMP      r1,#2
        0x002099fc:    d12f        /.      BNE      0x209a5e ; app_profile_callback + 310
        0x002099fe:    e003        ..      B        0x209a08 ; app_profile_callback + 224
;;;670                    {
;;;671                    case BAS_NOTIFY_BATTERY_LEVEL_ENABLE:
;;;672                        {
;;;673                            APP_PRINT_INFO0("BAS_NOTIFY_BATTERY_LEVEL_ENABLE");
        0x00209a00:    491e        .I      LDR      r1,[pc,#120] ; [0x209a7c] = 0x8800b90
        0x00209a02:    2200        ."      MOVS     r2,#0
        0x00209a04:    31f8        .1      ADDS     r1,r1,#0xf8
        0x00209a06:    e001        ..      B        0x209a0c ; app_profile_callback + 228
        0x00209a08:    2200        ."      MOVS     r2,#0
        0x00209a0a:    491d        .I      LDR      r1,[pc,#116] ; [0x209a80] = 0x8800cac
        0x00209a0c:    f5fef827    ..'.    BL       log_buffer ; 0x7a5e
        0x00209a10:    e025        %.      B        0x209a5e ; app_profile_callback + 310
;;;674                        }
;;;675                        break;
;;;676    
;;;677                    case BAS_NOTIFY_BATTERY_LEVEL_DISABLE:
;;;678                        {
;;;679                            APP_PRINT_INFO0("BAS_NOTIFY_BATTERY_LEVEL_DISABLE");
;;;680                        }
;;;681                        break;
;;;682                    default:
;;;683                        break;
;;;684                    }
;;;685                }
;;;686                break;
;;;687    
;;;688            case SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE:
;;;689                {
;;;690                    if (p_bas_cb_data->msg_data.read_value_index == BAS_READ_BATTERY_LEVEL)
        0x00209a12:    7889        .x      LDRB     r1,[r1,#2]
        0x00209a14:    2901        .)      CMP      r1,#1
        0x00209a16:    d122        ".      BNE      0x209a5e ; app_profile_callback + 310
        0x00209a18:    4919        .I      LDR      r1,[pc,#100] ; [0x209a80] = 0x8800cac
;;;691                    {
;;;692                        uint8_t battery_level = 90;
        0x00209a1a:    235a        Z#      MOVS     r3,#0x5a
        0x00209a1c:    f88d3000    ...0    STRB     r3,[sp,#0]
;;;693                        APP_PRINT_INFO1("BAS_READ_BATTERY_LEVEL: battery_level %d", battery_level);
        0x00209a20:    2201        ."      MOVS     r2,#1
        0x00209a22:    3124        $1      ADDS     r1,r1,#0x24
        0x00209a24:    f5fef81b    ....    BL       log_buffer ; 0x7a5e
;;;694                        bas_set_parameter(BAS_PARAM_BATTERY_LEVEL, 1, &battery_level);
        0x00209a28:    2101        .!      MOVS     r1,#1
        0x00209a2a:    466a        jF      MOV      r2,sp
        0x00209a2c:    4608        .F      MOV      r0,r1
        0x00209a2e:    f7fefbd7    ....    BL       bas_set_parameter ; 0x2081e0
;;;695                    }
        0x00209a32:    e014        ..      B        0x209a5e ; app_profile_callback + 310
;;;696                }
;;;697                break;
;;;698    
;;;699            default:
;;;700                break;
;;;701            }
;;;702        }
;;;703        else if (service_id == ota_srv_id)
        0x00209a34:    79eb        .y      LDRB     r3,[r5,#7]
        0x00209a36:    429a        .B      CMP      r2,r3
        0x00209a38:    d111        ..      BNE      0x209a5e ; app_profile_callback + 310
;;;704        {
;;;705    
;;;706            TOTA_CALLBACK_DATA *pOTACallbackData = (TOTA_CALLBACK_DATA *)p_data;
;;;707            switch (pOTACallbackData->msg_type)
        0x00209a3a:    780a        .x      LDRB     r2,[r1,#0]
        0x00209a3c:    2a03        .*      CMP      r2,#3
        0x00209a3e:    d10e        ..      BNE      0x209a5e ; app_profile_callback + 310
;;;708            {
;;;709            case SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE:
;;;710    
;;;711                if (OTA_WRITE_CHAR_VAL == pOTACallbackData->msg_data.write.opcode &&
        0x00209a40:    788a        .x      LDRB     r2,[r1,#2]
        0x00209a42:    2a01        .*      CMP      r2,#1
        0x00209a44:    d10b        ..      BNE      0x209a5e ; app_profile_callback + 310
;;;712                    OTA_VALUE_ENTER == pOTACallbackData->msg_data.write.u.value)
        0x00209a46:    7909        .y      LDRB     r1,[r1,#4]
        0x00209a48:    2901        .)      CMP      r1,#1
        0x00209a4a:    d108        ..      BNE      0x209a5e ; app_profile_callback + 310
;;;713                {
;;;714    
;;;715                    /*battery level is above 60 percent*/
;;;716                    APP_PRINT_INFO0("Preparing switch into OTA mode\n");
        0x00209a4c:    490c        .I      LDR      r1,[pc,#48] ; [0x209a80] = 0x8800cac
        0x00209a4e:    2200        ."      MOVS     r2,#0
        0x00209a50:    3150        P1      ADDS     r1,r1,#0x50
        0x00209a52:    f5fef804    ....    BL       log_buffer ; 0x7a5e
;;;717                    /*prepare to enter OTA mode, before switch action, we should disconnect first.*/
;;;718                    switch_into_ota_pending = true;
        0x00209a56:    70ae        .p      STRB     r6,[r5,#2]
;;;719                    le_disconnect(keyboard_con_id);
        0x00209a58:    7a28        (z      LDRB     r0,[r5,#8]
        0x00209a5a:    f644f8e3    D...    BL       le_disconnect ; 0x4dc24
;;;720                }
;;;721                else if (OTA_WRITE_IMAGE_COUNT_VAL == pOTACallbackData->msg_data.write.opcode)
;;;722                {
;;;723    
;;;724                }
;;;725    
;;;726                break;
;;;727    
;;;728            default:
;;;729    
;;;730                break;
;;;731            }
;;;732        }
;;;733    
;;;734        return app_result;
        0x00209a5e:    4638        8F      MOV      r0,r7
;;;735    }
        0x00209a60:    b004        ..      ADD      sp,sp,#0x10
        0x00209a62:    e5b3        ..      B        0x2095cc ; app_handle_conn_state_evt + 228
    $d
        0x00209a64:    0020bcc4    .. .    DCD    2145476
        0x00209a68:    21103002    .0.!    DCD    554708994
        0x00209a6c:    0020bc88    .. .    DCD    2145416
        0x00209a70:    088004b8    ....    DCD    142607544
        0x00209a74:    08800a7c    |...    DCD    142609020
        0x00209a78:    0020bccc    .. .    DCD    2145484
        0x00209a7c:    08800b90    ....    DCD    142609296
        0x00209a80:    08800cac    ....    DCD    142609580
    $t
    .text
    keyscan_pad_config
;;; ..\..\..\src\app\keyboard\keyscan.c
;;;46     {
        0x00209a84:    b51c        ..      PUSH     {r2-r4,lr}
;;;47         Pad_Config(ROW0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209a86:    2400        .$      MOVS     r4,#0
        0x00209a88:    2301        .#      MOVS     r3,#1
        0x00209a8a:    9400        ..      STR      r4,[sp,#0]
        0x00209a8c:    461a        .F      MOV      r2,r3
        0x00209a8e:    4619        .F      MOV      r1,r3
        0x00209a90:    201a        .       MOVS     r0,#0x1a
        0x00209a92:    9401        ..      STR      r4,[sp,#4]
        0x00209a94:    f607fca2    ....    BL       Pad_Config ; 0x113dc
;;;48         Pad_Config(ROW1, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209a98:    2301        .#      MOVS     r3,#1
        0x00209a9a:    9400        ..      STR      r4,[sp,#0]
        0x00209a9c:    461a        .F      MOV      r2,r3
        0x00209a9e:    4619        .F      MOV      r1,r3
        0x00209aa0:    201b        .       MOVS     r0,#0x1b
        0x00209aa2:    9401        ..      STR      r4,[sp,#4]
        0x00209aa4:    f607fc9a    ....    BL       Pad_Config ; 0x113dc
;;;49         Pad_Config(ROW2, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209aa8:    2301        .#      MOVS     r3,#1
        0x00209aaa:    9400        ..      STR      r4,[sp,#0]
        0x00209aac:    461a        .F      MOV      r2,r3
        0x00209aae:    4619        .F      MOV      r1,r3
        0x00209ab0:    201c        .       MOVS     r0,#0x1c
        0x00209ab2:    9401        ..      STR      r4,[sp,#4]
        0x00209ab4:    f607fc92    ....    BL       Pad_Config ; 0x113dc
;;;50         Pad_Config(ROW3, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209ab8:    2301        .#      MOVS     r3,#1
        0x00209aba:    9400        ..      STR      r4,[sp,#0]
        0x00209abc:    461a        .F      MOV      r2,r3
        0x00209abe:    4619        .F      MOV      r1,r3
        0x00209ac0:    2019        .       MOVS     r0,#0x19
        0x00209ac2:    9401        ..      STR      r4,[sp,#4]
        0x00209ac4:    f607fc8a    ....    BL       Pad_Config ; 0x113dc
;;;51     
;;;52         Pad_Config(COLUMN0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209ac8:    2201        ."      MOVS     r2,#1
        0x00209aca:    9400        ..      STR      r4,[sp,#0]
        0x00209acc:    2300        .#      MOVS     r3,#0
        0x00209ace:    4611        .F      MOV      r1,r2
        0x00209ad0:    2020                MOVS     r0,#0x20
        0x00209ad2:    9401        ..      STR      r4,[sp,#4]
        0x00209ad4:    f607fc82    ....    BL       Pad_Config ; 0x113dc
;;;53         Pad_Config(COLUMN1, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209ad8:    2201        ."      MOVS     r2,#1
        0x00209ada:    9400        ..      STR      r4,[sp,#0]
        0x00209adc:    2300        .#      MOVS     r3,#0
        0x00209ade:    4611        .F      MOV      r1,r2
        0x00209ae0:    2021        !       MOVS     r0,#0x21
        0x00209ae2:    9401        ..      STR      r4,[sp,#4]
        0x00209ae4:    f607fc7a    ..z.    BL       Pad_Config ; 0x113dc
;;;54         Pad_Config(COLUMN2, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209ae8:    2201        ."      MOVS     r2,#1
        0x00209aea:    9400        ..      STR      r4,[sp,#0]
        0x00209aec:    2300        .#      MOVS     r3,#0
        0x00209aee:    4611        .F      MOV      r1,r2
        0x00209af0:    2022        "       MOVS     r0,#0x22
        0x00209af2:    9401        ..      STR      r4,[sp,#4]
        0x00209af4:    f607fc72    ..r.    BL       Pad_Config ; 0x113dc
;;;55         Pad_Config(COLUMN3, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209af8:    2201        ."      MOVS     r2,#1
        0x00209afa:    9400        ..      STR      r4,[sp,#0]
        0x00209afc:    2300        .#      MOVS     r3,#0
        0x00209afe:    4611        .F      MOV      r1,r2
        0x00209b00:    2023        #       MOVS     r0,#0x23
        0x00209b02:    9401        ..      STR      r4,[sp,#4]
        0x00209b04:    f607fc6a    ..j.    BL       Pad_Config ; 0x113dc
;;;56     }
        0x00209b08:    bd1c        ..      POP      {r2-r4,pc}
    keyscan_pinmux_config
;;;57     
;;;58     void keyscan_pinmux_config(void)
;;;59     {
        0x00209b0a:    b510        ..      PUSH     {r4,lr}
;;;60         Pinmux_Config(ROW0, KEY_ROW_0);
        0x00209b0c:    214e        N!      MOVS     r1,#0x4e
        0x00209b0e:    201a        .       MOVS     r0,#0x1a
        0x00209b10:    f607fc30    ..0.    BL       Pinmux_Config ; 0x11374
;;;61         Pinmux_Config(ROW1, KEY_ROW_1);
        0x00209b14:    214f        O!      MOVS     r1,#0x4f
        0x00209b16:    201b        .       MOVS     r0,#0x1b
        0x00209b18:    f607fc2c    ..,.    BL       Pinmux_Config ; 0x11374
;;;62         Pinmux_Config(ROW2, KEY_ROW_2);
        0x00209b1c:    2150        P!      MOVS     r1,#0x50
        0x00209b1e:    201c        .       MOVS     r0,#0x1c
        0x00209b20:    f607fc28    ..(.    BL       Pinmux_Config ; 0x11374
;;;63         Pinmux_Config(ROW3, KEY_ROW_3);
        0x00209b24:    2151        Q!      MOVS     r1,#0x51
        0x00209b26:    2019        .       MOVS     r0,#0x19
        0x00209b28:    f607fc24    ..$.    BL       Pinmux_Config ; 0x11374
;;;64     
;;;65         Pinmux_Config(COLUMN0, KEY_COL_0);
        0x00209b2c:    213a        :!      MOVS     r1,#0x3a
        0x00209b2e:    2020                MOVS     r0,#0x20
        0x00209b30:    f607fc20    .. .    BL       Pinmux_Config ; 0x11374
;;;66         Pinmux_Config(COLUMN1, KEY_COL_1);
        0x00209b34:    213b        ;!      MOVS     r1,#0x3b
        0x00209b36:    2021        !       MOVS     r0,#0x21
        0x00209b38:    f607fc1c    ....    BL       Pinmux_Config ; 0x11374
;;;67         Pinmux_Config(COLUMN2, KEY_COL_2);
        0x00209b3c:    213c        <!      MOVS     r1,#0x3c
        0x00209b3e:    2022        "       MOVS     r0,#0x22
        0x00209b40:    f607fc18    ....    BL       Pinmux_Config ; 0x11374
;;;68         Pinmux_Config(COLUMN3, KEY_COL_3);
        0x00209b44:    213d        =!      MOVS     r1,#0x3d
        0x00209b46:    e8bd4010    ...@    POP      {r4,lr}
        0x00209b4a:    2023        #       MOVS     r0,#0x23
        0x00209b4c:    f607bc12    ....    B        Pinmux_Config ; 0x11374
    keyscan_enable_wakeup_config
;;;69     }
;;;70     
;;;71     /******************************************************************
;;;72      * @brief    keyscan enable wakeup config function
;;;73      */
;;;74     void keyscan_enable_wakeup_config(void)
;;;75     {
        0x00209b50:    b510        ..      PUSH     {r4,lr}
;;;76         /* @note: no key is pressed, use PAD wake up function with debounce,
;;;77         but pad debunce time should be smaller than ble connect interval */
;;;78         System_WakeUpDebounceTime(8);
        0x00209b52:    2008        .       MOVS     r0,#8
        0x00209b54:    f607fc89    ....    BL       System_WakeUpDebounceTime ; 0x1146a
;;;79     
;;;80         System_WakeUpPinEnable(ROW0, PAD_WAKEUP_POL_LOW, PAD_WK_DEBOUNCE_ENABLE);
        0x00209b58:    2201        ."      MOVS     r2,#1
        0x00209b5a:    4611        .F      MOV      r1,r2
        0x00209b5c:    201a        .       MOVS     r0,#0x1a
        0x00209b5e:    f607fcce    ....    BL       System_WakeUpPinEnable ; 0x114fe
;;;81         System_WakeUpPinEnable(ROW1, PAD_WAKEUP_POL_LOW, PAD_WK_DEBOUNCE_ENABLE);
        0x00209b62:    2201        ."      MOVS     r2,#1
        0x00209b64:    4611        .F      MOV      r1,r2
        0x00209b66:    201b        .       MOVS     r0,#0x1b
        0x00209b68:    f607fcc9    ....    BL       System_WakeUpPinEnable ; 0x114fe
;;;82         System_WakeUpPinEnable(ROW2, PAD_WAKEUP_POL_LOW, PAD_WK_DEBOUNCE_ENABLE);
        0x00209b6c:    2201        ."      MOVS     r2,#1
        0x00209b6e:    4611        .F      MOV      r1,r2
        0x00209b70:    201c        .       MOVS     r0,#0x1c
        0x00209b72:    f607fcc4    ....    BL       System_WakeUpPinEnable ; 0x114fe
;;;83         System_WakeUpPinEnable(ROW3, PAD_WAKEUP_POL_LOW, PAD_WK_DEBOUNCE_ENABLE);
        0x00209b76:    2201        ."      MOVS     r2,#1
        0x00209b78:    e8bd4010    ...@    POP      {r4,lr}
        0x00209b7c:    4611        .F      MOV      r1,r2
        0x00209b7e:    2019        .       MOVS     r0,#0x19
        0x00209b80:    f607bcbd    ....    B        System_WakeUpPinEnable ; 0x114fe
    keyscan_disable_wakeup_config
;;;84     }
;;;85     
;;;86     /******************************************************************
;;;87      * @brief    keyscan disable wakeup config function
;;;88      */
;;;89     void keyscan_disable_wakeup_config(void)
;;;90     {
        0x00209b84:    b510        ..      PUSH     {r4,lr}
;;;91         System_WakeUpPinDisable(ROW0);
        0x00209b86:    201a        .       MOVS     r0,#0x1a
        0x00209b88:    f607fcd2    ....    BL       System_WakeUpPinDisable ; 0x11530
;;;92         System_WakeUpPinDisable(ROW1);
        0x00209b8c:    201b        .       MOVS     r0,#0x1b
        0x00209b8e:    f607fccf    ....    BL       System_WakeUpPinDisable ; 0x11530
;;;93         System_WakeUpPinDisable(ROW2);
        0x00209b92:    201c        .       MOVS     r0,#0x1c
        0x00209b94:    f607fccc    ....    BL       System_WakeUpPinDisable ; 0x11530
;;;94         System_WakeUpPinDisable(ROW3);
        0x00209b98:    e8bd4010    ...@    POP      {r4,lr}
        0x00209b9c:    2019        .       MOVS     r0,#0x19
        0x00209b9e:    f607bcc7    ....    B        System_WakeUpPinDisable ; 0x11530
    keyscan_enter_dlps_config
;;;95     }
;;;96     
;;;97     
;;;98     /******************************************************************
;;;99      * @brief    keyscan enter DLPS config
;;;100     */
;;;101    void keyscan_enter_dlps_config(void)
;;;102    {
        0x00209ba2:    b57c        |.      PUSH     {r2-r6,lr}
;;;103        Pad_Config(COLUMN0, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x00209ba4:    2400        .$      MOVS     r4,#0
        0x00209ba6:    2501        .%      MOVS     r5,#1
        0x00209ba8:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x00209bac:    4623        #F      MOV      r3,r4
        0x00209bae:    462a        *F      MOV      r2,r5
        0x00209bb0:    4621        !F      MOV      r1,r4
        0x00209bb2:    2020                MOVS     r0,#0x20
        0x00209bb4:    f607fc12    ....    BL       Pad_Config ; 0x113dc
;;;104        Pad_Config(COLUMN1, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x00209bb8:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x00209bbc:    2300        .#      MOVS     r3,#0
        0x00209bbe:    2201        ."      MOVS     r2,#1
        0x00209bc0:    4619        .F      MOV      r1,r3
        0x00209bc2:    2021        !       MOVS     r0,#0x21
        0x00209bc4:    f607fc0a    ....    BL       Pad_Config ; 0x113dc
;;;105        Pad_Config(COLUMN2, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x00209bc8:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x00209bcc:    2300        .#      MOVS     r3,#0
        0x00209bce:    2201        ."      MOVS     r2,#1
        0x00209bd0:    4619        .F      MOV      r1,r3
        0x00209bd2:    2022        "       MOVS     r0,#0x22
        0x00209bd4:    f607fc02    ....    BL       Pad_Config ; 0x113dc
;;;106        Pad_Config(COLUMN3, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x00209bd8:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x00209bdc:    2300        .#      MOVS     r3,#0
        0x00209bde:    2201        ."      MOVS     r2,#1
        0x00209be0:    4619        .F      MOV      r1,r3
        0x00209be2:    2023        #       MOVS     r0,#0x23
        0x00209be4:    f607fbfa    ....    BL       Pad_Config ; 0x113dc
;;;107    
;;;108        if (keyscan_global_data.is_all_key_released == true)
        0x00209be8:    48f8        .H      LDR      r0,[pc,#992] ; [0x209fcc] = 0x20bc98
        0x00209bea:    78c0        .x      LDRB     r0,[r0,#3]
        0x00209bec:    2801        .(      CMP      r0,#1
        0x00209bee:    d022        ".      BEQ      0x209c36 ; keyscan_enter_dlps_config + 148
        0x00209bf0:    f7ffffc8    ....    BL       keyscan_disable_wakeup_config ; 0x209b84
        0x00209bf4:    9400        ..      STR      r4,[sp,#0]
        0x00209bf6:    2302        .#      MOVS     r3,#2
        0x00209bf8:    2201        ."      MOVS     r2,#1
        0x00209bfa:    2100        .!      MOVS     r1,#0
        0x00209bfc:    201a        .       MOVS     r0,#0x1a
        0x00209bfe:    9401        ..      STR      r4,[sp,#4]
        0x00209c00:    f607fbec    ....    BL       Pad_Config ; 0x113dc
        0x00209c04:    9400        ..      STR      r4,[sp,#0]
        0x00209c06:    2302        .#      MOVS     r3,#2
        0x00209c08:    2201        ."      MOVS     r2,#1
        0x00209c0a:    2100        .!      MOVS     r1,#0
        0x00209c0c:    201b        .       MOVS     r0,#0x1b
        0x00209c0e:    9401        ..      STR      r4,[sp,#4]
        0x00209c10:    f607fbe4    ....    BL       Pad_Config ; 0x113dc
        0x00209c14:    9400        ..      STR      r4,[sp,#0]
        0x00209c16:    2302        .#      MOVS     r3,#2
        0x00209c18:    2201        ."      MOVS     r2,#1
        0x00209c1a:    2100        .!      MOVS     r1,#0
        0x00209c1c:    201c        .       MOVS     r0,#0x1c
        0x00209c1e:    9401        ..      STR      r4,[sp,#4]
        0x00209c20:    f607fbdc    ....    BL       Pad_Config ; 0x113dc
        0x00209c24:    9400        ..      STR      r4,[sp,#0]
        0x00209c26:    2302        .#      MOVS     r3,#2
        0x00209c28:    9401        ..      STR      r4,[sp,#4]
        0x00209c2a:    2201        ."      MOVS     r2,#1
        0x00209c2c:    2100        .!      MOVS     r1,#0
        0x00209c2e:    2019        .       MOVS     r0,#0x19
        0x00209c30:    f607fbd4    ....    BL       Pad_Config ; 0x113dc
        0x00209c34:    bd7c        |.      POP      {r2-r6,pc}
;;;109        {
;;;110            keyscan_enable_wakeup_config();
        0x00209c36:    f7ffff8b    ....    BL       keyscan_enable_wakeup_config ; 0x209b50
;;;111            Pad_Config(ROW0, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209c3a:    2301        .#      MOVS     r3,#1
        0x00209c3c:    9400        ..      STR      r4,[sp,#0]
        0x00209c3e:    461a        .F      MOV      r2,r3
        0x00209c40:    2100        .!      MOVS     r1,#0
        0x00209c42:    201a        .       MOVS     r0,#0x1a
        0x00209c44:    9401        ..      STR      r4,[sp,#4]
        0x00209c46:    f607fbc9    ....    BL       Pad_Config ; 0x113dc
;;;112            Pad_Config(ROW1, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209c4a:    2301        .#      MOVS     r3,#1
        0x00209c4c:    9400        ..      STR      r4,[sp,#0]
        0x00209c4e:    461a        .F      MOV      r2,r3
        0x00209c50:    2100        .!      MOVS     r1,#0
        0x00209c52:    201b        .       MOVS     r0,#0x1b
        0x00209c54:    9401        ..      STR      r4,[sp,#4]
        0x00209c56:    f607fbc1    ....    BL       Pad_Config ; 0x113dc
;;;113            Pad_Config(ROW2, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209c5a:    2301        .#      MOVS     r3,#1
        0x00209c5c:    9400        ..      STR      r4,[sp,#0]
        0x00209c5e:    461a        .F      MOV      r2,r3
        0x00209c60:    2100        .!      MOVS     r1,#0
        0x00209c62:    201c        .       MOVS     r0,#0x1c
        0x00209c64:    9401        ..      STR      r4,[sp,#4]
        0x00209c66:    f607fbb9    ....    BL       Pad_Config ; 0x113dc
;;;114            Pad_Config(ROW3, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209c6a:    9400        ..      STR      r4,[sp,#0]
        0x00209c6c:    2301        .#      MOVS     r3,#1
        0x00209c6e:    9401        ..      STR      r4,[sp,#4]
        0x00209c70:    e7db        ..      B        0x209c2a ; keyscan_enter_dlps_config + 136
    keyscan_init_driver
;;;115        }
;;;116        else
;;;117        {
;;;118            /* any key is pressed, disable key row pins, just wait keyscan sw timer to wake */
;;;119            keyscan_disable_wakeup_config();
;;;120            Pad_Config(ROW0, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;121            Pad_Config(ROW1, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;122            Pad_Config(ROW2, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;123            Pad_Config(ROW3, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;124        }
;;;125    }
;;;126    
;;;127    /******************************************************************
;;;128     * @brief    keyscan exit DLPS config
;;;129     */
;;;130    void keyscan_exit_dlps_config(void)
;;;131    {
;;;132        keyscan_pad_config();
;;;133    
;;;134        if (true == keyscan_global_data.is_all_key_released)
;;;135        {
;;;136            keyscan_init_driver(KeyScan_Debounce_Enable);
;;;137        }
;;;138    }
;;;139    
;;;140    
;;;141    /******************************************************************
;;;142     * @fn       keyscan_init_driver
;;;143     * @brief    keyscan module initial
;;;144     *
;;;145     * @param    uint32_t is_debounce
;;;146     * @return   void
;;;147     * @note     when system in dlsp mode, keyscan debunce time should be smaller
;;;148     *           than wake up interval time (like ble interval), which can be modified
;;;149     *           through KeyScan_InitStruct.debouncecnt.
;;;150     */
;;;151    void keyscan_init_driver(uint32_t is_debounce)
;;;152    {
        0x00209c72:    b570        p.      PUSH     {r4-r6,lr}
        0x00209c74:    4cd6        .L      LDR      r4,[pc,#856] ; [0x209fd0] = 0x60000040
        0x00209c76:    4ed7        .N      LDR      r6,[pc,#860] ; [0x209fd4] = 0x8080000
        0x00209c78:    4605        .F      MOV      r5,r0
        0x00209c7a:    b08e        ..      SUB      sp,sp,#0x38
;;;153        RCC_PeriphClockCmd(APBPeriph_KEYSCAN, APBPeriph_KEYSCAN_CLOCK, DISABLE);
        0x00209c7c:    2200        ."      MOVS     r2,#0
        0x00209c7e:    4621        !F      MOV      r1,r4
        0x00209c80:    4630        0F      MOV      r0,r6
        0x00209c82:    f7fefe87    ....    BL       RCC_PeriphClockCmd ; 0x208994
;;;154        /* turn on keyscan clock */
;;;155        RCC_PeriphClockCmd(APBPeriph_KEYSCAN, APBPeriph_KEYSCAN_CLOCK, ENABLE);
        0x00209c86:    2201        ."      MOVS     r2,#1
        0x00209c88:    4621        !F      MOV      r1,r4
        0x00209c8a:    4630        0F      MOV      r0,r6
        0x00209c8c:    f7fefe82    ....    BL       RCC_PeriphClockCmd ; 0x208994
;;;156    
;;;157        keyscan_global_data.is_allowed_to_repeat_report = false;
        0x00209c90:    48ce        .H      LDR      r0,[pc,#824] ; [0x209fcc] = 0x20bc98
        0x00209c92:    2400        .$      MOVS     r4,#0
        0x00209c94:    7004        .p      STRB     r4,[r0,#0]
;;;158        KEYSCAN_InitTypeDef  KeyScan_InitStruct;
;;;159        KeyScan_StructInit(&KeyScan_InitStruct);
        0x00209c96:    4668        hF      MOV      r0,sp
        0x00209c98:    f7fff942    ..B.    BL       KeyScan_StructInit ; 0x208f20
;;;160        KeyScan_InitStruct.colSize         = KEYPAD_COLUMN_SIZE;
        0x00209c9c:    2104        .!      MOVS     r1,#4
        0x00209c9e:    2026        &       MOVS     r0,#0x26
        0x00209ca0:    f8ad1002    ....    STRH     r1,[sp,#2]
        0x00209ca4:    f8ad002c    ..,.    STRH     r0,[sp,#0x2c]
;;;161        KeyScan_InitStruct.rowSize         = KEYPAD_ROW_SIZE;
        0x00209ca8:    f8ad1000    ....    STRH     r1,[sp,#0]
        0x00209cac:    200f        .       MOVS     r0,#0xf
        0x00209cae:    f88d002e    ....    STRB     r0,[sp,#0x2e]
;;;162        KeyScan_InitStruct.scanmode        = KeyScan_Manual_Scan_Mode;
;;;163    
;;;164        KeyScan_InitStruct.clockdiv         = 0x26;  /* 128kHz = 5MHz/(clockdiv+1) */
        0x00209cb2:    940a        ..      STR      r4,[sp,#0x28]
;;;165        KeyScan_InitStruct.delayclk         = 0x0f;  /* 8kHz = 5MHz/(clockdiv+1)/(delayclk+1) */
        0x00209cb4:    e9cd5403    ...T    STRD     r5,r4,[sp,#0xc]
;;;166    
;;;167        KeyScan_InitStruct.debounceEn       = is_debounce;
;;;168        KeyScan_InitStruct.scantimerEn      = KeyScan_ScanInterval_Disable;//KeyScan_ScanInterval_Enable;
;;;169        KeyScan_InitStruct.detecttimerEn    = KeyScan_Release_Detect_Disable;
;;;170    
;;;171        KeyScan_InitStruct.scanInterval     = 0x190;  /* 50ms = scanInterval/8kHz */
        0x00209cb8:    f44f70c8    O..p    MOV      r0,#0x190
        0x00209cbc:    f8ad000a    ....    STRH     r0,[sp,#0xa]
        0x00209cc0:    2040        @       MOVS     r0,#0x40
        0x00209cc2:    9405        ..      STR      r4,[sp,#0x14]
;;;172        KeyScan_InitStruct.debouncecnt      = 0x40;   //8ms = debouncecnt/8kHz
        0x00209cc4:    f88d0032    ..2.    STRB     r0,[sp,#0x32]
;;;173        KeyScan_InitStruct.releasecnt       = 0x01;   //0.125ms = releasecnt/8kHz
        0x00209cc8:    2001        .       MOVS     r0,#1
        0x00209cca:    4cc3        .L      LDR      r4,[pc,#780] ; [0x209fd8] = 0x40005000
        0x00209ccc:    f88d0033    ..3.    STRB     r0,[sp,#0x33]
;;;174    
;;;175        KeyScan_Init(KEYSCAN, &KeyScan_InitStruct);
        0x00209cd0:    4669        iF      MOV      r1,sp
        0x00209cd2:    4620         F      MOV      r0,r4
        0x00209cd4:    f7fff8cc    ....    BL       KeyScan_Init ; 0x208e70
;;;176        KeyScan_INTConfig(KEYSCAN, KEYSCAN_INT_SCAN_END, ENABLE);
        0x00209cd8:    2201        ."      MOVS     r2,#1
        0x00209cda:    2104        .!      MOVS     r1,#4
        0x00209cdc:    4620         F      MOV      r0,r4
        0x00209cde:    f7fff93e    ..>.    BL       KeyScan_INTConfig ; 0x208f5e
;;; ..\..\..\inc\peripheral\rtl876x_keyscan.h
;;;404        KeyScan->INTCLR |= KeyScan_IT;
        0x00209ce2:    69e0        .i      LDR      r0,[r4,#0x1c]
        0x00209ce4:    f0400004    @...    ORR      r0,r0,#4
        0x00209ce8:    61e0        .a      STR      r0,[r4,#0x1c]
;;; ..\..\..\src\app\keyboard\keyscan.c
;;;178        KeyScan_INTMask(KEYSCAN, KEYSCAN_INT_SCAN_END, DISABLE);  /* Mask keyscan interrupt */
        0x00209cea:    2200        ."      MOVS     r2,#0
        0x00209cec:    2104        .!      MOVS     r1,#4
        0x00209cee:    4620         F      MOV      r0,r4
        0x00209cf0:    f7fff93d    ..=.    BL       KeyScan_INTMask ; 0x208f6e
;;;179        KeyScan_Cmd(KEYSCAN, ENABLE);
        0x00209cf4:    2101        .!      MOVS     r1,#1
        0x00209cf6:    4620         F      MOV      r0,r4
        0x00209cf8:    f7fff94c    ..L.    BL       KeyScan_Cmd ; 0x208f94
;;;180    }
        0x00209cfc:    b00e        ..      ADD      sp,sp,#0x38
        0x00209cfe:    bd70        p.      POP      {r4-r6,pc}
    keyscan_exit_dlps_config
;;; ..\..\..\src\app\keyboard\keyscan.c (131)
        0x00209d00:    b510        ..      PUSH     {r4,lr}
;;;132        keyscan_pad_config();
        0x00209d02:    f7fffebf    ....    BL       keyscan_pad_config ; 0x209a84
;;;133    
;;;134        if (true == keyscan_global_data.is_all_key_released)
        0x00209d06:    48b1        .H      LDR      r0,[pc,#708] ; [0x209fcc] = 0x20bc98
        0x00209d08:    78c0        .x      LDRB     r0,[r0,#3]
        0x00209d0a:    2801        .(      CMP      r0,#1
        0x00209d0c:    d103        ..      BNE      0x209d16 ; keyscan_exit_dlps_config + 22
;;;135        {
;;;136            keyscan_init_driver(KeyScan_Debounce_Enable);
        0x00209d0e:    e8bd4010    ...@    POP      {r4,lr}
        0x00209d12:    07c0        ..      LSLS     r0,r0,#31
        0x00209d14:    e7ad        ..      B        keyscan_init_driver ; 0x209c72
;;;137        }
;;;138    }
        0x00209d16:    bd10        ..      POP      {r4,pc}
    keyscan_nvic_config
;;;139    
;;;140    
;;;141    /******************************************************************
;;;142     * @fn       keyscan_init_driver
;;;143     * @brief    keyscan module initial
;;;144     *
;;;145     * @param    uint32_t is_debounce
;;;146     * @return   void
;;;147     * @note     when system in dlsp mode, keyscan debunce time should be smaller
;;;148     *           than wake up interval time (like ble interval), which can be modified
;;;149     *           through KeyScan_InitStruct.debouncecnt.
;;;150     */
;;;151    void keyscan_init_driver(uint32_t is_debounce)
;;;152    {
;;;153        RCC_PeriphClockCmd(APBPeriph_KEYSCAN, APBPeriph_KEYSCAN_CLOCK, DISABLE);
;;;154        /* turn on keyscan clock */
;;;155        RCC_PeriphClockCmd(APBPeriph_KEYSCAN, APBPeriph_KEYSCAN_CLOCK, ENABLE);
;;;156    
;;;157        keyscan_global_data.is_allowed_to_repeat_report = false;
;;;158        KEYSCAN_InitTypeDef  KeyScan_InitStruct;
;;;159        KeyScan_StructInit(&KeyScan_InitStruct);
;;;160        KeyScan_InitStruct.colSize         = KEYPAD_COLUMN_SIZE;
;;;161        KeyScan_InitStruct.rowSize         = KEYPAD_ROW_SIZE;
;;;162        KeyScan_InitStruct.scanmode        = KeyScan_Manual_Scan_Mode;
;;;163    
;;;164        KeyScan_InitStruct.clockdiv         = 0x26;  /* 128kHz = 5MHz/(clockdiv+1) */
;;;165        KeyScan_InitStruct.delayclk         = 0x0f;  /* 8kHz = 5MHz/(clockdiv+1)/(delayclk+1) */
;;;166    
;;;167        KeyScan_InitStruct.debounceEn       = is_debounce;
;;;168        KeyScan_InitStruct.scantimerEn      = KeyScan_ScanInterval_Disable;//KeyScan_ScanInterval_Enable;
;;;169        KeyScan_InitStruct.detecttimerEn    = KeyScan_Release_Detect_Disable;
;;;170    
;;;171        KeyScan_InitStruct.scanInterval     = 0x190;  /* 50ms = scanInterval/8kHz */
;;;172        KeyScan_InitStruct.debouncecnt      = 0x40;   //8ms = debouncecnt/8kHz
;;;173        KeyScan_InitStruct.releasecnt       = 0x01;   //0.125ms = releasecnt/8kHz
;;;174    
;;;175        KeyScan_Init(KEYSCAN, &KeyScan_InitStruct);
;;;176        KeyScan_INTConfig(KEYSCAN, KEYSCAN_INT_SCAN_END, ENABLE);
;;;177        KeyScan_ClearINTPendingBit(KEYSCAN, KEYSCAN_INT_SCAN_END);
;;;178        KeyScan_INTMask(KEYSCAN, KEYSCAN_INT_SCAN_END, DISABLE);  /* Mask keyscan interrupt */
;;;179        KeyScan_Cmd(KEYSCAN, ENABLE);
;;;180    }
;;;181    
;;;182    /******************************************************************
;;;183     * @brief    keyscan nvic config
;;;184     */
;;;185    void keyscan_nvic_config(void)
;;;186    {
        0x00209d18:    b50e        ..      PUSH     {r1-r3,lr}
;;;187        NVIC_InitTypeDef NVIC_InitStruct;
;;;188    
;;;189        NVIC_InitStruct.NVIC_IRQChannel = KeyScan_IRQn;
        0x00209d1a:    2036        6       MOVS     r0,#0x36
        0x00209d1c:    f88d0000    ....    STRB     r0,[sp,#0]
;;;190        NVIC_InitStruct.NVIC_IRQChannelPriority = 3;
        0x00209d20:    2003        .       MOVS     r0,#3
;;;191        NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
        0x00209d22:    9001        ..      STR      r0,[sp,#4]
        0x00209d24:    2001        .       MOVS     r0,#1
        0x00209d26:    f88d0008    ....    STRB     r0,[sp,#8]
;;;192    
;;;193        NVIC_Init(&NVIC_InitStruct);
        0x00209d2a:    4668        hF      MOV      r0,sp
        0x00209d2c:    f607fac8    ....    BL       NVIC_Init ; 0x112c0
;;;194    }
        0x00209d30:    bd0e        ..      POP      {r1-r3,pc}
    keyscan_init_data
;;;195    
;;;196    
;;;197    /**
;;;198    * @fn  keyscan_init_data
;;;199    * @brief  Initialize Keyscan driver data
;;;200    */
;;;201    void keyscan_init_data(void)
;;;202    {
        0x00209d32:    b510        ..      PUSH     {r4,lr}
;;;203        APP_PRINT_INFO0("[keyscan_init_data] init data");
        0x00209d34:    2200        ."      MOVS     r2,#0
        0x00209d36:    49a9        .I      LDR      r1,[pc,#676] ; [0x209fdc] = 0x8800d20
        0x00209d38:    48a9        .H      LDR      r0,[pc,#676] ; [0x209fe0] = 0x21103002
        0x00209d3a:    f5fdfe90    ....    BL       log_buffer ; 0x7a5e
;;;204        memset(&keyscan_global_data, 0, sizeof(keyscan_global_data));
        0x00209d3e:    212c        ,!      MOVS     r1,#0x2c
        0x00209d40:    48a2        .H      LDR      r0,[pc,#648] ; [0x209fcc] = 0x20bc98
        0x00209d42:    f650f98d    P...    BL       __aeabi_memclr4 ; 0x5a060
;;;205        keyscan_global_data.is_allowed_to_enter_dlps = true;
        0x00209d46:    48a1        .H      LDR      r0,[pc,#644] ; [0x209fcc] = 0x20bc98
        0x00209d48:    2101        .!      MOVS     r1,#1
        0x00209d4a:    7041        Ap      STRB     r1,[r0,#1]
;;;206        keyscan_global_data.is_all_key_released = true;
        0x00209d4c:    70c1        .p      STRB     r1,[r0,#3]
;;;207    }
        0x00209d4e:    bd10        ..      POP      {r4,pc}
    Keyscan_Handler
;;;208    
;;;209    
;;;210    /******************************************************************
;;;211     * @brief    keyscan interrupt handler
;;;212     *
;;;213     * If use Manual Scan Mode, it shall clear KEYSCAN_INT_SCAN_END to start next keyscan,
;;;214     * otherwise, keyscan will not start.
;;;215     */
;;;216    void keyscan_interrupt_handler(void)
;;;217    {
        0x00209d50:    e92d47ff    -..G    PUSH     {r0-r10,lr}
;;;218        APP_PRINT_INFO0("[keyscan_interrupt_handler] interrupt handler");
        0x00209d54:    49a1        .I      LDR      r1,[pc,#644] ; [0x209fdc] = 0x8800d20
        0x00209d56:    4fa2        .O      LDR      r7,[pc,#648] ; [0x209fe0] = 0x21103002
        0x00209d58:    2200        ."      MOVS     r2,#0
        0x00209d5a:    3124        $1      ADDS     r1,r1,#0x24
        0x00209d5c:    4638        8F      MOV      r0,r7
        0x00209d5e:    f5fdfe7e    ..~.    BL       log_buffer ; 0x7a5e
;;; ..\..\..\inc\peripheral\rtl876x_keyscan.h
;;;468        if ((KeyScan->STATUS & KeyScan_FLAG) != 0)
        0x00209d62:    4e9d        .N      LDR      r6,[pc,#628] ; [0x209fd8] = 0x40005000
        0x00209d64:    6a30        0j      LDR      r0,[r6,#0x20]
        0x00209d66:    f04f4900    O..I    MOV      r9,#0x80000000
;;; ..\..\..\inc\peripheral\rtl876x_keyscan.h (468)
        0x00209d6a:    f4103f00    ...?    TST      r0,#0x20000
        0x00209d6e:    d06d        m.      BEQ      0x209e4c ; Keyscan_Handler + 252
;;; ..\..\..\src\app\keyboard\keyscan.c
;;;224            keyscan_global_data.is_allowed_to_enter_dlps = true;
        0x00209d70:    4c96        .L      LDR      r4,[pc,#600] ; [0x209fcc] = 0x20bc98
        0x00209d72:    2501        .%      MOVS     r5,#1
        0x00209d74:    462a        *F      MOV      r2,r5
        0x00209d76:    7065        ep      STRB     r5,[r4,#1]
;;;225            KeyScan_INTMask(KEYSCAN, KEYSCAN_INT_SCAN_END, ENABLE);  /* Mask keyscan interrupt */
        0x00209d78:    2104        .!      MOVS     r1,#4
        0x00209d7a:    4630        0F      MOV      r0,r6
        0x00209d7c:    f7fff8f7    ....    BL       KeyScan_INTMask ; 0x208f6e
;;; ..\..\..\inc\peripheral\rtl876x_keyscan.h
;;;382        return (uint16_t)((KeyScan->STATUS & STATUS_FIFO_DATA_NUM_MASK) >> 4);
        0x00209d80:    6a30        0j      LDR      r0,[r6,#0x20]
        0x00209d82:    f1a70802    ....    SUB      r8,r7,#2
;;; ..\..\..\inc\peripheral\rtl876x_keyscan.h (382)
        0x00209d86:    f3c01205    ....    UBFX     r2,r0,#4,#6
;;; ..\..\..\src\app\keyboard\keyscan.c
;;;228            if (keyscan_global_data.cur_fifo_data.len != 0)
        0x00209d8a:    61a2        .a      STR      r2,[r4,#0x18]
        0x00209d8c:    b3d2        ..      CBZ      r2,0x209e04 ; Keyscan_Handler + 180
;;;229            {
;;;230                /* read keyscan fifo data */
;;;231                KeyScan_Read(KEYSCAN, (uint16_t *) & (keyscan_global_data.cur_fifo_data.key[0]),
        0x00209d8e:    f104011c    ....    ADD      r1,r4,#0x1c
        0x00209d92:    4630        0F      MOV      r0,r6
        0x00209d94:    f7fff8f3    ....    BL       KeyScan_Read ; 0x208f7e
;;;232                             keyscan_global_data.cur_fifo_data.len);
;;;233                keyscan_global_data.is_key_pressed = true;
        0x00209d98:    70a5        .p      STRB     r5,[r4,#2]
;;;234                keyscan_global_data.is_all_key_released = false;
        0x00209d9a:    2000        .       MOVS     r0,#0
        0x00209d9c:    70e0        .p      STRB     r0,[r4,#3]
;;;235    
;;;236                /* start sw timer to check press status */
;;;237                if (!os_timer_restart(&keyscan_timer, KEYSCAN_SW_INTERVAL))
        0x00209d9e:    2132        2!      MOVS     r1,#0x32
        0x00209da0:    1f20         .      SUBS     r0,r4,#4
        0x00209da2:    f61cff4c    ..L.    BL       os_timer_restart ; 0x26c3e
        0x00209da6:    b110        ..      CBZ      r0,0x209dae ; Keyscan_Handler + 94
        0x00209da8:    7820         x      LDRB     r0,[r4,#0]
        0x00209daa:    b120         .      CBZ      r0,0x209db6 ; Keyscan_Handler + 102
        0x00209dac:    e011        ..      B        0x209dd2 ; Keyscan_Handler + 130
;;;238                {
;;;239                    APP_PRINT_ERROR0("[keyscan_interrupt_handler] restart xTimersKeyScan failed!");
        0x00209dae:    498b        .I      LDR      r1,[pc,#556] ; [0x209fdc] = 0x8800d20
        0x00209db0:    2200        ."      MOVS     r2,#0
        0x00209db2:    3158        X1      ADDS     r1,r1,#0x58
;;;240                    /* set flag to default status and reinit keyscan module with debounce enabled */
;;;241                    keyscan_init_data();
;;;242                    keyscan_init_driver(KeyScan_Debounce_Enable);
;;;243                    return;
        0x00209db4:    e048        H.      B        0x209e48 ; Keyscan_Handler + 248
;;;244                }
;;;245    
;;;246                if (false == keyscan_global_data.is_allowed_to_repeat_report)
;;;247                {
;;;248                    if (!memcmp(&keyscan_global_data.cur_fifo_data, &keyscan_global_data.pre_fifo_data,
        0x00209db6:    4885        .H      LDR      r0,[pc,#532] ; [0x209fcc] = 0x20bc98
        0x00209db8:    2214        ."      MOVS     r2,#0x14
        0x00209dba:    3018        .0      ADDS     r0,r0,#0x18
        0x00209dbc:    1d21        !.      ADDS     r1,r4,#4
        0x00209dbe:    4606        .F      MOV      r6,r0
        0x00209dc0:    f650f820    P. .    BL       memcmp ; 0x59e04
        0x00209dc4:    2800        .(      CMP      r0,#0
        0x00209dc6:    d03a        :.      BEQ      0x209e3e ; Keyscan_Handler + 238
;;;249                                sizeof(T_KEYSCAN_FIFIO_DATA)))
;;;250                    {
;;;251                        /* some keyscan FIFO data, just return */
;;;252                        return;
;;;253                    }
;;;254                    else
;;;255                    {
;;;256                        /* updata previous keyscan FIFO data */
;;;257                        memcpy(&keyscan_global_data.pre_fifo_data, &keyscan_global_data.cur_fifo_data,
        0x00209dc8:    2214        ."      MOVS     r2,#0x14
        0x00209dca:    4631        1F      MOV      r1,r6
        0x00209dcc:    1d20         .      ADDS     r0,r4,#4
        0x00209dce:    f650f8eb    P...    BL       __aeabi_memcpy4 ; 0x59fa8
        0x00209dd2:    487e        ~H      LDR      r0,[pc,#504] ; [0x209fcc] = 0x20bc98
;;;258                               sizeof(T_KEYSCAN_FIFIO_DATA));
;;;259                    }
;;;260                }
;;;261    
;;;262                bee_io_msg.type = IO_MSG_TYPE_KEYSCAN;
        0x00209dd4:    f8ad5000    ...P    STRH     r5,[sp,#0]
        0x00209dd8:    1d00        ..      ADDS     r0,r0,#4
        0x00209dda:    9001        ..      STR      r0,[sp,#4]
;;;263                bee_io_msg.subtype = IO_MSG_KEYSCAN_RX_PKT;
        0x00209ddc:    f8ad5002    ...P    STRH     r5,[sp,#2]
;;;264                bee_io_msg.u.buf   = (void *)(&keyscan_global_data.pre_fifo_data);
;;;265                if (false == app_send_msg_to_apptask(&bee_io_msg))
        0x00209de0:    4668        hF      MOV      r0,sp
        0x00209de2:    f7fffab2    ....    BL       app_send_msg_to_apptask ; 0x20934a
        0x00209de6:    2800        .(      CMP      r0,#0
        0x00209de8:    d129        ).      BNE      0x209e3e ; Keyscan_Handler + 238
;;;266                {
;;;267                    APP_PRINT_ERROR0("[keyscan_interrupt_handler] send IO_MSG_KEYSCAN_RX_PKT message failed!");
        0x00209dea:    497c        |I      LDR      r1,[pc,#496] ; [0x209fdc] = 0x8800d20
        0x00209dec:    2200        ."      MOVS     r2,#0
        0x00209dee:    3198        .1      ADDS     r1,r1,#0x98
        0x00209df0:    4640        @F      MOV      r0,r8
        0x00209df2:    f5fdfe34    ..4.    BL       log_buffer ; 0x7a5e
;;;268                    /* set flag to default status and reinit keyscan module with debounce enabled */
;;;269                    keyscan_init_data();
        0x00209df6:    f7ffff9c    ....    BL       keyscan_init_data ; 0x209d32
;;;270                    os_timer_stop(&keyscan_timer);
        0x00209dfa:    4874        tH      LDR      r0,[pc,#464] ; [0x209fcc] = 0x20bc98
        0x00209dfc:    1f00        ..      SUBS     r0,r0,#4
        0x00209dfe:    f61cff31    ..1.    BL       os_timer_stop ; 0x26c64
;;;271                    keyscan_init_driver(KeyScan_Debounce_Enable);
;;;272                    return;
        0x00209e02:    e019        ..      B        0x209e38 ; Keyscan_Handler + 232
        0x00209e04:    e7ff        ..      B        0x209e06 ; Keyscan_Handler + 182
;;;273                }
;;;274            }
;;;275            else
;;;276            {
;;;277                if (false == keyscan_global_data.is_all_key_released)
        0x00209e06:    78e0        .x      LDRB     r0,[r4,#3]
        0x00209e08:    f04f0200    O...    MOV      r2,#0
        0x00209e0c:    b120         .      CBZ      r0,0x209e18 ; Keyscan_Handler + 200
        0x00209e0e:    4975        uI      LDR      r1,[pc,#468] ; [0x209fe4] = 0x8800e8c
        0x00209e10:    4638        8F      MOV      r0,r7
        0x00209e12:    f5fdfe24    ..$.    BL       log_buffer ; 0x7a5e
        0x00209e16:    e00d        ..      B        0x209e34 ; Keyscan_Handler + 228
;;;278                {
;;;279                    /* keyscan release event detected */
;;;280                    APP_PRINT_INFO0("[keyscan_interrupt_handler] keyscan release event detected");
        0x00209e18:    4972        rI      LDR      r1,[pc,#456] ; [0x209fe4] = 0x8800e8c
        0x00209e1a:    4638        8F      MOV      r0,r7
        0x00209e1c:    3988        .9      SUBS     r1,r1,#0x88
        0x00209e1e:    f5fdfe1e    ....    BL       log_buffer ; 0x7a5e
;;;281                    T_IO_MSG bee_io_msg;
;;;282                    bee_io_msg.type = IO_MSG_TYPE_KEYSCAN;
        0x00209e22:    f8ad5008    ...P    STRH     r5,[sp,#8]
;;;283                    bee_io_msg.subtype = IO_MSG_KEYSCAN_ALLKEYRELEASE;
        0x00209e26:    2003        .       MOVS     r0,#3
        0x00209e28:    f8ad000a    ....    STRH     r0,[sp,#0xa]
;;;284    
;;;285                    if (false == app_send_msg_to_apptask(&bee_io_msg))
        0x00209e2c:    a802        ..      ADD      r0,sp,#8
        0x00209e2e:    f7fffa8c    ....    BL       app_send_msg_to_apptask ; 0x20934a
        0x00209e32:    b130        0.      CBZ      r0,0x209e42 ; Keyscan_Handler + 242
        0x00209e34:    f7ffff7d    ..}.    BL       keyscan_init_data ; 0x209d32
        0x00209e38:    4648        HF      MOV      r0,r9
        0x00209e3a:    f7ffff1a    ....    BL       keyscan_init_driver ; 0x209c72
        0x00209e3e:    e8bd87ff    ....    POP      {r0-r10,pc}
;;;286                    {
;;;287                        APP_PRINT_ERROR0("[keyscan_interrupt_handler] Send IO_MSG_TYPE_KEYSCAN message failed!");
        0x00209e42:    4968        hI      LDR      r1,[pc,#416] ; [0x209fe4] = 0x8800e8c
        0x00209e44:    2200        ."      MOVS     r2,#0
        0x00209e46:    3948        H9      SUBS     r1,r1,#0x48
        0x00209e48:    4640        @F      MOV      r0,r8
        0x00209e4a:    e7e2        ..      B        0x209e12 ; Keyscan_Handler + 194
;;;288                    }
;;;289    
;;;290                    keyscan_init_data();
;;;291                    keyscan_init_driver(KeyScan_Debounce_Enable);
;;;292                }
;;;293                else
;;;294                {
;;;295                    /*if system active, keyscan no debounce can arrive here*/
;;;296                    APP_PRINT_INFO0("[keyscan_interrupt_handler] if system active, keyscan no debounce can arrive here");
;;;297                    keyscan_init_data();
;;;298                    keyscan_init_driver(KeyScan_Debounce_Enable);
;;;299                    return;
;;;300                }
;;;301            }
;;;302        }
;;;303        else
;;;304        {
;;;305            /* if not KEYSCAN_INT_FLAG_SCAN_END interrupt */
;;;306            APP_PRINT_INFO0("[keyscan_interrupt_handler] not KEYSCAN_INT_FLAG_SCAN_END interrupt");
        0x00209e4c:    4965        eI      LDR      r1,[pc,#404] ; [0x209fe4] = 0x8800e8c
        0x00209e4e:    2200        ."      MOVS     r2,#0
        0x00209e50:    3158        X1      ADDS     r1,r1,#0x58
;;;307            keyscan_init_data();
;;;308            keyscan_init_driver(KeyScan_Debounce_Enable);
;;;309            return;
        0x00209e52:    e7dd        ..      B        0x209e10 ; Keyscan_Handler + 192
    keyscan_timer_callback
;;;310        }
;;;311    }
;;;312    
;;;313    
;;;314    /******************************************************************
;;;315     * @brief    keyscan init timer
;;;316     */
;;;317    void keyscan_init_timer(void)
;;;318    {
;;;319        APP_PRINT_INFO0("[keyscan_init_timer] init timer");
;;;320        /*xTimersKeyScan is used for keyscan dlps*/
;;;321        if (false == os_timer_create(&keyscan_timer, "keyscan_timer",  1, \
;;;322                                     KEYSCAN_SW_INTERVAL, false, keyscan_timer_callback))
;;;323        {
;;;324            APP_PRINT_ERROR0("[keyscan_init_timer] timer creat failed!");
;;;325        }
;;;326    }
;;;327    
;;;328    /******************************************************************
;;;329     * @brief    keyscan timer callback
;;;330     */
;;;331    void keyscan_timer_callback(void *pxTimer)
;;;332    {
        0x00209e54:    b511        ..      PUSH     {r0,r4,lr}
        0x00209e56:    4c5d        ]L      LDR      r4,[pc,#372] ; [0x209fcc] = 0x20bc98
        0x00209e58:    4861        aH      LDR      r0,[pc,#388] ; [0x209fe0] = 0x21103002
;;; ..\..\..\src\app\keyboard\keyscan.c (332)
        0x00209e5a:    b083        ..      SUB      sp,sp,#0xc
        0x00209e5c:    78a1        .x      LDRB     r1,[r4,#2]
        0x00209e5e:    f04f0200    O...    MOV      r2,#0
        0x00209e62:    2901        .)      CMP      r1,#1
        0x00209e64:    d00d        ..      BEQ      0x209e82 ; keyscan_timer_callback + 46
        0x00209e66:    4960        `I      LDR      r1,[pc,#384] ; [0x209fe8] = 0x8800fac
        0x00209e68:    f5fdfdf9    ....    BL       log_buffer ; 0x7a5e
        0x00209e6c:    2001        .       MOVS     r0,#1
        0x00209e6e:    f8ad0000    ....    STRH     r0,[sp,#0]
        0x00209e72:    2003        .       MOVS     r0,#3
        0x00209e74:    f8ad0002    ....    STRH     r0,[sp,#2]
        0x00209e78:    4668        hF      MOV      r0,sp
        0x00209e7a:    f7fffa66    ..f.    BL       app_send_msg_to_apptask ; 0x20934a
        0x00209e7e:    b170        p.      CBZ      r0,0x209e9e ; keyscan_timer_callback + 74
        0x00209e80:    e014        ..      B        0x209eac ; keyscan_timer_callback + 88
;;;333        if (keyscan_global_data.is_key_pressed == true)
;;;334        {
;;;335            APP_PRINT_INFO0("[keyscan_timer_callback] start release timer");
        0x00209e82:    4959        YI      LDR      r1,[pc,#356] ; [0x209fe8] = 0x8800fac
        0x00209e84:    3930        09      SUBS     r1,r1,#0x30
        0x00209e86:    f5fdfdea    ....    BL       log_buffer ; 0x7a5e
;;;336            keyscan_global_data.is_key_pressed = false;
        0x00209e8a:    2000        .       MOVS     r0,#0
        0x00209e8c:    70a0        .p      STRB     r0,[r4,#2]
;;;337            keyscan_global_data.is_allowed_to_enter_dlps = false;
        0x00209e8e:    7060        `p      STRB     r0,[r4,#1]
;;;338            keyscan_init_driver(KeyScan_Debounce_Disable);
        0x00209e90:    f7fffeef    ....    BL       keyscan_init_driver ; 0x209c72
;;;339            /* start timer to check key status */
;;;340            os_timer_restart(&pxTimer, KEYSCAN_SW_RELEASE_TIMEOUT);
        0x00209e94:    210a        .!      MOVS     r1,#0xa
        0x00209e96:    a803        ..      ADD      r0,sp,#0xc
        0x00209e98:    f61cfed1    ....    BL       os_timer_restart ; 0x26c3e
        0x00209e9c:    bd1f        ..      POP      {r0-r4,pc}
;;;341        }
;;;342        else
;;;343        {
;;;344            /* keyscan release event detected */
;;;345            APP_PRINT_INFO0("[keyscan_timer_callback] keyscan release event detected");
;;;346            T_IO_MSG bee_io_msg;
;;;347            bee_io_msg.type = IO_MSG_TYPE_KEYSCAN;
;;;348            bee_io_msg.subtype = IO_MSG_KEYSCAN_ALLKEYRELEASE;
;;;349    
;;;350            if (false == app_send_msg_to_apptask(&bee_io_msg))
;;;351            {
;;;352                APP_PRINT_ERROR0("[keyscan_timer_callback] Send IO_MSG_TYPE_KEYSCAN message failed!");
        0x00209e9e:    4952        RI      LDR      r1,[pc,#328] ; [0x209fe8] = 0x8800fac
        0x00209ea0:    484f        OH      LDR      r0,[pc,#316] ; [0x209fe0] = 0x21103002
        0x00209ea2:    2200        ."      MOVS     r2,#0
        0x00209ea4:    313c        <1      ADDS     r1,r1,#0x3c
        0x00209ea6:    1e80        ..      SUBS     r0,r0,#2
        0x00209ea8:    f5fdfdd9    ....    BL       log_buffer ; 0x7a5e
;;;353            }
;;;354    
;;;355            keyscan_init_data();
        0x00209eac:    f7ffff41    ..A.    BL       keyscan_init_data ; 0x209d32
;;;356            keyscan_init_driver(KeyScan_Debounce_Enable);
        0x00209eb0:    f04f4000    O..@    MOV      r0,#0x80000000
        0x00209eb4:    f7fffedd    ....    BL       keyscan_init_driver ; 0x209c72
;;;357        }
;;;358    }
        0x00209eb8:    bd1f        ..      POP      {r0-r4,pc}
    keyscan_init_timer
        0x00209eba:    b51c        ..      PUSH     {r2-r4,lr}
;;; ..\..\..\src\app\keyboard\keyscan.c (319)
        0x00209ebc:    494a        JI      LDR      r1,[pc,#296] ; [0x209fe8] = 0x8800fac
        0x00209ebe:    2200        ."      MOVS     r2,#0
        0x00209ec0:    3980        .9      SUBS     r1,r1,#0x80
        0x00209ec2:    4847        GH      LDR      r0,[pc,#284] ; [0x209fe0] = 0x21103002
        0x00209ec4:    f5fdfdcb    ....    BL       log_buffer ; 0x7a5e
;;;320        /*xTimersKeyScan is used for keyscan dlps*/
;;;321        if (false == os_timer_create(&keyscan_timer, "keyscan_timer",  1, \
        0x00209ec8:    f2af0177    ..w.    ADR      r1,{pc}-0x73 ; 0x209e55
        0x00209ecc:    2000        .       MOVS     r0,#0
        0x00209ece:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x00209ed2:    483e        >H      LDR      r0,[pc,#248] ; [0x209fcc] = 0x20bc98
        0x00209ed4:    2332        2#      MOVS     r3,#0x32
        0x00209ed6:    2201        ."      MOVS     r2,#1
        0x00209ed8:    a144        D.      ADR      r1,{pc}+0x114 ; 0x209fec
        0x00209eda:    1f00        ..      SUBS     r0,r0,#4
        0x00209edc:    f61cfe7b    ..{.    BL       os_timer_create ; 0x26bd6
        0x00209ee0:    2800        .(      CMP      r0,#0
        0x00209ee2:    d109        ..      BNE      0x209ef8 ; keyscan_init_timer + 62
;;;322                                     KEYSCAN_SW_INTERVAL, false, keyscan_timer_callback))
;;;323        {
;;;324            APP_PRINT_ERROR0("[keyscan_init_timer] timer creat failed!");
        0x00209ee4:    4940        @I      LDR      r1,[pc,#256] ; [0x209fe8] = 0x8800fac
        0x00209ee6:    b002        ..      ADD      sp,sp,#8
        0x00209ee8:    483d        =H      LDR      r0,[pc,#244] ; [0x209fe0] = 0x21103002
        0x00209eea:    2200        ."      MOVS     r2,#0
        0x00209eec:    395c        \9      SUBS     r1,r1,#0x5c
        0x00209eee:    e8bd4010    ...@    POP      {r4,lr}
        0x00209ef2:    1e80        ..      SUBS     r0,r0,#2
        0x00209ef4:    f5fdbdb3    ....    B        log_buffer ; 0x7a5e
;;;325        }
;;;326    }
        0x00209ef8:    bd1c        ..      POP      {r2-r4,pc}
    handle_keyscan_wakeup
;;;327    
;;;328    /******************************************************************
;;;329     * @brief    keyscan timer callback
;;;330     */
;;;331    void keyscan_timer_callback(void *pxTimer)
;;;332    {
;;;333        if (keyscan_global_data.is_key_pressed == true)
;;;334        {
;;;335            APP_PRINT_INFO0("[keyscan_timer_callback] start release timer");
;;;336            keyscan_global_data.is_key_pressed = false;
;;;337            keyscan_global_data.is_allowed_to_enter_dlps = false;
;;;338            keyscan_init_driver(KeyScan_Debounce_Disable);
;;;339            /* start timer to check key status */
;;;340            os_timer_restart(&pxTimer, KEYSCAN_SW_RELEASE_TIMEOUT);
;;;341        }
;;;342        else
;;;343        {
;;;344            /* keyscan release event detected */
;;;345            APP_PRINT_INFO0("[keyscan_timer_callback] keyscan release event detected");
;;;346            T_IO_MSG bee_io_msg;
;;;347            bee_io_msg.type = IO_MSG_TYPE_KEYSCAN;
;;;348            bee_io_msg.subtype = IO_MSG_KEYSCAN_ALLKEYRELEASE;
;;;349    
;;;350            if (false == app_send_msg_to_apptask(&bee_io_msg))
;;;351            {
;;;352                APP_PRINT_ERROR0("[keyscan_timer_callback] Send IO_MSG_TYPE_KEYSCAN message failed!");
;;;353            }
;;;354    
;;;355            keyscan_init_data();
;;;356            keyscan_init_driver(KeyScan_Debounce_Enable);
;;;357        }
;;;358    }
;;;359    
;;;360    /**
;;;361    * @brief   keyscan wakeup handler
;;;362    * @return  void
;;;363    */
;;;364    void handle_keyscan_wakeup(void)
;;;365    {
        0x00209efa:    b57c        |.      PUSH     {r2-r6,lr}
;;;366    
;;;367        Pinmux_Config(ROW0, DWGPIO);
        0x00209efc:    215a        Z!      MOVS     r1,#0x5a
        0x00209efe:    201a        .       MOVS     r0,#0x1a
        0x00209f00:    f607fa38    ..8.    BL       Pinmux_Config ; 0x11374
;;;368        Pinmux_Config(ROW1, DWGPIO);
        0x00209f04:    215a        Z!      MOVS     r1,#0x5a
        0x00209f06:    201b        .       MOVS     r0,#0x1b
        0x00209f08:    f607fa34    ..4.    BL       Pinmux_Config ; 0x11374
;;;369        Pinmux_Config(ROW2, DWGPIO);
        0x00209f0c:    215a        Z!      MOVS     r1,#0x5a
        0x00209f0e:    201c        .       MOVS     r0,#0x1c
        0x00209f10:    f607fa30    ..0.    BL       Pinmux_Config ; 0x11374
;;;370        Pinmux_Config(ROW3, DWGPIO);
        0x00209f14:    215a        Z!      MOVS     r1,#0x5a
        0x00209f16:    2019        .       MOVS     r0,#0x19
        0x00209f18:    f607fa2c    ..,.    BL       Pinmux_Config ; 0x11374
;;;371    
;;;372        Pad_Config(ROW0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209f1c:    2400        .$      MOVS     r4,#0
        0x00209f1e:    2301        .#      MOVS     r3,#1
        0x00209f20:    9400        ..      STR      r4,[sp,#0]
        0x00209f22:    461a        .F      MOV      r2,r3
        0x00209f24:    4619        .F      MOV      r1,r3
        0x00209f26:    201a        .       MOVS     r0,#0x1a
        0x00209f28:    9401        ..      STR      r4,[sp,#4]
        0x00209f2a:    f607fa57    ..W.    BL       Pad_Config ; 0x113dc
;;;373        Pad_Config(ROW1, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209f2e:    2301        .#      MOVS     r3,#1
        0x00209f30:    9400        ..      STR      r4,[sp,#0]
        0x00209f32:    461a        .F      MOV      r2,r3
        0x00209f34:    4619        .F      MOV      r1,r3
        0x00209f36:    201b        .       MOVS     r0,#0x1b
        0x00209f38:    9401        ..      STR      r4,[sp,#4]
        0x00209f3a:    f607fa4f    ..O.    BL       Pad_Config ; 0x113dc
;;;374        Pad_Config(ROW2, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209f3e:    2301        .#      MOVS     r3,#1
        0x00209f40:    9400        ..      STR      r4,[sp,#0]
        0x00209f42:    461a        .F      MOV      r2,r3
        0x00209f44:    4619        .F      MOV      r1,r3
        0x00209f46:    201c        .       MOVS     r0,#0x1c
        0x00209f48:    9401        ..      STR      r4,[sp,#4]
        0x00209f4a:    f607fa47    ..G.    BL       Pad_Config ; 0x113dc
;;;375        Pad_Config(ROW3, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00209f4e:    2301        .#      MOVS     r3,#1
        0x00209f50:    9400        ..      STR      r4,[sp,#0]
        0x00209f52:    461a        .F      MOV      r2,r3
        0x00209f54:    4619        .F      MOV      r1,r3
        0x00209f56:    2019        .       MOVS     r0,#0x19
        0x00209f58:    9401        ..      STR      r4,[sp,#4]
        0x00209f5a:    f607fa3f    ..?.    BL       Pad_Config ; 0x113dc
;;; ..\..\..\inc\peripheral\rtl876x_gpio.h
;;;406        return GPIO->DATAIN;
        0x00209f5e:    4827        'H      LDR      r0,[pc,#156] ; [0x209ffc] = 0x40001000
        0x00209f60:    6d05        .m      LDR      r5,[r0,#0x50]
;;; ..\..\..\src\app\keyboard\keyscan.c
;;;380        gpio_pin = GPIO_GetPin(ROW0) | GPIO_GetPin(ROW1) | GPIO_GetPin(ROW2) | GPIO_GetPin(ROW3);
        0x00209f62:    201a        .       MOVS     r0,#0x1a
        0x00209f64:    f7feff49    ..I.    BL       GPIO_GetPin ; 0x208dfa
        0x00209f68:    4606        .F      MOV      r6,r0
        0x00209f6a:    201b        .       MOVS     r0,#0x1b
        0x00209f6c:    f7feff45    ..E.    BL       GPIO_GetPin ; 0x208dfa
        0x00209f70:    4306        .C      ORRS     r6,r6,r0
        0x00209f72:    201c        .       MOVS     r0,#0x1c
        0x00209f74:    f7feff41    ..A.    BL       GPIO_GetPin ; 0x208dfa
        0x00209f78:    4306        .C      ORRS     r6,r6,r0
        0x00209f7a:    2019        .       MOVS     r0,#0x19
        0x00209f7c:    f7feff3d    ..=.    BL       GPIO_GetPin ; 0x208dfa
        0x00209f80:    4306        .C      ORRS     r6,r6,r0
;;;381    
;;;382        keyscan_pinmux_config();
        0x00209f82:    f7fffdc2    ....    BL       keyscan_pinmux_config ; 0x209b0a
;;;383        keyscan_pad_config();
        0x00209f86:    f7fffd7d    ..}.    BL       keyscan_pad_config ; 0x209a84
;;;384    
;;;385        if (gpio_pin != (gpio_pin & gpio_data))
        0x00209f8a:    ea360005    6...    BICS     r0,r6,r5
        0x00209f8e:    d01c        ..      BEQ      0x209fca ; handle_keyscan_wakeup + 208
;;;386        {
;;;387            APP_PRINT_INFO2("wake up by keyscan, pin =0x%x, gpio input = 0x%x", gpio_pin, gpio_data);
        0x00209f90:    4915        .I      LDR      r1,[pc,#84] ; [0x209fe8] = 0x8800fac
        0x00209f92:    4633        3F      MOV      r3,r6
        0x00209f94:    2202        ."      MOVS     r2,#2
        0x00209f96:    3184        .1      ADDS     r1,r1,#0x84
        0x00209f98:    4811        .H      LDR      r0,[pc,#68] ; [0x209fe0] = 0x21103002
        0x00209f9a:    9500        ..      STR      r5,[sp,#0]
        0x00209f9c:    f5fdfd5f    .._.    BL       log_buffer ; 0x7a5e
;;;388            keyscan_init_driver(KeyScan_Debounce_Disable);
        0x00209fa0:    2000        .       MOVS     r0,#0
        0x00209fa2:    f7fffe66    ..f.    BL       keyscan_init_driver ; 0x209c72
;;;389            keyscan_global_data.is_allowed_to_enter_dlps = false;
        0x00209fa6:    4d09        .M      LDR      r5,[pc,#36] ; [0x209fcc] = 0x20bc98
        0x00209fa8:    2132        2!      MOVS     r1,#0x32
        0x00209faa:    1f28        (.      SUBS     r0,r5,#4
        0x00209fac:    706c        lp      STRB     r4,[r5,#1]
;;;390            /* not allow to enter DLPS before interrupt or timeout */
;;;391            /* Set flag and start timer to handle unexpection condition:
;;;392               1. Not Keyscan row PAD wake up system;
;;;393               2. PAD wake up signal disappear before Keyscan works; */
;;;394            keyscan_global_data.is_key_pressed = true;
        0x00209fae:    2401        .$      MOVS     r4,#1
        0x00209fb0:    70ac        .p      STRB     r4,[r5,#2]
;;;395            if (!os_timer_restart(&keyscan_timer, KEYSCAN_SW_INTERVAL))
        0x00209fb2:    f61cfe44    ..D.    BL       os_timer_restart ; 0x26c3e
        0x00209fb6:    2800        .(      CMP      r0,#0
        0x00209fb8:    d107        ..      BNE      0x209fca ; handle_keyscan_wakeup + 208
;;;396            {
;;;397                APP_PRINT_ERROR0("[System_Handler] xTimersKeyScan restart failed!");
        0x00209fba:    490b        .I      LDR      r1,[pc,#44] ; [0x209fe8] = 0x8800fac
        0x00209fbc:    4808        .H      LDR      r0,[pc,#32] ; [0x209fe0] = 0x21103002
        0x00209fbe:    2200        ."      MOVS     r2,#0
        0x00209fc0:    31b8        .1      ADDS     r1,r1,#0xb8
        0x00209fc2:    1e80        ..      SUBS     r0,r0,#2
        0x00209fc4:    f5fdfd4b    ..K.    BL       log_buffer ; 0x7a5e
;;;398                keyscan_global_data.is_allowed_to_enter_dlps = true;
        0x00209fc8:    706c        lp      STRB     r4,[r5,#1]
;;;399            }
;;;400        }
;;;401    
;;;402    
;;;403    
;;;404    
;;;405    }
        0x00209fca:    bd7c        |.      POP      {r2-r6,pc}
    $d
        0x00209fcc:    0020bc98    .. .    DCD    2145432
        0x00209fd0:    60000040    @..`    DCD    1610612800
        0x00209fd4:    08080000    ....    DCD    134742016
        0x00209fd8:    40005000    .P.@    DCD    1073762304
        0x00209fdc:    08800d20     ...    DCD    142609696
        0x00209fe0:    21103002    .0.!    DCD    554708994
        0x00209fe4:    08800e8c    ....    DCD    142610060
        0x00209fe8:    08800fac    ....    DCD    142610348
        0x00209fec:    7379656b    keys    DCD    1937335659
        0x00209ff0:    5f6e6163    can_    DCD    1601069411
        0x00209ff4:    656d6974    time    DCD    1701669236
        0x00209ff8:    00000072    r...    DCD    114
        0x00209ffc:    40001000    ...@    DCD    1073745920
    $t
    .text
    set_passkey
;;; ..\..\..\src\app\keyboard\key_handler.c
;;;38         if (key_num < 10)
        0x0020a000:    280a        .(      CMP      r0,#0xa
        0x0020a002:    d20b        ..      BCS      0x20a01c ; set_passkey + 28
;;;39         {
;;;40             if (p_passkey->count < 6)
        0x0020a004:    790a        .y      LDRB     r2,[r1,#4]
        0x0020a006:    2a06        .*      CMP      r2,#6
        0x0020a008:    d207        ..      BCS      0x20a01a ; set_passkey + 26
;;;41             {
;;;42                 p_passkey->value = p_passkey->value * 10;
        0x0020a00a:    680b        .h      LDR      r3,[r1,#0]
        0x0020a00c:    1c52        R.      ADDS     r2,r2,#1
        0x0020a00e:    eb030383    ....    ADD      r3,r3,r3,LSL #2
;;;43                 p_passkey->value += key_num;
        0x0020a012:    eb000043    ..C.    ADD      r0,r0,r3,LSL #1
;;;44                 p_passkey->count++;
        0x0020a016:    6008        .`      STR      r0,[r1,#0]
        0x0020a018:    710a        .q      STRB     r2,[r1,#4]
        0x0020a01a:    4770        pG      BX       lr
;;;45             }
;;;46         }
;;;47         else if (key_num == 10)
        0x0020a01c:    d1fd        ..      BNE      0x20a01a ; set_passkey + 26
;;;48         {
;;;49             //delete the last input key value
;;;50             p_passkey->value = p_passkey->value / 10;
        0x0020a01e:    6808        .h      LDR      r0,[r1,#0]
        0x0020a020:    220a        ."      MOVS     r2,#0xa
        0x0020a022:    fbb0f0f2    ....    UDIV     r0,r0,r2
;;;51             if (p_passkey->count > 0)
        0x0020a026:    6008        .`      STR      r0,[r1,#0]
        0x0020a028:    7908        .y      LDRB     r0,[r1,#4]
        0x0020a02a:    2800        .(      CMP      r0,#0
        0x0020a02c:    d0f5        ..      BEQ      0x20a01a ; set_passkey + 26
        0x0020a02e:    1e40        @.      SUBS     r0,r0,#1
;;;52             {
;;;53                 p_passkey->count--;
        0x0020a030:    7108        .q      STRB     r0,[r1,#4]
;;;54             }
;;;55         }
;;;56     }
        0x0020a032:    4770        pG      BX       lr
    keyboard_handle_pair_event
;;;57     
;;;58     /******************************************************************
;;;59      * @brief    handle pair event
;;;60      */
;;;61     void keyboard_handle_pair_event(T_KEYSCAN_FIFIO_DATA *p_key_data)
;;;62     {
        0x0020a034:    e92d4ffe    -..O    PUSH     {r1-r11,lr}
        0x0020a038:    4f94        .O      LDR      r7,[pc,#592] ; [0x20a28c] = 0x21103002
        0x0020a03a:    2400        .$      MOVS     r4,#0
;;; ..\..\..\src\app\keyboard\key_handler.c (62)
        0x0020a03c:    4606        .F      MOV      r6,r0
        0x0020a03e:    46a0        .F      MOV      r8,r4
        0x0020a040:    f8df9244    ..D.    LDR      r9,[pc,#580] ; [0x20a288] = 0x20bcc4
        0x0020a044:    f1a70a02    ....    SUB      r10,r7,#2
        0x0020a048:    e0b9        ..      B        0x20a1be ; keyboard_handle_pair_event + 394
;;;63         uint8_t usage_id;
;;;64     
;;;65         for (uint8_t i = 0; i < p_key_data->len; i++)
;;;66         {
;;;67             APP_PRINT_INFO4("No.%d,Total len=%d: (row, column) = (%d, %d)", i + 1, p_key_data->len,
        0x0020a04a:    eb060544    ..D.    ADD      r5,r6,r4,LSL #1
        0x0020a04e:    1c63        c.      ADDS     r3,r4,#1
        0x0020a050:    7928        (y      LDRB     r0,[r5,#4]
        0x0020a052:    9100        ..      STR      r1,[sp,#0]
        0x0020a054:    f000021f    ....    AND      r2,r0,#0x1f
        0x0020a058:    0940        @.      LSRS     r0,r0,#5
        0x0020a05a:    e9cd0201    ....    STRD     r0,r2,[sp,#4]
        0x0020a05e:    2204        ."      MOVS     r2,#4
        0x0020a060:    498b        .I      LDR      r1,[pc,#556] ; [0x20a290] = 0x8801098
        0x0020a062:    4638        8F      MOV      r0,r7
        0x0020a064:    f5fdfcfb    ....    BL       log_buffer ; 0x7a5e
;;;68                             p_key_data->key[i].row, p_key_data->key[i].column);
;;;69             usage_id = key_map[p_key_data->key[i].row][p_key_data->key[i].column];
        0x0020a068:    7928        (y      LDRB     r0,[r5,#4]
        0x0020a06a:    4a8a        .J      LDR      r2,[pc,#552] ; [0x20a294] = 0x20b7d6
        0x0020a06c:    0941        A.      LSRS     r1,r0,#5
        0x0020a06e:    eb0201c1    ....    ADD      r1,r2,r1,LSL #3
        0x0020a072:    f000001f    ....    AND      r0,r0,#0x1f
        0x0020a076:    f8113010    ...0    LDRB     r3,[r1,r0,LSL #1]
;;;70     
;;;71             switch (usage_id)
        0x0020a07a:    f1a3001e    ....    SUB      r0,r3,#0x1e
        0x0020a07e:    280d        .(      CMP      r0,#0xd
        0x0020a080:    d279        y.      BCS      0x20a176 ; keyboard_handle_pair_event + 322
        0x0020a082:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x0020a086:    1b10        ..      DCW    6928
        0x0020a088:    3f362d24    $-6?    DCD    1060515108
        0x0020a08c:    075a5148    HQZ.    DCD    123359560
        0x0020a090:    00899463    c...    DCD    9016419
    $t
;;;72             {
;;;73             case KB_0:
;;;74                 {
;;;75                     APP_PRINT_INFO0("passKey = KB_0");
        0x0020a094:    497e        ~I      LDR      r1,[pc,#504] ; [0x20a290] = 0x8801098
        0x0020a096:    2200        ."      MOVS     r2,#0
        0x0020a098:    3130        01      ADDS     r1,r1,#0x30
        0x0020a09a:    4638        8F      MOV      r0,r7
        0x0020a09c:    f5fdfcdf    ....    BL       log_buffer ; 0x7a5e
;;;76                     set_passkey(0, &passkey);
        0x0020a0a0:    4979        yI      LDR      r1,[pc,#484] ; [0x20a288] = 0x20bcc4
        0x0020a0a2:    2000        .       MOVS     r0,#0
;;;77                     break;
        0x0020a0a4:    e007        ..      B        0x20a0b6 ; keyboard_handle_pair_event + 130
;;;78                 }
;;;79             case KB_1:
;;;80                 {
;;;81                     APP_PRINT_INFO0("passKey = KB_1");
        0x0020a0a6:    497a        zI      LDR      r1,[pc,#488] ; [0x20a290] = 0x8801098
        0x0020a0a8:    2200        ."      MOVS     r2,#0
        0x0020a0aa:    3144        D1      ADDS     r1,r1,#0x44
        0x0020a0ac:    4638        8F      MOV      r0,r7
        0x0020a0ae:    f5fdfcd6    ....    BL       log_buffer ; 0x7a5e
;;;82                     set_passkey(1, &passkey);
        0x0020a0b2:    4975        uI      LDR      r1,[pc,#468] ; [0x20a288] = 0x20bcc4
        0x0020a0b4:    2001        .       MOVS     r0,#1
        0x0020a0b6:    f7ffffa3    ....    BL       set_passkey ; 0x20a000
        0x0020a0ba:    e07e        ~.      B        0x20a1ba ; keyboard_handle_pair_event + 390
;;;83                     break;
;;;84                 }
;;;85             case KB_2:
;;;86                 {
;;;87                     APP_PRINT_INFO0("passKey = KB_2");
        0x0020a0bc:    4974        tI      LDR      r1,[pc,#464] ; [0x20a290] = 0x8801098
        0x0020a0be:    2200        ."      MOVS     r2,#0
        0x0020a0c0:    3158        X1      ADDS     r1,r1,#0x58
        0x0020a0c2:    4638        8F      MOV      r0,r7
        0x0020a0c4:    f5fdfccb    ....    BL       log_buffer ; 0x7a5e
;;;88                     set_passkey(2, &passkey);
        0x0020a0c8:    496f        oI      LDR      r1,[pc,#444] ; [0x20a288] = 0x20bcc4
        0x0020a0ca:    2002        .       MOVS     r0,#2
;;;89                     break;
        0x0020a0cc:    e7f3        ..      B        0x20a0b6 ; keyboard_handle_pair_event + 130
;;;90                 }
;;;91             case KB_3:
;;;92                 {
;;;93                     APP_PRINT_INFO0("passKey = KB_3");
        0x0020a0ce:    4970        pI      LDR      r1,[pc,#448] ; [0x20a290] = 0x8801098
        0x0020a0d0:    2200        ."      MOVS     r2,#0
        0x0020a0d2:    316c        l1      ADDS     r1,r1,#0x6c
        0x0020a0d4:    4638        8F      MOV      r0,r7
        0x0020a0d6:    f5fdfcc2    ....    BL       log_buffer ; 0x7a5e
;;;94                     set_passkey(3, &passkey);
        0x0020a0da:    496b        kI      LDR      r1,[pc,#428] ; [0x20a288] = 0x20bcc4
        0x0020a0dc:    2003        .       MOVS     r0,#3
;;;95                     break;
        0x0020a0de:    e7ea        ..      B        0x20a0b6 ; keyboard_handle_pair_event + 130
;;;96                 }
;;;97             case KB_4:
;;;98                 {
;;;99                     APP_PRINT_INFO0("passKey = KB_4");
        0x0020a0e0:    496b        kI      LDR      r1,[pc,#428] ; [0x20a290] = 0x8801098
        0x0020a0e2:    2200        ."      MOVS     r2,#0
        0x0020a0e4:    3180        .1      ADDS     r1,r1,#0x80
        0x0020a0e6:    4638        8F      MOV      r0,r7
        0x0020a0e8:    f5fdfcb9    ....    BL       log_buffer ; 0x7a5e
;;;100                    set_passkey(4, &passkey);
        0x0020a0ec:    4966        fI      LDR      r1,[pc,#408] ; [0x20a288] = 0x20bcc4
        0x0020a0ee:    2004        .       MOVS     r0,#4
;;;101                    break;
        0x0020a0f0:    e7e1        ..      B        0x20a0b6 ; keyboard_handle_pair_event + 130
;;;102                }
;;;103            case KB_5:
;;;104                {
;;;105                    APP_PRINT_INFO0("passKey = KB_5");
        0x0020a0f2:    4967        gI      LDR      r1,[pc,#412] ; [0x20a290] = 0x8801098
        0x0020a0f4:    2200        ."      MOVS     r2,#0
        0x0020a0f6:    3194        .1      ADDS     r1,r1,#0x94
        0x0020a0f8:    4638        8F      MOV      r0,r7
        0x0020a0fa:    f5fdfcb0    ....    BL       log_buffer ; 0x7a5e
;;;106                    set_passkey(5, &passkey);
        0x0020a0fe:    4962        bI      LDR      r1,[pc,#392] ; [0x20a288] = 0x20bcc4
        0x0020a100:    2005        .       MOVS     r0,#5
;;;107                    break;
        0x0020a102:    e7d8        ..      B        0x20a0b6 ; keyboard_handle_pair_event + 130
;;;108                }
;;;109    
;;;110            case KB_6:
;;;111                {
;;;112                    APP_PRINT_INFO0("passKey = KB_6");
        0x0020a104:    4962        bI      LDR      r1,[pc,#392] ; [0x20a290] = 0x8801098
        0x0020a106:    2200        ."      MOVS     r2,#0
        0x0020a108:    31a8        .1      ADDS     r1,r1,#0xa8
        0x0020a10a:    4638        8F      MOV      r0,r7
        0x0020a10c:    f5fdfca7    ....    BL       log_buffer ; 0x7a5e
;;;113                    set_passkey(6, &passkey);
        0x0020a110:    495d        ]I      LDR      r1,[pc,#372] ; [0x20a288] = 0x20bcc4
        0x0020a112:    2006        .       MOVS     r0,#6
;;;114                    break;
        0x0020a114:    e7cf        ..      B        0x20a0b6 ; keyboard_handle_pair_event + 130
;;;115                }
;;;116            case KB_7:
;;;117                {
;;;118                    APP_PRINT_INFO0("passKey = KB_7");
        0x0020a116:    495e        ^I      LDR      r1,[pc,#376] ; [0x20a290] = 0x8801098
        0x0020a118:    2200        ."      MOVS     r2,#0
        0x0020a11a:    31bc        .1      ADDS     r1,r1,#0xbc
        0x0020a11c:    4638        8F      MOV      r0,r7
        0x0020a11e:    f5fdfc9e    ....    BL       log_buffer ; 0x7a5e
;;;119                    set_passkey(7, &passkey);
        0x0020a122:    4959        YI      LDR      r1,[pc,#356] ; [0x20a288] = 0x20bcc4
        0x0020a124:    2007        .       MOVS     r0,#7
;;;120                    break;
        0x0020a126:    e7c6        ..      B        0x20a0b6 ; keyboard_handle_pair_event + 130
;;;121                }
;;;122            case KB_8:
;;;123                {
;;;124                    APP_PRINT_INFO0("passKey = KB_8");
        0x0020a128:    4959        YI      LDR      r1,[pc,#356] ; [0x20a290] = 0x8801098
        0x0020a12a:    2200        ."      MOVS     r2,#0
        0x0020a12c:    31d0        .1      ADDS     r1,r1,#0xd0
        0x0020a12e:    4638        8F      MOV      r0,r7
        0x0020a130:    f5fdfc95    ....    BL       log_buffer ; 0x7a5e
;;;125                    set_passkey(8, &passkey);
        0x0020a134:    4954        TI      LDR      r1,[pc,#336] ; [0x20a288] = 0x20bcc4
        0x0020a136:    2008        .       MOVS     r0,#8
;;;126                    break;
        0x0020a138:    e7bd        ..      B        0x20a0b6 ; keyboard_handle_pair_event + 130
;;;127                }
;;;128            case KB_9:
;;;129                {
;;;130                    APP_PRINT_INFO0("passKey = KB_9");
        0x0020a13a:    4955        UI      LDR      r1,[pc,#340] ; [0x20a290] = 0x8801098
        0x0020a13c:    2200        ."      MOVS     r2,#0
        0x0020a13e:    31e4        .1      ADDS     r1,r1,#0xe4
        0x0020a140:    4638        8F      MOV      r0,r7
        0x0020a142:    f5fdfc8c    ....    BL       log_buffer ; 0x7a5e
;;;131                    set_passkey(9, &passkey);
        0x0020a146:    4950        PI      LDR      r1,[pc,#320] ; [0x20a288] = 0x20bcc4
        0x0020a148:    2009        .       MOVS     r0,#9
;;;132                    break;
        0x0020a14a:    e7b4        ..      B        0x20a0b6 ; keyboard_handle_pair_event + 130
;;;133                }
;;;134            case KB_Return_ENTER:
;;;135                {
;;;136                    APP_PRINT_INFO0("passKey = KB_Return_ENTER\n\n");
        0x0020a14c:    4950        PI      LDR      r1,[pc,#320] ; [0x20a290] = 0x8801098
        0x0020a14e:    2200        ."      MOVS     r2,#0
        0x0020a150:    31f8        .1      ADDS     r1,r1,#0xf8
        0x0020a152:    4638        8F      MOV      r0,r7
        0x0020a154:    f5fdfc83    ....    BL       log_buffer ; 0x7a5e
;;;137                    if (passkey.count == 6)
        0x0020a158:    f8990004    ....    LDRB     r0,[r9,#4]
        0x0020a15c:    464d        MF      MOV      r5,r9
        0x0020a15e:    2806        .(      CMP      r0,#6
        0x0020a160:    d00a        ..      BEQ      0x20a178 ; keyboard_handle_pair_event + 324
        0x0020a162:    2200        ."      MOVS     r2,#0
        0x0020a164:    494c        LI      LDR      r1,[pc,#304] ; [0x20a298] = 0x88011c0
        0x0020a166:    4650        PF      MOV      r0,r10
        0x0020a168:    f5fdfc79    ..y.    BL       log_buffer ; 0x7a5e
        0x0020a16c:    f8858004    ....    STRB     r8,[r5,#4]
        0x0020a170:    f8c58000    ....    STR      r8,[r5,#0]
        0x0020a174:    e021        !.      B        0x20a1ba ; keyboard_handle_pair_event + 390
        0x0020a176:    e01a        ..      B        0x20a1ae ; keyboard_handle_pair_event + 378
;;;138                    {
;;;139                        APP_PRINT_INFO1("passKey = %d", passkey.value);
        0x0020a178:    4947        GI      LDR      r1,[pc,#284] ; [0x20a298] = 0x88011c0
        0x0020a17a:    2201        ."      MOVS     r2,#1
        0x0020a17c:    3910        .9      SUBS     r1,r1,#0x10
        0x0020a17e:    4638        8F      MOV      r0,r7
        0x0020a180:    682b        +h      LDR      r3,[r5,#0]
        0x0020a182:    f5fdfc6c    ..l.    BL       log_buffer ; 0x7a5e
;;;140                        le_bond_passkey_input_confirm(keyboard_con_id, passkey.value, GAP_CFM_CAUSE_ACCEPT);
        0x0020a186:    4845        EH      LDR      r0,[pc,#276] ; [0x20a29c] = 0x20bc90
        0x0020a188:    2201        ."      MOVS     r2,#1
        0x0020a18a:    6829        )h      LDR      r1,[r5,#0]
        0x0020a18c:    7800        .x      LDRB     r0,[r0,#0]
        0x0020a18e:    f642f8f8    B...    BL       le_bond_passkey_input_confirm ; 0x4c382
;;;141                        passkey.enable_input = false;
        0x0020a192:    f8858005    ....    STRB     r8,[r5,#5]
        0x0020a196:    e7e9        ..      B        0x20a16c ; keyboard_handle_pair_event + 312
;;;142                    }
;;;143                    else
;;;144                    {
;;;145                        APP_PRINT_ERROR0("Error: The passkey length is not equal to six, please input again.\n");
;;;146                    }
;;;147                    // clear passkey data
;;;148                    passkey.count = 0;
;;;149                    passkey.value = 0;
;;;150                    break;
;;;151                }
;;;152    
;;;153            case KB_DELETE_Backspace:
;;;154                {
;;;155                    set_passkey(10, &passkey);
        0x0020a198:    493b        ;I      LDR      r1,[pc,#236] ; [0x20a288] = 0x20bcc4
        0x0020a19a:    200a        .       MOVS     r0,#0xa
        0x0020a19c:    f7ffff30    ..0.    BL       set_passkey ; 0x20a000
;;;156                    APP_PRINT_INFO0("Delete the last input key value");
        0x0020a1a0:    493d        =I      LDR      r1,[pc,#244] ; [0x20a298] = 0x88011c0
        0x0020a1a2:    2200        ."      MOVS     r2,#0
        0x0020a1a4:    3148        H1      ADDS     r1,r1,#0x48
        0x0020a1a6:    4638        8F      MOV      r0,r7
        0x0020a1a8:    f5fdfc59    ..Y.    BL       log_buffer ; 0x7a5e
;;;157                    break;
        0x0020a1ac:    e005        ..      B        0x20a1ba ; keyboard_handle_pair_event + 390
;;;158                }
;;;159    
;;;160            default:
;;;161                {
;;;162                    APP_PRINT_ERROR1("Invalid Passkey keyCode: 0x%x\n\n", usage_id);
        0x0020a1ae:    493a        :I      LDR      r1,[pc,#232] ; [0x20a298] = 0x88011c0
        0x0020a1b0:    2201        ."      MOVS     r2,#1
        0x0020a1b2:    316c        l1      ADDS     r1,r1,#0x6c
        0x0020a1b4:    4650        PF      MOV      r0,r10
        0x0020a1b6:    f5fdfc52    ..R.    BL       log_buffer ; 0x7a5e
        0x0020a1ba:    1c64        d.      ADDS     r4,r4,#1
        0x0020a1bc:    b2e4        ..      UXTB     r4,r4
        0x0020a1be:    6831        1h      LDR      r1,[r6,#0]
        0x0020a1c0:    42a1        .B      CMP      r1,r4
        0x0020a1c2:    f63faf42    ?.B.    BHI      0x20a04a ; keyboard_handle_pair_event + 22
;;;163                    break;
;;;164                }
;;;165            }
;;;166        }
;;;167    }
        0x0020a1c6:    e8bd8ffe    ....    POP      {r1-r11,pc}
    keyboard_handle_press_event
;;;168    
;;;169    /******************************************************************
;;;170     * @brief    handle keyscan press event
;;;171     */
;;;172    void keyboard_handle_press_event(T_KEYSCAN_FIFIO_DATA *p_key_data)
;;;173    {
        0x0020a1ca:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0020a1ce:    b086        ..      SUB      sp,sp,#0x18
        0x0020a1d0:    2500        .%      MOVS     r5,#0
        0x0020a1d2:    4606        .F      MOV      r6,r0
        0x0020a1d4:    9503        ..      STR      r5,[sp,#0xc]
        0x0020a1d6:    462c        ,F      MOV      r4,r5
        0x0020a1d8:    f04f0801    O...    MOV      r8,#1
        0x0020a1dc:    9504        ..      STR      r5,[sp,#0x10]
        0x0020a1de:    e031        1.      B        0x20a244 ; keyboard_handle_press_event + 122
;;;174        uint8_t keycount = 0;
;;;175        uint16_t usage_id;
;;;176        uint8_t keyboard_data[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;;;177    
;;;178    
;;;179        for (uint8_t i = 0; i < p_key_data->len; i++)
;;;180        {
;;;181            APP_PRINT_INFO4("No.%d,Total len=%d: (row, column) = (%d, %d)", i + 1, p_key_data->len,
        0x0020a1e0:    eb060744    ..D.    ADD      r7,r6,r4,LSL #1
        0x0020a1e4:    1c63        c.      ADDS     r3,r4,#1
        0x0020a1e6:    7938        8y      LDRB     r0,[r7,#4]
        0x0020a1e8:    9100        ..      STR      r1,[sp,#0]
        0x0020a1ea:    f000021f    ....    AND      r2,r0,#0x1f
        0x0020a1ee:    0940        @.      LSRS     r0,r0,#5
        0x0020a1f0:    e9cd0201    ....    STRD     r0,r2,[sp,#4]
        0x0020a1f4:    4928        (I      LDR      r1,[pc,#160] ; [0x20a298] = 0x88011c0
        0x0020a1f6:    2204        ."      MOVS     r2,#4
        0x0020a1f8:    3190        .1      ADDS     r1,r1,#0x90
        0x0020a1fa:    4824        $H      LDR      r0,[pc,#144] ; [0x20a28c] = 0x21103002
        0x0020a1fc:    f5fdfc2f    ../.    BL       log_buffer ; 0x7a5e
;;;182                            p_key_data->key[i].row, p_key_data->key[i].column);
;;;183            usage_id = key_map[p_key_data->key[i].row][p_key_data->key[i].column];
        0x0020a200:    7938        8y      LDRB     r0,[r7,#4]
        0x0020a202:    4a24        $J      LDR      r2,[pc,#144] ; [0x20a294] = 0x20b7d6
        0x0020a204:    0941        A.      LSRS     r1,r0,#5
        0x0020a206:    eb0201c1    ....    ADD      r1,r2,r1,LSL #3
        0x0020a20a:    f000001f    ....    AND      r0,r0,#0x1f
        0x0020a20e:    f8311010    1...    LDRH     r1,[r1,r0,LSL #1]
;;;184    
;;;185            /********Normal Keys**********/
;;;186            if (usage_id <= 0xA4)
        0x0020a212:    29a4        .)      CMP      r1,#0xa4
        0x0020a214:    d807        ..      BHI      0x20a226 ; keyboard_handle_press_event + 92
;;;187            {
;;;188                if (keycount < 6)
        0x0020a216:    2d06        .-      CMP      r5,#6
        0x0020a218:    d212        ..      BCS      0x20a240 ; keyboard_handle_press_event + 118
;;;189                {
;;;190                    keyboard_data[2 + keycount] = usage_id;
        0x0020a21a:    a803        ..      ADD      r0,sp,#0xc
        0x0020a21c:    4428        (D      ADD      r0,r0,r5
        0x0020a21e:    1c6d        m.      ADDS     r5,r5,#1
        0x0020a220:    7081        .p      STRB     r1,[r0,#2]
;;;191                    keycount++;
        0x0020a222:    b2ed        ..      UXTB     r5,r5
        0x0020a224:    e00c        ..      B        0x20a240 ; keyboard_handle_press_event + 118
;;;192                }
;;;193            }
;;;194            /*********Modifier Keys********/
;;;195            else if ((usage_id >= 0xE0) && (usage_id <= 0xE7))
        0x0020a226:    f1a100e0    ....    SUB      r0,r1,#0xe0
        0x0020a22a:    2807        .(      CMP      r0,#7
        0x0020a22c:    d808        ..      BHI      0x20a240 ; keyboard_handle_press_event + 118
;;;196            {
;;;197                keyboard_data[0] |= 1 << (usage_id & 0x07);
        0x0020a22e:    f89d000c    ....    LDRB     r0,[sp,#0xc]
        0x0020a232:    f0010207    ....    AND      r2,r1,#7
        0x0020a236:    fa08f102    ....    LSL      r1,r8,r2
        0x0020a23a:    4308        .C      ORRS     r0,r0,r1
        0x0020a23c:    f88d000c    ....    STRB     r0,[sp,#0xc]
        0x0020a240:    1c64        d.      ADDS     r4,r4,#1
        0x0020a242:    b2e4        ..      UXTB     r4,r4
        0x0020a244:    6831        1h      LDR      r1,[r6,#0]
        0x0020a246:    42a1        .B      CMP      r1,r4
        0x0020a248:    d8ca        ..      BHI      0x20a1e0 ; keyboard_handle_press_event + 22
;;;198            }
;;;199        }
;;;200    
;;;201        server_send_data(keyboard_con_id, hid_srv_id, GATT_SVC_HID_REPORT_INPUT_INDEX,
        0x0020a24a:    2108        .!      MOVS     r1,#8
        0x0020a24c:    4814        .H      LDR      r0,[pc,#80] ; [0x20a2a0] = 0x20bc8d
        0x0020a24e:    e9cd1800    ....    STRD     r1,r8,[sp,#0]
        0x0020a252:    7801        .x      LDRB     r1,[r0,#0]
        0x0020a254:    4811        .H      LDR      r0,[pc,#68] ; [0x20a29c] = 0x20bc90
        0x0020a256:    ab03        ..      ADD      r3,sp,#0xc
        0x0020a258:    2204        ."      MOVS     r2,#4
        0x0020a25a:    7800        .x      LDRB     r0,[r0,#0]
        0x0020a25c:    f645faa2    E...    BL       server_send_data ; 0x4f7a4
;;;202                         keyboard_data, sizeof(keyboard_data), GATT_PDU_TYPE_NOTIFICATION);
;;;203    }
        0x0020a260:    b006        ..      ADD      sp,sp,#0x18
        0x0020a262:    e8bd81f0    ....    POP      {r4-r8,pc}
    keyboard_handle_release_event
;;;204    
;;;205    /******************************************************************
;;;206     * @brief    handle keyscan release event
;;;207     */
;;;208    void keyboard_handle_release_event(void)
;;;209    {
        0x0020a266:    b51f        ..      PUSH     {r0-r4,lr}
;;;210        uint8_t keyboard_data[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
        0x0020a268:    2000        .       MOVS     r0,#0
        0x0020a26a:    9002        ..      STR      r0,[sp,#8]
;;;211        server_send_data(keyboard_con_id, hid_srv_id, GATT_SVC_HID_REPORT_INPUT_INDEX,
        0x0020a26c:    9003        ..      STR      r0,[sp,#0xc]
        0x0020a26e:    2101        .!      MOVS     r1,#1
        0x0020a270:    2008        .       MOVS     r0,#8
        0x0020a272:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0020a276:    480a        .H      LDR      r0,[pc,#40] ; [0x20a2a0] = 0x20bc8d
        0x0020a278:    ab02        ..      ADD      r3,sp,#8
        0x0020a27a:    2204        ."      MOVS     r2,#4
        0x0020a27c:    7801        .x      LDRB     r1,[r0,#0]
        0x0020a27e:    4807        .H      LDR      r0,[pc,#28] ; [0x20a29c] = 0x20bc90
        0x0020a280:    7800        .x      LDRB     r0,[r0,#0]
        0x0020a282:    f645fa8f    E...    BL       server_send_data ; 0x4f7a4
;;;212                         keyboard_data, sizeof(keyboard_data), GATT_PDU_TYPE_NOTIFICATION);
;;;213    }
        0x0020a286:    bd1f        ..      POP      {r0-r4,pc}
    $d
        0x0020a288:    0020bcc4    .. .    DCD    2145476
        0x0020a28c:    21103002    .0.!    DCD    554708994
        0x0020a290:    08801098    ....    DCD    142610584
        0x0020a294:    0020b7d6    .. .    DCD    2144214
        0x0020a298:    088011c0    ....    DCD    142610880
        0x0020a29c:    0020bc90    .. .    DCD    2145424
        0x0020a2a0:    0020bc8d    .. .    DCD    2145421
    $t
    .text
    gpio_button_pinmux_config
;;; ..\..\..\src\app\keyboard\keyboard_button.c
;;;41         Pinmux_Config(PAIR_BUTTON, DWGPIO);
        0x0020a2a4:    215a        Z!      MOVS     r1,#0x5a
        0x0020a2a6:    2014        .       MOVS     r0,#0x14
        0x0020a2a8:    f607b864    ..d.    B        Pinmux_Config ; 0x11374
    gpio_button_pad_config
;;;42     }
;;;43     
;;;44     /**
;;;45     * @brief   gpio button pad config
;;;46     * @return  void
;;;47     */
;;;48     void gpio_button_pad_config(void)
;;;49     {
        0x0020a2ac:    b51c        ..      PUSH     {r2-r4,lr}
;;;50         Pad_Config(PAIR_BUTTON, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0020a2ae:    2000        .       MOVS     r0,#0
        0x0020a2b0:    2301        .#      MOVS     r3,#1
        0x0020a2b2:    9000        ..      STR      r0,[sp,#0]
        0x0020a2b4:    9001        ..      STR      r0,[sp,#4]
        0x0020a2b6:    461a        .F      MOV      r2,r3
        0x0020a2b8:    4619        .F      MOV      r1,r3
        0x0020a2ba:    2014        .       MOVS     r0,#0x14
        0x0020a2bc:    f607f88e    ....    BL       Pad_Config ; 0x113dc
;;;51         System_WakeUpPinEnable(PAIR_BUTTON, PAD_WAKEUP_POL_LOW, PAD_WK_DEBOUNCE_ENABLE);
        0x0020a2c0:    b002        ..      ADD      sp,sp,#8
        0x0020a2c2:    2201        ."      MOVS     r2,#1
        0x0020a2c4:    e8bd4010    ...@    POP      {r4,lr}
        0x0020a2c8:    4611        .F      MOV      r1,r2
        0x0020a2ca:    2014        .       MOVS     r0,#0x14
        0x0020a2cc:    f607b917    ....    B        System_WakeUpPinEnable ; 0x114fe
    gpio_button_enter_dlps_config
;;;52     }
;;;53     
;;;54     /**
;;;55     * @brief   gpio button pad enter dlps config
;;;56     * @return  void
;;;57     */
;;;58     void gpio_button_enter_dlps_config(void)
;;;59     {
        0x0020a2d0:    b51c        ..      PUSH     {r2-r4,lr}
;;;60         Pad_Config(PAIR_BUTTON, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0020a2d2:    2000        .       MOVS     r0,#0
        0x0020a2d4:    9000        ..      STR      r0,[sp,#0]
        0x0020a2d6:    2301        .#      MOVS     r3,#1
        0x0020a2d8:    4601        .F      MOV      r1,r0
        0x0020a2da:    9001        ..      STR      r0,[sp,#4]
        0x0020a2dc:    461a        .F      MOV      r2,r3
        0x0020a2de:    2014        .       MOVS     r0,#0x14
        0x0020a2e0:    f607f87c    ..|.    BL       Pad_Config ; 0x113dc
;;;61     }
        0x0020a2e4:    bd1c        ..      POP      {r2-r4,pc}
    gpio_button_exit_dlps_config
;;;62     
;;;63     /**
;;;64     * @brief   gpio button pad exit dlps config
;;;65     * @return  void
;;;66     */
;;;67     void gpio_button_exit_dlps_config(void)
;;;68     {
        0x0020a2e6:    b51c        ..      PUSH     {r2-r4,lr}
;;;69         Pad_Config(PAIR_BUTTON, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0020a2e8:    2000        .       MOVS     r0,#0
        0x0020a2ea:    2301        .#      MOVS     r3,#1
        0x0020a2ec:    9000        ..      STR      r0,[sp,#0]
        0x0020a2ee:    9001        ..      STR      r0,[sp,#4]
        0x0020a2f0:    461a        .F      MOV      r2,r3
        0x0020a2f2:    4619        .F      MOV      r1,r3
        0x0020a2f4:    2014        .       MOVS     r0,#0x14
        0x0020a2f6:    f607f871    ..q.    BL       Pad_Config ; 0x113dc
;;;70     }
        0x0020a2fa:    bd1c        ..      POP      {r2-r4,pc}
    keyboard_button_init
;;;71     
;;;72     /**
;;;73     * @brief  keyboard button initialization function.
;;;74     * @param   GPIO_INT_PARAM.
;;;75     * @return  void
;;;76     */
;;;77     void keyboard_button_init(void)
;;;78     {
        0x0020a2fc:    b510        ..      PUSH     {r4,lr}
        0x0020a2fe:    b088        ..      SUB      sp,sp,#0x20
;;;79         /* Enable GPIO and hardware timer's clock */
;;;80         RCC_PeriphClockCmd(APBPeriph_GPIO,  APBPeriph_GPIO_CLOCK,  ENABLE);
        0x0020a300:    2201        ."      MOVS     r2,#1
        0x0020a302:    f04f5104    O..Q    MOV      r1,#0x21000000
        0x0020a306:    488a        .H      LDR      r0,[pc,#552] ; [0x20a530] = 0xc000100
        0x0020a308:    f7fefb44    ..D.    BL       RCC_PeriphClockCmd ; 0x208994
;;;81     
;;;82         /* Initialize GPIO as interrupt mode */
;;;83         GPIO_InitTypeDef GPIO_Param;
;;;84         GPIO_StructInit(&GPIO_Param);
        0x0020a30c:    4668        hF      MOV      r0,sp
        0x0020a30e:    f7fefd52    ..R.    BL       GPIO_StructInit ; 0x208db6
;;;85         GPIO_Param.GPIO_Pin = GPIO_GetPin(PAIR_BUTTON);
        0x0020a312:    2014        .       MOVS     r0,#0x14
        0x0020a314:    f7fefd71    ..q.    BL       GPIO_GetPin ; 0x208dfa
;;;86         GPIO_Param.GPIO_Mode = GPIO_Mode_IN;
        0x0020a318:    9000        ..      STR      r0,[sp,#0]
        0x0020a31a:    2000        .       MOVS     r0,#0
        0x0020a31c:    2401        .$      MOVS     r4,#1
        0x0020a31e:    f88d0004    ....    STRB     r0,[sp,#4]
;;;87         GPIO_Param.GPIO_ITCmd = ENABLE;
        0x0020a322:    f88d4005    ...@    STRB     r4,[sp,#5]
;;;88         GPIO_Param.GPIO_ITTrigger = GPIO_INT_Trigger_EDGE;
        0x0020a326:    f88d4006    ...@    STRB     r4,[sp,#6]
;;;89         GPIO_Param.GPIO_ITPolarity = GPIO_INT_POLARITY_ACTIVE_LOW;
        0x0020a32a:    f88d0007    ....    STRB     r0,[sp,#7]
        0x0020a32e:    2014        .       MOVS     r0,#0x14
        0x0020a330:    9003        ..      STR      r0,[sp,#0xc]
;;;90         GPIO_Param.GPIO_ITDebounce = GPIO_INT_DEBOUNCE_ENABLE;
        0x0020a332:    f88d4008    ...@    STRB     r4,[sp,#8]
;;;91         GPIO_Param.GPIO_DebounceTime = 20;
;;;92         GPIO_Init(&GPIO_Param);
        0x0020a336:    4668        hF      MOV      r0,sp
        0x0020a338:    f7fefcde    ....    BL       GPIO_Init ; 0x208cf8
;;;93     
;;;94         /* Enable interrupt */
;;;95         GPIO_INTConfig(GPIO_GetPin(PAIR_BUTTON), ENABLE);
        0x0020a33c:    2014        .       MOVS     r0,#0x14
        0x0020a33e:    f7fefd5c    ..\.    BL       GPIO_GetPin ; 0x208dfa
        0x0020a342:    2101        .!      MOVS     r1,#1
        0x0020a344:    f7fefd44    ..D.    BL       GPIO_INTConfig ; 0x208dd0
;;;96         GPIO_MaskINTConfig(GPIO_GetPin(PAIR_BUTTON), DISABLE);
        0x0020a348:    2014        .       MOVS     r0,#0x14
        0x0020a34a:    f7fefd56    ..V.    BL       GPIO_GetPin ; 0x208dfa
        0x0020a34e:    2100        .!      MOVS     r1,#0
        0x0020a350:    f7fefd4a    ..J.    BL       GPIO_MaskINTConfig ; 0x208de8
;;;97     
;;;98         NVIC_InitTypeDef NVIC_InitStruct;
;;;99         NVIC_InitStruct.NVIC_IRQChannel = GPIO20_IRQn;
        0x0020a354:    201e        .       MOVS     r0,#0x1e
        0x0020a356:    f88d0010    ....    STRB     r0,[sp,#0x10]
;;;100        NVIC_InitStruct.NVIC_IRQChannelPriority = 3;
        0x0020a35a:    2003        .       MOVS     r0,#3
;;;101        NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
        0x0020a35c:    9005        ..      STR      r0,[sp,#0x14]
        0x0020a35e:    f88d4018    ...@    STRB     r4,[sp,#0x18]
;;;102        NVIC_Init(&NVIC_InitStruct);
        0x0020a362:    a804        ..      ADD      r0,sp,#0x10
        0x0020a364:    f606ffac    ....    BL       NVIC_Init ; 0x112c0
;;;103    }
        0x0020a368:    b008        ..      ADD      sp,sp,#0x20
        0x0020a36a:    bd10        ..      POP      {r4,pc}
    longpress_timeout
;;;104    
;;;105    /**
;;;106    * @brief   longpress timeout callback
;;;107    * @return  void
;;;108    */
;;;109    void longpress_timeout(void *pxTimer)
;;;110    {
        0x0020a36c:    b570        p.      PUSH     {r4-r6,lr}
;;;111        APP_PRINT_INFO0("Pair button longpress !!!");
        0x0020a36e:    2200        ."      MOVS     r2,#0
        0x0020a370:    4970        pI      LDR      r1,[pc,#448] ; [0x20a534] = 0x8801280
        0x0020a372:    4871        qH      LDR      r0,[pc,#452] ; [0x20a538] = 0x21103002
        0x0020a374:    f5fdfb73    ..s.    BL       log_buffer ; 0x7a5e
;;;112    
;;;113        //if linkkey exist, clear key and start adv in the app gap callback
;;;114        if (resolv_list_exist)
        0x0020a378:    4870        pH      LDR      r0,[pc,#448] ; [0x20a53c] = 0x20bc8c
        0x0020a37a:    4d71        qM      LDR      r5,[pc,#452] ; [0x20a540] = 0x20bccc
        0x0020a37c:    4971        qI      LDR      r1,[pc,#452] ; [0x20a544] = 0x20bc88
        0x0020a37e:    7800        .x      LDRB     r0,[r0,#0]
        0x0020a380:    2401        .$      MOVS     r4,#1
        0x0020a382:    b1a8        ..      CBZ      r0,0x20a3b0 ; longpress_timeout + 68
;;;115        {
;;;116            //when adv is enabled & resolution is enabled, could not use stop resolution cmd
;;;117            if (app_privacy_resolution_state == LE_PRIVACY_RESOLUTION_ENABLED && \
        0x0020a384:    4870        pH      LDR      r0,[pc,#448] ; [0x20a548] = 0x20bce1
        0x0020a386:    7800        .x      LDRB     r0,[r0,#0]
        0x0020a388:    2803        .(      CMP      r0,#3
        0x0020a38a:    d005        ..      BEQ      0x20a398 ; longpress_timeout + 44
        0x0020a38c:    2800        .(      CMP      r0,#0
        0x0020a38e:    d119        ..      BNE      0x20a3c4 ; longpress_timeout + 88
        0x0020a390:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0020a394:    f641bedc    A...    B        le_bond_clear_all_keys ; 0x4c150
;;;118                gap_dev_state.gap_adv_state == GAP_ADV_STATE_ADVERTISING)
        0x0020a398:    7808        .x      LDRB     r0,[r1,#0]
        0x0020a39a:    f3c00081    ....    UBFX     r0,r0,#2,#2
        0x0020a39e:    2802        .(      CMP      r0,#2
        0x0020a3a0:    d003        ..      BEQ      0x20a3aa ; longpress_timeout + 62
        0x0020a3a2:    2000        .       MOVS     r0,#0
        0x0020a3a4:    f647fc27    G.'.    BL       le_privacy_set_addr_resolution ; 0x51bf6
        0x0020a3a8:    e7f2        ..      B        0x20a390 ; longpress_timeout + 36
;;;119            {
;;;120                le_adv_stop();
        0x0020a3aa:    f647feee    G...    BL       le_adv_stop ; 0x5218a
;;;121                start_pair_adv = true;
        0x0020a3ae:    e008        ..      B        0x20a3c2 ; longpress_timeout + 86
;;;122            }
;;;123            else if (app_privacy_resolution_state == LE_PRIVACY_RESOLUTION_ENABLED)
;;;124            {
;;;125                le_privacy_set_addr_resolution(false);
;;;126                le_bond_clear_all_keys();//maybe move this to privacy_handle_le_privacy_resolution_status_info
;;;127            }
;;;128            else if (app_privacy_resolution_state == LE_PRIVACY_RESOLUTION_DISABLED)
;;;129            {
;;;130                le_bond_clear_all_keys();
;;;131            }
;;;132        }
;;;133        else
;;;134        {
;;;135            if (gap_conn_state == GAP_CONN_STATE_DISCONNECTED)
        0x0020a3b0:    4866        fH      LDR      r0,[pc,#408] ; [0x20a54c] = 0x20bc89
        0x0020a3b2:    7800        .x      LDRB     r0,[r0,#0]
        0x0020a3b4:    b138        8.      CBZ      r0,0x20a3c6 ; longpress_timeout + 90
        0x0020a3b6:    2802        .(      CMP      r0,#2
        0x0020a3b8:    d104        ..      BNE      0x20a3c4 ; longpress_timeout + 88
        0x0020a3ba:    4865        eH      LDR      r0,[pc,#404] ; [0x20a550] = 0x20bc90
        0x0020a3bc:    7800        .x      LDRB     r0,[r0,#0]
        0x0020a3be:    f643fc31    C.1.    BL       le_disconnect ; 0x4dc24
        0x0020a3c2:    702c        ,p      STRB     r4,[r5,#0]
        0x0020a3c4:    bd70        p.      POP      {r4-r6,pc}
;;;136            {
;;;137                if (gap_dev_state.gap_adv_state == GAP_ADV_STATE_IDLE)
        0x0020a3c6:    7808        .x      LDRB     r0,[r1,#0]
        0x0020a3c8:    f0100f0c    ....    TST      r0,#0xc
        0x0020a3cc:    d007        ..      BEQ      0x20a3de ; longpress_timeout + 114
        0x0020a3ce:    f3c00081    ....    UBFX     r0,r0,#2,#2
        0x0020a3d2:    2802        .(      CMP      r0,#2
        0x0020a3d4:    d1f6        ..      BNE      0x20a3c4 ; longpress_timeout + 88
        0x0020a3d6:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0020a3da:    f000b947    ..G.    B.W      reset_adv_count ; 0x20a66c
;;;138                {
;;;139                    keyboard_start_adv(ADV_UNDIRECT_PAIRING);
        0x0020a3de:    2002        .       MOVS     r0,#2
        0x0020a3e0:    f000f98c    ....    BL       keyboard_start_adv ; 0x20a6fc
;;;140                    start_adv_led_timer(false);
        0x0020a3e4:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0020a3e8:    2000        .       MOVS     r0,#0
        0x0020a3ea:    f000b911    ....    B.W      start_adv_led_timer ; 0x20a610
    longpress_timer_init
;;;141                }
;;;142                else if (gap_dev_state.gap_adv_state == GAP_ADV_STATE_ADVERTISING)
;;;143                {
;;;144                    reset_adv_count();
;;;145                }
;;;146            }
;;;147            else if (gap_conn_state == GAP_CONN_STATE_CONNECTED)
;;;148            {
;;;149                le_disconnect(keyboard_con_id);
;;;150                start_pair_adv = true;
;;;151            }
;;;152        }
;;;153    
;;;154    }
;;;155    
;;;156    /**
;;;157    * @brief   longpress timer init
;;;158    * @return  void
;;;159    */
;;;160    void longpress_timer_init(void)
;;;161    {
        0x0020a3ee:    b51c        ..      PUSH     {r2-r4,lr}
;;;162        os_timer_create(&longpress_timer, "long press timer", 1, 3000, false, longpress_timeout);
        0x0020a3f0:    f2af0187    ....    ADR      r1,{pc}-0x83 ; 0x20a36d
        0x0020a3f4:    2000        .       MOVS     r0,#0
        0x0020a3f6:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0020a3fa:    4851        QH      LDR      r0,[pc,#324] ; [0x20a540] = 0x20bccc
        0x0020a3fc:    f64033b8    @..3    MOV      r3,#0xbb8
        0x0020a400:    2201        ."      MOVS     r2,#1
        0x0020a402:    a154        T.      ADR      r1,{pc}+0x152 ; 0x20a554
        0x0020a404:    1d00        ..      ADDS     r0,r0,#4
        0x0020a406:    f61cfbe6    ....    BL       os_timer_create ; 0x26bd6
;;;163    }
        0x0020a40a:    bd1c        ..      POP      {r2-r4,pc}
    stop_longpress_timer
;;;164    
;;;165    /**
;;;166    * @brief   stop longpress timer
;;;167    * @return  void
;;;168    */
;;;169    void stop_longpress_timer(void)
;;;170    {
;;;171        if (longpress_timer != NULL)
        0x0020a40c:    484c        LH      LDR      r0,[pc,#304] ; [0x20a540] = 0x20bccc
        0x0020a40e:    6840        @h      LDR      r0,[r0,#4]
;;; ..\..\..\src\app\keyboard\keyboard_button.c (170)
        0x0020a410:    2800        .(      CMP      r0,#0
        0x0020a412:    d003        ..      BEQ      0x20a41c ; stop_longpress_timer + 16
;;;171        if (longpress_timer != NULL)
;;;172        {
;;;173            os_timer_stop(&longpress_timer);
        0x0020a414:    484a        JH      LDR      r0,[pc,#296] ; [0x20a540] = 0x20bccc
        0x0020a416:    1d00        ..      ADDS     r0,r0,#4
        0x0020a418:    f61cbc24    ..$.    B        os_timer_stop ; 0x26c64
;;;174        }
;;;175    }
        0x0020a41c:    4770        pG      BX       lr
    start_longpress_timer
        0x0020a41e:    4848        HH      LDR      r0,[pc,#288] ; [0x20a540] = 0x20bccc
        0x0020a420:    6840        @h      LDR      r0,[r0,#4]
;;;176    
;;;177    /**
;;;178    * @brief   stop longpress timer
;;;179    * @return  void
;;;180    */
;;;181    void start_longpress_timer(void)
;;;182    {
        0x0020a422:    2800        .(      CMP      r0,#0
        0x0020a424:    d003        ..      BEQ      0x20a42e ; start_longpress_timer + 16
;;;183        if (longpress_timer != NULL)
;;;184        {
;;;185            os_timer_start(&longpress_timer);
        0x0020a426:    4846        FH      LDR      r0,[pc,#280] ; [0x20a540] = 0x20bccc
        0x0020a428:    1d00        ..      ADDS     r0,r0,#4
        0x0020a42a:    f61cbbf7    ....    B        os_timer_start ; 0x26c1c
;;;186        }
;;;187    }
        0x0020a42e:    4770        pG      BX       lr
    GPIO20_Handler
;;;188    
;;;189    /**
;;;190    * @brief   Pair button interrupt handler
;;;191    * @return  void
;;;192    */
;;;193    void GPIO20_Handler(void)
;;;194    {
        0x0020a430:    b57c        |.      PUSH     {r2-r6,lr}
;;;195        /*  Mask GPIO interrupt */
;;;196        GPIO_INTConfig(GPIO_GetPin(PAIR_BUTTON), DISABLE);
        0x0020a432:    2014        .       MOVS     r0,#0x14
        0x0020a434:    f7fefce1    ....    BL       GPIO_GetPin ; 0x208dfa
        0x0020a438:    2100        .!      MOVS     r1,#0
        0x0020a43a:    f7fefcc9    ....    BL       GPIO_INTConfig ; 0x208dd0
;;;197        GPIO_MaskINTConfig(GPIO_GetPin(PAIR_BUTTON), ENABLE);
        0x0020a43e:    2014        .       MOVS     r0,#0x14
        0x0020a440:    f7fefcdb    ....    BL       GPIO_GetPin ; 0x208dfa
        0x0020a444:    2101        .!      MOVS     r1,#1
        0x0020a446:    f7fefccf    ....    BL       GPIO_MaskINTConfig ; 0x208de8
;;;198        GPIO_ClearINTPendingBit(GPIO_GetPin(PAIR_BUTTON));
        0x0020a44a:    2014        .       MOVS     r0,#0x14
        0x0020a44c:    f7fefcd5    ....    BL       GPIO_GetPin ; 0x208dfa
        0x0020a450:    f7fefcc7    ....    BL       GPIO_ClearINTPendingBit ; 0x208de2
;;;199    
;;;200        T_IO_MSG button_msg;
;;;201        button_msg.type = IO_MSG_TYPE_GPIO;
        0x0020a454:    200b        .       MOVS     r0,#0xb
        0x0020a456:    f8ad0000    ....    STRH     r0,[sp,#0]
;;;202    
;;;203        if (GPIO_ReadInputDataBit(GPIO_GetPin(PAIR_BUTTON))) //Release
        0x0020a45a:    2014        .       MOVS     r0,#0x14
        0x0020a45c:    f7fefccd    ....    BL       GPIO_GetPin ; 0x208dfa
        0x0020a460:    f000f85e    ..^.    BL       GPIO_ReadInputDataBit ; 0x20a520
        0x0020a464:    0001        ..      MOVS     r1,r0
        0x0020a466:    4b36        6K      LDR      r3,[pc,#216] ; [0x20a540] = 0x20bccc
        0x0020a468:    4c3f        ?L      LDR      r4,[pc,#252] ; [0x20a568] = 0x40001000
        0x0020a46a:    4d33        3M      LDR      r5,[pc,#204] ; [0x20a538] = 0x21103002
        0x0020a46c:    f04f0000    O...    MOV      r0,#0
        0x0020a470:    f04f0201    O...    MOV      r2,#1
        0x0020a474:    d011        ..      BEQ      0x20a49a ; GPIO20_Handler + 106
;;;204        {
;;;205            pair_press = false;
        0x0020a476:    7058        Xp      STRB     r0,[r3,#1]
;;;206            button_msg.subtype = KEYBOARD_PAIR_RELEASE;
        0x0020a478:    f8ad2002    ...     STRH     r2,[sp,#2]
;;;207            GPIO->INTPOLARITY &= ~GPIO_GetPin(PAIR_BUTTON); //Polarity Low
        0x0020a47c:    2014        .       MOVS     r0,#0x14
        0x0020a47e:    f7fefcbc    ....    BL       GPIO_GetPin ; 0x208dfa
        0x0020a482:    6be1        .k      LDR      r1,[r4,#0x3c]
        0x0020a484:    4381        .C      BICS     r1,r1,r0
        0x0020a486:    63e1        .c      STR      r1,[r4,#0x3c]
;;;208            System_WakeUpPinEnable(PAIR_BUTTON, PAD_WAKEUP_POL_LOW, PAD_WK_DEBOUNCE_ENABLE);
        0x0020a488:    2201        ."      MOVS     r2,#1
        0x0020a48a:    4611        .F      MOV      r1,r2
        0x0020a48c:    2014        .       MOVS     r0,#0x14
        0x0020a48e:    f607f836    ..6.    BL       System_WakeUpPinEnable ; 0x114fe
;;;209            APP_PRINT_INFO0("Pair button release !!!");
        0x0020a492:    4928        (I      LDR      r1,[pc,#160] ; [0x20a534] = 0x8801280
        0x0020a494:    2200        ."      MOVS     r2,#0
        0x0020a496:    3120         1      ADDS     r1,r1,#0x20
        0x0020a498:    e010        ..      B        0x20a4bc ; GPIO20_Handler + 140
;;;210        }
;;;211        else
;;;212        {
;;;213            pair_press = true;
        0x0020a49a:    705a        Zp      STRB     r2,[r3,#1]
;;;214            button_msg.subtype = KEYBOARD_PAIR_PRESS;
        0x0020a49c:    f8ad0002    ....    STRH     r0,[sp,#2]
;;;215            GPIO->INTPOLARITY |= GPIO_GetPin(PAIR_BUTTON);   //Polarity High
        0x0020a4a0:    2014        .       MOVS     r0,#0x14
        0x0020a4a2:    f7fefcaa    ....    BL       GPIO_GetPin ; 0x208dfa
        0x0020a4a6:    6be1        .k      LDR      r1,[r4,#0x3c]
        0x0020a4a8:    4308        .C      ORRS     r0,r0,r1
        0x0020a4aa:    63e0        .c      STR      r0,[r4,#0x3c]
;;;216            System_WakeUpPinEnable(PAIR_BUTTON, PAD_WAKEUP_POL_HIGH, PAD_WK_DEBOUNCE_ENABLE);
        0x0020a4ac:    2201        ."      MOVS     r2,#1
        0x0020a4ae:    2100        .!      MOVS     r1,#0
        0x0020a4b0:    2014        .       MOVS     r0,#0x14
        0x0020a4b2:    f607f824    ..$.    BL       System_WakeUpPinEnable ; 0x114fe
;;;217            APP_PRINT_INFO0("Pair button press !!!");
        0x0020a4b6:    491f        .I      LDR      r1,[pc,#124] ; [0x20a534] = 0x8801280
        0x0020a4b8:    2200        ."      MOVS     r2,#0
        0x0020a4ba:    313c        <1      ADDS     r1,r1,#0x3c
        0x0020a4bc:    4628        (F      MOV      r0,r5
        0x0020a4be:    f5fdface    ....    BL       log_buffer ; 0x7a5e
;;;218        }
;;;219    
;;;220    
;;;221        app_send_msg_to_apptask(&button_msg);
        0x0020a4c2:    4668        hF      MOV      r0,sp
        0x0020a4c4:    f7feff41    ..A.    BL       app_send_msg_to_apptask ; 0x20934a
;;;222    
;;;223        GPIO_MaskINTConfig(GPIO_GetPin(PAIR_BUTTON), DISABLE);
        0x0020a4c8:    2014        .       MOVS     r0,#0x14
        0x0020a4ca:    f7fefc96    ....    BL       GPIO_GetPin ; 0x208dfa
        0x0020a4ce:    2100        .!      MOVS     r1,#0
        0x0020a4d0:    f7fefc8a    ....    BL       GPIO_MaskINTConfig ; 0x208de8
;;;224        GPIO_INTConfig(GPIO_GetPin(PAIR_BUTTON), ENABLE);
        0x0020a4d4:    2014        .       MOVS     r0,#0x14
        0x0020a4d6:    f7fefc90    ....    BL       GPIO_GetPin ; 0x208dfa
        0x0020a4da:    2101        .!      MOVS     r1,#1
        0x0020a4dc:    f7fefc78    ..x.    BL       GPIO_INTConfig ; 0x208dd0
;;;225    
;;;226    }
        0x0020a4e0:    bd7c        |.      POP      {r2-r6,pc}
    handle_pair_button_event
;;;227    
;;;228    /**
;;;229    * @brief   Pair button event handler
;;;230    * @return  void
;;;231    */
;;;232    void handle_pair_button_event(T_IO_MSG button_msg)
;;;233    {
        0x0020a4e2:    0c00        ..      LSRS     r0,r0,#16
        0x0020a4e4:    d002        ..      BEQ      0x20a4ec ; handle_pair_button_event + 10
        0x0020a4e6:    2801        .(      CMP      r0,#1
        0x0020a4e8:    d101        ..      BNE      0x20a4ee ; handle_pair_button_event + 12
        0x0020a4ea:    e78f        ..      B        stop_longpress_timer ; 0x20a40c
;;;234        if (button_msg.subtype == KEYBOARD_PAIR_PRESS)
;;;235        {
;;;236            start_longpress_timer();
        0x0020a4ec:    e797        ..      B        start_longpress_timer ; 0x20a41e
;;;237        }
;;;238        else if (button_msg.subtype == KEYBOARD_PAIR_RELEASE)
;;;239        {
;;;240            stop_longpress_timer();
;;;241        }
;;;242    }
        0x0020a4ee:    4770        pG      BX       lr
    handle_pair_button_wakeup
;;;243    
;;;244    /**
;;;245    * @brief   Pair button wakeup handler
;;;246    * @return  void
;;;247    */
;;;248    void handle_pair_button_wakeup(void)
;;;249    {
        0x0020a4f0:    b510        ..      PUSH     {r4,lr}
;;;250        if (GPIO_ReadInputDataBit(GPIO_GetPin(PAIR_BUTTON)) && pair_press)
        0x0020a4f2:    2014        .       MOVS     r0,#0x14
        0x0020a4f4:    f7fefc81    ....    BL       GPIO_GetPin ; 0x208dfa
        0x0020a4f8:    f000f812    ....    BL       GPIO_ReadInputDataBit ; 0x20a520
        0x0020a4fc:    4c10        .L      LDR      r4,[pc,#64] ; [0x20a540] = 0x20bccc
        0x0020a4fe:    b108        ..      CBZ      r0,0x20a504 ; handle_pair_button_wakeup + 20
        0x0020a500:    7860        `x      LDRB     r0,[r4,#1]
        0x0020a502:    b948        H.      CBNZ     r0,0x20a518 ; handle_pair_button_wakeup + 40
;;;251        {
;;;252            GPIO20_Handler();
;;;253        }
;;;254        else if (GPIO_ReadInputDataBit(GPIO_GetPin(PAIR_BUTTON)) == false && pair_press == false)
        0x0020a504:    2014        .       MOVS     r0,#0x14
        0x0020a506:    f7fefc78    ..x.    BL       GPIO_GetPin ; 0x208dfa
        0x0020a50a:    f000f809    ....    BL       GPIO_ReadInputDataBit ; 0x20a520
        0x0020a50e:    2800        .(      CMP      r0,#0
        0x0020a510:    d105        ..      BNE      0x20a51e ; handle_pair_button_wakeup + 46
        0x0020a512:    7860        `x      LDRB     r0,[r4,#1]
        0x0020a514:    2800        .(      CMP      r0,#0
        0x0020a516:    d102        ..      BNE      0x20a51e ; handle_pair_button_wakeup + 46
;;;255        {
;;;256            GPIO20_Handler();
        0x0020a518:    e8bd4010    ...@    POP      {r4,lr}
        0x0020a51c:    e788        ..      B        GPIO20_Handler ; 0x20a430
;;;257        }
;;;258    }
        0x0020a51e:    bd10        ..      POP      {r4,pc}
    GPIO_ReadInputDataBit
;;; ..\..\..\inc\peripheral\rtl876x_gpio.h
;;;391        if (GPIO->DATAIN & GPIO_Pin)
        0x0020a520:    4a11        .J      LDR      r2,[pc,#68] ; [0x20a568] = 0x40001000
;;; ..\..\..\inc\peripheral\rtl876x_gpio.h (385)
        0x0020a522:    4601        .F      MOV      r1,r0
        0x0020a524:    2000        .       MOVS     r0,#0
        0x0020a526:    6d12        .m      LDR      r2,[r2,#0x50]
        0x0020a528:    420a        .B      TST      r2,r1
        0x0020a52a:    d000        ..      BEQ      0x20a52e ; GPIO_ReadInputDataBit + 14
;;;386        uint8_t bitstatus = RESET;
;;;387    
;;;388        /* Check the parameters */
;;;389        assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;390    
;;;391        if (GPIO->DATAIN & GPIO_Pin)
;;;392        {
;;;393            bitstatus = (uint8_t)SET;
        0x0020a52c:    2001        .       MOVS     r0,#1
;;;394        }
;;;395    
;;;396        return bitstatus;
;;;397    }
        0x0020a52e:    4770        pG      BX       lr
    $d
        0x0020a530:    0c000100    ....    DCD    201326848
        0x0020a534:    08801280    ....    DCD    142611072
        0x0020a538:    21103002    .0.!    DCD    554708994
        0x0020a53c:    0020bc8c    .. .    DCD    2145420
        0x0020a540:    0020bccc    .. .    DCD    2145484
        0x0020a544:    0020bc88    .. .    DCD    2145416
        0x0020a548:    0020bce1    .. .    DCD    2145505
        0x0020a54c:    0020bc89    .. .    DCD    2145417
        0x0020a550:    0020bc90    .. .    DCD    2145424
        0x0020a554:    676e6f6c    long    DCD    1735290732
        0x0020a558:    65727020     pre    DCD    1701998624
        0x0020a55c:    74207373    ss t    DCD    1948283763
        0x0020a560:    72656d69    imer    DCD    1919249769
        0x0020a564:    00000000    ....    DCD    0
        0x0020a568:    40001000    ...@    DCD    1073745920
    $t
    .text
    adv_led_timeout
;;; ..\..\..\src\app\keyboard\keyboard_led.c
;;;33     {
        0x0020a56c:    b51c        ..      PUSH     {r2-r4,lr}
        0x0020a56e:    4a5c        \J      LDR      r2,[pc,#368] ; [0x20a6e0] = 0x20bcd4
        0x0020a570:    4c5c        \L      LDR      r4,[pc,#368] ; [0x20a6e4] = 0x21103002
        0x0020a572:    7850        Px      LDRB     r0,[r2,#1]
;;; ..\..\..\src\app\keyboard\keyboard_led.c (33)
        0x0020a574:    b120         .      CBZ      r0,0x20a580 ; adv_led_timeout + 20
;;;34         if (adv_reconnect)
;;;35         {
;;;36             le_adv_stop();
        0x0020a576:    f647fe08    G...    BL       le_adv_stop ; 0x5218a
;;;37             APP_PRINT_INFO0("ADV timeout, stop  reconnect ADV");
        0x0020a57a:    2200        ."      MOVS     r2,#0
        0x0020a57c:    495a        ZI      LDR      r1,[pc,#360] ; [0x20a6e8] = 0x88012d8
        0x0020a57e:    e032        2.      B        0x20a5e6 ; adv_led_timeout + 122
;;;38         }
;;;39         else
;;;40         {
;;;41             if (adv_count < 30)
        0x0020a580:    7891        .x      LDRB     r1,[r2,#2]
        0x0020a582:    2000        .       MOVS     r0,#0
        0x0020a584:    2301        .#      MOVS     r3,#1
        0x0020a586:    291e        .)      CMP      r1,#0x1e
        0x0020a588:    d21f        ..      BCS      0x20a5ca ; adv_led_timeout + 94
;;;42             {
;;;43                 if (adv_led_on)
        0x0020a58a:    7814        .x      LDRB     r4,[r2,#0]
        0x0020a58c:    b15c        \.      CBZ      r4,0x20a5a6 ; adv_led_timeout + 58
;;;44                 {
;;;45                     adv_led_on = false;
        0x0020a58e:    7010        .p      STRB     r0,[r2,#0]
        0x0020a590:    e9cd3000    ...0    STRD     r3,r0,[sp,#0]
;;;46                     Pad_Config(ADV_LED, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0020a594:    2302        .#      MOVS     r3,#2
        0x0020a596:    2201        ."      MOVS     r2,#1
        0x0020a598:    2100        .!      MOVS     r1,#0
        0x0020a59a:    2013        .       MOVS     r0,#0x13
        0x0020a59c:    f606ff1e    ....    BL       Pad_Config ; 0x113dc
;;;47                     os_timer_restart(&adv_led_timer, 900);
        0x0020a5a0:    f44f7161    O.aq    MOV      r1,#0x384
        0x0020a5a4:    e00b        ..      B        0x20a5be ; adv_led_timeout + 82
        0x0020a5a6:    1c49        I.      ADDS     r1,r1,#1
;;;48                 }
;;;49                 else
;;;50                 {
;;;51                     adv_count++;
        0x0020a5a8:    7091        .p      STRB     r1,[r2,#2]
;;;52                     adv_led_on = true;
        0x0020a5aa:    7013        .p      STRB     r3,[r2,#0]
;;;53                     Pad_Config(ADV_LED, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_ENABLE, PAD_OUT_HIGH);
        0x0020a5ac:    9300        ..      STR      r3,[sp,#0]
        0x0020a5ae:    9301        ..      STR      r3,[sp,#4]
        0x0020a5b0:    2301        .#      MOVS     r3,#1
        0x0020a5b2:    461a        .F      MOV      r2,r3
        0x0020a5b4:    2100        .!      MOVS     r1,#0
        0x0020a5b6:    2013        .       MOVS     r0,#0x13
        0x0020a5b8:    f606ff10    ....    BL       Pad_Config ; 0x113dc
;;;54                     os_timer_restart(&adv_led_timer, 100);
        0x0020a5bc:    2164        d!      MOVS     r1,#0x64
        0x0020a5be:    e8bd401c    ...@    POP      {r2-r4,lr}
        0x0020a5c2:    4847        GH      LDR      r0,[pc,#284] ; [0x20a6e0] = 0x20bcd4
        0x0020a5c4:    1d00        ..      ADDS     r0,r0,#4
        0x0020a5c6:    f61cbb3a    ..:.    B        os_timer_restart ; 0x26c3e
;;;55                 }
;;;56             }
;;;57             else
;;;58             {
;;;59                 adv_led_on = false;
        0x0020a5ca:    7010        .p      STRB     r0,[r2,#0]
        0x0020a5cc:    e9cd3000    ...0    STRD     r3,r0,[sp,#0]
;;;60                 Pad_Config(ADV_LED, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0020a5d0:    2302        .#      MOVS     r3,#2
        0x0020a5d2:    2201        ."      MOVS     r2,#1
        0x0020a5d4:    2100        .!      MOVS     r1,#0
        0x0020a5d6:    2013        .       MOVS     r0,#0x13
        0x0020a5d8:    f606ff00    ....    BL       Pad_Config ; 0x113dc
;;;61                 le_adv_stop();
        0x0020a5dc:    f647fdd5    G...    BL       le_adv_stop ; 0x5218a
;;;62                 APP_PRINT_INFO0("ADV timeout, stop pair ADV");
        0x0020a5e0:    4941        AI      LDR      r1,[pc,#260] ; [0x20a6e8] = 0x88012d8
        0x0020a5e2:    2200        ."      MOVS     r2,#0
        0x0020a5e4:    3124        $1      ADDS     r1,r1,#0x24
        0x0020a5e6:    b002        ..      ADD      sp,sp,#8
        0x0020a5e8:    4620         F      MOV      r0,r4
        0x0020a5ea:    e8bd4010    ...@    POP      {r4,lr}
        0x0020a5ee:    f5fdba36    ..6.    B        log_buffer ; 0x7a5e
    adv_led_timer_init
;;;63             }
;;;64         }
;;;65     }
;;;66     
;;;67     /**
;;;68     * @brief  create adv led timer
;;;69     * @return  void
;;;70     */
;;;71     void adv_led_timer_init(void)
;;;72     {
        0x0020a5f2:    b51c        ..      PUSH     {r2-r4,lr}
;;;73         os_timer_create(&adv_led_timer, "adv led timer", 1, 3000, false, adv_led_timeout);
        0x0020a5f4:    f2af018b    ....    ADR      r1,{pc}-0x87 ; 0x20a56d
        0x0020a5f8:    2000        .       MOVS     r0,#0
        0x0020a5fa:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0020a5fe:    4838        8H      LDR      r0,[pc,#224] ; [0x20a6e0] = 0x20bcd4
        0x0020a600:    f64033b8    @..3    MOV      r3,#0xbb8
        0x0020a604:    2201        ."      MOVS     r2,#1
        0x0020a606:    a139        9.      ADR      r1,{pc}+0xe6 ; 0x20a6ec
        0x0020a608:    1d00        ..      ADDS     r0,r0,#4
        0x0020a60a:    f61cfae4    ....    BL       os_timer_create ; 0x26bd6
;;;74     }
        0x0020a60e:    bd1c        ..      POP      {r2-r4,pc}
    start_adv_led_timer
;;;75     
;;;76     /**
;;;77     * @brief  start adv led timer
;;;78     * @return  void
;;;79     */
;;;80     void start_adv_led_timer(bool reconnect)
;;;81     {
        0x0020a610:    b51c        ..      PUSH     {r2-r4,lr}
        0x0020a612:    4933        3I      LDR      r1,[pc,#204] ; [0x20a6e0] = 0x20bcd4
        0x0020a614:    7048        Hp      STRB     r0,[r1,#1]
;;; ..\..\..\src\app\keyboard\keyboard_led.c (81)
        0x0020a616:    b110        ..      CBZ      r0,0x20a61e ; start_adv_led_timer + 14
;;;82         adv_reconnect = reconnect;
;;;83         if (adv_reconnect)
;;;84         {
;;;85             os_timer_restart(&adv_led_timer, 30000);
        0x0020a618:    f2475130    G.0Q    MOV      r1,#0x7530
        0x0020a61c:    e00c        ..      B        0x20a638 ; start_adv_led_timer + 40
;;;86         }
;;;87         else
;;;88         {
;;;89             adv_count = 0;
        0x0020a61e:    2000        .       MOVS     r0,#0
        0x0020a620:    7088        .p      STRB     r0,[r1,#2]
;;;90             adv_led_on = true;
        0x0020a622:    2001        .       MOVS     r0,#1
        0x0020a624:    7008        .p      STRB     r0,[r1,#0]
;;;91             Pad_Config(ADV_LED, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_ENABLE, PAD_OUT_HIGH);
        0x0020a626:    9000        ..      STR      r0,[sp,#0]
        0x0020a628:    4603        .F      MOV      r3,r0
        0x0020a62a:    4602        .F      MOV      r2,r0
        0x0020a62c:    9001        ..      STR      r0,[sp,#4]
        0x0020a62e:    2100        .!      MOVS     r1,#0
        0x0020a630:    2013        .       MOVS     r0,#0x13
        0x0020a632:    f606fed3    ....    BL       Pad_Config ; 0x113dc
;;;92             os_timer_restart(&adv_led_timer, 100);
        0x0020a636:    2164        d!      MOVS     r1,#0x64
        0x0020a638:    e8bd401c    ...@    POP      {r2-r4,lr}
        0x0020a63c:    4828        (H      LDR      r0,[pc,#160] ; [0x20a6e0] = 0x20bcd4
        0x0020a63e:    1d00        ..      ADDS     r0,r0,#4
        0x0020a640:    f61cbafd    ....    B        os_timer_restart ; 0x26c3e
    stop_adv_led_timer
;;;93         }
;;;94     }
;;;95     
;;;96     /**
;;;97     * @brief  stop adv led timer
;;;98     * @return  void
;;;99     */
;;;100    void stop_adv_led_timer(void)
;;;101    {
        0x0020a644:    b51c        ..      PUSH     {r2-r4,lr}
;;;102        adv_count = 0;
        0x0020a646:    4926        &I      LDR      r1,[pc,#152] ; [0x20a6e0] = 0x20bcd4
        0x0020a648:    2000        .       MOVS     r0,#0
        0x0020a64a:    2302        .#      MOVS     r3,#2
        0x0020a64c:    7088        .p      STRB     r0,[r1,#2]
;;;103        adv_led_on = false;
        0x0020a64e:    7008        .p      STRB     r0,[r1,#0]
;;;104        Pad_Config(ADV_LED, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0020a650:    2101        .!      MOVS     r1,#1
        0x0020a652:    e9cd1000    ....    STRD     r1,r0,[sp,#0]
        0x0020a656:    460a        .F      MOV      r2,r1
        0x0020a658:    4601        .F      MOV      r1,r0
        0x0020a65a:    2013        .       MOVS     r0,#0x13
        0x0020a65c:    f606febe    ....    BL       Pad_Config ; 0x113dc
;;;105        os_timer_stop(&adv_led_timer);
        0x0020a660:    e8bd401c    ...@    POP      {r2-r4,lr}
        0x0020a664:    481e        .H      LDR      r0,[pc,#120] ; [0x20a6e0] = 0x20bcd4
        0x0020a666:    1d00        ..      ADDS     r0,r0,#4
        0x0020a668:    f61cbafc    ....    B        os_timer_stop ; 0x26c64
    reset_adv_count
;;;106    }
;;;107    
;;;108    /**
;;;109    * @brief  reset adv count
;;;110    * @return  void
;;;111    */
;;;112    void reset_adv_count(void)
;;;113    {
        0x0020a66c:    b51c        ..      PUSH     {r2-r4,lr}
;;;114        adv_count = 0;
        0x0020a66e:    491c        .I      LDR      r1,[pc,#112] ; [0x20a6e0] = 0x20bcd4
        0x0020a670:    2000        .       MOVS     r0,#0
        0x0020a672:    2302        .#      MOVS     r3,#2
        0x0020a674:    7088        .p      STRB     r0,[r1,#2]
;;;115        adv_led_on = false;
        0x0020a676:    7008        .p      STRB     r0,[r1,#0]
;;;116        Pad_Config(ADV_LED, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0020a678:    2101        .!      MOVS     r1,#1
        0x0020a67a:    e9cd1000    ....    STRD     r1,r0,[sp,#0]
        0x0020a67e:    460a        .F      MOV      r2,r1
        0x0020a680:    4601        .F      MOV      r1,r0
        0x0020a682:    2013        .       MOVS     r0,#0x13
        0x0020a684:    f606feaa    ....    BL       Pad_Config ; 0x113dc
;;;117    }
        0x0020a688:    bd1c        ..      POP      {r2-r4,pc}
    keyboard_led_init
;;;118    
;;;119    /**
;;;120    * @brief  keyboard led initialization function.
;;;121    * @return  void
;;;122    */
;;;123    void keyboard_led_init(void)
;;;124    {
        0x0020a68a:    b57c        |.      PUSH     {r2-r6,lr}
;;;125        Pad_Config(ADV_LED, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0020a68c:    2500        .%      MOVS     r5,#0
        0x0020a68e:    2401        .$      MOVS     r4,#1
        0x0020a690:    2302        .#      MOVS     r3,#2
        0x0020a692:    4622        "F      MOV      r2,r4
        0x0020a694:    4629        )F      MOV      r1,r5
        0x0020a696:    2013        .       MOVS     r0,#0x13
        0x0020a698:    e9cd4500    ...E    STRD     r4,r5,[sp,#0]
        0x0020a69c:    f606fe9e    ....    BL       Pad_Config ; 0x113dc
;;;126        Pad_Config(CAPS_LOCK_LED, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0020a6a0:    2302        .#      MOVS     r3,#2
        0x0020a6a2:    2201        ."      MOVS     r2,#1
        0x0020a6a4:    2100        .!      MOVS     r1,#0
        0x0020a6a6:    2015        .       MOVS     r0,#0x15
        0x0020a6a8:    e9cd4500    ...E    STRD     r4,r5,[sp,#0]
        0x0020a6ac:    f606fe96    ....    BL       Pad_Config ; 0x113dc
;;;127    }
        0x0020a6b0:    bd7c        |.      POP      {r2-r6,pc}
    capslock_led_on
;;;128    
;;;129    /**
;;;130    * @brief  turn on capslock led
;;;131    * @return  void
;;;132    */
;;;133    void capslock_led_on(void)
;;;134    {
        0x0020a6b2:    b51c        ..      PUSH     {r2-r4,lr}
;;;135        Pad_Config(CAPS_LOCK_LED, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_ENABLE, PAD_OUT_HIGH);
        0x0020a6b4:    2001        .       MOVS     r0,#1
        0x0020a6b6:    9000        ..      STR      r0,[sp,#0]
        0x0020a6b8:    4603        .F      MOV      r3,r0
        0x0020a6ba:    4602        .F      MOV      r2,r0
        0x0020a6bc:    9001        ..      STR      r0,[sp,#4]
        0x0020a6be:    2100        .!      MOVS     r1,#0
        0x0020a6c0:    2015        .       MOVS     r0,#0x15
        0x0020a6c2:    f606fe8b    ....    BL       Pad_Config ; 0x113dc
;;;136    }
        0x0020a6c6:    bd1c        ..      POP      {r2-r4,pc}
    capslock_led_off
;;;137    
;;;138    /**
;;;139    * @brief  turn off capslock led
;;;140    * @return  void
;;;141    */
;;;142    void capslock_led_off(void)
;;;143    {
        0x0020a6c8:    b51c        ..      PUSH     {r2-r4,lr}
;;;144        Pad_Config(CAPS_LOCK_LED, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0020a6ca:    2001        .       MOVS     r0,#1
        0x0020a6cc:    2100        .!      MOVS     r1,#0
        0x0020a6ce:    4602        .F      MOV      r2,r0
        0x0020a6d0:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0020a6d4:    2302        .#      MOVS     r3,#2
        0x0020a6d6:    2015        .       MOVS     r0,#0x15
        0x0020a6d8:    f606fe80    ....    BL       Pad_Config ; 0x113dc
;;;145    }
        0x0020a6dc:    bd1c        ..      POP      {r2-r4,pc}
    $d
        0x0020a6de:    0000        ..      DCW    0
        0x0020a6e0:    0020bcd4    .. .    DCD    2145492
        0x0020a6e4:    21103002    .0.!    DCD    554708994
        0x0020a6e8:    088012d8    ....    DCD    142611160
        0x0020a6ec:    20766461    adv     DCD    544629857
        0x0020a6f0:    2064656c    led     DCD    543450476
        0x0020a6f4:    656d6974    time    DCD    1701669236
        0x0020a6f8:    00000072    r...    DCD    114
    $t
    .text
    keyboard_start_adv
;;; ..\..\..\src\app\keyboard\profile_init.c
;;;30     {
        0x0020a6fc:    b510        ..      PUSH     {r4,lr}
        0x0020a6fe:    b086        ..      SUB      sp,sp,#0x18
;;;31         uint8_t  adv_evt_type = GAP_ADTYPE_ADV_IND;
        0x0020a700:    2100        .!      MOVS     r1,#0
        0x0020a702:    f88d1000    ....    STRB     r1,[sp,#0]
;;;32         uint8_t  adv_direct_type = GAP_REMOTE_ADDR_LE_PUBLIC;
        0x0020a706:    f88d1004    ....    STRB     r1,[sp,#4]
;;;33         uint8_t  adv_direct_addr[GAP_BD_ADDR_LEN] = {0};
        0x0020a70a:    9102        ..      STR      r1,[sp,#8]
;;;34         uint8_t  adv_filter_policy = GAP_ADV_FILTER_ANY;
        0x0020a70c:    9103        ..      STR      r1,[sp,#0xc]
        0x0020a70e:    f88d1010    ....    STRB     r1,[sp,#0x10]
;;;35     
;;;36         switch (adv_type)
        0x0020a712:    2801        .(      CMP      r0,#1
        0x0020a714:    d122        ".      BNE      0x20a75c ; keyboard_start_adv + 96
;;;37         {
;;;38         case ADV_RECONECT:
;;;39             {
;;;40                 T_LE_KEY_ENTRY *p_entry;
;;;41                 p_entry = le_get_high_priority_bond();
        0x0020a716:    f645fe13    E...    BL       le_get_high_priority_bond ; 0x50340
;;;42                 if ((p_entry->flags & LE_KEY_STORE_REMOTE_IRK_BIT) == 0)
        0x0020a71a:    7881        .x      LDRB     r1,[r0,#2]
        0x0020a71c:    f04f0403    O...    MOV      r4,#3
        0x0020a720:    0709        ..      LSLS     r1,r1,#28
        0x0020a722:    d413        ..      BMI      0x20a74c ; keyboard_start_adv + 80
;;;43                 {
;;;44                     if ((p_entry->remote_bd.remote_bd_type == GAP_REMOTE_ADDR_LE_PUBLIC) ||
        0x0020a724:    7b81        .{      LDRB     r1,[r0,#0xe]
        0x0020a726:    b129        ).      CBZ      r1,0x20a734 ; keyboard_start_adv + 56
;;;45                         ((p_entry->remote_bd.remote_bd_type == GAP_REMOTE_ADDR_LE_RANDOM) &&
        0x0020a728:    2901        .)      CMP      r1,#1
        0x0020a72a:    d117        ..      BNE      0x20a75c ; keyboard_start_adv + 96
;;;46                          ((p_entry->remote_bd.addr[5] & RANDOM_ADDR_MASK) == RANDOM_ADDR_MASK_STATIC))
        0x0020a72c:    7b41        A{      LDRB     r1,[r0,#0xd]
        0x0020a72e:    ebb41f91    ....    CMP      r4,r1,LSR #6
        0x0020a732:    d113        ..      BNE      0x20a75c ; keyboard_start_adv + 96
;;;47                        )
;;;48                     {
;;;49                         adv_evt_type = GAP_ADTYPE_ADV_HDC_DIRECT_IND;
        0x0020a734:    2101        .!      MOVS     r1,#1
        0x0020a736:    f88d1000    ....    STRB     r1,[sp,#0]
;;;50                         memcpy(adv_direct_addr, p_entry->remote_bd.addr, GAP_BD_ADDR_LEN);
        0x0020a73a:    6881        .h      LDR      r1,[r0,#8]
        0x0020a73c:    9102        ..      STR      r1,[sp,#8]
        0x0020a73e:    8981        ..      LDRH     r1,[r0,#0xc]
        0x0020a740:    f8ad100c    ....    STRH     r1,[sp,#0xc]
;;;51                         adv_direct_type = p_entry->remote_bd.remote_bd_type;
        0x0020a744:    7b80        .{      LDRB     r0,[r0,#0xe]
        0x0020a746:    f88d0004    ....    STRB     r0,[sp,#4]
        0x0020a74a:    e007        ..      B        0x20a75c ; keyboard_start_adv + 96
;;;52                     }
;;;53                 }
;;;54                 else
;;;55                 {
;;;56                     if (app_privacy_resolution_state == LE_PRIVACY_RESOLUTION_DISABLED)
        0x0020a74c:    4843        CH      LDR      r0,[pc,#268] ; [0x20a85c] = 0x20bce1
        0x0020a74e:    7800        .x      LDRB     r0,[r0,#0]
        0x0020a750:    b910        ..      CBNZ     r0,0x20a758 ; keyboard_start_adv + 92
;;;57                     {
;;;58                         le_privacy_set_addr_resolution(true);
        0x0020a752:    2001        .       MOVS     r0,#1
        0x0020a754:    f647fa4f    G.O.    BL       le_privacy_set_addr_resolution ; 0x51bf6
;;;59                     }
;;;60                     adv_filter_policy = GAP_ADV_FILTER_WHITE_LIST_ALL;
        0x0020a758:    f88d4010    ...@    STRB     r4,[sp,#0x10]
;;;61                 }
;;;62                 break;
;;;63             }
;;;64         case ADV_UNDIRECT_PAIRING:
;;;65             {
;;;66                 break;
;;;67             }
;;;68         default:
;;;69             break;
;;;70         }
;;;71     
;;;72         le_adv_set_param(GAP_PARAM_ADV_EVENT_TYPE, sizeof(adv_evt_type), &adv_evt_type);
        0x0020a75c:    466a        jF      MOV      r2,sp
        0x0020a75e:    2101        .!      MOVS     r1,#1
        0x0020a760:    f2402063    @.c     MOV      r0,#0x263
        0x0020a764:    f647fb94    G...    BL       le_adv_set_param ; 0x51e90
;;;73         le_adv_set_param(GAP_PARAM_ADV_DIRECT_ADDR_TYPE, sizeof(adv_direct_type), &adv_direct_type);
        0x0020a768:    aa01        ..      ADD      r2,sp,#4
        0x0020a76a:    2101        .!      MOVS     r1,#1
        0x0020a76c:    f44f7019    O..p    MOV      r0,#0x264
        0x0020a770:    f647fb8e    G...    BL       le_adv_set_param ; 0x51e90
;;;74         le_adv_set_param(GAP_PARAM_ADV_DIRECT_ADDR, sizeof(adv_direct_addr), adv_direct_addr);
        0x0020a774:    aa02        ..      ADD      r2,sp,#8
        0x0020a776:    2106        .!      MOVS     r1,#6
        0x0020a778:    f2402065    @.e     MOV      r0,#0x265
        0x0020a77c:    f647fb88    G...    BL       le_adv_set_param ; 0x51e90
;;;75         le_adv_set_param(GAP_PARAM_ADV_FILTER_POLICY, sizeof(adv_filter_policy), &adv_filter_policy);
        0x0020a780:    aa04        ..      ADD      r2,sp,#0x10
        0x0020a782:    2101        .!      MOVS     r1,#1
        0x0020a784:    f2402067    @.g     MOV      r0,#0x267
        0x0020a788:    f647fb82    G...    BL       le_adv_set_param ; 0x51e90
;;;76         le_adv_start();
        0x0020a78c:    f647fc9b    G...    BL       le_adv_start ; 0x520c6
;;;77     }
        0x0020a790:    b006        ..      ADD      sp,sp,#0x18
        0x0020a792:    bd10        ..      POP      {r4,pc}
    keyboard_update_con_para
;;;78     
;;;79     
;;;80     /**
;;;81     * @brief   connection parameter update timeout callback
;;;82     * @return  void
;;;83     */
;;;84     void keyboard_update_con_para(void *pxTimer)
;;;85     {
        0x0020a794:    e92d43f0    -..C    PUSH     {r4-r9,lr}
        0x0020a798:    4831        1H      LDR      r0,[pc,#196] ; [0x20a860] = 0x20bc89
;;; ..\..\..\src\app\keyboard\profile_init.c (85)
        0x0020a79a:    b087        ..      SUB      sp,sp,#0x1c
        0x0020a79c:    7800        .x      LDRB     r0,[r0,#0]
        0x0020a79e:    2802        .(      CMP      r0,#2
        0x0020a7a0:    d13a        :.      BNE      0x20a818 ; keyboard_update_con_para + 132
;;;86         if (gap_conn_state != GAP_CONN_STATE_CONNECTED)
;;;87         {
;;;88             return;
;;;89         }
;;;90         APP_PRINT_INFO0("connection parameter update callback!");
        0x0020a7a2:    f8df90c4    ....    LDR      r9,[pc,#196] ; [0x20a868] = 0x21103002
        0x0020a7a6:    2200        ."      MOVS     r2,#0
        0x0020a7a8:    492e        .I      LDR      r1,[pc,#184] ; [0x20a864] = 0x880131c
        0x0020a7aa:    4648        HF      MOV      r0,r9
        0x0020a7ac:    f5fdf957    ..W.    BL       log_buffer ; 0x7a5e
;;;91         uint16_t conn_interval;
;;;92         uint16_t conn_slave_latency;
;;;93         uint16_t conn_supervision_timeout;
;;;94     
;;;95         le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, keyboard_con_id);
        0x0020a7b0:    4c2e        .L      LDR      r4,[pc,#184] ; [0x20a86c] = 0x20bc90
        0x0020a7b2:    a903        ..      ADD      r1,sp,#0xc
        0x0020a7b4:    f2402072    @.r     MOV      r0,#0x272
        0x0020a7b8:    7822        "x      LDRB     r2,[r4,#0]
        0x0020a7ba:    f643f960    C.`.    BL       le_get_conn_param ; 0x4da7e
;;;96         le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, keyboard_con_id);
        0x0020a7be:    7822        "x      LDRB     r2,[r4,#0]
        0x0020a7c0:    a904        ..      ADD      r1,sp,#0x10
        0x0020a7c2:    f2402073    @.s     MOV      r0,#0x273
        0x0020a7c6:    f643f95a    C.Z.    BL       le_get_conn_param ; 0x4da7e
;;;97         le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, keyboard_con_id);
        0x0020a7ca:    7822        "x      LDRB     r2,[r4,#0]
        0x0020a7cc:    a905        ..      ADD      r1,sp,#0x14
        0x0020a7ce:    f44f701d    O..p    MOV      r0,#0x274
        0x0020a7d2:    f643f954    C.T.    BL       le_get_conn_param ; 0x4da7e
;;;98     
;;;99         if (((conn_slave_latency + 1) * conn_interval < 16) || (conn_slave_latency == 0))
        0x0020a7d6:    f8bd0010    ....    LDRH     r0,[sp,#0x10]
        0x0020a7da:    f8bd200c    ...     LDRH     r2,[sp,#0xc]
        0x0020a7de:    1c41        A.      ADDS     r1,r0,#1
        0x0020a7e0:    4351        QC      MULS     r1,r2,r1
        0x0020a7e2:    2910        .)      CMP      r1,#0x10
        0x0020a7e4:    db01        ..      BLT      0x20a7ea ; keyboard_update_con_para + 86
        0x0020a7e6:    2800        .(      CMP      r0,#0
        0x0020a7e8:    d116        ..      BNE      0x20a818 ; keyboard_update_con_para + 132
        0x0020a7ea:    491e        .I      LDR      r1,[pc,#120] ; [0x20a864] = 0x880131c
;;;100        {
;;;101            uint16_t desired_interval_min = 6;
        0x0020a7ec:    2706        .'      MOVS     r7,#6
;;;102            uint16_t desired_interval_max = 16;
        0x0020a7ee:    2610        .&      MOVS     r6,#0x10
;;;103            uint16_t desired_latency = 20;
        0x0020a7f0:    2514        .%      MOVS     r5,#0x14
;;;104            uint16_t desired_superv_tout = 3000;
        0x0020a7f2:    f64038b8    @..8    MOV      r8,#0xbb8
;;;105            APP_PRINT_INFO0("connection parameter update request!");
        0x0020a7f6:    2200        ."      MOVS     r2,#0
        0x0020a7f8:    312c        ,1      ADDS     r1,r1,#0x2c
        0x0020a7fa:    4648        HF      MOV      r0,r9
        0x0020a7fc:    f5fdf92f    ../.    BL       log_buffer ; 0x7a5e
;;;106            le_update_conn_param(keyboard_con_id, desired_interval_min, desired_interval_max, desired_latency,
        0x0020a800:    210a        .!      MOVS     r1,#0xa
        0x0020a802:    fbb8f0f1    ....    UDIV     r0,r8,r1
        0x0020a806:    221e        ."      MOVS     r2,#0x1e
        0x0020a808:    e88d0007    ....    STM      sp,{r0-r2}
        0x0020a80c:    462b        +F      MOV      r3,r5
        0x0020a80e:    4632        2F      MOV      r2,r6
        0x0020a810:    4639        9F      MOV      r1,r7
        0x0020a812:    7820         x      LDRB     r0,[r4,#0]
        0x0020a814:    f643fa39    C.9.    BL       le_update_conn_param ; 0x4dc8a
;;;107                                 desired_superv_tout / 10, desired_interval_min * 2 - 2, desired_interval_max * 2 - 2);
;;;108        }
;;;109    
;;;110    }
        0x0020a818:    b007        ..      ADD      sp,sp,#0x1c
        0x0020a81a:    e8bd83f0    ....    POP      {r4-r9,pc}
    connection_param_updata_timer_init
;;;111    
;;;112    
;;;113    /**
;;;114    * @brief   create connection parameter update timer
;;;115    * @return  void
;;;116    */
;;;117    void connection_param_updata_timer_init(void)
;;;118    {
        0x0020a81e:    b51c        ..      PUSH     {r2-r4,lr}
;;;119        os_timer_create(&con_update_timer, "con param update timer", 1, 30000, false,
        0x0020a820:    f2af018f    ....    ADR      r1,{pc}-0x8b ; 0x20a795
        0x0020a824:    2000        .       MOVS     r0,#0
        0x0020a826:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0020a82a:    f2475330    G.0S    MOV      r3,#0x7530
        0x0020a82e:    2201        ."      MOVS     r2,#1
        0x0020a830:    a10f        ..      ADR      r1,{pc}+0x40 ; 0x20a870
        0x0020a832:    4815        .H      LDR      r0,[pc,#84] ; [0x20a888] = 0x20bcdc
        0x0020a834:    f61cf9cf    ....    BL       os_timer_create ; 0x26bd6
;;;120                        keyboard_update_con_para);
;;;121    }
        0x0020a838:    bd1c        ..      POP      {r2-r4,pc}
    stop_con_update_timer
        0x0020a83a:    4813        .H      LDR      r0,[pc,#76] ; [0x20a888] = 0x20bcdc
        0x0020a83c:    6800        .h      LDR      r0,[r0,#0]
;;;122    
;;;123    
;;;124    /**
;;;125    * @brief   stop con param update timer
;;;126    * @return  void
;;;127    */
;;;128    void stop_con_update_timer(void)
;;;129    {
        0x0020a83e:    2800        .(      CMP      r0,#0
        0x0020a840:    d002        ..      BEQ      0x20a848 ; stop_con_update_timer + 14
;;;130        if (con_update_timer != NULL)
;;;131        {
;;;132            os_timer_stop(&con_update_timer);
        0x0020a842:    4811        .H      LDR      r0,[pc,#68] ; [0x20a888] = 0x20bcdc
        0x0020a844:    f61cba0e    ....    B        os_timer_stop ; 0x26c64
;;;133        }
;;;134    }
        0x0020a848:    4770        pG      BX       lr
    start_con_update_timer
        0x0020a84a:    480f        .H      LDR      r0,[pc,#60] ; [0x20a888] = 0x20bcdc
        0x0020a84c:    6800        .h      LDR      r0,[r0,#0]
;;;135    
;;;136    /**
;;;137    * @brief   stop con param update timer
;;;138    * @return  void
;;;139    */
;;;140    void start_con_update_timer(void)
;;;141    {
        0x0020a84e:    2800        .(      CMP      r0,#0
        0x0020a850:    d002        ..      BEQ      0x20a858 ; start_con_update_timer + 14
;;;142        if (con_update_timer != NULL)
;;;143        {
;;;144            os_timer_start(&con_update_timer);
        0x0020a852:    480d        .H      LDR      r0,[pc,#52] ; [0x20a888] = 0x20bcdc
        0x0020a854:    f61cb9e2    ....    B        os_timer_start ; 0x26c1c
;;;145        }
;;;146    }
        0x0020a858:    4770        pG      BX       lr
    $d
        0x0020a85a:    0000        ..      DCW    0
        0x0020a85c:    0020bce1    .. .    DCD    2145505
        0x0020a860:    0020bc89    .. .    DCD    2145417
        0x0020a864:    0880131c    ....    DCD    142611228
        0x0020a868:    21103002    .0.!    DCD    554708994
        0x0020a86c:    0020bc90    .. .    DCD    2145424
        0x0020a870:    206e6f63    con     DCD    544108387
        0x0020a874:    61726170    para    DCD    1634886000
        0x0020a878:    7075206d    m up    DCD    1886724205
        0x0020a87c:    65746164    date    DCD    1702125924
        0x0020a880:    6d697420     tim    DCD    1835627552
        0x0020a884:    00007265    er..    DCD    29285
        0x0020a888:    0020bcdc    .. .    DCD    2145500
    $t
    .text
    privacy_modify_resolving_list
;;; ..\..\..\src\app\keyboard\privacy_mgnt.c
;;;24     {
        0x0020a88c:    e92d47fc    -..G    PUSH     {r2-r10,lr}
        0x0020a890:    460d        .F      MOV      r5,r1
        0x0020a892:    4680        .F      MOV      r8,r0
        0x0020a894:    461e        .F      MOV      r6,r3
        0x0020a896:    4692        .F      MOV      r10,r2
;;;25         T_GAP_CAUSE cause;
;;;26         APP_PRINT_INFO3("T_GAP_RESOLV_LIST_OP %d, BD %s, type %d\n", op, TRACE_BDADDR(addr), addr_type);
        0x0020a898:    4611        .F      MOV      r1,r2
        0x0020a89a:    48a2        .H      LDR      r0,[pc,#648] ; [0x20ab24] = 0x21300000
        0x0020a89c:    f5fdfa9c    ....    BL       trace_bdaddr ; 0x7dd8
        0x0020a8a0:    e9cd0500    ....    STRD     r0,r5,[sp,#0]
        0x0020a8a4:    f8df9284    ....    LDR      r9,[pc,#644] ; [0x20ab2c] = 0x21103002
        0x0020a8a8:    4643        CF      MOV      r3,r8
        0x0020a8aa:    2203        ."      MOVS     r2,#3
        0x0020a8ac:    499e        .I      LDR      r1,[pc,#632] ; [0x20ab28] = 0x8801370
        0x0020a8ae:    4648        HF      MOV      r0,r9
        0x0020a8b0:    f5fdf8d5    ....    BL       log_buffer ; 0x7a5e
        0x0020a8b4:    4c9e        .L      LDR      r4,[pc,#632] ; [0x20ab30] = 0x20bce0
        0x0020a8b6:    f1a90702    ....    SUB      r7,r9,#2
;;;27         switch (op)
        0x0020a8ba:    f1b80f00    ....    CMP      r8,#0
        0x0020a8be:    d01d        ..      BEQ      0x20a8fc ; privacy_modify_resolving_list + 112
        0x0020a8c0:    f1b80f01    ....    CMP      r8,#1
        0x0020a8c4:    d032        2.      BEQ      0x20a92c ; privacy_modify_resolving_list + 160
        0x0020a8c6:    f1b80f02    ....    CMP      r8,#2
        0x0020a8ca:    d16b        k.      BNE      0x20a9a4 ; privacy_modify_resolving_list + 280
        0x0020a8cc:    4996        .I      LDR      r1,[pc,#600] ; [0x20ab28] = 0x8801370
        0x0020a8ce:    2200        ."      MOVS     r2,#0
        0x0020a8d0:    31b0        .1      ADDS     r1,r1,#0xb0
        0x0020a8d2:    4648        HF      MOV      r0,r9
        0x0020a8d4:    f5fdf8c3    ....    BL       log_buffer ; 0x7a5e
        0x0020a8d8:    4652        RF      MOV      r2,r10
        0x0020a8da:    4629        )F      MOV      r1,r5
        0x0020a8dc:    2002        .       MOVS     r0,#2
        0x0020a8de:    f647f9e4    G...    BL       le_privacy_modify_resolv_list ; 0x51caa
        0x0020a8e2:    0003        ..      MOVS     r3,r0
        0x0020a8e4:    d04a        J.      BEQ      0x20a97c ; privacy_modify_resolving_list + 240
        0x0020a8e6:    2b02        .+      CMP      r3,#2
        0x0020a8e8:    d053        S.      BEQ      0x20a992 ; privacy_modify_resolving_list + 262
        0x0020a8ea:    498f        .I      LDR      r1,[pc,#572] ; [0x20ab28] = 0x8801370
        0x0020a8ec:    2201        ."      MOVS     r2,#1
        0x0020a8ee:    31cc        .1      ADDS     r1,r1,#0xcc
        0x0020a8f0:    b002        ..      ADD      sp,sp,#8
        0x0020a8f2:    4638        8F      MOV      r0,r7
        0x0020a8f4:    e8bd47f0    ...G    POP      {r4-r10,lr}
        0x0020a8f8:    f5fdb8b1    ....    B        log_buffer ; 0x7a5e
;;;28         {
;;;29         case GAP_RESOLV_LIST_OP_CLEAR:
;;;30             {
;;;31                 APP_PRINT_INFO0("resolving list clear");
        0x0020a8fc:    498a        .I      LDR      r1,[pc,#552] ; [0x20ab28] = 0x8801370
        0x0020a8fe:    2200        ."      MOVS     r2,#0
        0x0020a900:    312c        ,1      ADDS     r1,r1,#0x2c
        0x0020a902:    4648        HF      MOV      r0,r9
        0x0020a904:    f5fdf8ab    ....    BL       log_buffer ; 0x7a5e
;;;32                 cause = le_privacy_modify_resolv_list(GAP_RESOLV_LIST_OP_CLEAR, GAP_IDENT_ADDR_PUBLIC, NULL);
        0x0020a908:    2200        ."      MOVS     r2,#0
        0x0020a90a:    4611        .F      MOV      r1,r2
        0x0020a90c:    4610        .F      MOV      r0,r2
        0x0020a90e:    f647f9cc    G...    BL       le_privacy_modify_resolv_list ; 0x51caa
        0x0020a912:    0003        ..      MOVS     r3,r0
;;;33                 if (cause == GAP_CAUSE_SUCCESS)
        0x0020a914:    d003        ..      BEQ      0x20a91e ; privacy_modify_resolving_list + 146
        0x0020a916:    4984        .I      LDR      r1,[pc,#528] ; [0x20ab28] = 0x8801370
        0x0020a918:    2201        ."      MOVS     r2,#1
        0x0020a91a:    3144        D1      ADDS     r1,r1,#0x44
        0x0020a91c:    e7e8        ..      B        0x20a8f0 ; privacy_modify_resolving_list + 100
;;;34                 {
;;;35                     if (privacy_whitelist)
        0x0020a91e:    7820         x      LDRB     r0,[r4,#0]
        0x0020a920:    2800        .(      CMP      r0,#0
        0x0020a922:    d03f        ?.      BEQ      0x20a9a4 ; privacy_modify_resolving_list + 280
;;;36                     {
;;;37                         le_modify_white_list(GAP_WHITE_LIST_OP_CLEAR, NULL, GAP_REMOTE_ADDR_LE_PUBLIC);
        0x0020a924:    2200        ."      MOVS     r2,#0
        0x0020a926:    4611        .F      MOV      r1,r2
        0x0020a928:    4610        .F      MOV      r0,r2
        0x0020a92a:    e02d        -.      B        0x20a988 ; privacy_modify_resolving_list + 252
;;;38                     }
;;;39                 }
;;;40                 else
;;;41                 {
;;;42                     APP_PRINT_ERROR1("clear failed: cause %d", cause);
;;;43                 }
;;;44             }
;;;45             break;
;;;46         case GAP_RESOLV_LIST_OP_ADD:
;;;47             {
;;;48                 APP_PRINT_INFO0("resolving list add");
        0x0020a92c:    497e        ~I      LDR      r1,[pc,#504] ; [0x20ab28] = 0x8801370
        0x0020a92e:    2200        ."      MOVS     r2,#0
        0x0020a930:    3160        `1      ADDS     r1,r1,#0x60
        0x0020a932:    4648        HF      MOV      r0,r9
        0x0020a934:    f5fdf893    ....    BL       log_buffer ; 0x7a5e
;;;49                 cause = le_privacy_modify_resolv_list(GAP_RESOLV_LIST_OP_ADD, addr_type, addr);
        0x0020a938:    4652        RF      MOV      r2,r10
        0x0020a93a:    4629        )F      MOV      r1,r5
        0x0020a93c:    2001        .       MOVS     r0,#1
        0x0020a93e:    f647f9b4    G...    BL       le_privacy_modify_resolv_list ; 0x51caa
        0x0020a942:    0003        ..      MOVS     r3,r0
;;;50                 if (cause == GAP_CAUSE_SUCCESS)
        0x0020a944:    d005        ..      BEQ      0x20a952 ; privacy_modify_resolving_list + 198
        0x0020a946:    2b02        .+      CMP      r3,#2
        0x0020a948:    d014        ..      BEQ      0x20a974 ; privacy_modify_resolving_list + 232
        0x0020a94a:    4977        wI      LDR      r1,[pc,#476] ; [0x20ab28] = 0x8801370
        0x0020a94c:    2201        ."      MOVS     r2,#1
        0x0020a94e:    3178        x1      ADDS     r1,r1,#0x78
        0x0020a950:    e7ce        ..      B        0x20a8f0 ; privacy_modify_resolving_list + 100
;;;51                 {
;;;52                     if (privacy_whitelist)
        0x0020a952:    7820         x      LDRB     r0,[r4,#0]
        0x0020a954:    b120         .      CBZ      r0,0x20a960 ; privacy_modify_resolving_list + 212
;;;53                     {
;;;54                         le_modify_white_list(GAP_WHITE_LIST_OP_ADD, addr,
        0x0020a956:    462a        *F      MOV      r2,r5
        0x0020a958:    4651        QF      MOV      r1,r10
        0x0020a95a:    2001        .       MOVS     r0,#1
        0x0020a95c:    f642fa7a    B.z.    BL       le_modify_white_list ; 0x4ce54
;;;55                                              (T_GAP_REMOTE_ADDR_TYPE)addr_type);
;;;56                     }
;;;57                     if (device_mode)
        0x0020a960:    2e00        ..      CMP      r6,#0
        0x0020a962:    d01f        ..      BEQ      0x20a9a4 ; privacy_modify_resolving_list + 280
;;;58                     {
;;;59                         le_privacy_set_mode(addr_type, addr, GAP_PRIVACY_MODE_DEVICE);
        0x0020a964:    b002        ..      ADD      sp,sp,#8
        0x0020a966:    4651        QF      MOV      r1,r10
        0x0020a968:    4628        (F      MOV      r0,r5
        0x0020a96a:    e8bd47f0    ...G    POP      {r4-r10,lr}
        0x0020a96e:    2201        ."      MOVS     r2,#1
        0x0020a970:    f647b9f7    G...    B        le_privacy_set_mode ; 0x51d62
;;;60                     }
;;;61                 }
;;;62                 else if (cause != GAP_CAUSE_INVALID_STATE)
;;;63                 {
;;;64                     APP_PRINT_ERROR1("Add failed: cause %d", cause);
;;;65                 }
;;;66                 else
;;;67                 {
;;;68                     APP_PRINT_ERROR0("Add failed: invalid state");
        0x0020a974:    496c        lI      LDR      r1,[pc,#432] ; [0x20ab28] = 0x8801370
        0x0020a976:    2200        ."      MOVS     r2,#0
        0x0020a978:    3190        .1      ADDS     r1,r1,#0x90
        0x0020a97a:    e00d        ..      B        0x20a998 ; privacy_modify_resolving_list + 268
;;;69                 }
;;;70             }
;;;71             break;
;;;72         case GAP_RESOLV_LIST_OP_REMOVE:
;;;73             {
;;;74                 APP_PRINT_INFO0("resolving list remove");
;;;75                 cause = le_privacy_modify_resolv_list(GAP_RESOLV_LIST_OP_REMOVE, addr_type, addr);
;;;76                 if (cause == GAP_CAUSE_SUCCESS)
;;;77                 {
;;;78                     if (privacy_whitelist)
        0x0020a97c:    7820         x      LDRB     r0,[r4,#0]
        0x0020a97e:    2800        .(      CMP      r0,#0
        0x0020a980:    d010        ..      BEQ      0x20a9a4 ; privacy_modify_resolving_list + 280
;;;79                     {
;;;80                         le_modify_white_list(GAP_WHITE_LIST_OP_REMOVE, addr, (T_GAP_REMOTE_ADDR_TYPE)addr_type);
        0x0020a982:    462a        *F      MOV      r2,r5
        0x0020a984:    4651        QF      MOV      r1,r10
        0x0020a986:    2002        .       MOVS     r0,#2
        0x0020a988:    b002        ..      ADD      sp,sp,#8
        0x0020a98a:    e8bd47f0    ...G    POP      {r4-r10,lr}
        0x0020a98e:    f642ba61    B.a.    B        le_modify_white_list ; 0x4ce54
;;;81                     }
;;;82                 }
;;;83                 else if (cause != GAP_CAUSE_INVALID_STATE)
;;;84                 {
;;;85                     APP_PRINT_ERROR1("Remove failed: cause %d", cause);
;;;86                 }
;;;87                 else
;;;88                 {
;;;89                     APP_PRINT_ERROR0("Remove failed: invalid state");
        0x0020a992:    4965        eI      LDR      r1,[pc,#404] ; [0x20ab28] = 0x8801370
        0x0020a994:    2200        ."      MOVS     r2,#0
        0x0020a996:    31e8        .1      ADDS     r1,r1,#0xe8
        0x0020a998:    b002        ..      ADD      sp,sp,#8
        0x0020a99a:    4638        8F      MOV      r0,r7
        0x0020a99c:    e8bd47f0    ...G    POP      {r4-r10,lr}
        0x0020a9a0:    f5fdb85d    ..].    B        log_buffer ; 0x7a5e
;;;90                 }
;;;91             }
;;;92             break;
;;;93         default:
;;;94             break;
;;;95         }
;;;96     
;;;97     }
        0x0020a9a4:    e8bd87fc    ....    POP      {r2-r10,pc}
    privacy_add_device
;;;98     
;;;99     
;;;100    /**
;;;101    * @brief   add privacy device to resolving list
;;;102    * @return  void
;;;103    */
;;;104    bool privacy_add_device(T_LE_KEY_ENTRY *p_entry)
;;;105    {
        0x0020a9a8:    b5f8        ..      PUSH     {r3-r7,lr}
        0x0020a9aa:    0004        ..      MOVS     r4,r0
        0x0020a9ac:    d042        B.      BEQ      0x20aa34 ; privacy_add_device + 140
;;;106        if (p_entry != NULL && p_entry->is_used)
        0x0020a9ae:    7823        #x      LDRB     r3,[r4,#0]
        0x0020a9b0:    b3bb        ..      CBZ      r3,0x20aa22 ; privacy_add_device + 122
;;;107        {
;;;108    
;;;109            APP_PRINT_INFO1("privacy_add_device: p_entry->is_used = %d", p_entry->is_used);
        0x0020a9b2:    4e5e        ^N      LDR      r6,[pc,#376] ; [0x20ab2c] = 0x21103002
        0x0020a9b4:    2201        ."      MOVS     r2,#1
        0x0020a9b6:    495f        _I      LDR      r1,[pc,#380] ; [0x20ab34] = 0x8801478
        0x0020a9b8:    4630        0F      MOV      r0,r6
        0x0020a9ba:    f5fdf850    ..P.    BL       log_buffer ; 0x7a5e
;;;110            bool device_mode = true;
        0x0020a9be:    2501        .%      MOVS     r5,#1
;;;111            T_LE_PRIVACY_INFO privacy_info;
;;;112            if (le_get_privacy_info(p_entry, &privacy_info))
        0x0020a9c0:    4669        iF      MOV      r1,sp
        0x0020a9c2:    4620         F      MOV      r0,r4
        0x0020a9c4:    f646f8d9    F...    BL       le_get_privacy_info ; 0x50b7a
        0x0020a9c8:    b130        0.      CBZ      r0,0x20a9d8 ; privacy_add_device + 48
;;;113            {
;;;114                if (privacy_info.is_discov && privacy_info.resolv_addr_only)
        0x0020a9ca:    f89d0000    ....    LDRB     r0,[sp,#0]
        0x0020a9ce:    b118        ..      CBZ      r0,0x20a9d8 ; privacy_add_device + 48
        0x0020a9d0:    f89d0002    ....    LDRB     r0,[sp,#2]
        0x0020a9d4:    b100        ..      CBZ      r0,0x20a9d8 ; privacy_add_device + 48
;;;115                {
;;;116                    device_mode = false;
        0x0020a9d6:    2500        .%      MOVS     r5,#0
;;;117                }
;;;118            }
;;;119            if (p_entry->flags & LE_KEY_STORE_REMOTE_IRK_BIT)
        0x0020a9d8:    78a0        .x      LDRB     r0,[r4,#2]
        0x0020a9da:    f04f0200    O...    MOV      r2,#0
        0x0020a9de:    0700        ..      LSLS     r0,r0,#28
        0x0020a9e0:    d509        ..      BPL      0x20a9f6 ; privacy_add_device + 78
;;;120            {
;;;121                APP_PRINT_INFO0("privacy_add_device: LE_KEY_STORE_REMOTE_IRK_BIT");
        0x0020a9e2:    4954        TI      LDR      r1,[pc,#336] ; [0x20ab34] = 0x8801478
        0x0020a9e4:    4630        0F      MOV      r0,r6
        0x0020a9e6:    3130        01      ADDS     r1,r1,#0x30
        0x0020a9e8:    f5fdf839    ..9.    BL       log_buffer ; 0x7a5e
;;;122                privacy_modify_resolving_list(GAP_RESOLV_LIST_OP_ADD,
        0x0020a9ec:    7da1        .}      LDRB     r1,[r4,#0x16]
        0x0020a9ee:    462b        +F      MOV      r3,r5
        0x0020a9f0:    f1040210    ....    ADD      r2,r4,#0x10
;;;123                                              (T_GAP_IDENT_ADDR_TYPE)p_entry->resolved_remote_bd.remote_bd_type,
;;;124                                              p_entry->resolved_remote_bd.addr, device_mode);
;;;125                return true;
        0x0020a9f4:    e010        ..      B        0x20aa18 ; privacy_add_device + 112
;;;126            }
;;;127            else
;;;128            {
;;;129                APP_PRINT_INFO0("privacy_add_device: GAP_REMOTE_ADDR_LE_PUBLIC");
        0x0020a9f6:    494f        OI      LDR      r1,[pc,#316] ; [0x20ab34] = 0x8801478
        0x0020a9f8:    4630        0F      MOV      r0,r6
        0x0020a9fa:    3164        d1      ADDS     r1,r1,#0x64
        0x0020a9fc:    f5fdf82f    ../.    BL       log_buffer ; 0x7a5e
;;;130                if ((p_entry->remote_bd.remote_bd_type == GAP_REMOTE_ADDR_LE_PUBLIC) ||
        0x0020aa00:    7ba1        .{      LDRB     r1,[r4,#0xe]
        0x0020aa02:    b131        1.      CBZ      r1,0x20aa12 ; privacy_add_device + 106
;;;131                    ((p_entry->remote_bd.remote_bd_type == GAP_REMOTE_ADDR_LE_RANDOM) &&
        0x0020aa04:    2901        .)      CMP      r1,#1
        0x0020aa06:    d10d        ..      BNE      0x20aa24 ; privacy_add_device + 124
;;;132                     ((p_entry->remote_bd.addr[5] & RANDOM_ADDR_MASK) == RANDOM_ADDR_MASK_STATIC))
        0x0020aa08:    7b60        `{      LDRB     r0,[r4,#0xd]
        0x0020aa0a:    2203        ."      MOVS     r2,#3
        0x0020aa0c:    ebb21f90    ....    CMP      r2,r0,LSR #6
        0x0020aa10:    d108        ..      BNE      0x20aa24 ; privacy_add_device + 124
;;;133                   )
;;;134                {
;;;135                    privacy_modify_resolving_list(GAP_RESOLV_LIST_OP_ADD,
        0x0020aa12:    462b        +F      MOV      r3,r5
        0x0020aa14:    f1040208    ....    ADD      r2,r4,#8
        0x0020aa18:    2001        .       MOVS     r0,#1
        0x0020aa1a:    f7ffff37    ..7.    BL       privacy_modify_resolving_list ; 0x20a88c
;;;136                                                  (T_GAP_IDENT_ADDR_TYPE)p_entry->remote_bd.remote_bd_type,
;;;137                                                  p_entry->remote_bd.addr, device_mode);
;;;138                    return true;
        0x0020aa1e:    2001        .       MOVS     r0,#1
        0x0020aa20:    bdf8        ..      POP      {r3-r7,pc}
        0x0020aa22:    e007        ..      B        0x20aa34 ; privacy_add_device + 140
;;;139                }
;;;140                else
;;;141                {
;;;142                    APP_PRINT_ERROR1("privacy_add_device: failed, idx %d", p_entry->idx);
        0x0020aa24:    4943        CI      LDR      r1,[pc,#268] ; [0x20ab34] = 0x8801478
        0x0020aa26:    4841        AH      LDR      r0,[pc,#260] ; [0x20ab2c] = 0x21103002
        0x0020aa28:    7863        cx      LDRB     r3,[r4,#1]
        0x0020aa2a:    2201        ."      MOVS     r2,#1
        0x0020aa2c:    3198        .1      ADDS     r1,r1,#0x98
        0x0020aa2e:    1e80        ..      SUBS     r0,r0,#2
        0x0020aa30:    f5fdf815    ....    BL       log_buffer ; 0x7a5e
;;;143                }
;;;144            }
;;;145        }
;;;146        return false;
        0x0020aa34:    2000        .       MOVS     r0,#0
;;;147    }
        0x0020aa36:    e7f3        ..      B        0x20aa20 ; privacy_add_device + 120
    privacy_handle_le_privacy_modify_resolv_list_rsp
;;;148    
;;;149    /**
;;;150    * @brief   privacy init
;;;151    * @return  void
;;;152    */
;;;153    void privacy_init(bool whitelist)
;;;154    {
;;;155        T_LE_KEY_ENTRY *p_entry;
;;;156    
;;;157        APP_PRINT_INFO1("privacy_init: whitelist %d", whitelist);
;;;158    
;;;159        privacy_whitelist = whitelist;
;;;160        le_privacy_register_cb(privacy_msg_callback);
;;;161    
;;;162        p_entry = le_get_high_priority_bond();
;;;163        if ((p_entry != NULL) && (p_entry->is_used))
;;;164        {
;;;165            privacy_add_device(p_entry);
;;;166        }
;;;167        return;
;;;168    }
;;;169    
;;;170    
;;;171    /**
;;;172    * @brief   handle privacy resolution status
;;;173    * @return  void
;;;174    */
;;;175    void privacy_handle_le_privacy_resolution_status_info(T_LE_PRIVACY_RESOLUTION_STATUS_INFO
;;;176                                                          resolv_status)
;;;177    {
;;;178        APP_PRINT_INFO1("privacy_handle_le_privacy_resolution_status_info: status 0x%x\n",
;;;179                        resolv_status.status);
;;;180        app_privacy_resolution_state = resolv_status.status;
;;;181    }
;;;182    
;;;183    /**
;;;184    * @brief   modify resolving list response
;;;185    * @return  void
;;;186    */
;;;187    void privacy_handle_le_privacy_modify_resolv_list_rsp(T_LE_PRIVACY_MODIFY_RESOLV_LIST_RSP *p_rsp)
;;;188    {
        0x0020aa38:    b538        8.      PUSH     {r3-r5,lr}
        0x0020aa3a:    4604        .F      MOV      r4,r0
;;;189        APP_PRINT_INFO2("privacy_handle_le_privacy_modify_resolv_list_rsp: operation  0x%x, casue 0x%x",
        0x0020aa3c:    8840        @.      LDRH     r0,[r0,#2]
        0x0020aa3e:    9000        ..      STR      r0,[sp,#0]
        0x0020aa40:    7823        #x      LDRB     r3,[r4,#0]
        0x0020aa42:    2202        ."      MOVS     r2,#2
        0x0020aa44:    493c        <I      LDR      r1,[pc,#240] ; [0x20ab38] = 0x880159c
        0x0020aa46:    4839        9H      LDR      r0,[pc,#228] ; [0x20ab2c] = 0x21103002
        0x0020aa48:    f5fdf809    ....    BL       log_buffer ; 0x7a5e
;;;190                        p_rsp->operation, p_rsp->cause);
;;;191        if (p_rsp->cause == GAP_SUCCESS)
        0x0020aa4c:    8860        `.      LDRH     r0,[r4,#2]
        0x0020aa4e:    2800        .(      CMP      r0,#0
        0x0020aa50:    d105        ..      BNE      0x20aa5e ; privacy_handle_le_privacy_modify_resolv_list_rsp + 38
;;;192        {
;;;193            extern bool resolv_list_exist;
;;;194            if (p_rsp->operation == GAP_RESOLV_LIST_OP_ADD)
        0x0020aa52:    7821        !x      LDRB     r1,[r4,#0]
        0x0020aa54:    4839        9H      LDR      r0,[pc,#228] ; [0x20ab3c] = 0x20bc8c
        0x0020aa56:    2901        .)      CMP      r1,#1
        0x0020aa58:    d000        ..      BEQ      0x20aa5c ; privacy_handle_le_privacy_modify_resolv_list_rsp + 36
;;;195            {
;;;196                resolv_list_exist = true;
;;;197            }
;;;198            else
;;;199            {
;;;200                resolv_list_exist = false;
        0x0020aa5a:    2100        .!      MOVS     r1,#0
        0x0020aa5c:    7001        .p      STRB     r1,[r0,#0]
;;;201            }
;;;202        }
;;;203        else
;;;204        {
;;;205        }
;;;206    }
        0x0020aa5e:    bd38        8.      POP      {r3-r5,pc}
    privacy_handle_le_privacy_resolution_status_info
        0x0020aa60:    b510        ..      PUSH     {r4,lr}
        0x0020aa62:    b2c4        ..      UXTB     r4,r0
        0x0020aa64:    4934        4I      LDR      r1,[pc,#208] ; [0x20ab38] = 0x880159c
;;; ..\..\..\src\app\keyboard\privacy_mgnt.c (177)
        0x0020aa66:    4623        #F      MOV      r3,r4
;;;178        APP_PRINT_INFO1("privacy_handle_le_privacy_resolution_status_info: status 0x%x\n",
        0x0020aa68:    2201        ."      MOVS     r2,#1
        0x0020aa6a:    3944        D9      SUBS     r1,r1,#0x44
        0x0020aa6c:    482f        /H      LDR      r0,[pc,#188] ; [0x20ab2c] = 0x21103002
        0x0020aa6e:    f5fcfff6    ....    BL       log_buffer ; 0x7a5e
;;;179                        resolv_status.status);
;;;180        app_privacy_resolution_state = resolv_status.status;
        0x0020aa72:    482f        /H      LDR      r0,[pc,#188] ; [0x20ab30] = 0x20bce0
        0x0020aa74:    7044        Dp      STRB     r4,[r0,#1]
;;;181    }
        0x0020aa76:    bd10        ..      POP      {r4,pc}
    privacy_msg_callback
;;;182    
;;;183    /**
;;;184    * @brief   modify resolving list response
;;;185    * @return  void
;;;186    */
;;;187    void privacy_handle_le_privacy_modify_resolv_list_rsp(T_LE_PRIVACY_MODIFY_RESOLV_LIST_RSP *p_rsp)
;;;188    {
;;;189        APP_PRINT_INFO2("privacy_handle_le_privacy_modify_resolv_list_rsp: operation  0x%x, casue 0x%x",
;;;190                        p_rsp->operation, p_rsp->cause);
;;;191        if (p_rsp->cause == GAP_SUCCESS)
;;;192        {
;;;193            extern bool resolv_list_exist;
;;;194            if (p_rsp->operation == GAP_RESOLV_LIST_OP_ADD)
;;;195            {
;;;196                resolv_list_exist = true;
;;;197            }
;;;198            else
;;;199            {
;;;200                resolv_list_exist = false;
;;;201            }
;;;202        }
;;;203        else
;;;204        {
;;;205        }
;;;206    }
;;;207    
;;;208    
;;;209    /**
;;;210    * @brief   privacy message callback
;;;211    * @return  void
;;;212    */
;;;213    T_APP_RESULT privacy_msg_callback(uint8_t msg_type, T_LE_PRIVACY_CB_DATA msg_data)
;;;214    {
        0x0020aa78:    b570        p.      PUSH     {r4-r6,lr}
        0x0020aa7a:    460d        .F      MOV      r5,r1
        0x0020aa7c:    492e        .I      LDR      r1,[pc,#184] ; [0x20ab38] = 0x880159c
;;; ..\..\..\src\app\keyboard\privacy_mgnt.c (214)
        0x0020aa7e:    4604        .F      MOV      r4,r0
        0x0020aa80:    4603        .F      MOV      r3,r0
;;;215        T_APP_RESULT result = APP_RESULT_SUCCESS;
        0x0020aa82:    2600        .&      MOVS     r6,#0
;;;216        APP_PRINT_INFO1("privacy_msg_callback: msg_type  %d", msg_type);
        0x0020aa84:    2201        ."      MOVS     r2,#1
        0x0020aa86:    3154        T1      ADDS     r1,r1,#0x54
        0x0020aa88:    4828        (H      LDR      r0,[pc,#160] ; [0x20ab2c] = 0x21103002
        0x0020aa8a:    f5fcffe8    ....    BL       log_buffer ; 0x7a5e
        0x0020aa8e:    4628        (F      MOV      r0,r5
;;;217    
;;;218        switch (msg_type)
        0x0020aa90:    b114        ..      CBZ      r4,0x20aa98 ; privacy_msg_callback + 32
        0x0020aa92:    2c02        .,      CMP      r4,#2
        0x0020aa94:    d105        ..      BNE      0x20aaa2 ; privacy_msg_callback + 42
        0x0020aa96:    e002        ..      B        0x20aa9e ; privacy_msg_callback + 38
;;;219        {
;;;220        case GAP_MSG_LE_PRIVACY_RESOLUTION_STATUS_INFO:
;;;221            privacy_handle_le_privacy_resolution_status_info(msg_data.le_privacy_resolution_status_info);
        0x0020aa98:    f7ffffe2    ....    BL       privacy_handle_le_privacy_resolution_status_info ; 0x20aa60
;;;222            break;
        0x0020aa9c:    e001        ..      B        0x20aaa2 ; privacy_msg_callback + 42
;;;223    
;;;224        case GAP_MSG_LE_PRIVACY_MODIFY_RESOLV_LIST:
;;;225            privacy_handle_le_privacy_modify_resolv_list_rsp(msg_data.p_le_privacy_modify_resolv_list_rsp);
        0x0020aa9e:    f7ffffcb    ....    BL       privacy_handle_le_privacy_modify_resolv_list_rsp ; 0x20aa38
;;;226            break;
;;;227    
;;;228        default:
;;;229            break;
;;;230        }
;;;231        return result;
        0x0020aaa2:    4630        0F      MOV      r0,r6
;;;232    }
        0x0020aaa4:    bd70        p.      POP      {r4-r6,pc}
    privacy_init
        0x0020aaa6:    b510        ..      PUSH     {r4,lr}
        0x0020aaa8:    4923        #I      LDR      r1,[pc,#140] ; [0x20ab38] = 0x880159c
;;; ..\..\..\src\app\keyboard\privacy_mgnt.c (154)
        0x0020aaaa:    4604        .F      MOV      r4,r0
;;;155        T_LE_KEY_ENTRY *p_entry;
;;;156    
;;;157        APP_PRINT_INFO1("privacy_init: whitelist %d", whitelist);
        0x0020aaac:    4603        .F      MOV      r3,r0
        0x0020aaae:    2201        ."      MOVS     r2,#1
        0x0020aab0:    3964        d9      SUBS     r1,r1,#0x64
        0x0020aab2:    481e        .H      LDR      r0,[pc,#120] ; [0x20ab2c] = 0x21103002
        0x0020aab4:    f5fcffd3    ....    BL       log_buffer ; 0x7a5e
;;;158    
;;;159        privacy_whitelist = whitelist;
        0x0020aab8:    481d        .H      LDR      r0,[pc,#116] ; [0x20ab30] = 0x20bce0
        0x0020aaba:    7004        .p      STRB     r4,[r0,#0]
;;;160        le_privacy_register_cb(privacy_msg_callback);
        0x0020aabc:    f2af0047    ..G.    ADR      r0,{pc}-0x43 ; 0x20aa79
        0x0020aac0:    f647f896    G...    BL       le_privacy_register_cb ; 0x51bf0
;;;161    
;;;162        p_entry = le_get_high_priority_bond();
        0x0020aac4:    f645fc3c    E.<.    BL       le_get_high_priority_bond ; 0x50340
;;;163        if ((p_entry != NULL) && (p_entry->is_used))
        0x0020aac8:    2800        .(      CMP      r0,#0
        0x0020aaca:    d005        ..      BEQ      0x20aad8 ; privacy_init + 50
        0x0020aacc:    7801        .x      LDRB     r1,[r0,#0]
        0x0020aace:    2900        .)      CMP      r1,#0
        0x0020aad0:    d002        ..      BEQ      0x20aad8 ; privacy_init + 50
;;;164        {
;;;165            privacy_add_device(p_entry);
        0x0020aad2:    e8bd4010    ...@    POP      {r4,lr}
        0x0020aad6:    e767        g.      B        privacy_add_device ; 0x20a9a8
;;;166        }
;;;167        return;
;;;168    }
        0x0020aad8:    bd10        ..      POP      {r4,pc}
    privacy_handle_bond_modify_msg
;;;169    
;;;170    
;;;171    /**
;;;172    * @brief   handle privacy resolution status
;;;173    * @return  void
;;;174    */
;;;175    void privacy_handle_le_privacy_resolution_status_info(T_LE_PRIVACY_RESOLUTION_STATUS_INFO
;;;176                                                          resolv_status)
;;;177    {
;;;178        APP_PRINT_INFO1("privacy_handle_le_privacy_resolution_status_info: status 0x%x\n",
;;;179                        resolv_status.status);
;;;180        app_privacy_resolution_state = resolv_status.status;
;;;181    }
;;;182    
;;;183    /**
;;;184    * @brief   modify resolving list response
;;;185    * @return  void
;;;186    */
;;;187    void privacy_handle_le_privacy_modify_resolv_list_rsp(T_LE_PRIVACY_MODIFY_RESOLV_LIST_RSP *p_rsp)
;;;188    {
;;;189        APP_PRINT_INFO2("privacy_handle_le_privacy_modify_resolv_list_rsp: operation  0x%x, casue 0x%x",
;;;190                        p_rsp->operation, p_rsp->cause);
;;;191        if (p_rsp->cause == GAP_SUCCESS)
;;;192        {
;;;193            extern bool resolv_list_exist;
;;;194            if (p_rsp->operation == GAP_RESOLV_LIST_OP_ADD)
;;;195            {
;;;196                resolv_list_exist = true;
;;;197            }
;;;198            else
;;;199            {
;;;200                resolv_list_exist = false;
;;;201            }
;;;202        }
;;;203        else
;;;204        {
;;;205        }
;;;206    }
;;;207    
;;;208    
;;;209    /**
;;;210    * @brief   privacy message callback
;;;211    * @return  void
;;;212    */
;;;213    T_APP_RESULT privacy_msg_callback(uint8_t msg_type, T_LE_PRIVACY_CB_DATA msg_data)
;;;214    {
;;;215        T_APP_RESULT result = APP_RESULT_SUCCESS;
;;;216        APP_PRINT_INFO1("privacy_msg_callback: msg_type  %d", msg_type);
;;;217    
;;;218        switch (msg_type)
;;;219        {
;;;220        case GAP_MSG_LE_PRIVACY_RESOLUTION_STATUS_INFO:
;;;221            privacy_handle_le_privacy_resolution_status_info(msg_data.le_privacy_resolution_status_info);
;;;222            break;
;;;223    
;;;224        case GAP_MSG_LE_PRIVACY_MODIFY_RESOLV_LIST:
;;;225            privacy_handle_le_privacy_modify_resolv_list_rsp(msg_data.p_le_privacy_modify_resolv_list_rsp);
;;;226            break;
;;;227    
;;;228        default:
;;;229            break;
;;;230        }
;;;231        return result;
;;;232    }
;;;233    
;;;234    /**
;;;235    * @brief   privacy handle bond modify message, used in app_gap_callback
;;;236    * @return  void
;;;237    */
;;;238    void privacy_handle_bond_modify_msg(T_LE_BOND_MODIFY_TYPE type, T_LE_KEY_ENTRY *p_entry)
;;;239    {
        0x0020aada:    b570        p.      PUSH     {r4-r6,lr}
        0x0020aadc:    460c        .F      MOV      r4,r1
        0x0020aade:    4916        .I      LDR      r1,[pc,#88] ; [0x20ab38] = 0x880159c
        0x0020aae0:    4605        .F      MOV      r5,r0
;;;240        APP_PRINT_INFO1("privacy_handle_bond_modify_msg: type 0x%x", type);
        0x0020aae2:    4603        .F      MOV      r3,r0
        0x0020aae4:    2201        ."      MOVS     r2,#1
        0x0020aae6:    317c        |1      ADDS     r1,r1,#0x7c
        0x0020aae8:    4810        .H      LDR      r0,[pc,#64] ; [0x20ab2c] = 0x21103002
        0x0020aaea:    f5fcffb8    ....    BL       log_buffer ; 0x7a5e
;;;241    
;;;242        if (type == LE_BOND_CLEAR)
        0x0020aaee:    2d02        .-      CMP      r5,#2
        0x0020aaf0:    d009        ..      BEQ      0x20ab06 ; privacy_handle_bond_modify_msg + 44
;;;243        {
;;;244            privacy_modify_resolving_list(GAP_RESOLV_LIST_OP_CLEAR, GAP_IDENT_ADDR_PUBLIC, NULL, false);
;;;245        }
;;;246        else if (type == LE_BOND_DELETE)
        0x0020aaf2:    2d00        .-      CMP      r5,#0
        0x0020aaf4:    d114        ..      BNE      0x20ab20 ; privacy_handle_bond_modify_msg + 70
;;;247        {
;;;248            if (p_entry->flags & LE_KEY_STORE_REMOTE_IRK_BIT)
        0x0020aaf6:    78a0        .x      LDRB     r0,[r4,#2]
        0x0020aaf8:    0700        ..      LSLS     r0,r0,#28
        0x0020aafa:    d509        ..      BPL      0x20ab10 ; privacy_handle_bond_modify_msg + 54
;;;249            {
;;;250                privacy_modify_resolving_list(GAP_RESOLV_LIST_OP_REMOVE,
        0x0020aafc:    7da1        .}      LDRB     r1,[r4,#0x16]
        0x0020aafe:    2300        .#      MOVS     r3,#0
        0x0020ab00:    f1040210    ....    ADD      r2,r4,#0x10
        0x0020ab04:    e008        ..      B        0x20ab18 ; privacy_handle_bond_modify_msg + 62
        0x0020ab06:    2300        .#      MOVS     r3,#0
        0x0020ab08:    461a        .F      MOV      r2,r3
        0x0020ab0a:    4619        .F      MOV      r1,r3
        0x0020ab0c:    4618        .F      MOV      r0,r3
        0x0020ab0e:    e004        ..      B        0x20ab1a ; privacy_handle_bond_modify_msg + 64
;;;251                                              (T_GAP_IDENT_ADDR_TYPE)p_entry->resolved_remote_bd.remote_bd_type,
;;;252                                              p_entry->resolved_remote_bd.addr, false);
;;;253            }
;;;254            else
;;;255            {
;;;256                privacy_modify_resolving_list(GAP_RESOLV_LIST_OP_REMOVE,
        0x0020ab10:    7ba1        .{      LDRB     r1,[r4,#0xe]
        0x0020ab12:    2300        .#      MOVS     r3,#0
        0x0020ab14:    f1040208    ....    ADD      r2,r4,#8
        0x0020ab18:    2002        .       MOVS     r0,#2
        0x0020ab1a:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0020ab1e:    e6b5        ..      B        privacy_modify_resolving_list ; 0x20a88c
;;;257                                              (T_GAP_IDENT_ADDR_TYPE)p_entry->remote_bd.remote_bd_type,
;;;258                                              p_entry->remote_bd.addr, false);
;;;259            }
;;;260        }
;;;261    }
        0x0020ab20:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x0020ab22:    0000        ..      DCW    0
        0x0020ab24:    21300000    ..0!    DCD    556793856
        0x0020ab28:    08801370    p...    DCD    142611312
        0x0020ab2c:    21103002    .0.!    DCD    554708994
        0x0020ab30:    0020bce0    .. .    DCD    2145504
        0x0020ab34:    08801478    x...    DCD    142611576
        0x0020ab38:    0880159c    ....    DCD    142611868
        0x0020ab3c:    0020bc8c    .. .    DCD    2145420
    $t
    .text
    load_overlay
;;; .\..\..\..\src\mcu\rtl876x\overlay_mgr.c
;;;116    {
        0x0020ab40:    b510        ..      PUSH     {r4,lr}
        0x0020ab42:    2803        .(      CMP      r0,#3
;;; .\..\..\..\src\mcu\rtl876x\overlay_mgr.c (116)
        0x0020ab44:    d301        ..      BCC      0x20ab4a ; load_overlay + 10
;;;117        const T_OVERLAY_SECTION *selected_scenario;
;;;118    
;;;119        if (scenario_idx >= OVERLAY_SCENARIO_NUM)
;;;120        {
;;;121            return false;
        0x0020ab46:    2000        .       MOVS     r0,#0
        0x0020ab48:    bd10        ..      POP      {r4,pc}
;;;122        }
;;;123    
;;;124        selected_scenario = &overlay_sections[scenario_idx];
        0x0020ab4a:    491a        .I      LDR      r1,[pc,#104] ; [0x20abb4] = 0x20ba68
        0x0020ab4c:    eb0000c0    ....    ADD      r0,r0,r0,LSL #3
        0x0020ab50:    eb010480    ....    ADD      r4,r1,r0,LSL #2
;;;125    
;;;126        if (memcmp(selected_scenario->signature, scenario_name, 8) == 0)
        0x0020ab54:    2208        ."      MOVS     r2,#8
        0x0020ab56:    4918        .I      LDR      r1,[pc,#96] ; [0x20abb8] = 0x20bce2
        0x0020ab58:    6820         h      LDR      r0,[r4,#0]
        0x0020ab5a:    f64ff953    O.S.    BL       memcmp ; 0x59e04
        0x0020ab5e:    b198        ..      CBZ      r0,0x20ab88 ; load_overlay + 72
;;;127        {
;;;128            return true;
;;;129        }
;;;130    
;;;131        /* load code */
;;;132        memcpy(selected_scenario->image_ro_base, selected_scenario->load_ro_base,
        0x0020ab60:    69a2        .i      LDR      r2,[r4,#0x18]
        0x0020ab62:    6861        ah      LDR      r1,[r4,#4]
        0x0020ab64:    68e0        .h      LDR      r0,[r4,#0xc]
        0x0020ab66:    f64ff998    O...    BL       __aeabi_memcpy ; 0x59e9a
;;;133               selected_scenario->ro_length);
;;;134        /* load rw data */
;;;135        memcpy(selected_scenario->image_rw_base, selected_scenario->load_rw_base,
        0x0020ab6a:    69e2        .i      LDR      r2,[r4,#0x1c]
        0x0020ab6c:    68a1        .h      LDR      r1,[r4,#8]
        0x0020ab6e:    6920         i      LDR      r0,[r4,#0x10]
        0x0020ab70:    f64ff993    O...    BL       __aeabi_memcpy ; 0x59e9a
;;;136               selected_scenario->rw_length);
;;;137        /* clear zi data */
;;;138        memset(selected_scenario->image_zi_base, 0x0, selected_scenario->zi_length);
        0x0020ab74:    6a21        !j      LDR      r1,[r4,#0x20]
        0x0020ab76:    6960        `i      LDR      r0,[r4,#0x14]
        0x0020ab78:    f64ffa50    O.P.    BL       __aeabi_memclr ; 0x5a01c
;;;139    
;;;140        memcpy(scenario_name, selected_scenario->signature, 8);
        0x0020ab7c:    6820         h      LDR      r0,[r4,#0]
        0x0020ab7e:    490e        .I      LDR      r1,[pc,#56] ; [0x20abb8] = 0x20bce2
        0x0020ab80:    6802        .h      LDR      r2,[r0,#0]
        0x0020ab82:    600a        .`      STR      r2,[r1,#0]
        0x0020ab84:    6840        @h      LDR      r0,[r0,#4]
        0x0020ab86:    6048        H`      STR      r0,[r1,#4]
        0x0020ab88:    2001        .       MOVS     r0,#1
;;;141    
;;;142        return true;
;;;143    }
        0x0020ab8a:    bd10        ..      POP      {r4,pc}
    get_current_scenario_index
;;;144    
;;;145    T_OVERLAY_SCENARIO_IDX get_current_scenario_index(void)
;;;146    {
        0x0020ab8c:    b570        p.      PUSH     {r4-r6,lr}
        0x0020ab8e:    4d09        .M      LDR      r5,[pc,#36] ; [0x20abb4] = 0x20ba68
;;;147        const T_OVERLAY_SECTION *selected_scenario;
;;;148    
;;;149        for (int i = 0; i < (int)OVERLAY_SCENARIO_NUM; ++i)
        0x0020ab90:    2400        .$      MOVS     r4,#0
        0x0020ab92:    eb0400c4    ....    ADD      r0,r4,r4,LSL #3
        0x0020ab96:    2208        ."      MOVS     r2,#8
        0x0020ab98:    f8550020    U. .    LDR      r0,[r5,r0,LSL #2]
        0x0020ab9c:    4906        .I      LDR      r1,[pc,#24] ; [0x20abb8] = 0x20bce2
        0x0020ab9e:    f64ff931    O.1.    BL       memcmp ; 0x59e04
        0x0020aba2:    b120         .      CBZ      r0,0x20abae ; get_current_scenario_index + 34
        0x0020aba4:    1c64        d.      ADDS     r4,r4,#1
        0x0020aba6:    2c03        .,      CMP      r4,#3
        0x0020aba8:    dbf3        ..      BLT      0x20ab92 ; get_current_scenario_index + 6
        0x0020abaa:    2003        .       MOVS     r0,#3
        0x0020abac:    bd70        p.      POP      {r4-r6,pc}
;;;150        {
;;;151            selected_scenario = &overlay_sections[i];
;;;152            if (memcmp(selected_scenario->signature, scenario_name, 8) == 0)
;;;153            {
;;;154                return (T_OVERLAY_SCENARIO_IDX)i;
        0x0020abae:    b2e0        ..      UXTB     r0,r4
;;;155            }
;;;156        }
;;;157    
;;;158        return OVERLAY_SCENARIO_NUM; //not found valid scenario
;;;159    }
        0x0020abb0:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x0020abb2:    0000        ..      DCW    0
        0x0020abb4:    0020ba68    h. .    DCD    2144872
        0x0020abb8:    0020bce2    .. .    DCD    2145506
    $t
    .text
    gap_lib_handle_btif_msg
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (31)
        0x0020abbc:    b510        ..      PUSH     {r4,lr}
        0x0020abbe:    2201        ."      MOVS     r2,#1
        0x0020abc0:    700a        .p      STRB     r2,[r1,#0]
        0x0020abc2:    8841        A.      LDRH     r1,[r0,#2]
        0x0020abc4:    2400        .$      MOVS     r4,#0
        0x0020abc6:    290e        .)      CMP      r1,#0xe
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (31)
        0x0020abc8:    d102        ..      BNE      0x20abd0 ; gap_lib_handle_btif_msg + 20
        0x0020abca:    1d00        ..      ADDS     r0,r0,#4
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (39)
        0x0020abcc:    f000f8c1    ....    BL       le_handle_vendor_cmd_rsp ; 0x20ad52
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (112)
        0x0020abd0:    4620         F      MOV      r0,r4
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (113)
        0x0020abd2:    bd10        ..      POP      {r4,pc}
    gap_lib_init
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (116)
        0x0020abd4:    b570        p.      PUSH     {r4-r6,lr}
        0x0020abd6:    b088        ..      SUB      sp,sp,#0x20
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (117)
        0x0020abd8:    2400        .$      MOVS     r4,#0
        0x0020abda:    9405        ..      STR      r4,[sp,#0x14]
        0x0020abdc:    2501        .%      MOVS     r5,#1
        0x0020abde:    9406        ..      STR      r4,[sp,#0x18]
        0x0020abe0:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0020abe4:    4e0e        .N      LDR      r6,[pc,#56] ; [0x20ac20] = 0x21103500
        0x0020abe6:    2308        .#      MOVS     r3,#8
        0x0020abe8:    9403        ..      STR      r4,[sp,#0xc]
        0x0020abea:    9404        ..      STR      r4,[sp,#0x10]
        0x0020abec:    461a        .F      MOV      r2,r3
        0x0020abee:    490b        .I      LDR      r1,[pc,#44] ; [0x20ac1c] = 0x8801648
        0x0020abf0:    4630        0F      MOV      r0,r6
        0x0020abf2:    9402        ..      STR      r4,[sp,#8]
        0x0020abf4:    f5fcff33    ..3.    BL       log_buffer ; 0x7a5e
        0x0020abf8:    4908        .I      LDR      r1,[pc,#32] ; [0x20ac1c] = 0x8801648
        0x0020abfa:    e9cd4500    ...E    STRD     r4,r5,[sp,#0]
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (121)
        0x0020abfe:    2300        .#      MOVS     r3,#0
        0x0020ac00:    2204        ."      MOVS     r2,#4
        0x0020ac02:    31ec        .1      ADDS     r1,r1,#0xec
        0x0020ac04:    4630        0F      MOV      r0,r6
        0x0020ac06:    9502        ..      STR      r5,[sp,#8]
        0x0020ac08:    f5fcff29    ..).    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (123)
        0x0020ac0c:    f2af0053    ..S.    ADR      r0,{pc}-0x4f ; 0x20abbd
        0x0020ac10:    b008        ..      ADD      sp,sp,#0x20
        0x0020ac12:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0020ac16:    f641b8fb    A...    B        gap_register_extend_cb ; 0x4be10
    $d
        0x0020ac1a:    0000        ..      DCW    0
        0x0020ac1c:    08801648    H...    DCD    142612040
        0x0020ac20:    21103500    .5.!    DCD    554710272
    $t
    .text
    le_check_privacy_bond
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (163)
        0x0020ac24:    b530        0.      PUSH     {r4,r5,lr}
        0x0020ac26:    b08b        ..      SUB      sp,sp,#0x2c
        0x0020ac28:    f04f0100    O...    MOV      r1,#0
        0x0020ac2c:    4d33        3M      LDR      r5,[pc,#204] ; [0x20acfc] = 0x21103502
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (163)
        0x0020ac2e:    0004        ..      MOVS     r4,r0
        0x0020ac30:    9106        ..      STR      r1,[sp,#0x18]
        0x0020ac32:    9107        ..      STR      r1,[sp,#0x1c]
        0x0020ac34:    9108        ..      STR      r1,[sp,#0x20]
        0x0020ac36:    9109        ..      STR      r1,[sp,#0x24]
        0x0020ac38:    d002        ..      BEQ      0x20ac40 ; le_check_privacy_bond + 28
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (166)
        0x0020ac3a:    7820         x      LDRB     r0,[r4,#0]
        0x0020ac3c:    2801        .(      CMP      r0,#1
        0x0020ac3e:    d008        ..      BEQ      0x20ac52 ; le_check_privacy_bond + 46
        0x0020ac40:    2301        .#      MOVS     r3,#1
        0x0020ac42:    2201        ."      MOVS     r2,#1
        0x0020ac44:    492e        .I      LDR      r1,[pc,#184] ; [0x20ad00] = 0x88017e0
        0x0020ac46:    4628        (F      MOV      r0,r5
        0x0020ac48:    f5fcff09    ....    BL       log_buffer ; 0x7a5e
        0x0020ac4c:    2000        .       MOVS     r0,#0
        0x0020ac4e:    b00b        ..      ADD      sp,sp,#0x2c
        0x0020ac50:    bd30        0.      POP      {r4,r5,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (168)
        0x0020ac52:    78a0        .x      LDRB     r0,[r4,#2]
        0x0020ac54:    0700        ..      LSLS     r0,r0,#28
        0x0020ac56:    d518        ..      BPL      0x20ac8a ; le_check_privacy_bond + 102
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (171)
        0x0020ac58:    466a        jF      MOV      r2,sp
        0x0020ac5a:    2114        .!      MOVS     r1,#0x14
        0x0020ac5c:    4620         F      MOV      r0,r4
        0x0020ac5e:    f645fb81    E...    BL       le_get_key ; 0x50364
        0x0020ac62:    b180        ..      CBZ      r0,0x20ac86 ; le_check_privacy_bond + 98
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (173)
        0x0020ac64:    2210        ."      MOVS     r2,#0x10
        0x0020ac66:    a906        ..      ADD      r1,sp,#0x18
        0x0020ac68:    4668        hF      MOV      r0,sp
        0x0020ac6a:    f64ff8cb    O...    BL       memcmp ; 0x59e04
        0x0020ac6e:    b140        @.      CBZ      r0,0x20ac82 ; le_check_privacy_bond + 94
        0x0020ac70:    4923        #I      LDR      r1,[pc,#140] ; [0x20ad00] = 0x88017e0
        0x0020ac72:    7863        cx      LDRB     r3,[r4,#1]
        0x0020ac74:    2201        ."      MOVS     r2,#1
        0x0020ac76:    3930        09      SUBS     r1,r1,#0x30
        0x0020ac78:    4628        (F      MOV      r0,r5
        0x0020ac7a:    f5fcfef0    ....    BL       log_buffer ; 0x7a5e
        0x0020ac7e:    2001        .       MOVS     r0,#1
        0x0020ac80:    e7e5        ..      B        0x20ac4e ; le_check_privacy_bond + 42
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (175)
        0x0020ac82:    2305        .#      MOVS     r3,#5
        0x0020ac84:    e7dd        ..      B        0x20ac42 ; le_check_privacy_bond + 30
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (185)
        0x0020ac86:    2304        .#      MOVS     r3,#4
        0x0020ac88:    e7db        ..      B        0x20ac42 ; le_check_privacy_bond + 30
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (190)
        0x0020ac8a:    2302        .#      MOVS     r3,#2
        0x0020ac8c:    e7d9        ..      B        0x20ac42 ; le_check_privacy_bond + 30
    le_bond_just_work_confirm
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (202)
        0x0020ac8e:    460a        .F      MOV      r2,r1
        0x0020ac90:    eb000140    ..@.    ADD      r1,r0,r0,LSL #1
        0x0020ac94:    481b        .H      LDR      r0,[pc,#108] ; [0x20ad04] = 0x202e64
        0x0020ac96:    b510        ..      PUSH     {r4,lr}
        0x0020ac98:    6800        .h      LDR      r0,[r0,#0]
        0x0020ac9a:    eb001001    ....    ADD      r0,r0,r1,LSL #4
        0x0020ac9e:    7801        .x      LDRB     r1,[r0,#0]
        0x0020aca0:    b129        ).      CBZ      r1,0x20acae ; le_bond_just_work_confirm + 32
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (205)
        0x0020aca2:    7981        .y      LDRB     r1,[r0,#6]
        0x0020aca4:    1dc0        ..      ADDS     r0,r0,#7
        0x0020aca6:    f616fcd8    ....    BL       btif_just_work_req_cfm ; 0x2165a
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (207)
        0x0020acaa:    2000        .       MOVS     r0,#0
        0x0020acac:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (211)
        0x0020acae:    2004        .       MOVS     r0,#4
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (213)
        0x0020acb0:    bd10        ..      POP      {r4,pc}
    le_bond_get_sec_level
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (226)
        0x0020acb2:    b510        ..      PUSH     {r4,lr}
        0x0020acb4:    b08a        ..      SUB      sp,sp,#0x28
        0x0020acb6:    460c        .F      MOV      r4,r1
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (229)
        0x0020acb8:    2100        .!      MOVS     r1,#0
        0x0020acba:    7021        !p      STRB     r1,[r4,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (230)
        0x0020acbc:    aa09        ..      ADD      r2,sp,#0x24
        0x0020acbe:    a907        ..      ADD      r1,sp,#0x1c
        0x0020acc0:    f642ff95    B...    BL       le_get_conn_addr ; 0x4dbee
        0x0020acc4:    b1c0        ..      CBZ      r0,0x20acf8 ; le_bond_get_sec_level + 70
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (233)
        0x0020acc6:    f89d1024    ..$.    LDRB     r1,[sp,#0x24]
        0x0020acca:    a807        ..      ADD      r0,sp,#0x1c
        0x0020accc:    f645fa5f    E._.    BL       le_find_key_entry ; 0x5018e
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (234)
        0x0020acd0:    b190        ..      CBZ      r0,0x20acf8 ; le_bond_get_sec_level + 70
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (237)
        0x0020acd2:    466a        jF      MOV      r2,sp
        0x0020acd4:    2111        .!      MOVS     r1,#0x11
        0x0020acd6:    f645fb45    E.E.    BL       le_get_key ; 0x50364
        0x0020acda:    b168        h.      CBZ      r0,0x20acf8 ; le_bond_get_sec_level + 70
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (239)
        0x0020acdc:    4908        .I      LDR      r1,[pc,#32] ; [0x20ad00] = 0x88017e0
        0x0020acde:    f89d301b    ...0    LDRB     r3,[sp,#0x1b]
        0x0020ace2:    2201        ."      MOVS     r2,#1
        0x0020ace4:    3138        81      ADDS     r1,r1,#0x38
        0x0020ace6:    4805        .H      LDR      r0,[pc,#20] ; [0x20acfc] = 0x21103502
        0x0020ace8:    f5fcfeb9    ....    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (240)
        0x0020acec:    f89d001b    ....    LDRB     r0,[sp,#0x1b]
        0x0020acf0:    7020         p      STRB     r0,[r4,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (241)
        0x0020acf2:    2000        .       MOVS     r0,#0
        0x0020acf4:    b00a        ..      ADD      sp,sp,#0x28
        0x0020acf6:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (245)
        0x0020acf8:    2003        .       MOVS     r0,#3
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (246)
        0x0020acfa:    e7fb        ..      B        0x20acf4 ; le_bond_get_sec_level + 66
    $d
        0x0020acfc:    21103502    .5.!    DCD    554710274
        0x0020ad00:    088017e0    ....    DCD    142612448
        0x0020ad04:    00202e64    d. .    DCD    2109028
    $t
    .text
    gap_set_lps_bootup_active_time
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (43)
        0x0020ad08:    b508        ..      PUSH     {r3,lr}
        0x0020ad0a:    1ec1        ..      SUBS     r1,r0,#3
        0x0020ad0c:    f24072fe    @..r    MOV      r2,#0x7fe
        0x0020ad10:    4291        .B      CMP      r1,r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (43)
        0x0020ad12:    d301        ..      BCC      0x20ad18 ; gap_set_lps_bootup_active_time + 16
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (48)
        0x0020ad14:    2000        .       MOVS     r0,#0
        0x0020ad16:    bd08        ..      POP      {r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (50)
        0x0020ad18:    2105        .!      MOVS     r1,#5
        0x0020ad1a:    f88d1000    ....    STRB     r1,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (51)
        0x0020ad1e:    f88d0001    ....    STRB     r0,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (52)
        0x0020ad22:    0a00        ..      LSRS     r0,r0,#8
        0x0020ad24:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (54)
        0x0020ad28:    466a        jF      MOV      r2,sp
        0x0020ad2a:    2103        .!      MOVS     r1,#3
        0x0020ad2c:    f64f406e    O.n@    MOV      r0,#0xfc6e
        0x0020ad30:    f616fbdc    ....    BL       btif_vendor_cmd_req ; 0x214ec
        0x0020ad34:    2800        .(      CMP      r0,#0
        0x0020ad36:    d0ee        ..      BEQ      0x20ad16 ; gap_set_lps_bootup_active_time + 14
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (56)
        0x0020ad38:    2001        .       MOVS     r0,#1
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (59)
        0x0020ad3a:    bd08        ..      POP      {r3,pc}
    lps_get_wakeup_time
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (62)
        0x0020ad3c:    b530        0.      PUSH     {r4,r5,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (63)
        0x0020ad3e:    4b20         K      LDR      r3,[pc,#128] ; [0x20adc0] = 0x201b1c
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (64)
        0x0020ad40:    681d        .h      LDR      r5,[r3,#0]
        0x0020ad42:    1d1b        ..      ADDS     r3,r3,#4
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (65)
        0x0020ad44:    681c        .h      LDR      r4,[r3,#0]
        0x0020ad46:    1d1b        ..      ADDS     r3,r3,#4
        0x0020ad48:    681b        .h      LDR      r3,[r3,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (67)
        0x0020ad4a:    6005        .`      STR      r5,[r0,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (68)
        0x0020ad4c:    600c        .`      STR      r4,[r1,#0]
        0x0020ad4e:    6013        .`      STR      r3,[r2,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (69)
        0x0020ad50:    bd30        0.      POP      {r4,r5,pc}
    le_handle_vendor_cmd_rsp
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (169)
        0x0020ad52:    b508        ..      PUSH     {r3,lr}
        0x0020ad54:    8801        ..      LDRH     r1,[r0,#0]
        0x0020ad56:    f5a1427c    ..|B    SUB      r2,r1,#0xfc00
        0x0020ad5a:    3a6e        n:      SUBS     r2,r2,#0x6e
        0x0020ad5c:    d109        ..      BNE      0x20ad72 ; le_handle_vendor_cmd_rsp + 32
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (250)
        0x0020ad5e:    8840        @.      LDRH     r0,[r0,#2]
        0x0020ad60:    f8ad0000    ....    STRH     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (251)
        0x0020ad64:    4817        .H      LDR      r0,[pc,#92] ; [0x20adc4] = 0x202e48
        0x0020ad66:    6802        .h      LDR      r2,[r0,#0]
        0x0020ad68:    2a00        .*      CMP      r2,#0
        0x0020ad6a:    d002        ..      BEQ      0x20ad72 ; le_handle_vendor_cmd_rsp + 32
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (253)
        0x0020ad6c:    4669        iF      MOV      r1,sp
        0x0020ad6e:    20a6        .       MOVS     r0,#0xa6
        0x0020ad70:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (258)
        0x0020ad72:    bd08        ..      POP      {r3,pc}
    le_vendor_modify_bt_le_fw_policy
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (262)
        0x0020ad74:    b50e        ..      PUSH     {r1-r3,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (265)
        0x0020ad76:    2210        ."      MOVS     r2,#0x10
        0x0020ad78:    f88d2000    ...     STRB     r2,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (266)
        0x0020ad7c:    f88d0001    ....    STRB     r0,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (267)
        0x0020ad80:    0a02        ..      LSRS     r2,r0,#8
        0x0020ad82:    f88d2002    ...     STRB     r2,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (268)
        0x0020ad86:    0c02        ..      LSRS     r2,r0,#16
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (269)
        0x0020ad88:    0e00        ..      LSRS     r0,r0,#24
        0x0020ad8a:    f88d0004    ....    STRB     r0,[sp,#4]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (270)
        0x0020ad8e:    f88d1005    ....    STRB     r1,[sp,#5]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (271)
        0x0020ad92:    0a08        ..      LSRS     r0,r1,#8
        0x0020ad94:    f88d0006    ....    STRB     r0,[sp,#6]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (272)
        0x0020ad98:    0c08        ..      LSRS     r0,r1,#16
        0x0020ad9a:    f88d0007    ....    STRB     r0,[sp,#7]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (273)
        0x0020ad9e:    0e08        ..      LSRS     r0,r1,#24
        0x0020ada0:    f88d2003    ...     STRB     r2,[sp,#3]
        0x0020ada4:    f88d0008    ....    STRB     r0,[sp,#8]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (275)
        0x0020ada8:    466a        jF      MOV      r2,sp
        0x0020adaa:    2109        .!      MOVS     r1,#9
        0x0020adac:    f64f5080    O..P    MOV      r0,#0xfd80
        0x0020adb0:    f616fb9c    ....    BL       btif_vendor_cmd_req ; 0x214ec
        0x0020adb4:    b108        ..      CBZ      r0,0x20adba ; le_vendor_modify_bt_le_fw_policy + 70
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (277)
        0x0020adb6:    2000        .       MOVS     r0,#0
        0x0020adb8:    bd0e        ..      POP      {r1-r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (279)
        0x0020adba:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (286)
        0x0020adbc:    bd0e        ..      POP      {r1-r3,pc}
    $d
        0x0020adbe:    0000        ..      DCW    0
        0x0020adc0:    00201b1c    .. .    DCD    2104092
        0x0020adc4:    00202e48    H. .    DCD    2109000
    $t
    x$fpl$fpinit
    $v0
    _fp_init
        0x0020adc8:    f04f7040    O.@p    MOV      r0,#0x3000000
        0x0020adcc:    eee10a10    ....    VMSR     FPSCR,r0
    __fplib_config_fpu_vfp
    __fplib_config_pureend_doubles
        0x0020add0:    4770        pG      BX       lr
        0x0020add2:    0000        ..      MOVS     r0,r0
    $d.realdata
    .constdata
    app_cb_table
        0x0020add4:    0e85d101    ....    DCD    243650817
        0x0020add8:    00000001    ....    DCD    1
        0x0020addc:    00207f3f    ?. .    DCD    2129727
    .constdata
        0x0020ade0:    0020b934    4. .    DCD    2144564
        0x0020ade4:    0020b9e0    .. .    DCD    2144736
        0x0020ade8:    0020b928    (. .    DCD    2144552
        0x0020adec:    0020b9e8    .. .    DCD    2144744
        0x0020adf0:    0020b98c    .. .    DCD    2144652
        0x0020adf4:    0020ba00    .. .    DCD    2144768
        0x0020adf8:    0020b9f4    .. .    DCD    2144756
        0x0020adfc:    0020b97c    |. .    DCD    2144636
        0x0020ae00:    0020b97c    |. .    DCD    2144636
        0x0020ae04:    0020b97c    |. .    DCD    2144636
        0x0020ae08:    0020b97c    |. .    DCD    2144636
        0x0020ae0c:    0020b91c    .. .    DCD    2144540
        0x0020ae10:    0020b9d4    .. .    DCD    2144724
        0x0020ae14:    0020b97c    |. .    DCD    2144636
        0x0020ae18:    0020b944    D. .    DCD    2144580
        0x0020ae1c:    0020b9a4    .. .    DCD    2144676
        0x0020ae20:    0020b9b8    .. .    DCD    2144696
        0x0020ae24:    0020b924    $. .    DCD    2144548
        0x0020ae28:    0020b90c    .. .    DCD    2144524
        0x0020ae2c:    0020b88c    .. .    DCD    2144396
        0x0020ae30:    0020b860    `. .    DCD    2144352
        0x0020ae34:    0020b9c0    .. .    DCD    2144704
        0x0020ae38:    0020b974    t. .    DCD    2144628
        0x0020ae3c:    0020b960    `. .    DCD    2144608
        0x0020ae40:    0020b8f8    .. .    DCD    2144504
        0x0020ae44:    0020b8b8    .. .    DCD    2144440
        0x0020ae48:    0020b8d8    .. .    DCD    2144472
        0x0020ae4c:    0020b83c    <. .    DCD    2144316
        0x0020ae50:    0020b808    .. .    DCD    2144264
        0x0020ae54:    0020b918    .. .    DCD    2144536
        0x0020ae58:    0020b800    .. .    DCD    2144256
        0x0020ae5c:    0020b834    4. .    DCD    2144308
        0x0020ae60:    0020b7f8    .. .    DCD    2144248
        0x0020ae64:    0020b82c    ,. .    DCD    2144300
        0x0020ae68:    0020b914    .. .    DCD    2144532
        0x0020ae6c:    0020b9ac    .. .    DCD    2144684
        0x0020ae70:    0020b810    .. .    DCD    2144272
        0x0020ae74:    0020b844    D. .    DCD    2144324
        0x0020ae78:    0020b870    p. .    DCD    2144368
        0x0020ae7c:    0020b894    .. .    DCD    2144404
        0x0020ae80:    0020b8c0    .. .    DCD    2144448
        0x0020ae84:    0020b8e0    .. .    DCD    2144480
        0x0020ae88:    0020b8a4    .. .    DCD    2144420
        0x0020ae8c:    0020b880    .. .    DCD    2144384
        0x0020ae90:    0020b940    @. .    DCD    2144576
        0x0020ae94:    0020b854    T. .    DCD    2144340
        0x0020ae98:    0020b820     . .    DCD    2144288
        0x0020ae9c:    0020b868    h. .    DCD    2144360
        0x0020aea0:    0020b8b0    .. .    DCD    2144432
        0x0020aea4:    0020b8d0    .. .    DCD    2144464
        0x0020aea8:    0020b8f0    .. .    DCD    2144496
        0x0020aeac:    0020b904    .. .    DCD    2144516
        0x0020aeb0:    0020b998    .. .    DCD    2144664
        0x0020aeb4:    0020b984    .. .    DCD    2144644
        0x0020aeb8:    0020b9cc    .. .    DCD    2144716
        0x0020aebc:    0020b94c    L. .    DCD    2144588
        0x0020aec0:    0020b92c    ,. .    DCD    2144556
        0x0020aec4:    0020ba0c    .. .    DCD    2144780
        0x0020aec8:    0020b968    h. .    DCD    2144616
        0x0020aecc:    0020b954    T. .    DCD    2144596
        0x0020aed0:    0020b920     . .    DCD    2144544
    .constdata
    hids_report_descriptor
        0x0020aed4:    06090105    ....    DCD    101253381
        0x0020aed8:    038501a1    ....    DCD    59048353
        0x0020aedc:    e0190705    ....    DCD    3759736581
        0x0020aee0:    0015e729    )...    DCD    1435433
        0x0020aee4:    01750125    %.u.    DCD    24445221
        0x0020aee8:    02810895    ....    DCD    42010773
        0x0020aeec:    08750195    ..u.    DCD    141885845
        0x0020aef0:    05950181    ....    DCD    93651329
        0x0020aef4:    08050175    u...    DCD    134545781
        0x0020aef8:    05290119    ..).    DCD    86573337
        0x0020aefc:    01950291    ....    DCD    26542737
        0x0020af00:    01910375    u...    DCD    26280821
        0x0020af04:    08750695    ..u.    DCD    141887125
        0x0020af08:    a4250015    ..%.    DCD    2753888277
        0x0020af0c:    00190705    ....    DCD    1640197
        0x0020af10:    0081a429    )...    DCD    8496169
        0x0020af14:    090c05c0    ....    DCD    151782848
        0x0020af18:    8501a101    ....    DCD    2231476481
        0x0020af1c:    25001504    ...%    DCD    620762372
        0x0020af20:    95017501    .u..    DCD    2499900673
        0x0020af24:    09b50918    ....    DCD    162859288
        0x0020af28:    09b709b6    ....    DCD    162990518
        0x0020af2c:    09e209cd    ....    DCD    165808589
        0x0020af30:    09e709e5    ....    DCD    166136293
        0x0020af34:    0aea09e9    ....    DCD    183110121
        0x0020af38:    530a0152    R..S    DCD    1393164626
        0x0020af3c:    01540a01    ..T.    DCD    22284801
        0x0020af40:    0a01550a    .U..    DCD    167859466
        0x0020af44:    8a0a0183    ....    DCD    2315911555
        0x0020af48:    01920a01    ....    DCD    26348033
        0x0020af4c:    0a01940a    ....    DCD    167875594
        0x0020af50:    230a0221    !..#    DCD    587858465
        0x0020af54:    02240a02    ..$.    DCD    35916290
        0x0020af58:    0a02250a    .%..    DCD    167912714
        0x0020af5c:    270a0226    &..'    DCD    654967334
        0x0020af60:    022a0a02    ..*.    DCD    36309506
        0x0020af64:    00c00281    ....    DCD    12583553
    hids_attr_tbl
        0x0020af68:    28000802    ...(    DCD    671090690
        0x0020af6c:    00001812    ....    DCD    6162
        0x0020af70:    00000000    ....    DCD    0
        0x0020af74:    00000000    ....    DCD    0
        0x0020af78:    00020000    ....    DCD    131072
        0x0020af7c:    00000000    ....    DCD    0
        0x0020af80:    00000001    ....    DCD    1
        0x0020af84:    28030002    ...(    DCD    671285250
        0x0020af88:    00000006    ....    DCD    6
        0x0020af8c:    00000000    ....    DCD    0
        0x0020af90:    00000000    ....    DCD    0
        0x0020af94:    00010000    ....    DCD    65536
        0x0020af98:    00000000    ....    DCD    0
        0x0020af9c:    00000001    ....    DCD    1
        0x0020afa0:    2a4e0004    ..N*    DCD    709754884
        0x0020afa4:    00000000    ....    DCD    0
        0x0020afa8:    00000000    ....    DCD    0
        0x0020afac:    00000000    ....    DCD    0
        0x0020afb0:    00000000    ....    DCD    0
        0x0020afb4:    00000000    ....    DCD    0
        0x0020afb8:    00000022    "...    DCD    34
        0x0020afbc:    28030002    ...(    DCD    671285250
        0x0020afc0:    0000001a    ....    DCD    26
        0x0020afc4:    00000000    ....    DCD    0
        0x0020afc8:    00000000    ....    DCD    0
        0x0020afcc:    00010000    ....    DCD    65536
        0x0020afd0:    00000000    ....    DCD    0
        0x0020afd4:    00000001    ....    DCD    1
        0x0020afd8:    2a4d0004    ..M*    DCD    709689348
        0x0020afdc:    00000000    ....    DCD    0
        0x0020afe0:    00000000    ....    DCD    0
        0x0020afe4:    00000000    ....    DCD    0
        0x0020afe8:    00000000    ....    DCD    0
        0x0020afec:    00000000    ....    DCD    0
        0x0020aff0:    00000022    "...    DCD    34
        0x0020aff4:    29020012    ...)    DCD    687996946
        0x0020aff8:    00000000    ....    DCD    0
        0x0020affc:    00000000    ....    DCD    0
        0x0020b000:    00000000    ....    DCD    0
        0x0020b004:    00020000    ....    DCD    131072
        0x0020b008:    00000000    ....    DCD    0
        0x0020b00c:    00000022    "...    DCD    34
        0x0020b010:    29080012    ...)    DCD    688390162
        0x0020b014:    00000103    ....    DCD    259
        0x0020b018:    00000000    ....    DCD    0
        0x0020b01c:    00000000    ....    DCD    0
        0x0020b020:    00020000    ....    DCD    131072
        0x0020b024:    00000000    ....    DCD    0
        0x0020b028:    00000002    ....    DCD    2
        0x0020b02c:    28030002    ...(    DCD    671285250
        0x0020b030:    0000000e    ....    DCD    14
        0x0020b034:    00000000    ....    DCD    0
        0x0020b038:    00000000    ....    DCD    0
        0x0020b03c:    00010000    ....    DCD    65536
        0x0020b040:    00000000    ....    DCD    0
        0x0020b044:    00000001    ....    DCD    1
        0x0020b048:    2a4d0004    ..M*    DCD    709689348
        0x0020b04c:    00000000    ....    DCD    0
        0x0020b050:    00000000    ....    DCD    0
        0x0020b054:    00000000    ....    DCD    0
        0x0020b058:    00000000    ....    DCD    0
        0x0020b05c:    00000000    ....    DCD    0
        0x0020b060:    00000022    "...    DCD    34
        0x0020b064:    29080012    ...)    DCD    688390162
        0x0020b068:    00000203    ....    DCD    515
        0x0020b06c:    00000000    ....    DCD    0
        0x0020b070:    00000000    ....    DCD    0
        0x0020b074:    00020000    ....    DCD    131072
        0x0020b078:    00000000    ....    DCD    0
        0x0020b07c:    00000002    ....    DCD    2
        0x0020b080:    28030002    ...(    DCD    671285250
        0x0020b084:    0000000a    ....    DCD    10
        0x0020b088:    00000000    ....    DCD    0
        0x0020b08c:    00000000    ....    DCD    0
        0x0020b090:    00010000    ....    DCD    65536
        0x0020b094:    00000000    ....    DCD    0
        0x0020b098:    00000001    ....    DCD    1
        0x0020b09c:    2a4d0004    ..M*    DCD    709689348
        0x0020b0a0:    00000000    ....    DCD    0
        0x0020b0a4:    00000000    ....    DCD    0
        0x0020b0a8:    00000000    ....    DCD    0
        0x0020b0ac:    00000000    ....    DCD    0
        0x0020b0b0:    00000000    ....    DCD    0
        0x0020b0b4:    00000022    "...    DCD    34
        0x0020b0b8:    29080012    ...)    DCD    688390162
        0x0020b0bc:    00000303    ....    DCD    771
        0x0020b0c0:    00000000    ....    DCD    0
        0x0020b0c4:    00000000    ....    DCD    0
        0x0020b0c8:    00020000    ....    DCD    131072
        0x0020b0cc:    00000000    ....    DCD    0
        0x0020b0d0:    00000002    ....    DCD    2
        0x0020b0d4:    28030002    ...(    DCD    671285250
        0x0020b0d8:    00000002    ....    DCD    2
        0x0020b0dc:    00000000    ....    DCD    0
        0x0020b0e0:    00000000    ....    DCD    0
        0x0020b0e4:    00010000    ....    DCD    65536
        0x0020b0e8:    00000000    ....    DCD    0
        0x0020b0ec:    00000001    ....    DCD    1
        0x0020b0f0:    2a4b0004    ..K*    DCD    709558276
        0x0020b0f4:    00000000    ....    DCD    0
        0x0020b0f8:    00000000    ....    DCD    0
        0x0020b0fc:    00000000    ....    DCD    0
        0x0020b100:    00000000    ....    DCD    0
        0x0020b104:    00000000    ....    DCD    0
        0x0020b108:    00000002    ....    DCD    2
        0x0020b10c:    29070004    ...)    DCD    688324612
        0x0020b110:    00000000    ....    DCD    0
        0x0020b114:    00000000    ....    DCD    0
        0x0020b118:    00000000    ....    DCD    0
        0x0020b11c:    00000000    ....    DCD    0
        0x0020b120:    00000000    ....    DCD    0
        0x0020b124:    00000002    ....    DCD    2
        0x0020b128:    28030002    ...(    DCD    671285250
        0x0020b12c:    0000001a    ....    DCD    26
        0x0020b130:    00000000    ....    DCD    0
        0x0020b134:    00000000    ....    DCD    0
        0x0020b138:    00010000    ....    DCD    65536
        0x0020b13c:    00000000    ....    DCD    0
        0x0020b140:    00000001    ....    DCD    1
        0x0020b144:    2a220004    .."*    DCD    706871300
        0x0020b148:    00000000    ....    DCD    0
        0x0020b14c:    00000000    ....    DCD    0
        0x0020b150:    00000000    ....    DCD    0
        0x0020b154:    00000000    ....    DCD    0
        0x0020b158:    00000000    ....    DCD    0
        0x0020b15c:    00000022    "...    DCD    34
        0x0020b160:    29020012    ...)    DCD    687996946
        0x0020b164:    00000000    ....    DCD    0
        0x0020b168:    00000000    ....    DCD    0
        0x0020b16c:    00000000    ....    DCD    0
        0x0020b170:    00020000    ....    DCD    131072
        0x0020b174:    00000000    ....    DCD    0
        0x0020b178:    00000022    "...    DCD    34
        0x0020b17c:    28030002    ...(    DCD    671285250
        0x0020b180:    0000000e    ....    DCD    14
        0x0020b184:    00000000    ....    DCD    0
        0x0020b188:    00000000    ....    DCD    0
        0x0020b18c:    00010000    ....    DCD    65536
        0x0020b190:    00000000    ....    DCD    0
        0x0020b194:    00000001    ....    DCD    1
        0x0020b198:    2a320004    ..2*    DCD    707919876
        0x0020b19c:    00000000    ....    DCD    0
        0x0020b1a0:    00000000    ....    DCD    0
        0x0020b1a4:    00000000    ....    DCD    0
        0x0020b1a8:    00000000    ....    DCD    0
        0x0020b1ac:    00000000    ....    DCD    0
        0x0020b1b0:    00000022    "...    DCD    34
        0x0020b1b4:    28030002    ...(    DCD    671285250
        0x0020b1b8:    00000002    ....    DCD    2
        0x0020b1bc:    00000000    ....    DCD    0
        0x0020b1c0:    00000000    ....    DCD    0
        0x0020b1c4:    00010000    ....    DCD    65536
        0x0020b1c8:    00000000    ....    DCD    0
        0x0020b1cc:    00000001    ....    DCD    1
        0x0020b1d0:    2a4a0004    ..J*    DCD    709492740
        0x0020b1d4:    00000000    ....    DCD    0
        0x0020b1d8:    00000000    ....    DCD    0
        0x0020b1dc:    00000000    ....    DCD    0
        0x0020b1e0:    00000000    ....    DCD    0
        0x0020b1e4:    00000000    ....    DCD    0
        0x0020b1e8:    00000002    ....    DCD    2
        0x0020b1ec:    28030002    ...(    DCD    671285250
        0x0020b1f0:    00000004    ....    DCD    4
        0x0020b1f4:    00000000    ....    DCD    0
        0x0020b1f8:    00000000    ....    DCD    0
        0x0020b1fc:    00010000    ....    DCD    65536
        0x0020b200:    00000000    ....    DCD    0
        0x0020b204:    00000001    ....    DCD    1
        0x0020b208:    2a4c0004    ..L*    DCD    709623812
        0x0020b20c:    00000000    ....    DCD    0
        0x0020b210:    00000000    ....    DCD    0
        0x0020b214:    00000000    ....    DCD    0
        0x0020b218:    00000000    ....    DCD    0
        0x0020b21c:    00000000    ....    DCD    0
        0x0020b220:    00000022    "...    DCD    34
        0x0020b224:    28030002    ...(    DCD    671285250
        0x0020b228:    0000001a    ....    DCD    26
        0x0020b22c:    00000000    ....    DCD    0
        0x0020b230:    00000000    ....    DCD    0
        0x0020b234:    00010000    ....    DCD    65536
        0x0020b238:    00000000    ....    DCD    0
        0x0020b23c:    00000001    ....    DCD    1
        0x0020b240:    2a4d0004    ..M*    DCD    709689348
        0x0020b244:    00000000    ....    DCD    0
        0x0020b248:    00000000    ....    DCD    0
        0x0020b24c:    00000000    ....    DCD    0
        0x0020b250:    00030000    ....    DCD    196608
        0x0020b254:    00000000    ....    DCD    0
        0x0020b258:    00000022    "...    DCD    34
        0x0020b25c:    29020012    ...)    DCD    687996946
        0x0020b260:    00000000    ....    DCD    0
        0x0020b264:    00000000    ....    DCD    0
        0x0020b268:    00000000    ....    DCD    0
        0x0020b26c:    00020000    ....    DCD    131072
        0x0020b270:    00000000    ....    DCD    0
        0x0020b274:    00000022    "...    DCD    34
        0x0020b278:    29080012    ...)    DCD    688390162
        0x0020b27c:    00000104    ....    DCD    260
        0x0020b280:    00000000    ....    DCD    0
        0x0020b284:    00000000    ....    DCD    0
        0x0020b288:    00020000    ....    DCD    131072
        0x0020b28c:    00000000    ....    DCD    0
        0x0020b290:    00000002    ....    DCD    2
    hids_cbs
        0x0020b294:    00207fc9    .. .    DCD    2129865
        0x0020b298:    00208065    e. .    DCD    2130021
        0x0020b29c:    002080ed    .. .    DCD    2130157
    .constdata
    bas_attr_tbl
        0x0020b2a0:    28000802    ...(    DCD    671090690
        0x0020b2a4:    0000180f    ....    DCD    6159
        0x0020b2a8:    00000000    ....    DCD    0
        0x0020b2ac:    00000000    ....    DCD    0
        0x0020b2b0:    00020000    ....    DCD    131072
        0x0020b2b4:    00000000    ....    DCD    0
        0x0020b2b8:    00000001    ....    DCD    1
        0x0020b2bc:    28030002    ...(    DCD    671285250
        0x0020b2c0:    00000012    ....    DCD    18
        0x0020b2c4:    00000000    ....    DCD    0
        0x0020b2c8:    00000000    ....    DCD    0
        0x0020b2cc:    00010000    ....    DCD    65536
        0x0020b2d0:    00000000    ....    DCD    0
        0x0020b2d4:    00000001    ....    DCD    1
        0x0020b2d8:    2a190004    ...*    DCD    706281476
        0x0020b2dc:    00000000    ....    DCD    0
        0x0020b2e0:    00000000    ....    DCD    0
        0x0020b2e4:    00000000    ....    DCD    0
        0x0020b2e8:    00000000    ....    DCD    0
        0x0020b2ec:    00000000    ....    DCD    0
        0x0020b2f0:    00000001    ....    DCD    1
        0x0020b2f4:    29020012    ...)    DCD    687996946
        0x0020b2f8:    00000000    ....    DCD    0
        0x0020b2fc:    00000000    ....    DCD    0
        0x0020b300:    00000000    ....    DCD    0
        0x0020b304:    00020000    ....    DCD    131072
        0x0020b308:    00000000    ....    DCD    0
        0x0020b30c:    00000011    ....    DCD    17
    bas_cbs
        0x0020b310:    00208243    C. .    DCD    2130499
        0x0020b314:    00000000    ....    DCD    0
        0x0020b318:    002082ab    .. .    DCD    2130603
    .constdata
    dis_attr_tbl
        0x0020b31c:    28000802    ...(    DCD    671090690
        0x0020b320:    0000180a    ....    DCD    6154
        0x0020b324:    00000000    ....    DCD    0
        0x0020b328:    00000000    ....    DCD    0
        0x0020b32c:    00020000    ....    DCD    131072
        0x0020b330:    00000000    ....    DCD    0
        0x0020b334:    00000001    ....    DCD    1
        0x0020b338:    28030002    ...(    DCD    671285250
        0x0020b33c:    00000002    ....    DCD    2
        0x0020b340:    00000000    ....    DCD    0
        0x0020b344:    00000000    ....    DCD    0
        0x0020b348:    00010000    ....    DCD    65536
        0x0020b34c:    00000000    ....    DCD    0
        0x0020b350:    00000001    ....    DCD    1
        0x0020b354:    2a290004    ..)*    DCD    707330052
        0x0020b358:    00000000    ....    DCD    0
        0x0020b35c:    00000000    ....    DCD    0
        0x0020b360:    00000000    ....    DCD    0
        0x0020b364:    00000000    ....    DCD    0
        0x0020b368:    00000000    ....    DCD    0
        0x0020b36c:    00000001    ....    DCD    1
        0x0020b370:    28030002    ...(    DCD    671285250
        0x0020b374:    00000002    ....    DCD    2
        0x0020b378:    00000000    ....    DCD    0
        0x0020b37c:    00000000    ....    DCD    0
        0x0020b380:    00010000    ....    DCD    65536
        0x0020b384:    00000000    ....    DCD    0
        0x0020b388:    00000001    ....    DCD    1
        0x0020b38c:    2a240004    ..$*    DCD    707002372
        0x0020b390:    00000000    ....    DCD    0
        0x0020b394:    00000000    ....    DCD    0
        0x0020b398:    00000000    ....    DCD    0
        0x0020b39c:    00000000    ....    DCD    0
        0x0020b3a0:    00000000    ....    DCD    0
        0x0020b3a4:    00000001    ....    DCD    1
        0x0020b3a8:    28030002    ...(    DCD    671285250
        0x0020b3ac:    00000002    ....    DCD    2
        0x0020b3b0:    00000000    ....    DCD    0
        0x0020b3b4:    00000000    ....    DCD    0
        0x0020b3b8:    00010000    ....    DCD    65536
        0x0020b3bc:    00000000    ....    DCD    0
        0x0020b3c0:    00000001    ....    DCD    1
        0x0020b3c4:    2a250004    ..%*    DCD    707067908
        0x0020b3c8:    00000000    ....    DCD    0
        0x0020b3cc:    00000000    ....    DCD    0
        0x0020b3d0:    00000000    ....    DCD    0
        0x0020b3d4:    00000000    ....    DCD    0
        0x0020b3d8:    00000000    ....    DCD    0
        0x0020b3dc:    00000001    ....    DCD    1
        0x0020b3e0:    28030002    ...(    DCD    671285250
        0x0020b3e4:    00000002    ....    DCD    2
        0x0020b3e8:    00000000    ....    DCD    0
        0x0020b3ec:    00000000    ....    DCD    0
        0x0020b3f0:    00010000    ....    DCD    65536
        0x0020b3f4:    00000000    ....    DCD    0
        0x0020b3f8:    00000001    ....    DCD    1
        0x0020b3fc:    2a270004    ..'*    DCD    707198980
        0x0020b400:    00000000    ....    DCD    0
        0x0020b404:    00000000    ....    DCD    0
        0x0020b408:    00000000    ....    DCD    0
        0x0020b40c:    00000000    ....    DCD    0
        0x0020b410:    00000000    ....    DCD    0
        0x0020b414:    00000001    ....    DCD    1
        0x0020b418:    28030002    ...(    DCD    671285250
        0x0020b41c:    00000002    ....    DCD    2
        0x0020b420:    00000000    ....    DCD    0
        0x0020b424:    00000000    ....    DCD    0
        0x0020b428:    00010000    ....    DCD    65536
        0x0020b42c:    00000000    ....    DCD    0
        0x0020b430:    00000001    ....    DCD    1
        0x0020b434:    2a260004    ..&*    DCD    707133444
        0x0020b438:    00000000    ....    DCD    0
        0x0020b43c:    00000000    ....    DCD    0
        0x0020b440:    00000000    ....    DCD    0
        0x0020b444:    00000000    ....    DCD    0
        0x0020b448:    00000000    ....    DCD    0
        0x0020b44c:    00000001    ....    DCD    1
        0x0020b450:    28030002    ...(    DCD    671285250
        0x0020b454:    00000002    ....    DCD    2
        0x0020b458:    00000000    ....    DCD    0
        0x0020b45c:    00000000    ....    DCD    0
        0x0020b460:    00010000    ....    DCD    65536
        0x0020b464:    00000000    ....    DCD    0
        0x0020b468:    00000001    ....    DCD    1
        0x0020b46c:    2a280004    ..(*    DCD    707264516
        0x0020b470:    00000000    ....    DCD    0
        0x0020b474:    00000000    ....    DCD    0
        0x0020b478:    00000000    ....    DCD    0
        0x0020b47c:    00000000    ....    DCD    0
        0x0020b480:    00000000    ....    DCD    0
        0x0020b484:    00000001    ....    DCD    1
        0x0020b488:    28030002    ...(    DCD    671285250
        0x0020b48c:    00000002    ....    DCD    2
        0x0020b490:    00000000    ....    DCD    0
        0x0020b494:    00000000    ....    DCD    0
        0x0020b498:    00010000    ....    DCD    65536
        0x0020b49c:    00000000    ....    DCD    0
        0x0020b4a0:    00000001    ....    DCD    1
        0x0020b4a4:    2a230004    ..#*    DCD    706936836
        0x0020b4a8:    00000000    ....    DCD    0
        0x0020b4ac:    00000000    ....    DCD    0
        0x0020b4b0:    00000000    ....    DCD    0
        0x0020b4b4:    00000000    ....    DCD    0
        0x0020b4b8:    00000000    ....    DCD    0
        0x0020b4bc:    00000001    ....    DCD    1
        0x0020b4c0:    28030002    ...(    DCD    671285250
        0x0020b4c4:    00000002    ....    DCD    2
        0x0020b4c8:    00000000    ....    DCD    0
        0x0020b4cc:    00000000    ....    DCD    0
        0x0020b4d0:    00010000    ....    DCD    65536
        0x0020b4d4:    00000000    ....    DCD    0
        0x0020b4d8:    00000001    ....    DCD    1
        0x0020b4dc:    2a2a0004    ..**    DCD    707395588
        0x0020b4e0:    00000000    ....    DCD    0
        0x0020b4e4:    00000000    ....    DCD    0
        0x0020b4e8:    00000000    ....    DCD    0
        0x0020b4ec:    00000000    ....    DCD    0
        0x0020b4f0:    00000000    ....    DCD    0
        0x0020b4f4:    00000001    ....    DCD    1
        0x0020b4f8:    28030002    ...(    DCD    671285250
        0x0020b4fc:    00000002    ....    DCD    2
        0x0020b500:    00000000    ....    DCD    0
        0x0020b504:    00000000    ....    DCD    0
        0x0020b508:    00010000    ....    DCD    65536
        0x0020b50c:    00000000    ....    DCD    0
        0x0020b510:    00000001    ....    DCD    1
        0x0020b514:    2a500004    ..P*    DCD    709885956
        0x0020b518:    00000000    ....    DCD    0
        0x0020b51c:    00000000    ....    DCD    0
        0x0020b520:    00000000    ....    DCD    0
        0x0020b524:    00000000    ....    DCD    0
        0x0020b528:    00000000    ....    DCD    0
        0x0020b52c:    00000001    ....    DCD    1
    dis_cbs
        0x0020b530:    00208419    .. .    DCD    2130969
        0x0020b534:    00000000    ....    DCD    0
        0x0020b538:    00000000    ....    DCD    0
    .constdata
    GATT_UUID_OTA_SERVICE
        0x0020b53c:    2e4da212    ..M.    DCD    776839698
        0x0020b540:    8e4814fe    ..H.    DCD    2387088638
        0x0020b544:    3c17d293    ...<    DCD    1008194195
        0x0020b548:    0000d0ff    ....    DCD    53503
    .constdata
    gattOtaServiceTable
        0x0020b54c:    28000800    ...(    DCD    671090688
        0x0020b550:    00000000    ....    DCD    0
        0x0020b554:    00000000    ....    DCD    0
        0x0020b558:    00000000    ....    DCD    0
        0x0020b55c:    00100000    ....    DCD    1048576
        0x0020b560:    0020b53c    <. .    DCD    2143548
        0x0020b564:    00000001    ....    DCD    1
        0x0020b568:    28030002    ...(    DCD    671285250
        0x0020b56c:    00000004    ....    DCD    4
        0x0020b570:    00000000    ....    DCD    0
        0x0020b574:    00000000    ....    DCD    0
        0x0020b578:    00010000    ....    DCD    65536
        0x0020b57c:    00000000    ....    DCD    0
        0x0020b580:    00000001    ....    DCD    1
        0x0020b584:    ffd10004    ....    DCD    4291887108
        0x0020b588:    00000000    ....    DCD    0
        0x0020b58c:    00000000    ....    DCD    0
        0x0020b590:    00000000    ....    DCD    0
        0x0020b594:    00020000    ....    DCD    131072
        0x0020b598:    00000000    ....    DCD    0
        0x0020b59c:    00000011    ....    DCD    17
        0x0020b5a0:    28030002    ...(    DCD    671285250
        0x0020b5a4:    00000002    ....    DCD    2
        0x0020b5a8:    00000000    ....    DCD    0
        0x0020b5ac:    00000000    ....    DCD    0
        0x0020b5b0:    00010000    ....    DCD    65536
        0x0020b5b4:    00000000    ....    DCD    0
        0x0020b5b8:    00000001    ....    DCD    1
        0x0020b5bc:    ffd20004    ....    DCD    4291952644
        0x0020b5c0:    00000000    ....    DCD    0
        0x0020b5c4:    00000000    ....    DCD    0
        0x0020b5c8:    00000000    ....    DCD    0
        0x0020b5cc:    00010000    ....    DCD    65536
        0x0020b5d0:    00000000    ....    DCD    0
        0x0020b5d4:    00000001    ....    DCD    1
        0x0020b5d8:    28030002    ...(    DCD    671285250
        0x0020b5dc:    00000002    ....    DCD    2
        0x0020b5e0:    00000000    ....    DCD    0
        0x0020b5e4:    00000000    ....    DCD    0
        0x0020b5e8:    00010000    ....    DCD    65536
        0x0020b5ec:    00000000    ....    DCD    0
        0x0020b5f0:    00000001    ....    DCD    1
        0x0020b5f4:    ffd30004    ....    DCD    4292018180
        0x0020b5f8:    00000000    ....    DCD    0
        0x0020b5fc:    00000000    ....    DCD    0
        0x0020b600:    00000000    ....    DCD    0
        0x0020b604:    00010000    ....    DCD    65536
        0x0020b608:    00000000    ....    DCD    0
        0x0020b60c:    00000001    ....    DCD    1
        0x0020b610:    28030002    ...(    DCD    671285250
        0x0020b614:    00000002    ....    DCD    2
        0x0020b618:    00000000    ....    DCD    0
        0x0020b61c:    00000000    ....    DCD    0
        0x0020b620:    00010000    ....    DCD    65536
        0x0020b624:    00000000    ....    DCD    0
        0x0020b628:    00000001    ....    DCD    1
        0x0020b62c:    ffd40004    ....    DCD    4292083716
        0x0020b630:    00000000    ....    DCD    0
        0x0020b634:    00000000    ....    DCD    0
        0x0020b638:    00000000    ....    DCD    0
        0x0020b63c:    00010000    ....    DCD    65536
        0x0020b640:    00000000    ....    DCD    0
        0x0020b644:    00000001    ....    DCD    1
        0x0020b648:    28030002    ...(    DCD    671285250
        0x0020b64c:    00000002    ....    DCD    2
        0x0020b650:    00000000    ....    DCD    0
        0x0020b654:    00000000    ....    DCD    0
        0x0020b658:    00010000    ....    DCD    65536
        0x0020b65c:    00000000    ....    DCD    0
        0x0020b660:    00000001    ....    DCD    1
        0x0020b664:    ffd50004    ....    DCD    4292149252
        0x0020b668:    00000000    ....    DCD    0
        0x0020b66c:    00000000    ....    DCD    0
        0x0020b670:    00000000    ....    DCD    0
        0x0020b674:    00010000    ....    DCD    65536
        0x0020b678:    00000000    ....    DCD    0
        0x0020b67c:    00000001    ....    DCD    1
        0x0020b680:    28030002    ...(    DCD    671285250
        0x0020b684:    00000004    ....    DCD    4
        0x0020b688:    00000000    ....    DCD    0
        0x0020b68c:    00000000    ....    DCD    0
        0x0020b690:    00010000    ....    DCD    65536
        0x0020b694:    00000000    ....    DCD    0
        0x0020b698:    00000001    ....    DCD    1
        0x0020b69c:    ffd80004    ....    DCD    4292345860
        0x0020b6a0:    00000000    ....    DCD    0
        0x0020b6a4:    00000000    ....    DCD    0
        0x0020b6a8:    00000000    ....    DCD    0
        0x0020b6ac:    00000000    ....    DCD    0
        0x0020b6b0:    00000000    ....    DCD    0
        0x0020b6b4:    00000010    ....    DCD    16
        0x0020b6b8:    28030002    ...(    DCD    671285250
        0x0020b6bc:    00000002    ....    DCD    2
        0x0020b6c0:    00000000    ....    DCD    0
        0x0020b6c4:    00000000    ....    DCD    0
        0x0020b6c8:    00010000    ....    DCD    65536
        0x0020b6cc:    00000000    ....    DCD    0
        0x0020b6d0:    00000001    ....    DCD    1
        0x0020b6d4:    fff10004    ....    DCD    4293984260
        0x0020b6d8:    00000000    ....    DCD    0
        0x0020b6dc:    00000000    ....    DCD    0
        0x0020b6e0:    00000000    ....    DCD    0
        0x0020b6e4:    00010000    ....    DCD    65536
        0x0020b6e8:    00000000    ....    DCD    0
        0x0020b6ec:    00000001    ....    DCD    1
        0x0020b6f0:    28030002    ...(    DCD    671285250
        0x0020b6f4:    00000008    ....    DCD    8
        0x0020b6f8:    00000000    ....    DCD    0
        0x0020b6fc:    00000000    ....    DCD    0
        0x0020b700:    00010000    ....    DCD    65536
        0x0020b704:    00000000    ....    DCD    0
        0x0020b708:    00000001    ....    DCD    1
        0x0020b70c:    fff20004    ....    DCD    4294049796
        0x0020b710:    00000000    ....    DCD    0
        0x0020b714:    00000000    ....    DCD    0
        0x0020b718:    00000000    ....    DCD    0
        0x0020b71c:    00050000    ....    DCD    327680
        0x0020b720:    00000000    ....    DCD    0
        0x0020b724:    00000010    ....    DCD    16
        0x0020b728:    28030002    ...(    DCD    671285250
        0x0020b72c:    00000002    ....    DCD    2
        0x0020b730:    00000000    ....    DCD    0
        0x0020b734:    00000000    ....    DCD    0
        0x0020b738:    00010000    ....    DCD    65536
        0x0020b73c:    00000000    ....    DCD    0
        0x0020b740:    00000001    ....    DCD    1
        0x0020b744:    ffe00004    ....    DCD    4292870148
        0x0020b748:    00000000    ....    DCD    0
        0x0020b74c:    00000000    ....    DCD    0
        0x0020b750:    00000000    ....    DCD    0
        0x0020b754:    00010000    ....    DCD    65536
        0x0020b758:    00000000    ....    DCD    0
        0x0020b75c:    00000001    ....    DCD    1
    OTAServiceCBs
        0x0020b760:    00208675    u. .    DCD    2131573
        0x0020b764:    002085d1    .. .    DCD    2131409
        0x0020b768:    00000000    ....    DCD    0
    .constdata
    scan_rsp_data
        0x0020b76c:    03c11903    ....    DCD    62986499
    adv_data
        0x0020b770:    03050102    ....    DCD    50659586
        0x0020b774:    0d181203    ....    DCD    219681283
        0x0020b778:    454c4209    .BLE    DCD    1162625545
        0x0020b77c:    59454b5f    _KEY    DCD    1497713503
        0x0020b780:    52414f42    BOAR    DCD    1380011842
        0x0020b784:    00000044    D...    DCD    68
        0x0020b788:    5f454c42    BLE_    DCD    1598377026
        0x0020b78c:    4259454b    KEYB    DCD    1113146699
        0x0020b790:    4452414f    OARD    DCD    1146241359
        0x0020b794:    00000000    ....    DCD    0
        0x0020b798:    00000000    ....    DCD    0
        0x0020b79c:    00000000    ....    DCD    0
        0x0020b7a0:    00000000    ....    DCD    0
        0x0020b7a4:    00000000    ....    DCD    0
        0x0020b7a8:    00000000    ....    DCD    0
        0x0020b7ac:    00000000    ....    DCD    0
    .constdata
    __func__
        0x0020b7b0:    5f707061    app_    DCD    1601204321
        0x0020b7b4:    646e6573    send    DCD    1684956531
        0x0020b7b8:    67736d5f    _msg    DCD    1735617887
        0x0020b7bc:    5f6f745f    _to_    DCD    1601139807
        0x0020b7c0:    74707061    appt    DCD    1953525857
        0x0020b7c4:    006b7361    ask.    DCD    7041889
    __func__
        0x0020b7c8:    5f707061    app_    DCD    1601204321
        0x0020b7cc:    6e69616d    main    DCD    1852399981
        0x0020b7d0:    7361745f    _tas    DCD    1935766623
        0x0020b7d4:    006b        k.      DCW    107
    .constdata
    key_map
        0x0020b7d6:    0027        '.      DCW    39
        0x0020b7d8:    001f001e    ....    DCD    2031646
        0x0020b7dc:    00210020     .!.    DCD    2162720
        0x0020b7e0:    00230022    ".#.    DCD    2293794
        0x0020b7e4:    00250024    $.%.    DCD    2424868
        0x0020b7e8:    002a0026    &.*.    DCD    2752550
        0x0020b7ec:    00040028    (...    DCD    262184
        0x0020b7f0:    00500039    9.P.    DCD    5242937
        0x0020b7f4:    0000004f    O...    DCD    79
    .conststring
        0x0020b7f8:    30433249    I2C0    DCD    809710153
        0x0020b7fc:    00000000    ....    DCD    0
        0x0020b800:    30495053    SPI0    DCD    810111059
        0x0020b804:    00000000    ....    DCD    0
        0x0020b808:    54524155    UART    DCD    1414676821
        0x0020b80c:    00000030    0...    DCD    48
        0x0020b810:    414d4447    GDMA    DCD    1095582791
        0x0020b814:    68432030    0 Ch    DCD    1749229616
        0x0020b818:    656e6e61    anne    DCD    1701736033
        0x0020b81c:    0000306c    l0..    DCD    12396
        0x0020b820:    4f495047    GPIO    DCD    1330204743
        0x0020b824:    6f72475f    _Gro    DCD    1869760351
        0x0020b828:    00307075    up0.    DCD    3174517
        0x0020b82c:    31433249    I2C1    DCD    826487369
        0x0020b830:    00000000    ....    DCD    0
        0x0020b834:    31495053    SPI1    DCD    826888275
        0x0020b838:    00000000    ....    DCD    0
        0x0020b83c:    54524155    UART    DCD    1414676821
        0x0020b840:    00000031    1...    DCD    49
        0x0020b844:    414d4447    GDMA    DCD    1095582791
        0x0020b848:    68432030    0 Ch    DCD    1749229616
        0x0020b84c:    656e6e61    anne    DCD    1701736033
        0x0020b850:    0000316c    l1..    DCD    12652
        0x0020b854:    4f495047    GPIO    DCD    1330204743
        0x0020b858:    6f72475f    _Gro    DCD    1869760351
        0x0020b85c:    00317075    up1.    DCD    3240053
        0x0020b860:    324d4954    TIM2    DCD    843925844
        0x0020b864:    00000000    ....    DCD    0
        0x0020b868:    54524155    UART    DCD    1414676821
        0x0020b86c:    00000032    2...    DCD    50
        0x0020b870:    414d4447    GDMA    DCD    1095582791
        0x0020b874:    68432030    0 Ch    DCD    1749229616
        0x0020b878:    656e6e61    anne    DCD    1701736033
        0x0020b87c:    0000326c    l2..    DCD    12908
        0x0020b880:    4f495047    GPIO    DCD    1330204743
        0x0020b884:    6f72475f    _Gro    DCD    1869760351
        0x0020b888:    00327075    up2.    DCD    3305589
        0x0020b88c:    334d4954    TIM3    DCD    860703060
        0x0020b890:    00000000    ....    DCD    0
        0x0020b894:    414d4447    GDMA    DCD    1095582791
        0x0020b898:    68432030    0 Ch    DCD    1749229616
        0x0020b89c:    656e6e61    anne    DCD    1701736033
        0x0020b8a0:    0000336c    l3..    DCD    13164
        0x0020b8a4:    4f495047    GPIO    DCD    1330204743
        0x0020b8a8:    6f72475f    _Gro    DCD    1869760351
        0x0020b8ac:    00337075    up3.    DCD    3371125
        0x0020b8b0:    344d4954    TIM4    DCD    877480276
        0x0020b8b4:    00000000    ....    DCD    0
        0x0020b8b8:    4f495047    GPIO    DCD    1330204743
        0x0020b8bc:    00000034    4...    DCD    52
        0x0020b8c0:    414d4447    GDMA    DCD    1095582791
        0x0020b8c4:    68432030    0 Ch    DCD    1749229616
        0x0020b8c8:    656e6e61    anne    DCD    1701736033
        0x0020b8cc:    0000346c    l4..    DCD    13420
        0x0020b8d0:    354d4954    TIM5    DCD    894257492
        0x0020b8d4:    00000000    ....    DCD    0
        0x0020b8d8:    4f495047    GPIO    DCD    1330204743
        0x0020b8dc:    00000035    5...    DCD    53
        0x0020b8e0:    414d4447    GDMA    DCD    1095582791
        0x0020b8e4:    68432030    0 Ch    DCD    1749229616
        0x0020b8e8:    656e6e61    anne    DCD    1701736033
        0x0020b8ec:    0000356c    l5..    DCD    13676
        0x0020b8f0:    364d4954    TIM6    DCD    911034708
        0x0020b8f4:    00000000    ....    DCD    0
        0x0020b8f8:    656d6954    Time    DCD    1701669204
        0x0020b8fc:    372d3472    r4-7    DCD    925709426
        0x0020b900:    00000000    ....    DCD    0
        0x0020b904:    374d4954    TIM7    DCD    927811924
        0x0020b908:    00000000    ....    DCD    0
        0x0020b90c:    414d5442    BTMA    DCD    1095586882
        0x0020b910:    00000043    C...    DCD    67
        0x0020b914:    00434441    ADC.    DCD    4408385
        0x0020b918:    00435452    RTC.    DCD    4412498
        0x0020b91c:    00435653    SVC.    DCD    4413011
        0x0020b920:    0044434c    LCD.    DCD    4473676
        0x0020b924:    00474457    WDG.    DCD    4670551
        0x0020b928:    00494d4e    NMI.    DCD    4803918
        0x0020b92c:    4f43504c    LPCO    DCD    1329811532
        0x0020b930:    0000504d    MP..    DCD    20557
        0x0020b934:    74696e49    Init    DCD    1953066569
        0x0020b938:    536c6169    ialS    DCD    1399611753
        0x0020b93c:    00000050    P...    DCD    80
        0x0020b940:    00005249    IR..    DCD    21065
        0x0020b944:    646e6550    Pend    DCD    1684956496
        0x0020b948:    00005653    SV..    DCD    22099
        0x0020b94c:    32495053    SPI2    DCD    843665491
        0x0020b950:    00000057    W...    DCD    87
        0x0020b954:    524f5053    SPOR    DCD    1380929619
        0x0020b958:    52203154    T1 R    DCD    1377841492
        0x0020b95c:    00000058    X...    DCD    88
        0x0020b960:    30533249    I2S0    DCD    810758729
        0x0020b964:    0058525f    _RX.    DCD    5788255
        0x0020b968:    524f5053    SPOR    DCD    1380929619
        0x0020b96c:    54203154    T1 T    DCD    1411395924
        0x0020b970:    00000058    X...    DCD    88
        0x0020b974:    30533249    I2S0    DCD    810758729
        0x0020b978:    0058545f    _TX.    DCD    5788767
        0x0020b97c:    64767352    Rsvd    DCD    1685484370
        0x0020b980:    00000000    ....    DCD    0
        0x0020b984:    63656451    Qdec    DCD    1667589201
        0x0020b988:    0065646f    ode.    DCD    6644847
        0x0020b98c:    4d6d654d    MemM    DCD    1299014989
        0x0020b990:    67616e61    anag    DCD    1734438497
        0x0020b994:    00000065    e...    DCD    101
        0x0020b998:    5f495053    SPI_    DCD    1598640211
        0x0020b99c:    73616c46    Flas    DCD    1935764550
        0x0020b9a0:    00000068    h...    DCD    104
        0x0020b9a4:    54737953    SysT    DCD    1416853843
        0x0020b9a8:    006b6369    ick.    DCD    7037801
        0x0020b9ac:    69726550    Peri    DCD    1769104720
        0x0020b9b0:    72656870    pher    DCD    1919248496
        0x0020b9b4:    00006c61    al..    DCD    27745
        0x0020b9b8:    74737953    Syst    DCD    1953724755
        0x0020b9bc:    00006d65    em..    DCD    28005
        0x0020b9c0:    74616c50    Plat    DCD    1952541776
        0x0020b9c4:    6d726f66    form    DCD    1836216166
        0x0020b9c8:    00000000    ....    DCD    0
        0x0020b9cc:    7379654b    Keys    DCD    1937335627
        0x0020b9d0:    006e6163    can.    DCD    7233891
        0x0020b9d4:    75626544    Debu    DCD    1969382724
        0x0020b9d8:    6e6f4d67    gMon    DCD    1852788071
        0x0020b9dc:    00000000    ....    DCD    0
        0x0020b9e0:    65736552    Rese    DCD    1702061394
        0x0020b9e4:    00000074    t...    DCD    116
        0x0020b9e8:    64726148    Hard    DCD    1685217608
        0x0020b9ec:    6c756146    Faul    DCD    1819631942
        0x0020b9f0:    00000074    t...    DCD    116
        0x0020b9f4:    67617355    Usag    DCD    1734439765
        0x0020b9f8:    75614665    eFau    DCD    1969309285
        0x0020b9fc:    0000746c    lt..    DCD    29804
        0x0020ba00:    46737542    BusF    DCD    1181971778
        0x0020ba04:    746c7561    ault    DCD    1953264993
        0x0020ba08:    00000000    ....    DCD    0
        0x0020ba0c:    5f415450    PTA_    DCD    1598116944
        0x0020ba10:    6c69614d    Mail    DCD    1818845517
        0x0020ba14:    00786f62    box.    DCD    7892834
    .conststring
        0x0020ba18:    6e656353    Scen    DCD    1852138323
        0x0020ba1c:    00425f65    e_B.    DCD    4349797
        0x0020ba20:    6e656353    Scen    DCD    1852138323
        0x0020ba24:    00435f65    e_C.    DCD    4415333
        0x0020ba28:    746f6f42    Boot    DCD    1953460034
        0x0020ba2c:    65636e4f    Once    DCD    1701015119
        0x0020ba30:    00000000    ....    DCD    0

** Section #6 'RAM_DATA_ON' (SHT_PROGBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 160 bytes (alignment 4)
    Address: 0x0020ba34

    0x20ba34:   2c 03 00 00 00 01 0e 01 5d 00 00 00 00 01 00 01    ,.......].......
    0x20ba44:   02 00 00 03 04 05 fe 00 65 78 70 65 72 69 6d 65    ........experime
    0x20ba54:   6e 74 61 6c 00 00 00 00 00 00 00 00 00 00 00 00    ntal............
    0x20ba64:   00 00 00 00 28 ba 20 00 18 26 81 00 d8 26 81 00    ....(. ..&...&..
    0x20ba74:   ec bc 20 00 ac bd 20 00 ac bd 20 00 c0 00 00 00    .. ... ... .....
    0x20ba84:   00 00 00 00 00 00 00 00 18 ba 20 00 d8 26 81 00    .......... ..&..
    0x20ba94:   d8 26 81 00 ec bc 20 00 ec bc 20 00 ec bc 20 00    .&.... ... ... .
    0x20baa4:   00 00 00 00 00 00 00 00 00 00 00 00 20 ba 20 00    ............ . .
    0x20bab4:   d8 26 81 00 d8 26 81 00 ec bc 20 00 ec bc 20 00    .&...&.... ... .
    0x20bac4:   ec bc 20 00 00 00 00 00 00 00 00 00 00 00 00 00    .. .............


** Section #7 'RAM_DATA_ON' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 536 bytes (alignment 4)
    Address: 0x0020bad4


** Section #8 'OVERLAY_A' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 192 bytes (alignment 4)
    Address: 0x0020bcec

    $t
    .app.overlay_a
    AppUpdateVectorTable
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c
;;;474    static void AppUpdateVectorTable(void)
;;;474    {
        0x0020bcec:    e92d43f0    -..C    PUSH     {r4-r9,lr}
        0x0020bcf0:    b0bd        ..      SUB      sp,sp,#0xf4
;;;475        extern uint32_t Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;476        extern uint32_t Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;477        extern void Default_Handler(void);
;;;478        const char *SysException[] =
        0x0020bcf2:    2240        @"      MOVS     r2,#0x40
        0x0020bcf4:    4926        &I      LDR      r1,[pc,#152] ; [0x20bd90] = 0x20ade0
        0x0020bcf6:    a82d        -.      ADD      r0,sp,#0xb4
        0x0020bcf8:    f64ef956    N.V.    BL       __aeabi_memcpy4 ; 0x59fa8
;;;479        {
;;;480            "InitialSP", "Reset", "NMI", "HardFault", "MemManage", "BusFault", "UsageFault", "Rsvd",
;;;481            "Rsvd", "Rsvd", "Rsvd", "SVC", "DebugMon", "Rsvd", "PendSV", "SysTick"
;;;482        };
;;;483        const char *ExtIrq[] =
        0x0020bcfc:    4924        $I      LDR      r1,[pc,#144] ; [0x20bd90] = 0x20ade0
        0x0020bcfe:    22b4        ."      MOVS     r2,#0xb4
        0x0020bd00:    3140        @1      ADDS     r1,r1,#0x40
        0x0020bd02:    4668        hF      MOV      r0,sp
        0x0020bd04:    f64ef950    N.P.    BL       __aeabi_memcpy4 ; 0x59fa8
        0x0020bd08:    4924        $I      LDR      r1,[pc,#144] ; [0x20bd9c] = 0xe000ed08
;;;484        {
;;;485            "System", "WDG", "BTMAC", "TIM3", "TIM2", "Platform", "I2S0_TX", "I2S0_RX", "Timer4-7",
;;;486            "GPIO4", "GPIO5", "UART1", "UART0", "RTC", "SPI0", "SPI1", "I2C0", "I2C1", "ADC",
;;;487            "Peripheral", "GDMA0 Channel0", "GDMA0 Channel1", "GDMA0 Channel2", "GDMA0 Channel3",
;;;488            "GDMA0 Channel4", "GDMA0 Channel5", "GPIO_Group3", "GPIO_Group2", "IR", "GPIO_Group1",
;;;489            "GPIO_Group0", "UART2", "TIM4", "TIM5", "TIM6", "TIM7", "SPI_Flash", "Qdecode",
;;;490            "Keyscan", "SPI2W", "LPCOMP", "PTA_Mailbox", "SPORT1 TX", "SPORT1 RX", "LCD"
;;;491        };
;;;492    
;;;493        IRQ_Fun *pRamVector    = (IRQ_Fun *)VTOR_RAM_ADDR;
        0x0020bd0a:    f44f1000    O...    MOV      r0,#0x200000
        0x0020bd0e:    4d21        !M      LDR      r5,[pc,#132] ; [0x20bd94] = 0x80e650
        0x0020bd10:    4f21        !O      LDR      r7,[pc,#132] ; [0x20bd98] = 0xf4
        0x0020bd12:    6809        .h      LDR      r1,[r1,#0]
        0x0020bd14:    4606        .F      MOV      r6,r0
;;;494        IRQ_Fun *pAppVector    = (IRQ_Fun *)&Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;495        uint32_t AppVectorSize = (uint32_t)&Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;496        uint32_t i             = 0;
        0x0020bd16:    2400        .$      MOVS     r4,#0
;;;497    
;;;498        if (SCB->VTOR != VTOR_RAM_ADDR)
        0x0020bd18:    42b1        .B      CMP      r1,r6
        0x0020bd1a:    d001        ..      BEQ      0x20bd20 ; AppUpdateVectorTable + 52
;;;499        {
;;;500            RamVectorTableInit(VTOR_RAM_ADDR);
        0x0020bd1c:    f5f8ffc4    ....    BL       RamVectorTableInit ; 0x4ca8
        0x0020bd20:    f04f5805    O..X    MOV      r8,#0x21400000
        0x0020bd24:    f8df9078    ..x.    LDR      r9,[pc,#120] ; [0x20bda0] = 0x21100101
;;;501        }
;;;502    
;;;503        /* Update APP defined handlers */
;;;504        for (i = 0; i < AppVectorSize / 4; ++i)
        0x0020bd28:    e027        '.      B        0x20bd7a ; AppUpdateVectorTable + 142
;;;505        {
;;;506            if (i == 1) //skip reset_handler remap
        0x0020bd2a:    2c01        .,      CMP      r4,#1
        0x0020bd2c:    d024        $.      BEQ      0x20bd78 ; AppUpdateVectorTable + 140
;;;507            {
;;;508                continue;
;;;509            }
;;;510    
;;;511            if ((pAppVector[i] != Default_Handler) && (pAppVector[i] != 0))
        0x0020bd2e:    f8550024    U.$.    LDR      r0,[r5,r4,LSL #2]
        0x0020bd32:    491c        .I      LDR      r1,[pc,#112] ; [0x20bda4] = 0x207e79
        0x0020bd34:    4288        .B      CMP      r0,r1
        0x0020bd36:    d01f        ..      BEQ      0x20bd78 ; AppUpdateVectorTable + 140
        0x0020bd38:    b1f0        ..      CBZ      r0,0x20bd78 ; AppUpdateVectorTable + 140
;;;512            {
;;;513                if (i < System_VECTORn)
        0x0020bd3a:    2c10        .,      CMP      r4,#0x10
        0x0020bd3c:    d209        ..      BCS      0x20bd52 ; AppUpdateVectorTable + 102
;;;514                {
;;;515                    OS_PRINT_WARN1("Warning! %s is updated by APP!", TRACE_STRING(SysException[i]));
        0x0020bd3e:    a82d        -.      ADD      r0,sp,#0xb4
        0x0020bd40:    f8501024    P.$.    LDR      r1,[r0,r4,LSL #2]
        0x0020bd44:    4640        @F      MOV      r0,r8
        0x0020bd46:    f5fcf890    ....    BL       trace_string ; 0x7e6a
        0x0020bd4a:    4603        .F      MOV      r3,r0
        0x0020bd4c:    2201        ."      MOVS     r2,#1
        0x0020bd4e:    4916        .I      LDR      r1,[pc,#88] ; [0x20bda8] = 0x8800020
        0x0020bd50:    e00b        ..      B        0x20bd6a ; AppUpdateVectorTable + 126
;;;516                }
;;;517                else
;;;518                {
;;;519                    OS_PRINT_WARN1("Warning! ISR %s is updated by APP!",
        0x0020bd52:    4668        hF      MOV      r0,sp
        0x0020bd54:    eb000084    ....    ADD      r0,r0,r4,LSL #2
        0x0020bd58:    f8501c40    P.@.    LDR      r1,[r0,#-0x40]
        0x0020bd5c:    4640        @F      MOV      r0,r8
        0x0020bd5e:    f5fcf884    ....    BL       trace_string ; 0x7e6a
        0x0020bd62:    4911        .I      LDR      r1,[pc,#68] ; [0x20bda8] = 0x8800020
        0x0020bd64:    2201        ."      MOVS     r2,#1
        0x0020bd66:    4603        .F      MOV      r3,r0
        0x0020bd68:    3124        $1      ADDS     r1,r1,#0x24
        0x0020bd6a:    4648        HF      MOV      r0,r9
        0x0020bd6c:    f5fbfe77    ..w.    BL       log_buffer ; 0x7a5e
;;;520                                   TRACE_STRING(ExtIrq[i - System_VECTORn]));
;;;521                }
;;;522    
;;;523                pRamVector[i] = pAppVector[i];
        0x0020bd70:    f8550024    U.$.    LDR      r0,[r5,r4,LSL #2]
        0x0020bd74:    f8460024    F.$.    STR      r0,[r6,r4,LSL #2]
        0x0020bd78:    1c64        d.      ADDS     r4,r4,#1
        0x0020bd7a:    ebb40f97    ....    CMP      r4,r7,LSR #2
        0x0020bd7e:    d3d4        ..      BCC      0x20bd2a ; AppUpdateVectorTable + 62
;;;524            }
;;;525        }
;;;526    
;;;527        __DMB();
        0x0020bd80:    f3bf8f5f    .._.    DMB      
;;;528        __DSB();
        0x0020bd84:    f3bf8f4f    ..O.    DSB      
;;;529    }
        0x0020bd88:    b03d        =.      ADD      sp,sp,#0xf4
        0x0020bd8a:    e8bd83f0    ....    POP      {r4-r9,pc}
    $d
        0x0020bd8e:    0000        ..      DCW    0
        0x0020bd90:    0020ade0    .. .    DCD    2141664
        0x0020bd94:    0080e650    P...    DCD    8447568
        0x0020bd98:    000000f4    ....    DCD    244
        0x0020bd9c:    e000ed08    ....    DCD    3758157064
        0x0020bda0:    21100101    ...!    DCD    554696961
        0x0020bda4:    00207e79    y~ .    DCD    2129529
        0x0020bda8:    08800020     ...    DCD    142606368

** Section #9 'App.trace' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 6200 bytes (alignment 4)
    Address: 0x08800000

    0x8800000:   21 21 21 53 44 4b 20 56 65 72 3a 20 25 73 2c 20    !!!SDK Ver: %s, 
    0x8800010:   42 75 69 6c 64 20 54 69 6d 65 3a 20 25 73 00 00    Build Time: %s..
    0x8800020:   21 21 2a 57 61 72 6e 69 6e 67 21 20 25 73 20 69    !!*Warning! %s i
    0x8800030:   73 20 75 70 64 61 74 65 64 20 62 79 20 41 50 50    s updated by APP
    0x8800040:   21 00 00 00 21 21 2a 57 61 72 6e 69 6e 67 21 20    !...!!*Warning! 
    0x8800050:   49 53 52 20 25 73 20 69 73 20 75 70 64 61 74 65    ISR %s is update
    0x8800060:   64 20 62 79 20 41 50 50 21 00 00 00 21 2a 2a 68    d by APP!...!**h
    0x8800070:   69 64 73 5f 63 63 63 64 5f 75 70 64 61 74 65 5f    ids_cccd_update_
    0x8800080:   63 62 20 69 6e 64 65 78 20 3d 20 25 64 20 63 63    cb index = %d cc
    0x8800090:   63 5f 62 69 74 73 20 25 78 00 00 00 21 2a 2a 68    c_bits %x...!**h
    0x88000a0:   69 64 73 5f 73 65 6e 64 5f 72 65 70 6f 72 74 20    ids_send_report 
    0x88000b0:   64 61 74 61 5f 6c 65 6e 20 25 64 00 21 21 21 68    data_len %d.!!!h
    0x88000c0:   69 64 73 5f 61 64 64 5f 73 65 72 76 69 63 65 3a    ids_add_service:
    0x88000d0:   20 53 65 72 76 69 63 65 49 64 20 25 64 00 00 00     ServiceId %d...
    0x88000e0:   21 21 21 62 61 73 5f 73 65 74 5f 70 61 72 61 6d    !!!bas_set_param
    0x88000f0:   65 74 65 72 20 66 61 69 6c 65 64 00 21 2a 2a 62    eter failed.!**b
    0x8800100:   61 73 5f 61 74 74 72 5f 72 65 61 64 5f 63 62 20    as_attr_read_cb 
    0x8800110:   61 74 74 72 69 62 5f 69 6e 64 65 78 20 3d 20 25    attrib_index = %
    0x8800120:   64 20 6f 66 66 73 65 74 20 25 78 00 21 21 21 62    d offset %x.!!!b
    0x8800130:   61 73 5f 61 74 74 72 5f 72 65 61 64 5f 63 62 20    as_attr_read_cb 
    0x8800140:   61 74 74 72 69 62 5f 69 6e 64 65 78 20 3d 20 25    attrib_index = %
    0x8800150:   64 20 6e 6f 74 20 66 6f 75 6e 64 00 21 2a 2a 62    d not found.!**b
    0x8800160:   61 73 5f 63 63 63 64 5f 75 70 64 61 74 65 5f 63    as_cccd_update_c
    0x8800170:   62 20 69 6e 64 65 78 20 3d 20 25 64 20 63 63 63    b index = %d ccc
    0x8800180:   5f 62 69 74 73 20 25 78 00 00 00 00 21 21 21 62    _bits %x....!!!b
    0x8800190:   61 73 5f 61 64 64 5f 73 65 72 76 69 63 65 3a 20    as_add_service: 
    0x88001a0:   73 65 72 76 69 63 65 5f 69 64 20 25 64 00 00 00    service_id %d...
    0x88001b0:   21 21 21 44 49 53 20 70 61 72 61 6d 65 74 65 72    !!!DIS parameter
    0x88001c0:   20 73 65 74 20 66 61 69 6c 65 64 00 21 21 21 64     set failed.!!!d
    0x88001d0:   69 73 5f 61 74 74 72 5f 72 65 61 64 5f 63 62 3a    is_attr_read_cb:
    0x88001e0:   20 61 74 74 72 69 62 5f 69 6e 64 65 78 20 25 64     attrib_index %d
    0x88001f0:   00 00 00 00 21 2a 2a 64 69 73 5f 61 74 74 72 5f    ....!**dis_attr_
    0x8800200:   72 65 61 64 5f 63 62 3a 20 61 74 74 72 69 62 5f    read_cb: attrib_
    0x8800210:   69 6e 64 65 78 20 25 64 2c 20 2a 6c 65 6e 67 74    index %d, *lengt
    0x8800220:   68 5f 70 74 72 20 25 64 00 00 00 00 21 21 21 64    h_ptr %d....!!!d
    0x8800230:   69 73 5f 61 64 64 5f 73 65 72 76 69 63 65 3a 20    is_add_service: 
    0x8800240:   73 65 72 76 69 63 65 5f 69 64 20 25 64 00 00 00    service_id %d...
    0x8800250:   21 2a 2a 2d 2d 3e 20 4f 54 41 5f 41 74 74 72 57    !**--> OTA_AttrW
    0x8800260:   72 69 74 65 20 45 72 72 6f 72 20 20 69 41 74 74    rite Error  iAtt
    0x8800270:   72 69 62 49 6e 64 65 78 20 3d 20 30 78 25 78 20    ribIndex = 0x%x 
    0x8800280:   77 4c 65 6e 67 74 68 3d 25 64 00 00 21 2a 2a 3c    wLength=%d..!**<
    0x8800290:   2d 2d 20 4f 54 41 5f 41 74 74 72 52 65 61 64 2c    -- OTA_AttrRead,
    0x88002a0:   20 41 74 74 72 20 6e 6f 74 20 66 6f 75 6e 64 2c     Attr not found,
    0x88002b0:   20 69 6e 64 65 78 3d 25 64 00 00 00 21 2a 2a 70     index=%d...!**p
    0x88002c0:   61 74 63 68 5f 61 64 64 72 20 3d 20 25 78 00 00    atch_addr = %x..
    0x88002d0:   21 2a 2a 70 61 74 63 68 5f 76 65 72 73 69 6f 6e    !**patch_version
    0x88002e0:   20 3d 20 25 78 00 00 00 21 2a 2a 61 70 70 5f 61     = %x...!**app_a
    0x88002f0:   64 64 72 20 3d 20 25 78 00 00 00 00 21 2a 2a 61    ddr = %x....!**a
    0x8800300:   70 70 5f 76 65 72 73 69 6f 6e 20 3d 20 25 78 00    pp_version = %x.
    0x8800310:   21 2a 2a 6f 74 61 68 65 61 64 65 72 5f 61 64 64    !**otaheader_add
    0x8800320:   72 20 3d 20 25 78 00 00 21 2a 2a 6f 74 61 68 65    r = %x..!**otahe
    0x8800330:   61 64 65 72 5f 61 64 64 72 20 3d 20 25 78 00 00    ader_addr = %x..
    0x8800340:   21 2a 2a 6f 74 61 68 65 61 64 65 72 5f 76 65 72    !**otaheader_ver
    0x8800350:   73 69 6f 6e 20 3d 20 25 78 00 00 00 21 2a 2a 70    sion = %x...!**p
    0x8800360:   61 74 63 68 5f 61 64 64 72 20 3d 20 25 78 00 00    atch_addr = %x..
    0x8800370:   21 2a 2a 70 61 74 63 68 5f 76 65 72 73 69 6f 6e    !**patch_version
    0x8800380:   20 3d 20 25 78 00 00 00 21 2a 2a 61 70 70 5f 61     = %x...!**app_a
    0x8800390:   64 64 72 20 3d 20 25 78 00 00 00 00 21 2a 2a 61    ddr = %x....!**a
    0x88003a0:   70 70 5f 76 65 72 73 69 6f 6e 20 3d 20 25 78 00    pp_version = %x.
    0x88003b0:   21 21 21 4f 54 41 53 65 72 76 69 63 65 5f 41 64    !!!OTAService_Ad
    0x88003c0:   64 53 65 72 76 69 63 65 3a 20 53 65 72 76 69 63    dService: Servic
    0x88003d0:   65 49 64 20 25 64 00 00 21 21 2a 6d 69 73 73 20    eId %d..!!*miss 
    0x88003e0:   69 6e 74 65 72 72 75 70 74 3a 20 70 65 6e 64 69    interrupt: pendi
    0x88003f0:   6e 67 20 72 65 67 69 73 74 65 72 3a 20 30 78 25    ng register: 0x%
    0x8800400:   78 00 00 00 21 2a 2a 6b 65 79 62 6f 61 72 64 5f    x...!**keyboard_
    0x8800410:   65 6e 74 65 72 5f 64 6c 70 73 5f 63 68 65 63 6b    enter_dlps_check
    0x8800420:   20 72 65 67 20 66 61 69 6c 21 00 00 21 21 21 73     reg fail!..!!!s
    0x8800430:   65 6e 64 5f 69 6f 5f 6d 73 67 5f 74 6f 5f 61 70    end_io_msg_to_ap
    0x8800440:   70 20 66 61 69 6c 00 00 21 21 21 73 65 6e 64 5f    p fail..!!!send_
    0x8800450:   65 76 74 5f 6d 73 67 5f 74 6f 5f 61 70 70 20 66    evt_msg_to_app f
    0x8800460:   61 69 6c 00 21 2a 2a 4b 65 79 53 63 61 6e 20 4d    ail.!**KeyScan M
    0x8800470:   53 47 2c 20 53 75 62 20 74 79 70 65 20 53 63 61    SG, Sub type Sca
    0x8800480:   6e 20 65 6e 64 2e 00 00 21 2a 2a 6b 65 79 73 63    n end...!**keysc
    0x8800490:   61 6e 20 74 72 69 67 67 65 72 20 61 64 76 2c 20    an trigger adv, 
    0x88004a0:   72 65 73 6f 6c 76 5f 6c 69 73 74 5f 65 78 69 73    resolv_list_exis
    0x88004b0:   74 20 3d 20 25 64 00 00 21 2a 2a 4b 65 79 53 63    t = %d..!**KeySc
    0x88004c0:   61 6e 20 4d 53 47 2c 20 53 75 62 20 74 79 70 65    an MSG, Sub type
    0x88004d0:   20 41 6c 6c 20 72 65 61 6c 73 65 2e 00 00 00 00     All realse.....
    0x88004e0:   21 2a 2a 61 70 70 5f 68 61 6e 64 6c 65 5f 64 65    !**app_handle_de
    0x88004f0:   76 5f 73 74 61 74 65 5f 65 76 74 3a 20 69 6e 69    v_state_evt: ini
    0x8800500:   74 20 73 74 61 74 65 20 25 64 2c 20 61 64 76 20    t state %d, adv 
    0x8800510:   73 74 61 74 65 20 25 64 2c 20 63 61 75 73 65 20    state %d, cause 
    0x8800520:   30 78 25 78 00 00 00 00 21 2a 2a 47 41 50 20 73    0x%x....!**GAP s
    0x8800530:   74 61 63 6b 20 72 65 61 64 79 00 00 21 2a 2a 47    tack ready..!**G
    0x8800540:   41 50 20 61 64 76 20 73 74 6f 70 65 64 3a 20 62    AP adv stoped: b
    0x8800550:   65 63 61 75 73 65 20 63 6f 6e 6e 65 63 74 69 6f    ecause connectio
    0x8800560:   6e 20 63 72 65 61 74 65 64 00 00 00 21 2a 2a 47    n created...!**G
    0x8800570:   41 50 20 61 64 76 20 73 74 6f 70 65 64 00 00 00    AP adv stoped...
    0x8800580:   21 2a 2a 47 41 50 20 61 64 76 20 73 74 61 72 74    !**GAP adv start
    0x8800590:   00 00 00 00 21 2a 2a 61 70 70 5f 68 61 6e 64 6c    ....!**app_handl
    0x88005a0:   65 5f 63 6f 6e 6e 5f 73 74 61 74 65 5f 65 76 74    e_conn_state_evt
    0x88005b0:   3a 20 63 6f 6e 6e 5f 69 64 20 25 64 20 6f 6c 64    : conn_id %d old
    0x88005c0:   5f 73 74 61 74 65 20 25 64 20 6e 65 77 5f 73 74    _state %d new_st
    0x88005d0:   61 74 65 20 25 64 2c 20 64 69 73 63 5f 63 61 75    ate %d, disc_cau
    0x88005e0:   73 65 20 30 78 25 78 00 21 21 21 61 70 70 5f 68    se 0x%x.!!!app_h
    0x88005f0:   61 6e 64 6c 65 5f 63 6f 6e 6e 5f 73 74 61 74 65    andle_conn_state
    0x8800600:   5f 65 76 74 3a 20 63 6f 6e 6e 65 63 74 69 6f 6e    _evt: connection
    0x8800610:   20 6c 6f 73 74 20 63 61 75 73 65 20 30 78 25 78     lost cause 0x%x
    0x8800620:   00 00 00 00 21 2a 2a 64 69 73 63 6f 6e 6e 65 63    ....!**disconnec
    0x8800630:   74 20 61 6e 64 20 73 74 61 72 74 20 61 64 76 00    t and start adv.
    0x8800640:   21 2a 2a 47 41 50 5f 43 4f 4e 4e 5f 53 54 41 54    !**GAP_CONN_STAT
    0x8800650:   45 5f 43 4f 4e 4e 45 43 54 45 44 3a 20 63 6f 6e    E_CONNECTED: con
    0x8800660:   6e 5f 69 6e 74 65 72 76 61 6c 20 30 78 25 78 2c    n_interval 0x%x,
    0x8800670:   20 63 6f 6e 6e 5f 6c 61 74 65 6e 63 79 20 30 78     conn_latency 0x
    0x8800680:   25 78 2c 20 63 6f 6e 6e 5f 73 75 70 65 72 76 69    %x, conn_supervi
    0x8800690:   73 69 6f 6e 5f 74 69 6d 65 6f 75 74 20 30 78 25    sion_timeout 0x%
    0x88006a0:   78 00 00 00 21 2a 2a 61 70 70 5f 68 61 6e 64 6c    x...!**app_handl
    0x88006b0:   65 5f 61 75 74 68 65 6e 5f 73 74 61 74 65 5f 65    e_authen_state_e
    0x88006c0:   76 74 3a 63 6f 6e 6e 5f 69 64 20 25 64 2c 20 63    vt:conn_id %d, c
    0x88006d0:   61 75 73 65 20 30 78 25 78 00 00 00 21 2a 2a 61    ause 0x%x...!**a
    0x88006e0:   70 70 5f 68 61 6e 64 6c 65 5f 61 75 74 68 65 6e    pp_handle_authen
    0x88006f0:   5f 73 74 61 74 65 5f 65 76 74 3a 20 47 41 50 5f    _state_evt: GAP_
    0x8800700:   41 55 54 48 45 4e 5f 53 54 41 54 45 5f 53 54 41    AUTHEN_STATE_STA
    0x8800710:   52 54 45 44 00 00 00 00 21 2a 2a 61 70 70 5f 68    RTED....!**app_h
    0x8800720:   61 6e 64 6c 65 5f 61 75 74 68 65 6e 5f 73 74 61    andle_authen_sta
    0x8800730:   74 65 5f 65 76 74 3a 20 47 41 50 5f 41 55 54 48    te_evt: GAP_AUTH
    0x8800740:   45 4e 5f 53 54 41 54 45 5f 43 4f 4d 50 4c 45 54    EN_STATE_COMPLET
    0x8800750:   45 20 70 61 69 72 20 73 75 63 63 65 73 73 00 00    E pair success..
    0x8800760:   21 2a 2a 61 70 70 5f 68 61 6e 64 6c 65 5f 61 75    !**app_handle_au
    0x8800770:   74 68 65 6e 5f 73 74 61 74 65 5f 65 76 74 3a 20    then_state_evt: 
    0x8800780:   47 41 50 5f 41 55 54 48 45 4e 5f 53 54 41 54 45    GAP_AUTHEN_STATE
    0x8800790:   5f 43 4f 4d 50 4c 45 54 45 20 70 61 69 72 20 66    _COMPLETE pair f
    0x88007a0:   61 69 6c 65 64 00 00 00 21 21 21 61 70 70 5f 68    ailed...!!!app_h
    0x88007b0:   61 6e 64 6c 65 5f 61 75 74 68 65 6e 5f 73 74 61    andle_authen_sta
    0x88007c0:   74 65 5f 65 76 74 3a 20 75 6e 6b 6e 6f 77 6e 20    te_evt: unknown 
    0x88007d0:   6e 65 77 73 74 61 74 65 20 25 64 00 21 2a 2a 61    newstate %d.!**a
    0x88007e0:   70 70 5f 68 61 6e 64 6c 65 5f 63 6f 6e 6e 5f 6d    pp_handle_conn_m
    0x88007f0:   74 75 5f 69 6e 66 6f 5f 65 76 74 3a 20 63 6f 6e    tu_info_evt: con
    0x8800800:   6e 5f 69 64 20 25 64 2c 20 6d 74 75 5f 73 69 7a    n_id %d, mtu_siz
    0x8800810:   65 20 25 64 00 00 00 00 21 2a 2a 61 70 70 5f 68    e %d....!**app_h
    0x8800820:   61 6e 64 6c 65 5f 63 6f 6e 6e 5f 70 61 72 61 6d    andle_conn_param
    0x8800830:   5f 75 70 64 61 74 65 5f 65 76 74 20 75 70 64 61    _update_evt upda
    0x8800840:   74 65 20 73 75 63 63 65 73 73 3a 63 6f 6e 6e 5f    te success:conn_
    0x8800850:   69 6e 74 65 72 76 61 6c 20 30 78 25 78 2c 20 63    interval 0x%x, c
    0x8800860:   6f 6e 6e 5f 73 6c 61 76 65 5f 6c 61 74 65 6e 63    onn_slave_latenc
    0x8800870:   79 20 30 78 25 78 2c 20 63 6f 6e 6e 5f 73 75 70    y 0x%x, conn_sup
    0x8800880:   65 72 76 69 73 69 6f 6e 5f 74 69 6d 65 6f 75 74    ervision_timeout
    0x8800890:   20 30 78 25 78 00 00 00 21 2a 2a 72 65 75 70 64     0x%x...!**reupd
    0x88008a0:   61 74 65 20 74 68 65 20 63 6f 6e 6e 65 63 74 69    ate the connecti
    0x88008b0:   6f 6e 20 70 61 72 61 6d 65 74 65 72 00 00 00 00    on parameter....
    0x88008c0:   21 2a 2a 73 74 6f 70 20 75 70 64 61 74 65 20 74    !**stop update t
    0x88008d0:   68 65 20 63 6f 6e 6e 65 63 74 69 6f 6e 20 70 61    he connection pa
    0x88008e0:   72 61 6d 65 74 65 72 00 21 21 21 61 70 70 5f 68    rameter.!!!app_h
    0x88008f0:   61 6e 64 6c 65 5f 63 6f 6e 6e 5f 70 61 72 61 6d    andle_conn_param
    0x8800900:   5f 75 70 64 61 74 65 5f 65 76 74 20 75 70 64 61    _update_evt upda
    0x8800910:   74 65 20 66 61 69 6c 65 64 3a 20 63 61 75 73 65    te failed: cause
    0x8800920:   20 30 78 25 78 00 00 00 21 2a 2a 61 70 70 5f 68     0x%x...!**app_h
    0x8800930:   61 6e 64 6c 65 5f 63 6f 6e 6e 5f 70 61 72 61 6d    andle_conn_param
    0x8800940:   5f 75 70 64 61 74 65 5f 65 76 74 20 75 70 64 61    _update_evt upda
    0x8800950:   74 65 20 70 65 6e 64 69 6e 67 2e 00 61 70 70 5f    te pending..app_
    0x8800960:   68 61 6e 64 6c 65 5f 67 61 70 5f 6d 73 67 3a 20    handle_gap_msg: 
    0x8800970:   73 75 62 74 79 70 65 20 25 64 00 00 21 2a 2a 47    subtype %d..!**G
    0x8800980:   41 50 5f 4d 53 47 5f 4c 45 5f 42 4f 4e 44 5f 4a    AP_MSG_LE_BOND_J
    0x8800990:   55 53 54 5f 57 4f 52 4b 00 00 00 00 21 2a 2a 47    UST_WORK....!**G
    0x88009a0:   41 50 5f 4d 53 47 5f 4c 45 5f 42 4f 4e 44 5f 50    AP_MSG_LE_BOND_P
    0x88009b0:   41 53 53 4b 45 59 5f 44 49 53 50 4c 41 59 3a 70    ASSKEY_DISPLAY:p
    0x88009c0:   61 73 73 6b 65 79 20 25 64 00 00 00 21 2a 2a 47    asskey %d...!**G
    0x88009d0:   41 50 5f 4d 53 47 5f 4c 45 5f 42 4f 4e 44 5f 55    AP_MSG_LE_BOND_U
    0x88009e0:   53 45 52 5f 43 4f 4e 46 49 52 4d 41 54 49 4f 4e    SER_CONFIRMATION
    0x88009f0:   3a 20 70 61 73 73 6b 65 79 20 25 64 00 00 00 00    : passkey %d....
    0x8800a00:   21 2a 2a 47 41 50 5f 4d 53 47 5f 4c 45 5f 42 4f    !**GAP_MSG_LE_BO
    0x8800a10:   4e 44 5f 50 41 53 53 4b 45 59 5f 49 4e 50 55 54    ND_PASSKEY_INPUT
    0x8800a20:   3a 20 63 6f 6e 6e 5f 69 64 20 25 64 00 00 00 00    : conn_id %d....
    0x8800a30:   21 2a 2a 47 41 50 5f 4d 53 47 5f 4c 45 5f 42 4f    !**GAP_MSG_LE_BO
    0x8800a40:   4e 44 5f 4f 4f 42 5f 49 4e 50 55 54 00 00 00 00    ND_OOB_INPUT....
    0x8800a50:   21 21 21 61 70 70 5f 68 61 6e 64 6c 65 5f 67 61    !!!app_handle_ga
    0x8800a60:   70 5f 6d 73 67 3a 20 75 6e 6b 6e 6f 77 6e 20 73    p_msg: unknown s
    0x8800a70:   75 62 74 79 70 65 20 25 64 00 00 00 21 2a 2a 47    ubtype %d...!**G
    0x8800a80:   41 50 5f 4d 53 47 5f 4c 45 5f 44 41 54 41 5f 4c    AP_MSG_LE_DATA_L
    0x8800a90:   45 4e 5f 43 48 41 4e 47 45 5f 49 4e 46 4f 3a 20    EN_CHANGE_INFO: 
    0x8800aa0:   63 6f 6e 6e 5f 69 64 20 25 64 2c 20 74 78 20 6f    conn_id %d, tx o
    0x8800ab0:   63 74 65 74 73 20 30 78 25 78 2c 20 6d 61 78 5f    ctets 0x%x, max_
    0x8800ac0:   74 78 5f 74 69 6d 65 20 30 78 25 78 00 00 00 00    tx_time 0x%x....
    0x8800ad0:   21 2a 2a 47 41 50 5f 4d 53 47 5f 4c 45 5f 4d 4f    !**GAP_MSG_LE_MO
    0x8800ae0:   44 49 46 59 5f 57 48 49 54 45 5f 4c 49 53 54 3a    DIFY_WHITE_LIST:
    0x8800af0:   20 6f 70 65 72 61 74 69 6f 6e 20 25 64 2c 20 63     operation %d, c
    0x8800b00:   61 75 73 65 20 30 78 25 78 00 00 00 21 2a 2a 47    ause 0x%x...!**G
    0x8800b10:   41 50 5f 4d 53 47 5f 4c 45 5f 42 4f 4e 44 5f 4d    AP_MSG_LE_BOND_M
    0x8800b20:   4f 44 49 46 59 5f 49 4e 46 4f 3a 20 74 79 70 65    ODIFY_INFO: type
    0x8800b30:   20 30 78 25 78 00 00 00 21 21 21 61 70 70 5f 67     0x%x...!!!app_g
    0x8800b40:   61 70 5f 63 61 6c 6c 62 61 63 6b 3a 20 75 6e 68    ap_callback: unh
    0x8800b50:   61 6e 64 6c 65 64 20 63 62 5f 74 79 70 65 20 30    andled cb_type 0
    0x8800b60:   78 25 78 00 21 2a 2a 50 52 4f 46 49 4c 45 5f 45    x%x.!**PROFILE_E
    0x8800b70:   56 54 5f 53 52 56 5f 52 45 47 5f 43 4f 4d 50 4c    VT_SRV_REG_COMPL
    0x8800b80:   45 54 45 3a 20 72 65 73 75 6c 74 20 25 64 00 00    ETE: result %d..
    0x8800b90:   21 2a 2a 50 52 4f 46 49 4c 45 5f 45 56 54 5f 53    !**PROFILE_EVT_S
    0x8800ba0:   45 4e 44 5f 44 41 54 41 5f 43 4f 4d 50 4c 45 54    END_DATA_COMPLET
    0x8800bb0:   45 3a 20 63 6f 6e 6e 5f 69 64 20 25 64 2c 20 63    E: conn_id %d, c
    0x8800bc0:   61 75 73 65 20 30 78 25 78 2c 20 73 65 72 76 69    ause 0x%x, servi
    0x8800bd0:   63 65 5f 69 64 20 25 64 2c 20 61 74 74 72 69 62    ce_id %d, attrib
    0x8800be0:   5f 69 64 78 20 30 78 25 78 2c 20 63 72 65 64 69    _idx 0x%x, credi
    0x8800bf0:   74 73 20 25 64 00 00 00 21 2a 2a 50 52 4f 46 49    ts %d...!**PROFI
    0x8800c00:   4c 45 5f 45 56 54 5f 53 45 4e 44 5f 44 41 54 41    LE_EVT_SEND_DATA
    0x8800c10:   5f 43 4f 4d 50 4c 45 54 45 20 73 75 63 63 65 73    _COMPLETE succes
    0x8800c20:   73 00 00 00 21 21 21 50 52 4f 46 49 4c 45 5f 45    s...!!!PROFILE_E
    0x8800c30:   56 54 5f 53 45 4e 44 5f 44 41 54 41 5f 43 4f 4d    VT_SEND_DATA_COM
    0x8800c40:   50 4c 45 54 45 20 66 61 69 6c 65 64 00 00 00 00    PLETE failed....
    0x8800c50:   21 2a 2a 48 49 44 5f 57 52 49 54 45 5f 50 52 4f    !**HID_WRITE_PRO
    0x8800c60:   54 4f 43 4f 4c 20 4d 4f 44 45 20 25 64 0a 00 00    TOCOL MODE %d...
    0x8800c70:   21 2a 2a 48 49 44 5f 4f 55 54 50 55 54 20 76 61    !**HID_OUTPUT va
    0x8800c80:   6c 75 65 20 25 64 0a 00 21 2a 2a 42 41 53 5f 4e    lue %d..!**BAS_N
    0x8800c90:   4f 54 49 46 59 5f 42 41 54 54 45 52 59 5f 4c 45    OTIFY_BATTERY_LE
    0x8800ca0:   56 45 4c 5f 45 4e 41 42 4c 45 00 00 21 2a 2a 42    VEL_ENABLE..!**B
    0x8800cb0:   41 53 5f 4e 4f 54 49 46 59 5f 42 41 54 54 45 52    AS_NOTIFY_BATTER
    0x8800cc0:   59 5f 4c 45 56 45 4c 5f 44 49 53 41 42 4c 45 00    Y_LEVEL_DISABLE.
    0x8800cd0:   21 2a 2a 42 41 53 5f 52 45 41 44 5f 42 41 54 54    !**BAS_READ_BATT
    0x8800ce0:   45 52 59 5f 4c 45 56 45 4c 3a 20 62 61 74 74 65    ERY_LEVEL: batte
    0x8800cf0:   72 79 5f 6c 65 76 65 6c 20 25 64 00 21 2a 2a 50    ry_level %d.!**P
    0x8800d00:   72 65 70 61 72 69 6e 67 20 73 77 69 74 63 68 20    reparing switch 
    0x8800d10:   69 6e 74 6f 20 4f 54 41 20 6d 6f 64 65 0a 00 00    into OTA mode...
    0x8800d20:   21 2a 2a 5b 6b 65 79 73 63 61 6e 5f 69 6e 69 74    !**[keyscan_init
    0x8800d30:   5f 64 61 74 61 5d 20 69 6e 69 74 20 64 61 74 61    _data] init data
    0x8800d40:   00 00 00 00 21 2a 2a 5b 6b 65 79 73 63 61 6e 5f    ....!**[keyscan_
    0x8800d50:   69 6e 74 65 72 72 75 70 74 5f 68 61 6e 64 6c 65    interrupt_handle
    0x8800d60:   72 5d 20 69 6e 74 65 72 72 75 70 74 20 68 61 6e    r] interrupt han
    0x8800d70:   64 6c 65 72 00 00 00 00 21 21 21 5b 6b 65 79 73    dler....!!![keys
    0x8800d80:   63 61 6e 5f 69 6e 74 65 72 72 75 70 74 5f 68 61    can_interrupt_ha
    0x8800d90:   6e 64 6c 65 72 5d 20 72 65 73 74 61 72 74 20 78    ndler] restart x
    0x8800da0:   54 69 6d 65 72 73 4b 65 79 53 63 61 6e 20 66 61    TimersKeyScan fa
    0x8800db0:   69 6c 65 64 21 00 00 00 21 21 21 5b 6b 65 79 73    iled!...!!![keys
    0x8800dc0:   63 61 6e 5f 69 6e 74 65 72 72 75 70 74 5f 68 61    can_interrupt_ha
    0x8800dd0:   6e 64 6c 65 72 5d 20 73 65 6e 64 20 49 4f 5f 4d    ndler] send IO_M
    0x8800de0:   53 47 5f 4b 45 59 53 43 41 4e 5f 52 58 5f 50 4b    SG_KEYSCAN_RX_PK
    0x8800df0:   54 20 6d 65 73 73 61 67 65 20 66 61 69 6c 65 64    T message failed
    0x8800e00:   21 00 00 00 21 2a 2a 5b 6b 65 79 73 63 61 6e 5f    !...!**[keyscan_
    0x8800e10:   69 6e 74 65 72 72 75 70 74 5f 68 61 6e 64 6c 65    interrupt_handle
    0x8800e20:   72 5d 20 6b 65 79 73 63 61 6e 20 72 65 6c 65 61    r] keyscan relea
    0x8800e30:   73 65 20 65 76 65 6e 74 20 64 65 74 65 63 74 65    se event detecte
    0x8800e40:   64 00 00 00 21 21 21 5b 6b 65 79 73 63 61 6e 5f    d...!!![keyscan_
    0x8800e50:   69 6e 74 65 72 72 75 70 74 5f 68 61 6e 64 6c 65    interrupt_handle
    0x8800e60:   72 5d 20 53 65 6e 64 20 49 4f 5f 4d 53 47 5f 54    r] Send IO_MSG_T
    0x8800e70:   59 50 45 5f 4b 45 59 53 43 41 4e 20 6d 65 73 73    YPE_KEYSCAN mess
    0x8800e80:   61 67 65 20 66 61 69 6c 65 64 21 00 21 2a 2a 5b    age failed!.!**[
    0x8800e90:   6b 65 79 73 63 61 6e 5f 69 6e 74 65 72 72 75 70    keyscan_interrup
    0x8800ea0:   74 5f 68 61 6e 64 6c 65 72 5d 20 69 66 20 73 79    t_handler] if sy
    0x8800eb0:   73 74 65 6d 20 61 63 74 69 76 65 2c 20 6b 65 79    stem active, key
    0x8800ec0:   73 63 61 6e 20 6e 6f 20 64 65 62 6f 75 6e 63 65    scan no debounce
    0x8800ed0:   20 63 61 6e 20 61 72 72 69 76 65 20 68 65 72 65     can arrive here
    0x8800ee0:   00 00 00 00 21 2a 2a 5b 6b 65 79 73 63 61 6e 5f    ....!**[keyscan_
    0x8800ef0:   69 6e 74 65 72 72 75 70 74 5f 68 61 6e 64 6c 65    interrupt_handle
    0x8800f00:   72 5d 20 6e 6f 74 20 4b 45 59 53 43 41 4e 5f 49    r] not KEYSCAN_I
    0x8800f10:   4e 54 5f 46 4c 41 47 5f 53 43 41 4e 5f 45 4e 44    NT_FLAG_SCAN_END
    0x8800f20:   20 69 6e 74 65 72 72 75 70 74 00 00 21 2a 2a 5b     interrupt..!**[
    0x8800f30:   6b 65 79 73 63 61 6e 5f 69 6e 69 74 5f 74 69 6d    keyscan_init_tim
    0x8800f40:   65 72 5d 20 69 6e 69 74 20 74 69 6d 65 72 00 00    er] init timer..
    0x8800f50:   21 21 21 5b 6b 65 79 73 63 61 6e 5f 69 6e 69 74    !!![keyscan_init
    0x8800f60:   5f 74 69 6d 65 72 5d 20 74 69 6d 65 72 20 63 72    _timer] timer cr
    0x8800f70:   65 61 74 20 66 61 69 6c 65 64 21 00 21 2a 2a 5b    eat failed!.!**[
    0x8800f80:   6b 65 79 73 63 61 6e 5f 74 69 6d 65 72 5f 63 61    keyscan_timer_ca
    0x8800f90:   6c 6c 62 61 63 6b 5d 20 73 74 61 72 74 20 72 65    llback] start re
    0x8800fa0:   6c 65 61 73 65 20 74 69 6d 65 72 00 21 2a 2a 5b    lease timer.!**[
    0x8800fb0:   6b 65 79 73 63 61 6e 5f 74 69 6d 65 72 5f 63 61    keyscan_timer_ca
    0x8800fc0:   6c 6c 62 61 63 6b 5d 20 6b 65 79 73 63 61 6e 20    llback] keyscan 
    0x8800fd0:   72 65 6c 65 61 73 65 20 65 76 65 6e 74 20 64 65    release event de
    0x8800fe0:   74 65 63 74 65 64 00 00 21 21 21 5b 6b 65 79 73    tected..!!![keys
    0x8800ff0:   63 61 6e 5f 74 69 6d 65 72 5f 63 61 6c 6c 62 61    can_timer_callba
    0x8801000:   63 6b 5d 20 53 65 6e 64 20 49 4f 5f 4d 53 47 5f    ck] Send IO_MSG_
    0x8801010:   54 59 50 45 5f 4b 45 59 53 43 41 4e 20 6d 65 73    TYPE_KEYSCAN mes
    0x8801020:   73 61 67 65 20 66 61 69 6c 65 64 21 00 00 00 00    sage failed!....
    0x8801030:   21 2a 2a 77 61 6b 65 20 75 70 20 62 79 20 6b 65    !**wake up by ke
    0x8801040:   79 73 63 61 6e 2c 20 70 69 6e 20 3d 30 78 25 78    yscan, pin =0x%x
    0x8801050:   2c 20 67 70 69 6f 20 69 6e 70 75 74 20 3d 20 30    , gpio input = 0
    0x8801060:   78 25 78 00 21 21 21 5b 53 79 73 74 65 6d 5f 48    x%x.!!![System_H
    0x8801070:   61 6e 64 6c 65 72 5d 20 78 54 69 6d 65 72 73 4b    andler] xTimersK
    0x8801080:   65 79 53 63 61 6e 20 72 65 73 74 61 72 74 20 66    eyScan restart f
    0x8801090:   61 69 6c 65 64 21 00 00 21 2a 2a 4e 6f 2e 25 64    ailed!..!**No.%d
    0x88010a0:   2c 54 6f 74 61 6c 20 6c 65 6e 3d 25 64 3a 20 28    ,Total len=%d: (
    0x88010b0:   72 6f 77 2c 20 63 6f 6c 75 6d 6e 29 20 3d 20 28    row, column) = (
    0x88010c0:   25 64 2c 20 25 64 29 00 21 2a 2a 70 61 73 73 4b    %d, %d).!**passK
    0x88010d0:   65 79 20 3d 20 4b 42 5f 30 00 00 00 21 2a 2a 70    ey = KB_0...!**p
    0x88010e0:   61 73 73 4b 65 79 20 3d 20 4b 42 5f 31 00 00 00    assKey = KB_1...
    0x88010f0:   21 2a 2a 70 61 73 73 4b 65 79 20 3d 20 4b 42 5f    !**passKey = KB_
    0x8801100:   32 00 00 00 21 2a 2a 70 61 73 73 4b 65 79 20 3d    2...!**passKey =
    0x8801110:   20 4b 42 5f 33 00 00 00 21 2a 2a 70 61 73 73 4b     KB_3...!**passK
    0x8801120:   65 79 20 3d 20 4b 42 5f 34 00 00 00 21 2a 2a 70    ey = KB_4...!**p
    0x8801130:   61 73 73 4b 65 79 20 3d 20 4b 42 5f 35 00 00 00    assKey = KB_5...
    0x8801140:   21 2a 2a 70 61 73 73 4b 65 79 20 3d 20 4b 42 5f    !**passKey = KB_
    0x8801150:   36 00 00 00 21 2a 2a 70 61 73 73 4b 65 79 20 3d    6...!**passKey =
    0x8801160:   20 4b 42 5f 37 00 00 00 21 2a 2a 70 61 73 73 4b     KB_7...!**passK
    0x8801170:   65 79 20 3d 20 4b 42 5f 38 00 00 00 21 2a 2a 70    ey = KB_8...!**p
    0x8801180:   61 73 73 4b 65 79 20 3d 20 4b 42 5f 39 00 00 00    assKey = KB_9...
    0x8801190:   21 2a 2a 70 61 73 73 4b 65 79 20 3d 20 4b 42 5f    !**passKey = KB_
    0x88011a0:   52 65 74 75 72 6e 5f 45 4e 54 45 52 0a 0a 00 00    Return_ENTER....
    0x88011b0:   21 2a 2a 70 61 73 73 4b 65 79 20 3d 20 25 64 00    !**passKey = %d.
    0x88011c0:   21 21 21 45 72 72 6f 72 3a 20 54 68 65 20 70 61    !!!Error: The pa
    0x88011d0:   73 73 6b 65 79 20 6c 65 6e 67 74 68 20 69 73 20    sskey length is 
    0x88011e0:   6e 6f 74 20 65 71 75 61 6c 20 74 6f 20 73 69 78    not equal to six
    0x88011f0:   2c 20 70 6c 65 61 73 65 20 69 6e 70 75 74 20 61    , please input a
    0x8801200:   67 61 69 6e 2e 0a 00 00 21 2a 2a 44 65 6c 65 74    gain....!**Delet
    0x8801210:   65 20 74 68 65 20 6c 61 73 74 20 69 6e 70 75 74    e the last input
    0x8801220:   20 6b 65 79 20 76 61 6c 75 65 00 00 21 21 21 49     key value..!!!I
    0x8801230:   6e 76 61 6c 69 64 20 50 61 73 73 6b 65 79 20 6b    nvalid Passkey k
    0x8801240:   65 79 43 6f 64 65 3a 20 30 78 25 78 0a 0a 00 00    eyCode: 0x%x....
    0x8801250:   21 2a 2a 4e 6f 2e 25 64 2c 54 6f 74 61 6c 20 6c    !**No.%d,Total l
    0x8801260:   65 6e 3d 25 64 3a 20 28 72 6f 77 2c 20 63 6f 6c    en=%d: (row, col
    0x8801270:   75 6d 6e 29 20 3d 20 28 25 64 2c 20 25 64 29 00    umn) = (%d, %d).
    0x8801280:   21 2a 2a 50 61 69 72 20 62 75 74 74 6f 6e 20 6c    !**Pair button l
    0x8801290:   6f 6e 67 70 72 65 73 73 20 21 21 21 00 00 00 00    ongpress !!!....
    0x88012a0:   21 2a 2a 50 61 69 72 20 62 75 74 74 6f 6e 20 72    !**Pair button r
    0x88012b0:   65 6c 65 61 73 65 20 21 21 21 00 00 21 2a 2a 50    elease !!!..!**P
    0x88012c0:   61 69 72 20 62 75 74 74 6f 6e 20 70 72 65 73 73    air button press
    0x88012d0:   20 21 21 21 00 00 00 00 21 2a 2a 41 44 56 20 74     !!!....!**ADV t
    0x88012e0:   69 6d 65 6f 75 74 2c 20 73 74 6f 70 20 20 72 65    imeout, stop  re
    0x88012f0:   63 6f 6e 6e 65 63 74 20 41 44 56 00 21 2a 2a 41    connect ADV.!**A
    0x8801300:   44 56 20 74 69 6d 65 6f 75 74 2c 20 73 74 6f 70    DV timeout, stop
    0x8801310:   20 70 61 69 72 20 41 44 56 00 00 00 21 2a 2a 63     pair ADV...!**c
    0x8801320:   6f 6e 6e 65 63 74 69 6f 6e 20 70 61 72 61 6d 65    onnection parame
    0x8801330:   74 65 72 20 75 70 64 61 74 65 20 63 61 6c 6c 62    ter update callb
    0x8801340:   61 63 6b 21 00 00 00 00 21 2a 2a 63 6f 6e 6e 65    ack!....!**conne
    0x8801350:   63 74 69 6f 6e 20 70 61 72 61 6d 65 74 65 72 20    ction parameter 
    0x8801360:   75 70 64 61 74 65 20 72 65 71 75 65 73 74 21 00    update request!.
    0x8801370:   21 2a 2a 54 5f 47 41 50 5f 52 45 53 4f 4c 56 5f    !**T_GAP_RESOLV_
    0x8801380:   4c 49 53 54 5f 4f 50 20 25 64 2c 20 42 44 20 25    LIST_OP %d, BD %
    0x8801390:   73 2c 20 74 79 70 65 20 25 64 0a 00 21 2a 2a 72    s, type %d..!**r
    0x88013a0:   65 73 6f 6c 76 69 6e 67 20 6c 69 73 74 20 63 6c    esolving list cl
    0x88013b0:   65 61 72 00 21 21 21 63 6c 65 61 72 20 66 61 69    ear.!!!clear fai
    0x88013c0:   6c 65 64 3a 20 63 61 75 73 65 20 25 64 00 00 00    led: cause %d...
    0x88013d0:   21 2a 2a 72 65 73 6f 6c 76 69 6e 67 20 6c 69 73    !**resolving lis
    0x88013e0:   74 20 61 64 64 00 00 00 21 21 21 41 64 64 20 66    t add...!!!Add f
    0x88013f0:   61 69 6c 65 64 3a 20 63 61 75 73 65 20 25 64 00    ailed: cause %d.
    0x8801400:   21 21 21 41 64 64 20 66 61 69 6c 65 64 3a 20 69    !!!Add failed: i
    0x8801410:   6e 76 61 6c 69 64 20 73 74 61 74 65 00 00 00 00    nvalid state....
    0x8801420:   21 2a 2a 72 65 73 6f 6c 76 69 6e 67 20 6c 69 73    !**resolving lis
    0x8801430:   74 20 72 65 6d 6f 76 65 00 00 00 00 21 21 21 52    t remove....!!!R
    0x8801440:   65 6d 6f 76 65 20 66 61 69 6c 65 64 3a 20 63 61    emove failed: ca
    0x8801450:   75 73 65 20 25 64 00 00 21 21 21 52 65 6d 6f 76    use %d..!!!Remov
    0x8801460:   65 20 66 61 69 6c 65 64 3a 20 69 6e 76 61 6c 69    e failed: invali
    0x8801470:   64 20 73 74 61 74 65 00 21 2a 2a 70 72 69 76 61    d state.!**priva
    0x8801480:   63 79 5f 61 64 64 5f 64 65 76 69 63 65 3a 20 70    cy_add_device: p
    0x8801490:   5f 65 6e 74 72 79 2d 3e 69 73 5f 75 73 65 64 20    _entry->is_used 
    0x88014a0:   3d 20 25 64 00 00 00 00 21 2a 2a 70 72 69 76 61    = %d....!**priva
    0x88014b0:   63 79 5f 61 64 64 5f 64 65 76 69 63 65 3a 20 4c    cy_add_device: L
    0x88014c0:   45 5f 4b 45 59 5f 53 54 4f 52 45 5f 52 45 4d 4f    E_KEY_STORE_REMO
    0x88014d0:   54 45 5f 49 52 4b 5f 42 49 54 00 00 21 2a 2a 70    TE_IRK_BIT..!**p
    0x88014e0:   72 69 76 61 63 79 5f 61 64 64 5f 64 65 76 69 63    rivacy_add_devic
    0x88014f0:   65 3a 20 47 41 50 5f 52 45 4d 4f 54 45 5f 41 44    e: GAP_REMOTE_AD
    0x8801500:   44 52 5f 4c 45 5f 50 55 42 4c 49 43 00 00 00 00    DR_LE_PUBLIC....
    0x8801510:   21 21 21 70 72 69 76 61 63 79 5f 61 64 64 5f 64    !!!privacy_add_d
    0x8801520:   65 76 69 63 65 3a 20 66 61 69 6c 65 64 2c 20 69    evice: failed, i
    0x8801530:   64 78 20 25 64 00 00 00 21 2a 2a 70 72 69 76 61    dx %d...!**priva
    0x8801540:   63 79 5f 69 6e 69 74 3a 20 77 68 69 74 65 6c 69    cy_init: whiteli
    0x8801550:   73 74 20 25 64 00 00 00 21 2a 2a 70 72 69 76 61    st %d...!**priva
    0x8801560:   63 79 5f 68 61 6e 64 6c 65 5f 6c 65 5f 70 72 69    cy_handle_le_pri
    0x8801570:   76 61 63 79 5f 72 65 73 6f 6c 75 74 69 6f 6e 5f    vacy_resolution_
    0x8801580:   73 74 61 74 75 73 5f 69 6e 66 6f 3a 20 73 74 61    status_info: sta
    0x8801590:   74 75 73 20 30 78 25 78 0a 00 00 00 21 2a 2a 70    tus 0x%x....!**p
    0x88015a0:   72 69 76 61 63 79 5f 68 61 6e 64 6c 65 5f 6c 65    rivacy_handle_le
    0x88015b0:   5f 70 72 69 76 61 63 79 5f 6d 6f 64 69 66 79 5f    _privacy_modify_
    0x88015c0:   72 65 73 6f 6c 76 5f 6c 69 73 74 5f 72 73 70 3a    resolv_list_rsp:
    0x88015d0:   20 6f 70 65 72 61 74 69 6f 6e 20 20 30 78 25 78     operation  0x%x
    0x88015e0:   2c 20 63 61 73 75 65 20 30 78 25 78 00 00 00 00    , casue 0x%x....
    0x88015f0:   21 2a 2a 70 72 69 76 61 63 79 5f 6d 73 67 5f 63    !**privacy_msg_c
    0x8801600:   61 6c 6c 62 61 63 6b 3a 20 6d 73 67 5f 74 79 70    allback: msg_typ
    0x8801610:   65 20 20 25 64 00 00 00 21 2a 2a 70 72 69 76 61    e  %d...!**priva
    0x8801620:   63 79 5f 68 61 6e 64 6c 65 5f 62 6f 6e 64 5f 6d    cy_handle_bond_m
    0x8801630:   6f 64 69 66 79 5f 6d 73 67 3a 20 74 79 70 65 20    odify_msg: type 
    0x8801640:   30 78 25 78 00 00 00 00 21 21 21 67 61 70 5f 6c    0x%x....!!!gap_l
    0x8801650:   69 62 5f 69 6e 69 74 3a 20 76 65 72 20 25 64 2c    ib_init: ver %d,
    0x8801660:   20 46 5f 42 54 5f 4c 45 5f 35 5f 30 5f 53 55 50     F_BT_LE_5_0_SUP
    0x8801670:   50 4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 4c 45    PORT %d, F_BT_LE
    0x8801680:   5f 35 5f 30 5f 41 45 5f 41 44 56 5f 53 55 50 50    _5_0_AE_ADV_SUPP
    0x8801690:   4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 4c 45 5f    ORT %d, F_BT_LE_
    0x88016a0:   35 5f 30 5f 41 45 5f 53 43 41 4e 5f 53 55 50 50    5_0_AE_SCAN_SUPP
    0x88016b0:   4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 4c 45 5f    ORT %d, F_BT_LE_
    0x88016c0:   34 5f 31 5f 53 55 50 50 4f 52 54 20 25 64 2c 20    4_1_SUPPORT %d, 
    0x88016d0:   46 5f 42 54 5f 56 45 4e 44 4f 52 5f 46 45 41 54    F_BT_VENDOR_FEAT
    0x88016e0:   55 52 45 5f 53 55 50 50 4f 52 54 20 25 64 2c 20    URE_SUPPORT %d, 
    0x88016f0:   46 5f 42 54 5f 4c 45 5f 36 5f 30 5f 41 4f 41 5f    F_BT_LE_6_0_AOA_
    0x8801700:   41 4f 44 5f 53 55 50 50 4f 52 54 20 25 64 2c 20    AOD_SUPPORT %d, 
    0x8801710:   46 5f 42 54 5f 4c 45 5f 36 5f 30 5f 41 4f 58 5f    F_BT_LE_6_0_AOX_
    0x8801720:   43 4f 4e 4e 4c 45 53 53 5f 53 55 50 50 4f 52 54    CONNLESS_SUPPORT
    0x8801730:   20 25 64 00 21 21 21 67 61 70 5f 6c 69 62 5f 69     %d.!!!gap_lib_i
    0x8801740:   6e 69 74 3a 20 46 5f 42 54 5f 4c 45 5f 53 4d 50    nit: F_BT_LE_SMP
    0x8801750:   5f 53 43 5f 4f 4f 42 5f 53 55 50 50 4f 52 54 20    _SC_OOB_SUPPORT 
    0x8801760:   25 64 2c 20 46 5f 42 54 5f 53 57 5f 52 45 53 45    %d, F_BT_SW_RESE
    0x8801770:   54 5f 53 55 50 50 4f 52 54 20 25 64 2c 20 46 5f    T_SUPPORT %d, F_
    0x8801780:   42 54 5f 50 41 54 43 48 5f 46 4f 52 5f 43 48 41    BT_PATCH_FOR_CHA
    0x8801790:   4e 47 45 5f 41 50 49 20 25 64 2c 20 46 5f 42 54    NGE_API %d, F_BT
    0x88017a0:   5f 44 4c 50 53 5f 41 50 49 20 25 64 00 00 00 00    _DLPS_API %d....
    0x88017b0:   21 2a 2a 6c 65 5f 63 68 65 63 6b 5f 70 72 69 76    !**le_check_priv
    0x88017c0:   61 63 79 5f 62 6f 6e 64 3a 20 69 64 78 20 25 64    acy_bond: idx %d
    0x88017d0:   20 70 72 69 76 61 63 79 20 64 65 76 69 63 65 00     privacy device.
    0x88017e0:   21 2a 2a 6c 65 5f 63 68 65 63 6b 5f 70 72 69 76    !**le_check_priv
    0x88017f0:   61 63 79 5f 62 6f 6e 64 3a 20 6e 6f 74 20 70 72    acy_bond: not pr
    0x8801800:   69 76 61 63 79 20 64 65 76 69 63 65 2c 20 63 61    ivacy device, ca
    0x8801810:   75 73 65 20 25 64 00 00 21 2a 2a 6c 65 5f 62 6f    use %d..!**le_bo
    0x8801820:   6e 64 5f 67 65 74 5f 73 65 63 5f 6c 65 76 65 6c    nd_get_sec_level
    0x8801830:   3a 20 25 64 00 00 00 00                            : %d....


** Section #10 '.debug_abbrev' (SHT_PROGBITS)
    Size   : 1476 bytes


** Section #11 '.debug_frame' (SHT_PROGBITS)
    Size   : 5096 bytes


** Section #12 '.debug_info' (SHT_PROGBITS)
    Size   : 169076 bytes


** Section #13 '.debug_line' (SHT_PROGBITS)
    Size   : 26760 bytes


** Section #14 '.debug_loc' (SHT_PROGBITS)
    Size   : 11816 bytes


** Section #15 '.debug_macinfo' (SHT_PROGBITS)
    Size   : 128656 bytes


** Section #16 '.debug_pubnames' (SHT_PROGBITS)
    Size   : 7351 bytes


** Section #17 '.symtab' (SHT_SYMTAB)
    Size   : 22416 bytes (alignment 4)
    String table #18 '.strtab'
    Last local symbol no. 575


** Section #18 '.strtab' (SHT_STRTAB)
    Size   : 19712 bytes


** Section #19 '.note' (SHT_NOTE)
    Size   : 52 bytes (alignment 4)


** Section #20 '.comment' (SHT_PROGBITS)
    Size   : 26200 bytes


** Section #21 '.shstrtab' (SHT_STRTAB)
    Size   : 276 bytes


address     size       variable name                            type
0x0020ba68  0x6c       overlay_sections                         array[3] of T_OVERLAY_SECTION

address     size       variable name                            type
0x0020bce2  0x8        scenario_name                            array[8] of char

address     size       variable name                            type
0x0020bce1  0x1        app_privacy_resolution_state             T_LE_PRIVACY_STATE

address     size       variable name                            type
0x0020bce0  0x1        privacy_whitelist                        _Bool

address     size       variable name                            type
0x0020bcdc  0x4        con_update_timer                         pointer to unknown Type 

address     size       variable name                            type
0x0020bcd6  0x1        adv_count                                uint8_t

address     size       variable name                            type
0x0020bcd4  0x1        adv_led_on                               _Bool

address     size       variable name                            type
0x0020bcd8  0x4        adv_led_timer                            pointer to unknown Type 

address     size       variable name                            type
0x0020bcd5  0x1        adv_reconnect                            _Bool

address     size       variable name                            type
0x0020bcd0  0x4        longpress_timer                          pointer to unknown Type 

address     size       variable name                            type
0x0020bccd  0x1        pair_press                               _Bool

address     size       variable name                            type
0x0020bccc  0x1        start_pair_adv                           _Bool

address     size       variable name                            type
0x0020b7d6  0x20       key_map                                  array[4] of array[4] of const uint16_t

address     size       variable name                            type
0x0020bcc4  0x8        passkey                                  PASSKEY_DEF
0x0020bcc4  0x4        passkey.value                            uint32_t
0x0020bcc8  0x1        passkey.count                            uint8_t
0x0020bcc9  0x1        passkey.enable_input                     _Bool

address     size       variable name                            type
0x0020bc98  0x2c       keyscan_global_data                      T_KEYSCAN_GLOBAL_DATA
0x0020bc98  0x1        keyscan_global_data.is_allowed_to_repeat_report _Bool
0x0020bc99  0x1        keyscan_global_data.is_allowed_to_enter_dlps _Bool
0x0020bc9a  0x1        keyscan_global_data.is_key_pressed       _Bool
0x0020bc9b  0x1        keyscan_global_data.is_all_key_released  _Bool
0x0020bc9c  0x14       keyscan_global_data.pre_fifo_data        T_KEYSCAN_FIFIO_DATA
0x0020bc9c  0x4        keyscan_global_data.pre_fifo_data.len    uint32_t
0x0020bca0  0x10       keyscan_global_data.pre_fifo_data.key    array[8] of anonymous
0x0020bcb0  0x14       keyscan_global_data.cur_fifo_data        T_KEYSCAN_FIFIO_DATA
0x0020bcb0  0x4        keyscan_global_data.cur_fifo_data.len    uint32_t
0x0020bcb4  0x10       keyscan_global_data.cur_fifo_data.key    array[8] of anonymous

address     size       variable name                            type
0x0020bc94  0x4        keyscan_timer                            pointer to unknown Type 

address     size       variable name                            type
0x0020bc8e  0x1        bas_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x0020bc91  0x1        dis_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x0020bc89  0x1        gap_conn_state                           T_GAP_CONN_STATE

address     size       variable name                            type
0x0020bc88  0x1        gap_dev_state                            T_GAP_DEV_STATE
0x0020bc88  0x1(7:1)   gap_dev_state.gap_init_state             uint8_t
0x0020bc88  0x1(6:1)   gap_dev_state.gap_adv_sub_state          uint8_t
0x0020bc88  0x1(4:2)   gap_dev_state.gap_adv_state              uint8_t
0x0020bc88  0x1(2:2)   gap_dev_state.gap_scan_state             uint8_t
0x0020bc88  0x1(0:2)   gap_dev_state.gap_conn_state             uint8_t

address     size       variable name                            type
0x0020bc8d  0x1        hid_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x0020bc90  0x1        keyboard_con_id                          uint8_t

address     size       variable name                            type
0x0020bc8f  0x1        ota_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x0020bc8b  0x1        report_cccd_enable                       _Bool

address     size       variable name                            type
0x0020bc8c  0x1        resolv_list_exist                        _Bool

address     size       variable name                            type
0x0020bc8a  0x1        switch_into_ota_pending                  _Bool

address     size       variable name                            type
0x0020bc7c  0x4        app_task_handle                          pointer to unknown Type 

address     size       variable name                            type
0x0020bc80  0x4        evt_queue_handle                         pointer to unknown Type 

address     size       variable name                            type
0x0020bc84  0x4        io_queue_handle                          pointer to unknown Type 

address     size       variable name                            type
0x0020b770  0x15       adv_data                                 array[21] of const uint8_t

address     size       variable name                            type
0x0020b76c  0x4        scan_rsp_data                            array[4] of const uint8_t

address     size       variable name                            type
0x0020bbac  0x84       CPU_StoreReg                             array[33] of uint32_t

address     size       variable name                            type
0x0020bc58  0x24       GPIO_StoreReg                            array[9] of uint32_t

address     size       variable name                            type
0x0020bba0  0x4        PeriIntStoreReg                          uint32_t

address     size       variable name                            type
0x0020bc30  0x28       Pinmux_StoreReg                          array[10] of uint32_t

address     size       variable name                            type
0x0020bba8  0x4        User_IO_EnterDlpsCB                      DLPS_IO_EnterDlpsCB

address     size       variable name                            type
0x0020bba4  0x4        User_IO_ExitDlpsCB                       DLPS_IO_ExitDlpsCB

address     size       variable name                            type
0x0020b53c  0x10       GATT_UUID_OTA_SERVICE                    array[16] of const uint8_t

address     size       variable name                            type
0x0020b760  0xc        OTAServiceCBs                            const T_FUN_GATT_SERVICE_CBS
0x0020b760  0x4        OTAServiceCBs.read_attr_cb               P_FUN_GATT_READ_ATTR_CB
0x0020b764  0x4        OTAServiceCBs.write_attr_cb              P_FUN_GATT_WRITE_ATTR_CB
0x0020b768  0x4        OTAServiceCBs.cccd_update_cb             P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x0020bb74  0x4        app_version                              uint32_t

address     size       variable name                            type
0x0020b54c  0x214      gattOtaServiceTable                      array[19] of const T_ATTRIB_APPL

address     size       variable name                            type
0x0020bb78  0x6        mac_addr                                 array[6] of uint8_t

address     size       variable name                            type
0x00000000  0x1        ota_update_bank_num                      uint8_t

address     size       variable name                            type
0x00000000  0x4        patch_ext_version                        uint32_t

address     size       variable name                            type
0x0020bb70  0x4        patch_version                            uint32_t

address     size       variable name                            type
0x0020bb6c  0x4        pfnOTAExtendedCB                         P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x0020b31c  0x214      dis_attr_tbl                             array[19] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00000000  0x2        dis_attr_tbl_size                        const uint16_t

address     size       variable name                            type
0x0020b530  0xc        dis_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x0020b530  0x4        dis_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x0020b534  0x4        dis_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x0020b538  0x4        dis_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x0020bb44  0x14       dis_firmware_rev                         array[20] of uint8_t

address     size       variable name                            type
0x0020baec  0x1        dis_firmware_rev_len                     uint8_t

address     size       variable name                            type
0x0020bb30  0x14       dis_hardware_rev                         array[20] of uint8_t

address     size       variable name                            type
0x0020baeb  0x1        dis_hardware_rev_len                     uint8_t

address     size       variable name                            type
0x0020ba4a  0x1e       dis_ieee_data_list                       array[30] of uint8_t

address     size       variable name                            type
0x0020ba3a  0x1        dis_ieee_data_list_len                   uint8_t

address     size       variable name                            type
0x0020baf4  0x14       dis_manufacturer_name                    array[20] of uint8_t

address     size       variable name                            type
0x0020bae8  0x1        dis_manufacturer_name_len                uint8_t

address     size       variable name                            type
0x0020bb08  0x14       dis_model_number                         array[20] of uint8_t

address     size       variable name                            type
0x0020bae9  0x1        dis_model_number_len                     uint8_t

address     size       variable name                            type
0x0020ba3b  0x7        dis_pnp_id                               array[7] of uint8_t

address     size       variable name                            type
0x0020bb1c  0x14       dis_serial_number                        array[20] of uint8_t

address     size       variable name                            type
0x0020baea  0x1        dis_serial_number_len                    uint8_t

address     size       variable name                            type
0x0020bb58  0x14       dis_software_rev                         array[20] of uint8_t

address     size       variable name                            type
0x0020baed  0x1        dis_software_rev_len                     uint8_t

address     size       variable name                            type
0x0020ba42  0x8        dis_system_id                            array[8] of uint8_t

address     size       variable name                            type
0x0020baf0  0x4        pfn_dis_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x0020b2a0  0x70       bas_attr_tbl                             array[4] of const T_ATTRIB_APPL

address     size       variable name                            type
0x0020b310  0xc        bas_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x0020b310  0x4        bas_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x0020b314  0x4        bas_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x0020b318  0x4        bas_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x0020bae1  0x1        bas_read_battery_level_pending           _Bool

address     size       variable name                            type
0x0020bae0  0x1        battery_level                            uint8_t

address     size       variable name                            type
0x0020bae4  0x4        pfn_bas_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x0020bada  0x2        external_report_refer                    uint16_t

address     size       variable name                            type
0x0020ba36  0x4        hid_info                                 T_HID_INFO
0x0020ba36  0x1        hid_info.b_country_code                  uint8_t
0x0020ba37  0x1        hid_info.flags                           uint8_t
0x0020ba38  0x2        hid_info.bcd_hid                         uint16_t

address     size       variable name                            type
0x0020bad8  0x1        hid_protocol_mode                        T_HID_PROTOCOL_MODE

address     size       variable name                            type
0x0020bad9  0x1        hid_suspand_mode                         uint8_t

address     size       variable name                            type
0x0020af68  0x32c      hids_attr_tbl                            array[29] of const T_ATTRIB_APPL

address     size       variable name                            type
0x0020ba34  0x2        hids_attr_tbl_len                        uint16_t

address     size       variable name                            type
0x0020b294  0xc        hids_cbs                                 const T_FUN_GATT_SERVICE_CBS
0x0020b294  0x4        hids_cbs.read_attr_cb                    P_FUN_GATT_READ_ATTR_CB
0x0020b298  0x4        hids_cbs.write_attr_cb                   P_FUN_GATT_WRITE_ATTR_CB
0x0020b29c  0x4        hids_cbs.cccd_update_cb                  P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x0020aed4  0x93       hids_report_descriptor                   array[147] of const uint8_t

address     size       variable name                            type
0x0020badc  0x4        pfn_hids_cb                              P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x0020add4  0xc        app_cb_table                             const T_APP_CB_TABLE
0x0020add4  0x4        app_cb_table.app_cb_signature            uint32_t
0x0020add8  0x4        app_cb_table.app_cb_numbers              uint32_t
0x0020addc  0x4        app_cb_table.app_cb_addr                 array[1] of uint32_t

address     size       variable name                            type
0x0080e1e0  0x220      auth_header                              const T_AUTH_HEADER_FORMAT
0x0080e1e0  0x100      auth_header.payload_signature            array[256] of uint8_t
0x0080e2e0  0x10       auth_header.payload_mac                  array[16] of uint8_t
0x0080e2f0  0x100      auth_header.header_signature             array[256] of uint8_t
0x0080e3f0  0x10       auth_header.header_mac                   array[16] of uint8_t

address     size       variable name                            type
0x0080e000  0x1e0      img_header                               const T_IMG_HEADER_FORMAT
0x0080e000  0xc        img_header.ctrl_header                   T_IMG_CTRL_HEADER_FORMAT
0x0080e000  0x1        img_header.ctrl_header.ic_type           uint8_t
0x0080e001  0x1        img_header.ctrl_header.secure_version    uint8_t
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag         anonymous
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag.value   uint16_t
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag.flag_value anonymous
0x0080e002  0x2(15:1)  img_header.ctrl_header.ctrl_flag.flag_value.xip uint16_t
0x0080e002  0x2(14:1)  img_header.ctrl_header.ctrl_flag.flag_value.enc uint16_t
0x0080e002  0x2(13:1)  img_header.ctrl_header.ctrl_flag.flag_value.load_when_boot uint16_t
0x0080e002  0x2(12:1)  img_header.ctrl_header.ctrl_flag.flag_value.enc_load uint16_t
0x0080e002  0x2(9:3)   img_header.ctrl_header.ctrl_flag.flag_value.enc_key_select uint16_t
0x0080e002  0x2(8:1)   img_header.ctrl_header.ctrl_flag.flag_value.not_ready uint16_t
0x0080e002  0x2(7:1)   img_header.ctrl_header.ctrl_flag.flag_value.not_obsolete uint16_t
0x0080e002  0x2(6:1)   img_header.ctrl_header.ctrl_flag.flag_value.integrity_check_en_in_boot uint16_t
0x0080e002  0x2(0:6)   img_header.ctrl_header.ctrl_flag.flag_value.rsvd uint16_t
0x0080e004  0x2        img_header.ctrl_header.image_id          uint16_t
0x0080e006  0x2        img_header.ctrl_header.crc16             uint16_t
0x0080e008  0x4        img_header.ctrl_header.payload_len       uint32_t
0x0080e00c  0x10       img_header.uuid                          array[16] of uint8_t
0x0080e01c  0x4        img_header.exe_base                      uint32_t
0x0080e020  0x4        img_header.load_base                     uint32_t
0x0080e024  0x4        img_header.load_len                      uint32_t
0x0080e028  0x4        img_header.img_base                      uint32_t
0x0080e02c  0x4        img_header.rsvd0                         array[4] of uint8_t
0x0080e030  0x4        img_header.magic_pattern                 uint32_t
0x0080e034  0x10       img_header.dec_key                       array[16] of uint8_t
0x0080e044  0x1c       img_header.rsvd1                         array[28] of uint8_t
0x0080e060  0x10       img_header.git_ver                       T_VERSION_FORMAT
0x0080e060  0x4        img_header.git_ver.ver_info              anonymous
0x0080e060  0x4        img_header.git_ver.ver_info.version      uint32_t
0x0080e060  0x4        img_header.git_ver.ver_info.sub_version  anonymous
0x0080e060  0x4(28:4)  img_header.git_ver.ver_info.sub_version._version_major uint32_t
0x0080e060  0x4(20:8)  img_header.git_ver.ver_info.sub_version._version_minor uint32_t
0x0080e060  0x4(5:15)  img_header.git_ver.ver_info.sub_version._version_revision uint32_t
0x0080e060  0x4(0:5)   img_header.git_ver.ver_info.sub_version._version_reserve uint32_t
0x0080e064  0x4        img_header.git_ver._version_commitid     uint32_t
0x0080e068  0x8        img_header.git_ver._customer_name        array[8] of uint8_t
0x0080e070  0x104      img_header.rsaPubKey                     T_RSA_PUBLIC_KEY
0x0080e070  0x100      img_header.rsaPubKey.N                   array[256] of uint8_t
0x0080e170  0x4        img_header.rsaPubKey.E                   array[4] of uint8_t
0x0080e174  0x20       img_header.sha256                        array[32] of uint8_t
0x0080e194  0x44       img_header.rsvd2                         array[68] of uint8_t
0x0080e1d8  0x4        img_header.app_cb_signature              uint32_t
0x0080e1dc  0x4        img_header.app_cb_table_base_address     uint32_t

address     size       variable name                            type
0x0020bad4  0x4        user_wdg_cb                              BOOL_WDG_CB



========================================================================

** ELF Header Information

    File Name: W:\git\RTL8763BF\demoproject_1\keil\Objects\rtp8763_demo.axf

    Machine class: ELFCLASS32 (32-bit)
    Data encoding: ELFDATA2LSB (Little endian)
    Header version: EV_CURRENT (Current version)
    Operating System ABI: none
    ABI Version: 0
    File Type: ET_EXEC (Executable) (2)
    Machine: EM_ARM (ARM)

    Image Entry point: 0x0080e409
    Flags: EF_ARM_HASENTRY + EF_ARM_ABI_FLOAT_HARD (0x05000402)

    ARM ELF revision: 5 (ABI version 2)

    Conforms to Hard float procedure-call standard

    Built with
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armasm [4d35cf]
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armlink [4d35d2]

    Header size: 52 bytes (0x34)
    Program header entry size: 32 bytes (0x20)
    Section header entry size: 40 bytes (0x28)

    Program header entries: 2
    Section header entries: 22

    Program header offset: 422940 (0x0006741c)
    Section header offset: 423004 (0x0006745c)

    Section header string table index: 21

========================================================================

** Program header #0 (PT_LOAD) [PF_X + PF_W + PF_R + PF_ARM_ENTRY]
    Size : 15416 bytes (14732 bytes in file)
    Virtual address: 0x0080e000 (Alignment 4)


====================================

** Program header #1 (PT_LOAD) [PF_R]
    Size : 4456 bytes
    Virtual address: 0x08800000 (Alignment 4)


========================================================================

** Section #1 'app.bin' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 1024 bytes (alignment 4)
    Address: 0x0080e000

    0x80e000:   05 00 01 01 93 27 00 00 00 01 00 00 6d 67 de f1    .....'......mg..
    0x80e010:   3e 33 e8 11 b1 02 4d 2d f4 0c de 01 00 e4 80 00    >3....M-........
    0x80e020:   00 e4 80 00 00 00 00 00 00 e0 80 00 00 00 00 00    ................
    0x80e030:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e040:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e050:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e060:   01 20 00 00 a8 ac 83 2a 73 64 6b 23 23 23 23 23    . .....*sdk#####
    0x80e070:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e080:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e090:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e100:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e110:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e120:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e130:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e140:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e150:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e160:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e170:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e180:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e190:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1d0:   00 00 00 00 00 00 00 00 01 d1 85 0e 44 0b 81 00    ............D...
    0x80e1e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e200:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e210:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e220:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e230:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e240:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e250:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e260:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e270:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e280:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e290:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2e0:   ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................
    0x80e2f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e300:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e310:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e320:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e330:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e340:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e350:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e360:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e370:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e380:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e390:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3f0:   ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................


** Section #2 'FLASH_START_ADDR' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 8 bytes (alignment 4)
    Address: 0x0080e400

    $t
    RESET
    $v0
    Reset_Handler
;;; ..\\source\\app\\startup_rtl8762c.s
;;;96                     IMPORT SystemInit
;;;96                     LDR    R0, =SystemInit
        0x0080e400:    4800        .H      LDR      r0,[pc,#0] ; [0x80e404] = 0x80e5eb
;;;97                     BX     R0
        0x0080e402:    4700        .G      BX       r0
    $d
        0x0080e404:    0080e5eb    ....    DCD    8447467

** Section #3 'FLASH_TEXT' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 12212 bytes (alignment 4)
    Address: 0x0080e408

    $t
    !!!main
    __main
        0x0080e408:    f000f802    ....    BL       __scatterload ; 0x80e410
        0x0080e40c:    f000f83c    ..<.    BL       __rt_entry ; 0x80e488
    !!!scatter
    __scatterload
    __scatterload_rt2
    __scatterload_rt2_thumb_only
        0x0080e410:    a00a        ..      ADR      r0,{pc}+0x2c ; 0x80e43c
        0x0080e412:    e8900c00    ....    LDM      r0,{r10,r11}
        0x0080e416:    4482        .D      ADD      r10,r10,r0
        0x0080e418:    4483        .D      ADD      r11,r11,r0
        0x0080e41a:    f1aa0701    ....    SUB      r7,r10,#1
    __scatterload_null
        0x0080e41e:    45da        .E      CMP      r10,r11
        0x0080e420:    d101        ..      BNE      0x80e426 ; __scatterload_null + 8
        0x0080e422:    f000f831    ..1.    BL       __rt_entry ; 0x80e488
        0x0080e426:    f2af0e09    ....    ADR      lr,{pc}-7 ; 0x80e41f
        0x0080e42a:    e8ba000f    ....    LDM      r10!,{r0-r3}
        0x0080e42e:    f0130f01    ....    TST      r3,#1
        0x0080e432:    bf18        ..      IT       NE
        0x0080e434:    1afb        ..      SUBNE    r3,r7,r3
        0x0080e436:    f0430301    C...    ORR      r3,r3,#1
        0x0080e43a:    4718        .G      BX       r3
    $d
        0x0080e43c:    00002f40    @/..    DCD    12096
        0x0080e440:    00002f80    ./..    DCD    12160
    $t
    !!handler_copy
    __scatterload_copy
        0x0080e444:    3a10        .:      SUBS     r2,r2,#0x10
        0x0080e446:    bf24        $.      ITT      CS
        0x0080e448:    c878        x.      LDMCS    r0!,{r3-r6}
        0x0080e44a:    c178        x.      STMCS    r1!,{r3-r6}
        0x0080e44c:    d8fa        ..      BHI      __scatterload_copy ; 0x80e444
        0x0080e44e:    0752        R.      LSLS     r2,r2,#29
        0x0080e450:    bf24        $.      ITT      CS
        0x0080e452:    c830        0.      LDMCS    r0!,{r4,r5}
        0x0080e454:    c130        0.      STMCS    r1!,{r4,r5}
        0x0080e456:    bf44        D.      ITT      MI
        0x0080e458:    6804        .h      LDRMI    r4,[r0,#0]
        0x0080e45a:    600c        .`      STRMI    r4,[r1,#0]
        0x0080e45c:    4770        pG      BX       lr
        0x0080e45e:    0000        ..      MOVS     r0,r0
    !!handler_zi
    __scatterload_zeroinit
        0x0080e460:    2300        .#      MOVS     r3,#0
        0x0080e462:    2400        .$      MOVS     r4,#0
        0x0080e464:    2500        .%      MOVS     r5,#0
        0x0080e466:    2600        .&      MOVS     r6,#0
        0x0080e468:    3a10        .:      SUBS     r2,r2,#0x10
        0x0080e46a:    bf28        (.      IT       CS
        0x0080e46c:    c178        x.      STMCS    r1!,{r3-r6}
        0x0080e46e:    d8fb        ..      BHI      0x80e468 ; __scatterload_zeroinit + 8
        0x0080e470:    0752        R.      LSLS     r2,r2,#29
        0x0080e472:    bf28        (.      IT       CS
        0x0080e474:    c130        0.      STMCS    r1!,{r4,r5}
        0x0080e476:    bf48        H.      IT       MI
        0x0080e478:    600b        .`      STRMI    r3,[r1,#0]
        0x0080e47a:    4770        pG      BX       lr
    .ARM.Collect$$libinit$$00000000
    __rt_lib_init
        0x0080e47c:    b51f        ..      PUSH     {r0-r4,lr}
    .ARM.Collect$$libinit$$00000001
    __rt_lib_init_fp_1
        0x0080e47e:    f002fb5b    ..[.    BL       _fp_init ; 0x810b38
    .ARM.Collect$$libinit$$00000004
    .ARM.Collect$$libinit$$0000000A
    .ARM.Collect$$libinit$$0000000C
    .ARM.Collect$$libinit$$0000000D
    __rt_lib_init_heap_1
    __rt_lib_init_preinit_1
    __rt_lib_init_rand_2
    __rt_lib_init_user_alloc_1
        0x0080e482:    f002fb50    ..P.    BL       _rand_init ; 0x810b26
    .ARM.Collect$$libinit$$0000000E
    .ARM.Collect$$libinit$$00000011
    .ARM.Collect$$libinit$$00000013
    .ARM.Collect$$libinit$$00000015
    .ARM.Collect$$libinit$$00000017
    .ARM.Collect$$libinit$$00000019
    .ARM.Collect$$libinit$$0000001B
    .ARM.Collect$$libinit$$0000001D
    .ARM.Collect$$libinit$$0000001F
    .ARM.Collect$$libinit$$00000021
    .ARM.Collect$$libinit$$00000023
    .ARM.Collect$$libinit$$00000025
    .ARM.Collect$$libinit$$0000002C
    .ARM.Collect$$libinit$$0000002E
    .ARM.Collect$$libinit$$00000030
    .ARM.Collect$$libinit$$00000032
    .ARM.Collect$$libinit$$00000033
    __rt_lib_init_alloca_1
    __rt_lib_init_argv_1
    __rt_lib_init_atexit_1
    __rt_lib_init_clock_1
    __rt_lib_init_cpp_1
    __rt_lib_init_exceptions_1
    __rt_lib_init_fp_trap_1
    __rt_lib_init_getenv_1
    __rt_lib_init_lc_collate_1
    __rt_lib_init_lc_ctype_1
    __rt_lib_init_lc_monetary_1
    __rt_lib_init_lc_numeric_1
    __rt_lib_init_lc_time_1
    __rt_lib_init_rand_1
    __rt_lib_init_return
    __rt_lib_init_signal_1
    __rt_lib_init_stdio_1
        0x0080e486:    bd1f        ..      POP      {r0-r4,pc}
    .ARM.Collect$$rtentry$$00000000
    .ARM.Collect$$rtentry$$00000002
    .ARM.Collect$$rtentry$$00000004
    __rt_entry
    __rt_entry_presh_1
    __rt_entry_sh
        0x0080e488:    f002f944    ..D.    BL       __user_setup_stackheap ; 0x810714
        0x0080e48c:    4611        .F      MOV      r1,r2
    .ARM.Collect$$rtentry$$00000009
    .ARM.Collect$$rtentry$$0000000A
    __rt_entry_li
    __rt_entry_postsh_1
        0x0080e48e:    f7fffff5    ....    BL       __rt_lib_init ; 0x80e47c
    .ARM.Collect$$rtentry$$0000000C
    .ARM.Collect$$rtentry$$0000000D
    __rt_entry_main
    __rt_entry_postli_1
        0x0080e492:    f001fccb    ....    BL       main ; 0x80fe2c
        0x0080e496:    f44cf4c5    L...    BL       exit ; 0x5ae24
        0x0080e49a:    0000        ..      MOVS     r0,r0
    .app.flash.text
    ram_init
;;;369    {
        0x0080e49c:    b510        ..      PUSH     {r4,lr}
;;;370        //copy data on ro
;;;371        extern char Image$$RAM_DATA_ON$$RO$$Base[];
;;;372        extern char Load$$RAM_DATA_ON$$RO$$Base[];
;;;373        extern unsigned int Image$$RAM_DATA_ON$$RO$$Length;
;;;374    
;;;375        memcpy(Image$$RAM_DATA_ON$$RO$$Base,
        0x0080e49e:    4a7a        zJ      LDR      r2,[pc,#488] ; [0x80e688] = 0x34c
        0x0080e4a0:    497a        zI      LDR      r1,[pc,#488] ; [0x80e68c] = 0x8114b0
        0x0080e4a2:    487b        {H      LDR      r0,[pc,#492] ; [0x80e690] = 0x207c00
        0x0080e4a4:    f44bf4f9    K...    BL       __aeabi_memcpy ; 0x59e9a
;;;376               Load$$RAM_DATA_ON$$RO$$Base,
;;;377               (unsigned int)&Image$$RAM_DATA_ON$$RO$$Length);
;;;378    
;;;379        //copy data on rw
;;;380        extern char Image$$RAM_DATA_ON$$RW$$Base[];
;;;381        extern char Load$$RAM_DATA_ON$$RW$$Base[];
;;;382        extern unsigned int Image$$RAM_DATA_ON$$RW$$Length;
;;;383    
;;;384        memcpy(Image$$RAM_DATA_ON$$RW$$Base,
        0x0080e4a8:    4a7a        zJ      LDR      r2,[pc,#488] ; [0x80e694] = 0xd0
        0x0080e4aa:    497b        {I      LDR      r1,[pc,#492] ; [0x80e698] = 0x8117fc
        0x0080e4ac:    487b        {H      LDR      r0,[pc,#492] ; [0x80e69c] = 0x207f4c
        0x0080e4ae:    f44bf4f4    K...    BL       __aeabi_memcpy ; 0x59e9a
;;;385               Load$$RAM_DATA_ON$$RW$$Base,
;;;386               (unsigned int)&Image$$RAM_DATA_ON$$RW$$Length);
;;;387    
;;;388        //clear data on zi
;;;389        extern char Image$$RAM_DATA_ON$$ZI$$Base[];
;;;390        extern unsigned int Image$$RAM_DATA_ON$$ZI$$Length;
;;;391    
;;;392        memset(Image$$RAM_DATA_ON$$ZI$$Base,
        0x0080e4b2:    497b        {I      LDR      r1,[pc,#492] ; [0x80e6a0] = 0x2ac
        0x0080e4b4:    487b        {H      LDR      r0,[pc,#492] ; [0x80e6a4] = 0x20801c
        0x0080e4b6:    f44bf5b1    K...    BL       __aeabi_memclr ; 0x5a01c
;;;393               0,
;;;394               (unsigned int)&Image$$RAM_DATA_ON$$ZI$$Length);
;;;395    
;;;396        //copy cache ro
;;;397        extern char Image$$CACHE_DATA_ON$$RO$$Base[];
;;;398        extern char Load$$CACHE_DATA_ON$$RO$$Base[];
;;;399        extern unsigned int Image$$CACHE_DATA_ON$$RO$$Length;
;;;400    
;;;401        memcpy(Image$$CACHE_DATA_ON$$RO$$Base,
        0x0080e4ba:    4a7b        {J      LDR      r2,[pc,#492] ; [0x80e6a8] = 0
        0x0080e4bc:    497b        {I      LDR      r1,[pc,#492] ; [0x80e6ac] = 0x81198c
        0x0080e4be:    487c        |H      LDR      r0,[pc,#496] ; [0x80e6b0] = 0x21c000
        0x0080e4c0:    f44bf4eb    K...    BL       __aeabi_memcpy ; 0x59e9a
;;;402               Load$$CACHE_DATA_ON$$RO$$Base,
;;;403               (unsigned int)&Image$$CACHE_DATA_ON$$RO$$Length);
;;;404    
;;;405        //copy share cache ram rw
;;;406        extern char Image$$CACHE_DATA_ON$$RW$$Base[];
;;;407        extern char Load$$CACHE_DATA_ON$$RW$$Base[];
;;;408        extern unsigned int Image$$CACHE_DATA_ON$$RW$$Length;
;;;409    
;;;410        memcpy(Image$$CACHE_DATA_ON$$RW$$Base,
        0x0080e4c4:    4a7b        {J      LDR      r2,[pc,#492] ; [0x80e6b4] = 0
        0x0080e4c6:    497c        |I      LDR      r1,[pc,#496] ; [0x80e6b8] = 0x81198c
        0x0080e4c8:    487c        |H      LDR      r0,[pc,#496] ; [0x80e6bc] = 0x21c000
        0x0080e4ca:    f44bf4e6    K...    BL       __aeabi_memcpy ; 0x59e9a
;;;411               Load$$CACHE_DATA_ON$$RW$$Base,
;;;412               (unsigned int)&Image$$CACHE_DATA_ON$$RW$$Length);
;;;413    
;;;414        //clear share cache ram zi
;;;415        extern char Image$$CACHE_DATA_ON$$ZI$$Base[];
;;;416        extern unsigned int Image$$CACHE_DATA_ON$$ZI$$Length;
;;;417    
;;;418        memset(Image$$CACHE_DATA_ON$$ZI$$Base,
        0x0080e4ce:    e8bd4010    ...@    POP      {r4,lr}
        0x0080e4d2:    497b        {I      LDR      r1,[pc,#492] ; [0x80e6c0] = 0
        0x0080e4d4:    487b        {H      LDR      r0,[pc,#492] ; [0x80e6c4] = 0x21c000
        0x0080e4d6:    f44bb5a1    K...    B        __aeabi_memclr ; 0x5a01c
    random_seed_init
;;;419               0,
;;;420               (unsigned int)&Image$$CACHE_DATA_ON$$ZI$$Length);
;;;421    }
;;;422    
;;;423    uint32_t random_seed_value;
;;;424    
;;;425    APP_FLASH_TEXT_SECTION
;;;426    void random_seed_init(void)
;;;427    {
        0x0080e4da:    b57f        ..      PUSH     {r0-r6,lr}
;;;428        uint16_t crc16;
;;;429        uint8_t buf[DATA_SIZE_FOR_RANDOM_SEED];
;;;430        uint8_t *sour_addr = (uint8_t *)(OTP->appDataAddr + OTP->appDataSize + OTP->heapDataONSize);
        0x0080e4dc:    f44f1000    O...    MOV      r0,#0x200000
        0x0080e4e0:    e9f012e0    ....    LDRD     r1,r2,[r0,#0x380]!
        0x0080e4e4:    4411        .D      ADD      r1,r1,r2
        0x0080e4e6:    6880        .h      LDR      r0,[r0,#8]
        0x0080e4e8:    2210        ."      MOVS     r2,#0x10
        0x0080e4ea:    180d        ..      ADDS     r5,r1,r0
;;;431    
;;;432        memcpy(buf, sour_addr, DATA_SIZE_FOR_RANDOM_SEED);
        0x0080e4ec:    4629        )F      MOV      r1,r5
        0x0080e4ee:    4668        hF      MOV      r0,sp
        0x0080e4f0:    f44bf4d3    K...    BL       __aeabi_memcpy ; 0x59e9a
;;;433        crc16 = btxfcs(0, buf, DATA_SIZE_FOR_RANDOM_SEED);
        0x0080e4f4:    2210        ."      MOVS     r2,#0x10
        0x0080e4f6:    4669        iF      MOV      r1,sp
        0x0080e4f8:    2000        .       MOVS     r0,#0
        0x0080e4fa:    f7f8df6b    ..k.    BL       btxfcs ; 0x73d4
;;;434    
;;;435        random_seed_value = (crc16 << 16) | (*(volatile uint32_t *)(0x4005817C) & 0xFFFF);
        0x0080e4fe:    4972        rI      LDR      r1,[pc,#456] ; [0x80e6c8] = 0x40058000
        0x0080e500:    f8d1117c    ..|.    LDR      r1,[r1,#0x17c]
        0x0080e504:    4e71        qN      LDR      r6,[pc,#452] ; [0x80e6cc] = 0x20801c
        0x0080e506:    f360411f    `..A    BFI      r1,r0,#16,#16
;;;436    
;;;437        random_seed_value *= platform_random(0xFFFFFFFF);
        0x0080e50a:    f04f30ff    O..0    MOV      r0,#0xffffffff
        0x0080e50e:    60f1        .`      STR      r1,[r6,#0xc]
        0x0080e510:    f7f9d94f    ..O.    BL       platform_random ; 0x77b2
        0x0080e514:    68f1        .h      LDR      r1,[r6,#0xc]
        0x0080e516:    4348        HC      MULS     r0,r1,r0
;;;438    
;;;439        srand(random_seed_value);
        0x0080e518:    60f0        .`      STR      r0,[r6,#0xc]
        0x0080e51a:    f002faef    ....    BL       srand ; 0x810afc
;;;440    
;;;441        for (int i = 0; i < (DATA_SIZE_FOR_RANDOM_SEED / 4); ++i)
        0x0080e51e:    2400        .$      MOVS     r4,#0
        0x0080e520:    f000f8fc    ....    BL       rand ; 0x80e71c
        0x0080e524:    f8450024    E.$.    STR      r0,[r5,r4,LSL #2]
        0x0080e528:    1c64        d.      ADDS     r4,r4,#1
        0x0080e52a:    2c04        .,      CMP      r4,#4
        0x0080e52c:    dbf8        ..      BLT      0x80e520 ; random_seed_init + 70
;;;442        {
;;;443            *(uint32_t *)(sour_addr + i * 4) = rand();
;;;444        }
;;;445    
;;;446        random_seed_value = rand();
        0x0080e52e:    f000f8f5    ....    BL       rand ; 0x80e71c
        0x0080e532:    60f0        .`      STR      r0,[r6,#0xc]
;;;447    }
        0x0080e534:    bd7f        ..      POP      {r0-r6,pc}
    print_reset_reason
;;;448    
;;;449    APP_FLASH_TEXT_SECTION
;;;450    void SystemInit(void)
;;;451    {
;;;452        //hci mode check and bypass app
;;;453        if (check_hci_mode_flag())
;;;454        {
;;;455            return;
;;;456        }
;;;457    
;;;458        //init pre_main and main functions
;;;459        extern void pre_main(void);
;;;460        app_pre_main = (APP_MAIN_FUNC)pre_main;
;;;461        app_main = (APP_MAIN_FUNC)common_main;
;;;462    
;;;463        /******** update otp here**********/
;;;464        //ram config
;;;465        OTP->appDataSize = APP_GLOBAL_SIZE;
;;;466        OTP->heapDataONSize = HEAP_DATA_ON_SIZE - DATA_SIZE_FOR_RANDOM_SEED;
;;;467    
;;;468        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;469    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;470        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
;;;471    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;472        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;473    #else
;;;474        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;475    #endif
;;;476    
;;;477        //sw timer config
;;;478    #ifdef TIMER_MAX_NUMBER
;;;479        //define TIMER_MAX_NUMBER in otp_config.h
;;;480        OTP->timerMaxNumber = TIMER_MAX_NUMBER;
;;;481    #endif
;;;482    
;;;483        //flash config
;;;484        /*config enable flash block proect depending on flash layout and flash id*/
;;;485    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;486        OTP->bp_enable = 1;
;;;487    #else
;;;488        OTP->bp_enable = 0;
;;;489    #endif
;;;490        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
;;;491    
;;;492    
;;;493        //os config
;;;494        /*config enable check task stack overflow*/
;;;495    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;496        OTP->checkForStackOverflow = 1;
;;;497    #else
;;;498        OTP->checkForStackOverflow = 0;
;;;499    #endif
;;;500    
;;;501    
;;;502        //platform config
;;;503        /*config enable platform assert*/
;;;504    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;505        OTP->enableASSERT = 1;
;;;506    #else
;;;507        OTP->enableASSERT = 0;
;;;508    #endif
;;;509    
;;;510        /*Print all log in log buffer before entering DLPS */
;;;511    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;512        OTP->printAllLogBeforeEnterDLPS = 1;
;;;513    #else
;;;514        OTP->printAllLogBeforeEnterDLPS = 0;
;;;515    #endif
;;;516    
;;;517        /*config enable log or not*/
;;;518    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;519        OTP->logDisable = 0;
;;;520    #else
;;;521        OTP->logDisable = 1;
;;;522    #endif
;;;523    
;;;524        /*config enable swd pinmux*/
;;;525    #if (SWD_PINMUX_ENABLE == 1)
;;;526        OTP->SWD_ENABLE = 1;
;;;527    #else
;;;528        OTP->SWD_ENABLE = 0;
;;;529    #endif
;;;530    
;;;531        /*config enable watch dog in rom*/
;;;532    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;533        OTP->wdgEnableInRom = 1;
;;;534    #else
;;;535        OTP->wdgEnableInRom = 0;
;;;536    #endif
;;;537    
;;;538        /*config watch dog mode in rom, defualt reset all*/
;;;539        OTP->wdgMode = ROM_WATCH_DOG_MODE;
;;;540    
;;;541        /*use os tick as log timestamp instead of TIM7*/
;;;542        OTP->log_timestamp_src = LOG_TIMESTAMP_OS;
;;;543    
;;;544    
;;;545        //app config
;;;546        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
;;;547        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
;;;548        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
;;;549        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
;;;550    
;;;551    #if ROM_OTA_LINKLOSS_RST
;;;552        OTP->ota_link_loss_reset = 1;
;;;553    #endif
;;;554        /*config bt stack parameters in rom*/
;;;555    #ifdef BT_STACK_CONFIG_ENABLE
;;;556        bt_stack_config_init();
;;;557    #endif
;;;558    
;;;559    //add more otp config here
;;;560    }
;;;561    
;;;562    //Note: call print_reset_reason() before ram_init();
;;;563    APP_FLASH_TEXT_SECTION
;;;564    void print_reset_reason(void)
;;;565    {
        0x0080e536:    b570        p.      PUSH     {r4-r6,lr}
;;;566        if (check_reset_ram.check_reset_ram_pattern != RESET_RAM_PATTERN)
        0x0080e538:    4d65        eM      LDR      r5,[pc,#404] ; [0x80e6d0] = 0x207f4c
        0x0080e53a:    4966        fI      LDR      r1,[pc,#408] ; [0x80e6d4] = 0x72657400
        0x0080e53c:    4c66        fL      LDR      r4,[pc,#408] ; [0x80e6d8] = 0x21100302
        0x0080e53e:    6828        (h      LDR      r0,[r5,#0]
;;; ..\include\SDK\peripheral\rtl876x_wdg.h
;;;135        return (T_SW_RESET_REASON)flash_ioctl(flash_ioctl_get_aon_record_reset_reason, 0, 0);
        0x0080e540:    f04f0200    O...    MOV      r2,#0
        0x0080e544:    ebb12f00    .../    CMP      r1,r0,LSL #8
        0x0080e548:    d005        ..      BEQ      0x80e556 ; print_reset_reason + 32
;;; .\..\source\cmsis\system_rtl8762c.c
;;;568            BOOT_PRINT_INFO0("RESET Reason: HW or OTA");
        0x0080e54a:    4620         F      MOV      r0,r4
        0x0080e54c:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0080e550:    4962        bI      LDR      r1,[pc,#392] ; [0x80e6dc] = 0x8800000
        0x0080e552:    f7f99a84    ....    B        log_buffer ; 0x7a5e
;;; ..\include\SDK\peripheral\rtl876x_wdg.h
;;;135        return (T_SW_RESET_REASON)flash_ioctl(flash_ioctl_get_aon_record_reset_reason, 0, 0);
        0x0080e556:    2100        .!      MOVS     r1,#0
        0x0080e558:    f2450006    E...    MOV      r0,#0x5006
        0x0080e55c:    f7fddd89    ....    BL       flash_ioctl ; 0xc072
        0x0080e560:    f01003ff    ....    ANDS     r3,r0,#0xff
;;; .\..\source\cmsis\system_rtl8762c.c
;;;574            if (sw_reset_type != (T_SW_RESET_REASON)0)
        0x0080e564:    d003        ..      BEQ      0x80e56e ; print_reset_reason + 56
;;;575            {
;;;576                BOOT_PRINT_INFO1("RESET Reason: SW(reset except aon), TYPE 0x%x", sw_reset_type);
        0x0080e566:    495d        ]I      LDR      r1,[pc,#372] ; [0x80e6dc] = 0x8800000
        0x0080e568:    2201        ."      MOVS     r2,#1
        0x0080e56a:    311c        .1      ADDS     r1,r1,#0x1c
        0x0080e56c:    e004        ..      B        0x80e578 ; print_reset_reason + 66
;;;577            }
;;;578            else //reset all will clear aon register
;;;579            {
;;;580                BOOT_PRINT_INFO1("RESET Reason: SW(reset all), TYPE 0x%x", check_reset_ram.check_reset_ram_type);
        0x0080e56e:    6828        (h      LDR      r0,[r5,#0]
        0x0080e570:    495a        ZI      LDR      r1,[pc,#360] ; [0x80e6dc] = 0x8800000
        0x0080e572:    0e03        ..      LSRS     r3,r0,#24
        0x0080e574:    2201        ."      MOVS     r2,#1
        0x0080e576:    3150        P1      ADDS     r1,r1,#0x50
        0x0080e578:    4620         F      MOV      r0,r4
        0x0080e57a:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0080e57e:    f7f99a6e    ..n.    B        log_buffer ; 0x7a5e
    pre_main
;;;581            }
;;;582        }
;;;583    }
;;;584    
;;;585    APP_FLASH_TEXT_SECTION
;;;586    void pre_main(void)
;;;587    {
        0x0080e582:    b538        8.      PUSH     {r3-r5,lr}
;;;588        __disable_irq();
        0x0080e584:    b672        r.      CPSID    i
;;;589    
;;;590        print_reset_reason();  //Note: call this function before ram_init();
        0x0080e586:    f7ffffd6    ....    BL       print_reset_reason ; 0x80e536
;;;591    
;;;592        ram_init();
        0x0080e58a:    f7ffff87    ....    BL       ram_init ; 0x80e49c
;;;593    
;;;594        random_seed_init();
        0x0080e58e:    f7ffffa4    ....    BL       random_seed_init ; 0x80e4da
;;;595    
;;;596        load_overlay(OVERLAY_SCENARIO_BOOT_ONCE);
        0x0080e592:    2000        .       MOVS     r0,#0
        0x0080e594:    f002f878    ..x.    BL       load_overlay ; 0x810688
;;;597    
;;;598        //reset NVIC of DMA channel used in image decryption
;;;599        NVIC_DisableIRQ(GDMA0_Channel2_IRQn);
        0x0080e598:    2016        .       MOVS     r0,#0x16
        0x0080e59a:    f000f949    ..I.    BL       NVIC_DisableIRQ ; 0x80e830
;;;600        NVIC_DisableIRQ(GDMA0_Channel3_IRQn);
        0x0080e59e:    2017        .       MOVS     r0,#0x17
        0x0080e5a0:    f000f946    ..F.    BL       NVIC_DisableIRQ ; 0x80e830
;;;601    
;;;602        setlocale(LC_ALL, "C");
        0x0080e5a4:    a14e        N.      ADR      r1,{pc}+0x13c ; 0x80e6e0
        0x0080e5a6:    201f        .       MOVS     r0,#0x1f
        0x0080e5a8:    f44bf424    K.$.    BL       setlocale ; 0x59df4
;;;603    
;;;604        BOOT_PRINT_ERROR2("SDK Ver: %s, Build Time: %s",
        0x0080e5ac:    f04f5505    O..U    MOV      r5,#0x21400000
        0x0080e5b0:    a14c        L.      ADR      r1,{pc}+0x134 ; 0x80e6e4
        0x0080e5b2:    4628        (F      MOV      r0,r5
        0x0080e5b4:    f7f9dc59    ..Y.    BL       trace_string ; 0x7e6a
        0x0080e5b8:    4604        .F      MOV      r4,r0
        0x0080e5ba:    a151        Q.      ADR      r1,{pc}+0x146 ; 0x80e700
        0x0080e5bc:    4628        (F      MOV      r0,r5
        0x0080e5be:    f7f9dc54    ..T.    BL       trace_string ; 0x7e6a
        0x0080e5c2:    4603        .F      MOV      r3,r0
        0x0080e5c4:    4945        EI      LDR      r1,[pc,#276] ; [0x80e6dc] = 0x8800000
        0x0080e5c6:    4844        DH      LDR      r0,[pc,#272] ; [0x80e6d8] = 0x21100302
        0x0080e5c8:    2202        ."      MOVS     r2,#2
        0x0080e5ca:    317c        |1      ADDS     r1,r1,#0x7c
        0x0080e5cc:    1e80        ..      SUBS     r0,r0,#2
        0x0080e5ce:    9400        ..      STR      r4,[sp,#0]
        0x0080e5d0:    f7f9da45    ..E.    BL       log_buffer ; 0x7a5e
;;;605                          TRACE_STRING(VERSION_BUILD_STR),
;;;606                          TRACE_STRING(BUILDING_TIME));
;;;607    
;;;608        AppUpdateVectorTable();
        0x0080e5d4:    f5f9f678    ..x.    BL       AppUpdateVectorTable ; 0x2082c8
;;;609    
;;;610    #if (DEBUG_WATCHPOINT_ENABLE == 1)
;;;611        debug_monitor_enable();
;;;612    #endif
;;;613    
;;;614        if (app_pre_main_cb)
        0x0080e5d8:    484b        KH      LDR      r0,[pc,#300] ; [0x80e708] = 0x208024
        0x0080e5da:    6800        .h      LDR      r0,[r0,#0]
        0x0080e5dc:    2800        .(      CMP      r0,#0
        0x0080e5de:    d003        ..      BEQ      0x80e5e8 ; pre_main + 102
;;;615        {
;;;616            app_pre_main_cb();
        0x0080e5e0:    b001        ..      ADD      sp,sp,#4
        0x0080e5e2:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x0080e5e6:    4700        .G      BX       r0
;;;617        }
;;;618    
;;;619        return;
;;;620    }
        0x0080e5e8:    bd38        8.      POP      {r3-r5,pc}
    SystemInit
;;; .\..\source\cmsis\system_rtl8762c.c (451)
        0x0080e5ea:    b510        ..      PUSH     {r4,lr}
;;;452        //hci mode check and bypass app
;;;453        if (check_hci_mode_flag())
        0x0080e5ec:    f7fed8b8    ....    BL       check_hci_mode_flag ; 0xc760
        0x0080e5f0:    2800        .(      CMP      r0,#0
        0x0080e5f2:    d148        H.      BNE      0x80e686 ; SystemInit + 156
;;;454        {
;;;455            return;
;;;456        }
;;;457    
;;;458        //init pre_main and main functions
;;;459        extern void pre_main(void);
;;;460        app_pre_main = (APP_MAIN_FUNC)pre_main;
        0x0080e5f4:    f2af0075    ..u.    ADR      r0,{pc}-0x71 ; 0x80e583
        0x0080e5f8:    4944        DI      LDR      r1,[pc,#272] ; [0x80e70c] = 0x200c38
;;;461        app_main = (APP_MAIN_FUNC)common_main;
        0x0080e5fa:    6008        .`      STR      r0,[r1,#0]
        0x0080e5fc:    4945        EI      LDR      r1,[pc,#276] ; [0x80e714] = 0x200c3c
        0x0080e5fe:    4844        DH      LDR      r0,[pc,#272] ; [0x80e710] = 0x80e751
;;;462    
;;;463        /******** update otp here**********/
;;;464        //ram config
;;;465        OTP->appDataSize = APP_GLOBAL_SIZE;
        0x0080e600:    6008        .`      STR      r0,[r1,#0]
        0x0080e602:    f44f1000    O...    MOV      r0,#0x200000
        0x0080e606:    f44f410c    O..A    MOV      r1,#0x8c00
;;;466        OTP->heapDataONSize = HEAP_DATA_ON_SIZE - DATA_SIZE_FOR_RANDOM_SEED;
        0x0080e60a:    f8c01384    ....    STR      r1,[r0,#0x384]
        0x0080e60e:    f24771f0    G..q    MOV      r1,#0x77f0
;;;467    
;;;468        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;469    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;470        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
        0x0080e612:    f8c01388    ....    STR      r1,[r0,#0x388]
        0x0080e616:    4940        @I      LDR      r1,[pc,#256] ; [0x80e718] = 0xa2aa0003
;;;471    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;472        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;473    #else
;;;474        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;475    #endif
;;;476    
;;;477        //sw timer config
;;;478    #ifdef TIMER_MAX_NUMBER
;;;479        //define TIMER_MAX_NUMBER in otp_config.h
;;;480        OTP->timerMaxNumber = TIMER_MAX_NUMBER;
;;;481    #endif
;;;482    
;;;483        //flash config
;;;484        /*config enable flash block proect depending on flash layout and flash id*/
;;;485    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;486        OTP->bp_enable = 1;
;;;487    #else
;;;488        OTP->bp_enable = 0;
        0x0080e618:    f8c013cc    ....    STR      r1,[r0,#0x3cc]
        0x0080e61c:    f890134d    ..M.    LDRB     r1,[r0,#0x34d]
        0x0080e620:    f0210108    !...    BIC      r1,r1,#8
        0x0080e624:    f880134d    ..M.    STRB     r1,[r0,#0x34d]
;;;489    #endif
;;;490        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
        0x0080e628:    2106        .!      MOVS     r1,#6
        0x0080e62a:    f880134f    ..O.    STRB     r1,[r0,#0x34f]
;;;491    
;;;492    
;;;493        //os config
;;;494        /*config enable check task stack overflow*/
;;;495    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;496        OTP->checkForStackOverflow = 1;
        0x0080e62e:    f8901378    ..x.    LDRB     r1,[r0,#0x378]
;;;497    #else
;;;498        OTP->checkForStackOverflow = 0;
;;;499    #endif
;;;500    
;;;501    
;;;502        //platform config
;;;503        /*config enable platform assert*/
;;;504    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;505        OTP->enableASSERT = 1;
;;;506    #else
;;;507        OTP->enableASSERT = 0;
;;;508    #endif
;;;509    
;;;510        /*Print all log in log buffer before entering DLPS */
;;;511    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;512        OTP->printAllLogBeforeEnterDLPS = 1;
        0x0080e632:    f0410126    A.&.    ORR      r1,r1,#0x26
        0x0080e636:    f8801378    ..x.    STRB     r1,[r0,#0x378]
;;;513    #else
;;;514        OTP->printAllLogBeforeEnterDLPS = 0;
;;;515    #endif
;;;516    
;;;517        /*config enable log or not*/
;;;518    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;519        OTP->logDisable = 0;
        0x0080e63a:    f890139a    ....    LDRB     r1,[r0,#0x39a]
        0x0080e63e:    f0210101    !...    BIC      r1,r1,#1
        0x0080e642:    f880139a    ....    STRB     r1,[r0,#0x39a]
;;;520    #else
;;;521        OTP->logDisable = 1;
;;;522    #endif
;;;523    
;;;524        /*config enable swd pinmux*/
;;;525    #if (SWD_PINMUX_ENABLE == 1)
;;;526        OTP->SWD_ENABLE = 1;
        0x0080e646:    f8901334    ..4.    LDRB     r1,[r0,#0x334]
        0x0080e64a:    f0410101    A...    ORR      r1,r1,#1
        0x0080e64e:    f8801334    ..4.    STRB     r1,[r0,#0x334]
;;;527    #else
;;;528        OTP->SWD_ENABLE = 0;
;;;529    #endif
;;;530    
;;;531        /*config enable watch dog in rom*/
;;;532    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;533        OTP->wdgEnableInRom = 1;
;;;534    #else
;;;535        OTP->wdgEnableInRom = 0;
        0x0080e652:    f890137a    ..z.    LDRB     r1,[r0,#0x37a]
        0x0080e656:    f0210110    !...    BIC      r1,r1,#0x10
;;;536    #endif
;;;537    
;;;538        /*config watch dog mode in rom, defualt reset all*/
;;;539        OTP->wdgMode = ROM_WATCH_DOG_MODE;
        0x0080e65a:    f04101c0    A...    ORR      r1,r1,#0xc0
        0x0080e65e:    f880137a    ..z.    STRB     r1,[r0,#0x37a]
;;;540    
;;;541        /*use os tick as log timestamp instead of TIM7*/
;;;542        OTP->log_timestamp_src = LOG_TIMESTAMP_OS;
        0x0080e662:    f89013c3    ....    LDRB     r1,[r0,#0x3c3]
        0x0080e666:    f02101c0    !...    BIC      r1,r1,#0xc0
        0x0080e66a:    f88013c3    ....    STRB     r1,[r0,#0x3c3]
;;;543    
;;;544    
;;;545        //app config
;;;546        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
        0x0080e66e:    21b4        .!      MOVS     r1,#0xb4
        0x0080e670:    f8801320    .. .    STRB     r1,[r0,#0x320]
;;;547        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
        0x0080e674:    213c        <!      MOVS     r1,#0x3c
        0x0080e676:    f8801321    ..!.    STRB     r1,[r0,#0x321]
;;;548        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
        0x0080e67a:    2164        d!      MOVS     r1,#0x64
        0x0080e67c:    f8801322    ..".    STRB     r1,[r0,#0x322]
;;;549        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
        0x0080e680:    21ff        .!      MOVS     r1,#0xff
        0x0080e682:    f8801323    ..#.    STRB     r1,[r0,#0x323]
;;;550    
;;;551    #if ROM_OTA_LINKLOSS_RST
;;;552        OTP->ota_link_loss_reset = 1;
;;;553    #endif
;;;554        /*config bt stack parameters in rom*/
;;;555    #ifdef BT_STACK_CONFIG_ENABLE
;;;556        bt_stack_config_init();
;;;557    #endif
;;;558    
;;;559    //add more otp config here
;;;560    }
        0x0080e686:    bd10        ..      POP      {r4,pc}
    $d
        0x0080e688:    0000034c    L...    DCD    844
        0x0080e68c:    008114b0    ....    DCD    8459440
        0x0080e690:    00207c00    .| .    DCD    2128896
        0x0080e694:    000000d0    ....    DCD    208
        0x0080e698:    008117fc    ....    DCD    8460284
        0x0080e69c:    00207f4c    L. .    DCD    2129740
        0x0080e6a0:    000002ac    ....    DCD    684
        0x0080e6a4:    0020801c    .. .    DCD    2129948
        0x0080e6a8:    00000000    ....    DCD    0
        0x0080e6ac:    0081198c    ....    DCD    8460684
        0x0080e6b0:    0021c000    ..!.    DCD    2211840
        0x0080e6b4:    00000000    ....    DCD    0
        0x0080e6b8:    0081198c    ....    DCD    8460684
        0x0080e6bc:    0021c000    ..!.    DCD    2211840
        0x0080e6c0:    00000000    ....    DCD    0
        0x0080e6c4:    0021c000    ..!.    DCD    2211840
        0x0080e6c8:    40058000    ...@    DCD    1074102272
        0x0080e6cc:    0020801c    .. .    DCD    2129948
        0x0080e6d0:    00207f4c    L. .    DCD    2129740
        0x0080e6d4:    72657400    .ter    DCD    1919251456
        0x0080e6d8:    21100302    ...!    DCD    554697474
        0x0080e6dc:    08800000    ....    DCD    142606336
        0x0080e6e0:    00000043    C...    DCD    67
        0x0080e6e4:    20697246    Fri     DCD    543781446
        0x0080e6e8:    20706553    Sep     DCD    544236883
        0x0080e6ec:    31203132    21 1    DCD    824193330
        0x0080e6f0:    31303a33    3:01    DCD    825244211
        0x0080e6f4:    2037313a    :17     DCD    540487994
        0x0080e6f8:    38313032    2018    DCD    942747698
        0x0080e6fc:    00000000    ....    DCD    0
        0x0080e700:    2e302e31    1.0.    DCD    774909489
        0x0080e704:    00302e32    2.0.    DCD    3157554
        0x0080e708:    00208024    $. .    DCD    2129956
        0x0080e70c:    00200c38    8. .    DCD    2100280
        0x0080e710:    0080e751    Q...    DCD    8447825
        0x0080e714:    00200c3c    <. .    DCD    2100284
        0x0080e718:    a2aa0003    ....    DCD    2729050115
    $t
    .emb_text
    rand
        0x0080e71c:    490b        .I      LDR      r1,[pc,#44] ; [0x80e74c] = 0x2082c0
        0x0080e71e:    f8d1c000    ....    LDR      r12,[r1,#0]
        0x0080e722:    684a        Jh      LDR      r2,[r1,#4]
        0x0080e724:    f85c3b04    \..;    LDR      r3,[r12],#4
        0x0080e728:    6810        .h      LDR      r0,[r2,#0]
        0x0080e72a:    4418        .D      ADD      r0,r0,r3
        0x0080e72c:    f8420b04    B...    STR      r0,[r2],#4
        0x0080e730:    458c        .E      CMP      r12,r1
        0x0080e732:    bf28        (.      IT       CS
        0x0080e734:    f1a10cdc    ....    SUBCS    r12,r1,#0xdc
        0x0080e738:    428a        .B      CMP      r2,r1
        0x0080e73a:    bf28        (.      IT       CS
        0x0080e73c:    f1a102dc    ....    SUBCS    r2,r1,#0xdc
        0x0080e740:    f8c1c000    ....    STR      r12,[r1,#0]
        0x0080e744:    604a        J`      STR      r2,[r1,#4]
        0x0080e746:    f0204000     ..@    BIC      r0,r0,#0x80000000
        0x0080e74a:    4770        pG      BX       lr
    $d
        0x0080e74c:    002082c0    .. .    DCD    2130624
    $t
    .text
    common_main
;;; .\..\source\cmsis\system_rtl8762c.c (304)
        0x0080e750:    b510        ..      PUSH     {r4,lr}
;;;305    //add common system code here before enter user defined main function
;;;306        OTP->run_in_app = 1;
        0x0080e752:    f44f1400    O...    MOV      r4,#0x200000
        0x0080e756:    f894039b    ....    LDRB     r0,[r4,#0x39b]
        0x0080e75a:    f0400080    @...    ORR      r0,r0,#0x80
        0x0080e75e:    f884039b    ....    STRB     r0,[r4,#0x39b]
;;;307    
;;;308    #if (RUN_APP_IN_HCIMODE_ENABLE == 0)
;;;309        if (OTP->stack_en)
        0x0080e762:    f89402dc    ....    LDRB     r0,[r4,#0x2dc]
        0x0080e766:    07c1        ..      LSLS     r1,r0,#31
;;;310        {
;;;311            DBG_DIRECT("In SoC Mode");
        0x0080e768:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0080e76c:    d003        ..      BEQ      0x80e776 ; common_main + 38
        0x0080e76e:    a136        6.      ADR      r1,{pc}+0xda ; 0x80e848
        0x0080e770:    f7f9d91e    ....    BL       log_direct ; 0x79b0
        0x0080e774:    e006        ..      B        0x80e784 ; common_main + 52
;;;312        }
;;;313        else
;;;314        {
;;;315            DBG_DIRECT("WARNING: In HCI Mode, will not run APP Task");
        0x0080e776:    a137        7.      ADR      r1,{pc}+0xde ; 0x80e854
        0x0080e778:    f7f9d91a    ....    BL       log_direct ; 0x79b0
;;;316            WDG_Disable();
        0x0080e77c:    f403f0e1    ....    BL       WDG_Disable ; 0x11942
;;;317            os_sched_start();
        0x0080e780:    f418f01f    ....    BL       os_sched_start ; 0x267c2
;;;318        }
;;;319    #endif
;;;320    
;;;321        //fix system hang if app call log_module_trace_set after enable RELEASE_VERSION
;;;322        if (OTP->logDisable == 1)
        0x0080e784:    f894039a    ....    LDRB     r0,[r4,#0x39a]
        0x0080e788:    07c0        ..      LSLS     r0,r0,#31
        0x0080e78a:    d002        ..      BEQ      0x80e792 ; common_main + 66
;;;323        {
;;;324            log_module_trace_init(NULL);
        0x0080e78c:    2000        .       MOVS     r0,#0
        0x0080e78e:    f7f9dd21    ..!.    BL       log_module_trace_init ; 0x81d4
;;;325        }
;;;326    
;;;327    #if (SYSTEM_TRACE_ENABLE == 1)
;;;328        extern void system_trace_init(void);
;;;329        system_trace_init();
;;;330    #endif
;;;331    
;;;332        extern int __main(void);
;;;333        __main();
        0x0080e792:    e8bd4010    ...@    POP      {r4,lr}
        0x0080e796:    f7ffbe37    ..7.    B.W      __main ; 0x80e408
    WDG_SystemReset
;;;334    }
;;;335    
;;;336    #if (DEBUG_WATCHPOINT_ENABLE == 1)
;;;337    /**
;;;338     * @brief  Enable Debug Monitor Function (include NVIC Enable and DWT configuration)
;;;339     * @param  none
;;;340     * @return none
;;;341     */
;;;342    
;;;343    DATA_RAM_FUNCTION
;;;344    void debug_monitor_enable(void)
;;;345    {
;;;346        //DBG_DIRECT("debug_monitor_enable");
;;;347    
;;;348        //set debug monitor priority
;;;349        NVIC_SetPriority(DebugMonitor_IRQn, 3);
;;;350    
;;;351        //enable exception and monitor control register
;;;352        CoreDebug->DEMCR |= CoreDebug_DEMCR_MON_EN_Msk | CoreDebug_DEMCR_TRCENA_Msk;
;;;353    
;;;354        //set DWT compare registers (max 4 comparators)
;;;355        //watch_point_0_setting(0x1000180C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_WRITE);
;;;356        //watch_point_1_setting(0x10000004, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;357        //watch_point_2_setting(0x10000008, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;358        //watch_point_3_setting(0x1000000C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;359    
;;;360        //enable DWT control register
;;;361        DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
;;;362    
;;;363        return;
;;;364    }
;;;365    #endif
;;;366    
;;;367    APP_FLASH_TEXT_SECTION
;;;368    void ram_init(void)
;;;369    {
;;;370        //copy data on ro
;;;371        extern char Image$$RAM_DATA_ON$$RO$$Base[];
;;;372        extern char Load$$RAM_DATA_ON$$RO$$Base[];
;;;373        extern unsigned int Image$$RAM_DATA_ON$$RO$$Length;
;;;374    
;;;375        memcpy(Image$$RAM_DATA_ON$$RO$$Base,
;;;376               Load$$RAM_DATA_ON$$RO$$Base,
;;;377               (unsigned int)&Image$$RAM_DATA_ON$$RO$$Length);
;;;378    
;;;379        //copy data on rw
;;;380        extern char Image$$RAM_DATA_ON$$RW$$Base[];
;;;381        extern char Load$$RAM_DATA_ON$$RW$$Base[];
;;;382        extern unsigned int Image$$RAM_DATA_ON$$RW$$Length;
;;;383    
;;;384        memcpy(Image$$RAM_DATA_ON$$RW$$Base,
;;;385               Load$$RAM_DATA_ON$$RW$$Base,
;;;386               (unsigned int)&Image$$RAM_DATA_ON$$RW$$Length);
;;;387    
;;;388        //clear data on zi
;;;389        extern char Image$$RAM_DATA_ON$$ZI$$Base[];
;;;390        extern unsigned int Image$$RAM_DATA_ON$$ZI$$Length;
;;;391    
;;;392        memset(Image$$RAM_DATA_ON$$ZI$$Base,
;;;393               0,
;;;394               (unsigned int)&Image$$RAM_DATA_ON$$ZI$$Length);
;;;395    
;;;396        //copy cache ro
;;;397        extern char Image$$CACHE_DATA_ON$$RO$$Base[];
;;;398        extern char Load$$CACHE_DATA_ON$$RO$$Base[];
;;;399        extern unsigned int Image$$CACHE_DATA_ON$$RO$$Length;
;;;400    
;;;401        memcpy(Image$$CACHE_DATA_ON$$RO$$Base,
;;;402               Load$$CACHE_DATA_ON$$RO$$Base,
;;;403               (unsigned int)&Image$$CACHE_DATA_ON$$RO$$Length);
;;;404    
;;;405        //copy share cache ram rw
;;;406        extern char Image$$CACHE_DATA_ON$$RW$$Base[];
;;;407        extern char Load$$CACHE_DATA_ON$$RW$$Base[];
;;;408        extern unsigned int Image$$CACHE_DATA_ON$$RW$$Length;
;;;409    
;;;410        memcpy(Image$$CACHE_DATA_ON$$RW$$Base,
;;;411               Load$$CACHE_DATA_ON$$RW$$Base,
;;;412               (unsigned int)&Image$$CACHE_DATA_ON$$RW$$Length);
;;;413    
;;;414        //clear share cache ram zi
;;;415        extern char Image$$CACHE_DATA_ON$$ZI$$Base[];
;;;416        extern unsigned int Image$$CACHE_DATA_ON$$ZI$$Length;
;;;417    
;;;418        memset(Image$$CACHE_DATA_ON$$ZI$$Base,
;;;419               0,
;;;420               (unsigned int)&Image$$CACHE_DATA_ON$$ZI$$Length);
;;;421    }
;;;422    
;;;423    uint32_t random_seed_value;
;;;424    
;;;425    APP_FLASH_TEXT_SECTION
;;;426    void random_seed_init(void)
;;;427    {
;;;428        uint16_t crc16;
;;;429        uint8_t buf[DATA_SIZE_FOR_RANDOM_SEED];
;;;430        uint8_t *sour_addr = (uint8_t *)(OTP->appDataAddr + OTP->appDataSize + OTP->heapDataONSize);
;;;431    
;;;432        memcpy(buf, sour_addr, DATA_SIZE_FOR_RANDOM_SEED);
;;;433        crc16 = btxfcs(0, buf, DATA_SIZE_FOR_RANDOM_SEED);
;;;434    
;;;435        random_seed_value = (crc16 << 16) | (*(volatile uint32_t *)(0x4005817C) & 0xFFFF);
;;;436    
;;;437        random_seed_value *= platform_random(0xFFFFFFFF);
;;;438    
;;;439        srand(random_seed_value);
;;;440    
;;;441        for (int i = 0; i < (DATA_SIZE_FOR_RANDOM_SEED / 4); ++i)
;;;442        {
;;;443            *(uint32_t *)(sour_addr + i * 4) = rand();
;;;444        }
;;;445    
;;;446        random_seed_value = rand();
;;;447    }
;;;448    
;;;449    APP_FLASH_TEXT_SECTION
;;;450    void SystemInit(void)
;;;451    {
;;;452        //hci mode check and bypass app
;;;453        if (check_hci_mode_flag())
;;;454        {
;;;455            return;
;;;456        }
;;;457    
;;;458        //init pre_main and main functions
;;;459        extern void pre_main(void);
;;;460        app_pre_main = (APP_MAIN_FUNC)pre_main;
;;;461        app_main = (APP_MAIN_FUNC)common_main;
;;;462    
;;;463        /******** update otp here**********/
;;;464        //ram config
;;;465        OTP->appDataSize = APP_GLOBAL_SIZE;
;;;466        OTP->heapDataONSize = HEAP_DATA_ON_SIZE - DATA_SIZE_FOR_RANDOM_SEED;
;;;467    
;;;468        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;469    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;470        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
;;;471    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;472        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;473    #else
;;;474        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;475    #endif
;;;476    
;;;477        //sw timer config
;;;478    #ifdef TIMER_MAX_NUMBER
;;;479        //define TIMER_MAX_NUMBER in otp_config.h
;;;480        OTP->timerMaxNumber = TIMER_MAX_NUMBER;
;;;481    #endif
;;;482    
;;;483        //flash config
;;;484        /*config enable flash block proect depending on flash layout and flash id*/
;;;485    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;486        OTP->bp_enable = 1;
;;;487    #else
;;;488        OTP->bp_enable = 0;
;;;489    #endif
;;;490        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
;;;491    
;;;492    
;;;493        //os config
;;;494        /*config enable check task stack overflow*/
;;;495    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;496        OTP->checkForStackOverflow = 1;
;;;497    #else
;;;498        OTP->checkForStackOverflow = 0;
;;;499    #endif
;;;500    
;;;501    
;;;502        //platform config
;;;503        /*config enable platform assert*/
;;;504    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;505        OTP->enableASSERT = 1;
;;;506    #else
;;;507        OTP->enableASSERT = 0;
;;;508    #endif
;;;509    
;;;510        /*Print all log in log buffer before entering DLPS */
;;;511    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;512        OTP->printAllLogBeforeEnterDLPS = 1;
;;;513    #else
;;;514        OTP->printAllLogBeforeEnterDLPS = 0;
;;;515    #endif
;;;516    
;;;517        /*config enable log or not*/
;;;518    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;519        OTP->logDisable = 0;
;;;520    #else
;;;521        OTP->logDisable = 1;
;;;522    #endif
;;;523    
;;;524        /*config enable swd pinmux*/
;;;525    #if (SWD_PINMUX_ENABLE == 1)
;;;526        OTP->SWD_ENABLE = 1;
;;;527    #else
;;;528        OTP->SWD_ENABLE = 0;
;;;529    #endif
;;;530    
;;;531        /*config enable watch dog in rom*/
;;;532    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;533        OTP->wdgEnableInRom = 1;
;;;534    #else
;;;535        OTP->wdgEnableInRom = 0;
;;;536    #endif
;;;537    
;;;538        /*config watch dog mode in rom, defualt reset all*/
;;;539        OTP->wdgMode = ROM_WATCH_DOG_MODE;
;;;540    
;;;541        /*use os tick as log timestamp instead of TIM7*/
;;;542        OTP->log_timestamp_src = LOG_TIMESTAMP_OS;
;;;543    
;;;544    
;;;545        //app config
;;;546        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
;;;547        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
;;;548        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
;;;549        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
;;;550    
;;;551    #if ROM_OTA_LINKLOSS_RST
;;;552        OTP->ota_link_loss_reset = 1;
;;;553    #endif
;;;554        /*config bt stack parameters in rom*/
;;;555    #ifdef BT_STACK_CONFIG_ENABLE
;;;556        bt_stack_config_init();
;;;557    #endif
;;;558    
;;;559    //add more otp config here
;;;560    }
;;;561    
;;;562    //Note: call print_reset_reason() before ram_init();
;;;563    APP_FLASH_TEXT_SECTION
;;;564    void print_reset_reason(void)
;;;565    {
;;;566        if (check_reset_ram.check_reset_ram_pattern != RESET_RAM_PATTERN)
;;;567        {
;;;568            BOOT_PRINT_INFO0("RESET Reason: HW or OTA");
;;;569        }
;;;570        else
;;;571        {
;;;572            T_SW_RESET_REASON sw_reset_type = get_aon_record_reset_reason();
;;;573    
;;;574            if (sw_reset_type != (T_SW_RESET_REASON)0)
;;;575            {
;;;576                BOOT_PRINT_INFO1("RESET Reason: SW(reset except aon), TYPE 0x%x", sw_reset_type);
;;;577            }
;;;578            else //reset all will clear aon register
;;;579            {
;;;580                BOOT_PRINT_INFO1("RESET Reason: SW(reset all), TYPE 0x%x", check_reset_ram.check_reset_ram_type);
;;;581            }
;;;582        }
;;;583    }
;;;584    
;;;585    APP_FLASH_TEXT_SECTION
;;;586    void pre_main(void)
;;;587    {
;;;588        __disable_irq();
;;;589    
;;;590        print_reset_reason();  //Note: call this function before ram_init();
;;;591    
;;;592        ram_init();
;;;593    
;;;594        random_seed_init();
;;;595    
;;;596        load_overlay(OVERLAY_SCENARIO_BOOT_ONCE);
;;;597    
;;;598        //reset NVIC of DMA channel used in image decryption
;;;599        NVIC_DisableIRQ(GDMA0_Channel2_IRQn);
;;;600        NVIC_DisableIRQ(GDMA0_Channel3_IRQn);
;;;601    
;;;602        setlocale(LC_ALL, "C");
;;;603    
;;;604        BOOT_PRINT_ERROR2("SDK Ver: %s, Build Time: %s",
;;;605                          TRACE_STRING(VERSION_BUILD_STR),
;;;606                          TRACE_STRING(BUILDING_TIME));
;;;607    
;;;608        AppUpdateVectorTable();
;;;609    
;;;610    #if (DEBUG_WATCHPOINT_ENABLE == 1)
;;;611        debug_monitor_enable();
;;;612    #endif
;;;613    
;;;614        if (app_pre_main_cb)
;;;615        {
;;;616            app_pre_main_cb();
;;;617        }
;;;618    
;;;619        return;
;;;620    }
;;;621    /**
;;;622     * @brief  update vector table in app
;;;623     * @param  none
;;;624     * @return none
;;;625      */
;;;626    OVERLAY_SECTION_BOOT_ONCE
;;;627    static void AppUpdateVectorTable(void)
;;;628    {
;;;629        extern uint32_t Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;630        extern uint32_t Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;631        extern void Default_Handler(void);
;;;632        const char *SysException[] =
;;;633        {
;;;634            "InitialSP", "Reset", "NMI", "HardFault", "MemManage", "BusFault", "UsageFault", "Rsvd",
;;;635            "Rsvd", "Rsvd", "Rsvd", "SVC", "DebugMon", "Rsvd", "PendSV", "SysTick"
;;;636        };
;;;637        const char *ExtIrq[] =
;;;638        {
;;;639            "System", "WDG", "BTMAC", "TIM3", "TIM2", "Platform", "I2S0_TX", "I2S0_RX", "Timer4-7",
;;;640            "GPIO4", "GPIO5", "UART1", "UART0", "RTC", "SPI0", "SPI1", "I2C0", "I2C1", "ADC",
;;;641            "Peripheral", "GDMA0 Channel0", "GDMA0 Channel1", "GDMA0 Channel2", "GDMA0 Channel3",
;;;642            "GDMA0 Channel4", "GDMA0 Channel5", "GPIO_Group3", "GPIO_Group2", "IR", "GPIO_Group1",
;;;643            "GPIO_Group0", "UART2", "TIM4", "TIM5", "TIM6", "TIM7", "SPI_Flash", "Qdecode",
;;;644            "Keyscan", "SPI2W", "LPCOMP", "PTA_Mailbox", "SPORT1 TX", "SPORT1 RX", "LCD"
;;;645        };
;;;646    
;;;647        IRQ_Fun *pRamVector    = (IRQ_Fun *)VTOR_RAM_ADDR;
;;;648        IRQ_Fun *pAppVector    = (IRQ_Fun *)&Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;649        uint32_t AppVectorSize = (uint32_t)&Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;650        uint32_t i             = 0;
;;;651    
;;;652        if (SCB->VTOR != VTOR_RAM_ADDR)
;;;653        {
;;;654            RamVectorTableInit(VTOR_RAM_ADDR);
;;;655        }
;;;656    
;;;657        /* Update APP defined handlers */
;;;658        for (i = 0; i < AppVectorSize / 4; ++i)
;;;659        {
;;;660            if (i == 1) //skip reset_handler remap
;;;661            {
;;;662                continue;
;;;663            }
;;;664    
;;;665            if ((pAppVector[i] != Default_Handler) && (pAppVector[i] != 0))
;;;666            {
;;;667                if (i < System_VECTORn)
;;;668                {
;;;669                    OS_PRINT_WARN1("Warning! %s is updated by APP!", TRACE_STRING(SysException[i]));
;;;670                }
;;;671                else
;;;672                {
;;;673                    OS_PRINT_WARN1("Warning! ISR %s is updated by APP!",
;;;674                                   TRACE_STRING(ExtIrq[i - System_VECTORn]));
;;;675                }
;;;676    
;;;677                pRamVector[i] = pAppVector[i];
;;;678            }
;;;679        }
;;;680    
;;;681        __DMB();
;;;682        __DSB();
;;;683    }
;;;684    /**
;;;685     * @brief  GPIO Group3 Handler
;;;686     * @param  none
;;;687     * @return none
;;;688      */
;;;689    DATA_RAM_FUNCTION void GPIO_Group3_Handler(void)
;;;690    {
;;;691        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;692    
;;;693        //Check exact IRQ function
;;;694        if (GPIOIrqStatus & BIT3)
;;;695        {
;;;696            GPIO3_Handler();
;;;697        }
;;;698        if (GPIOIrqStatus & BIT7)
;;;699        {
;;;700            GPIO7_Handler();
;;;701        }
;;;702        if (GPIOIrqStatus & BIT11)
;;;703        {
;;;704            GPIO11_Handler();
;;;705        }
;;;706        if (GPIOIrqStatus & BIT15)
;;;707        {
;;;708            GPIO15_Handler();
;;;709        }
;;;710        if (GPIOIrqStatus & BIT19)
;;;711        {
;;;712            GPIO19_Handler();
;;;713        }
;;;714        if (GPIOIrqStatus & BIT23)
;;;715        {
;;;716            GPIO23_Handler();
;;;717        }
;;;718        if (GPIOIrqStatus & BIT27)
;;;719        {
;;;720            GPIO27_Handler();
;;;721        }
;;;722        if (GPIOIrqStatus & BIT31)
;;;723        {
;;;724            GPIO31_Handler();
;;;725        }
;;;726    }
;;;727    /**
;;;728     * @brief  GPIO Group2 Handler
;;;729     * @param  none
;;;730     * @return none
;;;731      */
;;;732    DATA_RAM_FUNCTION void GPIO_Group2_Handler(void)
;;;733    {
;;;734        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;735    
;;;736        //Check exact IRQ function
;;;737        if (GPIOIrqStatus & BIT2)
;;;738        {
;;;739            GPIO2_Handler();
;;;740        }
;;;741        if (GPIOIrqStatus & BIT6)
;;;742        {
;;;743            GPIO6_Handler();
;;;744        }
;;;745        if (GPIOIrqStatus & BIT10)
;;;746        {
;;;747            GPIO10_Handler();
;;;748        }
;;;749        if (GPIOIrqStatus & BIT14)
;;;750        {
;;;751            GPIO14_Handler();
;;;752        }
;;;753        if (GPIOIrqStatus & BIT18)
;;;754        {
;;;755            GPIO18_Handler();
;;;756        }
;;;757        if (GPIOIrqStatus & BIT22)
;;;758        {
;;;759            GPIO22_Handler();
;;;760        }
;;;761        if (GPIOIrqStatus & BIT26)
;;;762        {
;;;763            GPIO26_Handler();
;;;764        }
;;;765        if (GPIOIrqStatus & BIT30)
;;;766        {
;;;767            GPIO30_Handler();
;;;768        }
;;;769    }
;;;770    /**
;;;771     * @brief  GPIO Group1 Handler
;;;772     * @param  none
;;;773     * @return none
;;;774      */
;;;775    DATA_RAM_FUNCTION void GPIO_Group1_Handler(void)
;;;776    {
;;;777        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;778    
;;;779        //Check exact IRQ function
;;;780        if (GPIOIrqStatus & BIT1)
;;;781        {
;;;782            GPIO1_Handler();
;;;783        }
;;;784        if (GPIOIrqStatus & BIT9)
;;;785        {
;;;786            GPIO9_Handler();
;;;787        }
;;;788        if (GPIOIrqStatus & BIT13)
;;;789        {
;;;790            GPIO13_Handler();
;;;791        }
;;;792        if (GPIOIrqStatus & BIT17)
;;;793        {
;;;794            GPIO17_Handler();
;;;795        }
;;;796        if (GPIOIrqStatus & BIT21)
;;;797        {
;;;798            GPIO21_Handler();
;;;799        }
;;;800        if (GPIOIrqStatus & BIT25)
;;;801        {
;;;802            GPIO25_Handler();
;;;803        }
;;;804        if (GPIOIrqStatus & BIT29)
;;;805        {
;;;806            GPIO29_Handler();
;;;807        }
;;;808    }
;;;809    /**
;;;810     * @brief  GPIO Group0 Handler
;;;811     * @param  none
;;;812     * @return none
;;;813      */
;;;814    DATA_RAM_FUNCTION void GPIO_Group0_Handler(void)
;;;815    {
;;;816        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;817    
;;;818        //Check exact IRQ function
;;;819        if (GPIOIrqStatus & BIT0)
;;;820        {
;;;821            GPIO0_Handler();
;;;822        }
;;;823        if (GPIOIrqStatus & BIT8)
;;;824        {
;;;825            GPIO8_Handler();
;;;826        }
;;;827        if (GPIOIrqStatus & BIT12)
;;;828        {
;;;829            GPIO12_Handler();
;;;830        }
;;;831        if (GPIOIrqStatus & BIT16)
;;;832        {
;;;833            GPIO16_Handler();
;;;834        }
;;;835        if (GPIOIrqStatus & BIT20)
;;;836        {
;;;837            GPIO20_Handler();
;;;838        }
;;;839        if (GPIOIrqStatus & BIT24)
;;;840        {
;;;841            GPIO24_Handler();
;;;842        }
;;;843        if (GPIOIrqStatus & BIT28)
;;;844        {
;;;845            GPIO28_Handler();
;;;846        }
;;;847    }
;;;848    
;;;849    void WDG_SystemReset(T_WDG_MODE wdg_mode, T_SW_RESET_REASON reset_reason)
;;;850    {
;;;851        uint32_t parm = wdg_mode | (reset_reason << 8);
        0x0080e79a:    ea402101    @..!    ORR      r1,r0,r1,LSL #8
;;;852        SystemCall(SYSTEM_CALL_WDG_RESET, parm);
        0x0080e79e:    2001        .       MOVS     r0,#1
        0x0080e7a0:    f7f89d7e    ..~.    B        SystemCall ; 0x72a0
    flash_try_high_speed
;;;853    }
;;;854    
;;;855    /**
;;;856     * @brief  flash try to switch to high speed bit mode
;;;857     * @note  switch back to 1 bit mode, if flash switch to high speed bit mode fail
;;;858     * @param  bit_mode config bit mode @ref T_FLASH_MODE
;;;859     * @retval 0 fail
;;;860     * @retval 1 success
;;;861      */
;;;862    uint32_t flash_try_high_speed(T_FLASH_MODE bit_mode)
;;;863    {
        0x0080e7a4:    b510        ..      PUSH     {r4,lr}
;;;864        uint32_t result = 0;
;;;865        OTP->bit_mode = bit_mode;
        0x0080e7a6:    f44f1400    O...    MOV      r4,#0x200000
        0x0080e7aa:    2200        ."      MOVS     r2,#0
        0x0080e7ac:    f894134c    ..L.    LDRB     r1,[r4,#0x34c]
        0x0080e7b0:    f3600101    `...    BFI      r1,r0,#0,#2
        0x0080e7b4:    f884134c    ..L.    STRB     r1,[r4,#0x34c]
;;;866        result = flash_ioctl(flash_ioctrl_try_high_speed, 0, 0);
        0x0080e7b8:    4611        .F      MOV      r1,r2
        0x0080e7ba:    f2450002    E...    MOV      r0,#0x5002
        0x0080e7be:    f7fddc58    ..X.    BL       flash_ioctl ; 0xc072
;;;867        //if try fail, set back OTP->bit_mode to one bit mode
;;;868        if (!result)
        0x0080e7c2:    2800        .(      CMP      r0,#0
        0x0080e7c4:    d105        ..      BNE      0x80e7d2 ; flash_try_high_speed + 46
;;;869        {
;;;870            OTP->bit_mode = FLASH_MODE_1BIT;
        0x0080e7c6:    f894134c    ..L.    LDRB     r1,[r4,#0x34c]
        0x0080e7ca:    f0210103    !...    BIC      r1,r1,#3
        0x0080e7ce:    f884134c    ..L.    STRB     r1,[r4,#0x34c]
;;;871        }
;;;872        return result;
;;;873    }
        0x0080e7d2:    bd10        ..      POP      {r4,pc}
    malloc
;;;874    
;;;875    void *malloc(size_t size)
;;;876    {
;;;877        return os_mem_alloc(RAM_TYPE_DATA_ON, size);
        0x0080e7d4:    4601        .F      MOV      r1,r0
        0x0080e7d6:    f240336d    @.m3    MOV      r3,#0x36d
        0x0080e7da:    4a29        )J      LDR      r2,[pc,#164] ; [0x80e880] = 0x810b64
        0x0080e7dc:    2000        .       MOVS     r0,#0
        0x0080e7de:    f417b2bf    ....    B        os_mem_alloc_intern ; 0x25d60
    calloc
;;;878    }
;;;879    
;;;880    void *calloc(size_t n, size_t size)
;;;881    {
;;;882        return os_mem_zalloc(RAM_TYPE_DATA_ON, n * size);
        0x0080e7e2:    4a27        'J      LDR      r2,[pc,#156] ; [0x80e880] = 0x810b64
        0x0080e7e4:    4341        AC      MULS     r1,r0,r1
        0x0080e7e6:    1dd2        ..      ADDS     r2,r2,#7
        0x0080e7e8:    f2403372    @.r3    MOV      r3,#0x372
        0x0080e7ec:    2000        .       MOVS     r0,#0
        0x0080e7ee:    f417b2e3    ....    B        os_mem_zalloc_intern ; 0x25db8
    realloc
;;;883    }
;;;884    
;;;885    void *realloc(void *ptr, size_t size)
;;;886    {
        0x0080e7f2:    b510        ..      PUSH     {r4,lr}
        0x0080e7f4:    460c        .F      MOV      r4,r1
        0x0080e7f6:    b108        ..      CBZ      r0,0x80e7fc ; realloc + 10
;;;887        if (ptr)
;;;888        {
;;;889            os_mem_free(ptr);
        0x0080e7f8:    f417f33d    ..=.    BL       os_mem_free ; 0x25e76
;;;890        }
;;;891    
;;;892        return os_mem_alloc(RAM_TYPE_DATA_ON, size);
        0x0080e7fc:    4a20         J      LDR      r2,[pc,#128] ; [0x80e880] = 0x810b64
        0x0080e7fe:    4621        !F      MOV      r1,r4
        0x0080e800:    320e        .2      ADDS     r2,r2,#0xe
        0x0080e802:    e8bd4010    ...@    POP      {r4,lr}
        0x0080e806:    f44f735f    O._s    MOV      r3,#0x37c
        0x0080e80a:    2000        .       MOVS     r0,#0
        0x0080e80c:    f417b2a8    ....    B        os_mem_alloc_intern ; 0x25d60
    free
;;;893    }
;;;894    
;;;895    void free(void *ptr)
;;;896    {
;;;897        os_mem_free(ptr);
        0x0080e810:    f417b331    ..1.    B        os_mem_free ; 0x25e76
    app_cb0_wdg_reset
;;;898    }
;;;899    
;;;900    void app_cb0_wdg_reset(T_WDG_MODE wdg_mode, T_SW_RESET_REASON reset_reason)
;;;901    {
;;;902        check_reset_ram.check_reset_ram_type = reset_reason;
        0x0080e814:    4a1b        .J      LDR      r2,[pc,#108] ; [0x80e884] = 0x207f4c
        0x0080e816:    70d1        .p      STRB     r1,[r2,#3]
        0x0080e818:    4a1b        .J      LDR      r2,[pc,#108] ; [0x80e888] = 0x20801c
        0x0080e81a:    6812        .h      LDR      r2,[r2,#0]
;;; .\..\source\cmsis\system_rtl8762c.c (901)
        0x0080e81c:    2a00        .*      CMP      r2,#0
        0x0080e81e:    d000        ..      BEQ      0x80e822 ; app_cb0_wdg_reset + 14
;;;902        check_reset_ram.check_reset_ram_type = reset_reason;
;;;903    
;;;904        if (user_wdg_cb)
;;;905        {
;;;906            if (user_wdg_cb(wdg_mode, reset_reason))
        0x0080e820:    4710        .G      BX       r2
;;;907            {
;;;908                return;
;;;909            }
;;;910        }
;;;911    
;;;912        //do something necessary before watch dog reset
;;;913    }
        0x0080e822:    4770        pG      BX       lr
    app_cb5_dfu_status
;;;914    
;;;915    void app_cb5_dfu_status(DFU_PROGRESS_STATUS status, uint32_t length)
;;;916    {
;;;917    //    uint32_t value = 0;
;;;918    //    switch(status)
;;;919    //    {
;;;920    //        case DFU_START:
;;;921    //            value = *((uint32_t *)0x180e000);
;;;922    //            DBG_DIRECT("DFU start, total length = %d, value = 0x%x", length, value);
;;;923    //            break;
;;;924    //        case DFU_DOING:
;;;925    //            value = *((uint32_t *)0x180e000);
;;;926    //            DBG_DIRECT("DFU doing, paccket length = %d, value = 0x%x", length, value);
;;;927    //            break;
;;;928    //        case DFU_END:
;;;929    //            value = *((uint32_t *)0x180e000);
;;;930    //            DBG_DIRECT("DFU end, check result = %d, value = 0x%x", length, value);
;;;931    //            break;
;;;932    //        default:
;;;933    //            DBG_DIRECT("wrong status input");
;;;934    //    }
;;;935        if (user_dfu_status_cb)
        0x0080e824:    4a19        .J      LDR      r2,[pc,#100] ; [0x80e88c] = 0x208020
        0x0080e826:    6812        .h      LDR      r2,[r2,#0]
;;; .\..\source\cmsis\system_rtl8762c.c (916)
        0x0080e828:    2a00        .*      CMP      r2,#0
        0x0080e82a:    d000        ..      BEQ      0x80e82e ; app_cb5_dfu_status + 10
;;;917    //    uint32_t value = 0;
;;;918    //    switch(status)
;;;919    //    {
;;;920    //        case DFU_START:
;;;921    //            value = *((uint32_t *)0x180e000);
;;;922    //            DBG_DIRECT("DFU start, total length = %d, value = 0x%x", length, value);
;;;923    //            break;
;;;924    //        case DFU_DOING:
;;;925    //            value = *((uint32_t *)0x180e000);
;;;926    //            DBG_DIRECT("DFU doing, paccket length = %d, value = 0x%x", length, value);
;;;927    //            break;
;;;928    //        case DFU_END:
;;;929    //            value = *((uint32_t *)0x180e000);
;;;930    //            DBG_DIRECT("DFU end, check result = %d, value = 0x%x", length, value);
;;;931    //            break;
;;;932    //        default:
;;;933    //            DBG_DIRECT("wrong status input");
;;;934    //    }
;;;935        if (user_dfu_status_cb)
;;;936        {
;;;937            if (user_dfu_status_cb(status, length))
        0x0080e82c:    4710        .G      BX       r2
;;;938            {
;;;939                return;
;;;940            }
;;;941        }
;;;942    }
        0x0080e82e:    4770        pG      BX       lr
    NVIC_DisableIRQ
;;; ..\include\SDK\platform\cmsis\core_cm4.h
;;;1659       NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
        0x0080e830:    f000021f    ....    AND      r2,r0,#0x1f
        0x0080e834:    2101        .!      MOVS     r1,#1
        0x0080e836:    4091        .@      LSLS     r1,r1,r2
        0x0080e838:    0940        @.      LSRS     r0,r0,#5
        0x0080e83a:    0080        ..      LSLS     r0,r0,#2
        0x0080e83c:    f10020e0    ...     ADD      r0,r0,#0xe000e000
        0x0080e840:    f8c01180    ....    STR      r1,[r0,#0x180]
;;;1660   }
        0x0080e844:    4770        pG      BX       lr
    $d
        0x0080e846:    0000        ..      DCW    0
        0x0080e848:    53206e49    In S    DCD    1394634313
        0x0080e84c:    4d20436f    oC M    DCD    1293960047
        0x0080e850:    0065646f    ode.    DCD    6644847
        0x0080e854:    4e524157    WARN    DCD    1314013527
        0x0080e858:    3a474e49    ING:    DCD    977751625
        0x0080e85c:    206e4920     In     DCD    544098592
        0x0080e860:    20494348    HCI     DCD    541672264
        0x0080e864:    65646f4d    Mode    DCD    1701080909
        0x0080e868:    6977202c    , wi    DCD    1769414700
        0x0080e86c:    6e206c6c    ll n    DCD    1847618668
        0x0080e870:    7220746f    ot r    DCD    1914729583
        0x0080e874:    41206e75    un A    DCD    1092644469
        0x0080e878:    54205050    PP T    DCD    1411403856
        0x0080e87c:    006b7361    ask.    DCD    7041889
        0x0080e880:    00810b64    d...    DCD    8457060
        0x0080e884:    00207f4c    L. .    DCD    2129740
        0x0080e888:    0020801c    .. .    DCD    2129948
        0x0080e88c:    00208020     . .    DCD    2129952
    $t
    .text
    app_send_msg_to_apptask
;;; .\..\source\cmsis\app_task.c
;;;79     {
        0x0080e890:    b57c        |.      PUSH     {r2-r6,lr}
;;;80         uint8_t event = EVENT_IO_TO_APP;
        0x0080e892:    2202        ."      MOVS     r2,#2
        0x0080e894:    f88d2004    ...     STRB     r2,[sp,#4]
;;;81     
;;;82         if (os_msg_send(io_queue_handle, p_msg, 0) == false)
        0x0080e898:    2252        R"      MOVS     r2,#0x52
        0x0080e89a:    4c38        8L      LDR      r4,[pc,#224] ; [0x80e97c] = 0x20802c
        0x0080e89c:    9200        ..      STR      r2,[sp,#0]
        0x0080e89e:    4601        .F      MOV      r1,r0
        0x0080e8a0:    4b35        5K      LDR      r3,[pc,#212] ; [0x80e978] = 0x810c70
        0x0080e8a2:    2200        ."      MOVS     r2,#0
        0x0080e8a4:    68a0        .h      LDR      r0,[r4,#8]
        0x0080e8a6:    f417f39d    ....    BL       os_msg_send_intern ; 0x25fe4
        0x0080e8aa:    4d35        5M      LDR      r5,[pc,#212] ; [0x80e980] = 0x21103000
        0x0080e8ac:    b150        P.      CBZ      r0,0x80e8c4 ; app_send_msg_to_apptask + 52
        0x0080e8ae:    2057        W       MOVS     r0,#0x57
        0x0080e8b0:    9000        ..      STR      r0,[sp,#0]
        0x0080e8b2:    4b31        1K      LDR      r3,[pc,#196] ; [0x80e978] = 0x810c70
        0x0080e8b4:    2200        ."      MOVS     r2,#0
        0x0080e8b6:    a901        ..      ADD      r1,sp,#4
        0x0080e8b8:    6860        `h      LDR      r0,[r4,#4]
        0x0080e8ba:    f417f393    ....    BL       os_msg_send_intern ; 0x25fe4
        0x0080e8be:    b120         .      CBZ      r0,0x80e8ca ; app_send_msg_to_apptask + 58
        0x0080e8c0:    2001        .       MOVS     r0,#1
        0x0080e8c2:    bd7c        |.      POP      {r2-r6,pc}
;;;83         {
;;;84             APP_PRINT_ERROR0("send_io_msg_to_app fail");
        0x0080e8c4:    2200        ."      MOVS     r2,#0
        0x0080e8c6:    492f        /I      LDR      r1,[pc,#188] ; [0x80e984] = 0x88000e8
;;;85             return false;
        0x0080e8c8:    e002        ..      B        0x80e8d0 ; app_send_msg_to_apptask + 64
;;;86         }
;;;87         if (os_msg_send(evt_queue_handle, &event, 0) == false)
;;;88         {
;;;89             APP_PRINT_ERROR0("send_evt_msg_to_app fail");
        0x0080e8ca:    492e        .I      LDR      r1,[pc,#184] ; [0x80e984] = 0x88000e8
        0x0080e8cc:    2200        ."      MOVS     r2,#0
        0x0080e8ce:    311c        .1      ADDS     r1,r1,#0x1c
        0x0080e8d0:    4628        (F      MOV      r0,r5
        0x0080e8d2:    f7f9d8c4    ....    BL       log_buffer ; 0x7a5e
;;;90             return false;
        0x0080e8d6:    2000        .       MOVS     r0,#0
;;;91         }
;;;92         return true;
;;;93     }
        0x0080e8d8:    bd7c        |.      POP      {r2-r6,pc}
    app_main_task
;;;94     /**
;;;95      * @brief  Initialize App task
;;;96      * @return void
;;;97      */
;;;98     void app_task_init()
;;;99     {
;;;100        os_task_create(&app_task_handle, "app", app_main_task, 0, APP_TASK_STACK_SIZE,
;;;101                       APP_TASK_PRIORITY);
;;;102    }
;;;103    
;;;104    /**
;;;105     * @brief        App task to handle events & messages
;;;106     * @param[in]    p_params    Parameters sending to the task
;;;107     * @return       void
;;;108     */
;;;109    void driver_init(void);
;;;110    void app_main_task(void *p_param)
;;;111    {
        0x0080e8da:    b51f        ..      PUSH     {r0-r4,lr}
;;;112        uint8_t event;
;;;113    
;;;114        os_msg_queue_create(&io_queue_handle, MAX_NUMBER_OF_IO_MESSAGE, sizeof(T_IO_MSG));
        0x0080e8dc:    2072        r       MOVS     r0,#0x72
        0x0080e8de:    9000        ..      STR      r0,[sp,#0]
        0x0080e8e0:    4b25        %K      LDR      r3,[pc,#148] ; [0x80e978] = 0x810c70
        0x0080e8e2:    4826        &H      LDR      r0,[pc,#152] ; [0x80e97c] = 0x20802c
        0x0080e8e4:    3318        .3      ADDS     r3,r3,#0x18
        0x0080e8e6:    2208        ."      MOVS     r2,#8
        0x0080e8e8:    2120         !      MOVS     r1,#0x20
        0x0080e8ea:    3008        .0      ADDS     r0,r0,#8
        0x0080e8ec:    f417f302    ....    BL       os_msg_queue_create_intern ; 0x25ef4
;;;115        os_msg_queue_create(&evt_queue_handle, MAX_NUMBER_OF_EVENT_MESSAGE, sizeof(uint8_t));
        0x0080e8f0:    2073        s       MOVS     r0,#0x73
        0x0080e8f2:    9000        ..      STR      r0,[sp,#0]
        0x0080e8f4:    4b20         K      LDR      r3,[pc,#128] ; [0x80e978] = 0x810c70
        0x0080e8f6:    4821        !H      LDR      r0,[pc,#132] ; [0x80e97c] = 0x20802c
        0x0080e8f8:    3318        .3      ADDS     r3,r3,#0x18
        0x0080e8fa:    2201        ."      MOVS     r2,#1
        0x0080e8fc:    2140        @!      MOVS     r1,#0x40
        0x0080e8fe:    1d00        ..      ADDS     r0,r0,#4
        0x0080e900:    f417f2f8    ....    BL       os_msg_queue_create_intern ; 0x25ef4
;;;116    
;;;117        gap_start_bt_stack(evt_queue_handle, io_queue_handle, MAX_NUMBER_OF_GAP_MESSAGE);
        0x0080e904:    4c1d        .L      LDR      r4,[pc,#116] ; [0x80e97c] = 0x20802c
        0x0080e906:    2220         "      MOVS     r2,#0x20
        0x0080e908:    e9d40101    ....    LDRD     r0,r1,[r4,#4]
        0x0080e90c:    f43df2ad    =...    BL       gap_start_bt_stack ; 0x4be6a
;;;118    
;;;119    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;120        extern void reset_watch_dog_timer_enable(void);
;;;121        reset_watch_dog_timer_enable();
;;;122    #endif
;;;123    
;;;124    #if (AON_WDG_ENABLE == 1)
;;;125        aon_wdg_init(1, AON_WDG_TIME_OUT_PERIOD_SECOND);
;;;126    #endif
;;;127    
;;;128        //data_uart_init(evt_queue_handle, io_queue_handle);
;;;129        //user_cmd_init(&user_cmd_if, "scatternet");
;;;130        driver_init();
        0x0080e910:    f000f86d    ..m.    BL       driver_init ; 0x80e9ee
;;;131        while (true)
;;;132        {
;;;133            if (os_msg_recv(evt_queue_handle, &event, 0xFFFFFFFF) == true)
        0x0080e914:    2585        .%      MOVS     r5,#0x85
        0x0080e916:    f04f37ff    O..7    MOV      r7,#0xffffffff
        0x0080e91a:    268a        .&      MOVS     r6,#0x8a
        0x0080e91c:    4b16        .K      LDR      r3,[pc,#88] ; [0x80e978] = 0x810c70
        0x0080e91e:    9500        ..      STR      r5,[sp,#0]
        0x0080e920:    3318        .3      ADDS     r3,r3,#0x18
        0x0080e922:    463a        :F      MOV      r2,r7
        0x0080e924:    a903        ..      ADD      r1,sp,#0xc
        0x0080e926:    6860        `h      LDR      r0,[r4,#4]
        0x0080e928:    f417f38c    ....    BL       os_msg_recv_intern ; 0x26044
        0x0080e92c:    2800        .(      CMP      r0,#0
        0x0080e92e:    d0f5        ..      BEQ      0x80e91c ; app_main_task + 66
;;;134            {
;;;135                if (event == EVENT_IO_TO_APP)
        0x0080e930:    f89d000c    ....    LDRB     r0,[sp,#0xc]
        0x0080e934:    2802        .(      CMP      r0,#2
        0x0080e936:    d002        ..      BEQ      0x80e93e ; app_main_task + 100
        0x0080e938:    f43df304    =...    BL       gap_handle_msg ; 0x4bf44
        0x0080e93c:    e7ee        ..      B        0x80e91c ; app_main_task + 66
;;;136                {
;;;137                    T_IO_MSG io_msg;
;;;138                    if (os_msg_recv(io_queue_handle, &io_msg, 0) == true)
        0x0080e93e:    4b0e        .K      LDR      r3,[pc,#56] ; [0x80e978] = 0x810c70
        0x0080e940:    9600        ..      STR      r6,[sp,#0]
        0x0080e942:    3318        .3      ADDS     r3,r3,#0x18
        0x0080e944:    2200        ."      MOVS     r2,#0
        0x0080e946:    a901        ..      ADD      r1,sp,#4
        0x0080e948:    68a0        .h      LDR      r0,[r4,#8]
        0x0080e94a:    f417f37b    ..{.    BL       os_msg_recv_intern ; 0x26044
        0x0080e94e:    2800        .(      CMP      r0,#0
        0x0080e950:    d0e4        ..      BEQ      0x80e91c ; app_main_task + 66
        0x0080e952:    e9dd0101    ....    LDRD     r0,r1,[sp,#4]
;;;139                    {
;;;140                        app_handle_io_msg(io_msg);
        0x0080e956:    f001fcc5    ....    BL       app_handle_io_msg ; 0x8102e4
        0x0080e95a:    e7df        ..      B        0x80e91c ; app_main_task + 66
    app_task_init
;;; .\..\source\cmsis\app_task.c (99)
        0x0080e95c:    b51c        ..      PUSH     {r2-r4,lr}
;;;100        os_task_create(&app_task_handle, "app", app_main_task, 0, APP_TASK_STACK_SIZE,
        0x0080e95e:    2101        .!      MOVS     r1,#1
        0x0080e960:    f44f60c0    O..`    MOV      r0,#0x600
        0x0080e964:    2300        .#      MOVS     r3,#0
        0x0080e966:    f2af028d    ....    ADR      r2,{pc}-0x8b ; 0x80e8db
        0x0080e96a:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0080e96e:    a106        ..      ADR      r1,{pc}+0x1a ; 0x80e988
        0x0080e970:    4802        .H      LDR      r0,[pc,#8] ; [0x80e97c] = 0x20802c
        0x0080e972:    f418f02d    ..-.    BL       os_task_create ; 0x269d0
;;;101                       APP_TASK_PRIORITY);
;;;102    }
        0x0080e976:    bd1c        ..      POP      {r2-r4,pc}
    $d
        0x0080e978:    00810c70    p...    DCD    8457328
        0x0080e97c:    0020802c    ,. .    DCD    2129964
        0x0080e980:    21103000    .0.!    DCD    554708992
        0x0080e984:    088000e8    ....    DCD    142606568
        0x0080e988:    00707061    app.    DCD    7368801
    $t
    .text
    PINMUX_Configuration
;;; .\..\source\cmsis\iohandle.c
;;;39     {
        0x0080e98c:    b510        ..      PUSH     {r4,lr}
;;;40         Pinmux_Config(LED, DWGPIO);
        0x0080e98e:    215a        Z!      MOVS     r1,#0x5a
        0x0080e990:    2001        .       MOVS     r0,#1
        0x0080e992:    f402f4ef    ....    BL       Pinmux_Config ; 0x11374
;;;41         Pinmux_Config(BEEP, DWGPIO);
        0x0080e996:    215a        Z!      MOVS     r1,#0x5a
        0x0080e998:    2002        .       MOVS     r0,#2
        0x0080e99a:    f402f4eb    ....    BL       Pinmux_Config ; 0x11374
;;;42         Pinmux_Config(KEY, DWGPIO);
        0x0080e99e:    215a        Z!      MOVS     r1,#0x5a
        0x0080e9a0:    e8bd4010    ...@    POP      {r4,lr}
        0x0080e9a4:    2014        .       MOVS     r0,#0x14
        0x0080e9a6:    f402b4e5    ....    B        Pinmux_Config ; 0x11374
    PAD_Configuration
;;;43     
;;;44         return;
;;;45     }
;;;46     /**
;;;47      * @brief    pad configuration
;;;48      * @return   void
;;;49      */
;;;50     void PAD_Configuration(void)
;;;51     {
        0x0080e9aa:    b57c        |.      PUSH     {r2-r6,lr}
;;;52         /* Keypad pad config */
;;;53         Pad_Config(LED, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0080e9ac:    2501        .%      MOVS     r5,#1
        0x0080e9ae:    2400        .$      MOVS     r4,#0
        0x0080e9b0:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0080e9b4:    4623        #F      MOV      r3,r4
        0x0080e9b6:    462a        *F      MOV      r2,r5
        0x0080e9b8:    4629        )F      MOV      r1,r5
        0x0080e9ba:    4628        (F      MOV      r0,r5
        0x0080e9bc:    f402f50e    ....    BL       Pad_Config ; 0x113dc
;;;54         Pad_Config(BEEP, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0080e9c0:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0080e9c4:    2201        ."      MOVS     r2,#1
        0x0080e9c6:    2300        .#      MOVS     r3,#0
        0x0080e9c8:    4611        .F      MOV      r1,r2
        0x0080e9ca:    2002        .       MOVS     r0,#2
        0x0080e9cc:    f402f506    ....    BL       Pad_Config ; 0x113dc
;;;55         Pad_Config(KEY, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0080e9d0:    2301        .#      MOVS     r3,#1
        0x0080e9d2:    9400        ..      STR      r4,[sp,#0]
        0x0080e9d4:    461a        .F      MOV      r2,r3
        0x0080e9d6:    4619        .F      MOV      r1,r3
        0x0080e9d8:    2014        .       MOVS     r0,#0x14
        0x0080e9da:    9401        ..      STR      r4,[sp,#4]
        0x0080e9dc:    f402f4fe    ....    BL       Pad_Config ; 0x113dc
;;;56         return;
;;;57     }
        0x0080e9e0:    bd7c        |.      POP      {r2-r6,pc}
    RCC_Configuration
;;;58     /**
;;;59      * @brief    rcc configuration
;;;60      * @return   void
;;;61      */
;;;62     void RCC_Configuration(void)
;;;63     {
;;;64         RCC_PeriphClockCmd(APBPeriph_GPIO, APBPeriph_GPIO_CLOCK, ENABLE);
        0x0080e9e2:    2201        ."      MOVS     r2,#1
        0x0080e9e4:    f04f5104    O..Q    MOV      r1,#0x21000000
        0x0080e9e8:    48f7        .H      LDR      r0,[pc,#988] ; [0x80edc8] = 0xc000100
        0x0080e9ea:    f000bb13    ....    B.W      RCC_PeriphClockCmd ; 0x80f014
    driver_init
;;;65         return;
;;;66     }
;;;67     
;;;68     /**
;;;69      * @brief    Contains the initialization of peripherals
;;;70      * @note     Both new architecture driver and legacy driver initialization method can be used
;;;71      * @return   void
;;;72      */
;;;73     void driver_init(void)
;;;74     {
        0x0080e9ee:    b530        0.      PUSH     {r4,r5,lr}
        0x0080e9f0:    b087        ..      SUB      sp,sp,#0x1c
;;;75         GPIO_InitTypeDef Gpio_Struct;
;;;76         GPIO_StructInit(&Gpio_Struct);
        0x0080e9f2:    4668        hF      MOV      r0,sp
        0x0080e9f4:    f000fab1    ....    BL       GPIO_StructInit ; 0x80ef5a
;;;77         Gpio_Struct.GPIO_Pin = GPIO_GetPin(LED) | GPIO_GetPin(BEEP);
        0x0080e9f8:    2001        .       MOVS     r0,#1
        0x0080e9fa:    f000fad0    ....    BL       GPIO_GetPin ; 0x80ef9e
        0x0080e9fe:    4604        .F      MOV      r4,r0
        0x0080ea00:    2002        .       MOVS     r0,#2
        0x0080ea02:    f000facc    ....    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ea06:    4304        .C      ORRS     r4,r4,r0
;;;78         Gpio_Struct.GPIO_Mode = GPIO_Mode_OUT;
        0x0080ea08:    9400        ..      STR      r4,[sp,#0]
        0x0080ea0a:    2401        .$      MOVS     r4,#1
        0x0080ea0c:    f88d4004    ...@    STRB     r4,[sp,#4]
;;;79         GPIO_Init(&Gpio_Struct);
        0x0080ea10:    4668        hF      MOV      r0,sp
        0x0080ea12:    f000fa43    ..C.    BL       GPIO_Init ; 0x80ee9c
;;;80         GPIO_ResetBits(GPIO_GetPin(LED) | GPIO_GetPin(BEEP));
        0x0080ea16:    2001        .       MOVS     r0,#1
        0x0080ea18:    f000fac1    ....    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ea1c:    4605        .F      MOV      r5,r0
        0x0080ea1e:    2002        .       MOVS     r0,#2
        0x0080ea20:    f000fabd    ....    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ea24:    4328        (C      ORRS     r0,r0,r5
        0x0080ea26:    f000fa1b    ....    BL       GPIO_ResetBits ; 0x80ee60
;;;81     
;;;82         Gpio_Struct.GPIO_Pin = GPIO_GetPin(KEY);
        0x0080ea2a:    2014        .       MOVS     r0,#0x14
        0x0080ea2c:    f000fab7    ....    BL       GPIO_GetPin ; 0x80ef9e
;;;83         Gpio_Struct.GPIO_Mode = GPIO_Mode_IN;
        0x0080ea30:    9000        ..      STR      r0,[sp,#0]
        0x0080ea32:    2000        .       MOVS     r0,#0
        0x0080ea34:    f88d0004    ....    STRB     r0,[sp,#4]
;;;84         Gpio_Struct.GPIO_ITCmd = ENABLE;
        0x0080ea38:    f88d4005    ...@    STRB     r4,[sp,#5]
;;;85         Gpio_Struct.GPIO_ITTrigger = GPIO_INT_Trigger_EDGE;
        0x0080ea3c:    f88d4006    ...@    STRB     r4,[sp,#6]
;;;86         Gpio_Struct.GPIO_ITPolarity = GPIO_INT_POLARITY_ACTIVE_LOW;
        0x0080ea40:    f88d0007    ....    STRB     r0,[sp,#7]
        0x0080ea44:    2014        .       MOVS     r0,#0x14
        0x0080ea46:    9003        ..      STR      r0,[sp,#0xc]
;;;87         Gpio_Struct.GPIO_ITDebounce = GPIO_INT_DEBOUNCE_ENABLE;
        0x0080ea48:    f88d4008    ...@    STRB     r4,[sp,#8]
;;;88         Gpio_Struct.GPIO_DebounceTime = 20;
;;;89         GPIO_Init(&Gpio_Struct);
        0x0080ea4c:    4668        hF      MOV      r0,sp
        0x0080ea4e:    f000fa25    ..%.    BL       GPIO_Init ; 0x80ee9c
;;;90     
;;;91         keystatus = GPIO_ReadInputDataBit(GPIO_GetPin(KEY));
        0x0080ea52:    2014        .       MOVS     r0,#0x14
        0x0080ea54:    f000faa3    ....    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ea58:    f000f9ed    ....    BL       GPIO_ReadInputDataBit ; 0x80ee36
        0x0080ea5c:    49db        .I      LDR      r1,[pc,#876] ; [0x80edcc] = 0x208038
        0x0080ea5e:    7088        .p      STRB     r0,[r1,#2]
;;;92         GPIO_MaskINTConfig(GPIO_GetPin(KEY), DISABLE);
        0x0080ea60:    2014        .       MOVS     r0,#0x14
        0x0080ea62:    f000fa9c    ....    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ea66:    2100        .!      MOVS     r1,#0
        0x0080ea68:    f000fa90    ....    BL       GPIO_MaskINTConfig ; 0x80ef8c
;;;93         GPIO_INTConfig(GPIO_GetPin(KEY), ENABLE);
        0x0080ea6c:    2014        .       MOVS     r0,#0x14
        0x0080ea6e:    f000fa96    ....    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ea72:    2101        .!      MOVS     r1,#1
        0x0080ea74:    f000fa7e    ..~.    BL       GPIO_INTConfig ; 0x80ef74
;;;94     
;;;95         NVIC_InitTypeDef NVIC_InitStruct;
;;;96         //NVIC_InitStruct.NVIC_IRQChannel = GPIO5_IRQn;
;;;97         NVIC_InitStruct.NVIC_IRQChannel = KEY_IRQ;//P2_4
        0x0080ea78:    201e        .       MOVS     r0,#0x1e
        0x0080ea7a:    f88d0010    ....    STRB     r0,[sp,#0x10]
;;;98         NVIC_InitStruct.NVIC_IRQChannelPriority = 3;
        0x0080ea7e:    2003        .       MOVS     r0,#3
;;;99         NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
        0x0080ea80:    9005        ..      STR      r0,[sp,#0x14]
        0x0080ea82:    f88d4018    ...@    STRB     r4,[sp,#0x18]
;;;100        NVIC_Init(&NVIC_InitStruct);
        0x0080ea86:    a804        ..      ADD      r0,sp,#0x10
        0x0080ea88:    f402f41a    ....    BL       NVIC_Init ; 0x112c0
;;;101    }
        0x0080ea8c:    b007        ..      ADD      sp,sp,#0x1c
        0x0080ea8e:    bd30        0.      POP      {r4,r5,pc}
    GPIO20_Handler
;;;102    
;;;103    typedef enum _KeyStatus
;;;104    {
;;;105        keyIdle = 0,
;;;106        keyShortPress,
;;;107        keyLongPress,
;;;108    } KeyStatus;
;;;109    KeyStatus gKeyStatus = keyIdle;
;;;110    
;;;111    
;;;112    //void GPIO_Group0_Handler(void)
;;;113    //{
;;;114    //     APP_PRINT_ERROR0("Enter GPIO_Group0_Handler!");
;;;115    //}
;;;116    /**
;;;117    * @brief    KEY_INT_Handle for key interrupt/GPIO20/P2_4
;;;118     * @note     Send short press event when read correct gpio bit port
;;;119     * @return   void
;;;120     */
;;;121    //void GPIO5_Handler(void)
;;;122    void KEY_INT_Handle(void)//P2_4
;;;123    {
        0x0080ea90:    b57c        |.      PUSH     {r2-r6,lr}
;;;124    
;;;125        T_IO_MSG bee_io_msg;
;;;126        APP_PRINT_ERROR0("Enter GPIO5_Handler!");
        0x0080ea92:    2200        ."      MOVS     r2,#0
        0x0080ea94:    49ce        .I      LDR      r1,[pc,#824] ; [0x80edd0] = 0x8800120
        0x0080ea96:    48cf        .H      LDR      r0,[pc,#828] ; [0x80edd4] = 0x21103000
        0x0080ea98:    f7f8dfe1    ....    BL       log_buffer ; 0x7a5e
;;;127        GPIO_MaskINTConfig(GPIO_GetPin(KEY), ENABLE);
        0x0080ea9c:    2014        .       MOVS     r0,#0x14
        0x0080ea9e:    f000fa7e    ..~.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080eaa2:    2101        .!      MOVS     r1,#1
        0x0080eaa4:    f000fa72    ..r.    BL       GPIO_MaskINTConfig ; 0x80ef8c
        0x0080eaa8:    2014        .       MOVS     r0,#0x14
        0x0080eaaa:    f000fa78    ..x.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080eaae:    f000f9c2    ....    BL       GPIO_ReadInputDataBit ; 0x80ee36
        0x0080eab2:    4cc6        .L      LDR      r4,[pc,#792] ; [0x80edcc] = 0x208038
        0x0080eab4:    4dc8        .M      LDR      r5,[pc,#800] ; [0x80edd8] = 0x40001000
        0x0080eab6:    2601        .&      MOVS     r6,#1
;;;128        keystatus = GPIO_ReadInputDataBit(GPIO_GetPin(KEY));
        0x0080eab8:    70a0        .p      STRB     r0,[r4,#2]
;;;129    
;;;130        if (keystatus == 0)
        0x0080eaba:    b148        H.      CBZ      r0,0x80ead0 ; GPIO20_Handler + 64
        0x0080eabc:    2014        .       MOVS     r0,#0x14
        0x0080eabe:    f000fa6e    ..n.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080eac2:    6be9        .k      LDR      r1,[r5,#0x3c]
        0x0080eac4:    4381        .C      BICS     r1,r1,r0
        0x0080eac6:    63e9        .c      STR      r1,[r5,#0x3c]
        0x0080eac8:    7860        `x      LDRB     r0,[r4,#1]
        0x0080eaca:    2801        .(      CMP      r0,#1
        0x0080eacc:    d00c        ..      BEQ      0x80eae8 ; GPIO20_Handler + 88
        0x0080eace:    e017        ..      B        0x80eb00 ; GPIO20_Handler + 112
;;;131        {
;;;132            gKeyStatus = keyShortPress;
        0x0080ead0:    7066        fp      STRB     r6,[r4,#1]
;;;133            GPIO->INTPOLARITY |= GPIO_GetPin(KEY);
        0x0080ead2:    2014        .       MOVS     r0,#0x14
        0x0080ead4:    f000fa63    ..c.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ead8:    6be9        .k      LDR      r1,[r5,#0x3c]
        0x0080eada:    4308        .C      ORRS     r0,r0,r1
        0x0080eadc:    63e8        .c      STR      r0,[r5,#0x3c]
;;;134            os_timer_start(&xTimerLongPress);
        0x0080eade:    48bb        .H      LDR      r0,[pc,#748] ; [0x80edcc] = 0x208038
        0x0080eae0:    3014        .0      ADDS     r0,r0,#0x14
        0x0080eae2:    f418f09b    ....    BL       os_timer_start ; 0x26c1c
        0x0080eae6:    e00d        ..      B        0x80eb04 ; GPIO20_Handler + 116
;;;135        }
;;;136        else
;;;137        {
;;;138            GPIO->INTPOLARITY &= ~GPIO_GetPin(KEY);
;;;139            if (gKeyStatus == keyShortPress)
;;;140            {
;;;141                os_timer_stop(&xTimerLongPress);
        0x0080eae8:    48b8        .H      LDR      r0,[pc,#736] ; [0x80edcc] = 0x208038
        0x0080eaea:    3014        .0      ADDS     r0,r0,#0x14
        0x0080eaec:    f418f0ba    ....    BL       os_timer_stop ; 0x26c64
;;;142                bee_io_msg.type = IO_MSG_TYPE_GPIO;
        0x0080eaf0:    200b        .       MOVS     r0,#0xb
        0x0080eaf2:    f8ad0000    ....    STRH     r0,[sp,#0]
;;;143                bee_io_msg.subtype = MSG_SHORT_PRESS;
        0x0080eaf6:    f8ad6002    ...`    STRH     r6,[sp,#2]
;;;144                app_send_msg_to_apptask(&bee_io_msg);
        0x0080eafa:    4668        hF      MOV      r0,sp
        0x0080eafc:    f7fffec8    ....    BL       app_send_msg_to_apptask ; 0x80e890
;;;145            }
;;;146            gKeyStatus = keyIdle;
        0x0080eb00:    2000        .       MOVS     r0,#0
        0x0080eb02:    7060        `p      STRB     r0,[r4,#1]
;;;147        }
;;;148        GPIO_ClearINTPendingBit(GPIO_GetPin(KEY));
        0x0080eb04:    2014        .       MOVS     r0,#0x14
        0x0080eb06:    f000fa4a    ..J.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080eb0a:    f000fa3c    ..<.    BL       GPIO_ClearINTPendingBit ; 0x80ef86
;;;149        GPIO_MaskINTConfig(GPIO_GetPin(KEY), DISABLE);
        0x0080eb0e:    2014        .       MOVS     r0,#0x14
        0x0080eb10:    f000fa45    ..E.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080eb14:    2100        .!      MOVS     r1,#0
        0x0080eb16:    f000fa39    ..9.    BL       GPIO_MaskINTConfig ; 0x80ef8c
;;;150    }
        0x0080eb1a:    bd7c        |.      POP      {r2-r6,pc}
    StopPxpIO
;;;151    
;;;152    /**
;;;153     * @brief    Pxp_HandleButtonEvent for key io event
;;;154     * @note     Event for Gpio interrupt and long press timer.
;;;155     * @param[in] io_msg
;;;156     * @return   void
;;;157     */
;;;158    void Pxp_HandleButtonEvent(T_IO_MSG io_msg)
;;;159    {
;;;160        uint8_t value_to_send;
;;;161        uint8_t keytype = io_msg.subtype ;
;;;162        if (keytype == MSG_SHORT_PRESS)
;;;163        {
;;;164            APP_PRINT_ERROR0("MSG_SHORT_PRESS");
;;;165            switch (gPxpState)
;;;166            {
;;;167            case PxpStateIdle:
;;;168                if (gIoState == IoStateIdle)
;;;169                {
;;;170                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK,
;;;171                               1); /*low period 0.9s, high period 0.1s,  led blink,  1times(cnt)*/
;;;172                }
;;;173                break;
;;;174            case PxpStateAdv:
;;;175                if (gIoState == IoStateLlsAlert)
;;;176                {
;;;177                    gActCnt = 0;
;;;178                    allowedPxpEnterDlps = true;
;;;179                    os_timer_stop(&xTimerPxpIO);
;;;180                    gIoState = IoStateIdle;
;;;181                }
;;;182                break;
;;;183            case PxpStateLink:
;;;184                if (gIoState == IoStateImmAlert)
;;;185                {
;;;186                    gActCnt = 0;
;;;187                    allowedPxpEnterDlps = true;
;;;188                    os_timer_stop(&xTimerPxpIO);
;;;189                    gIoState = IoStateIdle;
;;;190                }
;;;191                else if (gIoState == IoStateIdle)
;;;192                {
;;;193                    value_to_send = 1;
;;;194                    server_send_data(0, kns_srv_id, KNS_KEY_VALUE_INDEX, \
;;;195                                     &value_to_send, sizeof(uint8_t), GATT_PDU_TYPE_NOTIFICATION);
;;;196                }
;;;197                else
;;;198                {
;;;199                    APP_PRINT_ERROR0("ERROR IO STATUS");//error status
;;;200                }
;;;201                break;
;;;202            default:
;;;203                break;
;;;204            }
;;;205        }
;;;206        else if (keytype == MSG_LONG_PRESS)
;;;207        {
;;;208            APP_PRINT_ERROR0("MSG_LONG_PRESS");
;;;209            switch (gPxpState)
;;;210            {
;;;211            case PxpStateIdle:
;;;212                if (gPowerFlg == false)
;;;213                {
;;;214                    gPowerFlg = true;
;;;215                    le_adv_start();
;;;216                }
;;;217                else
;;;218                {
;;;219                    APP_PRINT_ERROR0("ERROR POWER STATUS");//error status
;;;220                }
;;;221                break;
;;;222            case PxpStateAdv:
;;;223                if (gPowerFlg == true)
;;;224                {
;;;225                    gPowerFlg = false;
;;;226                    if (gIoState != IoStateIdle)
;;;227                    {
;;;228                        gIoState = IoStateIdle;
;;;229                        StopPxpIO();
;;;230                    }
;;;231                    le_adv_stop();
;;;232                }
;;;233                else
;;;234                {
;;;235                    APP_PRINT_ERROR0("ERROR POWER STATUS");//error status
;;;236                }
;;;237                break;
;;;238            case PxpStateLink:
;;;239                if (gPowerFlg == true)
;;;240                {
;;;241                    gPowerFlg = false;
;;;242                    if (gIoState != IoStateIdle)
;;;243                    {
;;;244                        gIoState = IoStateIdle;
;;;245                        StopPxpIO();
;;;246                    }
;;;247                    le_disconnect(0);
;;;248                }
;;;249                else
;;;250                {
;;;251                    APP_PRINT_ERROR0("ERROR POWER STATUS");//error status
;;;252                }
;;;253                break;
;;;254            default:
;;;255                break;
;;;256            }
;;;257        }
;;;258        else
;;;259        {
;;;260            //nothing to do
;;;261        }
;;;262    }
;;;263    
;;;264    /**
;;;265     * @brief    StartPxpIO for led blink and beep
;;;266     * @note     Set parameter and start swtimer xTimerPxpIO
;;;267     * @param[in] lowPeroid
;;;268     * @param[in] HighPeroid
;;;269     * @param[in] mode
;;;270     * @param[in] cnt
;;;271     * @return   void
;;;272     */
;;;273    void StartPxpIO(uint32_t lowPeroid, uint32_t HighPeroid, uint8_t mode, uint32_t cnt)
;;;274    {
;;;275        xPeriodLow = lowPeroid;
;;;276        xPeriodHigh = HighPeroid;
;;;277        gIoMode = mode;
;;;278        gActCnt = cnt;
;;;279        if (gIoMode)
;;;280        {
;;;281            if (gIoMode & 0x1)
;;;282            {
;;;283                GPIO_SetBits(GPIO_GetPin(LED));
;;;284            }
;;;285            if (gIoMode & 0x2)
;;;286            {
;;;287                GPIO_SetBits(GPIO_GetPin(BEEP));
;;;288            }
;;;289            allowedPxpEnterDlps = false;
;;;290            os_timer_restart(&xTimerPxpIO, HighPeroid);
;;;291        }
;;;292    }
;;;293    /**
;;;294     * @brief    StopPxpIO
;;;295     * @note     Stop pxp io action
;;;296     * @return   void
;;;297     */
;;;298    void StopPxpIO()
;;;299    {
;;;300        allowedPxpEnterDlps = true;
        0x0080eb1c:    49af        .I      LDR      r1,[pc,#700] ; [0x80eddc] = 0x207f82
;;; .\..\source\cmsis\iohandle.c (299)
        0x0080eb1e:    b510        ..      PUSH     {r4,lr}
;;;300        allowedPxpEnterDlps = true;
        0x0080eb20:    2001        .       MOVS     r0,#1
        0x0080eb22:    7008        .p      STRB     r0,[r1,#0]
;;;301        gActCnt = 0;
        0x0080eb24:    49a9        .I      LDR      r1,[pc,#676] ; [0x80edcc] = 0x208038
        0x0080eb26:    2000        .       MOVS     r0,#0
;;;302        GPIO_ResetBits(GPIO_GetPin(LED));
        0x0080eb28:    60c8        .`      STR      r0,[r1,#0xc]
        0x0080eb2a:    2001        .       MOVS     r0,#1
        0x0080eb2c:    f000fa37    ..7.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080eb30:    f000f996    ....    BL       GPIO_ResetBits ; 0x80ee60
;;;303        GPIO_ResetBits(GPIO_GetPin(BEEP));
        0x0080eb34:    2002        .       MOVS     r0,#2
        0x0080eb36:    f000fa32    ..2.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080eb3a:    f000f991    ....    BL       GPIO_ResetBits ; 0x80ee60
;;;304        os_timer_stop(&xTimerPxpIO);
        0x0080eb3e:    48a3        .H      LDR      r0,[pc,#652] ; [0x80edcc] = 0x208038
        0x0080eb40:    e8bd4010    ...@    POP      {r4,lr}
        0x0080eb44:    3010        .0      ADDS     r0,r0,#0x10
        0x0080eb46:    f418b08d    ....    B        os_timer_stop ; 0x26c64
    StartPxpIO
        0x0080eb4a:    b570        p.      PUSH     {r4-r6,lr}
        0x0080eb4c:    4c9f        .L      LDR      r4,[pc,#636] ; [0x80edcc] = 0x208038
;;; .\..\source\cmsis\iohandle.c (274)
        0x0080eb4e:    460d        .F      MOV      r5,r1
        0x0080eb50:    2a00        .*      CMP      r2,#0
        0x0080eb52:    e9c40101    ....    STRD     r0,r1,[r4,#4]
        0x0080eb56:    7022        "p      STRB     r2,[r4,#0]
        0x0080eb58:    60e3        .`      STR      r3,[r4,#0xc]
        0x0080eb5a:    d018        ..      BEQ      0x80eb8e ; StartPxpIO + 68
;;;275        xPeriodLow = lowPeroid;
;;;276        xPeriodHigh = HighPeroid;
;;;277        gIoMode = mode;
;;;278        gActCnt = cnt;
;;;279        if (gIoMode)
;;;280        {
;;;281            if (gIoMode & 0x1)
        0x0080eb5c:    07d0        ..      LSLS     r0,r2,#31
        0x0080eb5e:    d004        ..      BEQ      0x80eb6a ; StartPxpIO + 32
;;;282            {
;;;283                GPIO_SetBits(GPIO_GetPin(LED));
        0x0080eb60:    2001        .       MOVS     r0,#1
        0x0080eb62:    f000fa1c    ....    BL       GPIO_GetPin ; 0x80ef9e
        0x0080eb66:    f000f976    ..v.    BL       GPIO_SetBits ; 0x80ee56
;;;284            }
;;;285            if (gIoMode & 0x2)
        0x0080eb6a:    7820         x      LDRB     r0,[r4,#0]
        0x0080eb6c:    0780        ..      LSLS     r0,r0,#30
        0x0080eb6e:    d504        ..      BPL      0x80eb7a ; StartPxpIO + 48
;;;286            {
;;;287                GPIO_SetBits(GPIO_GetPin(BEEP));
        0x0080eb70:    2002        .       MOVS     r0,#2
        0x0080eb72:    f000fa14    ....    BL       GPIO_GetPin ; 0x80ef9e
        0x0080eb76:    f000f96e    ..n.    BL       GPIO_SetBits ; 0x80ee56
;;;288            }
;;;289            allowedPxpEnterDlps = false;
        0x0080eb7a:    4998        .I      LDR      r1,[pc,#608] ; [0x80eddc] = 0x207f82
        0x0080eb7c:    2000        .       MOVS     r0,#0
        0x0080eb7e:    7008        .p      STRB     r0,[r1,#0]
;;;290            os_timer_restart(&xTimerPxpIO, HighPeroid);
        0x0080eb80:    4629        )F      MOV      r1,r5
        0x0080eb82:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0080eb86:    4891        .H      LDR      r0,[pc,#580] ; [0x80edcc] = 0x208038
        0x0080eb88:    3010        .0      ADDS     r0,r0,#0x10
        0x0080eb8a:    f418b058    ..X.    B        os_timer_restart ; 0x26c3e
;;;291        }
;;;292    }
        0x0080eb8e:    bd70        p.      POP      {r4-r6,pc}
    Pxp_HandleButtonEvent
;;; .\..\source\cmsis\iohandle.c (159)
        0x0080eb90:    e92d43fe    -..C    PUSH     {r1-r9,lr}
;;;160        uint8_t value_to_send;
;;;161        uint8_t keytype = io_msg.subtype ;
        0x0080eb94:    f3c04007    ...@    UBFX     r0,r0,#16,#8
        0x0080eb98:    2601        .&      MOVS     r6,#1
        0x0080eb9a:    4f91        .O      LDR      r7,[pc,#580] ; [0x80ede0] = 0x2081d0
        0x0080eb9c:    4b8d        .K      LDR      r3,[pc,#564] ; [0x80edd4] = 0x21103000
        0x0080eb9e:    2500        .%      MOVS     r5,#0
        0x0080eba0:    4c90        .L      LDR      r4,[pc,#576] ; [0x80ede4] = 0x2081d1
;;;162        if (keytype == MSG_SHORT_PRESS)
        0x0080eba2:    2801        .(      CMP      r0,#1
        0x0080eba4:    d01d        ..      BEQ      0x80ebe2 ; Pxp_HandleButtonEvent + 82
        0x0080eba6:    2803        .(      CMP      r0,#3
        0x0080eba8:    d119        ..      BNE      0x80ebde ; Pxp_HandleButtonEvent + 78
        0x0080ebaa:    4989        .I      LDR      r1,[pc,#548] ; [0x80edd0] = 0x8800120
        0x0080ebac:    2200        ."      MOVS     r2,#0
        0x0080ebae:    3140        @1      ADDS     r1,r1,#0x40
        0x0080ebb0:    4698        .F      MOV      r8,r3
        0x0080ebb2:    4618        .F      MOV      r0,r3
        0x0080ebb4:    f7f8df53    ..S.    BL       log_buffer ; 0x7a5e
        0x0080ebb8:    7838        8x      LDRB     r0,[r7,#0]
        0x0080ebba:    498b        .I      LDR      r1,[pc,#556] ; [0x80ede8] = 0x2081d2
        0x0080ebbc:    b398        ..      CBZ      r0,0x80ec26 ; Pxp_HandleButtonEvent + 150
        0x0080ebbe:    2801        .(      CMP      r0,#1
        0x0080ebc0:    d053        S.      BEQ      0x80ec6a ; Pxp_HandleButtonEvent + 218
        0x0080ebc2:    2802        .(      CMP      r0,#2
        0x0080ebc4:    d10b        ..      BNE      0x80ebde ; Pxp_HandleButtonEvent + 78
        0x0080ebc6:    7808        .x      LDRB     r0,[r1,#0]
        0x0080ebc8:    2800        .(      CMP      r0,#0
        0x0080ebca:    d05d        ].      BEQ      0x80ec88 ; Pxp_HandleButtonEvent + 248
        0x0080ebcc:    700d        .p      STRB     r5,[r1,#0]
        0x0080ebce:    7820         x      LDRB     r0,[r4,#0]
        0x0080ebd0:    b110        ..      CBZ      r0,0x80ebd8 ; Pxp_HandleButtonEvent + 72
        0x0080ebd2:    7025        %p      STRB     r5,[r4,#0]
        0x0080ebd4:    f7ffffa2    ....    BL       StopPxpIO ; 0x80eb1c
        0x0080ebd8:    2000        .       MOVS     r0,#0
        0x0080ebda:    f43ff023    ?.#.    BL       le_disconnect ; 0x4dc24
        0x0080ebde:    e8bd83fe    ....    POP      {r1-r9,pc}
;;;163        {
;;;164            APP_PRINT_ERROR0("MSG_SHORT_PRESS");
        0x0080ebe2:    497b        {I      LDR      r1,[pc,#492] ; [0x80edd0] = 0x8800120
        0x0080ebe4:    2200        ."      MOVS     r2,#0
        0x0080ebe6:    3118        .1      ADDS     r1,r1,#0x18
        0x0080ebe8:    4698        .F      MOV      r8,r3
        0x0080ebea:    4618        .F      MOV      r0,r3
        0x0080ebec:    f7f8df37    ..7.    BL       log_buffer ; 0x7a5e
;;;165            switch (gPxpState)
        0x0080ebf0:    7838        8x      LDRB     r0,[r7,#0]
        0x0080ebf2:    b168        h.      CBZ      r0,0x80ec10 ; Pxp_HandleButtonEvent + 128
        0x0080ebf4:    4975        uI      LDR      r1,[pc,#468] ; [0x80edcc] = 0x208038
        0x0080ebf6:    4a79        yJ      LDR      r2,[pc,#484] ; [0x80eddc] = 0x207f82
        0x0080ebf8:    2801        .(      CMP      r0,#1
        0x0080ebfa:    d015        ..      BEQ      0x80ec28 ; Pxp_HandleButtonEvent + 152
        0x0080ebfc:    2802        .(      CMP      r0,#2
        0x0080ebfe:    d1ee        ..      BNE      0x80ebde ; Pxp_HandleButtonEvent + 78
        0x0080ec00:    7820         x      LDRB     r0,[r4,#0]
        0x0080ec02:    2802        .(      CMP      r0,#2
        0x0080ec04:    d013        ..      BEQ      0x80ec2e ; Pxp_HandleButtonEvent + 158
        0x0080ec06:    b1d0        ..      CBZ      r0,0x80ec3e ; Pxp_HandleButtonEvent + 174
        0x0080ec08:    4971        qI      LDR      r1,[pc,#452] ; [0x80edd0] = 0x8800120
        0x0080ec0a:    2200        ."      MOVS     r2,#0
        0x0080ec0c:    312c        ,1      ADDS     r1,r1,#0x2c
        0x0080ec0e:    e03e        >.      B        0x80ec8e ; Pxp_HandleButtonEvent + 254
;;;166            {
;;;167            case PxpStateIdle:
;;;168                if (gIoState == IoStateIdle)
        0x0080ec10:    7820         x      LDRB     r0,[r4,#0]
        0x0080ec12:    2800        .(      CMP      r0,#0
        0x0080ec14:    d1e3        ..      BNE      0x80ebde ; Pxp_HandleButtonEvent + 78
;;;169                {
;;;170                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK,
        0x0080ec16:    2301        .#      MOVS     r3,#1
        0x0080ec18:    461a        .F      MOV      r2,r3
        0x0080ec1a:    2164        d!      MOVS     r1,#0x64
        0x0080ec1c:    f44f7061    O.ap    MOV      r0,#0x384
        0x0080ec20:    f7ffff93    ....    BL       StartPxpIO ; 0x80eb4a
        0x0080ec24:    e7db        ..      B        0x80ebde ; Pxp_HandleButtonEvent + 78
        0x0080ec26:    e016        ..      B        0x80ec56 ; Pxp_HandleButtonEvent + 198
;;;171                               1); /*low period 0.9s, high period 0.1s,  led blink,  1times(cnt)*/
;;;172                }
;;;173                break;
;;;174            case PxpStateAdv:
;;;175                if (gIoState == IoStateLlsAlert)
        0x0080ec28:    7820         x      LDRB     r0,[r4,#0]
        0x0080ec2a:    2803        .(      CMP      r0,#3
        0x0080ec2c:    d1d7        ..      BNE      0x80ebde ; Pxp_HandleButtonEvent + 78
        0x0080ec2e:    4867        gH      LDR      r0,[pc,#412] ; [0x80edcc] = 0x208038
;;;176                {
;;;177                    gActCnt = 0;
;;;178                    allowedPxpEnterDlps = true;
;;;179                    os_timer_stop(&xTimerPxpIO);
;;;180                    gIoState = IoStateIdle;
;;;181                }
;;;182                break;
;;;183            case PxpStateLink:
;;;184                if (gIoState == IoStateImmAlert)
;;;185                {
;;;186                    gActCnt = 0;
;;;187                    allowedPxpEnterDlps = true;
        0x0080ec30:    60cd        .`      STR      r5,[r1,#0xc]
        0x0080ec32:    7016        .p      STRB     r6,[r2,#0]
;;;188                    os_timer_stop(&xTimerPxpIO);
        0x0080ec34:    3010        .0      ADDS     r0,r0,#0x10
        0x0080ec36:    f418f015    ....    BL       os_timer_stop ; 0x26c64
;;;189                    gIoState = IoStateIdle;
        0x0080ec3a:    7025        %p      STRB     r5,[r4,#0]
        0x0080ec3c:    e7cf        ..      B        0x80ebde ; Pxp_HandleButtonEvent + 78
        0x0080ec3e:    486b        kH      LDR      r0,[pc,#428] ; [0x80edec] = 0x2081d8
;;;190                }
;;;191                else if (gIoState == IoStateIdle)
;;;192                {
;;;193                    value_to_send = 1;
        0x0080ec40:    f88d6008    ...`    STRB     r6,[sp,#8]
;;;194                    server_send_data(0, kns_srv_id, KNS_KEY_VALUE_INDEX, \
        0x0080ec44:    9600        ..      STR      r6,[sp,#0]
        0x0080ec46:    9601        ..      STR      r6,[sp,#4]
        0x0080ec48:    7801        .x      LDRB     r1,[r0,#0]
        0x0080ec4a:    ab02        ..      ADD      r3,sp,#8
        0x0080ec4c:    2204        ."      MOVS     r2,#4
        0x0080ec4e:    2000        .       MOVS     r0,#0
        0x0080ec50:    f440f5a8    @...    BL       server_send_data ; 0x4f7a4
        0x0080ec54:    e7c3        ..      B        0x80ebde ; Pxp_HandleButtonEvent + 78
;;;195                                     &value_to_send, sizeof(uint8_t), GATT_PDU_TYPE_NOTIFICATION);
;;;196                }
;;;197                else
;;;198                {
;;;199                    APP_PRINT_ERROR0("ERROR IO STATUS");//error status
;;;200                }
;;;201                break;
;;;202            default:
;;;203                break;
;;;204            }
;;;205        }
;;;206        else if (keytype == MSG_LONG_PRESS)
;;;207        {
;;;208            APP_PRINT_ERROR0("MSG_LONG_PRESS");
;;;209            switch (gPxpState)
;;;210            {
;;;211            case PxpStateIdle:
;;;212                if (gPowerFlg == false)
        0x0080ec56:    7808        .x      LDRB     r0,[r1,#0]
        0x0080ec58:    b118        ..      CBZ      r0,0x80ec62 ; Pxp_HandleButtonEvent + 210
        0x0080ec5a:    495d        ]I      LDR      r1,[pc,#372] ; [0x80edd0] = 0x8800120
        0x0080ec5c:    2200        ."      MOVS     r2,#0
        0x0080ec5e:    3154        T1      ADDS     r1,r1,#0x54
        0x0080ec60:    e015        ..      B        0x80ec8e ; Pxp_HandleButtonEvent + 254
;;;213                {
;;;214                    gPowerFlg = true;
        0x0080ec62:    700e        .p      STRB     r6,[r1,#0]
;;;215                    le_adv_start();
        0x0080ec64:    f443f22f    C./.    BL       le_adv_start ; 0x520c6
        0x0080ec68:    e7b9        ..      B        0x80ebde ; Pxp_HandleButtonEvent + 78
;;;216                }
;;;217                else
;;;218                {
;;;219                    APP_PRINT_ERROR0("ERROR POWER STATUS");//error status
;;;220                }
;;;221                break;
;;;222            case PxpStateAdv:
;;;223                if (gPowerFlg == true)
        0x0080ec6a:    7808        .x      LDRB     r0,[r1,#0]
        0x0080ec6c:    b140        @.      CBZ      r0,0x80ec80 ; Pxp_HandleButtonEvent + 240
;;;224                {
;;;225                    gPowerFlg = false;
        0x0080ec6e:    700d        .p      STRB     r5,[r1,#0]
;;;226                    if (gIoState != IoStateIdle)
        0x0080ec70:    7820         x      LDRB     r0,[r4,#0]
        0x0080ec72:    b110        ..      CBZ      r0,0x80ec7a ; Pxp_HandleButtonEvent + 234
;;;227                    {
;;;228                        gIoState = IoStateIdle;
        0x0080ec74:    7025        %p      STRB     r5,[r4,#0]
;;;229                        StopPxpIO();
        0x0080ec76:    f7ffff51    ..Q.    BL       StopPxpIO ; 0x80eb1c
;;;230                    }
;;;231                    le_adv_stop();
        0x0080ec7a:    f443f286    C...    BL       le_adv_stop ; 0x5218a
        0x0080ec7e:    e7ae        ..      B        0x80ebde ; Pxp_HandleButtonEvent + 78
;;;232                }
;;;233                else
;;;234                {
;;;235                    APP_PRINT_ERROR0("ERROR POWER STATUS");//error status
        0x0080ec80:    4953        SI      LDR      r1,[pc,#332] ; [0x80edd0] = 0x8800120
        0x0080ec82:    2200        ."      MOVS     r2,#0
        0x0080ec84:    316c        l1      ADDS     r1,r1,#0x6c
        0x0080ec86:    e002        ..      B        0x80ec8e ; Pxp_HandleButtonEvent + 254
;;;236                }
;;;237                break;
;;;238            case PxpStateLink:
;;;239                if (gPowerFlg == true)
;;;240                {
;;;241                    gPowerFlg = false;
;;;242                    if (gIoState != IoStateIdle)
;;;243                    {
;;;244                        gIoState = IoStateIdle;
;;;245                        StopPxpIO();
;;;246                    }
;;;247                    le_disconnect(0);
;;;248                }
;;;249                else
;;;250                {
;;;251                    APP_PRINT_ERROR0("ERROR POWER STATUS");//error status
        0x0080ec88:    4951        QI      LDR      r1,[pc,#324] ; [0x80edd0] = 0x8800120
        0x0080ec8a:    2200        ."      MOVS     r2,#0
        0x0080ec8c:    3184        .1      ADDS     r1,r1,#0x84
        0x0080ec8e:    4640        @F      MOV      r0,r8
        0x0080ec90:    f7f8dee5    ....    BL       log_buffer ; 0x7a5e
;;;252                }
;;;253                break;
;;;254            default:
;;;255                break;
;;;256            }
;;;257        }
;;;258        else
;;;259        {
;;;260            //nothing to do
;;;261        }
;;;262    }
        0x0080ec94:    e7a3        ..      B        0x80ebde ; Pxp_HandleButtonEvent + 78
    vTimerPxpIOCallback
;;;263    
;;;264    /**
;;;265     * @brief    StartPxpIO for led blink and beep
;;;266     * @note     Set parameter and start swtimer xTimerPxpIO
;;;267     * @param[in] lowPeroid
;;;268     * @param[in] HighPeroid
;;;269     * @param[in] mode
;;;270     * @param[in] cnt
;;;271     * @return   void
;;;272     */
;;;273    void StartPxpIO(uint32_t lowPeroid, uint32_t HighPeroid, uint8_t mode, uint32_t cnt)
;;;274    {
;;;275        xPeriodLow = lowPeroid;
;;;276        xPeriodHigh = HighPeroid;
;;;277        gIoMode = mode;
;;;278        gActCnt = cnt;
;;;279        if (gIoMode)
;;;280        {
;;;281            if (gIoMode & 0x1)
;;;282            {
;;;283                GPIO_SetBits(GPIO_GetPin(LED));
;;;284            }
;;;285            if (gIoMode & 0x2)
;;;286            {
;;;287                GPIO_SetBits(GPIO_GetPin(BEEP));
;;;288            }
;;;289            allowedPxpEnterDlps = false;
;;;290            os_timer_restart(&xTimerPxpIO, HighPeroid);
;;;291        }
;;;292    }
;;;293    /**
;;;294     * @brief    StopPxpIO
;;;295     * @note     Stop pxp io action
;;;296     * @return   void
;;;297     */
;;;298    void StopPxpIO()
;;;299    {
;;;300        allowedPxpEnterDlps = true;
;;;301        gActCnt = 0;
;;;302        GPIO_ResetBits(GPIO_GetPin(LED));
;;;303        GPIO_ResetBits(GPIO_GetPin(BEEP));
;;;304        os_timer_stop(&xTimerPxpIO);
;;;305    }
;;;306    
;;;307    /**
;;;308     * @brief    vTimerPxpIOCallback
;;;309     * @note     BEEP & LED act here
;;;310     * @param[in] pxTimer
;;;311     * @return   void
;;;312     */
;;;313    void vTimerPxpIOCallback(TimerHandle_t pxTimer)
;;;314    {
        0x0080ec96:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0080ec9a:    4c4c        LL      LDR      r4,[pc,#304] ; [0x80edcc] = 0x208038
        0x0080ec9c:    7820         x      LDRB     r0,[r4,#0]
        0x0080ec9e:    07c1        ..      LSLS     r1,r0,#31
        0x0080eca0:    d001        ..      BEQ      0x80eca6 ; vTimerPxpIOCallback + 16
;;;315        uint8_t  status_value;
;;;316        uint32_t xNewPeriod;
;;;317        if (gIoMode & 0x1)
;;;318        {
;;;319            status_value = GPIO_ReadOutputDataBit(GPIO_GetPin(LED));
        0x0080eca2:    2001        .       MOVS     r0,#1
        0x0080eca4:    e002        ..      B        0x80ecac ; vTimerPxpIOCallback + 22
;;;320        }
;;;321        else if (gIoMode & 0x2)
        0x0080eca6:    0780        ..      LSLS     r0,r0,#30
        0x0080eca8:    d51a        ..      BPL      0x80ece0 ; vTimerPxpIOCallback + 74
;;;322        {
;;;323            status_value = GPIO_ReadOutputDataBit(GPIO_GetPin(BEEP));
        0x0080ecaa:    2002        .       MOVS     r0,#2
        0x0080ecac:    f000f977    ..w.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ecb0:    f000f8c9    ....    BL       GPIO_ReadOutputDataBit ; 0x80ee46
        0x0080ecb4:    4d49        IM      LDR      r5,[pc,#292] ; [0x80eddc] = 0x207f82
;;;324        }
;;;325        else
;;;326        {
;;;327            APP_PRINT_ERROR0("ERROR IO MODE");
;;;328            return;
;;;329        }
;;;330    
;;;331        if (status_value & 0x1)
        0x0080ecb6:    07c0        ..      LSLS     r0,r0,#31
        0x0080ecb8:    f04f0600    O...    MOV      r6,#0
        0x0080ecbc:    d018        ..      BEQ      0x80ecf0 ; vTimerPxpIOCallback + 90
;;;332        {
;;;333            xNewPeriod = xPeriodLow;
;;;334            GPIO_ResetBits(GPIO_GetPin(LED));
        0x0080ecbe:    2001        .       MOVS     r0,#1
        0x0080ecc0:    6867        gh      LDR      r7,[r4,#4]
        0x0080ecc2:    f000f96c    ..l.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ecc6:    f000f8cb    ....    BL       GPIO_ResetBits ; 0x80ee60
;;;335            GPIO_ResetBits(GPIO_GetPin(BEEP));
        0x0080ecca:    2002        .       MOVS     r0,#2
        0x0080eccc:    f000f967    ..g.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ecd0:    f000f8c6    ....    BL       GPIO_ResetBits ; 0x80ee60
;;;336            allowedPxpEnterDlps = true;
        0x0080ecd4:    2001        .       MOVS     r0,#1
        0x0080ecd6:    7028        (p      STRB     r0,[r5,#0]
;;;337            gActCnt--;
        0x0080ecd8:    68e0        .h      LDR      r0,[r4,#0xc]
        0x0080ecda:    1e40        @.      SUBS     r0,r0,#1
        0x0080ecdc:    60e0        .`      STR      r0,[r4,#0xc]
        0x0080ecde:    e01a        ..      B        0x80ed16 ; vTimerPxpIOCallback + 128
        0x0080ece0:    e8bd41f0    ...A    POP      {r4-r8,lr}
        0x0080ece4:    493a        :I      LDR      r1,[pc,#232] ; [0x80edd0] = 0x8800120
        0x0080ece6:    2200        ."      MOVS     r2,#0
        0x0080ece8:    319c        .1      ADDS     r1,r1,#0x9c
        0x0080ecea:    483a        :H      LDR      r0,[pc,#232] ; [0x80edd4] = 0x21103000
        0x0080ecec:    f7f89eb7    ....    B        log_buffer ; 0x7a5e
;;;338        }
;;;339        else
;;;340        {
;;;341            xNewPeriod = xPeriodHigh;
;;;342            if (gIoMode & 0x1)
        0x0080ecf0:    7820         x      LDRB     r0,[r4,#0]
        0x0080ecf2:    68a7        .h      LDR      r7,[r4,#8]
        0x0080ecf4:    07c0        ..      LSLS     r0,r0,#31
        0x0080ecf6:    d005        ..      BEQ      0x80ed04 ; vTimerPxpIOCallback + 110
;;;343            {
;;;344                GPIO_SetBits(GPIO_GetPin(LED));
        0x0080ecf8:    2001        .       MOVS     r0,#1
        0x0080ecfa:    f000f950    ..P.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ecfe:    f000f8aa    ....    BL       GPIO_SetBits ; 0x80ee56
;;;345                allowedPxpEnterDlps = false;
        0x0080ed02:    702e        .p      STRB     r6,[r5,#0]
;;;346            }
;;;347            if (gIoMode & 0x2)
        0x0080ed04:    7820         x      LDRB     r0,[r4,#0]
        0x0080ed06:    0780        ..      LSLS     r0,r0,#30
        0x0080ed08:    d505        ..      BPL      0x80ed16 ; vTimerPxpIOCallback + 128
;;;348            {
;;;349                GPIO_SetBits(GPIO_GetPin(BEEP));
        0x0080ed0a:    2002        .       MOVS     r0,#2
        0x0080ed0c:    f000f947    ..G.    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ed10:    f000f8a1    ....    BL       GPIO_SetBits ; 0x80ee56
;;;350                allowedPxpEnterDlps = false;
        0x0080ed14:    702e        .p      STRB     r6,[r5,#0]
;;;351            }
;;;352        }
;;;353        if (gActCnt)
        0x0080ed16:    68e0        .h      LDR      r0,[r4,#0xc]
        0x0080ed18:    b168        h.      CBZ      r0,0x80ed36 ; vTimerPxpIOCallback + 160
;;;354        {
;;;355            APP_PRINT_INFO0("xTimerPxpIO os_timer_restart.");
        0x0080ed1a:    492d        -I      LDR      r1,[pc,#180] ; [0x80edd0] = 0x8800120
        0x0080ed1c:    482d        -H      LDR      r0,[pc,#180] ; [0x80edd4] = 0x21103000
        0x0080ed1e:    2200        ."      MOVS     r2,#0
        0x0080ed20:    31b0        .1      ADDS     r1,r1,#0xb0
        0x0080ed22:    1c80        ..      ADDS     r0,r0,#2
        0x0080ed24:    f7f8de9b    ....    BL       log_buffer ; 0x7a5e
;;;356            os_timer_restart(&xTimerPxpIO, xNewPeriod);
        0x0080ed28:    4639        9F      MOV      r1,r7
        0x0080ed2a:    e8bd41f0    ...A    POP      {r4-r8,lr}
        0x0080ed2e:    4827        'H      LDR      r0,[pc,#156] ; [0x80edcc] = 0x208038
        0x0080ed30:    3010        .0      ADDS     r0,r0,#0x10
        0x0080ed32:    f417b784    ....    B        os_timer_restart ; 0x26c3e
;;;357        }
;;;358        else
;;;359        {
;;;360            gIoState = IoStateIdle;
        0x0080ed36:    482b        +H      LDR      r0,[pc,#172] ; [0x80ede4] = 0x2081d1
        0x0080ed38:    7006        .p      STRB     r6,[r0,#0]
;;;361        }
;;;362    }
        0x0080ed3a:    e8bd81f0    ....    POP      {r4-r8,pc}
    vTimerLongPressCallback
;;;363    
;;;364    /**
;;;365     * @brief    vTimerLongPressCallback
;;;366     * @note     if key still pressed , send long press message
;;;367     * @param[in] pxTimer
;;;368     * @return   void
;;;369     */
;;;370    void vTimerLongPressCallback(TimerHandle_t pxTimer)
;;;371    {
        0x0080ed3e:    b51c        ..      PUSH     {r2-r4,lr}
;;;372        T_IO_MSG bee_io_msg;
;;;373    
;;;374        gKeyStatus = keyLongPress;
        0x0080ed40:    4c22        "L      LDR      r4,[pc,#136] ; [0x80edcc] = 0x208038
        0x0080ed42:    2002        .       MOVS     r0,#2
        0x0080ed44:    7060        `p      STRB     r0,[r4,#1]
;;;375    
;;;376        keystatus = GPIO_ReadInputDataBit(GPIO_GetPin(KEY));
        0x0080ed46:    2014        .       MOVS     r0,#0x14
        0x0080ed48:    f000f929    ..).    BL       GPIO_GetPin ; 0x80ef9e
        0x0080ed4c:    f000f873    ..s.    BL       GPIO_ReadInputDataBit ; 0x80ee36
        0x0080ed50:    70a0        .p      STRB     r0,[r4,#2]
;;;377        if (keystatus == 0)
        0x0080ed52:    2800        .(      CMP      r0,#0
        0x0080ed54:    d108        ..      BNE      0x80ed68 ; vTimerLongPressCallback + 42
;;;378        {
;;;379            bee_io_msg.type = IO_MSG_TYPE_GPIO;
        0x0080ed56:    200b        .       MOVS     r0,#0xb
        0x0080ed58:    f8ad0000    ....    STRH     r0,[sp,#0]
;;;380            bee_io_msg.subtype = MSG_LONG_PRESS;
        0x0080ed5c:    2003        .       MOVS     r0,#3
        0x0080ed5e:    f8ad0002    ....    STRH     r0,[sp,#2]
;;;381            app_send_msg_to_apptask(&bee_io_msg);
        0x0080ed62:    4668        hF      MOV      r0,sp
        0x0080ed64:    f7fffd94    ....    BL       app_send_msg_to_apptask ; 0x80e890
;;;382        }
;;;383    }
        0x0080ed68:    bd1c        ..      POP      {r2-r4,pc}
    swTimerInit
;;;384    
;;;385    #if (AON_WDG_ENABLE == 1)
;;;386    void vTimerPeriodWakeupDlpsCallback(TimerHandle_t pxTimer)
;;;387    {
;;;388        APP_PRINT_INFO0("TimerPeriodWakeupDlps timeout!");
;;;389    }
;;;390    #endif
;;;391    
;;;392    /**
;;;393     * @brief    swTimerInit
;;;394     * @note     creat sw timer
;;;395     * @return   void
;;;396     */
;;;397    void swTimerInit()
;;;398    {
        0x0080ed6a:    b57c        |.      PUSH     {r2-r6,lr}
;;;399        bool retval ;
;;;400        /* xTimersRmcPairBtn is used to start bt pair process after timeout */
;;;401    
;;;402        retval = os_timer_create(&xTimerPxpIO, "xTimerPxpIO",  1, \
        0x0080ed6c:    f2af00d9    ....    ADR      r0,{pc}-0xd5 ; 0x80ec97
        0x0080ed70:    2500        .%      MOVS     r5,#0
        0x0080ed72:    e9cd5000    ...P    STRD     r5,r0,[sp,#0]
        0x0080ed76:    4815        .H      LDR      r0,[pc,#84] ; [0x80edcc] = 0x208038
        0x0080ed78:    2364        d#      MOVS     r3,#0x64
        0x0080ed7a:    2201        ."      MOVS     r2,#1
        0x0080ed7c:    a11c        ..      ADR      r1,{pc}+0x74 ; 0x80edf0
        0x0080ed7e:    3010        .0      ADDS     r0,r0,#0x10
        0x0080ed80:    f417f729    ..).    BL       os_timer_create ; 0x26bd6
        0x0080ed84:    4c1d        .L      LDR      r4,[pc,#116] ; [0x80edfc] = 0x21103002
        0x0080ed86:    0003        ..      MOVS     r3,r0
;;;403                                 100/*0.1s*/, false, vTimerPxpIOCallback);
;;;404        if (!retval)
        0x0080ed88:    d105        ..      BNE      0x80ed96 ; swTimerInit + 44
;;;405        {
;;;406            APP_PRINT_INFO1("xTimerAlert retval is %d", retval);
        0x0080ed8a:    4911        .I      LDR      r1,[pc,#68] ; [0x80edd0] = 0x8800120
        0x0080ed8c:    2201        ."      MOVS     r2,#1
        0x0080ed8e:    31d4        .1      ADDS     r1,r1,#0xd4
        0x0080ed90:    4620         F      MOV      r0,r4
        0x0080ed92:    f7f8de64    ..d.    BL       log_buffer ; 0x7a5e
;;;407        }
;;;408        retval = os_timer_create(&xTimerLongPress, "xTimerLongPress",  1, \
        0x0080ed96:    f2af0059    ..Y.    ADR      r0,{pc}-0x57 ; 0x80ed3f
        0x0080ed9a:    e9cd5000    ...P    STRD     r5,r0,[sp,#0]
        0x0080ed9e:    480b        .H      LDR      r0,[pc,#44] ; [0x80edcc] = 0x208038
        0x0080eda0:    f44f637a    O.zc    MOV      r3,#0xfa0
        0x0080eda4:    2201        ."      MOVS     r2,#1
        0x0080eda6:    a116        ..      ADR      r1,{pc}+0x5a ; 0x80ee00
        0x0080eda8:    3014        .0      ADDS     r0,r0,#0x14
        0x0080edaa:    f417f714    ....    BL       os_timer_create ; 0x26bd6
        0x0080edae:    0003        ..      MOVS     r3,r0
;;;409                                 4000/*4s*/, false, vTimerLongPressCallback);
;;;410        if (!retval)
        0x0080edb0:    d108        ..      BNE      0x80edc4 ; swTimerInit + 90
;;;411        {
;;;412            APP_PRINT_INFO1("xTimerLongPress retval is %d", retval);
        0x0080edb2:    b002        ..      ADD      sp,sp,#8
        0x0080edb4:    4620         F      MOV      r0,r4
        0x0080edb6:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0080edba:    4905        .I      LDR      r1,[pc,#20] ; [0x80edd0] = 0x8800120
        0x0080edbc:    2201        ."      MOVS     r2,#1
        0x0080edbe:    31f0        .1      ADDS     r1,r1,#0xf0
        0x0080edc0:    f7f89e4d    ..M.    B        log_buffer ; 0x7a5e
;;;413        }
;;;414    
;;;415    #if (AON_WDG_ENABLE == 1)
;;;416        retval = os_timer_create(&xTimerPeriodWakeupDlps, "xTimerPeriodWakeupDlps",  1, \
;;;417                                 TIMER_WAKEUP_DLPS_PERIOD, true, vTimerPeriodWakeupDlpsCallback);
;;;418        if (!retval)
;;;419        {
;;;420            APP_PRINT_INFO1("xTimerPeriodWakeupDlps retval is %d", retval);
;;;421        }
;;;422        else
;;;423        {
;;;424            os_timer_start(&xTimerPeriodWakeupDlps);
;;;425            APP_PRINT_INFO0("Start xTimerPeriodWakeupDlps!");;
;;;426        }
;;;427    #endif
;;;428    }
        0x0080edc4:    bd7c        |.      POP      {r2-r6,pc}
    $d
        0x0080edc6:    0000        ..      DCW    0
        0x0080edc8:    0c000100    ....    DCD    201326848
        0x0080edcc:    00208038    8. .    DCD    2129976
        0x0080edd0:    08800120     ...    DCD    142606624
        0x0080edd4:    21103000    .0.!    DCD    554708992
        0x0080edd8:    40001000    ...@    DCD    1073745920
        0x0080eddc:    00207f82    .. .    DCD    2129794
        0x0080ede0:    002081d0    .. .    DCD    2130384
        0x0080ede4:    002081d1    .. .    DCD    2130385
        0x0080ede8:    002081d2    .. .    DCD    2130386
        0x0080edec:    002081d8    .. .    DCD    2130392
        0x0080edf0:    6d695478    xTim    DCD    1835619448
        0x0080edf4:    78507265    erPx    DCD    2018538085
        0x0080edf8:    004f4970    pIO.    DCD    5196144
        0x0080edfc:    21103002    .0.!    DCD    554708994
        0x0080ee00:    6d695478    xTim    DCD    1835619448
        0x0080ee04:    6f4c7265    erLo    DCD    1867280997
        0x0080ee08:    7250676e    ngPr    DCD    1917871982
        0x0080ee0c:    00737365    ess.    DCD    7566181
    $t
    ChangeConnectionParameter
;;;429    /**
;;;430     * @brief change peripheral interval and latency function
;;;431     * @param interval - connection interval;
;;;432     * @param latency - peripheral connection latency;
;;;433     * @param timeout - supervision time out;
;;;434     * @return none
;;;435     */
;;;436    void ChangeConnectionParameter(uint16_t interval, uint16_t latency, uint16_t timeout)
;;;437    {
        0x0080ee10:    b50e        ..      PUSH     {r1-r3,lr}
        0x0080ee12:    460b        .F      MOV      r3,r1
;;;438        le_update_conn_param(0, interval, interval, latency, timeout / 10, interval * 2 - 2,
        0x0080ee14:    210a        .!      MOVS     r1,#0xa
        0x0080ee16:    fbb2f2f1    ....    UDIV     r2,r2,r1
        0x0080ee1a:    f06f0101    o...    MVN      r1,#1
        0x0080ee1e:    eb010140    ..@.    ADD      r1,r1,r0,LSL #1
        0x0080ee22:    b289        ..      UXTH     r1,r1
        0x0080ee24:    e9cd2100    ...!    STRD     r2,r1,[sp,#0]
        0x0080ee28:    4602        .F      MOV      r2,r0
        0x0080ee2a:    9102        ..      STR      r1,[sp,#8]
        0x0080ee2c:    4611        .F      MOV      r1,r2
        0x0080ee2e:    2000        .       MOVS     r0,#0
        0x0080ee30:    f43ef72b    >.+.    BL       le_update_conn_param ; 0x4dc8a
;;;439                             interval * 2 - 2);
;;;440    }
        0x0080ee34:    bd0e        ..      POP      {r1-r3,pc}
    GPIO_ReadInputDataBit
        0x0080ee36:    4a0d        .J      LDR      r2,[pc,#52] ; [0x80ee6c] = 0x40001000
;;; ..\include\SDK\peripheral\rtl876x_gpio.h
;;;385    {
        0x0080ee38:    4601        .F      MOV      r1,r0
        0x0080ee3a:    2000        .       MOVS     r0,#0
        0x0080ee3c:    6d12        .m      LDR      r2,[r2,#0x50]
        0x0080ee3e:    420a        .B      TST      r2,r1
        0x0080ee40:    d000        ..      BEQ      0x80ee44 ; GPIO_ReadInputDataBit + 14
;;;386        uint8_t bitstatus = RESET;
;;;387    
;;;388        /* Check the parameters */
;;;389        assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;390    
;;;391        if (GPIO->DATAIN & GPIO_Pin)
;;;392        {
;;;393            bitstatus = (uint8_t)SET;
        0x0080ee42:    2001        .       MOVS     r0,#1
;;;394        }
;;;395    
;;;396        return bitstatus;
;;;397    }
        0x0080ee44:    4770        pG      BX       lr
    GPIO_ReadOutputDataBit
        0x0080ee46:    4a09        .J      LDR      r2,[pc,#36] ; [0x80ee6c] = 0x40001000
;;;398    
;;;399    /**
;;;400      * @brief  Reads value of all  GPIO input data port.
;;;401      * @param  None
;;;402      * @retval GPIO input data port value.
;;;403      */
;;;404    __STATIC_INLINE uint32_t GPIO_ReadInputData(void)
;;;405    {
;;;406        return GPIO->DATAIN;
;;;407    }
;;;408    
;;;409    /**
;;;410      * @brief  Reads the specified output port pin.
;;;411      * @param  GPIO_Pin:  specifies the port bit to read.
;;;412      *   This parameter can be GPIO_Pin_x where x can be (0..31).
;;;413      * @retval The output port pin value.
;;;414      */
;;;415    __STATIC_INLINE uint8_t GPIO_ReadOutputDataBit(uint32_t GPIO_Pin)
;;;416    {
        0x0080ee48:    4601        .F      MOV      r1,r0
        0x0080ee4a:    2000        .       MOVS     r0,#0
        0x0080ee4c:    6812        .h      LDR      r2,[r2,#0]
        0x0080ee4e:    420a        .B      TST      r2,r1
        0x0080ee50:    d000        ..      BEQ      0x80ee54 ; GPIO_ReadOutputDataBit + 14
;;;417        uint8_t bitstatus = RESET;
;;;418    
;;;419        /* Check the parameters */
;;;420        assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;421    
;;;422        if (GPIO->DATAOUT & GPIO_Pin)
;;;423        {
;;;424            bitstatus = (uint8_t)SET;
        0x0080ee52:    2001        .       MOVS     r0,#1
;;;425        }
;;;426    
;;;427        return bitstatus;
;;;428    }
        0x0080ee54:    4770        pG      BX       lr
    GPIO_SetBits
;;;429    
;;;430    /**
;;;431      * @brief  Reads value of all  GPIO output data port.
;;;432      * @param  None
;;;433      * @retval GPIO output data port value.
;;;434      */
;;;435    __STATIC_INLINE uint32_t GPIO_ReadOutputData(void)
;;;436    {
;;;437        return ((uint32_t)GPIO->DATAOUT);
;;;438    }
;;;439    
;;;440    /**
;;;441      * @brief  Sets the selected data port bits.
;;;442      * @param  GPIO_Pin: specifies the port bits to be written.
;;;443      *   This parameter can be GPIO_Pin_x where x can be (0..31) or GPIO_Pin_All.
;;;444      * @retval None
;;;445      */
;;;446    __STATIC_INLINE void GPIO_SetBits(uint32_t GPIO_Pin)
;;;447    {
;;;448        /* Check the parameters */
;;;449        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;450    
;;;451        GPIO->DATAOUT |= GPIO_Pin;
        0x0080ee56:    4905        .I      LDR      r1,[pc,#20] ; [0x80ee6c] = 0x40001000
        0x0080ee58:    680a        .h      LDR      r2,[r1,#0]
        0x0080ee5a:    4302        .C      ORRS     r2,r2,r0
        0x0080ee5c:    600a        .`      STR      r2,[r1,#0]
;;;452    }
        0x0080ee5e:    4770        pG      BX       lr
    GPIO_ResetBits
;;;453    
;;;454    /**
;;;455      * @brief  Resets the selected data port bits.
;;;456      * @param  GPIO_Pin: specifies the port bits to be written.
;;;457      *   This parameter can be GPIO_Pin_0 to GPIO_Pin_31 or GPIO_Pin_All.
;;;458      * @retval None
;;;459      */
;;;460    __STATIC_INLINE void GPIO_ResetBits(uint32_t GPIO_Pin)
;;;461    {
;;;462        /* Check the parameters */
;;;463        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;464    
;;;465        GPIO->DATAOUT &= ~(GPIO_Pin);
        0x0080ee60:    4902        .I      LDR      r1,[pc,#8] ; [0x80ee6c] = 0x40001000
        0x0080ee62:    680a        .h      LDR      r2,[r1,#0]
        0x0080ee64:    4382        .C      BICS     r2,r2,r0
        0x0080ee66:    600a        .`      STR      r2,[r1,#0]
;;;466    }
        0x0080ee68:    4770        pG      BX       lr
    $d
        0x0080ee6a:    0000        ..      DCW    0
        0x0080ee6c:    40001000    ...@    DCD    1073745920
    $t
    .text
    DLPS_IORegister
;;; .\..\source\peripheral\rtl876x_io_dlps.c
;;;1894   {
        0x0080ee70:    b510        ..      PUSH     {r4,lr}
;;;1895       dlps_hw_control_cb_reg(DLPS_IO_EnterDlpsCb, DLPS_ENTER);
        0x0080ee72:    2100        .!      MOVS     r1,#0
        0x0080ee74:    4804        .H      LDR      r0,[pc,#16] ; [0x80ee88] = 0x207d25
        0x0080ee76:    f7f9dc3a    ..:.    BL       dlps_hw_control_cb_reg ; 0x86ee
;;;1896       dlps_hw_control_cb_reg(DLPS_IO_ExitDlpsCb, DLPS_EXIT4_BT_READY);
        0x0080ee7a:    e8bd4010    ...@    POP      {r4,lr}
        0x0080ee7e:    2104        .!      MOVS     r1,#4
        0x0080ee80:    4802        .H      LDR      r0,[pc,#8] ; [0x80ee8c] = 0x207e19
        0x0080ee82:    f7f99c34    ..4.    B        dlps_hw_control_cb_reg ; 0x86ee
    $d
        0x0080ee86:    0000        ..      DCW    0
        0x0080ee88:    00207d25    %} .    DCD    2129189
        0x0080ee8c:    00207e19    .~ .    DCD    2129433
    $t
    .text
    GPIO_DeInit
;;; .\..\source\peripheral\rtl876x_gpio.c
;;;33         RCC_PeriphClockCmd(APBPeriph_GPIO, APBPeriph_GPIO_CLOCK, DISABLE);
        0x0080ee90:    2200        ."      MOVS     r2,#0
        0x0080ee92:    f04f5104    O..Q    MOV      r1,#0x21000000
        0x0080ee96:    485d        ]H      LDR      r0,[pc,#372] ; [0x80f00c] = 0xc000100
        0x0080ee98:    f000b8bc    ....    B.W      RCC_PeriphClockCmd ; 0x80f014
    GPIO_Init
;;;34     }
;;;35     
;;;36     /**
;;;37       * @brief  Initializes the GPIO peripheral according to the specified
;;;38       *         parameters in the GPIO_InitStruct.
;;;39       * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
;;;40       *         contains the configuration information for the specified GPIO peripheral.
;;;41       * @retval None
;;;42       */
;;;43     void GPIO_Init(GPIO_InitTypeDef *GPIO_InitStruct)
;;;44     {
;;;45         /* Check the parameters */
;;;46         assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;47         assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;48         assert_param(IS_GPIOIT_LEVEL_TYPE(GPIO_InitStruct->GPIO_ITTrigger));
;;;49         assert_param(IS_GPIOIT_POLARITY_TYPE(GPIO_InitStruct->GPIO_ITPolarity));
;;;50         assert_param(IS_GPIOIT_DEBOUNCE_TYPE(GPIO_InitStruct->GPIO_ITDebounce));
;;;51     
;;;52         /* GPIO configure */
;;;53         if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT)
        0x0080ee9c:    7903        .y      LDRB     r3,[r0,#4]
        0x0080ee9e:    495c        \I      LDR      r1,[pc,#368] ; [0x80f010] = 0x40001000
        0x0080eea0:    2b01        .+      CMP      r3,#1
        0x0080eea2:    6802        .h      LDR      r2,[r0,#0]
        0x0080eea4:    684b        Kh      LDR      r3,[r1,#4]
;;; .\..\source\peripheral\rtl876x_gpio.c (44)
        0x0080eea6:    d030        0.      BEQ      0x80ef0a ; GPIO_Init + 110
;;;45         /* Check the parameters */
;;;46         assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;47         assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;48         assert_param(IS_GPIOIT_LEVEL_TYPE(GPIO_InitStruct->GPIO_ITTrigger));
;;;49         assert_param(IS_GPIOIT_POLARITY_TYPE(GPIO_InitStruct->GPIO_ITPolarity));
;;;50         assert_param(IS_GPIOIT_DEBOUNCE_TYPE(GPIO_InitStruct->GPIO_ITDebounce));
;;;51     
;;;52         /* GPIO configure */
;;;53         if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT)
;;;54         {
;;;55             GPIO->DATADIR |= GPIO_InitStruct->GPIO_Pin;
;;;56     
;;;57             if (GPIO_InitStruct->GPIO_ControlMode == GPIO_SOFTWARE_MODE)
;;;58             {
;;;59                 /* Config GPIO control software mode */
;;;60                 GPIO->DATASRC &= (~GPIO_InitStruct->GPIO_Pin);
;;;61             }
;;;62             else
;;;63             {
;;;64                 /* Config GPIO hardware control mode */
;;;65                 GPIO->DATASRC |= (GPIO_InitStruct->GPIO_Pin);
;;;66             }
;;;67     
;;;68         }
;;;69         else
;;;70         {
;;;71             /*Configure GPIO input mode */
;;;72             GPIO->DATADIR = GPIO->DATADIR & (~GPIO_InitStruct->GPIO_Pin);
        0x0080eea8:    4393        .C      BICS     r3,r3,r2
        0x0080eeaa:    604b        K`      STR      r3,[r1,#4]
;;;73     
;;;74             if (GPIO_InitStruct->GPIO_ITCmd == ENABLE)
        0x0080eeac:    7942        By      LDRB     r2,[r0,#5]
        0x0080eeae:    2a01        .*      CMP      r2,#1
        0x0080eeb0:    d12a        *.      BNE      0x80ef08 ; GPIO_Init + 108
;;;75             {
;;;76     
;;;77                 GPIO->INTMASK = ~GPIO_Pin_All;
        0x0080eeb2:    2200        ."      MOVS     r2,#0
        0x0080eeb4:    634a        Jc      STR      r2,[r1,#0x34]
;;;78     
;;;79                 /* configure GPIO interrupt trigger type */
;;;80                 if (GPIO_InitStruct->GPIO_ITTrigger == GPIO_INT_Trigger_LEVEL)
        0x0080eeb6:    7982        .y      LDRB     r2,[r0,#6]
        0x0080eeb8:    b38a        ..      CBZ      r2,0x80ef1e ; GPIO_Init + 130
;;;81                 {
;;;82                     GPIO->INTTYPE = GPIO->INTTYPE & (~GPIO_InitStruct->GPIO_Pin);
;;;83     
;;;84                     /* Level-sensitive synchronization enable register */
;;;85                     GPIO->LSSYNC |= GPIO_InitStruct->GPIO_Pin;
;;;86                 }
;;;87                 else if (GPIO_InitStruct->GPIO_ITTrigger == GPIO_INT_Trigger_EDGE)
        0x0080eeba:    2a01        .*      CMP      r2,#1
        0x0080eebc:    d03d        =.      BEQ      0x80ef3a ; GPIO_Init + 158
;;;88                 {
;;;89                     GPIO->INTTYPE = (GPIO->INTTYPE & (~GPIO_InitStruct->GPIO_Pin))
;;;90                                     | GPIO_InitStruct->GPIO_Pin;
;;;91                 }
;;;92                 else
;;;93                 {
;;;94                     GPIO->INTBOTHEDGE |= GPIO_InitStruct->GPIO_Pin;
        0x0080eebe:    6e8a        .n      LDR      r2,[r1,#0x68]
        0x0080eec0:    6803        .h      LDR      r3,[r0,#0]
        0x0080eec2:    431a        .C      ORRS     r2,r2,r3
        0x0080eec4:    668a        .f      STR      r2,[r1,#0x68]
;;;95                 }
;;;96     
;;;97                 /* configure Interrupt polarity register */
;;;98                 if (GPIO_InitStruct->GPIO_ITPolarity == GPIO_INT_POLARITY_ACTIVE_LOW)
        0x0080eec6:    79c2        .y      LDRB     r2,[r0,#7]
        0x0080eec8:    b352        R.      CBZ      r2,0x80ef20 ; GPIO_Init + 132
;;;99                 {
;;;100                    GPIO->INTPOLARITY = GPIO->INTPOLARITY & (~GPIO_InitStruct->GPIO_Pin);
;;;101                }
;;;102                else
;;;103                {
;;;104                    GPIO->INTPOLARITY = (GPIO->INTPOLARITY & (~GPIO_InitStruct->GPIO_Pin))
        0x0080eeca:    6bcb        .k      LDR      r3,[r1,#0x3c]
        0x0080eecc:    6802        .h      LDR      r2,[r0,#0]
        0x0080eece:    4393        .C      BICS     r3,r3,r2
        0x0080eed0:    4313        .C      ORRS     r3,r3,r2
        0x0080eed2:    63cb        .c      STR      r3,[r1,#0x3c]
;;;105                                        | GPIO_InitStruct->GPIO_Pin;
;;;106                }
;;;107                /* Configure Debounce enable register */
;;;108                if (GPIO_InitStruct->GPIO_ITDebounce == GPIO_INT_DEBOUNCE_DISABLE)
        0x0080eed4:    7a02        .z      LDRB     r2,[r0,#8]
        0x0080eed6:    b37a        z.      CBZ      r2,0x80ef38 ; GPIO_Init + 156
;;;109                {
;;;110                    GPIO->DEBOUNCE = GPIO->DEBOUNCE & (~GPIO_InitStruct->GPIO_Pin);
;;;111                }
;;;112                else
;;;113                {
;;;114                    GPIO->DEBOUNCE = (GPIO->DEBOUNCE & (~GPIO_InitStruct->GPIO_Pin))
        0x0080eed8:    6c8b        .l      LDR      r3,[r1,#0x48]
        0x0080eeda:    6802        .h      LDR      r2,[r0,#0]
        0x0080eedc:    4393        .C      BICS     r3,r3,r2
        0x0080eede:    4313        .C      ORRS     r3,r3,r2
        0x0080eee0:    648b        .d      STR      r3,[r1,#0x48]
;;;115                                     | GPIO_InitStruct->GPIO_Pin;
;;;116    
;;;117    #ifdef _IS_ASIC_
;;;118                    /* Config debounce time , default debounce DIV is 14*/
;;;119                    GPIO_DBCLK_DIV = (((0xd) << 8) | (1 << 12));
;;;120                    GPIO_DBCLK_DIV |= ((((GPIO_InitStruct->GPIO_DebounceTime) * (GPIO_CLOCK_SOURCE_KHZ) >>
;;;121                                         (14)) - 1) & 0xff);
;;;122    #else
;;;123                    /* Config debounce time , default debounce DIV is 13*/
;;;124                    GPIO_DBCLK_DIV = (((0x3) << 10) | (1 << 12));
        0x0080eee2:    f04f4180    O..A    MOV      r1,#0x40000000
        0x0080eee6:    f44f52e0    O..R    MOV      r2,#0x1c00
        0x0080eeea:    f8c12344    ..D#    STR      r2,[r1,#0x344]
;;;125                    GPIO_DBCLK_DIV |= ((((GPIO_InitStruct->GPIO_DebounceTime) * (GPIO_CLOCK_SOURCE_KHZ) >>
        0x0080eeee:    f8d12344    ..D#    LDR      r2,[r1,#0x344]
        0x0080eef2:    68c0        .h      LDR      r0,[r0,#0xc]
        0x0080eef4:    f6446320    D. c    MOV      r3,#0x4e20
        0x0080eef8:    4358        XC      MULS     r0,r3,r0
        0x0080eefa:    23ff        .#      MOVS     r3,#0xff
        0x0080eefc:    eb033050    ..P0    ADD      r0,r3,r0,LSR #13
        0x0080ef00:    b2c0        ..      UXTB     r0,r0
        0x0080ef02:    4302        .C      ORRS     r2,r2,r0
        0x0080ef04:    f8c12344    ..D#    STR      r2,[r1,#0x344]
;;;126                                         (13)) - 1) & 0xff);
;;;127    #endif
;;;128                }
;;;129    
;;;130                /* Configure Interrupt enable register */
;;;131                //GPIO->INTEN |= GPIO_InitStruct->GPIO_Pin;
;;;132            }
;;;133        }
;;;134    }
        0x0080ef08:    4770        pG      BX       lr
        0x0080ef0a:    4313        .C      ORRS     r3,r3,r2
        0x0080ef0c:    604b        K`      STR      r3,[r1,#4]
        0x0080ef0e:    7a42        Bz      LDRB     r2,[r0,#9]
        0x0080ef10:    2a00        .*      CMP      r2,#0
        0x0080ef12:    688a        .h      LDR      r2,[r1,#8]
        0x0080ef14:    6800        .h      LDR      r0,[r0,#0]
        0x0080ef16:    d004        ..      BEQ      0x80ef22 ; GPIO_Init + 134
        0x0080ef18:    4302        .C      ORRS     r2,r2,r0
        0x0080ef1a:    608a        .`      STR      r2,[r1,#8]
        0x0080ef1c:    4770        pG      BX       lr
        0x0080ef1e:    e002        ..      B        0x80ef26 ; GPIO_Init + 138
        0x0080ef20:    e011        ..      B        0x80ef46 ; GPIO_Init + 170
        0x0080ef22:    4382        .C      BICS     r2,r2,r0
        0x0080ef24:    e7f9        ..      B        0x80ef1a ; GPIO_Init + 126
        0x0080ef26:    6b8a        .k      LDR      r2,[r1,#0x38]
        0x0080ef28:    6803        .h      LDR      r3,[r0,#0]
        0x0080ef2a:    439a        .C      BICS     r2,r2,r3
        0x0080ef2c:    638a        .c      STR      r2,[r1,#0x38]
        0x0080ef2e:    6e0a        .n      LDR      r2,[r1,#0x60]
        0x0080ef30:    6803        .h      LDR      r3,[r0,#0]
        0x0080ef32:    431a        .C      ORRS     r2,r2,r3
        0x0080ef34:    660a        .f      STR      r2,[r1,#0x60]
        0x0080ef36:    e7c6        ..      B        0x80eec6 ; GPIO_Init + 42
        0x0080ef38:    e00a        ..      B        0x80ef50 ; GPIO_Init + 180
        0x0080ef3a:    6b8b        .k      LDR      r3,[r1,#0x38]
        0x0080ef3c:    6802        .h      LDR      r2,[r0,#0]
        0x0080ef3e:    4393        .C      BICS     r3,r3,r2
        0x0080ef40:    4313        .C      ORRS     r3,r3,r2
        0x0080ef42:    638b        .c      STR      r3,[r1,#0x38]
        0x0080ef44:    e7bf        ..      B        0x80eec6 ; GPIO_Init + 42
        0x0080ef46:    6bca        .k      LDR      r2,[r1,#0x3c]
        0x0080ef48:    6803        .h      LDR      r3,[r0,#0]
        0x0080ef4a:    439a        .C      BICS     r2,r2,r3
        0x0080ef4c:    63ca        .c      STR      r2,[r1,#0x3c]
        0x0080ef4e:    e7c1        ..      B        0x80eed4 ; GPIO_Init + 56
        0x0080ef50:    6c8a        .l      LDR      r2,[r1,#0x48]
        0x0080ef52:    6800        .h      LDR      r0,[r0,#0]
        0x0080ef54:    4382        .C      BICS     r2,r2,r0
        0x0080ef56:    648a        .d      STR      r2,[r1,#0x48]
        0x0080ef58:    e7e0        ..      B        0x80ef1c ; GPIO_Init + 128
    GPIO_StructInit
;;;135    
;;;136    /**
;;;137      * @brief    Fills each GPIO_InitStruct member with its default value.
;;;138      * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will
;;;139      *    be initialized.
;;;140      * @retval None
;;;141      */
;;;142    void GPIO_StructInit(GPIO_InitTypeDef *GPIO_InitStruct)
;;;143    {
;;;144        /* Reset GPIO init structure parameters values */
;;;145        GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
        0x0080ef5a:    f04f31ff    O..1    MOV      r1,#0xffffffff
;;;146        GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
        0x0080ef5e:    6001        .`      STR      r1,[r0,#0]
        0x0080ef60:    2100        .!      MOVS     r1,#0
        0x0080ef62:    7101        .q      STRB     r1,[r0,#4]
;;;147        GPIO_InitStruct->GPIO_ITCmd = DISABLE;
        0x0080ef64:    7141        Aq      STRB     r1,[r0,#5]
;;;148        GPIO_InitStruct->GPIO_ITTrigger = GPIO_INT_Trigger_LEVEL;
        0x0080ef66:    7181        .q      STRB     r1,[r0,#6]
;;;149        GPIO_InitStruct->GPIO_ITPolarity = GPIO_INT_POLARITY_ACTIVE_LOW;
        0x0080ef68:    71c1        .q      STRB     r1,[r0,#7]
;;;150        GPIO_InitStruct->GPIO_ITDebounce = GPIO_INT_DEBOUNCE_DISABLE;
        0x0080ef6a:    7201        .r      STRB     r1,[r0,#8]
;;;151        GPIO_InitStruct->GPIO_ControlMode = GPIO_SOFTWARE_MODE;
        0x0080ef6c:    7241        Ar      STRB     r1,[r0,#9]
;;;152        GPIO_InitStruct->GPIO_DebounceTime = 20;                 /* ms , can be 1~64 ms */
        0x0080ef6e:    2114        .!      MOVS     r1,#0x14
        0x0080ef70:    60c1        .`      STR      r1,[r0,#0xc]
;;;153    }
        0x0080ef72:    e7d3        ..      B        0x80ef1c ; GPIO_Init + 128
    GPIO_INTConfig
;;;154    
;;;155    /**
;;;156      * @brief enable the specified GPIO interrupt.
;;;157      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;158      * @retval None
;;;159      */
;;;160    void GPIO_INTConfig(uint32_t GPIO_Pin, FunctionalState NewState)
;;;161    {
;;;162        /* Check the parameters */
;;;163        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;164        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;165    
;;;166        if (NewState != DISABLE)
;;;167        {
;;;168            /* Enable the selected GPIO pin interrupts */
;;;169            GPIO->INTEN |= GPIO_Pin;
        0x0080ef74:    4a26        &J      LDR      r2,[pc,#152] ; [0x80f010] = 0x40001000
        0x0080ef76:    2900        .)      CMP      r1,#0
        0x0080ef78:    6b11        .k      LDR      r1,[r2,#0x30]
;;; .\..\source\peripheral\rtl876x_gpio.c (161)
        0x0080ef7a:    d001        ..      BEQ      0x80ef80 ; GPIO_INTConfig + 12
;;;162        /* Check the parameters */
;;;163        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;164        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;165    
;;;166        if (NewState != DISABLE)
;;;167        {
;;;168            /* Enable the selected GPIO pin interrupts */
;;;169            GPIO->INTEN |= GPIO_Pin;
        0x0080ef7c:    4301        .C      ORRS     r1,r1,r0
        0x0080ef7e:    e000        ..      B        0x80ef82 ; GPIO_INTConfig + 14
        0x0080ef80:    4381        .C      BICS     r1,r1,r0
        0x0080ef82:    6311        .c      STR      r1,[r2,#0x30]
;;;170        }
;;;171        else
;;;172        {
;;;173            /* Disable the selected GPIO pin interrupts */
;;;174            GPIO->INTEN &= ~GPIO_Pin;
;;;175        }
;;;176    }
        0x0080ef84:    e7ca        ..      B        0x80ef1c ; GPIO_Init + 128
    GPIO_ClearINTPendingBit
;;;177    
;;;178    /**
;;;179      * @brief clear the specified GPIO interrupt.
;;;180      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;181      * @retval None
;;;182      */
;;;183    void GPIO_ClearINTPendingBit(uint32_t GPIO_Pin)
;;;184    {
;;;185        /* Check the parameters */
;;;186        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;187    
;;;188        GPIO->INTCLR = GPIO_Pin;
        0x0080ef86:    4922        "I      LDR      r1,[pc,#136] ; [0x80f010] = 0x40001000
        0x0080ef88:    64c8        .d      STR      r0,[r1,#0x4c]
;;;189    }
        0x0080ef8a:    e7c7        ..      B        0x80ef1c ; GPIO_Init + 128
    GPIO_MaskINTConfig
;;;190    
;;;191    /**
;;;192      * @brief mask the specified GPIO interrupt.
;;;193      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;194      * @retval None
;;;195      */
;;;196    void GPIO_MaskINTConfig(uint32_t GPIO_Pin, FunctionalState NewState)
;;;197    {
;;;198        /* Check the parameters */
;;;199        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;200        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;201    
;;;202        if (NewState != DISABLE)
;;;203        {
;;;204            GPIO->INTMASK |= GPIO_Pin;
        0x0080ef8c:    4a20         J      LDR      r2,[pc,#128] ; [0x80f010] = 0x40001000
        0x0080ef8e:    2900        .)      CMP      r1,#0
        0x0080ef90:    6b51        Qk      LDR      r1,[r2,#0x34]
;;; .\..\source\peripheral\rtl876x_gpio.c (197)
        0x0080ef92:    d001        ..      BEQ      0x80ef98 ; GPIO_MaskINTConfig + 12
;;;198        /* Check the parameters */
;;;199        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;200        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;201    
;;;202        if (NewState != DISABLE)
;;;203        {
;;;204            GPIO->INTMASK |= GPIO_Pin;
        0x0080ef94:    4301        .C      ORRS     r1,r1,r0
        0x0080ef96:    e000        ..      B        0x80ef9a ; GPIO_MaskINTConfig + 14
        0x0080ef98:    4381        .C      BICS     r1,r1,r0
        0x0080ef9a:    6351        Qc      STR      r1,[r2,#0x34]
;;;205        }
;;;206        else
;;;207        {
;;;208            GPIO->INTMASK &= ~(GPIO_Pin);
;;;209        }
;;;210    }
        0x0080ef9c:    e7be        ..      B        0x80ef1c ; GPIO_Init + 128
    GPIO_GetPin
        0x0080ef9e:    2101        .!      MOVS     r1,#1
        0x0080efa0:    281e        .(      CMP      r0,#0x1e
;;;211    
;;;212    /**
;;;213      * @brief get the specified GPIO pin.
;;;214      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;215      * @retval  GPIO pin for GPIO initialization.
;;;216      */
;;;217    uint32_t GPIO_GetPin(uint8_t Pin_num)
;;;218    {
        0x0080efa2:    d90e        ..      BLS      0x80efc2 ; GPIO_GetPin + 36
;;;219        /* Check the parameters */
;;;220        assert_param(IS_PIN_NUM(Pin_num));
;;;221    
;;;222        if (Pin_num <= P3_6)
;;;223        {
;;;224            return  BIT(Pin_num);
;;;225        }
;;;226        else if ((Pin_num <= P4_3) && (Pin_num >= P4_0))
        0x0080efa4:    f1a00220    .. .    SUB      r2,r0,#0x20
        0x0080efa8:    2a03        .*      CMP      r2,#3
        0x0080efaa:    d801        ..      BHI      0x80efb0 ; GPIO_GetPin + 18
        0x0080efac:    1f00        ..      SUBS     r0,r0,#4
;;;227        {
;;;228            return BIT(Pin_num - 4);
        0x0080efae:    e008        ..      B        0x80efc2 ; GPIO_GetPin + 36
;;;229        }
;;;230        else if ((Pin_num == H_0) || (Pin_num == H_1) || (Pin_num == H_2))
        0x0080efb0:    2824        $(      CMP      r0,#0x24
        0x0080efb2:    d005        ..      BEQ      0x80efc0 ; GPIO_GetPin + 34
        0x0080efb4:    2825        %(      CMP      r0,#0x25
        0x0080efb6:    d003        ..      BEQ      0x80efc0 ; GPIO_GetPin + 34
        0x0080efb8:    2826        &(      CMP      r0,#0x26
        0x0080efba:    d001        ..      BEQ      0x80efc0 ; GPIO_GetPin + 34
        0x0080efbc:    20ff        .       MOVS     r0,#0xff
        0x0080efbe:    e7ad        ..      B        0x80ef1c ; GPIO_Init + 128
        0x0080efc0:    380b        .8      SUBS     r0,r0,#0xb
;;;231        {
;;;232            return BIT(Pin_num - 11);
        0x0080efc2:    fa01f000    ....    LSL      r0,r1,r0
;;;233        }
;;;234    
;;;235        return 0xFF;
;;;236    }
        0x0080efc6:    e7a9        ..      B        0x80ef1c ; GPIO_Init + 128
    GPIO_GetNum
;;;237    
;;;238    /**
;;;239      * @brief get the specified GPIO pin number.
;;;240      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;241      * @retval  GPIO pin number.
;;;242      */
;;;243    uint8_t GPIO_GetNum(uint8_t Pin_num)
;;;244    {
;;;245        /* Check the parameters */
;;;246        assert_param(IS_PIN_NUM(Pin_num));
;;;247    
;;;248        if (Pin_num <= P3_6)
        0x0080efc8:    281e        .(      CMP      r0,#0x1e
;;; .\..\source\peripheral\rtl876x_gpio.c (244)
        0x0080efca:    d9a7        ..      BLS      0x80ef1c ; GPIO_Init + 128
;;;245        /* Check the parameters */
;;;246        assert_param(IS_PIN_NUM(Pin_num));
;;;247    
;;;248        if (Pin_num <= P3_6)
;;;249        {
;;;250            return (Pin_num);
;;;251        }
;;;252        else if ((Pin_num <= P4_3) && (Pin_num >= P4_0))
        0x0080efcc:    f1a00120    .. .    SUB      r1,r0,#0x20
        0x0080efd0:    2903        .)      CMP      r1,#3
        0x0080efd2:    d801        ..      BHI      0x80efd8 ; GPIO_GetNum + 16
        0x0080efd4:    1f00        ..      SUBS     r0,r0,#4
;;;253        {
;;;254            return (Pin_num - 4);
        0x0080efd6:    e008        ..      B        0x80efea ; GPIO_GetNum + 34
;;;255        }
;;;256        else if ((Pin_num == H_0) || (Pin_num == H_1) || (Pin_num == H_2))
        0x0080efd8:    2824        $(      CMP      r0,#0x24
        0x0080efda:    d005        ..      BEQ      0x80efe8 ; GPIO_GetNum + 32
        0x0080efdc:    2825        %(      CMP      r0,#0x25
        0x0080efde:    d003        ..      BEQ      0x80efe8 ; GPIO_GetNum + 32
        0x0080efe0:    2826        &(      CMP      r0,#0x26
        0x0080efe2:    d001        ..      BEQ      0x80efe8 ; GPIO_GetNum + 32
        0x0080efe4:    20ff        .       MOVS     r0,#0xff
        0x0080efe6:    e799        ..      B        0x80ef1c ; GPIO_Init + 128
        0x0080efe8:    380b        .8      SUBS     r0,r0,#0xb
;;;257        {
;;;258            return (Pin_num - 11);
        0x0080efea:    b2c0        ..      UXTB     r0,r0
;;;259        }
;;;260    
;;;261        return 0xFF;
;;;262    }
        0x0080efec:    e796        ..      B        0x80ef1c ; GPIO_Init + 128
    GPIO_DBClkCmd
        0x0080efee:    f04f4180    O..A    MOV      r1,#0x40000000
        0x0080eff2:    2800        .(      CMP      r0,#0
        0x0080eff4:    f8d10344    ..D.    LDR      r0,[r1,#0x344]
;;;263    
;;;264    /**
;;;265      * @brief get the specified GPIO pin number.
;;;266      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;267      * @retval  GPIO pin number.
;;;268      */
;;;269    void GPIO_DBClkCmd(FunctionalState NewState)
;;;270    {
        0x0080eff8:    d002        ..      BEQ      0x80f000 ; GPIO_DBClkCmd + 18
;;;271        if (NewState != DISABLE)
;;;272        {
;;;273            GPIO_DBCLK_DIV |= BIT12;
        0x0080effa:    f4405080    @..P    ORR      r0,r0,#0x1000
        0x0080effe:    e001        ..      B        0x80f004 ; GPIO_DBClkCmd + 22
        0x0080f000:    f4205080     ..P    BIC      r0,r0,#0x1000
        0x0080f004:    f8c10344    ..D.    STR      r0,[r1,#0x344]
;;;274        }
;;;275        else
;;;276        {
;;;277            GPIO_DBCLK_DIV &= ~BIT12;
;;;278        }
;;;279    }
        0x0080f008:    e788        ..      B        0x80ef1c ; GPIO_Init + 128
    $d
        0x0080f00a:    0000        ..      DCW    0
        0x0080f00c:    0c000100    ....    DCD    201326848
        0x0080f010:    40001000    ...@    DCD    1073745920
    $t
    .text
    RCC_PeriphClockCmd
;;; .\..\source\peripheral\rtl876x_rcc.c
;;;66     {
        0x0080f014:    b5f0        ..      PUSH     {r4-r7,lr}
        0x0080f016:    f44f7790    O..w    MOV      r7,#0x120
        0x0080f01a:    067b        {.      LSLS     r3,r7,#25
;;;67         /* Check the parameters */
;;;68         assert_param(IS_APB_PERIPH(APBPeriph));
;;;69         assert_param(IS_APB_PERIPH_CLOCK(APBPeriph_Clock));
;;;70         assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;71     
;;;72         uint32_t apbRegOff = ((APBPeriph & (0x03 << 26)) >> 26);
        0x0080f01c:    f3c06681    ...f    UBFX     r6,r0,#26,#2
;;;73         uint32_t clkRegOff = ((APBPeriph_Clock & (0x03 << 29)) >> 29);
        0x0080f020:    f3c17541    ..Au    UBFX     r5,r1,#29,#2
        0x0080f024:    f44f7ea0    O..~    MOV      lr,#0x140
        0x0080f028:    ea400401    @...    ORR      r4,r0,r1
;;;74     
;;;75         /*Open clock gating first*/
;;;76         if (NewState == ENABLE)
        0x0080f02c:    2a01        .*      CMP      r2,#1
        0x0080f02e:    d006        ..      BEQ      0x80f03e ; RCC_PeriphClockCmd + 42
        0x0080f030:    42b9        .B      CMP      r1,r7
        0x0080f032:    d06f        o.      BEQ      0x80f114 ; RCC_PeriphClockCmd + 256
        0x0080f034:    4571        qE      CMP      r1,lr
        0x0080f036:    d06d        m.      BEQ      0x80f114 ; RCC_PeriphClockCmd + 256
        0x0080f038:    2910        .)      CMP      r1,#0x10
        0x0080f03a:    d06b        k.      BEQ      0x80f114 ; RCC_PeriphClockCmd + 256
        0x0080f03c:    e04b        K.      B        0x80f0d6 ; RCC_PeriphClockCmd + 194
;;;77         {
;;;78             if (APBPeriph_Clock == APBPeriph_KEYSCAN_CLOCK)
        0x0080f03e:    f1a14cc0    ...L    SUB      r12,r1,#0x60000000
        0x0080f042:    f1bc0c40    ..@.    SUBS     r12,r12,#0x40
        0x0080f046:    d018        ..      BEQ      0x80f07a ; RCC_PeriphClockCmd + 102
        0x0080f048:    f1b14fc2    ...O    CMP      r1,#0x61000000
        0x0080f04c:    d020         .      BEQ      0x80f090 ; RCC_PeriphClockCmd + 124
        0x0080f04e:    f1a14cc0    ...L    SUB      r12,r1,#0x60000000
        0x0080f052:    f1bc0c10    ....    SUBS     r12,r12,#0x10
        0x0080f056:    d003        ..      BEQ      0x80f060 ; RCC_PeriphClockCmd + 76
        0x0080f058:    f8dfc2f0    ....    LDR      r12,[pc,#752] ; [0x80f34c] = 0x60010000
        0x0080f05c:    4561        aE      CMP      r1,r12
        0x0080f05e:    d124        $.      BNE      0x80f0aa ; RCC_PeriphClockCmd + 150
        0x0080f060:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x0080f064:    f04c6c80    L..l    ORR      r12,r12,#0x4000000
        0x0080f068:    f8c3c20c    ....    STR      r12,[r3,#0x20c]
        0x0080f06c:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x0080f070:    f04c6c00    L..l    ORR      r12,r12,#0x8000000
        0x0080f074:    f8c3c20c    ....    STR      r12,[r3,#0x20c]
        0x0080f078:    e027        '.      B        0x80f0ca ; RCC_PeriphClockCmd + 182
;;;79             {
;;;80                 /*Open 5M clock source*/
;;;81                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
        0x0080f07a:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x0080f07e:    f04c6c80    L..l    ORR      r12,r12,#0x4000000
        0x0080f082:    f8c3c20c    ....    STR      r12,[r3,#0x20c]
;;;82                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
        0x0080f086:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x0080f08a:    f04c5c00    L..\    ORR      r12,r12,#0x20000000
        0x0080f08e:    e7f1        ..      B        0x80f074 ; RCC_PeriphClockCmd + 96
;;;83             }
;;;84             else if (APBPeriph_Clock == APBPeriph_ADC_CLOCK)
;;;85             {
;;;86                 /*Open 10M clock source*/
;;;87                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
        0x0080f090:    f8d3420c    ...B    LDR      r4,[r3,#0x20c]
        0x0080f094:    f0446480    D..d    ORR      r4,r4,#0x4000000
        0x0080f098:    f8c3420c    ...B    STR      r4,[r3,#0x20c]
;;;88                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
        0x0080f09c:    f8d3420c    ...B    LDR      r4,[r3,#0x20c]
        0x0080f0a0:    f0445480    D..T    ORR      r4,r4,#0x10000000
        0x0080f0a4:    f8c3420c    ...B    STR      r4,[r3,#0x20c]
        0x0080f0a8:    e015        ..      B        0x80f0d6 ; RCC_PeriphClockCmd + 194
;;;89             }
;;;90             else if ((APBPeriph_Clock == APBPeriph_QDEC_CLOCK) || (APBPeriph_Clock == APBPeriph_SPI2W_CLOCK))
;;;91             {
;;;92                 /*Open 20M clock source*/
;;;93                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;94                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;95             }
;;;96             else if (APBPeriph_Clock == APBPeriph_TIMER_CLOCK)
        0x0080f0aa:    f8dfc2a4    ....    LDR      r12,[pc,#676] ; [0x80f350] = 0x20004000
        0x0080f0ae:    4561        aE      CMP      r1,r12
        0x0080f0b0:    d10b        ..      BNE      0x80f0ca ; RCC_PeriphClockCmd + 182
;;;97             {
;;;98                 /* Enable TIM0~1 fixed 40M */
;;;99                 CLK_SOURCE_REG_2 |= BIT9;
        0x0080f0b2:    f8d3c360    ..`.    LDR      r12,[r3,#0x360]
        0x0080f0b6:    f44c7c00    L..|    ORR      r12,r12,#0x200
        0x0080f0ba:    f8c3c360    ..`.    STR      r12,[r3,#0x360]
;;;100                /* enable TIM2~7 ICG*/
;;;101                CLK_SOURCE_REG_0 |= BIT4;
        0x0080f0be:    f8d3c348    ..H.    LDR      r12,[r3,#0x348]
        0x0080f0c2:    f04c0c10    L...    ORR      r12,r12,#0x10
        0x0080f0c6:    f8c3c348    ..H.    STR      r12,[r3,#0x348]
;;;102            }
;;;103        }
;;;104    
;;;105        /* Special register handle */
;;;106        if (NewState == ENABLE)
;;;107        {
;;;108            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
        0x0080f0ca:    42b9        .B      CMP      r1,r7
        0x0080f0cc:    d01d        ..      BEQ      0x80f10a ; RCC_PeriphClockCmd + 246
        0x0080f0ce:    4571        qE      CMP      r1,lr
        0x0080f0d0:    d01b        ..      BEQ      0x80f10a ; RCC_PeriphClockCmd + 246
;;;109                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
        0x0080f0d2:    2910        .)      CMP      r1,#0x10
        0x0080f0d4:    d019        ..      BEQ      0x80f10a ; RCC_PeriphClockCmd + 246
;;;110            {
;;;111                SYSBLKCTRL->u_220 |= APBPeriph | APBPeriph_Clock;
;;;112                return;
;;;113            }
;;;114        }
;;;115        else
;;;116        {
;;;117            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
;;;118                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
;;;119            {
;;;120                SYSBLKCTRL->u_220 &= ~(APBPeriph | APBPeriph_Clock);
;;;121                return;
;;;122            }
;;;123        }
;;;124    
;;;125        /* clear flag */
;;;126        APBPeriph &= (~(0x03 << 26));
        0x0080f0d6:    f0206340     .@c    BIC      r3,r0,#0xc000000
;;;127        APBPeriph_Clock &= (~(0x03 << 29));
        0x0080f0da:    f02140c0    !..@    BIC      r0,r1,#0x60000000
        0x0080f0de:    ea4f0186    O...    LSL      r1,r6,#2
        0x0080f0e2:    f1014180    ...A    ADD      r1,r1,#0x40000000
;;;128    
;;;129        if (NewState == ENABLE)
        0x0080f0e6:    2a01        .*      CMP      r2,#1
        0x0080f0e8:    f8d12210    ..."    LDR      r2,[r1,#0x210]
        0x0080f0ec:    d018        ..      BEQ      0x80f120 ; RCC_PeriphClockCmd + 268
;;;130        {
;;;131            //enable peripheral
;;;132            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) |= APBPeriph;
;;;133            //enable peripheral clock
;;;134            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= APBPeriph_Clock;
;;;135            //enable peripheral clock in sleep mode
;;;136            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= (APBPeriph_Clock << 1);
;;;137        }
;;;138        else
;;;139        {
;;;140            //disable peripheral
;;;141            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) &= (~APBPeriph);
        0x0080f0ee:    439a        .C      BICS     r2,r2,r3
;;;142            //disable peripheral clock
;;;143            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~APBPeriph_Clock);
        0x0080f0f0:    f8c12210    ..."    STR      r2,[r1,#0x210]
        0x0080f0f4:    00a9        ..      LSLS     r1,r5,#2
        0x0080f0f6:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x0080f0fa:    f8d1222c    ..,"    LDR      r2,[r1,#0x22c]
        0x0080f0fe:    4382        .C      BICS     r2,r2,r0
;;;144            //disable peripheral clock in sleep mode
;;;145            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~(APBPeriph_Clock << 1));
        0x0080f100:    ea220040    ".@.    BIC      r0,r2,r0,LSL #1
        0x0080f104:    f8c1022c    ..,.    STR      r0,[r1,#0x22c]
;;;146        }
;;;147    
;;;148        return;
;;;149    }
        0x0080f108:    bdf0        ..      POP      {r4-r7,pc}
        0x0080f10a:    f8d30220    .. .    LDR      r0,[r3,#0x220]
        0x0080f10e:    4320         C      ORRS     r0,r0,r4
        0x0080f110:    e003        ..      B        0x80f11a ; RCC_PeriphClockCmd + 262
        0x0080f112:    e7ff        ..      B        0x80f114 ; RCC_PeriphClockCmd + 256
        0x0080f114:    f8d30220    .. .    LDR      r0,[r3,#0x220]
        0x0080f118:    43a0        .C      BICS     r0,r0,r4
        0x0080f11a:    f8c30220    .. .    STR      r0,[r3,#0x220]
        0x0080f11e:    bdf0        ..      POP      {r4-r7,pc}
        0x0080f120:    431a        .C      ORRS     r2,r2,r3
        0x0080f122:    f8c12210    ..."    STR      r2,[r1,#0x210]
        0x0080f126:    00a9        ..      LSLS     r1,r5,#2
        0x0080f128:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x0080f12c:    f8d1222c    ..,"    LDR      r2,[r1,#0x22c]
        0x0080f130:    4302        .C      ORRS     r2,r2,r0
        0x0080f132:    ea420040    B.@.    ORR      r0,r2,r0,LSL #1
        0x0080f136:    e7e5        ..      B        0x80f104 ; RCC_PeriphClockCmd + 240
    RCC_SPIClkDivConfig
;;;150    
;;;151    /**
;;;152      * @brief  SPI clock divider config.
;;;153      * @param  SPIx: where x can be 0 or 1 to select the SPI peripheral.
;;;154      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;155      *      this parameter can be one of the following values:
;;;156      *     @arg SPI_CLOCK_DIV_1
;;;157      *     @arg SPI_CLOCK_DIV_2
;;;158      *     @arg SPI_CLOCK_DIV_4
;;;159      *     @arg SPI_CLOCK_DIV_8
;;;160      * @retval None
;;;161      */
;;;162    void RCC_SPIClkDivConfig(SPI_TypeDef *SPIx, uint16_t ClockDiv)
;;;163    {
;;;164        assert_param(IS_SPI_DIV(ClockDiv));
;;;165    
;;;166        /* Config I2C clock divider */
;;;167        if (SPIx == SPI0)
        0x0080f138:    4b86        .K      LDR      r3,[pc,#536] ; [0x80f354] = 0x40013000
        0x0080f13a:    f04f4280    O..B    MOV      r2,#0x40000000
        0x0080f13e:    4298        .B      CMP      r0,r3
;;; .\..\source\peripheral\rtl876x_rcc.c (163)
        0x0080f140:    d116        ..      BNE      0x80f170 ; RCC_SPIClkDivConfig + 56
;;;164        assert_param(IS_SPI_DIV(ClockDiv));
;;;165    
;;;166        /* Config I2C clock divider */
;;;167        if (SPIx == SPI0)
;;;168        {
;;;169            /* disable clock first */
;;;170            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_SPI0_EN_Msk;
        0x0080f142:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x0080f146:    f4203080     ..0    BIC      r0,r0,#0x10000
        0x0080f14a:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;171            //platform_delay_us(1);
;;;172    
;;;173            CLK_SOURCE_REG_1 &= ~(0x03 << 19);
        0x0080f14e:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080f152:    f42010c0     ...    BIC      r0,r0,#0x180000
        0x0080f156:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;174            CLK_SOURCE_REG_1 |= (ClockDiv << 19);
        0x0080f15a:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080f15e:    ea4040c1    @..@    ORR      r0,r0,r1,LSL #19
        0x0080f162:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;175    
;;;176            //platform_delay_us(1);
;;;177            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_SPI0_EN_Msk;
        0x0080f166:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x0080f16a:    f4403080    @..0    ORR      r0,r0,#0x10000
        0x0080f16e:    e018        ..      B        0x80f1a2 ; RCC_SPIClkDivConfig + 106
;;;178        }
;;;179        else if (SPIx == SPI1)
        0x0080f170:    4b79        yK      LDR      r3,[pc,#484] ; [0x80f358] = 0x40013400
        0x0080f172:    4298        .B      CMP      r0,r3
        0x0080f174:    d117        ..      BNE      0x80f1a6 ; RCC_SPIClkDivConfig + 110
;;;180        {
;;;181            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_SPI1_EN_Msk;
        0x0080f176:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x0080f17a:    f4202080     ..     BIC      r0,r0,#0x40000
        0x0080f17e:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;182            //platform_delay_us(1);
;;;183    
;;;184            CLK_SOURCE_REG_1 &= ~(0x03 << 21);
        0x0080f182:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080f186:    f42000c0     ...    BIC      r0,r0,#0x600000
        0x0080f18a:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;185            CLK_SOURCE_REG_1 |= (ClockDiv << 21);
        0x0080f18e:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080f192:    ea405041    @.AP    ORR      r0,r0,r1,LSL #21
        0x0080f196:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;186    
;;;187            //platform_delay_us(1);
;;;188            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_SPI1_EN_Msk;
        0x0080f19a:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x0080f19e:    f4402080    @..     ORR      r0,r0,#0x40000
        0x0080f1a2:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;189        }
;;;190        return;
;;;191    }
        0x0080f1a6:    4770        pG      BX       lr
    RCC_I2CClkDivConfig
;;;192    
;;;193    /**
;;;194      * @brief  I2C clock divider config.
;;;195      * @param  I2Cx: where x can be 0 or 1 to select the I2C peripheral.
;;;196      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;197      *      this parameter can be one of the following values:
;;;198      *     @arg I2C_CLOCK_DIV_1
;;;199      *     @arg I2C_CLOCK_DIV_2
;;;200      *     @arg I2C_CLOCK_DIV_4
;;;201      *     @arg I2C_CLOCK_DIV_8
;;;202      * @retval None
;;;203      */
;;;204    void RCC_I2CClkDivConfig(I2C_TypeDef *I2Cx, uint16_t ClockDiv)
;;;205    {
;;;206        assert_param(IS_I2C_DIV(ClockDiv));
;;;207    
;;;208        /* Config I2C clock divider */
;;;209        if (I2Cx == I2C0)
        0x0080f1a8:    4b6c        lK      LDR      r3,[pc,#432] ; [0x80f35c] = 0x40015000
        0x0080f1aa:    049a        ..      LSLS     r2,r3,#18
        0x0080f1ac:    4298        .B      CMP      r0,r3
;;; .\..\source\peripheral\rtl876x_rcc.c (205)
        0x0080f1ae:    d116        ..      BNE      0x80f1de ; RCC_I2CClkDivConfig + 54
;;;206        assert_param(IS_I2C_DIV(ClockDiv));
;;;207    
;;;208        /* Config I2C clock divider */
;;;209        if (I2Cx == I2C0)
;;;210        {
;;;211            /* disable clock first */
;;;212            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 &= ~SYSBLK_ACTCK_I2C0_EN_Msk;
        0x0080f1b0:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x0080f1b4:    f0200001     ...    BIC      r0,r0,#1
        0x0080f1b8:    f8c20238    ..8.    STR      r0,[r2,#0x238]
;;;213            //platform_delay_us(1);
;;;214    
;;;215            CLK_SOURCE_REG_1 &= ~(0x03 << 15);
        0x0080f1bc:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080f1c0:    f42030c0     ..0    BIC      r0,r0,#0x18000
        0x0080f1c4:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;216            CLK_SOURCE_REG_1 |= (ClockDiv << 15);
        0x0080f1c8:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080f1cc:    ea4030c1    @..0    ORR      r0,r0,r1,LSL #15
        0x0080f1d0:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;217    
;;;218            //platform_delay_us(1);
;;;219            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= SYSBLK_ACTCK_I2C0_EN_Msk;
        0x0080f1d4:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x0080f1d8:    f0400001    @...    ORR      r0,r0,#1
        0x0080f1dc:    e018        ..      B        0x80f210 ; RCC_I2CClkDivConfig + 104
;;;220        }
;;;221        else if (I2Cx == I2C1)
        0x0080f1de:    4b60        `K      LDR      r3,[pc,#384] ; [0x80f360] = 0x40015400
        0x0080f1e0:    4298        .B      CMP      r0,r3
        0x0080f1e2:    d117        ..      BNE      0x80f214 ; RCC_I2CClkDivConfig + 108
;;;222        {
;;;223            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 &= ~SYSBLK_ACTCK_I2C1_EN_Msk;
        0x0080f1e4:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x0080f1e8:    f0200004     ...    BIC      r0,r0,#4
        0x0080f1ec:    f8c20238    ..8.    STR      r0,[r2,#0x238]
;;;224            //platform_delay_us(1);
;;;225    
;;;226            CLK_SOURCE_REG_1 &= ~(0x03 << 17);
        0x0080f1f0:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080f1f4:    f42020c0     ..     BIC      r0,r0,#0x60000
        0x0080f1f8:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;227            CLK_SOURCE_REG_1 |= (ClockDiv << 17);
        0x0080f1fc:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080f200:    ea404041    @.A@    ORR      r0,r0,r1,LSL #17
        0x0080f204:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;228    
;;;229            //platform_delay_us(1);
;;;230            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= SYSBLK_ACTCK_I2C1_EN_Msk;
        0x0080f208:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x0080f20c:    f0400004    @...    ORR      r0,r0,#4
        0x0080f210:    f8c20238    ..8.    STR      r0,[r2,#0x238]
;;;231        }
;;;232    
;;;233        return;
;;;234    }
        0x0080f214:    4770        pG      BX       lr
    RCC_UARTClkDivConfig
        0x0080f216:    4b53        SK      LDR      r3,[pc,#332] ; [0x80f364] = 0x40012000
        0x0080f218:    045a        Z.      LSLS     r2,r3,#17
        0x0080f21a:    4298        .B      CMP      r0,r3
;;;235    
;;;236    /**
;;;237      * @brief  UART clock divider config.
;;;238      * @param  UARTx: selected UART peripheral.
;;;239      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;240      *      this parameter can be one of the following values:
;;;241      *     @arg UART_CLOCK_DIV_1
;;;242      *     @arg UART_CLOCK_DIV_2
;;;243      *     @arg UART_CLOCK_DIV_4
;;;244      *     @arg UART_CLOCK_DIV_16
;;;245      * @retval None
;;;246      */
;;;247    void RCC_UARTClkDivConfig(UART_TypeDef *UARTx, uint16_t ClockDiv)
;;;248    {
        0x0080f21c:    d118        ..      BNE      0x80f250 ; RCC_UARTClkDivConfig + 58
;;;249        assert_param(IS_UART_DIV(ClockDiv));
;;;250    
;;;251        /* Config UART clock divider */
;;;252        if (UARTx == UART)
;;;253        {
;;;254            /* disable clock first */
;;;255            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_UART0DATA_EN_Msk;
        0x0080f21e:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x0080f222:    f0200001     ...    BIC      r0,r0,#1
        0x0080f226:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;256            //platform_delay_us(1);
;;;257    
;;;258            CLK_SOURCE_REG_1 &= ~(0x03 << 9);
        0x0080f22a:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080f22e:    f42060c0     ..`    BIC      r0,r0,#0x600
        0x0080f232:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;259            CLK_SOURCE_REG_1 |= (ClockDiv << 9);
        0x0080f236:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080f23a:    ea402041    @.A     ORR      r0,r0,r1,LSL #9
        0x0080f23e:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;260    
;;;261            //platform_delay_us(1);
;;;262            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_UART0DATA_EN_Msk;
        0x0080f242:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x0080f246:    f0400001    @...    ORR      r0,r0,#1
        0x0080f24a:    f8c20234    ..4.    STR      r0,[r2,#0x234]
        0x0080f24e:    4770        pG      BX       lr
;;;263        }
;;;264        else if (UARTx == UART1)
        0x0080f250:    4b45        EK      LDR      r3,[pc,#276] ; [0x80f368] = 0x40011000
        0x0080f252:    4298        .B      CMP      r0,r3
        0x0080f254:    d1fb        ..      BNE      0x80f24e ; RCC_UARTClkDivConfig + 56
;;;265        {
;;;266            SYSBLKCTRL->u_230.CLK_CTRL &= ~SYSBLK_ACTCK_LOGUART_EN_Msk;
        0x0080f256:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x0080f25a:    f4205080     ..P    BIC      r0,r0,#0x1000
        0x0080f25e:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;267            //platform_delay_us(1);
;;;268    
;;;269            CLK_SOURCE_REG_1 &= ~(0x03 << 11);
        0x0080f262:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080f266:    f42050c0     ..P    BIC      r0,r0,#0x1800
        0x0080f26a:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;270            CLK_SOURCE_REG_1 |= (ClockDiv << 11);
        0x0080f26e:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080f272:    ea4020c1    @..     ORR      r0,r0,r1,LSL #11
        0x0080f276:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;271    
;;;272            //platform_delay_us(1);
;;;273            SYSBLKCTRL->u_230.CLK_CTRL |= SYSBLK_ACTCK_LOGUART_EN_Msk;
        0x0080f27a:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x0080f27e:    f4405080    @..P    ORR      r0,r0,#0x1000
        0x0080f282:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;274        }
;;;275    
;;;276        return;
;;;277    }
        0x0080f286:    4770        pG      BX       lr
    RCC_PeriClockConfig
;;;278    
;;;279    /**
;;;280      * @brief  Enables or disables the APB peripheral clock.
;;;281      * @param  APBPeriph_Clock: specifies the APB peripheral clock config.
;;;282      *      this parameter can be one of the following values(must be the same with APBPeriph):
;;;283      *     @arg APBPeriph_TIMER_CLOCK
;;;284      *     @arg APBPeriph_GDMA_CLOCK
;;;285      *     @arg APBPeriph_SPI2W_CLOCK
;;;286      *     @arg APBPeriph_KEYSCAN_CLOCK
;;;287      *     @arg APBPeriph_QDEC_CLOCK
;;;288      *     @arg APBPeriph_I2C1_CLOCK
;;;289      *     @arg APBPeriph_I2C0_CLOCK
;;;290      *     @arg APBPeriph_IR_CLOCK
;;;291      *     @arg APBPeriph_SPI1_CLOCK
;;;292      *     @arg APBPeriph_SPI0_CLOCK
;;;293      *     @arg APBPeriph_UART0_CLOCK
;;;294      *     @arg APBPeriph_UART1_CLOCK
;;;295      *     @arg APBPeriph_UART2_CLOCK
;;;296      *     @arg APBPeriph_GPIO_CLOCK
;;;297      *     @arg APBPeriph_ADC_CLOCK
;;;298      *     @arg APBPeriph_I2S0_CLOCK
;;;299      *     @arg APBPeriph_I2S1_CLOCK
;;;300      *     @arg APBPeriph_CODEC_CLOCK
;;;301      * @param  NewState: new state of the specified peripheral clock.
;;;302      *   This parameter can be: ENABLE or DISABLE.
;;;303      * @retval None
;;;304      */
;;;305    void RCC_PeriClockConfig(uint32_t APBPeriph_Clock, FunctionalState NewState)
;;;306    {
        0x0080f288:    b530        0.      PUSH     {r4,r5,lr}
        0x0080f28a:    f44f74a0    O..t    MOV      r4,#0x140
        0x0080f28e:    0623        #.      LSLS     r3,r4,#24
        0x0080f290:    f3c07241    ..Ar    UBFX     r2,r0,#29,#2
        0x0080f294:    f44f7590    O..u    MOV      r5,#0x120
        0x0080f298:    2901        .)      CMP      r1,#1
;;; .\..\source\peripheral\rtl876x_rcc.c (306)
        0x0080f29a:    d006        ..      BEQ      0x80f2aa ; RCC_PeriClockConfig + 34
        0x0080f29c:    42a8        .B      CMP      r0,r5
        0x0080f29e:    d01e        ..      BEQ      0x80f2de ; RCC_PeriClockConfig + 86
        0x0080f2a0:    42a0        .B      CMP      r0,r4
        0x0080f2a2:    d01c        ..      BEQ      0x80f2de ; RCC_PeriClockConfig + 86
        0x0080f2a4:    2810        .(      CMP      r0,#0x10
        0x0080f2a6:    d01a        ..      BEQ      0x80f2de ; RCC_PeriClockConfig + 86
        0x0080f2a8:    e005        ..      B        0x80f2b6 ; RCC_PeriClockConfig + 46
;;;307        /* Check the parameters */
;;;308        assert_param(IS_APB_PERIPH_CLOCK(APBPeriph_Clock));
;;;309        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;310    
;;;311        uint32_t clkRegOff = ((APBPeriph_Clock & (0x03 << 29)) >> 29);
;;;312    
;;;313        /* Special register handle */
;;;314        if (NewState == ENABLE)
;;;315        {
;;;316            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
        0x0080f2aa:    42a8        .B      CMP      r0,r5
        0x0080f2ac:    d013        ..      BEQ      0x80f2d6 ; RCC_PeriClockConfig + 78
        0x0080f2ae:    42a0        .B      CMP      r0,r4
        0x0080f2b0:    d011        ..      BEQ      0x80f2d6 ; RCC_PeriClockConfig + 78
;;;317                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
        0x0080f2b2:    2810        .(      CMP      r0,#0x10
        0x0080f2b4:    d00f        ..      BEQ      0x80f2d6 ; RCC_PeriClockConfig + 78
        0x0080f2b6:    2901        .)      CMP      r1,#1
        0x0080f2b8:    ea4f0182    O...    LSL      r1,r2,#2
        0x0080f2bc:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x0080f2c0:    f02040c0     ..@    BIC      r0,r0,#0x60000000
        0x0080f2c4:    f8d1222c    ..,"    LDR      r2,[r1,#0x22c]
        0x0080f2c8:    d00f        ..      BEQ      0x80f2ea ; RCC_PeriClockConfig + 98
        0x0080f2ca:    4382        .C      BICS     r2,r2,r0
        0x0080f2cc:    ea220040    ".@.    BIC      r0,r2,r0,LSL #1
        0x0080f2d0:    f8c1022c    ..,.    STR      r0,[r1,#0x22c]
        0x0080f2d4:    bd30        0.      POP      {r4,r5,pc}
;;;318            {
;;;319                SYSBLKCTRL->u_220 |= APBPeriph_Clock;
        0x0080f2d6:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x0080f2da:    4301        .C      ORRS     r1,r1,r0
;;;320                return;
        0x0080f2dc:    e002        ..      B        0x80f2e4 ; RCC_PeriClockConfig + 92
;;;321            }
;;;322        }
;;;323        else
;;;324        {
;;;325            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
;;;326                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
;;;327            {
;;;328                SYSBLKCTRL->u_220 &= ~(APBPeriph_Clock);
        0x0080f2de:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x0080f2e2:    4381        .C      BICS     r1,r1,r0
        0x0080f2e4:    f8c31220    .. .    STR      r1,[r3,#0x220]
        0x0080f2e8:    bd30        0.      POP      {r4,r5,pc}
;;;329                return;
;;;330            }
;;;331        }
;;;332    
;;;333        APBPeriph_Clock &= (~(0x03 << 29));
;;;334    
;;;335        if (NewState == ENABLE)
;;;336        {
;;;337            //enable peripheral clock
;;;338            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= APBPeriph_Clock;
        0x0080f2ea:    4302        .C      ORRS     r2,r2,r0
;;;339            //enable peripheral clock in sleep mode
;;;340            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= (APBPeriph_Clock << 1);
        0x0080f2ec:    ea420040    B.@.    ORR      r0,r2,r0,LSL #1
        0x0080f2f0:    e7ee        ..      B        0x80f2d0 ; RCC_PeriClockConfig + 72
    RCC_PeriFunctionConfig
        0x0080f2f2:    f3c06281    ...b    UBFX     r2,r0,#26,#2
        0x0080f2f6:    f04f4380    O..C    MOV      r3,#0x40000000
        0x0080f2fa:    2901        .)      CMP      r1,#1
;;;341        }
;;;342        else
;;;343        {
;;;344            //disable peripheral clock
;;;345            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~APBPeriph_Clock);
;;;346            //disable peripheral clock in sleep mode
;;;347            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~(APBPeriph_Clock << 1));
;;;348        }
;;;349    
;;;350        return;
;;;351    }
;;;352    
;;;353    /**
;;;354      * @brief  Enables or disables the APB peripheral clock.
;;;355      * @param  APBPeriph: specifies the APB peripheral to gates its clock.
;;;356      *      this parameter can be one of the following values:
;;;357      *     @arg APBPeriph_TIMER
;;;358      *     @arg APBPeriph_GDMA
;;;359      *     @arg APBPeriph_LCD
;;;360      *     @arg APBPeriph_SPI2W
;;;361      *     @arg APBPeriph_KEYSCAN
;;;362      *     @arg APBPeriph_QDEC
;;;363      *     @arg APBPeriph_I2C1
;;;364      *     @arg APBPeriph_I2C0
;;;365      *     @arg APBPeriph_IR
;;;366      *     @arg APBPeriph_SPI1
;;;367      *     @arg APBPeriph_SPI0
;;;368      *     @arg APBPeriph_UART0
;;;369      *     @arg APBPeriph_UART1
;;;370      *     @arg APBPeriph_UART2
;;;371      *     @arg APBPeriph_GPIO
;;;372      *     @arg APBPeriph_ADC
;;;373      *     @arg APBPeriph_I2S0
;;;374      *     @arg APBPeriph_I2S1
;;;375      *     @arg APBPeriph_CODEC
;;;376      * @param  NewState: new state of the specified peripheral clock.
;;;377      *   This parameter can be: ENABLE or DISABLE.
;;;378      * @retval None
;;;379      */
;;;380    void RCC_PeriFunctionConfig(uint32_t APBPeriph, FunctionalState NewState)
;;;381    {
        0x0080f2fc:    d006        ..      BEQ      0x80f30c ; RCC_PeriFunctionConfig + 26
        0x0080f2fe:    2802        .(      CMP      r0,#2
        0x0080f300:    d01c        ..      BEQ      0x80f33c ; RCC_PeriFunctionConfig + 74
        0x0080f302:    2804        .(      CMP      r0,#4
        0x0080f304:    d01a        ..      BEQ      0x80f33c ; RCC_PeriFunctionConfig + 74
        0x0080f306:    2801        .(      CMP      r0,#1
        0x0080f308:    d018        ..      BEQ      0x80f33c ; RCC_PeriFunctionConfig + 74
        0x0080f30a:    e005        ..      B        0x80f318 ; RCC_PeriFunctionConfig + 38
;;;382        /* Check the parameters */
;;;383        assert_param(IS_APB_PERIPH(APBPeriph));
;;;384        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;385    
;;;386        uint32_t apbRegOff = ((APBPeriph & (0x03 << 26)) >> 26);
;;;387    
;;;388        /* Special register handle */
;;;389        if (NewState == ENABLE)
;;;390        {
;;;391            if ((APBPeriph == APBPeriph_I2S0) || ((APBPeriph == APBPeriph_I2S1)) ||
        0x0080f30c:    2802        .(      CMP      r0,#2
        0x0080f30e:    d011        ..      BEQ      0x80f334 ; RCC_PeriFunctionConfig + 66
        0x0080f310:    2804        .(      CMP      r0,#4
        0x0080f312:    d00f        ..      BEQ      0x80f334 ; RCC_PeriFunctionConfig + 66
;;;392                (APBPeriph == APBPeriph_CODEC))
        0x0080f314:    2801        .(      CMP      r0,#1
        0x0080f316:    d00d        ..      BEQ      0x80f334 ; RCC_PeriFunctionConfig + 66
        0x0080f318:    2901        .)      CMP      r1,#1
        0x0080f31a:    ea4f0182    O...    LSL      r1,r2,#2
        0x0080f31e:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x0080f322:    f0206040     .@`    BIC      r0,r0,#0xc000000
        0x0080f326:    f8d12210    ..."    LDR      r2,[r1,#0x210]
        0x0080f32a:    d00d        ..      BEQ      0x80f348 ; RCC_PeriFunctionConfig + 86
        0x0080f32c:    4382        .C      BICS     r2,r2,r0
        0x0080f32e:    f8c12210    ..."    STR      r2,[r1,#0x210]
        0x0080f332:    4770        pG      BX       lr
;;;393            {
;;;394                SYSBLKCTRL->u_220 |= APBPeriph;
        0x0080f334:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x0080f338:    4301        .C      ORRS     r1,r1,r0
;;;395                return;
        0x0080f33a:    e002        ..      B        0x80f342 ; RCC_PeriFunctionConfig + 80
;;;396            }
;;;397        }
;;;398        else
;;;399        {
;;;400            if ((APBPeriph == APBPeriph_I2S0) || ((APBPeriph == APBPeriph_I2S1)) ||
;;;401                (APBPeriph == APBPeriph_CODEC))
;;;402            {
;;;403                SYSBLKCTRL->u_220 &= ~(APBPeriph);
        0x0080f33c:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x0080f340:    4381        .C      BICS     r1,r1,r0
        0x0080f342:    f8c31220    .. .    STR      r1,[r3,#0x220]
        0x0080f346:    4770        pG      BX       lr
;;;404                return;
;;;405            }
;;;406        }
;;;407    
;;;408        /* clear flag */
;;;409        APBPeriph &= (~(0x03 << 26));
;;;410    
;;;411        if (NewState == ENABLE)
;;;412        {
;;;413            //enable peripheral
;;;414            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) |= APBPeriph;
        0x0080f348:    4302        .C      ORRS     r2,r2,r0
        0x0080f34a:    e7f0        ..      B        0x80f32e ; RCC_PeriFunctionConfig + 60
    $d
        0x0080f34c:    60010000    ...`    DCD    1610678272
        0x0080f350:    20004000    .@.     DCD    536887296
        0x0080f354:    40013000    .0.@    DCD    1073819648
        0x0080f358:    40013400    .4.@    DCD    1073820672
        0x0080f35c:    40015000    .P.@    DCD    1073827840
        0x0080f360:    40015400    .T.@    DCD    1073828864
        0x0080f364:    40012000    . .@    DCD    1073815552
        0x0080f368:    40011000    ...@    DCD    1073811456
    $t
    .text
    ias_attr_write_cb
;;; .\..\source\profile\ias.c
;;;96     {
        0x0080f36c:    b57c        |.      PUSH     {r2-r6,lr}
        0x0080f36e:    460d        .F      MOV      r5,r1
        0x0080f370:    4601        .F      MOV      r1,r0
        0x0080f372:    e9dd0306    ....    LDRD     r0,r3,[sp,#0x18]
        0x0080f376:    2400        .$      MOVS     r4,#0
;;; .\..\source\profile\ias.c (96)
        0x0080f378:    b123        #.      CBZ      r3,0x80f384 ; ias_attr_write_cb + 24
        0x0080f37a:    2a02        .*      CMP      r2,#2
        0x0080f37c:    d00b        ..      BEQ      0x80f396 ; ias_attr_write_cb + 42
        0x0080f37e:    f240440a    @..D    MOV      r4,#0x40a
        0x0080f382:    e015        ..      B        0x80f3b0 ; ias_attr_write_cb + 68
;;;97         T_APP_RESULT cause  = APP_RESULT_SUCCESS;
;;;98         T_IAS_CALLBACK_DATA callback_data;
;;;99         if (!p_value)
;;;100        {
;;;101            PROFILE_PRINT_ERROR2("ias_attr_write_cb: p_value %p length= 0x%x", p_value, length);
        0x0080f384:    9000        ..      STR      r0,[sp,#0]
        0x0080f386:    2202        ."      MOVS     r2,#2
        0x0080f388:    491d        .I      LDR      r1,[pc,#116] ; [0x80f400] = 0x880025c
        0x0080f38a:    481e        .H      LDR      r0,[pc,#120] ; [0x80f404] = 0x21103300
        0x0080f38c:    f7f8db67    ..g.    BL       log_buffer ; 0x7a5e
;;;102            cause = APP_RESULT_INVALID_PDU;
        0x0080f390:    f2404004    @..@    MOV      r0,#0x404
        0x0080f394:    bd7c        |.      POP      {r2-r6,pc}
;;;103            return cause;
;;;104        }
;;;105    
;;;106        switch (attrib_index)
;;;107        {
;;;108        default:
;;;109            cause = APP_RESULT_ATTR_NOT_FOUND;
;;;110            break;
;;;111    
;;;112        case GATT_SVC_PXP_IMMEDIATE_AlERT_VALUE_INDEX:
;;;113            if (length != sizeof(uint8_t))
        0x0080f396:    2801        .(      CMP      r0,#1
        0x0080f398:    d002        ..      BEQ      0x80f3a0 ; ias_attr_write_cb + 52
;;;114            {
;;;115                cause = APP_RESULT_INVALID_VALUE_SIZE;
        0x0080f39a:    f240440d    @..D    MOV      r4,#0x40d
        0x0080f39e:    e007        ..      B        0x80f3b0 ; ias_attr_write_cb + 68
;;;116            }
;;;117            else
;;;118            {
;;;119                callback_data.conn_id = conn_id;
        0x0080f3a0:    f88d1004    ....    STRB     r1,[sp,#4]
;;;120                callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
        0x0080f3a4:    2003        .       MOVS     r0,#3
        0x0080f3a6:    f88d0005    ....    STRB     r0,[sp,#5]
;;;121                callback_data.msg_data.write_alert_level = p_value[0];
        0x0080f3aa:    7818        .x      LDRB     r0,[r3,#0]
        0x0080f3ac:    f88d0006    ....    STRB     r0,[sp,#6]
;;;122            }
;;;123            break;
;;;124        }
;;;125        if (pfn_ias_cb && (cause == APP_RESULT_SUCCESS))
        0x0080f3b0:    4815        .H      LDR      r0,[pc,#84] ; [0x80f408] = 0x20812c
        0x0080f3b2:    6802        .h      LDR      r2,[r0,#0]
        0x0080f3b4:    b11a        ..      CBZ      r2,0x80f3be ; ias_attr_write_cb + 82
        0x0080f3b6:    b914        ..      CBNZ     r4,0x80f3be ; ias_attr_write_cb + 82
;;;126        {
;;;127            pfn_ias_cb(service_id, (void *)&callback_data);
        0x0080f3b8:    a901        ..      ADD      r1,sp,#4
        0x0080f3ba:    4628        (F      MOV      r0,r5
        0x0080f3bc:    4790        .G      BLX      r2
;;;128        }
;;;129    
;;;130        return cause;
        0x0080f3be:    4620         F      MOV      r0,r4
;;;131    }
        0x0080f3c0:    bd7c        |.      POP      {r2-r6,pc}
    ias_add_service
;;;132    
;;;133    /*********************************************************************
;;;134     * SERVICE CALLBACKS
;;;135     */
;;;136    // IAS related Service Callbacks
;;;137    const T_FUN_GATT_SERVICE_CBS ias_cbs =
;;;138    {
;;;139        NULL,  // Read callback function pointer
;;;140        ias_attr_write_cb, // Write callback function pointer
;;;141        NULL  // CCCD update callback function pointer
;;;142    };
;;;143    
;;;144    /**
;;;145      * @brief Add immediate alert service to the BLE stack database.
;;;146      *
;;;147      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;148      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;149      * @retval 0xFF Operation failure.
;;;150      * @retval others Service id assigned by stack.
;;;151      *
;;;152      * <b>Example usage</b>
;;;153      * \code{.c}
;;;154        void profile_init()
;;;155        {
;;;156            server_init(1);
;;;157            ias_id = ias_add_service(app_handle_profile_message);
;;;158        }
;;;159      * \endcode
;;;160      */
;;;161    T_SERVER_ID ias_add_service(void *p_func)
;;;162    {
        0x0080f3c2:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080f3c4:    4604        .F      MOV      r4,r0
;;;163        T_SERVER_ID service_id;
;;;164        if (false == server_add_service(&service_id,
        0x0080f3c6:    4811        .H      LDR      r0,[pc,#68] ; [0x80f40c] = 0x810c98
        0x0080f3c8:    e9d01216    ....    LDRD     r1,r2,[r0,#0x58]
        0x0080f3cc:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0080f3d0:    4601        .F      MOV      r1,r0
        0x0080f3d2:    6d43        Cm      LDR      r3,[r0,#0x54]
        0x0080f3d4:    2254        T"      MOVS     r2,#0x54
        0x0080f3d6:    a802        ..      ADD      r0,sp,#8
        0x0080f3d8:    f440f149    @.I.    BL       server_add_service ; 0x4f66e
        0x0080f3dc:    b950        P.      CBNZ     r0,0x80f3f4 ; ias_add_service + 50
;;;165                                        (uint8_t *)ias_attr_tbl,
;;;166                                        ias_attr_tbl_size,
;;;167                                        ias_cbs))
;;;168        {
;;;169            PROFILE_PRINT_ERROR1("ias_add_service: service_id %d", service_id);
        0x0080f3de:    4908        .I      LDR      r1,[pc,#32] ; [0x80f400] = 0x880025c
        0x0080f3e0:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080f3e4:    2201        ."      MOVS     r2,#1
        0x0080f3e6:    3130        01      ADDS     r1,r1,#0x30
        0x0080f3e8:    4806        .H      LDR      r0,[pc,#24] ; [0x80f404] = 0x21103300
        0x0080f3ea:    f7f8db38    ..8.    BL       log_buffer ; 0x7a5e
;;;170            service_id = 0xff;
        0x0080f3ee:    20ff        .       MOVS     r0,#0xff
        0x0080f3f0:    f88d0008    ....    STRB     r0,[sp,#8]
;;;171        }
;;;172    
;;;173        pfn_ias_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x0080f3f4:    4804        .H      LDR      r0,[pc,#16] ; [0x80f408] = 0x20812c
;;;174        return service_id;
        0x0080f3f6:    6004        .`      STR      r4,[r0,#0]
        0x0080f3f8:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;175    }
        0x0080f3fc:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080f3fe:    0000        ..      DCW    0
        0x0080f400:    0880025c    \...    DCD    142606940
        0x0080f404:    21103300    .3.!    DCD    554709760
        0x0080f408:    0020812c    ,. .    DCD    2130220
        0x0080f40c:    00810c98    ....    DCD    8457368
    $t
    .text
    lls_set_parameter
;;; .\..\source\profile\lls.c
;;;102    {
        0x0080f410:    b510        ..      PUSH     {r4,lr}
        0x0080f412:    2401        .$      MOVS     r4,#1
;;; .\..\source\profile\lls.c (102)
        0x0080f414:    b130        0.      CBZ      r0,0x80f424 ; lls_set_parameter + 20
;;;103        bool ret = true;
;;;104    
;;;105        switch (param_type)
;;;106        {
;;;107        default:
;;;108            ret = false;
        0x0080f416:    2400        .$      MOVS     r4,#0
        0x0080f418:    4622        "F      MOV      r2,r4
        0x0080f41a:    4942        BI      LDR      r1,[pc,#264] ; [0x80f524] = 0x88002b0
        0x0080f41c:    4842        BH      LDR      r0,[pc,#264] ; [0x80f528] = 0x21103300
        0x0080f41e:    f7f8db1e    ....    BL       log_buffer ; 0x7a5e
;;;109            break;
        0x0080f422:    e002        ..      B        0x80f42a ; lls_set_parameter + 26
;;;110        case LLS_PARAM_LINK_LOSS_ALERT_LEVEL:
;;;111            lls_alert_level = *(uint8_t *)p_value;
        0x0080f424:    4941        AI      LDR      r1,[pc,#260] ; [0x80f52c] = 0x208130
        0x0080f426:    7810        .x      LDRB     r0,[r2,#0]
        0x0080f428:    7008        .p      STRB     r0,[r1,#0]
;;;112            break;
;;;113        }
;;;114    
;;;115        if (!ret)
;;;116        {
;;;117            PROFILE_PRINT_ERROR0("lls_set_parameter: lls alert level parameter set failed");
;;;118        }
;;;119    
;;;120        return ret;
        0x0080f42a:    4620         F      MOV      r0,r4
;;;121    }
        0x0080f42c:    bd10        ..      POP      {r4,pc}
    lls_attr_read_cb
;;;122    
;;;123    
;;;124    /**
;;;125     * @brief read characteristic data from service.
;;;126     *
;;;127     * @param conn_id           connection id.
;;;128     * @param service_id        ServiceID to be read.
;;;129     * @param attrib_index      Attribute index of getting characteristic data.
;;;130     * @param offset            offset of characteritic to be read.
;;;131     * @param p_length          length of getting characteristic data.
;;;132     * @param pp_value          pointer to pointer of characteristic value to be read.
;;;133     * @return T_APP_RESULT
;;;134    */
;;;135    T_APP_RESULT lls_attr_read_cb(uint8_t conn_id, uint8_t service_id, uint16_t attrib_index,
;;;136                                  uint16_t offset, uint16_t *p_length, uint8_t **pp_value)
;;;137    {
        0x0080f42e:    e92d47fc    -..G    PUSH     {r2-r10,lr}
        0x0080f432:    2500        .%      MOVS     r5,#0
        0x0080f434:    e9dd690a    ...i    LDRD     r6,r9,[sp,#0x28]
        0x0080f438:    460b        .F      MOV      r3,r1
        0x0080f43a:    8035        5.      STRH     r5,[r6,#0]
        0x0080f43c:    2a02        .*      CMP      r2,#2
        0x0080f43e:    d009        ..      BEQ      0x80f454 ; lls_attr_read_cb + 38
;;;138        T_APP_RESULT cause = APP_RESULT_SUCCESS;
;;;139        *p_length = 0;
;;;140        T_LLS_CALLBACK_DATA callback_data;
;;;141    
;;;142        switch (attrib_index)
;;;143        {
;;;144        default:
;;;145            PROFILE_PRINT_ERROR1("lls_attr_read_cb default:attrib_index %d", attrib_index);
        0x0080f440:    4938        8I      LDR      r1,[pc,#224] ; [0x80f524] = 0x88002b0
        0x0080f442:    4613        .F      MOV      r3,r2
        0x0080f444:    2201        ."      MOVS     r2,#1
        0x0080f446:    313c        <1      ADDS     r1,r1,#0x3c
        0x0080f448:    4837        7H      LDR      r0,[pc,#220] ; [0x80f528] = 0x21103300
        0x0080f44a:    f7f8db08    ....    BL       log_buffer ; 0x7a5e
;;;146            cause = APP_RESULT_ATTR_NOT_FOUND;
        0x0080f44e:    f240450a    @..E    MOV      r5,#0x40a
;;;147            break;
        0x0080f452:    e01a        ..      B        0x80f48a ; lls_attr_read_cb + 92
        0x0080f454:    2702        .'      MOVS     r7,#2
;;;148    
;;;149        case GATT_SVC_PXP_LINK_LOSS_ALERT_LEVEL_INDEX:
;;;150            callback_data.conn_id = conn_id;
        0x0080f456:    f88d0004    ....    STRB     r0,[sp,#4]
        0x0080f45a:    f8df80d0    ....    LDR      r8,[pc,#208] ; [0x80f52c] = 0x208130
;;;151            callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0080f45e:    f88d7005    ...p    STRB     r7,[sp,#5]
;;;152            callback_data.msg_data.read_value_index = LLS_READ_ALERT_LEVEL;
        0x0080f462:    2401        .$      MOVS     r4,#1
        0x0080f464:    f88d4006    ...@    STRB     r4,[sp,#6]
;;;153            pfn_lls_cb(service_id, (void *)&callback_data);
        0x0080f468:    f8d82004    ...     LDR      r2,[r8,#4]
        0x0080f46c:    a901        ..      ADD      r1,sp,#4
        0x0080f46e:    4618        .F      MOV      r0,r3
        0x0080f470:    4790        .G      BLX      r2
;;;154            *pp_value = (uint8_t *)&lls_alert_level;
;;;155            *p_length = sizeof(lls_alert_level);
        0x0080f472:    f8c98000    ....    STR      r8,[r9,#0]
        0x0080f476:    492b        +I      LDR      r1,[pc,#172] ; [0x80f524] = 0x88002b0
        0x0080f478:    482b        +H      LDR      r0,[pc,#172] ; [0x80f528] = 0x21103300
        0x0080f47a:    8034        4.      STRH     r4,[r6,#0]
;;;156            PROFILE_PRINT_INFO2("lls_attr_read_cb: attrib_index %d, length %d", attrib_index, *p_length);
        0x0080f47c:    463b        ;F      MOV      r3,r7
        0x0080f47e:    2202        ."      MOVS     r2,#2
        0x0080f480:    3168        h1      ADDS     r1,r1,#0x68
        0x0080f482:    1c80        ..      ADDS     r0,r0,#2
        0x0080f484:    9400        ..      STR      r4,[sp,#0]
        0x0080f486:    f7f8daea    ....    BL       log_buffer ; 0x7a5e
;;;157            break;
;;;158        }
;;;159    
;;;160        return (cause);
        0x0080f48a:    4628        (F      MOV      r0,r5
;;;161    }
        0x0080f48c:    e8bd87fc    ....    POP      {r2-r10,pc}
    lls_attr_write_cb
;;;162    
;;;163    /**
;;;164     * @brief write characteristic data from service.
;;;165     *
;;;166     * @param conn_id               connection id.
;;;167     * @param service_id            ServiceID to be written.
;;;168     * @param attrib_index          Attribute index of characteristic.
;;;169     * @param length                length of writing characteristic data.
;;;170     * @param p_value               pointer to characteristic data.
;;;171     * @param p_write_ind_post_proc function pointer called after lls_attr_write_cb.
;;;172     * @return T_APP_RESULT
;;;173    */
;;;174    T_APP_RESULT lls_attr_write_cb(uint8_t conn_id, uint8_t service_id, uint16_t attrib_index,
;;;175                                   T_WRITE_TYPE write_type,
;;;176                                   uint16_t length, uint8_t *p_value, P_FUN_WRITE_IND_POST_PROC *p_write_ind_post_proc)
;;;177    {
        0x0080f490:    b57c        |.      PUSH     {r2-r6,lr}
        0x0080f492:    460d        .F      MOV      r5,r1
        0x0080f494:    4601        .F      MOV      r1,r0
        0x0080f496:    e9dd0306    ....    LDRD     r0,r3,[sp,#0x18]
        0x0080f49a:    2400        .$      MOVS     r4,#0
;;; .\..\source\profile\lls.c (177)
        0x0080f49c:    b123        #.      CBZ      r3,0x80f4a8 ; lls_attr_write_cb + 24
        0x0080f49e:    2a02        .*      CMP      r2,#2
        0x0080f4a0:    d00c        ..      BEQ      0x80f4bc ; lls_attr_write_cb + 44
        0x0080f4a2:    f240440a    @..D    MOV      r4,#0x40a
        0x0080f4a6:    e016        ..      B        0x80f4d6 ; lls_attr_write_cb + 70
;;;178        T_APP_RESULT  cause = APP_RESULT_SUCCESS;
;;;179        T_LLS_CALLBACK_DATA callback_data;
;;;180        if (!p_value)
;;;181        {
;;;182            PROFILE_PRINT_ERROR2("lls_attr_write_cb: p_value %p, length 0x%x", p_value, length);
        0x0080f4a8:    491e        .I      LDR      r1,[pc,#120] ; [0x80f524] = 0x88002b0
        0x0080f4aa:    9000        ..      STR      r0,[sp,#0]
        0x0080f4ac:    2202        ."      MOVS     r2,#2
        0x0080f4ae:    3198        .1      ADDS     r1,r1,#0x98
        0x0080f4b0:    481d        .H      LDR      r0,[pc,#116] ; [0x80f528] = 0x21103300
        0x0080f4b2:    f7f8dad4    ....    BL       log_buffer ; 0x7a5e
;;;183            cause = APP_RESULT_INVALID_PDU;
        0x0080f4b6:    f2404004    @..@    MOV      r0,#0x404
        0x0080f4ba:    bd7c        |.      POP      {r2-r6,pc}
;;;184            return cause;
;;;185        }
;;;186    
;;;187        switch (attrib_index)
;;;188        {
;;;189        default:
;;;190            cause = APP_RESULT_ATTR_NOT_FOUND;
;;;191            break;
;;;192        case GATT_SVC_PXP_LINK_LOSS_ALERT_LEVEL_INDEX:
;;;193            if (length != sizeof(uint8_t))
        0x0080f4bc:    2801        .(      CMP      r0,#1
        0x0080f4be:    d002        ..      BEQ      0x80f4c6 ; lls_attr_write_cb + 54
;;;194            {
;;;195                cause = APP_RESULT_INVALID_VALUE_SIZE;
        0x0080f4c0:    f240440d    @..D    MOV      r4,#0x40d
        0x0080f4c4:    e007        ..      B        0x80f4d6 ; lls_attr_write_cb + 70
;;;196            }
;;;197            else
;;;198            {
;;;199                callback_data.conn_id = conn_id;
        0x0080f4c6:    f88d1004    ....    STRB     r1,[sp,#4]
;;;200                callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
        0x0080f4ca:    2003        .       MOVS     r0,#3
        0x0080f4cc:    f88d0005    ....    STRB     r0,[sp,#5]
;;;201                callback_data.msg_data.write_alert_level = p_value[0];
        0x0080f4d0:    7818        .x      LDRB     r0,[r3,#0]
        0x0080f4d2:    f88d0006    ....    STRB     r0,[sp,#6]
;;;202            }
;;;203            break;
;;;204    
;;;205        }
;;;206        if (pfn_lls_cb && (cause == APP_RESULT_SUCCESS))
        0x0080f4d6:    4815        .H      LDR      r0,[pc,#84] ; [0x80f52c] = 0x208130
        0x0080f4d8:    6842        Bh      LDR      r2,[r0,#4]
        0x0080f4da:    b11a        ..      CBZ      r2,0x80f4e4 ; lls_attr_write_cb + 84
        0x0080f4dc:    b914        ..      CBNZ     r4,0x80f4e4 ; lls_attr_write_cb + 84
;;;207        {
;;;208            pfn_lls_cb(service_id, (void *)&callback_data);
        0x0080f4de:    a901        ..      ADD      r1,sp,#4
        0x0080f4e0:    4628        (F      MOV      r0,r5
        0x0080f4e2:    4790        .G      BLX      r2
;;;209        }
;;;210    
;;;211        return cause;
        0x0080f4e4:    4620         F      MOV      r0,r4
;;;212    
;;;213    }
        0x0080f4e6:    bd7c        |.      POP      {r2-r6,pc}
    lls_add_service
;;;214    
;;;215    
;;;216    // LLS related Service Callbacks
;;;217    const T_FUN_GATT_SERVICE_CBS lls_cbs =
;;;218    {
;;;219        lls_attr_read_cb,   // Read callback function pointer
;;;220        lls_attr_write_cb,  // Write callback function pointer
;;;221        NULL                // CCCD update callback function pointer
;;;222    };
;;;223    
;;;224    /**
;;;225      * @brief Add link loss service to the BLE stack database.
;;;226      *
;;;227      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;228      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;229      * @retval 0xFF Operation failure.
;;;230      * @retval others Service id assigned by stack.
;;;231      *
;;;232      * <b>Example usage</b>
;;;233      * \code{.c}
;;;234        void profile_init()
;;;235        {
;;;236            server_init(1);
;;;237            lls_id = lls_add_service(app_handle_profile_message);
;;;238        }
;;;239      * \endcode
;;;240      */
;;;241    T_SERVER_ID lls_add_service(void *p_func)
;;;242    {
        0x0080f4e8:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080f4ea:    4604        .F      MOV      r4,r0
;;;243        T_SERVER_ID service_id;
;;;244        if (false == server_add_service(&service_id,
        0x0080f4ec:    4810        .H      LDR      r0,[pc,#64] ; [0x80f530] = 0x810cf8
        0x0080f4ee:    e9d01216    ....    LDRD     r1,r2,[r0,#0x58]
        0x0080f4f2:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0080f4f6:    4601        .F      MOV      r1,r0
        0x0080f4f8:    6d43        Cm      LDR      r3,[r0,#0x54]
        0x0080f4fa:    2254        T"      MOVS     r2,#0x54
        0x0080f4fc:    a802        ..      ADD      r0,sp,#8
        0x0080f4fe:    f440f0b6    @...    BL       server_add_service ; 0x4f66e
        0x0080f502:    b950        P.      CBNZ     r0,0x80f51a ; lls_add_service + 50
;;;245                                        (uint8_t *)lls_attr_tbl,
;;;246                                        lls_attr_tbl_size,
;;;247                                        lls_cbs))
;;;248        {
;;;249            PROFILE_PRINT_ERROR1("lls_add_service: service_id %d", service_id);
        0x0080f504:    4907        .I      LDR      r1,[pc,#28] ; [0x80f524] = 0x88002b0
        0x0080f506:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080f50a:    2201        ."      MOVS     r2,#1
        0x0080f50c:    31c8        .1      ADDS     r1,r1,#0xc8
        0x0080f50e:    4806        .H      LDR      r0,[pc,#24] ; [0x80f528] = 0x21103300
        0x0080f510:    f7f8daa5    ....    BL       log_buffer ; 0x7a5e
;;;250            service_id = 0xff;
        0x0080f514:    20ff        .       MOVS     r0,#0xff
        0x0080f516:    f88d0008    ....    STRB     r0,[sp,#8]
;;;251        }
;;;252    
;;;253        pfn_lls_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x0080f51a:    4804        .H      LDR      r0,[pc,#16] ; [0x80f52c] = 0x208130
;;;254        return service_id;
        0x0080f51c:    6044        D`      STR      r4,[r0,#4]
        0x0080f51e:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;255    }
        0x0080f522:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080f524:    088002b0    ....    DCD    142607024
        0x0080f528:    21103300    .3.!    DCD    554709760
        0x0080f52c:    00208130    0. .    DCD    2130224
        0x0080f530:    00810cf8    ....    DCD    8457464
    $t
    .text
    tps_set_parameter
;;; .\..\source\profile\tps.c
;;;105    {
        0x0080f534:    b510        ..      PUSH     {r4,lr}
        0x0080f536:    2401        .$      MOVS     r4,#1
;;; .\..\source\profile\tps.c (105)
        0x0080f538:    b130        0.      CBZ      r0,0x80f548 ; tps_set_parameter + 20
;;;106        bool ret = true;
;;;107    
;;;108        switch (param_type)
;;;109        {
;;;110        default:
;;;111            /* invalid param to set. */
;;;112            ret = false;
        0x0080f53a:    2400        .$      MOVS     r4,#0
        0x0080f53c:    4622        "F      MOV      r2,r4
        0x0080f53e:    492c        ,I      LDR      r1,[pc,#176] ; [0x80f5f0] = 0x880039c
        0x0080f540:    482c        ,H      LDR      r0,[pc,#176] ; [0x80f5f4] = 0x21103300
        0x0080f542:    f7f8da8c    ....    BL       log_buffer ; 0x7a5e
;;;113            break;
        0x0080f546:    e002        ..      B        0x80f54e ; tps_set_parameter + 26
;;;114    
;;;115        case TPS_PARAM_TX_POWER:
;;;116            tx_power_value = *(uint8_t *)p_value;
        0x0080f548:    492b        +I      LDR      r1,[pc,#172] ; [0x80f5f8] = 0x208138
        0x0080f54a:    7810        .x      LDRB     r0,[r2,#0]
        0x0080f54c:    7008        .p      STRB     r0,[r1,#0]
;;;117            break;
;;;118        }
;;;119    
;;;120        if (!ret)
;;;121        {
;;;122            PROFILE_PRINT_ERROR0("tps_set_parameter: TPS parameter set failed");
;;;123        }
;;;124    
;;;125        return ret;
        0x0080f54e:    4620         F      MOV      r0,r4
;;;126    }
        0x0080f550:    bd10        ..      POP      {r4,pc}
    tps_attr_read_cb
;;;127    
;;;128    
;;;129    /**
;;;130     * @brief read characteristic data from service.
;;;131     *
;;;132     * @param[in] conn_id   Connection id.
;;;133     * @param[in] service_id          ServiceID to be read.
;;;134     * @param[in] attrib_index          Attribute index of getting characteristic data.
;;;135     * @param[in] offset                offset of characteritic to be read.
;;;136     * @param[in,out] length_ptr            length of getting characteristic data.
;;;137     * @param[in,out] pp_value            pointer to pointer of characteristic value to be read.
;;;138     * @return TProfileResult
;;;139    */
;;;140    T_APP_RESULT tps_attr_read_cb(uint8_t conn_id, uint8_t service_id, uint16_t attrib_index,
;;;141                                  uint16_t offset, uint16_t *length_ptr, uint8_t **pp_value)
;;;142    {
        0x0080f552:    e92d47fc    -..G    PUSH     {r2-r10,lr}
        0x0080f556:    2500        .%      MOVS     r5,#0
        0x0080f558:    e9dd490a    ...I    LDRD     r4,r9,[sp,#0x28]
        0x0080f55c:    4690        .F      MOV      r8,r2
        0x0080f55e:    460b        .F      MOV      r3,r1
        0x0080f560:    8025        %.      STRH     r5,[r4,#0]
        0x0080f562:    2a02        .*      CMP      r2,#2
        0x0080f564:    d009        ..      BEQ      0x80f57a ; tps_attr_read_cb + 40
;;;143        T_APP_RESULT  cause  = APP_RESULT_SUCCESS;
;;;144        *length_ptr = 0;
;;;145        T_TPS_CALLBACK_DATA callback_data;
;;;146        switch (attrib_index)
;;;147        {
;;;148        default:
;;;149            PROFILE_PRINT_ERROR1("tps_attr_read_cb: attrib_index %d", attrib_index);
        0x0080f566:    4922        "I      LDR      r1,[pc,#136] ; [0x80f5f0] = 0x880039c
        0x0080f568:    4613        .F      MOV      r3,r2
        0x0080f56a:    2201        ."      MOVS     r2,#1
        0x0080f56c:    3130        01      ADDS     r1,r1,#0x30
        0x0080f56e:    4821        !H      LDR      r0,[pc,#132] ; [0x80f5f4] = 0x21103300
        0x0080f570:    f7f8da75    ..u.    BL       log_buffer ; 0x7a5e
;;;150            cause = APP_RESULT_ATTR_NOT_FOUND;
        0x0080f574:    f240450a    @..E    MOV      r5,#0x40a
;;;151            break;
        0x0080f578:    e00f        ..      B        0x80f59a ; tps_attr_read_cb + 72
;;;152    
;;;153        case TPS_TX_POWER_VALUE_INDEX:
;;;154            callback_data.conn_id = conn_id;
        0x0080f57a:    f88d0004    ....    STRB     r0,[sp,#4]
;;;155            callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0080f57e:    2002        .       MOVS     r0,#2
        0x0080f580:    4e1d        .N      LDR      r6,[pc,#116] ; [0x80f5f8] = 0x208138
        0x0080f582:    f88d0005    ....    STRB     r0,[sp,#5]
;;;156            callback_data.msg_data.read_value_index = TPS_READ_TX_POWER_VALUE;
        0x0080f586:    2701        .'      MOVS     r7,#1
        0x0080f588:    f88d7006    ...p    STRB     r7,[sp,#6]
;;;157            pfn_tps_cb(service_id, (void *)&callback_data);
        0x0080f58c:    6872        rh      LDR      r2,[r6,#4]
        0x0080f58e:    a901        ..      ADD      r1,sp,#4
        0x0080f590:    4618        .F      MOV      r0,r3
        0x0080f592:    4790        .G      BLX      r2
;;;158    
;;;159            *pp_value   = (uint8_t *)&tx_power_value;
;;;160            *length_ptr = sizeof(tx_power_value);
        0x0080f594:    f8c96000    ...`    STR      r6,[r9,#0]
        0x0080f598:    8027        '.      STRH     r7,[r4,#0]
;;;161            break;
;;;162        }
;;;163    
;;;164        PROFILE_PRINT_INFO2("tps_attr_read_cb: attrib_index %d, *length_ptr %d", attrib_index, *length_ptr);
        0x0080f59a:    8820         .      LDRH     r0,[r4,#0]
        0x0080f59c:    9000        ..      STR      r0,[sp,#0]
        0x0080f59e:    4914        .I      LDR      r1,[pc,#80] ; [0x80f5f0] = 0x880039c
        0x0080f5a0:    4814        .H      LDR      r0,[pc,#80] ; [0x80f5f4] = 0x21103300
        0x0080f5a2:    4643        CF      MOV      r3,r8
        0x0080f5a4:    2202        ."      MOVS     r2,#2
        0x0080f5a6:    3158        X1      ADDS     r1,r1,#0x58
        0x0080f5a8:    1c80        ..      ADDS     r0,r0,#2
        0x0080f5aa:    f7f8da58    ..X.    BL       log_buffer ; 0x7a5e
;;;165    
;;;166        return (cause);
        0x0080f5ae:    4628        (F      MOV      r0,r5
;;;167    }
        0x0080f5b0:    e8bd87fc    ....    POP      {r2-r10,pc}
    tps_add_service
;;;168    
;;;169    
;;;170    // TPS related Service Callbacks
;;;171    const T_FUN_GATT_SERVICE_CBS tps_cbs =
;;;172    {
;;;173        tps_attr_read_cb,  // Read callback function pointer
;;;174        NULL,           // Write callback function pointer
;;;175        NULL            // CCCD update callback function pointer
;;;176    };
;;;177    
;;;178    /**
;;;179      * @brief Add tx power service to the BLE stack database.
;;;180      *
;;;181      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;182      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;183      * @retval 0xFF Operation failure.
;;;184      * @retval others Service id assigned by stack.
;;;185      *
;;;186      * <b>Example usage</b>
;;;187      * \code{.c}
;;;188         void profile_init()
;;;189         {
;;;190             server_init(1);
;;;191             tps_id = tps_add_service(app_handle_profile_message);
;;;192         }
;;;193      * \endcode
;;;194      */
;;;195    T_SERVER_ID tps_add_service(void *p_func)
;;;196    {
        0x0080f5b4:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080f5b6:    4604        .F      MOV      r4,r0
;;;197        T_SERVER_ID service_id;
;;;198        if (false == server_add_service(&service_id,
        0x0080f5b8:    4810        .H      LDR      r0,[pc,#64] ; [0x80f5fc] = 0x810d58
        0x0080f5ba:    e9d01216    ....    LDRD     r1,r2,[r0,#0x58]
        0x0080f5be:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0080f5c2:    4601        .F      MOV      r1,r0
        0x0080f5c4:    6d43        Cm      LDR      r3,[r0,#0x54]
        0x0080f5c6:    2254        T"      MOVS     r2,#0x54
        0x0080f5c8:    a802        ..      ADD      r0,sp,#8
        0x0080f5ca:    f440f050    @.P.    BL       server_add_service ; 0x4f66e
        0x0080f5ce:    b950        P.      CBNZ     r0,0x80f5e6 ; tps_add_service + 50
;;;199                                        (uint8_t *)tps_attr_tbl,
;;;200                                        tps_attr_tbl_size,
;;;201                                        tps_cbs))
;;;202        {
;;;203            PROFILE_PRINT_ERROR1("tps_add_service: service_id %d", service_id);
        0x0080f5d0:    4907        .I      LDR      r1,[pc,#28] ; [0x80f5f0] = 0x880039c
        0x0080f5d2:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080f5d6:    2201        ."      MOVS     r2,#1
        0x0080f5d8:    3190        .1      ADDS     r1,r1,#0x90
        0x0080f5da:    4806        .H      LDR      r0,[pc,#24] ; [0x80f5f4] = 0x21103300
        0x0080f5dc:    f7f8da3f    ..?.    BL       log_buffer ; 0x7a5e
;;;204            service_id = 0xff;
        0x0080f5e0:    20ff        .       MOVS     r0,#0xff
        0x0080f5e2:    f88d0008    ....    STRB     r0,[sp,#8]
;;;205        }
;;;206    
;;;207        pfn_tps_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x0080f5e6:    4804        .H      LDR      r0,[pc,#16] ; [0x80f5f8] = 0x208138
;;;208        return service_id;
        0x0080f5e8:    6044        D`      STR      r4,[r0,#4]
        0x0080f5ea:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;209    }
        0x0080f5ee:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080f5f0:    0880039c    ....    DCD    142607260
        0x0080f5f4:    21103300    .3.!    DCD    554709760
        0x0080f5f8:    00208138    8. .    DCD    2130232
        0x0080f5fc:    00810d58    X...    DCD    8457560
    $t
    .text
    bas_set_parameter
;;; .\..\source\profile\bas.c
;;;137    {
        0x0080f600:    b510        ..      PUSH     {r4,lr}
        0x0080f602:    2401        .$      MOVS     r4,#1
        0x0080f604:    2801        .(      CMP      r0,#1
;;; .\..\source\profile\bas.c (137)
        0x0080f606:    d006        ..      BEQ      0x80f616 ; bas_set_parameter + 22
;;;138        bool ret = true;
;;;139    
;;;140        switch (param_type)
;;;141        {
;;;142        default:
;;;143            {
;;;144                ret = false;
        0x0080f608:    2400        .$      MOVS     r4,#0
;;;145                PROFILE_PRINT_ERROR0("bas_set_parameter failed");
        0x0080f60a:    4622        "F      MOV      r2,r4
        0x0080f60c:    4953        SI      LDR      r1,[pc,#332] ; [0x80f75c] = 0x8800450
        0x0080f60e:    4854        TH      LDR      r0,[pc,#336] ; [0x80f760] = 0x21103300
        0x0080f610:    f7f8da25    ..%.    BL       log_buffer ; 0x7a5e
;;;146            }
;;;147            break;
        0x0080f614:    e006        ..      B        0x80f624 ; bas_set_parameter + 36
;;;148    
;;;149        case BAS_PARAM_BATTERY_LEVEL:
;;;150            {
;;;151                if (length != sizeof(uint8_t))
        0x0080f616:    2901        .)      CMP      r1,#1
        0x0080f618:    d001        ..      BEQ      0x80f61e ; bas_set_parameter + 30
;;;152                {
;;;153                    ret = false;
        0x0080f61a:    2400        .$      MOVS     r4,#0
        0x0080f61c:    e002        ..      B        0x80f624 ; bas_set_parameter + 36
;;;154                }
;;;155                else
;;;156                {
;;;157                    battery_level = p_value[0];
        0x0080f61e:    4951        QI      LDR      r1,[pc,#324] ; [0x80f764] = 0x208140
        0x0080f620:    7810        .x      LDRB     r0,[r2,#0]
        0x0080f622:    7008        .p      STRB     r0,[r1,#0]
;;;158                }
;;;159            }
;;;160            break;
;;;161        }
;;;162    
;;;163        return ret;
        0x0080f624:    4620         F      MOV      r0,r4
;;;164    }
        0x0080f626:    bd10        ..      POP      {r4,pc}
    bas_battery_level_value_notify
;;;165    
;;;166    /**
;;;167     * @brief       Send notify battery level notification data .
;;;168     *
;;;169     * @param[in]   conn_id  Connection id.
;;;170     * @param[in]   service_id  Service id.
;;;171     * @param[in]   battery_level  Battery level value.
;;;172     * @return Operation result.
;;;173     * @retval true Operation success.
;;;174     * @retval false Operation failure.
;;;175     *
;;;176     * <b>Example usage</b>
;;;177     * \code{.c}
;;;178        void test(void)
;;;179        {
;;;180            uint8_t battery_level = 90;
;;;181            bas_battery_level_value_notify(conn_id, bas_id, battery_level);
;;;182        }
;;;183     * \endcode
;;;184     */
;;;185    bool bas_battery_level_value_notify(uint8_t conn_id, uint8_t service_id, uint8_t battery_level)
;;;186    {
        0x0080f628:    b507        ..      PUSH     {r0-r2,lr}
        0x0080f62a:    b082        ..      SUB      sp,sp,#8
;;;187        return server_send_data(conn_id, service_id, GATT_SVC_BAS_BATTERY_LEVEL_INDEX, &battery_level,
        0x0080f62c:    2300        .#      MOVS     r3,#0
        0x0080f62e:    2201        ."      MOVS     r2,#1
        0x0080f630:    e9cd2300    ...#    STRD     r2,r3,[sp,#0]
        0x0080f634:    ab04        ..      ADD      r3,sp,#0x10
        0x0080f636:    2202        ."      MOVS     r2,#2
        0x0080f638:    f440f0b4    @...    BL       server_send_data ; 0x4f7a4
;;;188                                sizeof(battery_level), GATT_PDU_TYPE_ANY);
;;;189    }
        0x0080f63c:    b005        ..      ADD      sp,sp,#0x14
        0x0080f63e:    bd00        ..      POP      {pc}
    bas_battery_level_value_read_confirm
;;;190    
;;;191    /**
;;;192     * @brief       Confirm for read battery level value request.
;;;193     *
;;;194     * @param[in]   conn_id  Callback when service attribute was read/write.
;;;195     * @param[in]   service_id  Callback when service attribute was read/write.
;;;196     * @param[in]   battery_level  Callback when service attribute was read/write.
;;;197     * @return Operation result.
;;;198     * @retval true Operation success.
;;;199     * @retval false Operation failure.
;;;200     *
;;;201     * <b>Example usage</b>
;;;202     * \code{.c}
;;;203        void test(void)
;;;204        {
;;;205            uint8_t battery_level = 90;
;;;206            bas_battery_level_value_read_confirm(conn_id, bas_id, battery_level);
;;;207        }
;;;208     * \endcode
;;;209     */
;;;210    bool bas_battery_level_value_read_confirm(uint8_t conn_id, uint8_t service_id,
;;;211                                              uint8_t battery_level)
;;;212    {
        0x0080f640:    b507        ..      PUSH     {r0-r2,lr}
        0x0080f642:    4b48        HK      LDR      r3,[pc,#288] ; [0x80f764] = 0x208140
;;; .\..\source\profile\bas.c (212)
        0x0080f644:    b082        ..      SUB      sp,sp,#8
        0x0080f646:    785a        Zx      LDRB     r2,[r3,#1]
        0x0080f648:    b14a        J.      CBZ      r2,0x80f65e ; bas_battery_level_value_read_confirm + 30
;;;213        if (bas_read_battery_level_pending == true)
;;;214        {
;;;215            bas_read_battery_level_pending = false;
        0x0080f64a:    2200        ."      MOVS     r2,#0
        0x0080f64c:    705a        Zp      STRB     r2,[r3,#1]
;;;216            return server_attr_read_confirm(conn_id, service_id, GATT_SVC_BAS_BATTERY_LEVEL_INDEX,
        0x0080f64e:    2301        .#      MOVS     r3,#1
        0x0080f650:    e9cd3200    ...2    STRD     r3,r2,[sp,#0]
        0x0080f654:    ab04        ..      ADD      r3,sp,#0x10
        0x0080f656:    2202        ."      MOVS     r2,#2
        0x0080f658:    f440f01b    @...    BL       server_attr_read_confirm ; 0x4f692
        0x0080f65c:    e7ee        ..      B        0x80f63c ; bas_battery_level_value_notify + 20
;;;217                                            &battery_level, sizeof(battery_level), APP_RESULT_SUCCESS);
;;;218        }
;;;219        else
;;;220        {
;;;221            return false;
        0x0080f65e:    2000        .       MOVS     r0,#0
;;;222        }
;;;223    }
        0x0080f660:    e7ec        ..      B        0x80f63c ; bas_battery_level_value_notify + 20
    bas_attr_read_cb
;;;224    
;;;225    /**
;;;226     * @brief read characteristic data from service.
;;;227     *
;;;228     * @param conn_id           Connection ID.
;;;229     * @param service_id        ServiceID to be read.
;;;230     * @param attrib_index      Attribute index of getting characteristic data.
;;;231     * @param offset            Offset of characteritic to be read.
;;;232     * @param p_length          Length of getting characteristic data.
;;;233     * @param pp_value          Pointer to pointer of characteristic value to be read.
;;;234     * @return T_APP_RESULT
;;;235    */
;;;236    T_APP_RESULT bas_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t attrib_index,
;;;237                                  uint16_t offset, uint16_t *p_length, uint8_t **pp_value)
;;;238    {
        0x0080f662:    e92d43f8    -..C    PUSH     {r3-r9,lr}
        0x0080f666:    4605        .F      MOV      r5,r0
        0x0080f668:    e9dd6708    ...g    LDRD     r6,r7,[sp,#0x20]
        0x0080f66c:    2000        .       MOVS     r0,#0
        0x0080f66e:    8030        0.      STRH     r0,[r6,#0]
        0x0080f670:    4688        .F      MOV      r8,r1
        0x0080f672:    9300        ..      STR      r3,[sp,#0]
        0x0080f674:    4939        9I      LDR      r1,[pc,#228] ; [0x80f75c] = 0x8800450
        0x0080f676:    483a        :H      LDR      r0,[pc,#232] ; [0x80f760] = 0x21103300
        0x0080f678:    4614        .F      MOV      r4,r2
;;;239        T_APP_RESULT cause = APP_RESULT_SUCCESS;
;;;240        *p_length = 0;
;;;241    
;;;242        PROFILE_PRINT_INFO2("bas_attr_read_cb attrib_index = %d offset %x", attrib_index, offset);
        0x0080f67a:    4613        .F      MOV      r3,r2
        0x0080f67c:    2202        ."      MOVS     r2,#2
        0x0080f67e:    311c        .1      ADDS     r1,r1,#0x1c
        0x0080f680:    1c80        ..      ADDS     r0,r0,#2
        0x0080f682:    f7f8d9ec    ....    BL       log_buffer ; 0x7a5e
;;;243    
;;;244        switch (attrib_index)
        0x0080f686:    2c02        .,      CMP      r4,#2
        0x0080f688:    d00a        ..      BEQ      0x80f6a0 ; bas_attr_read_cb + 62
;;;245        {
;;;246        default:
;;;247            {
;;;248                PROFILE_PRINT_ERROR1("bas_attr_read_cb attrib_index = %d not found", attrib_index);
        0x0080f68a:    4934        4I      LDR      r1,[pc,#208] ; [0x80f75c] = 0x8800450
        0x0080f68c:    4623        #F      MOV      r3,r4
        0x0080f68e:    2201        ."      MOVS     r2,#1
        0x0080f690:    314c        L1      ADDS     r1,r1,#0x4c
        0x0080f692:    4833        3H      LDR      r0,[pc,#204] ; [0x80f760] = 0x21103300
        0x0080f694:    f7f8d9e3    ....    BL       log_buffer ; 0x7a5e
;;;249                cause  = APP_RESULT_ATTR_NOT_FOUND;
        0x0080f698:    f240400a    @..@    MOV      r0,#0x40a
        0x0080f69c:    e8bd83f8    ....    POP      {r3-r9,pc}
;;;250            }
;;;251            break;
;;;252    
;;;253        case GATT_SVC_BAS_BATTERY_LEVEL_INDEX:
;;;254            {
;;;255                T_BAS_CALLBACK_DATA callback_data;
;;;256                callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0080f6a0:    2002        .       MOVS     r0,#2
        0x0080f6a2:    f88d0001    ....    STRB     r0,[sp,#1]
;;;257                callback_data.conn_id = conn_id;
        0x0080f6a6:    f88d5000    ...P    STRB     r5,[sp,#0]
        0x0080f6aa:    4d2e        .M      LDR      r5,[pc,#184] ; [0x80f764] = 0x208140
;;;258                callback_data.msg_data.read_value_index = BAS_READ_BATTERY_LEVEL;
        0x0080f6ac:    2401        .$      MOVS     r4,#1
        0x0080f6ae:    f88d4002    ...@    STRB     r4,[sp,#2]
;;;259                cause = pfn_bas_cb(service_id, (void *)&callback_data);
        0x0080f6b2:    686a        jh      LDR      r2,[r5,#4]
        0x0080f6b4:    4669        iF      MOV      r1,sp
        0x0080f6b6:    4640        @F      MOV      r0,r8
        0x0080f6b8:    4790        .G      BLX      r2
;;;260                if (cause == APP_RESULT_PENDING)
        0x0080f6ba:    f5a06150    ..Pa    SUB      r1,r0,#0xd00
        0x0080f6be:    3901        .9      SUBS     r1,#1
        0x0080f6c0:    d100        ..      BNE      0x80f6c4 ; bas_attr_read_cb + 98
;;;261                {
;;;262                    bas_read_battery_level_pending = true;
        0x0080f6c2:    706c        lp      STRB     r4,[r5,#1]
;;;263                }
;;;264    
;;;265                *pp_value = &battery_level;
;;;266                *p_length = sizeof(battery_level);
        0x0080f6c4:    603d        =`      STR      r5,[r7,#0]
        0x0080f6c6:    8034        4.      STRH     r4,[r6,#0]
;;;267            }
;;;268            break;
;;;269        }
;;;270        return (cause);
;;;271    }
        0x0080f6c8:    e7e8        ..      B        0x80f69c ; bas_attr_read_cb + 58
    bas_cccd_update_cb
;;;272    
;;;273    /**
;;;274     * @brief update CCCD bits from stack.
;;;275     *
;;;276     * @param conn_id           Connection ID.
;;;277     * @param service_id        Service ID.
;;;278     * @param index             Attribute index of characteristic data.
;;;279     * @param ccc_bits          CCCD bits from stack.
;;;280     * @return None
;;;281    */
;;;282    void bas_cccd_update_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t index, uint16_t ccc_bits)
;;;283    {
        0x0080f6ca:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x0080f6ce:    2601        .&      MOVS     r6,#1
        0x0080f6d0:    f88d6005    ...`    STRB     r6,[sp,#5]
        0x0080f6d4:    4688        .F      MOV      r8,r1
        0x0080f6d6:    f88d0004    ....    STRB     r0,[sp,#4]
        0x0080f6da:    461d        .F      MOV      r5,r3
        0x0080f6dc:    9300        ..      STR      r3,[sp,#0]
        0x0080f6de:    491f        .I      LDR      r1,[pc,#124] ; [0x80f75c] = 0x8800450
        0x0080f6e0:    481f        .H      LDR      r0,[pc,#124] ; [0x80f760] = 0x21103300
        0x0080f6e2:    4617        .F      MOV      r7,r2
        0x0080f6e4:    4613        .F      MOV      r3,r2
;;;284        T_BAS_CALLBACK_DATA callback_data;
;;;285        callback_data.msg_type = SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION;
;;;286        callback_data.conn_id = conn_id;
;;;287        bool handle = true;
        0x0080f6e6:    4634        4F      MOV      r4,r6
;;;288        PROFILE_PRINT_INFO2("bas_cccd_update_cb index = %d ccc_bits %x", index, ccc_bits);
        0x0080f6e8:    2202        ."      MOVS     r2,#2
        0x0080f6ea:    317c        |1      ADDS     r1,r1,#0x7c
        0x0080f6ec:    1c80        ..      ADDS     r0,r0,#2
        0x0080f6ee:    f7f8d9b6    ....    BL       log_buffer ; 0x7a5e
;;;289    
;;;290        switch (index)
        0x0080f6f2:    2f03        ./      CMP      r7,#3
        0x0080f6f4:    d00b        ..      BEQ      0x80f70e ; bas_cccd_update_cb + 68
;;;291        {
;;;292        case GATT_SVC_BAS_CHAR_CCCD_INDEX:
;;;293            {
;;;294                if (ccc_bits & GATT_CLIENT_CHAR_CONFIG_NOTIFY)
;;;295                {
;;;296                    callback_data.msg_data.notification_indification_index = BAS_NOTIFY_BATTERY_LEVEL_ENABLE;
;;;297                }
;;;298                else
;;;299                {
;;;300                    callback_data.msg_data.notification_indification_index = BAS_NOTIFY_BATTERY_LEVEL_DISABLE;
;;;301                }
;;;302                break;
;;;303            }
;;;304        default:
;;;305            {
;;;306                handle = false;
        0x0080f6f6:    2400        .$      MOVS     r4,#0
;;;307                break;
;;;308            }
;;;309    
;;;310        }
;;;311    
;;;312        if (pfn_bas_cb && (handle == true))
        0x0080f6f8:    481a        .H      LDR      r0,[pc,#104] ; [0x80f764] = 0x208140
        0x0080f6fa:    6842        Bh      LDR      r2,[r0,#4]
        0x0080f6fc:    2a00        .*      CMP      r2,#0
        0x0080f6fe:    d004        ..      BEQ      0x80f70a ; bas_cccd_update_cb + 64
        0x0080f700:    2c00        .,      CMP      r4,#0
        0x0080f702:    d002        ..      BEQ      0x80f70a ; bas_cccd_update_cb + 64
;;;313        {
;;;314            pfn_bas_cb(service_id, (void *)&callback_data);
        0x0080f704:    a901        ..      ADD      r1,sp,#4
        0x0080f706:    4640        @F      MOV      r0,r8
        0x0080f708:    4790        .G      BLX      r2
;;;315        }
;;;316    
;;;317        return;
;;;318    }
        0x0080f70a:    e8bd81fc    ....    POP      {r2-r8,pc}
        0x0080f70e:    07e8        ..      LSLS     r0,r5,#31
        0x0080f710:    d002        ..      BEQ      0x80f718 ; bas_cccd_update_cb + 78
        0x0080f712:    f88d6006    ...`    STRB     r6,[sp,#6]
        0x0080f716:    e7ef        ..      B        0x80f6f8 ; bas_cccd_update_cb + 46
        0x0080f718:    2002        .       MOVS     r0,#2
        0x0080f71a:    f88d0006    ....    STRB     r0,[sp,#6]
        0x0080f71e:    e7eb        ..      B        0x80f6f8 ; bas_cccd_update_cb + 46
    bas_add_service
;;;319    
;;;320    /**
;;;321     * @brief BAS Service Callbacks.
;;;322    */
;;;323    const T_FUN_GATT_SERVICE_CBS bas_cbs =
;;;324    {
;;;325        bas_attr_read_cb,  // Read callback function pointer
;;;326        NULL, // Write callback function pointer
;;;327        bas_cccd_update_cb  // CCCD update callback function pointer
;;;328    };
;;;329    
;;;330    /**
;;;331      * @brief       Add battery service to the BLE stack database.
;;;332      *
;;;333      *
;;;334      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;335      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;336      * @retval 0xFF Operation failure.
;;;337      * @retval Others Service id assigned by stack.
;;;338      *
;;;339      * <b>Example usage</b>
;;;340      * \code{.c}
;;;341         void profile_init()
;;;342         {
;;;343             server_init(1);
;;;344             bas_id = bas_add_service(app_handle_profile_message);
;;;345         }
;;;346      * \endcode
;;;347      */
;;;348    T_SERVER_ID bas_add_service(void *p_func)
;;;349    {
        0x0080f720:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080f722:    4604        .F      MOV      r4,r0
;;;350        T_SERVER_ID service_id;
;;;351        if (false == server_add_service(&service_id,
        0x0080f724:    4810        .H      LDR      r0,[pc,#64] ; [0x80f768] = 0x810db8
        0x0080f726:    e9d0121d    ....    LDRD     r1,r2,[r0,#0x74]
        0x0080f72a:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0080f72e:    4601        .F      MOV      r1,r0
        0x0080f730:    6f03        .o      LDR      r3,[r0,#0x70]
        0x0080f732:    2270        p"      MOVS     r2,#0x70
        0x0080f734:    a802        ..      ADD      r0,sp,#8
        0x0080f736:    f43ff79a    ?...    BL       server_add_service ; 0x4f66e
        0x0080f73a:    b950        P.      CBNZ     r0,0x80f752 ; bas_add_service + 50
;;;352                                        (uint8_t *)bas_attr_tbl,
;;;353                                        bas_attr_tbl_size,
;;;354                                        bas_cbs))
;;;355        {
;;;356            PROFILE_PRINT_ERROR1("bas_add_service: service_id %d", service_id);
        0x0080f73c:    4907        .I      LDR      r1,[pc,#28] ; [0x80f75c] = 0x8800450
        0x0080f73e:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080f742:    2201        ."      MOVS     r2,#1
        0x0080f744:    31ac        .1      ADDS     r1,r1,#0xac
        0x0080f746:    4806        .H      LDR      r0,[pc,#24] ; [0x80f760] = 0x21103300
        0x0080f748:    f7f8d989    ....    BL       log_buffer ; 0x7a5e
;;;357            service_id = 0xff;
        0x0080f74c:    20ff        .       MOVS     r0,#0xff
        0x0080f74e:    f88d0008    ....    STRB     r0,[sp,#8]
;;;358        }
;;;359        pfn_bas_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x0080f752:    4804        .H      LDR      r0,[pc,#16] ; [0x80f764] = 0x208140
;;;360        return service_id;
        0x0080f754:    6044        D`      STR      r4,[r0,#4]
        0x0080f756:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;361    }
        0x0080f75a:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080f75c:    08800450    P...    DCD    142607440
        0x0080f760:    21103300    .3.!    DCD    554709760
        0x0080f764:    00208140    @. .    DCD    2130240
        0x0080f768:    00810db8    ....    DCD    8457656
    $t
    .text
    kns_set_parameter
;;; .\..\source\profile\kns.c
;;;203    {
        0x0080f76c:    b510        ..      PUSH     {r4,lr}
        0x0080f76e:    2401        .$      MOVS     r4,#1
;;; .\..\source\profile\kns.c (203)
        0x0080f770:    b130        0.      CBZ      r0,0x80f780 ; kns_set_parameter + 20
;;;204        bool ret = true;
;;;205    
;;;206        switch (param_type)
;;;207        {
;;;208        default:
;;;209            {
;;;210                ret = false;
        0x0080f772:    2400        .$      MOVS     r4,#0
;;;211                PROFILE_PRINT_ERROR0("bas_set_parameter failed");
        0x0080f774:    4622        "F      MOV      r2,r4
        0x0080f776:    4957        WI      LDR      r1,[pc,#348] ; [0x80f8d4] = 0x8800520
        0x0080f778:    4857        WH      LDR      r0,[pc,#348] ; [0x80f8d8] = 0x21103300
        0x0080f77a:    f7f8d970    ..p.    BL       log_buffer ; 0x7a5e
;;;212            }
;;;213            break;
        0x0080f77e:    e006        ..      B        0x80f78e ; kns_set_parameter + 34
;;;214    
;;;215        case KNS_PARAM_VALUE:
;;;216            {
;;;217                if (length != sizeof(uint32_t))
        0x0080f780:    2904        .)      CMP      r1,#4
        0x0080f782:    d001        ..      BEQ      0x80f788 ; kns_set_parameter + 28
;;;218                {
;;;219                    ret = false;
        0x0080f784:    2400        .$      MOVS     r4,#0
        0x0080f786:    e002        ..      B        0x80f78e ; kns_set_parameter + 34
;;;220                }
;;;221                else
;;;222                {
;;;223                    gParaValue = *p_value;
        0x0080f788:    4954        TI      LDR      r1,[pc,#336] ; [0x80f8dc] = 0x207f50
        0x0080f78a:    6810        .h      LDR      r0,[r2,#0]
        0x0080f78c:    6008        .`      STR      r0,[r1,#0]
;;;224                }
;;;225            }
;;;226            break;
;;;227        }
;;;228    
;;;229        return ret;
        0x0080f78e:    4620         F      MOV      r0,r4
;;;230    }
        0x0080f790:    bd10        ..      POP      {r4,pc}
    kns_attr_read_cb
;;;231    /**
;;;232     * @brief read characteristic data from stack.
;;;233     *
;;;234     * @param ServiceId          ServiceId generated when register to upper stack.
;;;235     * @param attrib_index          Attribute index of getting characteristic data.
;;;236     * @param offset                Used for Blob Read.
;;;237     * @param length_ptr            length of getting characteristic data.
;;;238     * @param ppValue            pointer of getting characteristic data.
;;;239     * @return TProfileResult   profile procedure results.
;;;240    */
;;;241    T_APP_RESULT kns_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t attrib_index,
;;;242                                  uint16_t offset, uint16_t *p_length, uint8_t **pp_value)
;;;243    {
        0x0080f792:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x0080f796:    2500        .%      MOVS     r5,#0
        0x0080f798:    e9dd4708    ...G    LDRD     r4,r7,[sp,#0x20]
        0x0080f79c:    4616        .F      MOV      r6,r2
        0x0080f79e:    460b        .F      MOV      r3,r1
        0x0080f7a0:    8025        %.      STRH     r5,[r4,#0]
        0x0080f7a2:    2a02        .*      CMP      r2,#2
        0x0080f7a4:    d009        ..      BEQ      0x80f7ba ; kns_attr_read_cb + 40
;;;244        T_APP_RESULT  cause  = APP_RESULT_SUCCESS;
;;;245        *p_length = 0;
;;;246    
;;;247        switch (attrib_index)
;;;248        {
;;;249        default:
;;;250            /* invalid attribute index. */
;;;251            PROFILE_PRINT_ERROR1("kns_attr_read_cb attrib_index = %d not found", attrib_index);
        0x0080f7a6:    494b        KI      LDR      r1,[pc,#300] ; [0x80f8d4] = 0x8800520
        0x0080f7a8:    4613        .F      MOV      r3,r2
        0x0080f7aa:    2201        ."      MOVS     r2,#1
        0x0080f7ac:    311c        .1      ADDS     r1,r1,#0x1c
        0x0080f7ae:    484a        JH      LDR      r0,[pc,#296] ; [0x80f8d8] = 0x21103300
        0x0080f7b0:    f7f8d955    ..U.    BL       log_buffer ; 0x7a5e
;;;252            cause  = APP_RESULT_ATTR_NOT_FOUND;
        0x0080f7b4:    f240450a    @..E    MOV      r5,#0x40a
;;;253            break;
        0x0080f7b8:    e00e        ..      B        0x80f7d8 ; kns_attr_read_cb + 70
;;;254        case KNS_PARAM_VALUE_INDEX:
;;;255            {
;;;256                T_KNS_CALLBACK_DATA callback_data;
;;;257    
;;;258                callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0080f7ba:    2002        .       MOVS     r0,#2
        0x0080f7bc:    f88d0000    ....    STRB     r0,[sp,#0]
;;;259                //callback_data.conn_id = conn_id;
;;;260                callback_data.msg_data.read_index = KNS_READ_PARA;
        0x0080f7c0:    f88d0004    ....    STRB     r0,[sp,#4]
;;;261                if (pfn_kns_cb)
        0x0080f7c4:    4846        FH      LDR      r0,[pc,#280] ; [0x80f8e0] = 0x208148
        0x0080f7c6:    6802        .h      LDR      r2,[r0,#0]
        0x0080f7c8:    b112        ..      CBZ      r2,0x80f7d0 ; kns_attr_read_cb + 62
;;;262                {
;;;263                    pfn_kns_cb(service_id, (void *)&callback_data);
        0x0080f7ca:    4669        iF      MOV      r1,sp
        0x0080f7cc:    4618        .F      MOV      r0,r3
        0x0080f7ce:    4790        .G      BLX      r2
;;;264                }
;;;265    
;;;266                *pp_value = (uint8_t *)&gParaValue;
        0x0080f7d0:    4842        BH      LDR      r0,[pc,#264] ; [0x80f8dc] = 0x207f50
;;;267                *p_length = sizeof(gParaValue);
        0x0080f7d2:    6038        8`      STR      r0,[r7,#0]
        0x0080f7d4:    2004        .       MOVS     r0,#4
        0x0080f7d6:    8020         .      STRH     r0,[r4,#0]
;;;268            }
;;;269            break;
;;;270        }
;;;271    
;;;272        PROFILE_PRINT_INFO2("<-- gatt get PxpExtended attribute value: AttribIndex--%d, length--%d",
        0x0080f7d8:    8820         .      LDRH     r0,[r4,#0]
        0x0080f7da:    9000        ..      STR      r0,[sp,#0]
        0x0080f7dc:    493d        =I      LDR      r1,[pc,#244] ; [0x80f8d4] = 0x8800520
        0x0080f7de:    483e        >H      LDR      r0,[pc,#248] ; [0x80f8d8] = 0x21103300
        0x0080f7e0:    4633        3F      MOV      r3,r6
        0x0080f7e2:    2202        ."      MOVS     r2,#2
        0x0080f7e4:    314c        L1      ADDS     r1,r1,#0x4c
        0x0080f7e6:    1c80        ..      ADDS     r0,r0,#2
        0x0080f7e8:    f7f8d939    ..9.    BL       log_buffer ; 0x7a5e
;;;273                            attrib_index,
;;;274                            *p_length);
;;;275        return (cause);
        0x0080f7ec:    4628        (F      MOV      r0,r5
;;;276    }
        0x0080f7ee:    e8bd81fc    ....    POP      {r2-r8,pc}
    kns_attr_write_cb
;;;277    
;;;278    /**
;;;279     * @brief write characteristic data from stack.
;;;280     *
;;;281     * @param ServiceId          ServiceId generated when register to upper stack.
;;;282     * @param iAttribIndex          Attribute index of getting characteristic data.
;;;283     * @param wLength                length of data to be written.
;;;284     * @param pValue            pointer of data to be written.
;;;285     * @return TProfileResult   profile procedure results.
;;;286    */
;;;287    
;;;288    static T_APP_RESULT kns_attr_write_cb(uint8_t conn_id, T_SERVER_ID service_id,
;;;289                                          uint16_t attr_index, T_WRITE_TYPE write_type, uint16_t length,
;;;290                                          uint8_t *p_value, P_FUN_WRITE_IND_POST_PROC *p_write_ind_post_proc)
;;;291    {
        0x0080f7f2:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080f7f4:    460d        .F      MOV      r5,r1
        0x0080f7f6:    e9dd0306    ....    LDRD     r0,r3,[sp,#0x18]
        0x0080f7fa:    2400        .$      MOVS     r4,#0
        0x0080f7fc:    b123        #.      CBZ      r3,0x80f808 ; kns_attr_write_cb + 22
        0x0080f7fe:    2a02        .*      CMP      r2,#2
        0x0080f800:    d00c        ..      BEQ      0x80f81c ; kns_attr_write_cb + 42
        0x0080f802:    f240440a    @..D    MOV      r4,#0x40a
        0x0080f806:    e013        ..      B        0x80f830 ; kns_attr_write_cb + 62
;;;292        T_APP_RESULT  cause = APP_RESULT_SUCCESS;
;;;293        T_KNS_CALLBACK_DATA callback_data;
;;;294        if (!p_value)
;;;295        {
;;;296            PROFILE_PRINT_ERROR2("kns_attr_write_cb: p_value %p, length 0x%x", p_value, length);
        0x0080f808:    4932        2I      LDR      r1,[pc,#200] ; [0x80f8d4] = 0x8800520
        0x0080f80a:    9000        ..      STR      r0,[sp,#0]
        0x0080f80c:    2202        ."      MOVS     r2,#2
        0x0080f80e:    3198        .1      ADDS     r1,r1,#0x98
        0x0080f810:    4831        1H      LDR      r0,[pc,#196] ; [0x80f8d8] = 0x21103300
        0x0080f812:    f7f8d924    ..$.    BL       log_buffer ; 0x7a5e
;;;297            cause = APP_RESULT_INVALID_PDU;
        0x0080f816:    f2404004    @..@    MOV      r0,#0x404
        0x0080f81a:    bd3e        >.      POP      {r1-r5,pc}
;;;298            return cause;
;;;299        }
;;;300    
;;;301        switch (attr_index)
;;;302        {
;;;303        default:
;;;304            cause = APP_RESULT_ATTR_NOT_FOUND;
;;;305            break;
;;;306        case KNS_PARAM_VALUE_INDEX:
;;;307            if (length != sizeof(uint32_t))
        0x0080f81c:    2804        .(      CMP      r0,#4
        0x0080f81e:    d002        ..      BEQ      0x80f826 ; kns_attr_write_cb + 52
;;;308            {
;;;309                cause = APP_RESULT_INVALID_VALUE_SIZE;
        0x0080f820:    f240440d    @..D    MOV      r4,#0x40d
        0x0080f824:    e004        ..      B        0x80f830 ; kns_attr_write_cb + 62
;;;310            }
;;;311            else
;;;312            {
;;;313                //callback_data.conn_id = conn_id;
;;;314                callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
        0x0080f826:    2003        .       MOVS     r0,#3
        0x0080f828:    f88d0004    ....    STRB     r0,[sp,#4]
;;;315                callback_data.msg_data.write_value = *(uint32_t *)p_value;
        0x0080f82c:    6818        .h      LDR      r0,[r3,#0]
        0x0080f82e:    9002        ..      STR      r0,[sp,#8]
;;;316            }
;;;317            break;
;;;318    
;;;319        }
;;;320        if (pfn_kns_cb && (cause == APP_RESULT_SUCCESS))
        0x0080f830:    482b        +H      LDR      r0,[pc,#172] ; [0x80f8e0] = 0x208148
        0x0080f832:    6802        .h      LDR      r2,[r0,#0]
        0x0080f834:    b11a        ..      CBZ      r2,0x80f83e ; kns_attr_write_cb + 76
        0x0080f836:    b914        ..      CBNZ     r4,0x80f83e ; kns_attr_write_cb + 76
;;;321        {
;;;322            pfn_kns_cb(service_id, (void *)&callback_data);
        0x0080f838:    a901        ..      ADD      r1,sp,#4
        0x0080f83a:    4628        (F      MOV      r0,r5
        0x0080f83c:    4790        .G      BLX      r2
;;;323        }
;;;324        return cause;
        0x0080f83e:    4620         F      MOV      r0,r4
;;;325    
;;;326    }
        0x0080f840:    bd3e        >.      POP      {r1-r5,pc}
    kns_cccd_update_cb
;;;327    /**
;;;328     * @brief update CCCD bits from stack.
;;;329     *
;;;330     * @param ServiceId          ServiceId generated when register to upper stack.
;;;331     * @param Index          Attribute index of getting characteristic data.
;;;332     * @param wCCCBits                CCCD bits to be updated.
;;;333     * @return none.
;;;334    */
;;;335    
;;;336    void kns_cccd_update_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t index, uint16_t ccc_bits)
;;;337    {
        0x0080f842:    e92d43fe    -..C    PUSH     {r1-r9,lr}
        0x0080f846:    4688        .F      MOV      r8,r1
        0x0080f848:    461d        .F      MOV      r5,r3
        0x0080f84a:    2601        .&      MOVS     r6,#1
        0x0080f84c:    9300        ..      STR      r3,[sp,#0]
        0x0080f84e:    4921        !I      LDR      r1,[pc,#132] ; [0x80f8d4] = 0x8800520
        0x0080f850:    4821        !H      LDR      r0,[pc,#132] ; [0x80f8d8] = 0x21103300
        0x0080f852:    4617        .F      MOV      r7,r2
        0x0080f854:    4613        .F      MOV      r3,r2
;;;338        T_KNS_CALLBACK_DATA callback_data;
;;;339        callback_data.msg_type = SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION;
        0x0080f856:    f88d6004    ...`    STRB     r6,[sp,#4]
;;;340        //callback_data.conn_id = conn_id;
;;;341        bool handle = true;
        0x0080f85a:    4634        4F      MOV      r4,r6
;;;342        PROFILE_PRINT_INFO2("kns_cccd_update_cb index = %d ccc_bits %x", index, ccc_bits);
        0x0080f85c:    2202        ."      MOVS     r2,#2
        0x0080f85e:    31c8        .1      ADDS     r1,r1,#0xc8
        0x0080f860:    1c80        ..      ADDS     r0,r0,#2
        0x0080f862:    f7f8d8fc    ....    BL       log_buffer ; 0x7a5e
;;;343    
;;;344        switch (index)
        0x0080f866:    2f05        ./      CMP      r7,#5
        0x0080f868:    d00b        ..      BEQ      0x80f882 ; kns_cccd_update_cb + 64
;;;345        {
;;;346        case KNS_KEY_VALUE_CCCD_INDEX:
;;;347            {
;;;348                if (ccc_bits & GATT_CLIENT_CHAR_CONFIG_NOTIFY)
;;;349                {
;;;350                    callback_data.msg_data.notification_indification_index = KNS_NOTIFY_ENABLE;
;;;351                }
;;;352                else
;;;353                {
;;;354                    callback_data.msg_data.notification_indification_index = KNS_NOTIFY_DISABLE;
;;;355                }
;;;356                break;
;;;357            }
;;;358        default:
;;;359            {
;;;360                handle = false;
        0x0080f86a:    2400        .$      MOVS     r4,#0
;;;361                break;
;;;362            }
;;;363    
;;;364        }
;;;365    
;;;366        if (pfn_kns_cb && (handle == true))
        0x0080f86c:    481c        .H      LDR      r0,[pc,#112] ; [0x80f8e0] = 0x208148
        0x0080f86e:    6802        .h      LDR      r2,[r0,#0]
        0x0080f870:    2a00        .*      CMP      r2,#0
        0x0080f872:    d004        ..      BEQ      0x80f87e ; kns_cccd_update_cb + 60
        0x0080f874:    2c00        .,      CMP      r4,#0
        0x0080f876:    d002        ..      BEQ      0x80f87e ; kns_cccd_update_cb + 60
;;;367        {
;;;368            pfn_kns_cb(service_id, (void *)&callback_data);
        0x0080f878:    a901        ..      ADD      r1,sp,#4
        0x0080f87a:    4640        @F      MOV      r0,r8
        0x0080f87c:    4790        .G      BLX      r2
;;;369        }
;;;370    
;;;371        return;
;;;372    }
        0x0080f87e:    e8bd83fe    ....    POP      {r1-r9,pc}
        0x0080f882:    07e8        ..      LSLS     r0,r5,#31
        0x0080f884:    d002        ..      BEQ      0x80f88c ; kns_cccd_update_cb + 74
        0x0080f886:    f88d6008    ...`    STRB     r6,[sp,#8]
        0x0080f88a:    e7ef        ..      B        0x80f86c ; kns_cccd_update_cb + 42
        0x0080f88c:    2000        .       MOVS     r0,#0
        0x0080f88e:    f88d0008    ....    STRB     r0,[sp,#8]
        0x0080f892:    e7eb        ..      B        0x80f86c ; kns_cccd_update_cb + 42
    kns_add_service
;;;373    
;;;374    /**
;;;375     * @brief KNS Service Callbacks.
;;;376    */
;;;377    const T_FUN_GATT_SERVICE_CBS kns_cbs =
;;;378    {
;;;379        kns_attr_read_cb,  // Read callback function pointer
;;;380        kns_attr_write_cb, // Write callback function pointer
;;;381        kns_cccd_update_cb  // CCCD update callback function pointer
;;;382    };
;;;383    
;;;384    /**
;;;385     * @brief Add PXP extended service to stack/profile.
;;;386     *
;;;387     * @param pFunc          pointer of function to send data to application from PXP extended service.
;;;388     * @return ServiceId.   the service ID auto generated by stack when register this service to stack
;;;389    */
;;;390    uint8_t kns_add_service(void *pFunc)
;;;391    {
        0x0080f894:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080f896:    4604        .F      MOV      r4,r0
;;;392        T_SERVER_ID service_id;
;;;393        if (false == server_add_service(&service_id,
        0x0080f898:    4812        .H      LDR      r0,[pc,#72] ; [0x80f8e4] = 0x810ec4
        0x0080f89a:    e9d0120b    ....    LDRD     r1,r2,[r0,#0x2c]
        0x0080f89e:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0080f8a2:    f1a00180    ....    SUB      r1,r0,#0x80
        0x0080f8a6:    6a83        .j      LDR      r3,[r0,#0x28]
        0x0080f8a8:    22a8        ."      MOVS     r2,#0xa8
        0x0080f8aa:    a802        ..      ADD      r0,sp,#8
        0x0080f8ac:    f43ff6df    ?...    BL       server_add_service ; 0x4f66e
        0x0080f8b0:    b950        P.      CBNZ     r0,0x80f8c8 ; kns_add_service + 52
;;;394                                        (uint8_t *)kns_attr_tbl,
;;;395                                        kns_attr_tbl_size,
;;;396                                        kns_cbs))
;;;397        {
;;;398            PROFILE_PRINT_ERROR1("kns_add_service: service_id %d", service_id);
        0x0080f8b2:    4908        .I      LDR      r1,[pc,#32] ; [0x80f8d4] = 0x8800520
        0x0080f8b4:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080f8b8:    2201        ."      MOVS     r2,#1
        0x0080f8ba:    31f8        .1      ADDS     r1,r1,#0xf8
        0x0080f8bc:    4806        .H      LDR      r0,[pc,#24] ; [0x80f8d8] = 0x21103300
        0x0080f8be:    f7f8d8ce    ....    BL       log_buffer ; 0x7a5e
;;;399            service_id = 0xff;
        0x0080f8c2:    20ff        .       MOVS     r0,#0xff
        0x0080f8c4:    f88d0008    ....    STRB     r0,[sp,#8]
;;;400        }
;;;401    
;;;402        pfn_kns_cb = (P_FUN_SERVER_GENERAL_CB)pFunc;
        0x0080f8c8:    4805        .H      LDR      r0,[pc,#20] ; [0x80f8e0] = 0x208148
;;;403        return service_id;
        0x0080f8ca:    6004        .`      STR      r4,[r0,#0]
        0x0080f8cc:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;404    }
        0x0080f8d0:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080f8d2:    0000        ..      DCW    0
        0x0080f8d4:    08800520     ...    DCD    142607648
        0x0080f8d8:    21103300    .3.!    DCD    554709760
        0x0080f8dc:    00207f50    P. .    DCD    2129744
        0x0080f8e0:    00208148    H. .    DCD    2130248
        0x0080f8e4:    00810ec4    ....    DCD    8457924
    $t
    .text
    dis_set_parameter
;;; .\..\source\profile\dis.c
;;;422    {
        0x0080f8e8:    b570        p.      PUSH     {r4-r6,lr}
        0x0080f8ea:    4613        .F      MOV      r3,r2
;;;423        bool ret = true;
        0x0080f8ec:    2401        .$      MOVS     r4,#1
        0x0080f8ee:    4a9a        .J      LDR      r2,[pc,#616] ; [0x80fb58] = 0x20814c
;;;424    
;;;425        switch (param_type)
        0x0080f8f0:    2809        .(      CMP      r0,#9
        0x0080f8f2:    d206        ..      BCS      0x80f902 ; dis_set_parameter + 26
        0x0080f8f4:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x0080f8f8:    2a21150c    ..!*    DCD    706811148
        0x0080f8fc:    4c453c33    3<EL    DCD    1279605811
        0x0080f900:    0056        V.      DCW    86
    $t
;;;426        {
;;;427        default:
;;;428            ret = false;
        0x0080f902:    2400        .$      MOVS     r4,#0
        0x0080f904:    4622        "F      MOV      r2,r4
        0x0080f906:    4995        .I      LDR      r1,[pc,#596] ; [0x80fb5c] = 0x880063c
        0x0080f908:    4895        .H      LDR      r0,[pc,#596] ; [0x80fb60] = 0x21103300
        0x0080f90a:    f7f8d8a8    ....    BL       log_buffer ; 0x7a5e
;;;429            break;
        0x0080f90e:    e012        ..      B        0x80f936 ; dis_set_parameter + 78
;;;430    
;;;431    #if DIS_CHAR_MANUFACTURER_NAME_SUPPORT
;;;432        case DIS_PARAM_MANUFACTURER_NAME:
;;;433            if (length > DIS_CHAR_MANUFACTURER_NAME_STR_MAX_LENGTH)
        0x0080f910:    2914        .)      CMP      r1,#0x14
        0x0080f912:    d900        ..      BLS      0x80f916 ; dis_set_parameter + 46
;;;434            {
;;;435                length = DIS_CHAR_MANUFACTURER_NAME_STR_MAX_LENGTH;
        0x0080f914:    2114        .!      MOVS     r1,#0x14
;;;436            }
;;;437            dis_manufacturer_name_len = length;
        0x0080f916:    7011        .p      STRB     r1,[r2,#0]
;;;438            memcpy(dis_manufacturer_name, p_value, length);
        0x0080f918:    488f        .H      LDR      r0,[pc,#572] ; [0x80fb58] = 0x20814c
        0x0080f91a:    460a        .F      MOV      r2,r1
        0x0080f91c:    4619        .F      MOV      r1,r3
        0x0080f91e:    300c        .0      ADDS     r0,r0,#0xc
;;;439            break;
        0x0080f920:    e007        ..      B        0x80f932 ; dis_set_parameter + 74
;;;440    #endif
;;;441    
;;;442    #if DIS_CHAR_MODEL_NUMBER_SUPPORT
;;;443        case DIS_PARAM_MODEL_NUMBER:
;;;444            if (length > DIS_CHAR_MODEL_NUMBER_STR_MAX_LENGTH)
        0x0080f922:    2914        .)      CMP      r1,#0x14
        0x0080f924:    d900        ..      BLS      0x80f928 ; dis_set_parameter + 64
;;;445            {
;;;446                length = DIS_CHAR_MODEL_NUMBER_STR_MAX_LENGTH;
        0x0080f926:    2114        .!      MOVS     r1,#0x14
;;;447            }
;;;448            dis_model_number_len = length;
        0x0080f928:    7051        Qp      STRB     r1,[r2,#1]
;;;449            memcpy(dis_model_number, p_value, length);
        0x0080f92a:    488b        .H      LDR      r0,[pc,#556] ; [0x80fb58] = 0x20814c
        0x0080f92c:    460a        .F      MOV      r2,r1
        0x0080f92e:    4619        .F      MOV      r1,r3
        0x0080f930:    3020         0      ADDS     r0,r0,#0x20
        0x0080f932:    f44af2b2    J...    BL       __aeabi_memcpy ; 0x59e9a
        0x0080f936:    4620         F      MOV      r0,r4
        0x0080f938:    bd70        p.      POP      {r4-r6,pc}
;;;450            break;
;;;451    #endif
;;;452    
;;;453    #if DIS_CHAR_SERIAL_NUMBER_SUPPORT
;;;454        case DIS_PARAM_SERIAL_NUMBER:
;;;455            if (length > DIS_CHAR_SERIAL_NUMBER_STR_MAX_LENGTH)
        0x0080f93a:    2914        .)      CMP      r1,#0x14
        0x0080f93c:    d900        ..      BLS      0x80f940 ; dis_set_parameter + 88
;;;456            {
;;;457                length = DIS_CHAR_SERIAL_NUMBER_STR_MAX_LENGTH;
        0x0080f93e:    2114        .!      MOVS     r1,#0x14
;;;458            }
;;;459            dis_serial_number_len = length;
        0x0080f940:    7091        .p      STRB     r1,[r2,#2]
;;;460            memcpy(dis_serial_number, p_value, length);
        0x0080f942:    4885        .H      LDR      r0,[pc,#532] ; [0x80fb58] = 0x20814c
        0x0080f944:    460a        .F      MOV      r2,r1
        0x0080f946:    4619        .F      MOV      r1,r3
        0x0080f948:    3034        40      ADDS     r0,r0,#0x34
;;;461    
;;;462            break;
        0x0080f94a:    e7f2        ..      B        0x80f932 ; dis_set_parameter + 74
;;;463    #endif
;;;464    
;;;465    #if DIS_CHAR_HARDWARE_REVISION_SUPPORT
;;;466        case DIS_PARAM_HARDWARE_REVISION:
;;;467            if (length > DIS_CHAR_HARDWARE_REVISION_STR_MAX_LENGTH)
        0x0080f94c:    2914        .)      CMP      r1,#0x14
        0x0080f94e:    d900        ..      BLS      0x80f952 ; dis_set_parameter + 106
;;;468            {
;;;469                length = DIS_CHAR_HARDWARE_REVISION_STR_MAX_LENGTH;
        0x0080f950:    2114        .!      MOVS     r1,#0x14
;;;470            }
;;;471            dis_hardware_rev_len = length;
        0x0080f952:    70d1        .p      STRB     r1,[r2,#3]
;;;472            memcpy(dis_hardware_rev, p_value, length);
        0x0080f954:    4880        .H      LDR      r0,[pc,#512] ; [0x80fb58] = 0x20814c
        0x0080f956:    460a        .F      MOV      r2,r1
        0x0080f958:    4619        .F      MOV      r1,r3
        0x0080f95a:    3048        H0      ADDS     r0,r0,#0x48
;;;473            break;
        0x0080f95c:    e7e9        ..      B        0x80f932 ; dis_set_parameter + 74
;;;474    #endif
;;;475    
;;;476    #if DIS_CHAR_FIRMWARE_REVISION_SUPPORT
;;;477        case DIS_PARAM_FIRMWARE_REVISION:
;;;478            if (length > DIS_CHAR_FIRMWARE_REVISION_STR_MAX_LENGTH)
        0x0080f95e:    2914        .)      CMP      r1,#0x14
        0x0080f960:    d900        ..      BLS      0x80f964 ; dis_set_parameter + 124
;;;479            {
;;;480                length = DIS_CHAR_FIRMWARE_REVISION_STR_MAX_LENGTH;
        0x0080f962:    2114        .!      MOVS     r1,#0x14
;;;481            }
;;;482            dis_firmware_rev_len = length;
        0x0080f964:    7111        .q      STRB     r1,[r2,#4]
;;;483            memcpy(dis_firmware_rev, p_value, length);
        0x0080f966:    487c        |H      LDR      r0,[pc,#496] ; [0x80fb58] = 0x20814c
        0x0080f968:    460a        .F      MOV      r2,r1
        0x0080f96a:    4619        .F      MOV      r1,r3
        0x0080f96c:    305c        \0      ADDS     r0,r0,#0x5c
;;;484            break;
        0x0080f96e:    e7e0        ..      B        0x80f932 ; dis_set_parameter + 74
;;;485    #endif
;;;486    
;;;487    #if DIS_CHAR_SOFTWARE_REVISION_SUPPORT
;;;488        case DIS_PARAM_SOFTWARE_REVISION:
;;;489            if (length > DIS_CHAR_SOFTWARE_REVISION_STR_MAX_LENGTH)
        0x0080f970:    2914        .)      CMP      r1,#0x14
        0x0080f972:    d900        ..      BLS      0x80f976 ; dis_set_parameter + 142
;;;490            {
;;;491                length = DIS_CHAR_SOFTWARE_REVISION_STR_MAX_LENGTH;
        0x0080f974:    2114        .!      MOVS     r1,#0x14
;;;492            }
;;;493            dis_software_rev_len = length;
        0x0080f976:    7151        Qq      STRB     r1,[r2,#5]
;;;494            memcpy(dis_software_rev, p_value, length);
        0x0080f978:    4877        wH      LDR      r0,[pc,#476] ; [0x80fb58] = 0x20814c
        0x0080f97a:    460a        .F      MOV      r2,r1
        0x0080f97c:    4619        .F      MOV      r1,r3
        0x0080f97e:    3070        p0      ADDS     r0,r0,#0x70
;;;495            break;
        0x0080f980:    e7d7        ..      B        0x80f932 ; dis_set_parameter + 74
;;;496    #endif
;;;497    
;;;498    #if DIS_CHAR_SYSTEM_ID_SUPPORT
;;;499        case DIS_PARAM_SYSTEM_ID:
;;;500            if (length > DIS_SYSTEM_ID_LENGTH)
        0x0080f982:    2908        .)      CMP      r1,#8
        0x0080f984:    d900        ..      BLS      0x80f988 ; dis_set_parameter + 160
;;;501            {
;;;502                length = DIS_SYSTEM_ID_LENGTH;
        0x0080f986:    2108        .!      MOVS     r1,#8
;;;503            }
;;;504            memcpy(dis_system_id, p_value, length);
        0x0080f988:    460a        .F      MOV      r2,r1
        0x0080f98a:    4619        .F      MOV      r1,r3
        0x0080f98c:    4875        uH      LDR      r0,[pc,#468] ; [0x80fb64] = 0x207f5c
;;;505            break;
        0x0080f98e:    e7d0        ..      B        0x80f932 ; dis_set_parameter + 74
;;;506    #endif
;;;507    
;;;508    #if DIS_CHAR_IEEE_CERTIF_DATA_LIST_SUPPORT
;;;509        case DIS_PARAM_IEEE_DATA_LIST:
;;;510            if (length > DIS_CHAR_IEEE_CERTIF_DATA_LIST_MAX_LENGTH)
        0x0080f990:    291e        .)      CMP      r1,#0x1e
        0x0080f992:    d900        ..      BLS      0x80f996 ; dis_set_parameter + 174
;;;511            {
;;;512                length = DIS_CHAR_IEEE_CERTIF_DATA_LIST_MAX_LENGTH;
        0x0080f994:    211e        .!      MOVS     r1,#0x1e
;;;513            }
;;;514            dis_ieee_data_list_len = length;
        0x0080f996:    4873        sH      LDR      r0,[pc,#460] ; [0x80fb64] = 0x207f5c
        0x0080f998:    460a        .F      MOV      r2,r1
        0x0080f99a:    3808        .8      SUBS     r0,r0,#8
        0x0080f99c:    7001        .p      STRB     r1,[r0,#0]
;;;515            memcpy(dis_ieee_data_list, p_value, length);
        0x0080f99e:    4619        .F      MOV      r1,r3
        0x0080f9a0:    3010        .0      ADDS     r0,r0,#0x10
;;;516            break;
        0x0080f9a2:    e7c6        ..      B        0x80f932 ; dis_set_parameter + 74
;;;517    #endif
;;;518    
;;;519    #if DIS_CHAR_PNP_ID_SUPPORT
;;;520        case DIS_PARAM_PNP_ID:
;;;521            if (length > DIS_PNP_ID_LENGTH)
        0x0080f9a4:    2907        .)      CMP      r1,#7
        0x0080f9a6:    d900        ..      BLS      0x80f9aa ; dis_set_parameter + 194
;;;522            {
;;;523                length = DIS_PNP_ID_LENGTH;
        0x0080f9a8:    2107        .!      MOVS     r1,#7
;;;524            }
;;;525            memcpy(dis_pnp_id, p_value, length);
        0x0080f9aa:    486e        nH      LDR      r0,[pc,#440] ; [0x80fb64] = 0x207f5c
        0x0080f9ac:    460a        .F      MOV      r2,r1
        0x0080f9ae:    4619        .F      MOV      r1,r3
        0x0080f9b0:    1fc0        ..      SUBS     r0,r0,#7
;;;526            break;
        0x0080f9b2:    e7be        ..      B        0x80f932 ; dis_set_parameter + 74
    dis_attr_read_cb
;;;527    #endif
;;;528        }
;;;529    
;;;530        if (!ret)
;;;531        {
;;;532            PROFILE_PRINT_ERROR0("DIS parameter set failed");
;;;533        }
;;;534    
;;;535        return ret;
;;;536    }
;;;537    
;;;538    /**
;;;539     * @brief Read characteristic data from service.
;;;540     *
;;;541     * @param[in]   conn_id  Connection id.
;;;542     * @param[in] service_id            ServiceID to be read.
;;;543     * @param[in] attrib_index          Attribute index of getting characteristic data.
;;;544     * @param[in] offset                offset of characteritic to be read.
;;;545     * @param[in,out] length_ptr            length of getting characteristic data.
;;;546     * @param[in,out] pp_value              pointer to pointer of characteristic value to be read.
;;;547     * @return T_APP_RESULT
;;;548    */
;;;549    T_APP_RESULT dis_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t attrib_index,
;;;550                                  uint16_t offset, uint16_t *length_ptr, uint8_t **pp_value)
;;;551    {
        0x0080f9b4:    e92d47fc    -..G    PUSH     {r2-r10,lr}
        0x0080f9b8:    4692        .F      MOV      r10,r2
        0x0080f9ba:    e9dd450a    ...E    LDRD     r4,r5,[sp,#0x28]
        0x0080f9be:    460a        .F      MOV      r2,r1
;;;552        T_DIS_CALLBACK_DATA callback_data;
;;;553        T_APP_RESULT  cause  = APP_RESULT_SUCCESS;
        0x0080f9c0:    2600        .&      MOVS     r6,#0
;;;554        *length_ptr = 0;
        0x0080f9c2:    8026        &.      STRH     r6,[r4,#0]
;;;555        callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0080f9c4:    2102        .!      MOVS     r1,#2
        0x0080f9c6:    f88d1004    ....    STRB     r1,[sp,#4]
;;;556        callback_data.conn_id = conn_id;
        0x0080f9ca:    f88d0005    ....    STRB     r0,[sp,#5]
;;;557    
;;;558        switch (attrib_index)
        0x0080f9ce:    f1aa0002    ....    SUB      r0,r10,#2
        0x0080f9d2:    2708        .'      MOVS     r7,#8
        0x0080f9d4:    f8df8180    ....    LDR      r8,[pc,#384] ; [0x80fb58] = 0x20814c
        0x0080f9d8:    f04f0907    O...    MOV      r9,#7
        0x0080f9dc:    2811        .(      CMP      r0,#0x11
        0x0080f9de:    d20a        ..      BCS      0x80f9f6 ; dis_attr_read_cb + 66
        0x0080f9e0:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x0080f9e4:    098c091e    ....    DCD    160172318
        0x0080f9e8:    0949092c    ,.I.    DCD    155781420
        0x0080f9ec:    0957093b    ;.W.    DCD    156698939
        0x0080f9f0:    09650913    ..e.    DCD    157616403
        0x0080f9f4:    0072        r.      DCW    114
    $t
;;;559        {
;;;560        default:
;;;561            PROFILE_PRINT_ERROR1("dis_attr_read_cb: attrib_index %d", attrib_index);
        0x0080f9f6:    4959        YI      LDR      r1,[pc,#356] ; [0x80fb5c] = 0x880063c
        0x0080f9f8:    4653        SF      MOV      r3,r10
        0x0080f9fa:    2201        ."      MOVS     r2,#1
        0x0080f9fc:    311c        .1      ADDS     r1,r1,#0x1c
        0x0080f9fe:    4858        XH      LDR      r0,[pc,#352] ; [0x80fb60] = 0x21103300
        0x0080fa00:    f7f8d82d    ..-.    BL       log_buffer ; 0x7a5e
;;;562            cause = APP_RESULT_ATTR_NOT_FOUND;
        0x0080fa04:    f240460a    @..F    MOV      r6,#0x40a
;;;563            break;
        0x0080fa08:    e06b        k.      B        0x80fae2 ; dis_attr_read_cb + 302
;;;564    
;;;565    #if DIS_CHAR_SYSTEM_ID_SUPPORT
;;;566        case GATT_SVC_DIS_SYSTEM_ID_INDEX:
;;;567            callback_data.msg_data.read_value_index = DIS_READ_SYSTEM_ID_INDEX;
        0x0080fa0a:    f88d9006    ....    STRB     r9,[sp,#6]
;;;568            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fa0e:    4610        .F      MOV      r0,r2
        0x0080fa10:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080fa14:    a901        ..      ADD      r1,sp,#4
        0x0080fa16:    4790        .G      BLX      r2
;;;569            *pp_value    = (uint8_t *)&dis_system_id;
        0x0080fa18:    4852        RH      LDR      r0,[pc,#328] ; [0x80fb64] = 0x207f5c
;;;570            *length_ptr = sizeof(dis_system_id);
        0x0080fa1a:    6028        (`      STR      r0,[r5,#0]
        0x0080fa1c:    8027        '.      STRH     r7,[r4,#0]
;;;571            break;
        0x0080fa1e:    e060        `.      B        0x80fae2 ; dis_attr_read_cb + 302
;;;572    #endif
;;;573    
;;;574    #if DIS_CHAR_MANUFACTURER_NAME_SUPPORT
;;;575        case GATT_SVC_DIS_MANU_NAME_INDEX:
;;;576            callback_data.msg_data.read_value_index = DIS_READ_MANU_NAME_INDEX;
        0x0080fa20:    2001        .       MOVS     r0,#1
        0x0080fa22:    f88d0006    ....    STRB     r0,[sp,#6]
;;;577            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fa26:    4610        .F      MOV      r0,r2
        0x0080fa28:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080fa2c:    a901        ..      ADD      r1,sp,#4
        0x0080fa2e:    4790        .G      BLX      r2
;;;578            *pp_value    = (uint8_t *)&dis_manufacturer_name;
        0x0080fa30:    4849        IH      LDR      r0,[pc,#292] ; [0x80fb58] = 0x20814c
        0x0080fa32:    300c        .0      ADDS     r0,r0,#0xc
;;;579            *length_ptr = dis_manufacturer_name_len;
        0x0080fa34:    6028        (`      STR      r0,[r5,#0]
        0x0080fa36:    f8980000    ....    LDRB     r0,[r8,#0]
;;;580            break;
        0x0080fa3a:    e00c        ..      B        0x80fa56 ; dis_attr_read_cb + 162
;;;581    #endif
;;;582    
;;;583    #if DIS_CHAR_SERIAL_NUMBER_SUPPORT
;;;584        case GATT_SVC_DIS_SERIAL_NUM_INDEX:
;;;585            callback_data.msg_data.read_value_index = DIS_READ_SERIAL_NUM_INDEX;
        0x0080fa3c:    2003        .       MOVS     r0,#3
        0x0080fa3e:    f88d0006    ....    STRB     r0,[sp,#6]
;;;586            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fa42:    4610        .F      MOV      r0,r2
        0x0080fa44:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080fa48:    a901        ..      ADD      r1,sp,#4
        0x0080fa4a:    4790        .G      BLX      r2
;;;587            *pp_value    = (uint8_t *)&dis_serial_number;
        0x0080fa4c:    4842        BH      LDR      r0,[pc,#264] ; [0x80fb58] = 0x20814c
        0x0080fa4e:    3034        40      ADDS     r0,r0,#0x34
;;;588            *length_ptr = dis_serial_number_len;
        0x0080fa50:    6028        (`      STR      r0,[r5,#0]
        0x0080fa52:    f8980002    ....    LDRB     r0,[r8,#2]
        0x0080fa56:    8020         .      STRH     r0,[r4,#0]
        0x0080fa58:    e043        C.      B        0x80fae2 ; dis_attr_read_cb + 302
;;;589            break;
;;;590    #endif
;;;591    
;;;592    #if DIS_CHAR_FIRMWARE_REVISION_SUPPORT
;;;593        case GATT_SVC_DIS_FIRMWARE_REV_INDEX:
;;;594            callback_data.msg_data.read_value_index = DIS_READ_FIRMWARE_REV_INDEX;
        0x0080fa5a:    2005        .       MOVS     r0,#5
        0x0080fa5c:    f88d0006    ....    STRB     r0,[sp,#6]
;;;595            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fa60:    4610        .F      MOV      r0,r2
        0x0080fa62:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080fa66:    a901        ..      ADD      r1,sp,#4
        0x0080fa68:    4790        .G      BLX      r2
;;;596            *pp_value    = (uint8_t *)&dis_firmware_rev;
        0x0080fa6a:    483b        ;H      LDR      r0,[pc,#236] ; [0x80fb58] = 0x20814c
        0x0080fa6c:    305c        \0      ADDS     r0,r0,#0x5c
;;;597            *length_ptr = dis_firmware_rev_len;
        0x0080fa6e:    6028        (`      STR      r0,[r5,#0]
        0x0080fa70:    f8980004    ....    LDRB     r0,[r8,#4]
;;;598            break;
        0x0080fa74:    e7ef        ..      B        0x80fa56 ; dis_attr_read_cb + 162
;;;599    #endif
;;;600    
;;;601    #if DIS_CHAR_HARDWARE_REVISION_SUPPORT
;;;602        case GATT_SVC_DIS_HARDWARE_REV_INDEX:
;;;603            callback_data.msg_data.read_value_index = DIS_READ_HARDWARE_REV_INDEX;
        0x0080fa76:    2004        .       MOVS     r0,#4
        0x0080fa78:    f88d0006    ....    STRB     r0,[sp,#6]
;;;604            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fa7c:    4610        .F      MOV      r0,r2
        0x0080fa7e:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080fa82:    a901        ..      ADD      r1,sp,#4
        0x0080fa84:    4790        .G      BLX      r2
;;;605            *pp_value    = (uint8_t *)&dis_hardware_rev;
        0x0080fa86:    4834        4H      LDR      r0,[pc,#208] ; [0x80fb58] = 0x20814c
        0x0080fa88:    3048        H0      ADDS     r0,r0,#0x48
;;;606            *length_ptr = dis_hardware_rev_len;
        0x0080fa8a:    6028        (`      STR      r0,[r5,#0]
        0x0080fa8c:    f8980003    ....    LDRB     r0,[r8,#3]
;;;607            break;
        0x0080fa90:    e7e1        ..      B        0x80fa56 ; dis_attr_read_cb + 162
;;;608    #endif
;;;609    
;;;610    #if DIS_CHAR_SOFTWARE_REVISION_SUPPORT
;;;611        case GATT_SVC_DIS_SOFTWARE_REV_INDEX:
;;;612            callback_data.msg_data.read_value_index = DIS_READ_SOFTWARE_REV_INDEX;
        0x0080fa92:    2006        .       MOVS     r0,#6
        0x0080fa94:    f88d0006    ....    STRB     r0,[sp,#6]
;;;613            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fa98:    4610        .F      MOV      r0,r2
        0x0080fa9a:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080fa9e:    a901        ..      ADD      r1,sp,#4
        0x0080faa0:    4790        .G      BLX      r2
;;;614            *pp_value    = (uint8_t *)&dis_software_rev;
        0x0080faa2:    482d        -H      LDR      r0,[pc,#180] ; [0x80fb58] = 0x20814c
        0x0080faa4:    3070        p0      ADDS     r0,r0,#0x70
;;;615            *length_ptr = dis_software_rev_len;
        0x0080faa6:    6028        (`      STR      r0,[r5,#0]
        0x0080faa8:    f8980005    ....    LDRB     r0,[r8,#5]
;;;616            break;
        0x0080faac:    e7d3        ..      B        0x80fa56 ; dis_attr_read_cb + 162
;;;617    #endif
;;;618    
;;;619    #if DIS_CHAR_IEEE_CERTIF_DATA_LIST_SUPPORT
;;;620        case GATT_SVC_DIS_IEEE_CERT_STR_INDEX:
;;;621            callback_data.msg_data.read_value_index = DIS_READ_IEEE_CERT_STR_INDEX;
        0x0080faae:    f88d7006    ...p    STRB     r7,[sp,#6]
;;;622            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fab2:    4610        .F      MOV      r0,r2
        0x0080fab4:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080fab8:    a901        ..      ADD      r1,sp,#4
        0x0080faba:    4790        .G      BLX      r2
;;;623            *pp_value    = (uint8_t *)&dis_ieee_data_list;
        0x0080fabc:    4829        )H      LDR      r0,[pc,#164] ; [0x80fb64] = 0x207f5c
        0x0080fabe:    3008        .0      ADDS     r0,r0,#8
;;;624            *length_ptr = dis_ieee_data_list_len;
        0x0080fac0:    6028        (`      STR      r0,[r5,#0]
        0x0080fac2:    3810        .8      SUBS     r0,r0,#0x10
        0x0080fac4:    7800        .x      LDRB     r0,[r0,#0]
;;;625            break;
        0x0080fac6:    e7c6        ..      B        0x80fa56 ; dis_attr_read_cb + 162
;;;626    #endif
;;;627    
;;;628    #if DIS_CHAR_PNP_ID_SUPPORT
;;;629        case GATT_SVC_DIS_PNP_ID_INDEX:
;;;630            callback_data.msg_data.read_value_index = DIS_READ_PNP_ID_INDEX;
        0x0080fac8:    2009        .       MOVS     r0,#9
        0x0080faca:    f88d0006    ....    STRB     r0,[sp,#6]
;;;631            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080face:    4610        .F      MOV      r0,r2
        0x0080fad0:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080fad4:    a901        ..      ADD      r1,sp,#4
        0x0080fad6:    4790        .G      BLX      r2
;;;632            *pp_value    = (uint8_t *)&dis_pnp_id;
        0x0080fad8:    4822        "H      LDR      r0,[pc,#136] ; [0x80fb64] = 0x207f5c
        0x0080fada:    1fc0        ..      SUBS     r0,r0,#7
;;;633            *length_ptr = sizeof(dis_pnp_id);
        0x0080fadc:    6028        (`      STR      r0,[r5,#0]
        0x0080fade:    f8a49000    ....    STRH     r9,[r4,#0]
        0x0080fae2:    8820         .      LDRH     r0,[r4,#0]
        0x0080fae4:    9000        ..      STR      r0,[sp,#0]
        0x0080fae6:    491d        .I      LDR      r1,[pc,#116] ; [0x80fb5c] = 0x880063c
        0x0080fae8:    481d        .H      LDR      r0,[pc,#116] ; [0x80fb60] = 0x21103300
        0x0080faea:    4653        SF      MOV      r3,r10
        0x0080faec:    2202        ."      MOVS     r2,#2
        0x0080faee:    3144        D1      ADDS     r1,r1,#0x44
        0x0080faf0:    1c80        ..      ADDS     r0,r0,#2
        0x0080faf2:    f7f7dfb4    ....    BL       log_buffer ; 0x7a5e
        0x0080faf6:    4630        0F      MOV      r0,r6
        0x0080faf8:    e8bd87fc    ....    POP      {r2-r10,pc}
;;;634            break;
;;;635    #endif
;;;636    
;;;637    #if DIS_CHAR_MODEL_NUMBER_SUPPORT
;;;638        case GATT_SVC_DIS_MODEL_NUM_INDEX:
;;;639            callback_data.msg_data.read_value_index = DIS_READ_MODEL_NUM_INDEX;
        0x0080fafc:    f88d1006    ....    STRB     r1,[sp,#6]
;;;640            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fb00:    4610        .F      MOV      r0,r2
        0x0080fb02:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080fb06:    a901        ..      ADD      r1,sp,#4
        0x0080fb08:    4790        .G      BLX      r2
;;;641            *pp_value    = (uint8_t *)&dis_model_number;
        0x0080fb0a:    4813        .H      LDR      r0,[pc,#76] ; [0x80fb58] = 0x20814c
        0x0080fb0c:    3020         0      ADDS     r0,r0,#0x20
;;;642            *length_ptr = dis_model_number_len;
        0x0080fb0e:    6028        (`      STR      r0,[r5,#0]
        0x0080fb10:    f8980001    ....    LDRB     r0,[r8,#1]
;;;643            break;
        0x0080fb14:    e79f        ..      B        0x80fa56 ; dis_attr_read_cb + 162
    dis_add_service
;;;644    #endif
;;;645    
;;;646        }
;;;647    
;;;648        PROFILE_PRINT_INFO2("dis_attr_read_cb: attrib_index %d, *length_ptr %d",
;;;649                            attrib_index,
;;;650                            *length_ptr);
;;;651        return (cause);
;;;652    }
;;;653    
;;;654    const T_FUN_GATT_SERVICE_CBS dis_cbs =
;;;655    {
;;;656        dis_attr_read_cb,  // Read callback function pointer
;;;657        NULL, // Write callback function pointer
;;;658        NULL  // Authorization callback function pointer
;;;659    };
;;;660    
;;;661    /**
;;;662      * @brief Add device information service to the BLE stack database.
;;;663      *
;;;664      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;665      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;666      * @retval 0xFF Operation failure.
;;;667      * @retval others Service id assigned by stack.
;;;668      *
;;;669      * <b>Example usage</b>
;;;670      * \code{.c}
;;;671        void profile_init()
;;;672        {
;;;673            server_init(1);
;;;674            dis_id = dis_add_service(app_handle_profile_message);
;;;675        }
;;;676      * \endcode
;;;677      */
;;;678    T_SERVER_ID dis_add_service(void *p_func)
;;;679    {
        0x0080fb16:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080fb18:    4604        .F      MOV      r4,r0
;;;680        T_SERVER_ID service_id;
;;;681        if (false == server_add_service(&service_id,
        0x0080fb1a:    4813        .H      LDR      r0,[pc,#76] ; [0x80fb68] = 0x8110f8
        0x0080fb1c:    e9d01206    ....    LDRD     r1,r2,[r0,#0x18]
        0x0080fb20:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0080fb24:    f5a07100    ...q    SUB      r1,r0,#0x200
        0x0080fb28:    6943        Ci      LDR      r3,[r0,#0x14]
        0x0080fb2a:    f44f7205    O..r    MOV      r2,#0x214
        0x0080fb2e:    a802        ..      ADD      r0,sp,#8
        0x0080fb30:    f43ff59d    ?...    BL       server_add_service ; 0x4f66e
        0x0080fb34:    b950        P.      CBNZ     r0,0x80fb4c ; dis_add_service + 54
;;;682                                        (uint8_t *)dis_attr_tbl,
;;;683                                        dis_attr_tbl_size,
;;;684                                        dis_cbs))
;;;685        {
;;;686            PROFILE_PRINT_ERROR1("dis_add_service: service_id %d", service_id);
        0x0080fb36:    4909        .I      LDR      r1,[pc,#36] ; [0x80fb5c] = 0x880063c
        0x0080fb38:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080fb3c:    2201        ."      MOVS     r2,#1
        0x0080fb3e:    317c        |1      ADDS     r1,r1,#0x7c
        0x0080fb40:    4807        .H      LDR      r0,[pc,#28] ; [0x80fb60] = 0x21103300
        0x0080fb42:    f7f7df8c    ....    BL       log_buffer ; 0x7a5e
;;;687            service_id = 0xff;
        0x0080fb46:    20ff        .       MOVS     r0,#0xff
        0x0080fb48:    f88d0008    ....    STRB     r0,[sp,#8]
;;;688        }
;;;689        pfn_dis_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x0080fb4c:    4802        .H      LDR      r0,[pc,#8] ; [0x80fb58] = 0x20814c
;;;690        return service_id;
        0x0080fb4e:    6084        .`      STR      r4,[r0,#8]
        0x0080fb50:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;691    }
        0x0080fb54:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080fb56:    0000        ..      DCW    0
        0x0080fb58:    0020814c    L. .    DCD    2130252
        0x0080fb5c:    0880063c    <...    DCD    142607932
        0x0080fb60:    21103300    .3.!    DCD    554709760
        0x0080fb64:    00207f5c    \. .    DCD    2129756
        0x0080fb68:    008110f8    ....    DCD    8458488
    $t
    .text
    app_le_gap_init
;;; .\..\source\cmsis\main.c
;;;151    {
        0x0080fb6c:    b500        ..      PUSH     {lr}
        0x0080fb6e:    b09d        ..      SUB      sp,sp,#0x74
;;;152        /* Device name and device appearance */
;;;153        uint8_t  device_name[GAP_DEVICE_NAME_LEN] = "REAL_PXP";
        0x0080fb70:    2228        ("      MOVS     r2,#0x28
        0x0080fb72:    49bb        .I      LDR      r1,[pc,#748] ; [0x80fe60] = 0x811118
        0x0080fb74:    4668        hF      MOV      r0,sp
        0x0080fb76:    f44af217    J...    BL       __aeabi_memcpy4 ; 0x59fa8
;;;154        uint16_t appearance = GAP_GATT_APPEARANCE_GENERIC_KEYRING;
        0x0080fb7a:    f44f7010    O..p    MOV      r0,#0x240
        0x0080fb7e:    f8ad006c    ..l.    STRH     r0,[sp,#0x6c]
;;;155        uint8_t  slave_init_mtu_req = false;
        0x0080fb82:    2000        .       MOVS     r0,#0
        0x0080fb84:    2107        .!      MOVS     r1,#7
        0x0080fb86:    f88d1034    ..4.    STRB     r1,[sp,#0x34]
        0x0080fb8a:    f44f71a0    O..q    MOV      r1,#0x140
        0x0080fb8e:    f88d0044    ..D.    STRB     r0,[sp,#0x44]
        0x0080fb92:    f8ad1048    ..H.    STRH     r1,[sp,#0x48]
        0x0080fb96:    f8ad1030    ..0.    STRH     r1,[sp,#0x30]
        0x0080fb9a:    2101        .!      MOVS     r1,#1
        0x0080fb9c:    f88d0040    ..@.    STRB     r0,[sp,#0x40]
        0x0080fba0:    f88d003c    ..<.    STRB     r0,[sp,#0x3c]
        0x0080fba4:    900b        ..      STR      r0,[sp,#0x2c]
;;;156    
;;;157        /* Advertising parameters */
;;;158        uint8_t  adv_evt_type = GAP_ADTYPE_ADV_IND;
;;;159        uint8_t  adv_direct_type = GAP_REMOTE_ADDR_LE_PUBLIC;
;;;160        uint8_t  adv_direct_addr[GAP_BD_ADDR_LEN] = {0};
        0x0080fba6:    900a        ..      STR      r0,[sp,#0x28]
;;;161        uint8_t  adv_chann_map = GAP_ADVCHAN_ALL;
;;;162        uint8_t  adv_filter_policy = GAP_ADV_FILTER_ANY;
        0x0080fba8:    f88d0038    ..8.    STRB     r0,[sp,#0x38]
        0x0080fbac:    2203        ."      MOVS     r2,#3
;;;163        uint16_t adv_int_min = DEFAULT_ADVERTISING_INTERVAL_MIN;
;;;164        uint16_t adv_int_max = DEFAULT_ADVERTISING_INTERVAL_MIN;
;;;165    
;;;166        /* GAP Bond Manager parameters */
;;;167        uint8_t  auth_pair_mode = GAP_PAIRING_MODE_PAIRABLE;
        0x0080fbae:    f88d104c    ..L.    STRB     r1,[sp,#0x4c]
;;;168        uint16_t auth_flags = GAP_AUTHEN_BIT_BONDING_FLAG;
        0x0080fbb2:    f8ad1050    ..P.    STRH     r1,[sp,#0x50]
;;;169        uint8_t  auth_io_cap = GAP_IO_CAP_NO_INPUT_NO_OUTPUT;
        0x0080fbb6:    f88d2054    ..T     STRB     r2,[sp,#0x54]
;;;170        uint8_t  auth_oob = false;
        0x0080fbba:    f88d0058    ..X.    STRB     r0,[sp,#0x58]
;;;171        uint8_t  auth_use_fix_passkey = false;
        0x0080fbbe:    f88d005c    ..\.    STRB     r0,[sp,#0x5c]
;;;172        uint32_t auth_fix_passkey = 0;
;;;173    
;;;174        uint8_t  auth_sec_req_enable = false;
        0x0080fbc2:    9018        ..      STR      r0,[sp,#0x60]
        0x0080fbc4:    f88d0064    ..d.    STRB     r0,[sp,#0x64]
;;;175    
;;;176        uint16_t auth_sec_req_flags = GAP_AUTHEN_BIT_BONDING_FLAG;
        0x0080fbc8:    f8ad1068    ..h.    STRH     r1,[sp,#0x68]
;;;177    
;;;178        /* Set device name and device appearance */
;;;179        le_set_gap_param(GAP_PARAM_DEVICE_NAME, GAP_DEVICE_NAME_LEN, device_name);
        0x0080fbcc:    466a        jF      MOV      r2,sp
        0x0080fbce:    2128        (!      MOVS     r1,#0x28
        0x0080fbd0:    f2402022    @."     MOV      r0,#0x222
        0x0080fbd4:    f43df038    =.8.    BL       le_set_gap_param ; 0x4cc48
;;;180        le_set_gap_param(GAP_PARAM_APPEARANCE, sizeof(appearance), &appearance);
        0x0080fbd8:    aa1b        ..      ADD      r2,sp,#0x6c
        0x0080fbda:    2102        .!      MOVS     r1,#2
        0x0080fbdc:    f2402021    @.!     MOV      r0,#0x221
        0x0080fbe0:    f43df032    =.2.    BL       le_set_gap_param ; 0x4cc48
;;;181        le_set_gap_param(GAP_PARAM_SLAVE_INIT_GATT_MTU_REQ, sizeof(slave_init_mtu_req),
        0x0080fbe4:    aa0f        ..      ADD      r2,sp,#0x3c
        0x0080fbe6:    2101        .!      MOVS     r1,#1
        0x0080fbe8:    f2402023    @.#     MOV      r0,#0x223
        0x0080fbec:    f43df02c    =.,.    BL       le_set_gap_param ; 0x4cc48
;;;182                         &slave_init_mtu_req);
;;;183    
;;;184        /* Set advertising parameters */
;;;185        le_adv_set_param(GAP_PARAM_ADV_EVENT_TYPE, sizeof(adv_evt_type), &adv_evt_type);
        0x0080fbf0:    aa10        ..      ADD      r2,sp,#0x40
        0x0080fbf2:    2101        .!      MOVS     r1,#1
        0x0080fbf4:    f2402063    @.c     MOV      r0,#0x263
        0x0080fbf8:    f442f14a    B.J.    BL       le_adv_set_param ; 0x51e90
;;;186        le_adv_set_param(GAP_PARAM_ADV_DIRECT_ADDR_TYPE, sizeof(adv_direct_type), &adv_direct_type);
        0x0080fbfc:    aa11        ..      ADD      r2,sp,#0x44
        0x0080fbfe:    2101        .!      MOVS     r1,#1
        0x0080fc00:    f44f7019    O..p    MOV      r0,#0x264
        0x0080fc04:    f442f144    B.D.    BL       le_adv_set_param ; 0x51e90
;;;187        le_adv_set_param(GAP_PARAM_ADV_DIRECT_ADDR, sizeof(adv_direct_addr), adv_direct_addr);
        0x0080fc08:    aa0a        ..      ADD      r2,sp,#0x28
        0x0080fc0a:    2106        .!      MOVS     r1,#6
        0x0080fc0c:    f2402065    @.e     MOV      r0,#0x265
        0x0080fc10:    f442f13e    B.>.    BL       le_adv_set_param ; 0x51e90
;;;188        le_adv_set_param(GAP_PARAM_ADV_CHANNEL_MAP, sizeof(adv_chann_map), &adv_chann_map);
        0x0080fc14:    aa0d        ..      ADD      r2,sp,#0x34
        0x0080fc16:    2101        .!      MOVS     r1,#1
        0x0080fc18:    f2402066    @.f     MOV      r0,#0x266
        0x0080fc1c:    f442f138    B.8.    BL       le_adv_set_param ; 0x51e90
;;;189        le_adv_set_param(GAP_PARAM_ADV_FILTER_POLICY, sizeof(adv_filter_policy), &adv_filter_policy);
        0x0080fc20:    aa0e        ..      ADD      r2,sp,#0x38
        0x0080fc22:    2101        .!      MOVS     r1,#1
        0x0080fc24:    f2402067    @.g     MOV      r0,#0x267
        0x0080fc28:    f442f132    B.2.    BL       le_adv_set_param ; 0x51e90
;;;190        le_adv_set_param(GAP_PARAM_ADV_INTERVAL_MIN, sizeof(adv_int_min), &adv_int_min);
        0x0080fc2c:    aa12        ..      ADD      r2,sp,#0x48
        0x0080fc2e:    2102        .!      MOVS     r1,#2
        0x0080fc30:    f44f701a    O..p    MOV      r0,#0x268
        0x0080fc34:    f442f12c    B.,.    BL       le_adv_set_param ; 0x51e90
;;;191        le_adv_set_param(GAP_PARAM_ADV_INTERVAL_MAX, sizeof(adv_int_max), &adv_int_max);
        0x0080fc38:    aa0c        ..      ADD      r2,sp,#0x30
        0x0080fc3a:    2102        .!      MOVS     r1,#2
        0x0080fc3c:    f2402069    @.i     MOV      r0,#0x269
        0x0080fc40:    f442f126    B.&.    BL       le_adv_set_param ; 0x51e90
;;;192        le_adv_set_param(GAP_PARAM_ADV_DATA, sizeof(adv_data), (void *)adv_data);
        0x0080fc44:    4a87        .J      LDR      r2,[pc,#540] ; [0x80fe64] = 0x207f91
        0x0080fc46:    2115        .!      MOVS     r1,#0x15
        0x0080fc48:    f2402061    @.a     MOV      r0,#0x261
        0x0080fc4c:    f442f120    B. .    BL       le_adv_set_param ; 0x51e90
;;;193        le_adv_set_param(GAP_PARAM_SCAN_RSP_DATA, sizeof(scan_rsp_data), (void *)scan_rsp_data);
        0x0080fc50:    4a84        .J      LDR      r2,[pc,#528] ; [0x80fe64] = 0x207f91
        0x0080fc52:    210e        .!      MOVS     r1,#0xe
        0x0080fc54:    3a0e        .:      SUBS     r2,r2,#0xe
        0x0080fc56:    f2402062    @.b     MOV      r0,#0x262
        0x0080fc5a:    f442f119    B...    BL       le_adv_set_param ; 0x51e90
;;;194    
;;;195        /* Setup the GAP Bond Manager */
;;;196        gap_set_param(GAP_PARAM_BOND_PAIRING_MODE, sizeof(auth_pair_mode), &auth_pair_mode);
        0x0080fc5e:    aa13        ..      ADD      r2,sp,#0x4c
        0x0080fc60:    2101        .!      MOVS     r1,#1
        0x0080fc62:    f2402002    @..     MOV      r0,#0x202
        0x0080fc66:    f43cf1a0    <...    BL       gap_set_param ; 0x4bfaa
;;;197        gap_set_param(GAP_PARAM_BOND_AUTHEN_REQUIREMENTS_FLAGS, sizeof(auth_flags), &auth_flags);
        0x0080fc6a:    aa14        ..      ADD      r2,sp,#0x50
        0x0080fc6c:    2102        .!      MOVS     r1,#2
        0x0080fc6e:    f2402003    @..     MOV      r0,#0x203
        0x0080fc72:    f43cf19a    <...    BL       gap_set_param ; 0x4bfaa
;;;198        gap_set_param(GAP_PARAM_BOND_IO_CAPABILITIES, sizeof(auth_io_cap), &auth_io_cap);
        0x0080fc76:    aa15        ..      ADD      r2,sp,#0x54
        0x0080fc78:    2101        .!      MOVS     r1,#1
        0x0080fc7a:    f44f7001    O..p    MOV      r0,#0x204
        0x0080fc7e:    f43cf194    <...    BL       gap_set_param ; 0x4bfaa
;;;199        gap_set_param(GAP_PARAM_BOND_OOB_ENABLED, sizeof(auth_oob), &auth_oob);
        0x0080fc82:    aa16        ..      ADD      r2,sp,#0x58
        0x0080fc84:    2101        .!      MOVS     r1,#1
        0x0080fc86:    f2402005    @..     MOV      r0,#0x205
        0x0080fc8a:    f43cf18e    <...    BL       gap_set_param ; 0x4bfaa
;;;200        le_bond_set_param(GAP_PARAM_BOND_FIXED_PASSKEY, sizeof(auth_fix_passkey), &auth_fix_passkey);
        0x0080fc8e:    aa18        ..      ADD      r2,sp,#0x60
        0x0080fc90:    2104        .!      MOVS     r1,#4
        0x0080fc92:    f2402011    @..     MOV      r0,#0x211
        0x0080fc96:    f43cf2aa    <...    BL       le_bond_set_param ; 0x4c1ee
;;;201        le_bond_set_param(GAP_PARAM_BOND_FIXED_PASSKEY_ENABLE, sizeof(auth_use_fix_passkey),
        0x0080fc9a:    aa17        ..      ADD      r2,sp,#0x5c
        0x0080fc9c:    2101        .!      MOVS     r1,#1
        0x0080fc9e:    f2402012    @..     MOV      r0,#0x212
        0x0080fca2:    f43cf2a4    <...    BL       le_bond_set_param ; 0x4c1ee
;;;202                          &auth_use_fix_passkey);
;;;203        le_bond_set_param(GAP_PARAM_BOND_SEC_REQ_ENABLE, sizeof(auth_sec_req_enable), &auth_sec_req_enable);
        0x0080fca6:    aa19        ..      ADD      r2,sp,#0x64
        0x0080fca8:    2101        .!      MOVS     r1,#1
        0x0080fcaa:    f2402013    @..     MOV      r0,#0x213
        0x0080fcae:    f43cf29e    <...    BL       le_bond_set_param ; 0x4c1ee
;;;204        le_bond_set_param(GAP_PARAM_BOND_SEC_REQ_REQUIREMENT, sizeof(auth_sec_req_flags),
        0x0080fcb2:    aa1a        ..      ADD      r2,sp,#0x68
        0x0080fcb4:    2102        .!      MOVS     r1,#2
        0x0080fcb6:    f44f7005    O..p    MOV      r0,#0x214
        0x0080fcba:    f43cf298    <...    BL       le_bond_set_param ; 0x4c1ee
;;;205                          &auth_sec_req_flags);
;;;206    
;;;207        /* register gap message callback */
;;;208        le_register_app_cb(app_gap_callback);
        0x0080fcbe:    486a        jH      LDR      r0,[pc,#424] ; [0x80fe68] = 0x810317
        0x0080fcc0:    f43cf7bf    <...    BL       le_register_app_cb ; 0x4cc42
;;;209    }
        0x0080fcc4:    b01d        ..      ADD      sp,sp,#0x74
        0x0080fcc6:    bd00        ..      POP      {pc}
    app_le_profile_init
;;;210    
;;;211    /**
;;;212     * @brief  Add GATT services, clients and register callbacks
;;;213     * @return void
;;;214     */
;;;215    void app_le_profile_init(void)
;;;216    {
        0x0080fcc8:    b510        ..      PUSH     {r4,lr}
;;;217        server_init(6);
        0x0080fcca:    2006        .       MOVS     r0,#6
        0x0080fccc:    f43ff41a    ?...    BL       server_init ; 0x4f504
;;;218        //simp_srv_id = simp_ble_service_add_service(app_profile_callback);
;;;219        ias_srv_id  = ias_add_service(app_profile_callback);
        0x0080fcd0:    4866        fH      LDR      r0,[pc,#408] ; [0x80fe6c] = 0x810365
        0x0080fcd2:    f7fffb76    ..v.    BL       ias_add_service ; 0x80f3c2
        0x0080fcd6:    4966        fI      LDR      r1,[pc,#408] ; [0x80fe70] = 0x2081d5
        0x0080fcd8:    7008        .p      STRB     r0,[r1,#0]
;;;220        lls_srv_id  = lls_add_service(app_profile_callback);
        0x0080fcda:    4864        dH      LDR      r0,[pc,#400] ; [0x80fe6c] = 0x810365
        0x0080fcdc:    f7fffc04    ....    BL       lls_add_service ; 0x80f4e8
        0x0080fce0:    4964        dI      LDR      r1,[pc,#400] ; [0x80fe74] = 0x2081d6
        0x0080fce2:    7008        .p      STRB     r0,[r1,#0]
;;;221        tps_srv_id  = tps_add_service(app_profile_callback);
        0x0080fce4:    4861        aH      LDR      r0,[pc,#388] ; [0x80fe6c] = 0x810365
        0x0080fce6:    f7fffc65    ..e.    BL       tps_add_service ; 0x80f5b4
        0x0080fcea:    4963        cI      LDR      r1,[pc,#396] ; [0x80fe78] = 0x2081d7
        0x0080fcec:    7008        .p      STRB     r0,[r1,#0]
;;;222        kns_srv_id  = kns_add_service(app_profile_callback);
        0x0080fcee:    485f        _H      LDR      r0,[pc,#380] ; [0x80fe6c] = 0x810365
        0x0080fcf0:    f7fffdd0    ....    BL       kns_add_service ; 0x80f894
        0x0080fcf4:    4961        aI      LDR      r1,[pc,#388] ; [0x80fe7c] = 0x2081d8
        0x0080fcf6:    7008        .p      STRB     r0,[r1,#0]
;;;223        bas_srv_id  = bas_add_service(app_profile_callback);
        0x0080fcf8:    485c        \H      LDR      r0,[pc,#368] ; [0x80fe6c] = 0x810365
        0x0080fcfa:    f7fffd11    ....    BL       bas_add_service ; 0x80f720
        0x0080fcfe:    4960        `I      LDR      r1,[pc,#384] ; [0x80fe80] = 0x2081d9
        0x0080fd00:    7008        .p      STRB     r0,[r1,#0]
;;;224        dis_srv_id  = dis_add_service(app_profile_callback);
        0x0080fd02:    485a        ZH      LDR      r0,[pc,#360] ; [0x80fe6c] = 0x810365
        0x0080fd04:    f7ffff07    ....    BL       dis_add_service ; 0x80fb16
        0x0080fd08:    495e        ^I      LDR      r1,[pc,#376] ; [0x80fe84] = 0x2081da
        0x0080fd0a:    7008        .p      STRB     r0,[r1,#0]
;;;225        server_register_app_cb(app_profile_callback);
        0x0080fd0c:    e8bd4010    ...@    POP      {r4,lr}
        0x0080fd10:    4856        VH      LDR      r0,[pc,#344] ; [0x80fe6c] = 0x810365
        0x0080fd12:    f43fb410    ?...    B        server_register_app_cb ; 0x4f536
    board_init
;;;226    
;;;227    }
;;;228    
;;;229    
;;;230    /**
;;;231     * @brief    Contains the initialization of pinmux settings and pad settings
;;;232     * @note     All the pinmux settings and pad settings shall be initiated in this function,
;;;233     *           but if legacy driver is used, the initialization of pinmux setting and pad setting
;;;234     *           should be peformed with the IO initializing.
;;;235     * @return   void
;;;236     */
;;;237    void board_init(void)
;;;238    {
        0x0080fd16:    b510        ..      PUSH     {r4,lr}
;;;239        RCC_Configuration();
        0x0080fd18:    f7fefe63    ..c.    BL       RCC_Configuration ; 0x80e9e2
;;;240        PINMUX_Configuration();
        0x0080fd1c:    f7fefe36    ..6.    BL       PINMUX_Configuration ; 0x80e98c
;;;241        PAD_Configuration();
        0x0080fd20:    e8bd4010    ...@    POP      {r4,lr}
        0x0080fd24:    f7febe41    ..A.    B        PAD_Configuration ; 0x80e9aa
    System_Handler
;;;242    }
;;;243    /**
;;;244     * @brief    System_Handler
;;;245     * @note     system handle to judge which pin is wake source
;;;246     * @return   void
;;;247     */
;;;248    void System_Handler(void)
;;;249    {
        0x0080fd28:    b570        p.      PUSH     {r4-r6,lr}
;;;250        uint8_t tmpVal;
;;;251    
;;;252        APP_PRINT_INFO0("System_Handler");
        0x0080fd2a:    2200        ."      MOVS     r2,#0
        0x0080fd2c:    4956        VI      LDR      r1,[pc,#344] ; [0x80fe88] = 0x88006dc
        0x0080fd2e:    4857        WH      LDR      r0,[pc,#348] ; [0x80fe8c] = 0x21103002
        0x0080fd30:    f7f7de95    ....    BL       log_buffer ; 0x7a5e
;;; ..\include\SDK\platform\cmsis\core_cm4.h
;;;1659       NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
        0x0080fd34:    f04f25e0    O..%    MOV      r5,#0xe000e000
        0x0080fd38:    2401        .$      MOVS     r4,#1
        0x0080fd3a:    f8c54180    ...A    STR      r4,[r5,#0x180]
        0x0080fd3e:    f50575c0    ...u    ADD      r5,r5,#0x180
;;; .\..\source\cmsis\main.c
;;;255        KEY_INT_Handle();//P2_4  edge triggle , can't interrupt after dlps
        0x0080fd42:    f7fefea5    ....    BL       GPIO20_Handler ; 0x80ea90
;;;256    
;;;257        // need clear debounce bit here.
;;;258        tmpVal = btaon_fast_read_safe(0x2b);
        0x0080fd46:    202b        +       MOVS     r0,#0x2b
        0x0080fd48:    f42ff05c    /.\.    BL       btaon_fast_read_safe ; 0x3ee04
;;;259        btaon_fast_write_safe(0x2b, (tmpVal | BIT7));
        0x0080fd4c:    f0400180    @...    ORR      r1,r0,#0x80
        0x0080fd50:    202b        +       MOVS     r0,#0x2b
        0x0080fd52:    f42ff078    /.x.    BL       btaon_fast_write_safe ; 0x3ee46
;;; ..\include\SDK\platform\cmsis\core_cm4.h
;;;1700       NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) &
        0x0080fd56:    f8c54100    ...A    STR      r4,[r5,#0x100]
;;; .\..\source\cmsis\main.c
;;;271    }
        0x0080fd5a:    bd70        p.      POP      {r4-r6,pc}
    PxpEnterDlpsSet
;;;272    /**
;;;273     * @brief    PxpEnterDlpsSet
;;;274     * @note     enter dlps to set pad&wake up pin
;;;275     * @return   void
;;;276     */
;;;277    void PxpEnterDlpsSet(void)
;;;278    {
        0x0080fd5c:    b57c        |.      PUSH     {r2-r6,lr}
;;;279        Pad_Config(KEY, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0080fd5e:    2400        .$      MOVS     r4,#0
        0x0080fd60:    2301        .#      MOVS     r3,#1
        0x0080fd62:    9400        ..      STR      r4,[sp,#0]
        0x0080fd64:    461a        .F      MOV      r2,r3
        0x0080fd66:    4621        !F      MOV      r1,r4
        0x0080fd68:    2014        .       MOVS     r0,#0x14
        0x0080fd6a:    9401        ..      STR      r4,[sp,#4]
        0x0080fd6c:    f401f336    ..6.    BL       Pad_Config ; 0x113dc
;;;280        Pad_Config(LED, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0080fd70:    2501        .%      MOVS     r5,#1
        0x0080fd72:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0080fd76:    2300        .#      MOVS     r3,#0
        0x0080fd78:    462a        *F      MOV      r2,r5
        0x0080fd7a:    4619        .F      MOV      r1,r3
        0x0080fd7c:    4628        (F      MOV      r0,r5
        0x0080fd7e:    f401f32d    ..-.    BL       Pad_Config ; 0x113dc
;;;281        Pad_Config(BEEP, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0080fd82:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0080fd86:    2300        .#      MOVS     r3,#0
        0x0080fd88:    2201        ."      MOVS     r2,#1
        0x0080fd8a:    4619        .F      MOV      r1,r3
        0x0080fd8c:    2002        .       MOVS     r0,#2
        0x0080fd8e:    f401f325    ..%.    BL       Pad_Config ; 0x113dc
;;;282        System_WakeUpDebounceTime(0x8);
        0x0080fd92:    2008        .       MOVS     r0,#8
        0x0080fd94:    f401f369    ..i.    BL       System_WakeUpDebounceTime ; 0x1146a
;;;283        if (keystatus)
        0x0080fd98:    483d        =H      LDR      r0,[pc,#244] ; [0x80fe90] = 0x20803a
        0x0080fd9a:    f04f0201    O...    MOV      r2,#1
        0x0080fd9e:    7800        .x      LDRB     r0,[r0,#0]
        0x0080fda0:    b108        ..      CBZ      r0,0x80fda6 ; PxpEnterDlpsSet + 74
;;;284        {
;;;285            System_WakeUpPinEnable(KEY, PAD_WAKEUP_POL_LOW, PAD_WK_DEBOUNCE_ENABLE);
        0x0080fda2:    2101        .!      MOVS     r1,#1
        0x0080fda4:    e000        ..      B        0x80fda8 ; PxpEnterDlpsSet + 76
;;;286        }
;;;287        else
;;;288        {
;;;289            System_WakeUpPinEnable(KEY, PAD_WAKEUP_POL_HIGH, PAD_WK_DEBOUNCE_ENABLE);
        0x0080fda6:    2100        .!      MOVS     r1,#0
        0x0080fda8:    b002        ..      ADD      sp,sp,#8
        0x0080fdaa:    2014        .       MOVS     r0,#0x14
        0x0080fdac:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0080fdb0:    f401b3a5    ....    B        System_WakeUpPinEnable ; 0x114fe
    PxpExitDlpsInit
;;;290        }
;;;291    
;;;292    #if (AON_WDG_ENABLE == 1)
;;;293        aon_wdg_enable();
;;;294    #endif
;;;295    }
;;;296    /**
;;;297     * @brief    PxpExitDlpsInit
;;;298     * @note     Exit dlps to configure pad
;;;299     * @return   void
;;;300     */
;;;301    void PxpExitDlpsInit(void)
;;;302    {
        0x0080fdb4:    b57c        |.      PUSH     {r2-r6,lr}
;;;303        Pad_Config(LED, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0080fdb6:    2501        .%      MOVS     r5,#1
        0x0080fdb8:    2400        .$      MOVS     r4,#0
        0x0080fdba:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0080fdbe:    4623        #F      MOV      r3,r4
        0x0080fdc0:    462a        *F      MOV      r2,r5
        0x0080fdc2:    4629        )F      MOV      r1,r5
        0x0080fdc4:    4628        (F      MOV      r0,r5
        0x0080fdc6:    f401f309    ....    BL       Pad_Config ; 0x113dc
;;;304        Pad_Config(BEEP, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0080fdca:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0080fdce:    2201        ."      MOVS     r2,#1
        0x0080fdd0:    2300        .#      MOVS     r3,#0
        0x0080fdd2:    4611        .F      MOV      r1,r2
        0x0080fdd4:    2002        .       MOVS     r0,#2
        0x0080fdd6:    f401f301    ....    BL       Pad_Config ; 0x113dc
;;;305        Pad_Config(KEY, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0080fdda:    2301        .#      MOVS     r3,#1
        0x0080fddc:    9400        ..      STR      r4,[sp,#0]
        0x0080fdde:    461a        .F      MOV      r2,r3
        0x0080fde0:    4619        .F      MOV      r1,r3
        0x0080fde2:    2014        .       MOVS     r0,#0x14
        0x0080fde4:    9401        ..      STR      r4,[sp,#4]
        0x0080fde6:    f401f2f9    ....    BL       Pad_Config ; 0x113dc
;;;306    
;;;307    #if (AON_WDG_ENABLE == 1)
;;;308        aon_wdg_disable();
;;;309    #endif
;;;310    }
        0x0080fdea:    bd7c        |.      POP      {r2-r6,pc}
    DLPS_PxpCheck
;;;311    /**
;;;312     * @brief    DLPS_PxpCheck
;;;313     * @note     check app enter dlps flg.
;;;314     * @return   bool
;;;315     */
;;;316    bool DLPS_PxpCheck(void)
;;;317    {
;;;318        return allowedPxpEnterDlps;
        0x0080fdec:    481d        .H      LDR      r0,[pc,#116] ; [0x80fe64] = 0x207f91
        0x0080fdee:    380f        .8      SUBS     r0,r0,#0xf
        0x0080fdf0:    7800        .x      LDRB     r0,[r0,#0]
;;;319    }
        0x0080fdf2:    4770        pG      BX       lr
    pwr_mgr_init
;;;320    
;;;321    /**
;;;322     * @brief    Contains the power mode settings
;;;323     * @return   void
;;;324     */
;;;325    void pwr_mgr_init(void)
;;;326    {
        0x0080fdf4:    b510        ..      PUSH     {r4,lr}
;;;327    #if DLPS_EN
;;;328        if (false == dlps_check_cb_reg(DLPS_PxpCheck))
        0x0080fdf6:    f2af000b    ....    ADR      r0,{pc}-9 ; 0x80fded
        0x0080fdfa:    f7f8dc00    ....    BL       dlps_check_cb_reg ; 0x85fe
        0x0080fdfe:    b920         .      CBNZ     r0,0x80fe0a ; pwr_mgr_init + 22
;;;329        {
;;;330            DBG_DIRECT("Error: dlps_check_cb_reg(DLPS_RcuCheck) failed!\n");
        0x0080fe00:    a124        $.      ADR      r1,{pc}+0x94 ; 0x80fe94
        0x0080fe02:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0080fe06:    f7f7ddd3    ....    BL       log_direct ; 0x79b0
;;;331        }
;;;332        DLPS_IORegUserDlpsEnterCb(PxpEnterDlpsSet);
        0x0080fe0a:    f2af00af    ....    ADR      r0,{pc}-0xad ; 0x80fd5d
;;; ..\include\SDK\peripheral\rtl876x_io_dlps.h
;;;88         User_IO_EnterDlpsCB = func;
        0x0080fe0e:    492e        .I      LDR      r1,[pc,#184] ; [0x80fec8] = 0x208058
;;; .\..\source\cmsis\main.c
;;;333        DLPS_IORegUserDlpsExitCb(PxpExitDlpsInit);
        0x0080fe10:    6008        .`      STR      r0,[r1,#0]
        0x0080fe12:    f2af005f    .._.    ADR      r0,{pc}-0x5d ; 0x80fdb5
;;; ..\include\SDK\peripheral\rtl876x_io_dlps.h
;;;72         User_IO_ExitDlpsCB = func;
        0x0080fe16:    492d        -I      LDR      r1,[pc,#180] ; [0x80fecc] = 0x208054
;;; .\..\source\cmsis\main.c
;;;334        DLPS_IORegister();
        0x0080fe18:    6008        .`      STR      r0,[r1,#0]
        0x0080fe1a:    f7fff829    ..).    BL       DLPS_IORegister ; 0x80ee70
;;;335        lps_mode_set(LPM_DLPS_MODE);
        0x0080fe1e:    e8bd4010    ...@    POP      {r4,lr}
        0x0080fe22:    2002        .       MOVS     r0,#2
        0x0080fe24:    f7f89d1b    ....    B        lps_mode_set ; 0x885e
    task_init
;;;336    #endif
;;;337    }
;;;338    
;;;339    /**
;;;340     * @brief    Contains the initialization of all tasks
;;;341     * @note     There is only one task in BLE Scatternet APP, thus only one APP task is init here
;;;342     * @return   void
;;;343     */
;;;344    void task_init(void)
;;;345    {
;;;346        app_task_init();
        0x0080fe28:    f7febd98    ....    B        app_task_init ; 0x80e95c
    main
;;;347    }
;;;348    
;;;349    /**
;;;350     * @brief    Entry of APP code
;;;351     * @return   int (To avoid compile warning)
;;;352     */
;;;353    int main(void)
;;;354    {
;;;355        extern uint32_t random_seed_value;
;;;356        srand(random_seed_value);
        0x0080fe2c:    4828        (H      LDR      r0,[pc,#160] ; [0x80fed0] = 0x208028
;;; .\..\source\cmsis\main.c (354)
        0x0080fe2e:    b510        ..      PUSH     {r4,lr}
;;;355        extern uint32_t random_seed_value;
;;;356        srand(random_seed_value);
        0x0080fe30:    6800        .h      LDR      r0,[r0,#0]
        0x0080fe32:    f000fe63    ..c.    BL       srand ; 0x810afc
;;;357        board_init();
        0x0080fe36:    f7ffff6e    ..n.    BL       board_init ; 0x80fd16
;;;358    
;;;359        le_gap_init(APP_MAX_LINKS);
        0x0080fe3a:    2001        .       MOVS     r0,#1
        0x0080fe3c:    f43cf6be    <...    BL       le_gap_init ; 0x4cbbc
;;;360        gap_lib_init();
        0x0080fe40:    f000fca2    ....    BL       gap_lib_init ; 0x810788
;;;361        app_le_gap_init();
        0x0080fe44:    f7fffe92    ....    BL       app_le_gap_init ; 0x80fb6c
;;;362        app_le_profile_init();
        0x0080fe48:    f7ffff3e    ..>.    BL       app_le_profile_init ; 0x80fcc8
;;;363        pwr_mgr_init();
        0x0080fe4c:    f7ffffd2    ....    BL       pwr_mgr_init ; 0x80fdf4
;;;364        swTimerInit();
        0x0080fe50:    f7feff8b    ....    BL       swTimerInit ; 0x80ed6a
        0x0080fe54:    f7fefd82    ....    BL       app_task_init ; 0x80e95c
;;;365        task_init();
;;;366        os_sched_start();
        0x0080fe58:    f416f4b3    ....    BL       os_sched_start ; 0x267c2
;;;367    
;;;368        return 0;
        0x0080fe5c:    2000        .       MOVS     r0,#0
;;;369    }
        0x0080fe5e:    bd10        ..      POP      {r4,pc}
    $d
        0x0080fe60:    00811118    ....    DCD    8458520
        0x0080fe64:    00207f91    .. .    DCD    2129809
        0x0080fe68:    00810317    ....    DCD    8454935
        0x0080fe6c:    00810365    e...    DCD    8455013
        0x0080fe70:    002081d5    .. .    DCD    2130389
        0x0080fe74:    002081d6    .. .    DCD    2130390
        0x0080fe78:    002081d7    .. .    DCD    2130391
        0x0080fe7c:    002081d8    .. .    DCD    2130392
        0x0080fe80:    002081d9    .. .    DCD    2130393
        0x0080fe84:    002081da    .. .    DCD    2130394
        0x0080fe88:    088006dc    ....    DCD    142608092
        0x0080fe8c:    21103002    .0.!    DCD    554708994
        0x0080fe90:    0020803a    :. .    DCD    2129978
        0x0080fe94:    6f727245    Erro    DCD    1869771333
        0x0080fe98:    64203a72    r: d    DCD    1679833714
        0x0080fe9c:    5f73706c    lps_    DCD    1601400940
        0x0080fea0:    63656863    chec    DCD    1667590243
        0x0080fea4:    62635f6b    k_cb    DCD    1650679659
        0x0080fea8:    6765725f    _reg    DCD    1734701663
        0x0080feac:    504c4428    (DLP    DCD    1347175464
        0x0080feb0:    63525f53    S_Rc    DCD    1666342739
        0x0080feb4:    65684375    uChe    DCD    1701331829
        0x0080feb8:    20296b63    ck)     DCD    539585379
        0x0080febc:    6c696166    fail    DCD    1818845542
        0x0080fec0:    0a216465    ed!.    DCD    169960549
        0x0080fec4:    00000000    ....    DCD    0
        0x0080fec8:    00208058    X. .    DCD    2130008
        0x0080fecc:    00208054    T. .    DCD    2130004
        0x0080fed0:    00208028    (. .    DCD    2129960
    $t
    .text
    app_handle_authen_state_evt
;;; .\..\source\app\pxp_app.c
;;;241    {
        0x0080fed4:    b5f8        ..      PUSH     {r3-r7,lr}
        0x0080fed6:    4efa        .N      LDR      r6,[pc,#1000] ; [0x8102c0] = 0x21103002
;;; .\..\source\app\pxp_app.c (241)
        0x0080fed8:    4615        .F      MOV      r5,r2
        0x0080feda:    460c        .F      MOV      r4,r1
;;;242        APP_PRINT_INFO2("app_handle_authen_state_evt:conn_id %d, cause 0x%x", conn_id, cause);
        0x0080fedc:    4603        .F      MOV      r3,r0
        0x0080fede:    9200        ..      STR      r2,[sp,#0]
        0x0080fee0:    2202        ."      MOVS     r2,#2
        0x0080fee2:    49f6        .I      LDR      r1,[pc,#984] ; [0x8102bc] = 0x88008fc
        0x0080fee4:    4630        0F      MOV      r0,r6
        0x0080fee6:    f7f7ddba    ....    BL       log_buffer ; 0x7a5e
;;;243    
;;;244        switch (new_state)
        0x0080feea:    b154        T.      CBZ      r4,0x80ff02 ; app_handle_authen_state_evt + 46
        0x0080feec:    2c01        .,      CMP      r4,#1
        0x0080feee:    d00c        ..      BEQ      0x80ff0a ; app_handle_authen_state_evt + 54
        0x0080fef0:    2201        ."      MOVS     r2,#1
        0x0080fef2:    b001        ..      ADD      sp,sp,#4
        0x0080fef4:    4623        #F      MOV      r3,r4
        0x0080fef6:    1eb0        ..      SUBS     r0,r6,#2
        0x0080fef8:    e8bd40f0    ...@    POP      {r4-r7,lr}
        0x0080fefc:    49f1        .I      LDR      r1,[pc,#964] ; [0x8102c4] = 0x8800a00
        0x0080fefe:    f7f79dae    ....    B        log_buffer ; 0x7a5e
;;;245        {
;;;246        case GAP_AUTHEN_STATE_STARTED:
;;;247            {
;;;248                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
        0x0080ff02:    49ee        .I      LDR      r1,[pc,#952] ; [0x8102bc] = 0x88008fc
        0x0080ff04:    2200        ."      MOVS     r2,#0
        0x0080ff06:    3138        81      ADDS     r1,r1,#0x38
;;;249            }
;;;250            break;
        0x0080ff08:    e003        ..      B        0x80ff12 ; app_handle_authen_state_evt + 62
;;;251    
;;;252        case GAP_AUTHEN_STATE_COMPLETE:
;;;253            {
;;;254                if (cause == GAP_SUCCESS)
        0x0080ff0a:    b13d        =.      CBZ      r5,0x80ff1c ; app_handle_authen_state_evt + 72
        0x0080ff0c:    49ed        .I      LDR      r1,[pc,#948] ; [0x8102c4] = 0x8800a00
        0x0080ff0e:    2200        ."      MOVS     r2,#0
        0x0080ff10:    3948        H9      SUBS     r1,r1,#0x48
        0x0080ff12:    4630        0F      MOV      r0,r6
        0x0080ff14:    e8bd40f8    ...@    POP      {r3-r7,lr}
        0x0080ff18:    f7f79da1    ....    B        log_buffer ; 0x7a5e
;;;255                {
;;;256                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, 1);
        0x0080ff1c:    2301        .#      MOVS     r3,#1
        0x0080ff1e:    2203        ."      MOVS     r2,#3
        0x0080ff20:    2164        d!      MOVS     r1,#0x64
        0x0080ff22:    f44f7061    O.ap    MOV      r0,#0x384
        0x0080ff26:    f7fefe10    ....    BL       StartPxpIO ; 0x80eb4a
;;;257    
;;;258                    ChangeConnectionParameter(400, 0, 2000); //interval = 400*1.25ms
        0x0080ff2a:    f44f62fa    O..b    MOV      r2,#0x7d0
        0x0080ff2e:    2100        .!      MOVS     r1,#0
        0x0080ff30:    f44f70c8    O..p    MOV      r0,#0x190
        0x0080ff34:    f7feff6c    ..l.    BL       ChangeConnectionParameter ; 0x80ee10
;;;259                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
        0x0080ff38:    49e0        .I      LDR      r1,[pc,#896] ; [0x8102bc] = 0x88008fc
        0x0080ff3a:    2200        ."      MOVS     r2,#0
        0x0080ff3c:    3174        t1      ADDS     r1,r1,#0x74
        0x0080ff3e:    e7e8        ..      B        0x80ff12 ; app_handle_authen_state_evt + 62
    app_handle_conn_param_update_evt
;;;260    
;;;261                }
;;;262                else
;;;263                {
;;;264                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;265                }
;;;266            }
;;;267            break;
;;;268    
;;;269        default:
;;;270            {
;;;271                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;272            }
;;;273            break;
;;;274        }
;;;275    }
;;;276    
;;;277    /**
;;;278     * @brief    Handle msg GAP_MSG_LE_CONN_MTU_INFO
;;;279     * @note     This msg is used to inform APP that exchange mtu procedure is completed.
;;;280     * @param[in] conn_id Connection ID
;;;281     * @param[in] mtu_size  New mtu size
;;;282     * @return   void
;;;283     */
;;;284    void app_handle_conn_mtu_info_evt(uint8_t conn_id, uint16_t mtu_size)
;;;285    {
;;;286        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
;;;287    }
;;;288    
;;;289    
;;;290    /**
;;;291     * @brief    Handle msg GAP_MSG_LE_CONN_PARAM_UPDATE
;;;292     * @note     All the connection parameter update change  events are pre-handled in this function.
;;;293     * @param[in] conn_id Connection ID
;;;294     * @param[in] status  New update state
;;;295     * @param[in] cause Use this cause when status is GAP_CONN_PARAM_UPDATE_STATUS_FAIL
;;;296     * @return   void
;;;297     */
;;;298    void app_handle_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;299    {
        0x0080ff40:    b530        0.      PUSH     {r4,r5,lr}
        0x0080ff42:    4cdf        .L      LDR      r4,[pc,#892] ; [0x8102c0] = 0x21103002
;;; .\..\source\app\pxp_app.c (299)
        0x0080ff44:    b085        ..      SUB      sp,sp,#0x14
        0x0080ff46:    4605        .F      MOV      r5,r0
        0x0080ff48:    b159        Y.      CBZ      r1,0x80ff62 ; app_handle_conn_param_update_evt + 34
;;;300        switch (status)
        0x0080ff4a:    2901        .)      CMP      r1,#1
        0x0080ff4c:    d02b        +.      BEQ      0x80ffa6 ; app_handle_conn_param_update_evt + 102
        0x0080ff4e:    2902        .)      CMP      r1,#2
        0x0080ff50:    d127        '.      BNE      0x80ffa2 ; app_handle_conn_param_update_evt + 98
        0x0080ff52:    b005        ..      ADD      sp,sp,#0x14
        0x0080ff54:    4620         F      MOV      r0,r4
        0x0080ff56:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x0080ff5a:    2200        ."      MOVS     r2,#0
        0x0080ff5c:    49da        .I      LDR      r1,[pc,#872] ; [0x8102c8] = 0x8800b30
        0x0080ff5e:    f7f79d7e    ..~.    B        log_buffer ; 0x7a5e
;;;301        {
;;;302        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;303            {
;;;304                uint16_t conn_interval;
;;;305                uint16_t conn_slave_latency;
;;;306                uint16_t conn_supervision_timeout;
;;;307    
;;;308                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
        0x0080ff62:    4602        .F      MOV      r2,r0
        0x0080ff64:    a904        ..      ADD      r1,sp,#0x10
        0x0080ff66:    f2402072    @.r     MOV      r0,#0x272
        0x0080ff6a:    f43df588    =...    BL       le_get_conn_param ; 0x4da7e
;;;309                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
        0x0080ff6e:    462a        *F      MOV      r2,r5
        0x0080ff70:    a903        ..      ADD      r1,sp,#0xc
        0x0080ff72:    f2402073    @.s     MOV      r0,#0x273
        0x0080ff76:    f43df582    =...    BL       le_get_conn_param ; 0x4da7e
;;;310                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
        0x0080ff7a:    462a        *F      MOV      r2,r5
        0x0080ff7c:    a902        ..      ADD      r1,sp,#8
        0x0080ff7e:    f44f701d    O..p    MOV      r0,#0x274
        0x0080ff82:    f43df57c    =.|.    BL       le_get_conn_param ; 0x4da7e
;;;311                APP_PRINT_INFO3("app_handle_conn_param_update_evt update success:conn_interval 0x%x, conn_slave_latency 0x%x, conn_supervision_timeout 0x%x",
        0x0080ff86:    f8bd1008    ....    LDRH     r1,[sp,#8]
        0x0080ff8a:    f8bd000c    ....    LDRH     r0,[sp,#0xc]
        0x0080ff8e:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0080ff92:    49cc        .I      LDR      r1,[pc,#816] ; [0x8102c4] = 0x8800a00
        0x0080ff94:    f8bd3010    ...0    LDRH     r3,[sp,#0x10]
        0x0080ff98:    2203        ."      MOVS     r2,#3
        0x0080ff9a:    3170        p1      ADDS     r1,r1,#0x70
        0x0080ff9c:    4620         F      MOV      r0,r4
        0x0080ff9e:    f7f7dd5e    ..^.    BL       log_buffer ; 0x7a5e
        0x0080ffa2:    b005        ..      ADD      sp,sp,#0x14
        0x0080ffa4:    bd30        0.      POP      {r4,r5,pc}
;;;312                                conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;313            }
;;;314            break;
;;;315    
;;;316        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;317            {
;;;318                APP_PRINT_ERROR1("app_handle_conn_param_update_evt update failed: cause 0x%x", cause);
        0x0080ffa6:    b005        ..      ADD      sp,sp,#0x14
        0x0080ffa8:    49c7        .I      LDR      r1,[pc,#796] ; [0x8102c8] = 0x8800b30
        0x0080ffaa:    4613        .F      MOV      r3,r2
        0x0080ffac:    48c4        .H      LDR      r0,[pc,#784] ; [0x8102c0] = 0x21103002
        0x0080ffae:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x0080ffb2:    2201        ."      MOVS     r2,#1
        0x0080ffb4:    3940        @9      SUBS     r1,r1,#0x40
        0x0080ffb6:    1e80        ..      SUBS     r0,r0,#2
        0x0080ffb8:    f7f79d51    ..Q.    B        log_buffer ; 0x7a5e
    app_handle_conn_mtu_info_evt
        0x0080ffbc:    b508        ..      PUSH     {r3,lr}
        0x0080ffbe:    4603        .F      MOV      r3,r0
        0x0080ffc0:    9100        ..      STR      r1,[sp,#0]
        0x0080ffc2:    49c0        .I      LDR      r1,[pc,#768] ; [0x8102c4] = 0x8800a00
        0x0080ffc4:    2202        ."      MOVS     r2,#2
        0x0080ffc6:    3134        41      ADDS     r1,r1,#0x34
        0x0080ffc8:    48bd        .H      LDR      r0,[pc,#756] ; [0x8102c0] = 0x21103002
        0x0080ffca:    f7f7dd48    ..H.    BL       log_buffer ; 0x7a5e
        0x0080ffce:    bd08        ..      POP      {r3,pc}
    app_handle_conn_state_evt
;;; .\..\source\app\pxp_app.c (170)
        0x0080ffd0:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0080ffd4:    4dbd        .M      LDR      r5,[pc,#756] ; [0x8102cc] = 0x2081d0
;;; .\..\source\app\pxp_app.c (170)
        0x0080ffd6:    4680        .F      MOV      r8,r0
        0x0080ffd8:    b08a        ..      SUB      sp,sp,#0x28
        0x0080ffda:    4616        .F      MOV      r6,r2
        0x0080ffdc:    460c        .F      MOV      r4,r1
;;;171        APP_PRINT_INFO4("app_handle_conn_state_evt: conn_id %d old_state %d new_state %d, disc_cause 0x%x",
        0x0080ffde:    7928        (y      LDRB     r0,[r5,#4]
        0x0080ffe0:    4fb7        .O      LDR      r7,[pc,#732] ; [0x8102c0] = 0x21103002
        0x0080ffe2:    e88d0051    ..Q.    STM      sp,{r0,r4,r6}
        0x0080ffe6:    4643        CF      MOV      r3,r8
        0x0080ffe8:    2204        ."      MOVS     r2,#4
        0x0080ffea:    49b9        .I      LDR      r1,[pc,#740] ; [0x8102d0] = 0x88007c4
        0x0080ffec:    4638        8F      MOV      r0,r7
        0x0080ffee:    f7f7dd36    ..6.    BL       log_buffer ; 0x7a5e
;;;172                        conn_id, gap_conn_state, new_state, disc_cause);
;;;173        switch (new_state)
        0x0080fff2:    b114        ..      CBZ      r4,0x80fffa ; app_handle_conn_state_evt + 42
        0x0080fff4:    2c02        .,      CMP      r4,#2
        0x0080fff6:    d163        c.      BNE      0x8100c0 ; app_handle_conn_state_evt + 240
        0x0080fff8:    e034        4.      B        0x810064 ; app_handle_conn_state_evt + 148
        0x0080fffa:    4fb1        .O      LDR      r7,[pc,#708] ; [0x8102c0] = 0x21103002
;;;174        {
;;;175        case GAP_CONN_STATE_DISCONNECTED:
;;;176            {
;;;177                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
        0x0080fffc:    f5a67080    ...p    SUB      r0,r6,#0x100
        0x00810000:    1ebf        ..      SUBS     r7,r7,#2
        0x00810002:    3813        .8      SUBS     r0,r0,#0x13
        0x00810004:    d009        ..      BEQ      0x81001a ; app_handle_conn_state_evt + 74
;;;178                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
        0x00810006:    f5b67f8b    ....    CMP      r6,#0x116
        0x0081000a:    d006        ..      BEQ      0x81001a ; app_handle_conn_state_evt + 74
;;;179                {
;;;180                    APP_PRINT_ERROR1("app_handle_conn_state_evt: connection lost cause 0x%x", disc_cause);
        0x0081000c:    49b0        .I      LDR      r1,[pc,#704] ; [0x8102d0] = 0x88007c4
        0x0081000e:    4633        3F      MOV      r3,r6
        0x00810010:    2201        ."      MOVS     r2,#1
        0x00810012:    3154        T1      ADDS     r1,r1,#0x54
        0x00810014:    4638        8F      MOV      r0,r7
        0x00810016:    f7f7dd22    ..".    BL       log_buffer ; 0x7a5e
;;;181                }
;;;182                gPxpState = PxpStateIdle;
        0x0081001a:    2000        .       MOVS     r0,#0
        0x0081001c:    7028        (p      STRB     r0,[r5,#0]
;;;183                if (gPowerFlg == true)
        0x0081001e:    78a8        .x      LDRB     r0,[r5,#2]
        0x00810020:    b1f8        ..      CBZ      r0,0x810062 ; app_handle_conn_state_evt + 146
;;;184                {
;;;185                    le_adv_start();
        0x00810022:    f442f050    B.P.    BL       le_adv_start ; 0x520c6
;;;186                    APP_PRINT_ERROR1("g_pxp_linkloss_alert_level is %d", g_pxp_linkloss_alert_level);
        0x00810026:    4eab        .N      LDR      r6,[pc,#684] ; [0x8102d4] = 0x207fa8
        0x00810028:    49a9        .I      LDR      r1,[pc,#676] ; [0x8102d0] = 0x88007c4
        0x0081002a:    2201        ."      MOVS     r2,#1
        0x0081002c:    7833        3x      LDRB     r3,[r6,#0]
        0x0081002e:    3190        .1      ADDS     r1,r1,#0x90
        0x00810030:    4638        8F      MOV      r0,r7
        0x00810032:    f7f7dd14    ....    BL       log_buffer ; 0x7a5e
;;;187                    gIoState = IoStateLlsAlert;
        0x00810036:    2003        .       MOVS     r0,#3
        0x00810038:    7068        hp      STRB     r0,[r5,#1]
;;;188                    if (g_pxp_linkloss_alert_level == 1)
        0x0081003a:    7830        0x      LDRB     r0,[r6,#0]
        0x0081003c:    f44f7761    O.aw    MOV      r7,#0x384
        0x00810040:    2801        .(      CMP      r0,#1
        0x00810042:    d105        ..      BNE      0x810050 ; app_handle_conn_state_evt + 128
;;;189                    {
;;;190                        StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK, LL_ASSERT_TIME);
        0x00810044:    2201        ."      MOVS     r2,#1
        0x00810046:    2164        d!      MOVS     r1,#0x64
        0x00810048:    4638        8F      MOV      r0,r7
        0x0081004a:    6873        sh      LDR      r3,[r6,#4]
        0x0081004c:    f7fefd7d    ..}.    BL       StartPxpIO ; 0x80eb4a
;;;191                    }
;;;192                    if (g_pxp_linkloss_alert_level == 2)
        0x00810050:    7830        0x      LDRB     r0,[r6,#0]
        0x00810052:    2802        .(      CMP      r0,#2
        0x00810054:    d134        4.      BNE      0x8100c0 ; app_handle_conn_state_evt + 240
;;;193                    {
;;;194                        StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, LL_ASSERT_TIME);
        0x00810056:    2203        ."      MOVS     r2,#3
        0x00810058:    2164        d!      MOVS     r1,#0x64
        0x0081005a:    4638        8F      MOV      r0,r7
        0x0081005c:    6873        sh      LDR      r3,[r6,#4]
        0x0081005e:    f7fefd74    ..t.    BL       StartPxpIO ; 0x80eb4a
        0x00810062:    e02d        -.      B        0x8100c0 ; app_handle_conn_state_evt + 240
;;;195                    }
;;;196                    else
;;;197                    {
;;;198                        //nothing to do
;;;199                    }
;;;200                }
;;;201            }
;;;202            break;
;;;203    
;;;204        case GAP_CONN_STATE_CONNECTED:
;;;205            {
;;;206                uint16_t conn_interval;
;;;207                uint16_t conn_latency;
;;;208                uint16_t conn_supervision_timeout;
;;;209                uint8_t  remote_bd[6];
;;;210                T_GAP_REMOTE_ADDR_TYPE remote_bd_type;
;;;211    
;;;212                gPxpState = PxpStateLink;
        0x00810064:    2002        .       MOVS     r0,#2
        0x00810066:    7028        (p      STRB     r0,[r5,#0]
;;;213    
;;;214                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
        0x00810068:    4642        BF      MOV      r2,r8
        0x0081006a:    a906        ..      ADD      r1,sp,#0x18
        0x0081006c:    f2402072    @.r     MOV      r0,#0x272
        0x00810070:    f43df505    =...    BL       le_get_conn_param ; 0x4da7e
;;;215                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_latency, conn_id);
        0x00810074:    4642        BF      MOV      r2,r8
        0x00810076:    a908        ..      ADD      r1,sp,#0x20
        0x00810078:    f2402073    @.s     MOV      r0,#0x273
        0x0081007c:    f43df4ff    =...    BL       le_get_conn_param ; 0x4da7e
;;;216                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
        0x00810080:    4642        BF      MOV      r2,r8
        0x00810082:    a909        ..      ADD      r1,sp,#0x24
        0x00810084:    f44f701d    O..p    MOV      r0,#0x274
        0x00810088:    f43df4f9    =...    BL       le_get_conn_param ; 0x4da7e
;;;217                le_get_conn_addr(conn_id, remote_bd, &remote_bd_type);
        0x0081008c:    aa07        ..      ADD      r2,sp,#0x1c
        0x0081008e:    a904        ..      ADD      r1,sp,#0x10
        0x00810090:    4640        @F      MOV      r0,r8
        0x00810092:    f43df5ac    =...    BL       le_get_conn_addr ; 0x4dbee
;;;218                APP_PRINT_INFO5("GAP_CONN_STATE_CONNECTED:remote_bd %s, remote_addr_type %d, conn_interval 0x%x, conn_latency 0x%x, conn_supervision_timeout 0x%x",
        0x00810096:    a904        ..      ADD      r1,sp,#0x10
        0x00810098:    488f        .H      LDR      r0,[pc,#572] ; [0x8102d8] = 0x21300000
        0x0081009a:    f7f7de9d    ....    BL       trace_bdaddr ; 0x7dd8
        0x0081009e:    4603        .F      MOV      r3,r0
        0x008100a0:    f89d001c    ....    LDRB     r0,[sp,#0x1c]
        0x008100a4:    f8bd6024    ..$`    LDRH     r6,[sp,#0x24]
        0x008100a8:    f8bd2020    ..      LDRH     r2,[sp,#0x20]
        0x008100ac:    f8bd1018    ....    LDRH     r1,[sp,#0x18]
        0x008100b0:    e88d0047    ..G.    STM      sp,{r0-r2,r6}
        0x008100b4:    4981        .I      LDR      r1,[pc,#516] ; [0x8102bc] = 0x88008fc
        0x008100b6:    2205        ."      MOVS     r2,#5
        0x008100b8:    3984        .9      SUBS     r1,r1,#0x84
        0x008100ba:    4638        8F      MOV      r0,r7
        0x008100bc:    f7f7dccf    ....    BL       log_buffer ; 0x7a5e
;;;219                                TRACE_BDADDR(remote_bd), remote_bd_type,
;;;220                                conn_interval, conn_latency, conn_supervision_timeout);
;;;221            }
;;;222            break;
;;;223    
;;;224        default:
;;;225            break;
;;;226        }
;;;227        gap_conn_state = new_state;
        0x008100c0:    712c        ,q      STRB     r4,[r5,#4]
;;;228    }
        0x008100c2:    b00a        ..      ADD      sp,sp,#0x28
        0x008100c4:    e8bd81f0    ....    POP      {r4-r8,pc}
    app_handle_dev_state_evt
        0x008100c8:    e92d47fc    -..G    PUSH     {r2-r10,lr}
        0x008100cc:    b2c4        ..      UXTB     r4,r0
;;; .\..\source\app\pxp_app.c (119)
        0x008100ce:    f3c40581    ....    UBFX     r5,r4,#2,#2
        0x008100d2:    e9cd5100    ...Q    STRD     r5,r1,[sp,#0]
        0x008100d6:    497e        ~I      LDR      r1,[pc,#504] ; [0x8102d0] = 0x88007c4
        0x008100d8:    f8dfa1e4    ....    LDR      r10,[pc,#484] ; [0x8102c0] = 0x21103002
        0x008100dc:    f0040701    ....    AND      r7,r4,#1
        0x008100e0:    463b        ;F      MOV      r3,r7
        0x008100e2:    2203        ."      MOVS     r2,#3
        0x008100e4:    39b4        .9      SUBS     r1,r1,#0xb4
        0x008100e6:    4650        PF      MOV      r0,r10
        0x008100e8:    f7f7dcb9    ....    BL       log_buffer ; 0x7a5e
;;;120                        new_state.gap_init_state, new_state.gap_adv_state, cause);
;;;121        if (gap_dev_state.gap_init_state != new_state.gap_init_state)
        0x008100ec:    f8df91dc    ....    LDR      r9,[pc,#476] ; [0x8102cc] = 0x2081d0
        0x008100f0:    4e76        vN      LDR      r6,[pc,#472] ; [0x8102cc] = 0x2081d0
        0x008100f2:    f1090903    ....    ADD      r9,r9,#3
        0x008100f6:    f04f0800    O...    MOV      r8,#0
        0x008100fa:    f8990000    ....    LDRB     r0,[r9,#0]
        0x008100fe:    f0000001    ....    AND      r0,r0,#1
        0x00810102:    42b8        .B      CMP      r0,r7
        0x00810104:    d009        ..      BEQ      0x81011a ; app_handle_dev_state_evt + 82
;;;122        {
;;;123            if (new_state.gap_init_state == GAP_INIT_STATE_STACK_READY)
        0x00810106:    07e0        ..      LSLS     r0,r4,#31
        0x00810108:    d007        ..      BEQ      0x81011a ; app_handle_dev_state_evt + 82
;;;124            {
;;;125                APP_PRINT_INFO0("GAP stack ready");
        0x0081010a:    4971        qI      LDR      r1,[pc,#452] ; [0x8102d0] = 0x88007c4
        0x0081010c:    2200        ."      MOVS     r2,#0
        0x0081010e:    396c        l9      SUBS     r1,r1,#0x6c
        0x00810110:    4650        PF      MOV      r0,r10
        0x00810112:    f7f7dca4    ....    BL       log_buffer ; 0x7a5e
;;;126                gPowerFlg = false;
        0x00810116:    f8868002    ....    STRB     r8,[r6,#2]
;;;127            }
;;;128        }
;;;129    
;;;130        if (gap_dev_state.gap_adv_state != new_state.gap_adv_state)
        0x0081011a:    f8990000    ....    LDRB     r0,[r9,#0]
        0x0081011e:    f3c00081    ....    UBFX     r0,r0,#2,#2
        0x00810122:    42a8        .B      CMP      r0,r5
        0x00810124:    d027        '.      BEQ      0x810176 ; app_handle_dev_state_evt + 174
;;;131        {
;;;132            if (new_state.gap_adv_state == GAP_ADV_STATE_IDLE)
        0x00810126:    f0140f0c    ....    TST      r4,#0xc
        0x0081012a:    d002        ..      BEQ      0x810132 ; app_handle_dev_state_evt + 106
        0x0081012c:    2d02        .-      CMP      r5,#2
        0x0081012e:    d00f        ..      BEQ      0x810150 ; app_handle_dev_state_evt + 136
        0x00810130:    e021        !.      B        0x810176 ; app_handle_dev_state_evt + 174
;;;133            {
;;;134                if (new_state.gap_adv_sub_state == GAP_ADV_TO_IDLE_CAUSE_CONN)
        0x00810132:    07a0        ..      LSLS     r0,r4,#30
        0x00810134:    d503        ..      BPL      0x81013e ; app_handle_dev_state_evt + 118
;;;135                {
;;;136                    APP_PRINT_INFO0("GAP adv stoped: because connection created");
        0x00810136:    4966        fI      LDR      r1,[pc,#408] ; [0x8102d0] = 0x88007c4
        0x00810138:    2200        ."      MOVS     r2,#0
        0x0081013a:    3958        X9      SUBS     r1,r1,#0x58
        0x0081013c:    e004        ..      B        0x810148 ; app_handle_dev_state_evt + 128
        0x0081013e:    4964        dI      LDR      r1,[pc,#400] ; [0x8102d0] = 0x88007c4
        0x00810140:    2200        ."      MOVS     r2,#0
;;;137                }
;;;138                else
;;;139                {
;;;140                    gPxpState = PxpStateIdle;
        0x00810142:    f8868000    ....    STRB     r8,[r6,#0]
;;;141                    APP_PRINT_INFO0("GAP adv stoped");
        0x00810146:    3928        (9      SUBS     r1,r1,#0x28
        0x00810148:    4650        PF      MOV      r0,r10
        0x0081014a:    f7f7dc88    ....    BL       log_buffer ; 0x7a5e
        0x0081014e:    e012        ..      B        0x810176 ; app_handle_dev_state_evt + 174
;;;142                }
;;;143            }
;;;144            else if (new_state.gap_adv_state == GAP_ADV_STATE_ADVERTISING)
;;;145            {
;;;146                APP_PRINT_INFO0("GAP adv start");
        0x00810150:    495f        _I      LDR      r1,[pc,#380] ; [0x8102d0] = 0x88007c4
        0x00810152:    2200        ."      MOVS     r2,#0
        0x00810154:    3914        .9      SUBS     r1,r1,#0x14
        0x00810156:    4650        PF      MOV      r0,r10
        0x00810158:    f7f7dc81    ....    BL       log_buffer ; 0x7a5e
;;;147                gPxpState = PxpStateAdv;
        0x0081015c:    2501        .%      MOVS     r5,#1
        0x0081015e:    7035        5p      STRB     r5,[r6,#0]
;;;148                if (gIoState != IoStateLlsAlert)
        0x00810160:    7870        px      LDRB     r0,[r6,#1]
        0x00810162:    2803        .(      CMP      r0,#3
        0x00810164:    d007        ..      BEQ      0x810176 ; app_handle_dev_state_evt + 174
;;;149                {
;;;150                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK,
        0x00810166:    230a        .#      MOVS     r3,#0xa
        0x00810168:    2201        ."      MOVS     r2,#1
        0x0081016a:    2164        d!      MOVS     r1,#0x64
        0x0081016c:    f44f7061    O.ap    MOV      r0,#0x384
        0x00810170:    f7fefceb    ....    BL       StartPxpIO ; 0x80eb4a
;;;151                               10); /*low period 0.9s, high period 0.1s,  led blink,  10times(cnt)*/
;;;152                    gIoState = IoStateAdvBlink;
        0x00810174:    7075        up      STRB     r5,[r6,#1]
;;;153                }
;;;154            }
;;;155        }
;;;156    
;;;157        gap_dev_state = new_state;
        0x00810176:    70f4        .p      STRB     r4,[r6,#3]
;;;158    }
        0x00810178:    e8bd87fc    ....    POP      {r2-r10,pc}
    app_handle_gap_msg
;;;159    
;;;160    /**
;;;161     * @brief    Handle msg GAP_MSG_LE_CONN_STATE_CHANGE
;;;162     * @note     All the gap conn state events are pre-handled in this function.
;;;163     *           Then the event handling function shall be called according to the new_state
;;;164     * @param[in] conn_id Connection ID
;;;165     * @param[in] new_state  New gap connection state
;;;166     * @param[in] disc_cause Use this cause when new_state is GAP_CONN_STATE_DISCONNECTED
;;;167     * @return   void
;;;168     */
;;;169    void app_handle_conn_state_evt(uint8_t conn_id, T_GAP_CONN_STATE new_state, uint16_t disc_cause)
;;;170    {
;;;171        APP_PRINT_INFO4("app_handle_conn_state_evt: conn_id %d old_state %d new_state %d, disc_cause 0x%x",
;;;172                        conn_id, gap_conn_state, new_state, disc_cause);
;;;173        switch (new_state)
;;;174        {
;;;175        case GAP_CONN_STATE_DISCONNECTED:
;;;176            {
;;;177                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
;;;178                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
;;;179                {
;;;180                    APP_PRINT_ERROR1("app_handle_conn_state_evt: connection lost cause 0x%x", disc_cause);
;;;181                }
;;;182                gPxpState = PxpStateIdle;
;;;183                if (gPowerFlg == true)
;;;184                {
;;;185                    le_adv_start();
;;;186                    APP_PRINT_ERROR1("g_pxp_linkloss_alert_level is %d", g_pxp_linkloss_alert_level);
;;;187                    gIoState = IoStateLlsAlert;
;;;188                    if (g_pxp_linkloss_alert_level == 1)
;;;189                    {
;;;190                        StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK, LL_ASSERT_TIME);
;;;191                    }
;;;192                    if (g_pxp_linkloss_alert_level == 2)
;;;193                    {
;;;194                        StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, LL_ASSERT_TIME);
;;;195                    }
;;;196                    else
;;;197                    {
;;;198                        //nothing to do
;;;199                    }
;;;200                }
;;;201            }
;;;202            break;
;;;203    
;;;204        case GAP_CONN_STATE_CONNECTED:
;;;205            {
;;;206                uint16_t conn_interval;
;;;207                uint16_t conn_latency;
;;;208                uint16_t conn_supervision_timeout;
;;;209                uint8_t  remote_bd[6];
;;;210                T_GAP_REMOTE_ADDR_TYPE remote_bd_type;
;;;211    
;;;212                gPxpState = PxpStateLink;
;;;213    
;;;214                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;215                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_latency, conn_id);
;;;216                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;217                le_get_conn_addr(conn_id, remote_bd, &remote_bd_type);
;;;218                APP_PRINT_INFO5("GAP_CONN_STATE_CONNECTED:remote_bd %s, remote_addr_type %d, conn_interval 0x%x, conn_latency 0x%x, conn_supervision_timeout 0x%x",
;;;219                                TRACE_BDADDR(remote_bd), remote_bd_type,
;;;220                                conn_interval, conn_latency, conn_supervision_timeout);
;;;221            }
;;;222            break;
;;;223    
;;;224        default:
;;;225            break;
;;;226        }
;;;227        gap_conn_state = new_state;
;;;228    }
;;;229    
;;;230    
;;;231    /**
;;;232     * @brief    Handle msg GAP_MSG_LE_AUTHEN_STATE_CHANGE
;;;233     * @note     All the gap authentication state events are pre-handled in this function.
;;;234     *           Then the event handling function shall be called according to the new_state
;;;235     * @param[in] conn_id Connection ID
;;;236     * @param[in] new_state  New authentication state
;;;237     * @param[in] cause Use this cause when new_state is GAP_AUTHEN_STATE_COMPLETE
;;;238     * @return   void
;;;239     */
;;;240    void app_handle_authen_state_evt(uint8_t conn_id, uint8_t new_state, uint16_t cause)
;;;241    {
;;;242        APP_PRINT_INFO2("app_handle_authen_state_evt:conn_id %d, cause 0x%x", conn_id, cause);
;;;243    
;;;244        switch (new_state)
;;;245        {
;;;246        case GAP_AUTHEN_STATE_STARTED:
;;;247            {
;;;248                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
;;;249            }
;;;250            break;
;;;251    
;;;252        case GAP_AUTHEN_STATE_COMPLETE:
;;;253            {
;;;254                if (cause == GAP_SUCCESS)
;;;255                {
;;;256                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, 1);
;;;257    
;;;258                    ChangeConnectionParameter(400, 0, 2000); //interval = 400*1.25ms
;;;259                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
;;;260    
;;;261                }
;;;262                else
;;;263                {
;;;264                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;265                }
;;;266            }
;;;267            break;
;;;268    
;;;269        default:
;;;270            {
;;;271                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;272            }
;;;273            break;
;;;274        }
;;;275    }
;;;276    
;;;277    /**
;;;278     * @brief    Handle msg GAP_MSG_LE_CONN_MTU_INFO
;;;279     * @note     This msg is used to inform APP that exchange mtu procedure is completed.
;;;280     * @param[in] conn_id Connection ID
;;;281     * @param[in] mtu_size  New mtu size
;;;282     * @return   void
;;;283     */
;;;284    void app_handle_conn_mtu_info_evt(uint8_t conn_id, uint16_t mtu_size)
;;;285    {
;;;286        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
;;;287    }
;;;288    
;;;289    
;;;290    /**
;;;291     * @brief    Handle msg GAP_MSG_LE_CONN_PARAM_UPDATE
;;;292     * @note     All the connection parameter update change  events are pre-handled in this function.
;;;293     * @param[in] conn_id Connection ID
;;;294     * @param[in] status  New update state
;;;295     * @param[in] cause Use this cause when status is GAP_CONN_PARAM_UPDATE_STATUS_FAIL
;;;296     * @return   void
;;;297     */
;;;298    void app_handle_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;299    {
;;;300        switch (status)
;;;301        {
;;;302        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;303            {
;;;304                uint16_t conn_interval;
;;;305                uint16_t conn_slave_latency;
;;;306                uint16_t conn_supervision_timeout;
;;;307    
;;;308                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;309                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
;;;310                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;311                APP_PRINT_INFO3("app_handle_conn_param_update_evt update success:conn_interval 0x%x, conn_slave_latency 0x%x, conn_supervision_timeout 0x%x",
;;;312                                conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;313            }
;;;314            break;
;;;315    
;;;316        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;317            {
;;;318                APP_PRINT_ERROR1("app_handle_conn_param_update_evt update failed: cause 0x%x", cause);
;;;319            }
;;;320            break;
;;;321    
;;;322        case GAP_CONN_PARAM_UPDATE_STATUS_PENDING:
;;;323            {
;;;324                APP_PRINT_INFO0("app_handle_conn_param_update_evt update pending.");
;;;325            }
;;;326            break;
;;;327    
;;;328        default:
;;;329            break;
;;;330        }
;;;331    }
;;;332    
;;;333    
;;;334    /**
;;;335     * @brief    All the BT GAP MSG are pre-handled in this function.
;;;336     * @note     Then the event handling function shall be called according to the
;;;337     *           subtype of T_IO_MSG
;;;338     * @param[in] p_gap_msg Pointer to GAP msg
;;;339     * @return   void
;;;340     */
;;;341    void app_handle_gap_msg(T_IO_MSG *p_gap_msg)
;;;342    {
        0x0081017c:    b57f        ..      PUSH     {r0-r6,lr}
        0x0081017e:    4605        .F      MOV      r5,r0
;;;343        T_LE_GAP_MSG gap_msg;
;;;344        uint8_t conn_id;
;;;345        memcpy(&gap_msg, &p_gap_msg->u.param, sizeof(p_gap_msg->u.param));
;;;346    
;;;347        APP_PRINT_TRACE1("app_handle_gap_msg: subtype %d", p_gap_msg->subtype);
        0x00810180:    8843        C.      LDRH     r3,[r0,#2]
        0x00810182:    6844        Dh      LDR      r4,[r0,#4]
        0x00810184:    4950        PI      LDR      r1,[pc,#320] ; [0x8102c8] = 0x8800b30
        0x00810186:    484e        NH      LDR      r0,[pc,#312] ; [0x8102c0] = 0x21103002
        0x00810188:    2201        ."      MOVS     r2,#1
        0x0081018a:    3134        41      ADDS     r1,r1,#0x34
        0x0081018c:    1c40        @.      ADDS     r0,r0,#1
        0x0081018e:    f7f7dc66    ..f.    BL       log_buffer ; 0x7a5e
;;;348        switch (p_gap_msg->subtype)
        0x00810192:    886b        k.      LDRH     r3,[r5,#2]
        0x00810194:    2000        .       MOVS     r0,#0
        0x00810196:    4d4a        JM      LDR      r5,[pc,#296] ; [0x8102c0] = 0x21103002
        0x00810198:    2b0b        .+      CMP      r3,#0xb
        0x0081019a:    d27c        |.      BCS      0x810296 ; app_handle_gap_msg + 282
        0x0081019c:    e8dff003    ....    TBB      [pc,r3]
    $d
        0x008101a0:    1a0c0683    ....    DCD    436995715
        0x008101a4:    5b372214    ."7[    DCD    1530339860
        0x008101a8:    002a496c    lI*.    DCD    2771308
    $t
;;;349        {
;;;350        case GAP_MSG_LE_DEV_STATE_CHANGE:
;;;351            {
;;;352                app_handle_dev_state_evt(gap_msg.msg_data.gap_dev_state_change.new_state,
        0x008101ac:    b004        ..      ADD      sp,sp,#0x10
        0x008101ae:    4620         F      MOV      r0,r4
        0x008101b0:    0c21        !.      LSRS     r1,r4,#16
        0x008101b2:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x008101b6:    e787        ..      B        app_handle_dev_state_evt ; 0x8100c8
        0x008101b8:    b004        ..      ADD      sp,sp,#0x10
        0x008101ba:    0c22        ".      LSRS     r2,r4,#16
        0x008101bc:    f3c42107    ...!    UBFX     r1,r4,#8,#8
        0x008101c0:    b2e0        ..      UXTB     r0,r4
;;;353                                         gap_msg.msg_data.gap_dev_state_change.cause);
;;;354            }
;;;355            break;
;;;356    
;;;357        case GAP_MSG_LE_CONN_STATE_CHANGE:
;;;358            {
;;;359                app_handle_conn_state_evt(gap_msg.msg_data.gap_conn_state_change.conn_id,
        0x008101c2:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x008101c6:    e703        ..      B        app_handle_conn_state_evt ; 0x80ffd0
        0x008101c8:    b004        ..      ADD      sp,sp,#0x10
        0x008101ca:    0c21        !.      LSRS     r1,r4,#16
        0x008101cc:    b2e0        ..      UXTB     r0,r4
;;;360                                          (T_GAP_CONN_STATE)gap_msg.msg_data.gap_conn_state_change.new_state,
;;;361                                          gap_msg.msg_data.gap_conn_state_change.disc_cause);
;;;362            }
;;;363            break;
;;;364    
;;;365        case GAP_MSG_LE_CONN_MTU_INFO:
;;;366            {
;;;367                app_handle_conn_mtu_info_evt(gap_msg.msg_data.gap_conn_mtu_info.conn_id,
        0x008101ce:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x008101d2:    e6f3        ..      B        app_handle_conn_mtu_info_evt ; 0x80ffbc
        0x008101d4:    b004        ..      ADD      sp,sp,#0x10
        0x008101d6:    0c22        ".      LSRS     r2,r4,#16
        0x008101d8:    f3c42107    ...!    UBFX     r1,r4,#8,#8
        0x008101dc:    b2e0        ..      UXTB     r0,r4
;;;368                                             gap_msg.msg_data.gap_conn_mtu_info.mtu_size);
;;;369            }
;;;370            break;
;;;371    
;;;372        case GAP_MSG_LE_CONN_PARAM_UPDATE:
;;;373            {
;;;374                app_handle_conn_param_update_evt(gap_msg.msg_data.gap_conn_param_update.conn_id,
        0x008101de:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x008101e2:    e6ad        ..      B        app_handle_conn_param_update_evt ; 0x80ff40
        0x008101e4:    b004        ..      ADD      sp,sp,#0x10
        0x008101e6:    0c22        ".      LSRS     r2,r4,#16
        0x008101e8:    f3c42107    ...!    UBFX     r1,r4,#8,#8
        0x008101ec:    b2e0        ..      UXTB     r0,r4
;;;375                                                 gap_msg.msg_data.gap_conn_param_update.status,
;;;376                                                 gap_msg.msg_data.gap_conn_param_update.cause);
;;;377            }
;;;378            break;
;;;379    
;;;380        case GAP_MSG_LE_AUTHEN_STATE_CHANGE:
;;;381            {
;;;382                app_handle_authen_state_evt(gap_msg.msg_data.gap_authen_state.conn_id,
        0x008101ee:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x008101f2:    e66f        o.      B        app_handle_authen_state_evt ; 0x80fed4
        0x008101f4:    b2e0        ..      UXTB     r0,r4
;;;383                                            gap_msg.msg_data.gap_authen_state.new_state,
;;;384                                            gap_msg.msg_data.gap_authen_state.status);
;;;385            }
;;;386            break;
;;;387    
;;;388        case GAP_MSG_LE_BOND_JUST_WORK:
;;;389            {
;;;390                conn_id = gap_msg.msg_data.gap_bond_just_work_conf.conn_id;
;;;391                le_bond_just_work_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x008101f6:    2101        .!      MOVS     r1,#1
        0x008101f8:    f000fb59    ..Y.    BL       le_bond_just_work_confirm ; 0x8108ae
;;;392                APP_PRINT_INFO0("GAP_MSG_LE_BOND_JUST_WORK");
        0x008101fc:    b004        ..      ADD      sp,sp,#0x10
        0x008101fe:    4628        (F      MOV      r0,r5
        0x00810200:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00810204:    4930        0I      LDR      r1,[pc,#192] ; [0x8102c8] = 0x8800b30
        0x00810206:    2200        ."      MOVS     r2,#0
        0x00810208:    3154        T1      ADDS     r1,r1,#0x54
        0x0081020a:    f7f79c28    ..(.    B        log_buffer ; 0x7a5e
;;;393            }
;;;394            break;
;;;395    
;;;396        case GAP_MSG_LE_BOND_PASSKEY_DISPLAY:
;;;397            {
;;;398                uint32_t display_value = 0;
        0x0081020e:    b2e4        ..      UXTB     r4,r4
;;;399                conn_id = gap_msg.msg_data.gap_bond_passkey_display.conn_id;
;;;400                le_bond_get_display_key(conn_id, &display_value);
        0x00810210:    9000        ..      STR      r0,[sp,#0]
        0x00810212:    4669        iF      MOV      r1,sp
        0x00810214:    4620         F      MOV      r0,r4
        0x00810216:    f43cf0e8    <...    BL       le_bond_get_display_key ; 0x4c3ea
;;;401                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_DISPLAY:passkey %d", display_value);
        0x0081021a:    492b        +I      LDR      r1,[pc,#172] ; [0x8102c8] = 0x8800b30
        0x0081021c:    2201        ."      MOVS     r2,#1
        0x0081021e:    3174        t1      ADDS     r1,r1,#0x74
        0x00810220:    4628        (F      MOV      r0,r5
        0x00810222:    9b00        ..      LDR      r3,[sp,#0]
        0x00810224:    f7f7dc1b    ....    BL       log_buffer ; 0x7a5e
;;;402                le_bond_passkey_display_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x00810228:    2101        .!      MOVS     r1,#1
        0x0081022a:    4620         F      MOV      r0,r4
        0x0081022c:    f43cf122    <.".    BL       le_bond_passkey_display_confirm ; 0x4c474
        0x00810230:    bd7f        ..      POP      {r0-r6,pc}
;;;403            }
;;;404            break;
;;;405    
;;;406        case GAP_MSG_LE_BOND_USER_CONFIRMATION:
;;;407            {
;;;408                uint32_t display_value = 0;
        0x00810232:    b2e4        ..      UXTB     r4,r4
;;;409                conn_id = gap_msg.msg_data.gap_bond_user_conf.conn_id;
;;;410                le_bond_get_display_key(conn_id, &display_value);
        0x00810234:    9000        ..      STR      r0,[sp,#0]
        0x00810236:    4669        iF      MOV      r1,sp
        0x00810238:    4620         F      MOV      r0,r4
        0x0081023a:    f43cf0d6    <...    BL       le_bond_get_display_key ; 0x4c3ea
;;;411                APP_PRINT_INFO1("GAP_MSG_LE_BOND_USER_CONFIRMATION: passkey %d", display_value);
        0x0081023e:    4922        "I      LDR      r1,[pc,#136] ; [0x8102c8] = 0x8800b30
        0x00810240:    2201        ."      MOVS     r2,#1
        0x00810242:    31a4        .1      ADDS     r1,r1,#0xa4
        0x00810244:    4628        (F      MOV      r0,r5
        0x00810246:    9b00        ..      LDR      r3,[sp,#0]
        0x00810248:    f7f7dc09    ....    BL       log_buffer ; 0x7a5e
;;;412                le_bond_user_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x0081024c:    2101        .!      MOVS     r1,#1
        0x0081024e:    4620         F      MOV      r0,r4
        0x00810250:    f43cf0e0    <...    BL       le_bond_user_confirm ; 0x4c414
        0x00810254:    bd7f        ..      POP      {r0-r6,pc}
        0x00810256:    491c        .I      LDR      r1,[pc,#112] ; [0x8102c8] = 0x8800b30
;;;413            }
;;;414            break;
;;;415    
;;;416        case GAP_MSG_LE_BOND_PASSKEY_INPUT:
;;;417            {
;;;418                uint32_t passkey = 888888;
        0x00810258:    b2e4        ..      UXTB     r4,r4
        0x0081025a:    4e20         N      LDR      r6,[pc,#128] ; [0x8102dc] = 0xd9038
;;;419                conn_id = gap_msg.msg_data.gap_bond_passkey_input.conn_id;
;;;420                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d", conn_id);
        0x0081025c:    4623        #F      MOV      r3,r4
        0x0081025e:    2201        ."      MOVS     r2,#1
        0x00810260:    31d8        .1      ADDS     r1,r1,#0xd8
        0x00810262:    4628        (F      MOV      r0,r5
        0x00810264:    f7f7dbfb    ....    BL       log_buffer ; 0x7a5e
;;;421                le_bond_passkey_input_confirm(conn_id, passkey, GAP_CFM_CAUSE_ACCEPT);
        0x00810268:    b004        ..      ADD      sp,sp,#0x10
        0x0081026a:    4631        1F      MOV      r1,r6
        0x0081026c:    4620         F      MOV      r0,r4
        0x0081026e:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00810272:    2201        ."      MOVS     r2,#1
        0x00810274:    f43cb085    <...    B        le_bond_passkey_input_confirm ; 0x4c382
;;;422            }
;;;423            break;
;;;424    
;;;425        case GAP_MSG_LE_BOND_OOB_INPUT:
;;;426            {
;;;427                uint8_t oob_data[GAP_OOB_LEN] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        0x00810278:    9000        ..      STR      r0,[sp,#0]
        0x0081027a:    9001        ..      STR      r0,[sp,#4]
        0x0081027c:    9002        ..      STR      r0,[sp,#8]
        0x0081027e:    9003        ..      STR      r0,[sp,#0xc]
        0x00810280:    b2e4        ..      UXTB     r4,r4
;;;428                conn_id = gap_msg.msg_data.gap_bond_oob_input.conn_id;
;;;429                APP_PRINT_INFO0("GAP_MSG_LE_BOND_OOB_INPUT");
        0x00810282:    2200        ."      MOVS     r2,#0
        0x00810284:    4916        .I      LDR      r1,[pc,#88] ; [0x8102e0] = 0x8800c38
        0x00810286:    4628        (F      MOV      r0,r5
        0x00810288:    f7f7dbe9    ....    BL       log_buffer ; 0x7a5e
;;;430                le_bond_set_param(GAP_PARAM_BOND_OOB_DATA, GAP_OOB_LEN, oob_data);
        0x0081028c:    466a        jF      MOV      r2,sp
        0x0081028e:    2110        .!      MOVS     r1,#0x10
        0x00810290:    f44f7004    O..p    MOV      r0,#0x210
        0x00810294:    e000        ..      B        0x810298 ; app_handle_gap_msg + 284
        0x00810296:    e006        ..      B        0x8102a6 ; app_handle_gap_msg + 298
        0x00810298:    f43bf7a9    ;...    BL       le_bond_set_param ; 0x4c1ee
;;;431                le_bond_oob_input_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x0081029c:    2101        .!      MOVS     r1,#1
        0x0081029e:    4620         F      MOV      r0,r4
        0x008102a0:    f43cf089    <...    BL       le_bond_oob_input_confirm ; 0x4c3b6
        0x008102a4:    bd7f        ..      POP      {r0-r6,pc}
;;;432            }
;;;433            break;
;;;434    
;;;435        default:
;;;436            APP_PRINT_ERROR1("app_handle_gap_msg: unknown subtype %d", p_gap_msg->subtype);
        0x008102a6:    b004        ..      ADD      sp,sp,#0x10
        0x008102a8:    490d        .I      LDR      r1,[pc,#52] ; [0x8102e0] = 0x8800c38
        0x008102aa:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x008102ae:    4804        .H      LDR      r0,[pc,#16] ; [0x8102c0] = 0x21103002
        0x008102b0:    2201        ."      MOVS     r2,#1
        0x008102b2:    3120         1      ADDS     r1,r1,#0x20
        0x008102b4:    1e80        ..      SUBS     r0,r0,#2
        0x008102b6:    f7f79bd2    ....    B        log_buffer ; 0x7a5e
    $d
        0x008102ba:    0000        ..      DCW    0
        0x008102bc:    088008fc    ....    DCD    142608636
        0x008102c0:    21103002    .0.!    DCD    554708994
        0x008102c4:    08800a00    ....    DCD    142608896
        0x008102c8:    08800b30    0...    DCD    142609200
        0x008102cc:    002081d0    .. .    DCD    2130384
        0x008102d0:    088007c4    ....    DCD    142608324
        0x008102d4:    00207fa8    .. .    DCD    2129832
        0x008102d8:    21300000    ..0!    DCD    556793856
        0x008102dc:    000d9038    8...    DCD    888888
        0x008102e0:    08800c38    8...    DCD    142609464
    $t
    app_handle_io_msg
        0x008102e4:    b513        ..      PUSH     {r0,r1,r4,lr}
        0x008102e6:    f8bd0000    ....    LDRH     r0,[sp,#0]
;;; .\..\source\app\pxp_app.c (84)
        0x008102ea:    b158        X.      CBZ      r0,0x810304 ; app_handle_io_msg + 32
;;;85         uint16_t msg_type = io_msg.type;
;;;86     
;;;87         switch (msg_type)
        0x008102ec:    280b        .(      CMP      r0,#0xb
        0x008102ee:    d00d        ..      BEQ      0x81030c ; app_handle_io_msg + 40
        0x008102f0:    2819        .(      CMP      r0,#0x19
        0x008102f2:    d106        ..      BNE      0x810302 ; app_handle_io_msg + 30
;;;88         {
;;;89         case IO_MSG_TYPE_BT_STATUS:
;;;90             {
;;;91                 app_handle_gap_msg(&io_msg);
;;;92             }
;;;93             break;
;;;94         case IO_MSG_TYPE_GPIO:
;;;95             Pxp_HandleButtonEvent(io_msg);
;;;96             break;
;;;97         case IO_MSG_TYPE_RESET_WDG_TIMER:
;;;98             {
;;;99                 APP_PRINT_INFO0("[WDG] Watch Dog Rset Timer");
        0x008102f4:    2200        ."      MOVS     r2,#0
        0x008102f6:    49bd        .I      LDR      r1,[pc,#756] ; [0x8105ec] = 0x88006f0
        0x008102f8:    48bd        .H      LDR      r0,[pc,#756] ; [0x8105f0] = 0x21103002
        0x008102fa:    f7f7dbb0    ....    BL       log_buffer ; 0x7a5e
;;;100                WDG_Restart();
        0x008102fe:    f401f329    ..).    BL       WDG_Restart ; 0x11954
;;;101            }
;;;102            break;
;;;103        default:
;;;104            break;
;;;105        }
;;;106    }
        0x00810302:    bd1c        ..      POP      {r2-r4,pc}
        0x00810304:    4668        hF      MOV      r0,sp
        0x00810306:    f7ffff39    ..9.    BL       app_handle_gap_msg ; 0x81017c
        0x0081030a:    bd1c        ..      POP      {r2-r4,pc}
        0x0081030c:    e9dd0100    ....    LDRD     r0,r1,[sp,#0]
        0x00810310:    f7fefc3e    ..>.    BL       Pxp_HandleButtonEvent ; 0x80eb90
        0x00810314:    bd1c        ..      POP      {r2-r4,pc}
    app_gap_callback
;;;107    
;;;108    
;;;109    /**
;;;110     * @brief    Handle msg GAP_MSG_LE_DEV_STATE_CHANGE
;;;111     * @note     All the gap device state events are pre-handled in this function.
;;;112     *           Then the event handling function shall be called according to the new_state
;;;113     * @param[in] new_state  New gap device state
;;;114     * @param[in] cause GAP device state change cause
;;;115     * @return   void
;;;116     */
;;;117    void app_handle_dev_state_evt(T_GAP_DEV_STATE new_state, uint16_t cause)
;;;118    {
;;;119        APP_PRINT_INFO3("app_handle_dev_state_evt: init state %d, adv state %d, cause 0x%x",
;;;120                        new_state.gap_init_state, new_state.gap_adv_state, cause);
;;;121        if (gap_dev_state.gap_init_state != new_state.gap_init_state)
;;;122        {
;;;123            if (new_state.gap_init_state == GAP_INIT_STATE_STACK_READY)
;;;124            {
;;;125                APP_PRINT_INFO0("GAP stack ready");
;;;126                gPowerFlg = false;
;;;127            }
;;;128        }
;;;129    
;;;130        if (gap_dev_state.gap_adv_state != new_state.gap_adv_state)
;;;131        {
;;;132            if (new_state.gap_adv_state == GAP_ADV_STATE_IDLE)
;;;133            {
;;;134                if (new_state.gap_adv_sub_state == GAP_ADV_TO_IDLE_CAUSE_CONN)
;;;135                {
;;;136                    APP_PRINT_INFO0("GAP adv stoped: because connection created");
;;;137                }
;;;138                else
;;;139                {
;;;140                    gPxpState = PxpStateIdle;
;;;141                    APP_PRINT_INFO0("GAP adv stoped");
;;;142                }
;;;143            }
;;;144            else if (new_state.gap_adv_state == GAP_ADV_STATE_ADVERTISING)
;;;145            {
;;;146                APP_PRINT_INFO0("GAP adv start");
;;;147                gPxpState = PxpStateAdv;
;;;148                if (gIoState != IoStateLlsAlert)
;;;149                {
;;;150                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK,
;;;151                               10); /*low period 0.9s, high period 0.1s,  led blink,  10times(cnt)*/
;;;152                    gIoState = IoStateAdvBlink;
;;;153                }
;;;154            }
;;;155        }
;;;156    
;;;157        gap_dev_state = new_state;
;;;158    }
;;;159    
;;;160    /**
;;;161     * @brief    Handle msg GAP_MSG_LE_CONN_STATE_CHANGE
;;;162     * @note     All the gap conn state events are pre-handled in this function.
;;;163     *           Then the event handling function shall be called according to the new_state
;;;164     * @param[in] conn_id Connection ID
;;;165     * @param[in] new_state  New gap connection state
;;;166     * @param[in] disc_cause Use this cause when new_state is GAP_CONN_STATE_DISCONNECTED
;;;167     * @return   void
;;;168     */
;;;169    void app_handle_conn_state_evt(uint8_t conn_id, T_GAP_CONN_STATE new_state, uint16_t disc_cause)
;;;170    {
;;;171        APP_PRINT_INFO4("app_handle_conn_state_evt: conn_id %d old_state %d new_state %d, disc_cause 0x%x",
;;;172                        conn_id, gap_conn_state, new_state, disc_cause);
;;;173        switch (new_state)
;;;174        {
;;;175        case GAP_CONN_STATE_DISCONNECTED:
;;;176            {
;;;177                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
;;;178                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
;;;179                {
;;;180                    APP_PRINT_ERROR1("app_handle_conn_state_evt: connection lost cause 0x%x", disc_cause);
;;;181                }
;;;182                gPxpState = PxpStateIdle;
;;;183                if (gPowerFlg == true)
;;;184                {
;;;185                    le_adv_start();
;;;186                    APP_PRINT_ERROR1("g_pxp_linkloss_alert_level is %d", g_pxp_linkloss_alert_level);
;;;187                    gIoState = IoStateLlsAlert;
;;;188                    if (g_pxp_linkloss_alert_level == 1)
;;;189                    {
;;;190                        StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK, LL_ASSERT_TIME);
;;;191                    }
;;;192                    if (g_pxp_linkloss_alert_level == 2)
;;;193                    {
;;;194                        StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, LL_ASSERT_TIME);
;;;195                    }
;;;196                    else
;;;197                    {
;;;198                        //nothing to do
;;;199                    }
;;;200                }
;;;201            }
;;;202            break;
;;;203    
;;;204        case GAP_CONN_STATE_CONNECTED:
;;;205            {
;;;206                uint16_t conn_interval;
;;;207                uint16_t conn_latency;
;;;208                uint16_t conn_supervision_timeout;
;;;209                uint8_t  remote_bd[6];
;;;210                T_GAP_REMOTE_ADDR_TYPE remote_bd_type;
;;;211    
;;;212                gPxpState = PxpStateLink;
;;;213    
;;;214                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;215                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_latency, conn_id);
;;;216                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;217                le_get_conn_addr(conn_id, remote_bd, &remote_bd_type);
;;;218                APP_PRINT_INFO5("GAP_CONN_STATE_CONNECTED:remote_bd %s, remote_addr_type %d, conn_interval 0x%x, conn_latency 0x%x, conn_supervision_timeout 0x%x",
;;;219                                TRACE_BDADDR(remote_bd), remote_bd_type,
;;;220                                conn_interval, conn_latency, conn_supervision_timeout);
;;;221            }
;;;222            break;
;;;223    
;;;224        default:
;;;225            break;
;;;226        }
;;;227        gap_conn_state = new_state;
;;;228    }
;;;229    
;;;230    
;;;231    /**
;;;232     * @brief    Handle msg GAP_MSG_LE_AUTHEN_STATE_CHANGE
;;;233     * @note     All the gap authentication state events are pre-handled in this function.
;;;234     *           Then the event handling function shall be called according to the new_state
;;;235     * @param[in] conn_id Connection ID
;;;236     * @param[in] new_state  New authentication state
;;;237     * @param[in] cause Use this cause when new_state is GAP_AUTHEN_STATE_COMPLETE
;;;238     * @return   void
;;;239     */
;;;240    void app_handle_authen_state_evt(uint8_t conn_id, uint8_t new_state, uint16_t cause)
;;;241    {
;;;242        APP_PRINT_INFO2("app_handle_authen_state_evt:conn_id %d, cause 0x%x", conn_id, cause);
;;;243    
;;;244        switch (new_state)
;;;245        {
;;;246        case GAP_AUTHEN_STATE_STARTED:
;;;247            {
;;;248                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
;;;249            }
;;;250            break;
;;;251    
;;;252        case GAP_AUTHEN_STATE_COMPLETE:
;;;253            {
;;;254                if (cause == GAP_SUCCESS)
;;;255                {
;;;256                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, 1);
;;;257    
;;;258                    ChangeConnectionParameter(400, 0, 2000); //interval = 400*1.25ms
;;;259                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
;;;260    
;;;261                }
;;;262                else
;;;263                {
;;;264                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;265                }
;;;266            }
;;;267            break;
;;;268    
;;;269        default:
;;;270            {
;;;271                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;272            }
;;;273            break;
;;;274        }
;;;275    }
;;;276    
;;;277    /**
;;;278     * @brief    Handle msg GAP_MSG_LE_CONN_MTU_INFO
;;;279     * @note     This msg is used to inform APP that exchange mtu procedure is completed.
;;;280     * @param[in] conn_id Connection ID
;;;281     * @param[in] mtu_size  New mtu size
;;;282     * @return   void
;;;283     */
;;;284    void app_handle_conn_mtu_info_evt(uint8_t conn_id, uint16_t mtu_size)
;;;285    {
;;;286        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
;;;287    }
;;;288    
;;;289    
;;;290    /**
;;;291     * @brief    Handle msg GAP_MSG_LE_CONN_PARAM_UPDATE
;;;292     * @note     All the connection parameter update change  events are pre-handled in this function.
;;;293     * @param[in] conn_id Connection ID
;;;294     * @param[in] status  New update state
;;;295     * @param[in] cause Use this cause when status is GAP_CONN_PARAM_UPDATE_STATUS_FAIL
;;;296     * @return   void
;;;297     */
;;;298    void app_handle_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;299    {
;;;300        switch (status)
;;;301        {
;;;302        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;303            {
;;;304                uint16_t conn_interval;
;;;305                uint16_t conn_slave_latency;
;;;306                uint16_t conn_supervision_timeout;
;;;307    
;;;308                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;309                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
;;;310                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;311                APP_PRINT_INFO3("app_handle_conn_param_update_evt update success:conn_interval 0x%x, conn_slave_latency 0x%x, conn_supervision_timeout 0x%x",
;;;312                                conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;313            }
;;;314            break;
;;;315    
;;;316        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;317            {
;;;318                APP_PRINT_ERROR1("app_handle_conn_param_update_evt update failed: cause 0x%x", cause);
;;;319            }
;;;320            break;
;;;321    
;;;322        case GAP_CONN_PARAM_UPDATE_STATUS_PENDING:
;;;323            {
;;;324                APP_PRINT_INFO0("app_handle_conn_param_update_evt update pending.");
;;;325            }
;;;326            break;
;;;327    
;;;328        default:
;;;329            break;
;;;330        }
;;;331    }
;;;332    
;;;333    
;;;334    /**
;;;335     * @brief    All the BT GAP MSG are pre-handled in this function.
;;;336     * @note     Then the event handling function shall be called according to the
;;;337     *           subtype of T_IO_MSG
;;;338     * @param[in] p_gap_msg Pointer to GAP msg
;;;339     * @return   void
;;;340     */
;;;341    void app_handle_gap_msg(T_IO_MSG *p_gap_msg)
;;;342    {
;;;343        T_LE_GAP_MSG gap_msg;
;;;344        uint8_t conn_id;
;;;345        memcpy(&gap_msg, &p_gap_msg->u.param, sizeof(p_gap_msg->u.param));
;;;346    
;;;347        APP_PRINT_TRACE1("app_handle_gap_msg: subtype %d", p_gap_msg->subtype);
;;;348        switch (p_gap_msg->subtype)
;;;349        {
;;;350        case GAP_MSG_LE_DEV_STATE_CHANGE:
;;;351            {
;;;352                app_handle_dev_state_evt(gap_msg.msg_data.gap_dev_state_change.new_state,
;;;353                                         gap_msg.msg_data.gap_dev_state_change.cause);
;;;354            }
;;;355            break;
;;;356    
;;;357        case GAP_MSG_LE_CONN_STATE_CHANGE:
;;;358            {
;;;359                app_handle_conn_state_evt(gap_msg.msg_data.gap_conn_state_change.conn_id,
;;;360                                          (T_GAP_CONN_STATE)gap_msg.msg_data.gap_conn_state_change.new_state,
;;;361                                          gap_msg.msg_data.gap_conn_state_change.disc_cause);
;;;362            }
;;;363            break;
;;;364    
;;;365        case GAP_MSG_LE_CONN_MTU_INFO:
;;;366            {
;;;367                app_handle_conn_mtu_info_evt(gap_msg.msg_data.gap_conn_mtu_info.conn_id,
;;;368                                             gap_msg.msg_data.gap_conn_mtu_info.mtu_size);
;;;369            }
;;;370            break;
;;;371    
;;;372        case GAP_MSG_LE_CONN_PARAM_UPDATE:
;;;373            {
;;;374                app_handle_conn_param_update_evt(gap_msg.msg_data.gap_conn_param_update.conn_id,
;;;375                                                 gap_msg.msg_data.gap_conn_param_update.status,
;;;376                                                 gap_msg.msg_data.gap_conn_param_update.cause);
;;;377            }
;;;378            break;
;;;379    
;;;380        case GAP_MSG_LE_AUTHEN_STATE_CHANGE:
;;;381            {
;;;382                app_handle_authen_state_evt(gap_msg.msg_data.gap_authen_state.conn_id,
;;;383                                            gap_msg.msg_data.gap_authen_state.new_state,
;;;384                                            gap_msg.msg_data.gap_authen_state.status);
;;;385            }
;;;386            break;
;;;387    
;;;388        case GAP_MSG_LE_BOND_JUST_WORK:
;;;389            {
;;;390                conn_id = gap_msg.msg_data.gap_bond_just_work_conf.conn_id;
;;;391                le_bond_just_work_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;392                APP_PRINT_INFO0("GAP_MSG_LE_BOND_JUST_WORK");
;;;393            }
;;;394            break;
;;;395    
;;;396        case GAP_MSG_LE_BOND_PASSKEY_DISPLAY:
;;;397            {
;;;398                uint32_t display_value = 0;
;;;399                conn_id = gap_msg.msg_data.gap_bond_passkey_display.conn_id;
;;;400                le_bond_get_display_key(conn_id, &display_value);
;;;401                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_DISPLAY:passkey %d", display_value);
;;;402                le_bond_passkey_display_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;403            }
;;;404            break;
;;;405    
;;;406        case GAP_MSG_LE_BOND_USER_CONFIRMATION:
;;;407            {
;;;408                uint32_t display_value = 0;
;;;409                conn_id = gap_msg.msg_data.gap_bond_user_conf.conn_id;
;;;410                le_bond_get_display_key(conn_id, &display_value);
;;;411                APP_PRINT_INFO1("GAP_MSG_LE_BOND_USER_CONFIRMATION: passkey %d", display_value);
;;;412                le_bond_user_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;413            }
;;;414            break;
;;;415    
;;;416        case GAP_MSG_LE_BOND_PASSKEY_INPUT:
;;;417            {
;;;418                uint32_t passkey = 888888;
;;;419                conn_id = gap_msg.msg_data.gap_bond_passkey_input.conn_id;
;;;420                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d", conn_id);
;;;421                le_bond_passkey_input_confirm(conn_id, passkey, GAP_CFM_CAUSE_ACCEPT);
;;;422            }
;;;423            break;
;;;424    
;;;425        case GAP_MSG_LE_BOND_OOB_INPUT:
;;;426            {
;;;427                uint8_t oob_data[GAP_OOB_LEN] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
;;;428                conn_id = gap_msg.msg_data.gap_bond_oob_input.conn_id;
;;;429                APP_PRINT_INFO0("GAP_MSG_LE_BOND_OOB_INPUT");
;;;430                le_bond_set_param(GAP_PARAM_BOND_OOB_DATA, GAP_OOB_LEN, oob_data);
;;;431                le_bond_oob_input_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;432            }
;;;433            break;
;;;434    
;;;435        default:
;;;436            APP_PRINT_ERROR1("app_handle_gap_msg: unknown subtype %d", p_gap_msg->subtype);
;;;437            break;
;;;438        }
;;;439    }
;;;440    /** @} */ /* End of group PERIPH_GAP_MSG */
;;;441    
;;;442    
;;;443    
;;;444    /** @defgroup  PXP_SMART_GAP_CALLBACK GAP Callback Event Handler
;;;445        * @brief Handle GAP callback event
;;;446        * @{
;;;447        */
;;;448    /**
;;;449      * @brief Callback for gap le to notify app
;;;450      * @param[in] cb_type callback msy type @ref GAP_LE_MSG_Types.
;;;451      * @param[in] p_cb_data point to callback data @ref T_LE_CB_DATA.
;;;452      * @retval result @ref T_APP_RESULT
;;;453      */
;;;454    T_APP_RESULT app_gap_callback(uint8_t cb_type, void *p_cb_data)
;;;455    {
        0x00810316:    b57c        |.      PUSH     {r2-r6,lr}
        0x00810318:    2400        .$      MOVS     r4,#0
        0x0081031a:    4db5        .M      LDR      r5,[pc,#724] ; [0x8105f0] = 0x21103002
        0x0081031c:    2801        .(      CMP      r0,#1
        0x0081031e:    d016        ..      BEQ      0x81034e ; app_gap_callback + 56
;;;456        T_APP_RESULT result = APP_RESULT_SUCCESS;
;;;457        T_LE_CB_DATA *p_data = (T_LE_CB_DATA *)p_cb_data;
;;;458    
;;;459        switch (cb_type)
        0x00810320:    2814        .(      CMP      r0,#0x14
        0x00810322:    d007        ..      BEQ      0x810334 ; app_gap_callback + 30
        0x00810324:    4603        .F      MOV      r3,r0
        0x00810326:    2201        ."      MOVS     r2,#1
        0x00810328:    49b2        .I      LDR      r1,[pc,#712] ; [0x8105f4] = 0x8800d14
        0x0081032a:    1ea8        ..      SUBS     r0,r5,#2
        0x0081032c:    f7f7db97    ....    BL       log_buffer ; 0x7a5e
        0x00810330:    4620         F      MOV      r0,r4
        0x00810332:    bd7c        |.      POP      {r2-r6,pc}
;;;460        {
;;;461        case GAP_MSG_LE_DATA_LEN_CHANGE_INFO:
;;;462            APP_PRINT_INFO3("GAP_MSG_LE_DATA_LEN_CHANGE_INFO: conn_id %d, tx octets 0x%x, max_tx_time 0x%x",
        0x00810334:    6808        .h      LDR      r0,[r1,#0]
        0x00810336:    8882        ..      LDRH     r2,[r0,#4]
        0x00810338:    8841        A.      LDRH     r1,[r0,#2]
        0x0081033a:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0081033e:    49ad        .I      LDR      r1,[pc,#692] ; [0x8105f4] = 0x8800d14
        0x00810340:    7803        .x      LDRB     r3,[r0,#0]
        0x00810342:    2203        ."      MOVS     r2,#3
        0x00810344:    3990        .9      SUBS     r1,r1,#0x90
        0x00810346:    4628        (F      MOV      r0,r5
        0x00810348:    f7f7db89    ....    BL       log_buffer ; 0x7a5e
;;;463                            p_data->p_le_data_len_change_info->conn_id,
;;;464                            p_data->p_le_data_len_change_info->max_tx_octets,
;;;465                            p_data->p_le_data_len_change_info->max_tx_time);
;;;466            break;
        0x0081034c:    e7f0        ..      B        0x810330 ; app_gap_callback + 26
;;;467    
;;;468        case GAP_MSG_LE_MODIFY_WHITE_LIST:
;;;469            APP_PRINT_INFO2("GAP_MSG_LE_MODIFY_WHITE_LIST: operation %d, cause 0x%x",
        0x0081034e:    6808        .h      LDR      r0,[r1,#0]
        0x00810350:    2202        ."      MOVS     r2,#2
        0x00810352:    8841        A.      LDRH     r1,[r0,#2]
        0x00810354:    9100        ..      STR      r1,[sp,#0]
        0x00810356:    49a7        .I      LDR      r1,[pc,#668] ; [0x8105f4] = 0x8800d14
        0x00810358:    7803        .x      LDRB     r3,[r0,#0]
        0x0081035a:    393c        <9      SUBS     r1,r1,#0x3c
        0x0081035c:    4628        (F      MOV      r0,r5
        0x0081035e:    f7f7db7e    ..~.    BL       log_buffer ; 0x7a5e
;;;470                            p_data->p_le_modify_white_list_rsp->operation,
;;;471                            p_data->p_le_modify_white_list_rsp->cause);
;;;472            break;
        0x00810362:    e7e5        ..      B        0x810330 ; app_gap_callback + 26
    app_profile_callback
;;;473    
;;;474        default:
;;;475            APP_PRINT_ERROR1("app_gap_callback: unhandled cb_type 0x%x", cb_type);
;;;476            break;
;;;477        }
;;;478        return result;
;;;479    }
;;;480    /** @} */ /* End of group PXP_GAP_CALLBACK */
;;;481    
;;;482    
;;;483    /** @defgroup  PXP_SEVER_CALLBACK Profile Server Callback Event Handler
;;;484        * @brief Handle profile server callback event
;;;485        * @{
;;;486        */
;;;487    /**
;;;488     * @brief    All the BT Profile service callback events are handled in this function
;;;489     * @note     Then the event handling function shall be called according to the
;;;490     *           service_id.
;;;491     * @param[in] service_id  Profile service ID
;;;492     * @param[in] p_data      Pointer to callback data
;;;493     * @return   Indicates the function call is successful or not
;;;494     * @retval   result @ref T_APP_RESULT
;;;495     */
;;;496    
;;;497    T_APP_RESULT app_profile_callback(T_SERVER_ID service_id, void *p_data)
;;;498    {
        0x00810364:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x00810368:    f8df8284    ....    LDR      r8,[pc,#644] ; [0x8105f0] = 0x21103002
        0x0081036c:    2500        .%      MOVS     r5,#0
        0x0081036e:    4fa0        .O      LDR      r7,[pc,#640] ; [0x8105f0] = 0x21103002
;;; .\..\source\app\pxp_app.c (498)
        0x00810370:    b086        ..      SUB      sp,sp,#0x18
        0x00810372:    f1a80802    ....    SUB      r8,r8,#2
        0x00810376:    28ff        .(      CMP      r0,#0xff
        0x00810378:    d00e        ..      BEQ      0x810398 ; app_profile_callback + 52
        0x0081037a:    4e9f        .N      LDR      r6,[pc,#636] ; [0x8105f8] = 0x2081d0
        0x0081037c:    4c9f        .L      LDR      r4,[pc,#636] ; [0x8105fc] = 0x207fa8
        0x0081037e:    7972        ry      LDRB     r2,[r6,#5]
        0x00810380:    4290        .B      CMP      r0,r2
        0x00810382:    d149        I.      BNE      0x810418 ; app_profile_callback + 180
        0x00810384:    460f        .F      MOV      r7,r1
        0x00810386:    2200        ."      MOVS     r2,#0
        0x00810388:    499d        .I      LDR      r1,[pc,#628] ; [0x810600] = 0x8800e2c
        0x0081038a:    4640        @F      MOV      r0,r8
        0x0081038c:    f7f7db67    ..g.    BL       log_buffer ; 0x7a5e
        0x00810390:    7878        xx      LDRB     r0,[r7,#1]
        0x00810392:    2803        .(      CMP      r0,#3
        0x00810394:    d026        &.      BEQ      0x8103e4 ; app_profile_callback + 128
        0x00810396:    e0eb        ..      B        0x810570 ; app_profile_callback + 524
        0x00810398:    7808        .x      LDRB     r0,[r1,#0]
;;;499        T_APP_RESULT app_result = APP_RESULT_SUCCESS;
;;;500        if (service_id == SERVICE_PROFILE_GENERAL_ID)
;;;501        {
;;;502            T_SERVER_APP_CB_DATA *p_param = (T_SERVER_APP_CB_DATA *)p_data;
        0x0081039a:    460c        .F      MOV      r4,r1
;;;503            switch (p_param->eventId)
        0x0081039c:    b110        ..      CBZ      r0,0x8103a4 ; app_profile_callback + 64
        0x0081039e:    2801        .(      CMP      r0,#1
        0x008103a0:    d1f9        ..      BNE      0x810396 ; app_profile_callback + 50
        0x008103a2:    e007        ..      B        0x8103b4 ; app_profile_callback + 80
;;;504            {
;;;505            case PROFILE_EVT_SRV_REG_COMPLETE:// srv register result event.
;;;506                APP_PRINT_INFO1("PROFILE_EVT_SRV_REG_COMPLETE: result %d",
        0x008103a4:    788b        .x      LDRB     r3,[r1,#2]
        0x008103a6:    4993        .I      LDR      r1,[pc,#588] ; [0x8105f4] = 0x8800d14
        0x008103a8:    2201        ."      MOVS     r2,#1
        0x008103aa:    312c        ,1      ADDS     r1,r1,#0x2c
        0x008103ac:    4638        8F      MOV      r0,r7
        0x008103ae:    f7f7db56    ..V.    BL       log_buffer ; 0x7a5e
;;;507                                p_param->event_data.service_reg_result);
;;;508                break;
        0x008103b2:    e0dd        ..      B        0x810570 ; app_profile_callback + 524
;;;509    
;;;510            case PROFILE_EVT_SEND_DATA_COMPLETE:
;;;511                APP_PRINT_INFO5("PROFILE_EVT_SEND_DATA_COMPLETE: conn_id %d, cause 0x%x, service_id %d, attrib_idx 0x%x, credits %d",
        0x008103b4:    8920         .      LDRH     r0,[r4,#8]
        0x008103b6:    8863        c.      LDRH     r3,[r4,#2]
        0x008103b8:    88e2        ..      LDRH     r2,[r4,#6]
        0x008103ba:    7961        ay      LDRB     r1,[r4,#5]
        0x008103bc:    e88d000f    ....    STM      sp,{r0-r3}
        0x008103c0:    498c        .I      LDR      r1,[pc,#560] ; [0x8105f4] = 0x8800d14
        0x008103c2:    7923        #y      LDRB     r3,[r4,#4]
        0x008103c4:    2205        ."      MOVS     r2,#5
        0x008103c6:    3158        X1      ADDS     r1,r1,#0x58
        0x008103c8:    4638        8F      MOV      r0,r7
        0x008103ca:    f7f7db48    ..H.    BL       log_buffer ; 0x7a5e
;;;512                                p_param->event_data.send_data_result.conn_id,
;;;513                                p_param->event_data.send_data_result.cause,
;;;514                                p_param->event_data.send_data_result.service_id,
;;;515                                p_param->event_data.send_data_result.attrib_idx,
;;;516                                p_param->event_data.send_data_result.credits);
;;;517                if (p_param->event_data.send_data_result.cause == GAP_SUCCESS)
        0x008103ce:    8920         .      LDRH     r0,[r4,#8]
        0x008103d0:    f04f0200    O...    MOV      r2,#0
        0x008103d4:    b118        ..      CBZ      r0,0x8103de ; app_profile_callback + 122
        0x008103d6:    498a        .I      LDR      r1,[pc,#552] ; [0x810600] = 0x8800e2c
        0x008103d8:    4640        @F      MOV      r0,r8
        0x008103da:    392c        ,9      SUBS     r1,r1,#0x2c
        0x008103dc:    e088        ..      B        0x8104f0 ; app_profile_callback + 396
;;;518                {
;;;519                    APP_PRINT_INFO0("PROFILE_EVT_SEND_DATA_COMPLETE success");
        0x008103de:    4988        .I      LDR      r1,[pc,#544] ; [0x810600] = 0x8800e2c
        0x008103e0:    3958        X9      SUBS     r1,r1,#0x58
        0x008103e2:    e084        ..      B        0x8104ee ; app_profile_callback + 394
;;;520                }
;;;521                else
;;;522                {
;;;523                    APP_PRINT_ERROR0("PROFILE_EVT_SEND_DATA_COMPLETE failed");
;;;524                }
;;;525                break;
;;;526    
;;;527            default:
;;;528                break;
;;;529            }
;;;530        }
;;;531        else if (service_id == ias_srv_id)
;;;532        {
;;;533            T_IAS_CALLBACK_DATA *p_ias_cb_data = (T_IAS_CALLBACK_DATA *)p_data;
;;;534            APP_PRINT_ERROR0("IAS CallBack.");
;;;535            if (p_ias_cb_data->msg_type == SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE)
;;;536            {
;;;537                g_pxp_immediate_alert_level = p_ias_cb_data->msg_data.write_alert_level;
        0x008103e4:    78b8        .x      LDRB     r0,[r7,#2]
        0x008103e6:    2102        .!      MOVS     r1,#2
        0x008103e8:    72f0        .r      STRB     r0,[r6,#0xb]
        0x008103ea:    f44f7761    O.aw    MOV      r7,#0x384
;;;538                if (g_pxp_immediate_alert_level == 1)
        0x008103ee:    2801        .(      CMP      r0,#1
        0x008103f0:    d004        ..      BEQ      0x8103fc ; app_profile_callback + 152
        0x008103f2:    2802        .(      CMP      r0,#2
        0x008103f4:    d008        ..      BEQ      0x810408 ; app_profile_callback + 164
        0x008103f6:    f7fefb91    ....    BL       StopPxpIO ; 0x80eb1c
        0x008103fa:    e0b9        ..      B        0x810570 ; app_profile_callback + 524
;;;539                {
;;;540                    gIoState = IoStateImmAlert;
        0x008103fc:    7071        qp      STRB     r1,[r6,#1]
;;;541                    StopPxpIO();
        0x008103fe:    f7fefb8d    ....    BL       StopPxpIO ; 0x80eb1c
;;;542                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK, gTimeParaValue);
        0x00810402:    2201        ."      MOVS     r2,#1
        0x00810404:    6863        ch      LDR      r3,[r4,#4]
        0x00810406:    e002        ..      B        0x81040e ; app_profile_callback + 170
        0x00810408:    7071        qp      STRB     r1,[r6,#1]
        0x0081040a:    6863        ch      LDR      r3,[r4,#4]
        0x0081040c:    2203        ."      MOVS     r2,#3
        0x0081040e:    2164        d!      MOVS     r1,#0x64
        0x00810410:    4638        8F      MOV      r0,r7
        0x00810412:    f7fefb9a    ....    BL       StartPxpIO ; 0x80eb4a
        0x00810416:    e0ab        ..      B        0x810570 ; app_profile_callback + 524
;;;543                }
;;;544                else if (g_pxp_immediate_alert_level == 2)
;;;545                {
;;;546                    gIoState = IoStateImmAlert;
;;;547                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, gTimeParaValue);
;;;548                }
;;;549                else
;;;550                {
;;;551                    StopPxpIO();
;;;552                }
;;;553            }
;;;554        }
;;;555        else if (service_id == lls_srv_id)
        0x00810418:    79b2        .y      LDRB     r2,[r6,#6]
        0x0081041a:    4290        .B      CMP      r0,r2
        0x0081041c:    d10d        ..      BNE      0x81043a ; app_profile_callback + 214
;;;556        {
;;;557            T_LLS_CALLBACK_DATA *p_lls_cb_data = (T_LLS_CALLBACK_DATA *)p_data;
;;;558            switch (p_lls_cb_data->msg_type)
        0x0081041e:    7848        Hx      LDRB     r0,[r1,#1]
        0x00810420:    2802        .(      CMP      r0,#2
        0x00810422:    d004        ..      BEQ      0x81042e ; app_profile_callback + 202
        0x00810424:    2803        .(      CMP      r0,#3
        0x00810426:    d101        ..      BNE      0x81042c ; app_profile_callback + 200
;;;559            {
;;;560            case SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE:
;;;561                g_pxp_linkloss_alert_level = p_lls_cb_data->msg_data.write_alert_level;
        0x00810428:    7888        .x      LDRB     r0,[r1,#2]
        0x0081042a:    7020         p      STRB     r0,[r4,#0]
;;;562                break;
        0x0081042c:    e0a0        ..      B        0x810570 ; app_profile_callback + 524
;;;563            case SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE:
;;;564                lls_set_parameter(LLS_PARAM_LINK_LOSS_ALERT_LEVEL, 1, &g_pxp_linkloss_alert_level);
        0x0081042e:    4a73        sJ      LDR      r2,[pc,#460] ; [0x8105fc] = 0x207fa8
        0x00810430:    2101        .!      MOVS     r1,#1
        0x00810432:    2000        .       MOVS     r0,#0
        0x00810434:    f7feffec    ....    BL       lls_set_parameter ; 0x80f410
;;;565                break;
        0x00810438:    e09a        ..      B        0x810570 ; app_profile_callback + 524
;;;566            default:
;;;567                break;
;;;568            }
;;;569        }
;;;570        else if (service_id == tps_srv_id)
        0x0081043a:    79f3        .y      LDRB     r3,[r6,#7]
        0x0081043c:    2200        ."      MOVS     r2,#0
        0x0081043e:    4298        .B      CMP      r0,r3
        0x00810440:    d10d        ..      BNE      0x81045e ; app_profile_callback + 250
;;;571        {
;;;572            T_TPS_CALLBACK_DATA *p_tps_cb_data = (T_TPS_CALLBACK_DATA *)p_data;
;;;573            if (p_tps_cb_data->msg_type == SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE)
        0x00810442:    7848        Hx      LDRB     r0,[r1,#1]
        0x00810444:    2802        .(      CMP      r0,#2
        0x00810446:    d109        ..      BNE      0x81045c ; app_profile_callback + 248
;;;574            {
;;;575                if (p_tps_cb_data->msg_data.read_value_index == TPS_READ_TX_POWER_VALUE)
        0x00810448:    7888        .x      LDRB     r0,[r1,#2]
        0x0081044a:    2801        .(      CMP      r0,#1
        0x0081044c:    d106        ..      BNE      0x81045c ; app_profile_callback + 248
;;;576                {
;;;577                    uint8_t tps_value = 0;
        0x0081044e:    f88d2000    ...     STRB     r2,[sp,#0]
;;;578                    tps_set_parameter(TPS_PARAM_TX_POWER, 1, &tps_value);
        0x00810452:    466a        jF      MOV      r2,sp
        0x00810454:    2101        .!      MOVS     r1,#1
        0x00810456:    2000        .       MOVS     r0,#0
        0x00810458:    f7fff86c    ..l.    BL       tps_set_parameter ; 0x80f534
;;;579                }
        0x0081045c:    e088        ..      B        0x810570 ; app_profile_callback + 524
;;;580            }
;;;581        }
;;;582    
;;;583        else  if (service_id == kns_srv_id)
        0x0081045e:    7a33        3z      LDRB     r3,[r6,#8]
        0x00810460:    4298        .B      CMP      r0,r3
        0x00810462:    d12e        ..      BNE      0x8104c2 ; app_profile_callback + 350
        0x00810464:    7808        .x      LDRB     r0,[r1,#0]
;;;584        {
;;;585            T_KNS_CALLBACK_DATA *p_kns_cb_data = (T_KNS_CALLBACK_DATA *)p_data;
        0x00810466:    460e        .F      MOV      r6,r1
;;;586            switch (p_kns_cb_data->msg_type)
        0x00810468:    2801        .(      CMP      r0,#1
        0x0081046a:    d004        ..      BEQ      0x810476 ; app_profile_callback + 274
        0x0081046c:    2802        .(      CMP      r0,#2
        0x0081046e:    d00e        ..      BEQ      0x81048e ; app_profile_callback + 298
        0x00810470:    2803        .(      CMP      r0,#3
        0x00810472:    d17d        }.      BNE      0x810570 ; app_profile_callback + 524
        0x00810474:    e01b        ..      B        0x8104ae ; app_profile_callback + 330
;;;587            {
;;;588            case SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION:
;;;589                {
;;;590                    switch (p_kns_cb_data->msg_data.notification_indification_index)
        0x00810476:    7908        .y      LDRB     r0,[r1,#4]
        0x00810478:    b128        (.      CBZ      r0,0x810486 ; app_profile_callback + 290
        0x0081047a:    2801        .(      CMP      r0,#1
        0x0081047c:    d178        x.      BNE      0x810570 ; app_profile_callback + 524
;;;591                    {
;;;592                    case KNS_NOTIFY_ENABLE:
;;;593                        {
;;;594                            APP_PRINT_INFO0("KNS_NOTIFY_ENABLE");
        0x0081047e:    4960        `I      LDR      r1,[pc,#384] ; [0x810600] = 0x8800e2c
        0x00810480:    2200        ."      MOVS     r2,#0
        0x00810482:    3114        .1      ADDS     r1,r1,#0x14
;;;595                        }
;;;596                        break;
        0x00810484:    e033        3.      B        0x8104ee ; app_profile_callback + 394
;;;597    
;;;598                    case KNS_NOTIFY_DISABLE:
;;;599                        {
;;;600                            APP_PRINT_INFO0("KNS_NOTIFY_DISABLE");
        0x00810486:    495e        ^I      LDR      r1,[pc,#376] ; [0x810600] = 0x8800e2c
        0x00810488:    2200        ."      MOVS     r2,#0
        0x0081048a:    312c        ,1      ADDS     r1,r1,#0x2c
;;;601                        }
;;;602                        break;
        0x0081048c:    e02f        /.      B        0x8104ee ; app_profile_callback + 394
;;;603                    default:
;;;604                        break;
;;;605                    }
;;;606                }
;;;607                break;
;;;608    
;;;609            case SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE:
;;;610                {
;;;611                    if (p_kns_cb_data->msg_data.read_index == KNS_READ_PARA)
        0x0081048e:    7908        .y      LDRB     r0,[r1,#4]
        0x00810490:    2802        .(      CMP      r0,#2
        0x00810492:    d16d        m.      BNE      0x810570 ; app_profile_callback + 524
;;;612                    {
;;;613                        APP_PRINT_INFO0("KNS_READ_PARA");
        0x00810494:    495a        ZI      LDR      r1,[pc,#360] ; [0x810600] = 0x8800e2c
        0x00810496:    2200        ."      MOVS     r2,#0
        0x00810498:    3144        D1      ADDS     r1,r1,#0x44
        0x0081049a:    4638        8F      MOV      r0,r7
        0x0081049c:    f7f7dadf    ....    BL       log_buffer ; 0x7a5e
;;;614                        kns_set_parameter(KNS_PARAM_VALUE, 4, &gTimeParaValue);
        0x008104a0:    4a56        VJ      LDR      r2,[pc,#344] ; [0x8105fc] = 0x207fa8
        0x008104a2:    2104        .!      MOVS     r1,#4
        0x008104a4:    1d12        ..      ADDS     r2,r2,#4
        0x008104a6:    2000        .       MOVS     r0,#0
        0x008104a8:    f7fff960    ..`.    BL       kns_set_parameter ; 0x80f76c
        0x008104ac:    e060        `.      B        0x810570 ; app_profile_callback + 524
;;;615                    }
;;;616                }
;;;617                break;
;;;618            case SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE:
;;;619                {
;;;620                    APP_PRINT_INFO1("KNS_WRITE_PARA %x", p_kns_cb_data->msg_data.write_value);
        0x008104ae:    4954        TI      LDR      r1,[pc,#336] ; [0x810600] = 0x8800e2c
        0x008104b0:    2201        ."      MOVS     r2,#1
        0x008104b2:    3158        X1      ADDS     r1,r1,#0x58
        0x008104b4:    4638        8F      MOV      r0,r7
        0x008104b6:    6873        sh      LDR      r3,[r6,#4]
        0x008104b8:    f7f7dad1    ....    BL       log_buffer ; 0x7a5e
;;;621                    gTimeParaValue = p_kns_cb_data->msg_data.write_value;
        0x008104bc:    6870        ph      LDR      r0,[r6,#4]
;;;622                }
;;;623                break;
        0x008104be:    6060        ``      STR      r0,[r4,#4]
        0x008104c0:    e056        V.      B        0x810570 ; app_profile_callback + 524
;;;624    
;;;625            default:
;;;626                break;
;;;627            }
;;;628        }
;;;629        else if (service_id == bas_srv_id)
        0x008104c2:    7a73        sz      LDRB     r3,[r6,#9]
        0x008104c4:    4298        .B      CMP      r0,r3
        0x008104c6:    d128        (.      BNE      0x81051a ; app_profile_callback + 438
;;;630        {
;;;631            T_BAS_CALLBACK_DATA *p_bas_cb_data = (T_BAS_CALLBACK_DATA *)p_data;
;;;632            switch (p_bas_cb_data->msg_type)
        0x008104c8:    7848        Hx      LDRB     r0,[r1,#1]
        0x008104ca:    2801        .(      CMP      r0,#1
        0x008104cc:    d002        ..      BEQ      0x8104d4 ; app_profile_callback + 368
        0x008104ce:    2802        .(      CMP      r0,#2
        0x008104d0:    d14e        N.      BNE      0x810570 ; app_profile_callback + 524
        0x008104d2:    e010        ..      B        0x8104f6 ; app_profile_callback + 402
;;;633            {
;;;634            case SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION:
;;;635                {
;;;636                    switch (p_bas_cb_data->msg_data.notification_indification_index)
        0x008104d4:    7888        .x      LDRB     r0,[r1,#2]
        0x008104d6:    2801        .(      CMP      r0,#1
        0x008104d8:    d002        ..      BEQ      0x8104e0 ; app_profile_callback + 380
        0x008104da:    2802        .(      CMP      r0,#2
        0x008104dc:    d148        H.      BNE      0x810570 ; app_profile_callback + 524
        0x008104de:    e003        ..      B        0x8104e8 ; app_profile_callback + 388
;;;637                    {
;;;638                    case BAS_NOTIFY_BATTERY_LEVEL_ENABLE:
;;;639                        {
;;;640                            APP_PRINT_INFO0("BAS_NOTIFY_BATTERY_LEVEL_ENABLE");
        0x008104e0:    4947        GI      LDR      r1,[pc,#284] ; [0x810600] = 0x8800e2c
        0x008104e2:    2200        ."      MOVS     r2,#0
        0x008104e4:    3170        p1      ADDS     r1,r1,#0x70
        0x008104e6:    e002        ..      B        0x8104ee ; app_profile_callback + 394
        0x008104e8:    4945        EI      LDR      r1,[pc,#276] ; [0x810600] = 0x8800e2c
        0x008104ea:    2200        ."      MOVS     r2,#0
        0x008104ec:    3194        .1      ADDS     r1,r1,#0x94
        0x008104ee:    4638        8F      MOV      r0,r7
        0x008104f0:    f7f7dab5    ....    BL       log_buffer ; 0x7a5e
        0x008104f4:    e03c        <.      B        0x810570 ; app_profile_callback + 524
;;;641                        }
;;;642                        break;
;;;643    
;;;644                    case BAS_NOTIFY_BATTERY_LEVEL_DISABLE:
;;;645                        {
;;;646                            APP_PRINT_INFO0("BAS_NOTIFY_BATTERY_LEVEL_DISABLE");
;;;647                        }
;;;648                        break;
;;;649                    default:
;;;650                        break;
;;;651                    }
;;;652                }
;;;653                break;
;;;654    
;;;655            case SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE:
;;;656                {
;;;657                    if (p_bas_cb_data->msg_data.read_value_index == BAS_READ_BATTERY_LEVEL)
        0x008104f6:    7888        .x      LDRB     r0,[r1,#2]
        0x008104f8:    2801        .(      CMP      r0,#1
        0x008104fa:    d139        9.      BNE      0x810570 ; app_profile_callback + 524
        0x008104fc:    4940        @I      LDR      r1,[pc,#256] ; [0x810600] = 0x8800e2c
;;;658                    {
;;;659                        uint8_t battery_level = 90;
        0x008104fe:    235a        Z#      MOVS     r3,#0x5a
        0x00810500:    f88d3000    ...0    STRB     r3,[sp,#0]
;;;660                        APP_PRINT_INFO1("BAS_READ_BATTERY_LEVEL: battery_level %d", battery_level);
        0x00810504:    2201        ."      MOVS     r2,#1
        0x00810506:    31b8        .1      ADDS     r1,r1,#0xb8
        0x00810508:    4638        8F      MOV      r0,r7
        0x0081050a:    f7f7daa8    ....    BL       log_buffer ; 0x7a5e
;;;661                        bas_set_parameter(BAS_PARAM_BATTERY_LEVEL, 1, &battery_level);
        0x0081050e:    2101        .!      MOVS     r1,#1
        0x00810510:    466a        jF      MOV      r2,sp
        0x00810512:    4608        .F      MOV      r0,r1
        0x00810514:    f7fff874    ..t.    BL       bas_set_parameter ; 0x80f600
;;;662                    }
        0x00810518:    e02a        *.      B        0x810570 ; app_profile_callback + 524
;;;663                }
;;;664                break;
;;;665            default:
;;;666                break;
;;;667            }
;;;668        }
;;;669        else if (service_id == dis_srv_id)
        0x0081051a:    7ab3        .z      LDRB     r3,[r6,#0xa]
        0x0081051c:    4298        .B      CMP      r0,r3
        0x0081051e:    d127        '.      BNE      0x810570 ; app_profile_callback + 524
;;;670        {
;;;671            T_DIS_CALLBACK_DATA *p_dis_cb_data = (T_DIS_CALLBACK_DATA *)p_data;
;;;672            switch (p_dis_cb_data->msg_type)
        0x00810520:    7808        .x      LDRB     r0,[r1,#0]
        0x00810522:    2802        .(      CMP      r0,#2
        0x00810524:    d124        $.      BNE      0x810570 ; app_profile_callback + 524
;;;673            {
;;;674            case SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE:
;;;675                {
;;;676                    if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_MANU_NAME_INDEX)
        0x00810526:    7889        .x      LDRB     r1,[r1,#2]
        0x00810528:    2901        .)      CMP      r1,#1
        0x0081052a:    d010        ..      BEQ      0x81054e ; app_profile_callback + 490
;;;677                    {
;;;678                        const uint8_t DISManufacturerName[] = "Realtek BT";
;;;679                        dis_set_parameter(DIS_PARAM_MANUFACTURER_NAME,
;;;680                                          sizeof(DISManufacturerName),
;;;681                                          (void *)DISManufacturerName);
;;;682    
;;;683                    }
;;;684                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_MODEL_NUM_INDEX)
        0x0081052c:    2902        .)      CMP      r1,#2
        0x0081052e:    d016        ..      BEQ      0x81055e ; app_profile_callback + 506
;;;685                    {
;;;686                        const uint8_t DISModelNumber[] = "Model Nbr 0.9";
;;;687                        dis_set_parameter(DIS_PARAM_MODEL_NUMBER,
;;;688                                          sizeof(DISModelNumber),
;;;689                                          (void *)DISModelNumber);
;;;690                    }
;;;691                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_SERIAL_NUM_INDEX)
        0x00810530:    2903        .)      CMP      r1,#3
        0x00810532:    d020         .      BEQ      0x810576 ; app_profile_callback + 530
        0x00810534:    2904        .)      CMP      r1,#4
        0x00810536:    d026        &.      BEQ      0x810586 ; app_profile_callback + 546
        0x00810538:    2905        .)      CMP      r1,#5
        0x0081053a:    d02d        -.      BEQ      0x810598 ; app_profile_callback + 564
        0x0081053c:    2906        .)      CMP      r1,#6
        0x0081053e:    d034        4.      BEQ      0x8105aa ; app_profile_callback + 582
        0x00810540:    2907        .)      CMP      r1,#7
        0x00810542:    d03b        ;.      BEQ      0x8105bc ; app_profile_callback + 600
        0x00810544:    2908        .)      CMP      r1,#8
        0x00810546:    d042        B.      BEQ      0x8105ce ; app_profile_callback + 618
        0x00810548:    2909        .)      CMP      r1,#9
        0x0081054a:    d049        I.      BEQ      0x8105e0 ; app_profile_callback + 636
        0x0081054c:    e010        ..      B        0x810570 ; app_profile_callback + 524
        0x0081054e:    a02d        -.      ADR      r0,{pc}+0xb6 ; 0x810604
        0x00810550:    c807        ..      LDM      r0,{r0-r2}
        0x00810552:    e88d0007    ....    STM      sp,{r0-r2}
        0x00810556:    210b        .!      MOVS     r1,#0xb
        0x00810558:    466a        jF      MOV      r2,sp
        0x0081055a:    2000        .       MOVS     r0,#0
        0x0081055c:    e006        ..      B        0x81056c ; app_profile_callback + 520
        0x0081055e:    a02c        ,.      ADR      r0,{pc}+0xb2 ; 0x810610
        0x00810560:    c80f        ..      LDM      r0,{r0-r3}
        0x00810562:    e88d000f    ....    STM      sp,{r0-r3}
        0x00810566:    466a        jF      MOV      r2,sp
        0x00810568:    210e        .!      MOVS     r1,#0xe
        0x0081056a:    2001        .       MOVS     r0,#1
        0x0081056c:    f7fff9bc    ....    BL       dis_set_parameter ; 0x80f8e8
        0x00810570:    4628        (F      MOV      r0,r5
        0x00810572:    b006        ..      ADD      sp,sp,#0x18
        0x00810574:    e5a6        ..      B        0x8100c4 ; app_handle_conn_state_evt + 244
;;;692                    {
;;;693                        const uint8_t DISSerialNumber[] = "RTKBeeSerialNum";
        0x00810576:    a02a        *.      ADR      r0,{pc}+0xaa ; 0x810620
        0x00810578:    c80f        ..      LDM      r0,{r0-r3}
        0x0081057a:    e88d000f    ....    STM      sp,{r0-r3}
;;;694                        dis_set_parameter(DIS_PARAM_SERIAL_NUMBER,
        0x0081057e:    2110        .!      MOVS     r1,#0x10
        0x00810580:    466a        jF      MOV      r2,sp
        0x00810582:    2002        .       MOVS     r0,#2
;;;695                                          sizeof(DISSerialNumber),
;;;696                                          (void *)DISSerialNumber);
;;;697    
;;;698                    }
        0x00810584:    e7f2        ..      B        0x81056c ; app_profile_callback + 520
;;;699                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_HARDWARE_REV_INDEX)
;;;700                    {
;;;701                        const uint8_t DISHardwareRev[] = "RTKBeeHardwareRev";
        0x00810586:    2214        ."      MOVS     r2,#0x14
        0x00810588:    a129        ).      ADR      r1,{pc}+0xa8 ; 0x810630
        0x0081058a:    4668        hF      MOV      r0,sp
        0x0081058c:    f449f50c    I...    BL       __aeabi_memcpy4 ; 0x59fa8
;;;702                        dis_set_parameter(DIS_PARAM_HARDWARE_REVISION,
        0x00810590:    2112        .!      MOVS     r1,#0x12
        0x00810592:    466a        jF      MOV      r2,sp
        0x00810594:    2003        .       MOVS     r0,#3
;;;703                                          sizeof(DISHardwareRev),
;;;704                                          (void *)DISHardwareRev);
;;;705                    }
        0x00810596:    e7e9        ..      B        0x81056c ; app_profile_callback + 520
;;;706                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_FIRMWARE_REV_INDEX)
;;;707                    {
;;;708                        const uint8_t DISFirmwareRev[] = "RTKBeeFirmwareRev";
        0x00810598:    2214        ."      MOVS     r2,#0x14
        0x0081059a:    a12a        *.      ADR      r1,{pc}+0xaa ; 0x810644
        0x0081059c:    4668        hF      MOV      r0,sp
        0x0081059e:    f449f503    I...    BL       __aeabi_memcpy4 ; 0x59fa8
;;;709                        dis_set_parameter(DIS_PARAM_FIRMWARE_REVISION,
        0x008105a2:    2112        .!      MOVS     r1,#0x12
        0x008105a4:    466a        jF      MOV      r2,sp
        0x008105a6:    2004        .       MOVS     r0,#4
;;;710                                          sizeof(DISFirmwareRev),
;;;711                                          (void *)DISFirmwareRev);
;;;712                    }
        0x008105a8:    e7e0        ..      B        0x81056c ; app_profile_callback + 520
;;;713                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_SOFTWARE_REV_INDEX)
;;;714                    {
;;;715                        const uint8_t DISSoftwareRev[] = "RTKBeeSoftwareRev";
        0x008105aa:    2214        ."      MOVS     r2,#0x14
        0x008105ac:    a12a        *.      ADR      r1,{pc}+0xac ; 0x810658
        0x008105ae:    4668        hF      MOV      r0,sp
        0x008105b0:    f449f4fa    I...    BL       __aeabi_memcpy4 ; 0x59fa8
;;;716                        dis_set_parameter(DIS_PARAM_SOFTWARE_REVISION,
        0x008105b4:    2112        .!      MOVS     r1,#0x12
        0x008105b6:    466a        jF      MOV      r2,sp
        0x008105b8:    2005        .       MOVS     r0,#5
;;;717                                          sizeof(DISSoftwareRev),
;;;718                                          (void *)DISSoftwareRev);
;;;719                    }
        0x008105ba:    e7d7        ..      B        0x81056c ; app_profile_callback + 520
;;;720                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_SYSTEM_ID_INDEX)
;;;721                    {
;;;722                        const uint8_t DISSystemID[DIS_SYSTEM_ID_LENGTH] = {0, 1, 2, 0, 0, 3, 4, 5};
        0x008105bc:    a02b        +.      ADR      r0,{pc}+0xb0 ; 0x81066c
        0x008105be:    466a        jF      MOV      r2,sp
        0x008105c0:    e9d01000    ....    LDRD     r1,r0,[r0,#0]
;;;723                        dis_set_parameter(DIS_PARAM_SYSTEM_ID,
        0x008105c4:    e9cd1000    ....    STRD     r1,r0,[sp,#0]
        0x008105c8:    2108        .!      MOVS     r1,#8
        0x008105ca:    2006        .       MOVS     r0,#6
;;;724                                          sizeof(DISSystemID),
;;;725                                          (void *)DISSystemID);
;;;726    
;;;727                    }
        0x008105cc:    e7ce        ..      B        0x81056c ; app_profile_callback + 520
;;;728                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_IEEE_CERT_STR_INDEX)
;;;729                    {
;;;730                        const uint8_t DISIEEEDataList[] = "RTKBeeIEEEDatalist";
        0x008105ce:    2214        ."      MOVS     r2,#0x14
        0x008105d0:    a128        (.      ADR      r1,{pc}+0xa4 ; 0x810674
        0x008105d2:    4668        hF      MOV      r0,sp
        0x008105d4:    f449f4e8    I...    BL       __aeabi_memcpy4 ; 0x59fa8
;;;731                        dis_set_parameter(DIS_PARAM_IEEE_DATA_LIST,
        0x008105d8:    2113        .!      MOVS     r1,#0x13
        0x008105da:    466a        jF      MOV      r2,sp
        0x008105dc:    2007        .       MOVS     r0,#7
;;;732                                          sizeof(DISIEEEDataList),
;;;733                                          (void *)DISIEEEDataList);
;;;734                    }
        0x008105de:    e7c5        ..      B        0x81056c ; app_profile_callback + 520
;;;735                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_PNP_ID_INDEX)
;;;736                    {
;;;737                        uint8_t DISPnpID[DIS_PNP_ID_LENGTH] = {0};
        0x008105e0:    9200        ..      STR      r2,[sp,#0]
;;;738                        dis_set_parameter(DIS_PARAM_PNP_ID,
        0x008105e2:    9201        ..      STR      r2,[sp,#4]
        0x008105e4:    2107        .!      MOVS     r1,#7
        0x008105e6:    466a        jF      MOV      r2,sp
        0x008105e8:    2008        .       MOVS     r0,#8
;;;739                                          sizeof(DISPnpID),
;;;740                                          DISPnpID);
;;;741                    }
        0x008105ea:    e7bf        ..      B        0x81056c ; app_profile_callback + 520
    $d
        0x008105ec:    088006f0    ....    DCD    142608112
        0x008105f0:    21103002    .0.!    DCD    554708994
        0x008105f4:    08800d14    ....    DCD    142609684
        0x008105f8:    002081d0    .. .    DCD    2130384
        0x008105fc:    00207fa8    .. .    DCD    2129832
        0x00810600:    08800e2c    ,...    DCD    142609964
        0x00810604:    6c616552    Real    DCD    1818322258
        0x00810608:    206b6574    tek     DCD    543909236
        0x0081060c:    00005442    BT..    DCD    21570
        0x00810610:    65646f4d    Mode    DCD    1701080909
        0x00810614:    624e206c    l Nb    DCD    1649287276
        0x00810618:    2e302072    r 0.    DCD    774905970
        0x0081061c:    00000039    9...    DCD    57
        0x00810620:    424b5452    RTKB    DCD    1112233042
        0x00810624:    65536565    eeSe    DCD    1699964261
        0x00810628:    6c616972    rial    DCD    1818323314
        0x0081062c:    006d754e    Num.    DCD    7173454
        0x00810630:    424b5452    RTKB    DCD    1112233042
        0x00810634:    61486565    eeHa    DCD    1632134501
        0x00810638:    61776472    rdwa    DCD    1635214450
        0x0081063c:    65526572    reRe    DCD    1699898738
        0x00810640:    00000076    v...    DCD    118
        0x00810644:    424b5452    RTKB    DCD    1112233042
        0x00810648:    69466565    eeFi    DCD    1766221157
        0x0081064c:    61776d72    rmwa    DCD    1635216754
        0x00810650:    65526572    reRe    DCD    1699898738
        0x00810654:    00000076    v...    DCD    118
        0x00810658:    424b5452    RTKB    DCD    1112233042
        0x0081065c:    6f536565    eeSo    DCD    1867736421
        0x00810660:    61777466    ftwa    DCD    1635218534
        0x00810664:    65526572    reRe    DCD    1699898738
        0x00810668:    00000076    v...    DCD    118
        0x0081066c:    00020100    ....    DCD    131328
        0x00810670:    05040300    ....    DCD    84148992
        0x00810674:    424b5452    RTKB    DCD    1112233042
        0x00810678:    45496565    eeIE    DCD    1162437989
        0x0081067c:    61444545    EEDa    DCD    1631864133
        0x00810680:    696c6174    tali    DCD    1768710516
        0x00810684:    00007473    st..    DCD    29811
    $t
    .text
    load_overlay
;;; .\..\source\app\overlay_mgr.c
;;;116    {
        0x00810688:    b510        ..      PUSH     {r4,lr}
        0x0081068a:    2803        .(      CMP      r0,#3
;;; .\..\source\app\overlay_mgr.c (116)
        0x0081068c:    d301        ..      BCC      0x810692 ; load_overlay + 10
;;;117        const T_OVERLAY_SECTION *selected_scenario;
;;;118    
;;;119        if (scenario_idx >= OVERLAY_SCENARIO_NUM)
;;;120        {
;;;121            return false;
        0x0081068e:    2000        .       MOVS     r0,#0
        0x00810690:    bd10        ..      POP      {r4,pc}
;;;122        }
;;;123    
;;;124        selected_scenario = &overlay_sections[scenario_idx];
        0x00810692:    491a        .I      LDR      r1,[pc,#104] ; [0x8106fc] = 0x207fb0
        0x00810694:    eb0000c0    ....    ADD      r0,r0,r0,LSL #3
        0x00810698:    eb010480    ....    ADD      r4,r1,r0,LSL #2
;;;125    
;;;126        if (memcmp(selected_scenario->signature, scenario_name, 8) == 0)
        0x0081069c:    2208        ."      MOVS     r2,#8
        0x0081069e:    4918        .I      LDR      r1,[pc,#96] ; [0x810700] = 0x2081dc
        0x008106a0:    6820         h      LDR      r0,[r4,#0]
        0x008106a2:    f449f3af    I...    BL       memcmp ; 0x59e04
        0x008106a6:    b198        ..      CBZ      r0,0x8106d0 ; load_overlay + 72
;;;127        {
;;;128            return true;
;;;129        }
;;;130    
;;;131        /* load code */
;;;132        memcpy(selected_scenario->image_ro_base, selected_scenario->load_ro_base,
        0x008106a8:    69a2        .i      LDR      r2,[r4,#0x18]
        0x008106aa:    6861        ah      LDR      r1,[r4,#4]
        0x008106ac:    68e0        .h      LDR      r0,[r4,#0xc]
        0x008106ae:    f449f3f4    I...    BL       __aeabi_memcpy ; 0x59e9a
;;;133               selected_scenario->ro_length);
;;;134        /* load rw data */
;;;135        memcpy(selected_scenario->image_rw_base, selected_scenario->load_rw_base,
        0x008106b2:    69e2        .i      LDR      r2,[r4,#0x1c]
        0x008106b4:    68a1        .h      LDR      r1,[r4,#8]
        0x008106b6:    6920         i      LDR      r0,[r4,#0x10]
        0x008106b8:    f449f3ef    I...    BL       __aeabi_memcpy ; 0x59e9a
;;;136               selected_scenario->rw_length);
;;;137        /* clear zi data */
;;;138        memset(selected_scenario->image_zi_base, 0x0, selected_scenario->zi_length);
        0x008106bc:    6a21        !j      LDR      r1,[r4,#0x20]
        0x008106be:    6960        `i      LDR      r0,[r4,#0x14]
        0x008106c0:    f449f4ac    I...    BL       __aeabi_memclr ; 0x5a01c
;;;139    
;;;140        memcpy(scenario_name, selected_scenario->signature, 8);
        0x008106c4:    6820         h      LDR      r0,[r4,#0]
        0x008106c6:    490e        .I      LDR      r1,[pc,#56] ; [0x810700] = 0x2081dc
        0x008106c8:    6802        .h      LDR      r2,[r0,#0]
        0x008106ca:    600a        .`      STR      r2,[r1,#0]
        0x008106cc:    6840        @h      LDR      r0,[r0,#4]
        0x008106ce:    6048        H`      STR      r0,[r1,#4]
        0x008106d0:    2001        .       MOVS     r0,#1
;;;141    
;;;142        return true;
;;;143    }
        0x008106d2:    bd10        ..      POP      {r4,pc}
    get_current_scenario_index
;;;144    
;;;145    T_OVERLAY_SCENARIO_IDX get_current_scenario_index(void)
;;;146    {
        0x008106d4:    b570        p.      PUSH     {r4-r6,lr}
        0x008106d6:    4d09        .M      LDR      r5,[pc,#36] ; [0x8106fc] = 0x207fb0
;;;147        const T_OVERLAY_SECTION *selected_scenario;
;;;148    
;;;149        for (int i = 0; i < (int)OVERLAY_SCENARIO_NUM; ++i)
        0x008106d8:    2400        .$      MOVS     r4,#0
        0x008106da:    eb0400c4    ....    ADD      r0,r4,r4,LSL #3
        0x008106de:    2208        ."      MOVS     r2,#8
        0x008106e0:    f8550020    U. .    LDR      r0,[r5,r0,LSL #2]
        0x008106e4:    4906        .I      LDR      r1,[pc,#24] ; [0x810700] = 0x2081dc
        0x008106e6:    f449f38d    I...    BL       memcmp ; 0x59e04
        0x008106ea:    b120         .      CBZ      r0,0x8106f6 ; get_current_scenario_index + 34
        0x008106ec:    1c64        d.      ADDS     r4,r4,#1
        0x008106ee:    2c03        .,      CMP      r4,#3
        0x008106f0:    dbf3        ..      BLT      0x8106da ; get_current_scenario_index + 6
        0x008106f2:    2003        .       MOVS     r0,#3
        0x008106f4:    bd70        p.      POP      {r4-r6,pc}
;;;150        {
;;;151            selected_scenario = &overlay_sections[i];
;;;152            if (memcmp(selected_scenario->signature, scenario_name, 8) == 0)
;;;153            {
;;;154                return (T_OVERLAY_SCENARIO_IDX)i;
        0x008106f6:    b2e0        ..      UXTB     r0,r4
;;;155            }
;;;156        }
;;;157    
;;;158        return OVERLAY_SCENARIO_NUM; //not found valid scenario
;;;159    }
        0x008106f8:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x008106fa:    0000        ..      DCW    0
        0x008106fc:    00207fb0    .. .    DCD    2129840
        0x00810700:    002081dc    .. .    DCD    2130396
    $t
    .text
    $v0
    ADC_Handler
    BTMAC_Handler
    BusFault_Handler
    DebugMon_Handler
    Default_Handler
    GDMA0_Channel0_Handler
    GDMA0_Channel1_Handler
    GDMA0_Channel2_Handler
    GDMA0_Channel3_Handler
    GDMA0_Channel4_Handler
    GDMA0_Channel5_Handler
    GPIO0_Handler
    GPIO10_Handler
    GPIO11_Handler
    GPIO12_Handler
    GPIO13_Handler
    GPIO14_Handler
    GPIO15_Handler
    GPIO16_Handler
    GPIO17_Handler
    GPIO18_Handler
    GPIO19_Handler
    GPIO1_Handler
    GPIO21_Handler
    GPIO22_Handler
    GPIO23_Handler
    GPIO24_Handler
    GPIO25_Handler
    GPIO26_Handler
    GPIO27_Handler
    GPIO28_Handler
    GPIO29_Handler
    GPIO2_Handler
    GPIO30_Handler
    GPIO31_Handler
    GPIO3_Handler
    GPIO4_Handler
    GPIO5_Handler
    GPIO6_Handler
    GPIO7_Handler
    GPIO8_Handler
    GPIO9_Handler
    HardFault_Handler
    I2C0_Handler
    I2C1_Handler
    I2S0_RX_Handler
    I2S0_TX_Handler
    I2S1_RX_Handler
    I2S1_TX_Handler
    IR_Handler
    Keyscan_Handler
    LCD_Handler
    LPCOMP_Handler
    MemManage_Handler
    NMI_Handler
    PTA_Mailbox_Handler
    PendSV_Handler
    Peripheral_Handler
    Qdecode_Handler
    RTC_Handler
    SPI0_Handler
    SPI1_Handler
    SPI2W_Handler
    SPI_Flash_Handler
    SVC_Handler
    SysTick_Handler
    Timer2_Handler
    Timer3_Handler
    Timer4_7_Handler
    Timer4_Handler
    Timer5_Handler
    Timer6_Handler
    Timer7_Handler
    UART0_Handler
    UART1_Handler
    UART2_Handler
    UsageFault_Handler
    WDG_Handler
;;; ..\\source\\app\\startup_rtl8762c.s
;;;276                    LDR    R0, =0x20000000
        0x00810704:    f04f5000    O..P    MOV      r0,#0x20000000
;;;277                    LDR    R1, =DEFAULT_HANDLER_TXT
        0x00810708:    4910        .I      LDR      r1,[pc,#64] ; [0x81074c] = 0x810716
;;;278                    MRS    R2, IPSR
        0x0081070a:    f3ef8205    ....    MRS      r2,IPSR
;;;279                    LDR    R3, =log_direct
        0x0081070e:    4b10        .K      LDR      r3,[pc,#64] ; [0x810750] = 0x79b1
;;;280                    BLX    R3
        0x00810710:    4798        .G      BLX      r3
;;;281                    B      .
        0x00810712:    e7fe        ..      B        0x810712 ; ADC_Handler + 14
    __user_setup_stackheap
;;;282    
;;;283                    ENDP
;;;284    
;;;285    
;;;286    ; User Initial Stack
;;;287                    EXPORT  __user_setup_stackheap
;;;288    __user_setup_stackheap PROC
;;;289                    BX      LR
        0x00810714:    4770        pG      BX       lr
    $d
    DEFAULT_HANDLER_TXT
        0x00810716:    7245        Er      DCW    29253
        0x00810718:    21726f72    ror!    DCD    561147762
        0x0081071c:    656c5020     Ple    DCD    1701597216
        0x00810720:    20657361    ase     DCD    543519585
        0x00810724:    6c706d69    impl    DCD    1819307369
        0x00810728:    6e656d65    emen    DCD    1852140901
        0x0081072c:    6f792074    t yo    DCD    1870209140
        0x00810730:    49207275    ur I    DCD    1226863221
        0x00810734:    48205253    SR H    DCD    1210077779
        0x00810738:    6c646e61    andl    DCD    1818521185
        0x0081073c:    66207265    er f    DCD    1713402469
        0x00810740:    4920726f    or I    DCD    1226863215
        0x00810744:    25205152    RQ %    DCD    622874962
        0x00810748:    000a2164    d!..    DCD    663908
        0x0081074c:    00810716    ....    DCD    8455958
        0x00810750:    000079b1    .y..    DCD    31153
    $t
    .text
    gap_lib_handle_btif_msg
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (31)
        0x00810754:    b510        ..      PUSH     {r4,lr}
        0x00810756:    2201        ."      MOVS     r2,#1
        0x00810758:    700a        .p      STRB     r2,[r1,#0]
        0x0081075a:    8841        A.      LDRH     r1,[r0,#2]
        0x0081075c:    2400        .$      MOVS     r4,#0
        0x0081075e:    290e        .)      CMP      r1,#0xe
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (31)
        0x00810760:    d004        ..      BEQ      0x81076c ; gap_lib_handle_btif_msg + 24
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (35)
        0x00810762:    290f        .)      CMP      r1,#0xf
        0x00810764:    d00b        ..      BEQ      0x81077e ; gap_lib_handle_btif_msg + 42
        0x00810766:    2922        ")      CMP      r1,#0x22
        0x00810768:    d10c        ..      BNE      0x810784 ; gap_lib_handle_btif_msg + 48
        0x0081076a:    e003        ..      B        0x810774 ; gap_lib_handle_btif_msg + 32
        0x0081076c:    1d00        ..      ADDS     r0,r0,#4
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (39)
        0x0081076e:    f000f962    ..b.    BL       le_handle_vendor_cmd_rsp ; 0x810a36
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (40)
        0x00810772:    e007        ..      B        0x810784 ; gap_lib_handle_btif_msg + 48
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (44)
        0x00810774:    8880        ..      LDRH     r0,[r0,#4]
        0x00810776:    f000f850    ..P.    BL       le_handle_sw_reset_rsp ; 0x81081a
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (45)
        0x0081077a:    2401        .$      MOVS     r4,#1
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (46)
        0x0081077c:    e002        ..      B        0x810784 ; gap_lib_handle_btif_msg + 48
        0x0081077e:    1d00        ..      ADDS     r0,r0,#4
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (109)
        0x00810780:    f000f985    ....    BL       le_handle_vendor_evt_info ; 0x810a8e
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (117)
        0x00810784:    4620         F      MOV      r0,r4
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (118)
        0x00810786:    bd10        ..      POP      {r4,pc}
    gap_lib_init
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (121)
        0x00810788:    b530        0.      PUSH     {r4,r5,lr}
        0x0081078a:    b087        ..      SUB      sp,sp,#0x1c
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (122)
        0x0081078c:    2000        .       MOVS     r0,#0
        0x0081078e:    9005        ..      STR      r0,[sp,#0x14]
        0x00810790:    2401        .$      MOVS     r4,#1
        0x00810792:    9006        ..      STR      r0,[sp,#0x18]
        0x00810794:    e9cd4000    ...@    STRD     r4,r0,[sp,#0]
        0x00810798:    4d0f        .M      LDR      r5,[pc,#60] ; [0x8107d8] = 0x21103500
        0x0081079a:    9003        ..      STR      r0,[sp,#0xc]
        0x0081079c:    9004        ..      STR      r0,[sp,#0x10]
        0x0081079e:    9002        ..      STR      r0,[sp,#8]
        0x008107a0:    230d        .#      MOVS     r3,#0xd
        0x008107a2:    2208        ."      MOVS     r2,#8
        0x008107a4:    490b        .I      LDR      r1,[pc,#44] ; [0x8107d4] = 0x8800f10
        0x008107a6:    4628        (F      MOV      r0,r5
        0x008107a8:    f7f7d959    ..Y.    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (126)
        0x008107ac:    4909        .I      LDR      r1,[pc,#36] ; [0x8107d4] = 0x8800f10
        0x008107ae:    9401        ..      STR      r4,[sp,#4]
        0x008107b0:    9402        ..      STR      r4,[sp,#8]
        0x008107b2:    9403        ..      STR      r4,[sp,#0xc]
        0x008107b4:    9404        ..      STR      r4,[sp,#0x10]
        0x008107b6:    2300        .#      MOVS     r3,#0
        0x008107b8:    2206        ."      MOVS     r2,#6
        0x008107ba:    31f0        .1      ADDS     r1,r1,#0xf0
        0x008107bc:    4628        (F      MOV      r0,r5
        0x008107be:    9400        ..      STR      r4,[sp,#0]
        0x008107c0:    f7f7d94d    ..M.    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (129)
        0x008107c4:    f2af0073    ..s.    ADR      r0,{pc}-0x6f ; 0x810755
        0x008107c8:    b007        ..      ADD      sp,sp,#0x1c
        0x008107ca:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x008107ce:    f43bb31f    ;...    B        gap_register_extend_cb ; 0x4be10
    $d
        0x008107d2:    0000        ..      DCW    0
        0x008107d4:    08800f10    ....    DCD    142610192
        0x008107d8:    21103500    .5.!    DCD    554710272
    $t
    .text
    gap_sw_reset_req
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (123)
        0x008107dc:    b570        p.      PUSH     {r4-r6,lr}
        0x008107de:    2402        .$      MOVS     r4,#2
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (123)
        0x008107e0:    4605        .F      MOV      r5,r0
        0x008107e2:    2801        .(      CMP      r0,#1
        0x008107e4:    d002        ..      BEQ      0x8107ec ; gap_sw_reset_req + 16
        0x008107e6:    2403        .$      MOVS     r4,#3
        0x008107e8:    4620         F      MOV      r0,r4
        0x008107ea:    bd70        p.      POP      {r4-r6,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (127)
        0x008107ec:    f43df1c0    =...    BL       le_get_active_link_num ; 0x4db70
        0x008107f0:    2800        .(      CMP      r0,#0
        0x008107f2:    d1f9        ..      BNE      0x8107e8 ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (128)
        0x008107f4:    4873        sH      LDR      r0,[pc,#460] ; [0x8109c4] = 0x202e38
        0x008107f6:    7801        .x      LDRB     r1,[r0,#0]
        0x008107f8:    07c8        ..      LSLS     r0,r1,#31
        0x008107fa:    d0f5        ..      BEQ      0x8107e8 ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (129)
        0x008107fc:    f0110f0c    ....    TST      r1,#0xc
        0x00810800:    d0f2        ..      BEQ      0x8107e8 ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (130)
        0x00810802:    f0110f30    ..0.    TST      r1,#0x30
        0x00810806:    d1ef        ..      BNE      0x8107e8 ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (131)
        0x00810808:    0988        ..      LSRS     r0,r1,#6
        0x0081080a:    d1ed        ..      BNE      0x8107e8 ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (133)
        0x0081080c:    4628        (F      MOV      r0,r5
        0x0081080e:    f410f768    ..h.    BL       btif_sw_reset_req ; 0x216e2
        0x00810812:    2800        .(      CMP      r0,#0
        0x00810814:    d0e8        ..      BEQ      0x8107e8 ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (135)
        0x00810816:    2400        .$      MOVS     r4,#0
        0x00810818:    e7e6        ..      B        0x8107e8 ; gap_sw_reset_req + 12
    le_handle_sw_reset_rsp
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (147)
        0x0081081a:    b538        8.      PUSH     {r3-r5,lr}
        0x0081081c:    0004        ..      MOVS     r4,r0
        0x0081081e:    d107        ..      BNE      0x810830 ; le_handle_sw_reset_rsp + 22
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (150)
        0x00810820:    4968        hI      LDR      r1,[pc,#416] ; [0x8109c4] = 0x202e38
        0x00810822:    7808        .x      LDRB     r0,[r1,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (151)
        0x00810824:    f020000e     ...    BIC      r0,r0,#0xe
        0x00810828:    7008        .p      STRB     r0,[r1,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (152)
        0x0081082a:    20fc        .       MOVS     r0,#0xfc
        0x0081082c:    f43cf349    <.I.    BL       gap_send_dev_state ; 0x4cec2
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (154)
        0x00810830:    4865        eH      LDR      r0,[pc,#404] ; [0x8109c8] = 0x202e48
        0x00810832:    6802        .h      LDR      r2,[r0,#0]
        0x00810834:    2a00        .*      CMP      r2,#0
        0x00810836:    d004        ..      BEQ      0x810842 ; le_handle_sw_reset_rsp + 40
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (157)
        0x00810838:    f8ad4000    ...@    STRH     r4,[sp,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (158)
        0x0081083c:    4669        iF      MOV      r1,sp
        0x0081083e:    20a5        .       MOVS     r0,#0xa5
        0x00810840:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (160)
        0x00810842:    bd38        8.      POP      {r3-r5,pc}
    le_check_privacy_bond
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (166)
        0x00810844:    b530        0.      PUSH     {r4,r5,lr}
        0x00810846:    b08b        ..      SUB      sp,sp,#0x2c
        0x00810848:    f04f0100    O...    MOV      r1,#0
        0x0081084c:    4d5f        _M      LDR      r5,[pc,#380] ; [0x8109cc] = 0x21103502
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (166)
        0x0081084e:    0004        ..      MOVS     r4,r0
        0x00810850:    9106        ..      STR      r1,[sp,#0x18]
        0x00810852:    9107        ..      STR      r1,[sp,#0x1c]
        0x00810854:    9108        ..      STR      r1,[sp,#0x20]
        0x00810856:    9109        ..      STR      r1,[sp,#0x24]
        0x00810858:    d002        ..      BEQ      0x810860 ; le_check_privacy_bond + 28
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (169)
        0x0081085a:    7820         x      LDRB     r0,[r4,#0]
        0x0081085c:    2801        .(      CMP      r0,#1
        0x0081085e:    d008        ..      BEQ      0x810872 ; le_check_privacy_bond + 46
        0x00810860:    2301        .#      MOVS     r3,#1
        0x00810862:    2201        ."      MOVS     r2,#1
        0x00810864:    495a        ZI      LDR      r1,[pc,#360] ; [0x8109d0] = 0x88010d4
        0x00810866:    4628        (F      MOV      r0,r5
        0x00810868:    f7f7d8f9    ....    BL       log_buffer ; 0x7a5e
        0x0081086c:    2000        .       MOVS     r0,#0
        0x0081086e:    b00b        ..      ADD      sp,sp,#0x2c
        0x00810870:    bd30        0.      POP      {r4,r5,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (171)
        0x00810872:    78a0        .x      LDRB     r0,[r4,#2]
        0x00810874:    0700        ..      LSLS     r0,r0,#28
        0x00810876:    d518        ..      BPL      0x8108aa ; le_check_privacy_bond + 102
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (174)
        0x00810878:    466a        jF      MOV      r2,sp
        0x0081087a:    2114        .!      MOVS     r1,#0x14
        0x0081087c:    4620         F      MOV      r0,r4
        0x0081087e:    f43ff571    ?.q.    BL       le_get_key ; 0x50364
        0x00810882:    b180        ..      CBZ      r0,0x8108a6 ; le_check_privacy_bond + 98
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (176)
        0x00810884:    2210        ."      MOVS     r2,#0x10
        0x00810886:    a906        ..      ADD      r1,sp,#0x18
        0x00810888:    4668        hF      MOV      r0,sp
        0x0081088a:    f449f2bb    I...    BL       memcmp ; 0x59e04
        0x0081088e:    b140        @.      CBZ      r0,0x8108a2 ; le_check_privacy_bond + 94
        0x00810890:    494f        OI      LDR      r1,[pc,#316] ; [0x8109d0] = 0x88010d4
        0x00810892:    7863        cx      LDRB     r3,[r4,#1]
        0x00810894:    2201        ."      MOVS     r2,#1
        0x00810896:    3930        09      SUBS     r1,r1,#0x30
        0x00810898:    4628        (F      MOV      r0,r5
        0x0081089a:    f7f7d8e0    ....    BL       log_buffer ; 0x7a5e
        0x0081089e:    2001        .       MOVS     r0,#1
        0x008108a0:    e7e5        ..      B        0x81086e ; le_check_privacy_bond + 42
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (178)
        0x008108a2:    2305        .#      MOVS     r3,#5
        0x008108a4:    e7dd        ..      B        0x810862 ; le_check_privacy_bond + 30
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (188)
        0x008108a6:    2304        .#      MOVS     r3,#4
        0x008108a8:    e7db        ..      B        0x810862 ; le_check_privacy_bond + 30
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (193)
        0x008108aa:    2302        .#      MOVS     r3,#2
        0x008108ac:    e7d9        ..      B        0x810862 ; le_check_privacy_bond + 30
    le_bond_just_work_confirm
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (205)
        0x008108ae:    460a        .F      MOV      r2,r1
        0x008108b0:    eb000140    ..@.    ADD      r1,r0,r0,LSL #1
        0x008108b4:    4847        GH      LDR      r0,[pc,#284] ; [0x8109d4] = 0x202e64
        0x008108b6:    b510        ..      PUSH     {r4,lr}
        0x008108b8:    6800        .h      LDR      r0,[r0,#0]
        0x008108ba:    eb001001    ....    ADD      r0,r0,r1,LSL #4
        0x008108be:    7801        .x      LDRB     r1,[r0,#0]
        0x008108c0:    b129        ).      CBZ      r1,0x8108ce ; le_bond_just_work_confirm + 32
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (208)
        0x008108c2:    7981        .y      LDRB     r1,[r0,#6]
        0x008108c4:    1dc0        ..      ADDS     r0,r0,#7
        0x008108c6:    f410f6c8    ....    BL       btif_just_work_req_cfm ; 0x2165a
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (210)
        0x008108ca:    2000        .       MOVS     r0,#0
        0x008108cc:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (214)
        0x008108ce:    2004        .       MOVS     r0,#4
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (216)
        0x008108d0:    bd10        ..      POP      {r4,pc}
    le_gen_rand_addr
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (220)
        0x008108d2:    b5f0        ..      PUSH     {r4-r7,lr}
        0x008108d4:    b085        ..      SUB      sp,sp,#0x14
        0x008108d6:    460c        .F      MOV      r4,r1
        0x008108d8:    0005        ..      MOVS     r5,r0
        0x008108da:    d006        ..      BEQ      0x8108ea ; le_gen_rand_addr + 24
        0x008108dc:    f411f409    ....    BL       btif_le_gen_rand_addr ; 0x220f2
        0x008108e0:    2800        .(      CMP      r0,#0
        0x008108e2:    d048        H.      BEQ      0x810976 ; le_gen_rand_addr + 164
        0x008108e4:    2000        .       MOVS     r0,#0
        0x008108e6:    b005        ..      ADD      sp,sp,#0x14
        0x008108e8:    bdf0        ..      POP      {r4-r7,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (224)
        0x008108ea:    2600        .&      MOVS     r6,#0
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (226)
        0x008108ec:    b384        ..      CBZ      r4,0x810950 ; le_gen_rand_addr + 126
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (232)
        0x008108ee:    f7fdff15    ....    BL       rand ; 0x80e71c
        0x008108f2:    7020         p      STRB     r0,[r4,#0]
        0x008108f4:    1c67        g.      ADDS     r7,r4,#1
        0x008108f6:    f7fdff11    ....    BL       rand ; 0x80e71c
        0x008108fa:    0a00        ..      LSRS     r0,r0,#8
        0x008108fc:    7038        8p      STRB     r0,[r7,#0]
        0x008108fe:    f7fdff0d    ....    BL       rand ; 0x80e71c
        0x00810902:    0c00        ..      LSRS     r0,r0,#16
        0x00810904:    7078        xp      STRB     r0,[r7,#1]
        0x00810906:    f7fdff09    ....    BL       rand ; 0x80e71c
        0x0081090a:    0e00        ..      LSRS     r0,r0,#24
        0x0081090c:    70b8        .p      STRB     r0,[r7,#2]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (233)
        0x0081090e:    f7fdff05    ....    BL       rand ; 0x80e71c
        0x00810912:    70f8        .p      STRB     r0,[r7,#3]
        0x00810914:    f7fdff02    ....    BL       rand ; 0x80e71c
        0x00810918:    0a00        ..      LSRS     r0,r0,#8
        0x0081091a:    7138        8q      STRB     r0,[r7,#4]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (235)
        0x0081091c:    f04000c0    @...    ORR      r0,r0,#0xc0
        0x00810920:    7160        `q      STRB     r0,[r4,#5]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (236)
        0x00810922:    a02d        -.      ADR      r0,{pc}+0xb6 ; 0x8109d8
        0x00810924:    2206        ."      MOVS     r2,#6
        0x00810926:    e9d01000    ....    LDRD     r1,r0,[r0,#0]
        0x0081092a:    e9cd1001    ....    STRD     r1,r0,[sp,#4]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (237)
        0x0081092e:    a02c        ,.      ADR      r0,{pc}+0xb2 ; 0x8109e0
        0x00810930:    e9d01000    ....    LDRD     r1,r0,[r0,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (238)
        0x00810934:    e9cd1003    ....    STRD     r1,r0,[sp,#0xc]
        0x00810938:    a901        ..      ADD      r1,sp,#4
        0x0081093a:    4620         F      MOV      r0,r4
        0x0081093c:    f449f262    I.b.    BL       memcmp ; 0x59e04
        0x00810940:    b148        H.      CBZ      r0,0x810956 ; le_gen_rand_addr + 132
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (239)
        0x00810942:    2206        ."      MOVS     r2,#6
        0x00810944:    a903        ..      ADD      r1,sp,#0xc
        0x00810946:    4620         F      MOV      r0,r4
        0x00810948:    f449f25c    I.\.    BL       memcmp ; 0x59e04
        0x0081094c:    b118        ..      CBZ      r0,0x810956 ; le_gen_rand_addr + 132
        0x0081094e:    e004        ..      B        0x81095a ; le_gen_rand_addr + 136
        0x00810950:    e7ff        ..      B        0x810952 ; le_gen_rand_addr + 128
        0x00810952:    2003        .       MOVS     r0,#3
        0x00810954:    e7c7        ..      B        0x8108e6 ; le_gen_rand_addr + 20
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (241)
        0x00810956:    2066        f       MOVS     r0,#0x66
        0x00810958:    7020         p      STRB     r0,[r4,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (243)
        0x0081095a:    4621        !F      MOV      r1,r4
        0x0081095c:    4822        "H      LDR      r0,[pc,#136] ; [0x8109e8] = 0x21300000
        0x0081095e:    f7f7da3b    ..;.    BL       trace_bdaddr ; 0x7dd8
        0x00810962:    491b        .I      LDR      r1,[pc,#108] ; [0x8109d0] = 0x88010d4
        0x00810964:    4603        .F      MOV      r3,r0
        0x00810966:    2202        ."      MOVS     r2,#2
        0x00810968:    3138        81      ADDS     r1,r1,#0x38
        0x0081096a:    4818        .H      LDR      r0,[pc,#96] ; [0x8109cc] = 0x21103502
        0x0081096c:    9500        ..      STR      r5,[sp,#0]
        0x0081096e:    f7f7d876    ..v.    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (245)
        0x00810972:    4630        0F      MOV      r0,r6
        0x00810974:    e7b7        ..      B        0x8108e6 ; le_gen_rand_addr + 20
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (251)
        0x00810976:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (252)
        0x00810978:    e7b5        ..      B        0x8108e6 ; le_gen_rand_addr + 20
    le_bond_get_sec_level
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (266)
        0x0081097a:    b510        ..      PUSH     {r4,lr}
        0x0081097c:    b08a        ..      SUB      sp,sp,#0x28
        0x0081097e:    460c        .F      MOV      r4,r1
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (269)
        0x00810980:    2100        .!      MOVS     r1,#0
        0x00810982:    7021        !p      STRB     r1,[r4,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (270)
        0x00810984:    aa09        ..      ADD      r2,sp,#0x24
        0x00810986:    a907        ..      ADD      r1,sp,#0x1c
        0x00810988:    f43df131    =.1.    BL       le_get_conn_addr ; 0x4dbee
        0x0081098c:    b1c0        ..      CBZ      r0,0x8109c0 ; le_bond_get_sec_level + 70
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (273)
        0x0081098e:    f89d1024    ..$.    LDRB     r1,[sp,#0x24]
        0x00810992:    a807        ..      ADD      r0,sp,#0x1c
        0x00810994:    f43ff3fb    ?...    BL       le_find_key_entry ; 0x5018e
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (274)
        0x00810998:    b190        ..      CBZ      r0,0x8109c0 ; le_bond_get_sec_level + 70
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (277)
        0x0081099a:    466a        jF      MOV      r2,sp
        0x0081099c:    2111        .!      MOVS     r1,#0x11
        0x0081099e:    f43ff4e1    ?...    BL       le_get_key ; 0x50364
        0x008109a2:    b168        h.      CBZ      r0,0x8109c0 ; le_bond_get_sec_level + 70
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (279)
        0x008109a4:    490a        .I      LDR      r1,[pc,#40] ; [0x8109d0] = 0x88010d4
        0x008109a6:    f89d301b    ...0    LDRB     r3,[sp,#0x1b]
        0x008109aa:    2201        ."      MOVS     r2,#1
        0x008109ac:    3174        t1      ADDS     r1,r1,#0x74
        0x008109ae:    4807        .H      LDR      r0,[pc,#28] ; [0x8109cc] = 0x21103502
        0x008109b0:    f7f7d855    ..U.    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (280)
        0x008109b4:    f89d001b    ....    LDRB     r0,[sp,#0x1b]
        0x008109b8:    7020         p      STRB     r0,[r4,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (281)
        0x008109ba:    2000        .       MOVS     r0,#0
        0x008109bc:    b00a        ..      ADD      sp,sp,#0x28
        0x008109be:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (285)
        0x008109c0:    2003        .       MOVS     r0,#3
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (286)
        0x008109c2:    e7fb        ..      B        0x8109bc ; le_bond_get_sec_level + 66
    $d
        0x008109c4:    00202e38    8. .    DCD    2108984
        0x008109c8:    00202e48    H. .    DCD    2109000
        0x008109cc:    21103502    .5.!    DCD    554710274
        0x008109d0:    088010d4    ....    DCD    142610644
        0x008109d4:    00202e64    d. .    DCD    2109028
        0x008109d8:    00000000    ....    DCD    0
        0x008109dc:    0000c000    ....    DCD    49152
        0x008109e0:    ffffffff    ....    DCD    4294967295
        0x008109e4:    0000ffff    ....    DCD    65535
        0x008109e8:    21300000    ..0!    DCD    556793856
    $t
    .text
    gap_set_lps_bootup_active_time
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (51)
        0x008109ec:    b508        ..      PUSH     {r3,lr}
        0x008109ee:    1ec1        ..      SUBS     r1,r0,#3
        0x008109f0:    f24072fe    @..r    MOV      r2,#0x7fe
        0x008109f4:    4291        .B      CMP      r1,r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (51)
        0x008109f6:    d301        ..      BCC      0x8109fc ; gap_set_lps_bootup_active_time + 16
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (56)
        0x008109f8:    2000        .       MOVS     r0,#0
        0x008109fa:    bd08        ..      POP      {r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (58)
        0x008109fc:    2105        .!      MOVS     r1,#5
        0x008109fe:    f88d1000    ....    STRB     r1,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (59)
        0x00810a02:    f88d0001    ....    STRB     r0,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (60)
        0x00810a06:    0a00        ..      LSRS     r0,r0,#8
        0x00810a08:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (62)
        0x00810a0c:    466a        jF      MOV      r2,sp
        0x00810a0e:    2103        .!      MOVS     r1,#3
        0x00810a10:    f64f406e    O.n@    MOV      r0,#0xfc6e
        0x00810a14:    f410f56a    ..j.    BL       btif_vendor_cmd_req ; 0x214ec
        0x00810a18:    2800        .(      CMP      r0,#0
        0x00810a1a:    d0ee        ..      BEQ      0x8109fa ; gap_set_lps_bootup_active_time + 14
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (64)
        0x00810a1c:    2001        .       MOVS     r0,#1
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (67)
        0x00810a1e:    bd08        ..      POP      {r3,pc}
    lps_get_wakeup_time
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (70)
        0x00810a20:    b530        0.      PUSH     {r4,r5,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (71)
        0x00810a22:    4b33        3K      LDR      r3,[pc,#204] ; [0x810af0] = 0x201b1c
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (72)
        0x00810a24:    681d        .h      LDR      r5,[r3,#0]
        0x00810a26:    1d1b        ..      ADDS     r3,r3,#4
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (73)
        0x00810a28:    681c        .h      LDR      r4,[r3,#0]
        0x00810a2a:    1d1b        ..      ADDS     r3,r3,#4
        0x00810a2c:    681b        .h      LDR      r3,[r3,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (75)
        0x00810a2e:    6005        .`      STR      r5,[r0,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (76)
        0x00810a30:    600c        .`      STR      r4,[r1,#0]
        0x00810a32:    6013        .`      STR      r3,[r2,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (77)
        0x00810a34:    bd30        0.      POP      {r4,r5,pc}
    le_handle_vendor_cmd_rsp
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (177)
        0x00810a36:    b538        8.      PUSH     {r3-r5,lr}
        0x00810a38:    4604        .F      MOV      r4,r0
        0x00810a3a:    8800        ..      LDRH     r0,[r0,#0]
        0x00810a3c:    f64f456e    O.nE    MOV      r5,#0xfc6e
        0x00810a40:    42a8        .B      CMP      r0,r5
        0x00810a42:    d108        ..      BNE      0x810a56 ; le_handle_vendor_cmd_rsp + 32
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (267)
        0x00810a44:    8860        `.      LDRH     r0,[r4,#2]
        0x00810a46:    f8ad0000    ....    STRH     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (268)
        0x00810a4a:    482a        *H      LDR      r0,[pc,#168] ; [0x810af4] = 0x202e48
        0x00810a4c:    6802        .h      LDR      r2,[r0,#0]
        0x00810a4e:    b112        ..      CBZ      r2,0x810a56 ; le_handle_vendor_cmd_rsp + 32
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (270)
        0x00810a50:    4669        iF      MOV      r1,sp
        0x00810a52:    20a6        .       MOVS     r0,#0xa6
        0x00810a54:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (276)
        0x00810a56:    8820         .      LDRH     r0,[r4,#0]
        0x00810a58:    f5a0417d    ..}A    SUB      r1,r0,#0xfd00
        0x00810a5c:    3980        .9      SUBS     r1,r1,#0x80
        0x00810a5e:    d00d        ..      BEQ      0x810a7c ; le_handle_vendor_cmd_rsp + 70
        0x00810a60:    1e49        I.      SUBS     r1,r1,#1
        0x00810a62:    d00b        ..      BEQ      0x810a7c ; le_handle_vendor_cmd_rsp + 70
        0x00810a64:    1e49        I.      SUBS     r1,r1,#1
        0x00810a66:    d009        ..      BEQ      0x810a7c ; le_handle_vendor_cmd_rsp + 70
        0x00810a68:    42a8        .B      CMP      r0,r5
        0x00810a6a:    d007        ..      BEQ      0x810a7c ; le_handle_vendor_cmd_rsp + 70
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (279)
        0x00810a6c:    4822        "H      LDR      r0,[pc,#136] ; [0x810af8] = 0x202df4
        0x00810a6e:    6802        .h      LDR      r2,[r0,#0]
        0x00810a70:    2a00        .*      CMP      r2,#0
        0x00810a72:    d003        ..      BEQ      0x810a7c ; le_handle_vendor_cmd_rsp + 70
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (282)
        0x00810a74:    2003        .       MOVS     r0,#3
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (284)
        0x00810a76:    4669        iF      MOV      r1,sp
        0x00810a78:    9400        ..      STR      r4,[sp,#0]
        0x00810a7a:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (287)
        0x00810a7c:    bd38        8.      POP      {r3-r5,pc}
    gap_vendor_cmd_req
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (291)
        0x00810a7e:    b510        ..      PUSH     {r4,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (292)
        0x00810a80:    f410f534    ..4.    BL       btif_vendor_cmd_req ; 0x214ec
        0x00810a84:    b108        ..      CBZ      r0,0x810a8a ; gap_vendor_cmd_req + 12
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (294)
        0x00810a86:    2000        .       MOVS     r0,#0
        0x00810a88:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (296)
        0x00810a8a:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (297)
        0x00810a8c:    bd10        ..      POP      {r4,pc}
    le_handle_vendor_evt_info
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (300)
        0x00810a8e:    4601        .F      MOV      r1,r0
        0x00810a90:    4819        .H      LDR      r0,[pc,#100] ; [0x810af8] = 0x202df4
        0x00810a92:    b508        ..      PUSH     {r3,lr}
        0x00810a94:    6802        .h      LDR      r2,[r0,#0]
        0x00810a96:    2a00        .*      CMP      r2,#0
        0x00810a98:    d003        ..      BEQ      0x810aa2 ; le_handle_vendor_evt_info + 20
        0x00810a9a:    9100        ..      STR      r1,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (304)
        0x00810a9c:    2004        .       MOVS     r0,#4
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (306)
        0x00810a9e:    4669        iF      MOV      r1,sp
        0x00810aa0:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (308)
        0x00810aa2:    bd08        ..      POP      {r3,pc}
    le_vendor_modify_bt_le_fw_policy
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (313)
        0x00810aa4:    b50e        ..      PUSH     {r1-r3,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (316)
        0x00810aa6:    2210        ."      MOVS     r2,#0x10
        0x00810aa8:    f88d2000    ...     STRB     r2,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (317)
        0x00810aac:    f88d0001    ....    STRB     r0,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (318)
        0x00810ab0:    0a02        ..      LSRS     r2,r0,#8
        0x00810ab2:    f88d2002    ...     STRB     r2,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (319)
        0x00810ab6:    0c02        ..      LSRS     r2,r0,#16
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (320)
        0x00810ab8:    0e00        ..      LSRS     r0,r0,#24
        0x00810aba:    f88d0004    ....    STRB     r0,[sp,#4]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (321)
        0x00810abe:    f88d1005    ....    STRB     r1,[sp,#5]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (322)
        0x00810ac2:    0a08        ..      LSRS     r0,r1,#8
        0x00810ac4:    f88d0006    ....    STRB     r0,[sp,#6]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (323)
        0x00810ac8:    0c08        ..      LSRS     r0,r1,#16
        0x00810aca:    f88d0007    ....    STRB     r0,[sp,#7]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (324)
        0x00810ace:    0e08        ..      LSRS     r0,r1,#24
        0x00810ad0:    f88d2003    ...     STRB     r2,[sp,#3]
        0x00810ad4:    f88d0008    ....    STRB     r0,[sp,#8]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (326)
        0x00810ad8:    466a        jF      MOV      r2,sp
        0x00810ada:    2109        .!      MOVS     r1,#9
        0x00810adc:    f64f5080    O..P    MOV      r0,#0xfd80
        0x00810ae0:    f410f504    ....    BL       btif_vendor_cmd_req ; 0x214ec
        0x00810ae4:    b108        ..      CBZ      r0,0x810aea ; le_vendor_modify_bt_le_fw_policy + 70
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (328)
        0x00810ae6:    2000        .       MOVS     r0,#0
        0x00810ae8:    bd0e        ..      POP      {r1-r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (330)
        0x00810aea:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (337)
        0x00810aec:    bd0e        ..      POP      {r1-r3,pc}
    $d
        0x00810aee:    0000        ..      DCW    0
        0x00810af0:    00201b1c    .. .    DCD    2104092
        0x00810af4:    00202e48    H. .    DCD    2109000
        0x00810af8:    00202df4    .- .    DCD    2108916
    $t
    .text
    srand
        0x00810afc:    490b        .I      LDR      r1,[pc,#44] ; [0x810b2c] = 0x208260
        0x00810afe:    b510        ..      PUSH     {r4,lr}
        0x00810b00:    f1a1027c    ..|.    SUB      r2,r1,#0x7c
        0x00810b04:    4c0a        .L      LDR      r4,[pc,#40] ; [0x810b30] = 0x66d619e1
        0x00810b06:    e9c21237    ..7.    STRD     r1,r2,[r2,#0xdc]
        0x00810b0a:    2137        7!      MOVS     r1,#0x37
        0x00810b0c:    e006        ..      B        0x810b1c ; srand + 32
        0x00810b0e:    eb004310    ...C    ADD      r3,r0,r0,LSR #16
        0x00810b12:    f8423021    B.!0    STR      r3,[r2,r1,LSL #2]
        0x00810b16:    4b07        .K      LDR      r3,[pc,#28] ; [0x810b34] = 0x10dcd
        0x00810b18:    fb004003    ...@    MLA      r0,r0,r3,r4
        0x00810b1c:    1e0b        ..      SUBS     r3,r1,#0
        0x00810b1e:    f1a10101    ....    SUB      r1,r1,#1
        0x00810b22:    dcf4        ..      BGT      0x810b0e ; srand + 18
        0x00810b24:    bd10        ..      POP      {r4,pc}
    _rand_init
        0x00810b26:    2001        .       MOVS     r0,#1
        0x00810b28:    e7e8        ..      B        srand ; 0x810afc
    $d
        0x00810b2a:    0000        ..      DCW    0
        0x00810b2c:    00208260    `. .    DCD    2130528
        0x00810b30:    66d619e1    ...f    DCD    1725307361
        0x00810b34:    00010dcd    ....    DCD    69069
    $t
    x$fpl$fpinit
    $v0
    _fp_init
        0x00810b38:    f04f7040    O.@p    MOV      r0,#0x3000000
        0x00810b3c:    eee10a10    ....    VMSR     FPSCR,r0
    __fplib_config_fpu_vfp
    __fplib_config_pureend_doubles
        0x00810b40:    4770        pG      BX       lr
        0x00810b42:    0000        ..      MOVS     r0,r0
    $d.realdata
    .constdata
    app_cb_table
        0x00810b44:    0e85d101    ....    DCD    243650817
        0x00810b48:    00000006    ....    DCD    6
        0x00810b4c:    0080e815    ....    DCD    8448021
        0x00810b50:    00000000    ....    DCD    0
        0x00810b54:    00000000    ....    DCD    0
        0x00810b58:    00000000    ....    DCD    0
        0x00810b5c:    00000000    ....    DCD    0
        0x00810b60:    0080e825    %...    DCD    8448037
    .constdata
    __func__
        0x00810b64:    6c6c616d    mall    DCD    1819042157
        0x00810b68:    636f        oc      DCW    25455
        0x00810b6a:    00          .       DCB    0
    __func__
        0x00810b6b:    63          c       DCB    99
        0x00810b6c:    6f6c6c61    allo    DCD    1869376609
        0x00810b70:    0063        c.      DCW    99
    __func__
        0x00810b72:    6572        re      DCW    25970
        0x00810b74:    6f6c6c61    allo    DCD    1869376609
        0x00810b78:    00000063    c...    DCD    99
        0x00810b7c:    0081127c    |...    DCD    8458876
        0x00810b80:    00811328    (...    DCD    8459048
        0x00810b84:    00811270    p...    DCD    8458864
        0x00810b88:    00811330    0...    DCD    8459056
        0x00810b8c:    008112d4    ....    DCD    8458964
        0x00810b90:    00811348    H...    DCD    8459080
        0x00810b94:    0081133c    <...    DCD    8459068
        0x00810b98:    008112c4    ....    DCD    8458948
        0x00810b9c:    008112c4    ....    DCD    8458948
        0x00810ba0:    008112c4    ....    DCD    8458948
        0x00810ba4:    008112c4    ....    DCD    8458948
        0x00810ba8:    00811264    d...    DCD    8458852
        0x00810bac:    0081131c    ....    DCD    8459036
        0x00810bb0:    008112c4    ....    DCD    8458948
        0x00810bb4:    0081128c    ....    DCD    8458892
        0x00810bb8:    008112ec    ....    DCD    8458988
        0x00810bbc:    00811300    ....    DCD    8459008
        0x00810bc0:    0081126c    l...    DCD    8458860
        0x00810bc4:    00811254    T...    DCD    8458836
        0x00810bc8:    008111d4    ....    DCD    8458708
        0x00810bcc:    008111a8    ....    DCD    8458664
        0x00810bd0:    00811308    ....    DCD    8459016
        0x00810bd4:    008112bc    ....    DCD    8458940
        0x00810bd8:    008112a8    ....    DCD    8458920
        0x00810bdc:    00811240    @...    DCD    8458816
        0x00810be0:    00811200    ....    DCD    8458752
        0x00810be4:    00811220     ...    DCD    8458784
        0x00810be8:    00811184    ....    DCD    8458628
        0x00810bec:    00811150    P...    DCD    8458576
        0x00810bf0:    00811260    `...    DCD    8458848
        0x00810bf4:    00811148    H...    DCD    8458568
        0x00810bf8:    0081117c    |...    DCD    8458620
        0x00810bfc:    00811140    @...    DCD    8458560
        0x00810c00:    00811174    t...    DCD    8458612
        0x00810c04:    0081125c    \...    DCD    8458844
        0x00810c08:    008112f4    ....    DCD    8458996
        0x00810c0c:    00811158    X...    DCD    8458584
        0x00810c10:    0081118c    ....    DCD    8458636
        0x00810c14:    008111b8    ....    DCD    8458680
        0x00810c18:    008111dc    ....    DCD    8458716
        0x00810c1c:    00811208    ....    DCD    8458760
        0x00810c20:    00811228    (...    DCD    8458792
        0x00810c24:    008111ec    ....    DCD    8458732
        0x00810c28:    008111c8    ....    DCD    8458696
        0x00810c2c:    00811288    ....    DCD    8458888
        0x00810c30:    0081119c    ....    DCD    8458652
        0x00810c34:    00811168    h...    DCD    8458600
        0x00810c38:    008111b0    ....    DCD    8458672
        0x00810c3c:    008111f8    ....    DCD    8458744
        0x00810c40:    00811218    ....    DCD    8458776
        0x00810c44:    00811238    8...    DCD    8458808
        0x00810c48:    0081124c    L...    DCD    8458828
        0x00810c4c:    008112e0    ....    DCD    8458976
        0x00810c50:    008112cc    ....    DCD    8458956
        0x00810c54:    00811314    ....    DCD    8459028
        0x00810c58:    00811294    ....    DCD    8458900
        0x00810c5c:    00811274    t...    DCD    8458868
        0x00810c60:    00811354    T...    DCD    8459092
        0x00810c64:    008112b0    ....    DCD    8458928
        0x00810c68:    0081129c    ....    DCD    8458908
        0x00810c6c:    00811268    h...    DCD    8458856
    .constdata
    __func__
        0x00810c70:    5f707061    app_    DCD    1601204321
        0x00810c74:    646e6573    send    DCD    1684956531
        0x00810c78:    67736d5f    _msg    DCD    1735617887
        0x00810c7c:    5f6f745f    _to_    DCD    1601139807
        0x00810c80:    74707061    appt    DCD    1953525857
        0x00810c84:    006b7361    ask.    DCD    7041889
    __func__
        0x00810c88:    5f707061    app_    DCD    1601204321
        0x00810c8c:    6e69616d    main    DCD    1852399981
        0x00810c90:    7361745f    _tas    DCD    1935766623
        0x00810c94:    0000006b    k...    DCD    107
    .constdata
    ias_attr_tbl
        0x00810c98:    28000802    ...(    DCD    671090690
        0x00810c9c:    00001802    ....    DCD    6146
        0x00810ca0:    00000000    ....    DCD    0
        0x00810ca4:    00000000    ....    DCD    0
        0x00810ca8:    00020000    ....    DCD    131072
        0x00810cac:    00000000    ....    DCD    0
        0x00810cb0:    00000001    ....    DCD    1
        0x00810cb4:    28030002    ...(    DCD    671285250
        0x00810cb8:    00000004    ....    DCD    4
        0x00810cbc:    00000000    ....    DCD    0
        0x00810cc0:    00000000    ....    DCD    0
        0x00810cc4:    00010000    ....    DCD    65536
        0x00810cc8:    00000000    ....    DCD    0
        0x00810ccc:    00000001    ....    DCD    1
        0x00810cd0:    2a060004    ...*    DCD    705036292
        0x00810cd4:    00000000    ....    DCD    0
        0x00810cd8:    00000000    ....    DCD    0
        0x00810cdc:    00000000    ....    DCD    0
        0x00810ce0:    00000000    ....    DCD    0
        0x00810ce4:    00000000    ....    DCD    0
        0x00810ce8:    00000011    ....    DCD    17
    ias_cbs
        0x00810cec:    00000000    ....    DCD    0
        0x00810cf0:    0080f36d    m...    DCD    8450925
        0x00810cf4:    00000000    ....    DCD    0
    .constdata
    lls_attr_tbl
        0x00810cf8:    28000802    ...(    DCD    671090690
        0x00810cfc:    00001803    ....    DCD    6147
        0x00810d00:    00000000    ....    DCD    0
        0x00810d04:    00000000    ....    DCD    0
        0x00810d08:    00020000    ....    DCD    131072
        0x00810d0c:    00000000    ....    DCD    0
        0x00810d10:    00000001    ....    DCD    1
        0x00810d14:    28030002    ...(    DCD    671285250
        0x00810d18:    0000000a    ....    DCD    10
        0x00810d1c:    00000000    ....    DCD    0
        0x00810d20:    00000000    ....    DCD    0
        0x00810d24:    00010000    ....    DCD    65536
        0x00810d28:    00000000    ....    DCD    0
        0x00810d2c:    00000001    ....    DCD    1
        0x00810d30:    2a060004    ...*    DCD    705036292
        0x00810d34:    00000000    ....    DCD    0
        0x00810d38:    00000000    ....    DCD    0
        0x00810d3c:    00000000    ....    DCD    0
        0x00810d40:    00000000    ....    DCD    0
        0x00810d44:    00000000    ....    DCD    0
        0x00810d48:    00000011    ....    DCD    17
    lls_cbs
        0x00810d4c:    0080f42f    /...    DCD    8451119
        0x00810d50:    0080f491    ....    DCD    8451217
        0x00810d54:    00000000    ....    DCD    0
    .constdata
    tps_attr_tbl
        0x00810d58:    28000802    ...(    DCD    671090690
        0x00810d5c:    00001804    ....    DCD    6148
        0x00810d60:    00000000    ....    DCD    0
        0x00810d64:    00000000    ....    DCD    0
        0x00810d68:    00020000    ....    DCD    131072
        0x00810d6c:    00000000    ....    DCD    0
        0x00810d70:    00000001    ....    DCD    1
        0x00810d74:    28030002    ...(    DCD    671285250
        0x00810d78:    00000002    ....    DCD    2
        0x00810d7c:    00000000    ....    DCD    0
        0x00810d80:    00000000    ....    DCD    0
        0x00810d84:    00010000    ....    DCD    65536
        0x00810d88:    00000000    ....    DCD    0
        0x00810d8c:    00000001    ....    DCD    1
        0x00810d90:    2a070004    ...*    DCD    705101828
        0x00810d94:    00000000    ....    DCD    0
        0x00810d98:    00000000    ....    DCD    0
        0x00810d9c:    00000000    ....    DCD    0
        0x00810da0:    00000000    ....    DCD    0
        0x00810da4:    00000000    ....    DCD    0
        0x00810da8:    00000001    ....    DCD    1
    tps_cbs
        0x00810dac:    0080f553    S...    DCD    8451411
        0x00810db0:    00000000    ....    DCD    0
        0x00810db4:    00000000    ....    DCD    0
    .constdata
    bas_attr_tbl
        0x00810db8:    28000802    ...(    DCD    671090690
        0x00810dbc:    0000180f    ....    DCD    6159
        0x00810dc0:    00000000    ....    DCD    0
        0x00810dc4:    00000000    ....    DCD    0
        0x00810dc8:    00020000    ....    DCD    131072
        0x00810dcc:    00000000    ....    DCD    0
        0x00810dd0:    00000001    ....    DCD    1
        0x00810dd4:    28030002    ...(    DCD    671285250
        0x00810dd8:    00000012    ....    DCD    18
        0x00810ddc:    00000000    ....    DCD    0
        0x00810de0:    00000000    ....    DCD    0
        0x00810de4:    00010000    ....    DCD    65536
        0x00810de8:    00000000    ....    DCD    0
        0x00810dec:    00000001    ....    DCD    1
        0x00810df0:    2a190004    ...*    DCD    706281476
        0x00810df4:    00000000    ....    DCD    0
        0x00810df8:    00000000    ....    DCD    0
        0x00810dfc:    00000000    ....    DCD    0
        0x00810e00:    00000000    ....    DCD    0
        0x00810e04:    00000000    ....    DCD    0
        0x00810e08:    00000001    ....    DCD    1
        0x00810e0c:    29020012    ...)    DCD    687996946
        0x00810e10:    00000000    ....    DCD    0
        0x00810e14:    00000000    ....    DCD    0
        0x00810e18:    00000000    ....    DCD    0
        0x00810e1c:    00020000    ....    DCD    131072
        0x00810e20:    00000000    ....    DCD    0
        0x00810e24:    00000011    ....    DCD    17
    bas_cbs
        0x00810e28:    0080f663    c...    DCD    8451683
        0x00810e2c:    00000000    ....    DCD    0
        0x00810e30:    0080f6cb    ....    DCD    8451787
    .constdata
    GATT_UUID128_KNS_SERVICE
        0x00810e34:    07f6f6a6    ....    DCD    133625510
        0x00810e38:    989dc44d    M...    DCD    2560476237
        0x00810e3c:    bb29456d    mE).    DCD    3140044141
        0x00810e40:    0000ffd0    ....    DCD    65488
    .constdata
    kns_attr_tbl
        0x00810e44:    28000800    ...(    DCD    671090688
        0x00810e48:    00000000    ....    DCD    0
        0x00810e4c:    00000000    ....    DCD    0
        0x00810e50:    00000000    ....    DCD    0
        0x00810e54:    00100000    ....    DCD    1048576
        0x00810e58:    00810e34    4...    DCD    8457780
        0x00810e5c:    00000001    ....    DCD    1
        0x00810e60:    28030002    ...(    DCD    671285250
        0x00810e64:    0000000a    ....    DCD    10
        0x00810e68:    00000000    ....    DCD    0
        0x00810e6c:    00000000    ....    DCD    0
        0x00810e70:    00010000    ....    DCD    65536
        0x00810e74:    00000000    ....    DCD    0
        0x00810e78:    00000001    ....    DCD    1
        0x00810e7c:    f6a60005    ....    DCD    4138074117
        0x00810e80:    c44d07f6    ..M.    DCD    3293382646
        0x00810e84:    456d989d    ..mE    DCD    1164810397
        0x00810e88:    ffd1bb29    )...    DCD    4291935017
        0x00810e8c:    00000000    ....    DCD    0
        0x00810e90:    00000000    ....    DCD    0
        0x00810e94:    00000011    ....    DCD    17
        0x00810e98:    28030002    ...(    DCD    671285250
        0x00810e9c:    00000010    ....    DCD    16
        0x00810ea0:    00000000    ....    DCD    0
        0x00810ea4:    00000000    ....    DCD    0
        0x00810ea8:    00010000    ....    DCD    65536
        0x00810eac:    00000000    ....    DCD    0
        0x00810eb0:    00000001    ....    DCD    1
        0x00810eb4:    f6a60005    ....    DCD    4138074117
        0x00810eb8:    c44d07f6    ..M.    DCD    3293382646
        0x00810ebc:    456d989d    ..mE    DCD    1164810397
        0x00810ec0:    ffd2bb29    )...    DCD    4292000553
        0x00810ec4:    00000000    ....    DCD    0
        0x00810ec8:    00000000    ....    DCD    0
        0x00810ecc:    00000001    ....    DCD    1
        0x00810ed0:    29020012    ...)    DCD    687996946
        0x00810ed4:    00000000    ....    DCD    0
        0x00810ed8:    00000000    ....    DCD    0
        0x00810edc:    00000000    ....    DCD    0
        0x00810ee0:    00020000    ....    DCD    131072
        0x00810ee4:    00000000    ....    DCD    0
        0x00810ee8:    00000011    ....    DCD    17
    kns_cbs
        0x00810eec:    0080f793    ....    DCD    8451987
        0x00810ef0:    0080f7f3    ....    DCD    8452083
        0x00810ef4:    0080f843    C...    DCD    8452163
    .constdata
    dis_attr_tbl
        0x00810ef8:    28000802    ...(    DCD    671090690
        0x00810efc:    0000180a    ....    DCD    6154
        0x00810f00:    00000000    ....    DCD    0
        0x00810f04:    00000000    ....    DCD    0
        0x00810f08:    00020000    ....    DCD    131072
        0x00810f0c:    00000000    ....    DCD    0
        0x00810f10:    00000001    ....    DCD    1
        0x00810f14:    28030002    ...(    DCD    671285250
        0x00810f18:    00000002    ....    DCD    2
        0x00810f1c:    00000000    ....    DCD    0
        0x00810f20:    00000000    ....    DCD    0
        0x00810f24:    00010000    ....    DCD    65536
        0x00810f28:    00000000    ....    DCD    0
        0x00810f2c:    00000001    ....    DCD    1
        0x00810f30:    2a290004    ..)*    DCD    707330052
        0x00810f34:    00000000    ....    DCD    0
        0x00810f38:    00000000    ....    DCD    0
        0x00810f3c:    00000000    ....    DCD    0
        0x00810f40:    00000000    ....    DCD    0
        0x00810f44:    00000000    ....    DCD    0
        0x00810f48:    00000001    ....    DCD    1
        0x00810f4c:    28030002    ...(    DCD    671285250
        0x00810f50:    00000002    ....    DCD    2
        0x00810f54:    00000000    ....    DCD    0
        0x00810f58:    00000000    ....    DCD    0
        0x00810f5c:    00010000    ....    DCD    65536
        0x00810f60:    00000000    ....    DCD    0
        0x00810f64:    00000001    ....    DCD    1
        0x00810f68:    2a240004    ..$*    DCD    707002372
        0x00810f6c:    00000000    ....    DCD    0
        0x00810f70:    00000000    ....    DCD    0
        0x00810f74:    00000000    ....    DCD    0
        0x00810f78:    00000000    ....    DCD    0
        0x00810f7c:    00000000    ....    DCD    0
        0x00810f80:    00000001    ....    DCD    1
        0x00810f84:    28030002    ...(    DCD    671285250
        0x00810f88:    00000002    ....    DCD    2
        0x00810f8c:    00000000    ....    DCD    0
        0x00810f90:    00000000    ....    DCD    0
        0x00810f94:    00010000    ....    DCD    65536
        0x00810f98:    00000000    ....    DCD    0
        0x00810f9c:    00000001    ....    DCD    1
        0x00810fa0:    2a250004    ..%*    DCD    707067908
        0x00810fa4:    00000000    ....    DCD    0
        0x00810fa8:    00000000    ....    DCD    0
        0x00810fac:    00000000    ....    DCD    0
        0x00810fb0:    00000000    ....    DCD    0
        0x00810fb4:    00000000    ....    DCD    0
        0x00810fb8:    00000001    ....    DCD    1
        0x00810fbc:    28030002    ...(    DCD    671285250
        0x00810fc0:    00000002    ....    DCD    2
        0x00810fc4:    00000000    ....    DCD    0
        0x00810fc8:    00000000    ....    DCD    0
        0x00810fcc:    00010000    ....    DCD    65536
        0x00810fd0:    00000000    ....    DCD    0
        0x00810fd4:    00000001    ....    DCD    1
        0x00810fd8:    2a270004    ..'*    DCD    707198980
        0x00810fdc:    00000000    ....    DCD    0
        0x00810fe0:    00000000    ....    DCD    0
        0x00810fe4:    00000000    ....    DCD    0
        0x00810fe8:    00000000    ....    DCD    0
        0x00810fec:    00000000    ....    DCD    0
        0x00810ff0:    00000001    ....    DCD    1
        0x00810ff4:    28030002    ...(    DCD    671285250
        0x00810ff8:    00000002    ....    DCD    2
        0x00810ffc:    00000000    ....    DCD    0
        0x00811000:    00000000    ....    DCD    0
        0x00811004:    00010000    ....    DCD    65536
        0x00811008:    00000000    ....    DCD    0
        0x0081100c:    00000001    ....    DCD    1
        0x00811010:    2a260004    ..&*    DCD    707133444
        0x00811014:    00000000    ....    DCD    0
        0x00811018:    00000000    ....    DCD    0
        0x0081101c:    00000000    ....    DCD    0
        0x00811020:    00000000    ....    DCD    0
        0x00811024:    00000000    ....    DCD    0
        0x00811028:    00000001    ....    DCD    1
        0x0081102c:    28030002    ...(    DCD    671285250
        0x00811030:    00000002    ....    DCD    2
        0x00811034:    00000000    ....    DCD    0
        0x00811038:    00000000    ....    DCD    0
        0x0081103c:    00010000    ....    DCD    65536
        0x00811040:    00000000    ....    DCD    0
        0x00811044:    00000001    ....    DCD    1
        0x00811048:    2a280004    ..(*    DCD    707264516
        0x0081104c:    00000000    ....    DCD    0
        0x00811050:    00000000    ....    DCD    0
        0x00811054:    00000000    ....    DCD    0
        0x00811058:    00000000    ....    DCD    0
        0x0081105c:    00000000    ....    DCD    0
        0x00811060:    00000001    ....    DCD    1
        0x00811064:    28030002    ...(    DCD    671285250
        0x00811068:    00000002    ....    DCD    2
        0x0081106c:    00000000    ....    DCD    0
        0x00811070:    00000000    ....    DCD    0
        0x00811074:    00010000    ....    DCD    65536
        0x00811078:    00000000    ....    DCD    0
        0x0081107c:    00000001    ....    DCD    1
        0x00811080:    2a230004    ..#*    DCD    706936836
        0x00811084:    00000000    ....    DCD    0
        0x00811088:    00000000    ....    DCD    0
        0x0081108c:    00000000    ....    DCD    0
        0x00811090:    00000000    ....    DCD    0
        0x00811094:    00000000    ....    DCD    0
        0x00811098:    00000001    ....    DCD    1
        0x0081109c:    28030002    ...(    DCD    671285250
        0x008110a0:    00000002    ....    DCD    2
        0x008110a4:    00000000    ....    DCD    0
        0x008110a8:    00000000    ....    DCD    0
        0x008110ac:    00010000    ....    DCD    65536
        0x008110b0:    00000000    ....    DCD    0
        0x008110b4:    00000001    ....    DCD    1
        0x008110b8:    2a2a0004    ..**    DCD    707395588
        0x008110bc:    00000000    ....    DCD    0
        0x008110c0:    00000000    ....    DCD    0
        0x008110c4:    00000000    ....    DCD    0
        0x008110c8:    00000000    ....    DCD    0
        0x008110cc:    00000000    ....    DCD    0
        0x008110d0:    00000001    ....    DCD    1
        0x008110d4:    28030002    ...(    DCD    671285250
        0x008110d8:    00000002    ....    DCD    2
        0x008110dc:    00000000    ....    DCD    0
        0x008110e0:    00000000    ....    DCD    0
        0x008110e4:    00010000    ....    DCD    65536
        0x008110e8:    00000000    ....    DCD    0
        0x008110ec:    00000001    ....    DCD    1
        0x008110f0:    2a500004    ..P*    DCD    709885956
        0x008110f4:    00000000    ....    DCD    0
        0x008110f8:    00000000    ....    DCD    0
        0x008110fc:    00000000    ....    DCD    0
        0x00811100:    00000000    ....    DCD    0
        0x00811104:    00000000    ....    DCD    0
        0x00811108:    00000001    ....    DCD    1
    dis_cbs
        0x0081110c:    0080f9b5    ....    DCD    8452533
        0x00811110:    00000000    ....    DCD    0
        0x00811114:    00000000    ....    DCD    0
    .constdata
        0x00811118:    4c414552    REAL    DCD    1279346002
        0x0081111c:    5058505f    _PXP    DCD    1347965023
        0x00811120:    00000000    ....    DCD    0
        0x00811124:    00000000    ....    DCD    0
        0x00811128:    00000000    ....    DCD    0
        0x0081112c:    00000000    ....    DCD    0
        0x00811130:    00000000    ....    DCD    0
        0x00811134:    00000000    ....    DCD    0
        0x00811138:    00000000    ....    DCD    0
        0x0081113c:    00000000    ....    DCD    0
    .conststring
        0x00811140:    30433249    I2C0    DCD    809710153
        0x00811144:    00000000    ....    DCD    0
        0x00811148:    30495053    SPI0    DCD    810111059
        0x0081114c:    00000000    ....    DCD    0
        0x00811150:    54524155    UART    DCD    1414676821
        0x00811154:    00000030    0...    DCD    48
        0x00811158:    414d4447    GDMA    DCD    1095582791
        0x0081115c:    68432030    0 Ch    DCD    1749229616
        0x00811160:    656e6e61    anne    DCD    1701736033
        0x00811164:    0000306c    l0..    DCD    12396
        0x00811168:    4f495047    GPIO    DCD    1330204743
        0x0081116c:    6f72475f    _Gro    DCD    1869760351
        0x00811170:    00307075    up0.    DCD    3174517
        0x00811174:    31433249    I2C1    DCD    826487369
        0x00811178:    00000000    ....    DCD    0
        0x0081117c:    31495053    SPI1    DCD    826888275
        0x00811180:    00000000    ....    DCD    0
        0x00811184:    54524155    UART    DCD    1414676821
        0x00811188:    00000031    1...    DCD    49
        0x0081118c:    414d4447    GDMA    DCD    1095582791
        0x00811190:    68432030    0 Ch    DCD    1749229616
        0x00811194:    656e6e61    anne    DCD    1701736033
        0x00811198:    0000316c    l1..    DCD    12652
        0x0081119c:    4f495047    GPIO    DCD    1330204743
        0x008111a0:    6f72475f    _Gro    DCD    1869760351
        0x008111a4:    00317075    up1.    DCD    3240053
        0x008111a8:    324d4954    TIM2    DCD    843925844
        0x008111ac:    00000000    ....    DCD    0
        0x008111b0:    54524155    UART    DCD    1414676821
        0x008111b4:    00000032    2...    DCD    50
        0x008111b8:    414d4447    GDMA    DCD    1095582791
        0x008111bc:    68432030    0 Ch    DCD    1749229616
        0x008111c0:    656e6e61    anne    DCD    1701736033
        0x008111c4:    0000326c    l2..    DCD    12908
        0x008111c8:    4f495047    GPIO    DCD    1330204743
        0x008111cc:    6f72475f    _Gro    DCD    1869760351
        0x008111d0:    00327075    up2.    DCD    3305589
        0x008111d4:    334d4954    TIM3    DCD    860703060
        0x008111d8:    00000000    ....    DCD    0
        0x008111dc:    414d4447    GDMA    DCD    1095582791
        0x008111e0:    68432030    0 Ch    DCD    1749229616
        0x008111e4:    656e6e61    anne    DCD    1701736033
        0x008111e8:    0000336c    l3..    DCD    13164
        0x008111ec:    4f495047    GPIO    DCD    1330204743
        0x008111f0:    6f72475f    _Gro    DCD    1869760351
        0x008111f4:    00337075    up3.    DCD    3371125
        0x008111f8:    344d4954    TIM4    DCD    877480276
        0x008111fc:    00000000    ....    DCD    0
        0x00811200:    4f495047    GPIO    DCD    1330204743
        0x00811204:    00000034    4...    DCD    52
        0x00811208:    414d4447    GDMA    DCD    1095582791
        0x0081120c:    68432030    0 Ch    DCD    1749229616
        0x00811210:    656e6e61    anne    DCD    1701736033
        0x00811214:    0000346c    l4..    DCD    13420
        0x00811218:    354d4954    TIM5    DCD    894257492
        0x0081121c:    00000000    ....    DCD    0
        0x00811220:    4f495047    GPIO    DCD    1330204743
        0x00811224:    00000035    5...    DCD    53
        0x00811228:    414d4447    GDMA    DCD    1095582791
        0x0081122c:    68432030    0 Ch    DCD    1749229616
        0x00811230:    656e6e61    anne    DCD    1701736033
        0x00811234:    0000356c    l5..    DCD    13676
        0x00811238:    364d4954    TIM6    DCD    911034708
        0x0081123c:    00000000    ....    DCD    0
        0x00811240:    656d6954    Time    DCD    1701669204
        0x00811244:    372d3472    r4-7    DCD    925709426
        0x00811248:    00000000    ....    DCD    0
        0x0081124c:    374d4954    TIM7    DCD    927811924
        0x00811250:    00000000    ....    DCD    0
        0x00811254:    414d5442    BTMA    DCD    1095586882
        0x00811258:    00000043    C...    DCD    67
        0x0081125c:    00434441    ADC.    DCD    4408385
        0x00811260:    00435452    RTC.    DCD    4412498
        0x00811264:    00435653    SVC.    DCD    4413011
        0x00811268:    0044434c    LCD.    DCD    4473676
        0x0081126c:    00474457    WDG.    DCD    4670551
        0x00811270:    00494d4e    NMI.    DCD    4803918
        0x00811274:    4f43504c    LPCO    DCD    1329811532
        0x00811278:    0000504d    MP..    DCD    20557
        0x0081127c:    74696e49    Init    DCD    1953066569
        0x00811280:    536c6169    ialS    DCD    1399611753
        0x00811284:    00000050    P...    DCD    80
        0x00811288:    00005249    IR..    DCD    21065
        0x0081128c:    646e6550    Pend    DCD    1684956496
        0x00811290:    00005653    SV..    DCD    22099
        0x00811294:    32495053    SPI2    DCD    843665491
        0x00811298:    00000057    W...    DCD    87
        0x0081129c:    524f5053    SPOR    DCD    1380929619
        0x008112a0:    52203154    T1 R    DCD    1377841492
        0x008112a4:    00000058    X...    DCD    88
        0x008112a8:    30533249    I2S0    DCD    810758729
        0x008112ac:    0058525f    _RX.    DCD    5788255
        0x008112b0:    524f5053    SPOR    DCD    1380929619
        0x008112b4:    54203154    T1 T    DCD    1411395924
        0x008112b8:    00000058    X...    DCD    88
        0x008112bc:    30533249    I2S0    DCD    810758729
        0x008112c0:    0058545f    _TX.    DCD    5788767
        0x008112c4:    64767352    Rsvd    DCD    1685484370
        0x008112c8:    00000000    ....    DCD    0
        0x008112cc:    63656451    Qdec    DCD    1667589201
        0x008112d0:    0065646f    ode.    DCD    6644847
        0x008112d4:    4d6d654d    MemM    DCD    1299014989
        0x008112d8:    67616e61    anag    DCD    1734438497
        0x008112dc:    00000065    e...    DCD    101
        0x008112e0:    5f495053    SPI_    DCD    1598640211
        0x008112e4:    73616c46    Flas    DCD    1935764550
        0x008112e8:    00000068    h...    DCD    104
        0x008112ec:    54737953    SysT    DCD    1416853843
        0x008112f0:    006b6369    ick.    DCD    7037801
        0x008112f4:    69726550    Peri    DCD    1769104720
        0x008112f8:    72656870    pher    DCD    1919248496
        0x008112fc:    00006c61    al..    DCD    27745
        0x00811300:    74737953    Syst    DCD    1953724755
        0x00811304:    00006d65    em..    DCD    28005
        0x00811308:    74616c50    Plat    DCD    1952541776
        0x0081130c:    6d726f66    form    DCD    1836216166
        0x00811310:    00000000    ....    DCD    0
        0x00811314:    7379654b    Keys    DCD    1937335627
        0x00811318:    006e6163    can.    DCD    7233891
        0x0081131c:    75626544    Debu    DCD    1969382724
        0x00811320:    6e6f4d67    gMon    DCD    1852788071
        0x00811324:    00000000    ....    DCD    0
        0x00811328:    65736552    Rese    DCD    1702061394
        0x0081132c:    00000074    t...    DCD    116
        0x00811330:    64726148    Hard    DCD    1685217608
        0x00811334:    6c756146    Faul    DCD    1819631942
        0x00811338:    00000074    t...    DCD    116
        0x0081133c:    67617355    Usag    DCD    1734439765
        0x00811340:    75614665    eFau    DCD    1969309285
        0x00811344:    0000746c    lt..    DCD    29804
        0x00811348:    46737542    BusF    DCD    1181971778
        0x0081134c:    746c7561    ault    DCD    1953264993
        0x00811350:    00000000    ....    DCD    0
        0x00811354:    5f415450    PTA_    DCD    1598116944
        0x00811358:    6c69614d    Mail    DCD    1818845517
        0x0081135c:    00786f62    box.    DCD    7892834
    .conststring
        0x00811360:    6e656353    Scen    DCD    1852138323
        0x00811364:    00425f65    e_B.    DCD    4349797
        0x00811368:    6e656353    Scen    DCD    1852138323
        0x0081136c:    00435f65    e_C.    DCD    4415333
        0x00811370:    746f6f42    Boot    DCD    1953460034
        0x00811374:    65636e4f    Once    DCD    1701015119
        0x00811378:    00000000    ....    DCD    0
    Region$$Table$$Base
        0x0081137c:    008113bc    ....    DCD    8459196
        0x00811380:    00200000    .. .    DCD    2097152
        0x00811384:    000000f4    ....    DCD    244
        0x00811388:    0080e444    D...    DCD    8447044
        0x0081138c:    008114b0    ....    DCD    8459440
        0x00811390:    00207c00    .| .    DCD    2128896
        0x00811394:    0000034c    L...    DCD    844
        0x00811398:    0080e444    D...    DCD    8447044
        0x0081139c:    008117fc    ....    DCD    8460284
        0x008113a0:    00207f4c    L. .    DCD    2129740
        0x008113a4:    000000d0    ....    DCD    208
        0x008113a8:    0080e444    D...    DCD    8447044
        0x008113ac:    008118cc    ....    DCD    8460492
        0x008113b0:    0020801c    .. .    DCD    2129948
        0x008113b4:    000002ac    ....    DCD    684
        0x008113b8:    0080e460    `...    DCD    8447072
    Region$$Table$$Limit

** Section #4 'RAM_VECTOR_TABLE' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 244 bytes (alignment 4)
    Address: 0x00200000

    0x200000:   00 38 20 00 01 e4 80 00 05 07 81 00 05 07 81 00    .8 .............
    0x200010:   05 07 81 00 05 07 81 00 05 07 81 00 00 00 00 00    ................
    0x200020:   00 00 00 00 00 00 00 00 00 00 00 00 05 07 81 00    ................
    0x200030:   05 07 81 00 00 00 00 00 05 07 81 00 05 07 81 00    ................
    0x200040:   29 fd 80 00 05 07 81 00 05 07 81 00 05 07 81 00    )...............
    0x200050:   05 07 81 00 05 07 81 00 05 07 81 00 05 07 81 00    ................
    0x200060:   05 07 81 00 05 07 81 00 05 07 81 00 05 07 81 00    ................
    0x200070:   05 07 81 00 05 07 81 00 05 07 81 00 05 07 81 00    ................
    0x200080:   05 07 81 00 05 07 81 00 05 07 81 00 05 07 81 00    ................
    0x200090:   05 07 81 00 05 07 81 00 05 07 81 00 05 07 81 00    ................
    0x2000a0:   05 07 81 00 05 07 81 00 01 7c 20 00 4d 7c 20 00    .........| .M| .
    0x2000b0:   05 07 81 00 99 7c 20 00 dd 7c 20 00 05 07 81 00    .....| ..| .....
    0x2000c0:   05 07 81 00 05 07 81 00 05 07 81 00 05 07 81 00    ................
    0x2000d0:   05 07 81 00 05 07 81 00 05 07 81 00 05 07 81 00    ................
    0x2000e0:   05 07 81 00 05 07 81 00 05 07 81 00 05 07 81 00    ................
    0x2000f0:   05 07 81 00                                        ....

    __Vectors_End

** Section #5 'RAM_DATA_ON' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 844 bytes (alignment 4)
    Address: 0x00207c00

    $t
    .ram.dataon.data
    GPIO_Group3_Handler
;;; .\..\source\cmsis\system_rtl8762c.c
;;;691    DATA_RAM_FUNCTION void GPIO_Group3_Handler(void)
;;;691    {
;;;691        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207c00:    4847        GH      LDR      r0,[pc,#284] ; [0x207d20] = 0x40001000
;;; .\..\source\cmsis\system_rtl8762c.c (690)
        0x00207c02:    b510        ..      PUSH     {r4,lr}
        0x00207c04:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207c06:    0720         .      LSLS     r0,r4,#28
        0x00207c08:    d501        ..      BPL      0x207c0e ; GPIO_Group3_Handler + 14
;;;691        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;692    
;;;693        //Check exact IRQ function
;;;694        if (GPIOIrqStatus & BIT3)
;;;695        {
;;;696            GPIO3_Handler();
        0x00207c0a:    f208f57b    ..{.    BL       ADC_Handler ; 0x810704
;;;697        }
;;;698        if (GPIOIrqStatus & BIT7)
        0x00207c0e:    0620         .      LSLS     r0,r4,#24
        0x00207c10:    d501        ..      BPL      0x207c16 ; GPIO_Group3_Handler + 22
;;;699        {
;;;700            GPIO7_Handler();
        0x00207c12:    f208f577    ..w.    BL       ADC_Handler ; 0x810704
;;;701        }
;;;702        if (GPIOIrqStatus & BIT11)
        0x00207c16:    0520         .      LSLS     r0,r4,#20
        0x00207c18:    d501        ..      BPL      0x207c1e ; GPIO_Group3_Handler + 30
;;;703        {
;;;704            GPIO11_Handler();
        0x00207c1a:    f208f573    ..s.    BL       ADC_Handler ; 0x810704
;;;705        }
;;;706        if (GPIOIrqStatus & BIT15)
        0x00207c1e:    0420         .      LSLS     r0,r4,#16
        0x00207c20:    d501        ..      BPL      0x207c26 ; GPIO_Group3_Handler + 38
;;;707        {
;;;708            GPIO15_Handler();
        0x00207c22:    f208f56f    ..o.    BL       ADC_Handler ; 0x810704
;;;709        }
;;;710        if (GPIOIrqStatus & BIT19)
        0x00207c26:    0320         .      LSLS     r0,r4,#12
        0x00207c28:    d501        ..      BPL      0x207c2e ; GPIO_Group3_Handler + 46
;;;711        {
;;;712            GPIO19_Handler();
        0x00207c2a:    f208f56b    ..k.    BL       ADC_Handler ; 0x810704
;;;713        }
;;;714        if (GPIOIrqStatus & BIT23)
        0x00207c2e:    0220         .      LSLS     r0,r4,#8
        0x00207c30:    d501        ..      BPL      0x207c36 ; GPIO_Group3_Handler + 54
;;;715        {
;;;716            GPIO23_Handler();
        0x00207c32:    f208f567    ..g.    BL       ADC_Handler ; 0x810704
;;;717        }
;;;718        if (GPIOIrqStatus & BIT27)
        0x00207c36:    0120         .      LSLS     r0,r4,#4
        0x00207c38:    d501        ..      BPL      0x207c3e ; GPIO_Group3_Handler + 62
;;;719        {
;;;720            GPIO27_Handler();
        0x00207c3a:    f208f563    ..c.    BL       ADC_Handler ; 0x810704
;;;721        }
;;;722        if (GPIOIrqStatus & BIT31)
        0x00207c3e:    2c00        .,      CMP      r4,#0
        0x00207c40:    da03        ..      BGE      0x207c4a ; GPIO_Group3_Handler + 74
;;;723        {
;;;724            GPIO31_Handler();
        0x00207c42:    e8bd4010    ...@    POP      {r4,lr}
        0x00207c46:    f208b55d    ..].    B.W      ADC_Handler ; 0x810704
;;;725        }
;;;726    }
        0x00207c4a:    bd10        ..      POP      {r4,pc}
    GPIO_Group2_Handler
;;;727    /**
;;;728     * @brief  GPIO Group2 Handler
;;;729     * @param  none
;;;730     * @return none
;;;731      */
;;;732    DATA_RAM_FUNCTION void GPIO_Group2_Handler(void)
;;;733    {
;;;734        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207c4c:    4834        4H      LDR      r0,[pc,#208] ; [0x207d20] = 0x40001000
;;; .\..\source\cmsis\system_rtl8762c.c (733)
        0x00207c4e:    b510        ..      PUSH     {r4,lr}
        0x00207c50:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207c52:    0760        `.      LSLS     r0,r4,#29
        0x00207c54:    d501        ..      BPL      0x207c5a ; GPIO_Group2_Handler + 14
;;;734        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;735    
;;;736        //Check exact IRQ function
;;;737        if (GPIOIrqStatus & BIT2)
;;;738        {
;;;739            GPIO2_Handler();
        0x00207c56:    f208f555    ..U.    BL       ADC_Handler ; 0x810704
;;;740        }
;;;741        if (GPIOIrqStatus & BIT6)
        0x00207c5a:    0660        `.      LSLS     r0,r4,#25
        0x00207c5c:    d501        ..      BPL      0x207c62 ; GPIO_Group2_Handler + 22
;;;742        {
;;;743            GPIO6_Handler();
        0x00207c5e:    f208f551    ..Q.    BL       ADC_Handler ; 0x810704
;;;744        }
;;;745        if (GPIOIrqStatus & BIT10)
        0x00207c62:    0560        `.      LSLS     r0,r4,#21
        0x00207c64:    d501        ..      BPL      0x207c6a ; GPIO_Group2_Handler + 30
;;;746        {
;;;747            GPIO10_Handler();
        0x00207c66:    f208f54d    ..M.    BL       ADC_Handler ; 0x810704
;;;748        }
;;;749        if (GPIOIrqStatus & BIT14)
        0x00207c6a:    0460        `.      LSLS     r0,r4,#17
        0x00207c6c:    d501        ..      BPL      0x207c72 ; GPIO_Group2_Handler + 38
;;;750        {
;;;751            GPIO14_Handler();
        0x00207c6e:    f208f549    ..I.    BL       ADC_Handler ; 0x810704
;;;752        }
;;;753        if (GPIOIrqStatus & BIT18)
        0x00207c72:    0360        `.      LSLS     r0,r4,#13
        0x00207c74:    d501        ..      BPL      0x207c7a ; GPIO_Group2_Handler + 46
;;;754        {
;;;755            GPIO18_Handler();
        0x00207c76:    f208f545    ..E.    BL       ADC_Handler ; 0x810704
;;;756        }
;;;757        if (GPIOIrqStatus & BIT22)
        0x00207c7a:    0260        `.      LSLS     r0,r4,#9
        0x00207c7c:    d501        ..      BPL      0x207c82 ; GPIO_Group2_Handler + 54
;;;758        {
;;;759            GPIO22_Handler();
        0x00207c7e:    f208f541    ..A.    BL       ADC_Handler ; 0x810704
;;;760        }
;;;761        if (GPIOIrqStatus & BIT26)
        0x00207c82:    0160        `.      LSLS     r0,r4,#5
        0x00207c84:    d501        ..      BPL      0x207c8a ; GPIO_Group2_Handler + 62
;;;762        {
;;;763            GPIO26_Handler();
        0x00207c86:    f208f53d    ..=.    BL       ADC_Handler ; 0x810704
;;;764        }
;;;765        if (GPIOIrqStatus & BIT30)
        0x00207c8a:    0060        `.      LSLS     r0,r4,#1
        0x00207c8c:    d503        ..      BPL      0x207c96 ; GPIO_Group2_Handler + 74
;;;766        {
;;;767            GPIO30_Handler();
        0x00207c8e:    e8bd4010    ...@    POP      {r4,lr}
        0x00207c92:    f208b537    ..7.    B.W      ADC_Handler ; 0x810704
;;;768        }
;;;769    }
        0x00207c96:    bd10        ..      POP      {r4,pc}
    GPIO_Group1_Handler
;;;770    /**
;;;771     * @brief  GPIO Group1 Handler
;;;772     * @param  none
;;;773     * @return none
;;;774      */
;;;775    DATA_RAM_FUNCTION void GPIO_Group1_Handler(void)
;;;776    {
;;;777        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207c98:    4821        !H      LDR      r0,[pc,#132] ; [0x207d20] = 0x40001000
;;; .\..\source\cmsis\system_rtl8762c.c (776)
        0x00207c9a:    b510        ..      PUSH     {r4,lr}
        0x00207c9c:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207c9e:    07a0        ..      LSLS     r0,r4,#30
        0x00207ca0:    d501        ..      BPL      0x207ca6 ; GPIO_Group1_Handler + 14
;;;777        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;778    
;;;779        //Check exact IRQ function
;;;780        if (GPIOIrqStatus & BIT1)
;;;781        {
;;;782            GPIO1_Handler();
        0x00207ca2:    f208f52f    ../.    BL       ADC_Handler ; 0x810704
;;;783        }
;;;784        if (GPIOIrqStatus & BIT9)
        0x00207ca6:    05a0        ..      LSLS     r0,r4,#22
        0x00207ca8:    d501        ..      BPL      0x207cae ; GPIO_Group1_Handler + 22
;;;785        {
;;;786            GPIO9_Handler();
        0x00207caa:    f208f52b    ..+.    BL       ADC_Handler ; 0x810704
;;;787        }
;;;788        if (GPIOIrqStatus & BIT13)
        0x00207cae:    04a0        ..      LSLS     r0,r4,#18
        0x00207cb0:    d501        ..      BPL      0x207cb6 ; GPIO_Group1_Handler + 30
;;;789        {
;;;790            GPIO13_Handler();
        0x00207cb2:    f208f527    ..'.    BL       ADC_Handler ; 0x810704
;;;791        }
;;;792        if (GPIOIrqStatus & BIT17)
        0x00207cb6:    03a0        ..      LSLS     r0,r4,#14
        0x00207cb8:    d501        ..      BPL      0x207cbe ; GPIO_Group1_Handler + 38
;;;793        {
;;;794            GPIO17_Handler();
        0x00207cba:    f208f523    ..#.    BL       ADC_Handler ; 0x810704
;;;795        }
;;;796        if (GPIOIrqStatus & BIT21)
        0x00207cbe:    02a0        ..      LSLS     r0,r4,#10
        0x00207cc0:    d501        ..      BPL      0x207cc6 ; GPIO_Group1_Handler + 46
;;;797        {
;;;798            GPIO21_Handler();
        0x00207cc2:    f208f51f    ....    BL       ADC_Handler ; 0x810704
;;;799        }
;;;800        if (GPIOIrqStatus & BIT25)
        0x00207cc6:    01a0        ..      LSLS     r0,r4,#6
        0x00207cc8:    d501        ..      BPL      0x207cce ; GPIO_Group1_Handler + 54
;;;801        {
;;;802            GPIO25_Handler();
        0x00207cca:    f208f51b    ....    BL       ADC_Handler ; 0x810704
;;;803        }
;;;804        if (GPIOIrqStatus & BIT29)
        0x00207cce:    00a0        ..      LSLS     r0,r4,#2
        0x00207cd0:    d503        ..      BPL      0x207cda ; GPIO_Group1_Handler + 66
;;;805        {
;;;806            GPIO29_Handler();
        0x00207cd2:    e8bd4010    ...@    POP      {r4,lr}
        0x00207cd6:    f208b515    ....    B.W      ADC_Handler ; 0x810704
;;;807        }
;;;808    }
        0x00207cda:    bd10        ..      POP      {r4,pc}
    GPIO_Group0_Handler
;;;809    /**
;;;810     * @brief  GPIO Group0 Handler
;;;811     * @param  none
;;;812     * @return none
;;;813      */
;;;814    DATA_RAM_FUNCTION void GPIO_Group0_Handler(void)
;;;815    {
;;;816        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207cdc:    4810        .H      LDR      r0,[pc,#64] ; [0x207d20] = 0x40001000
;;; .\..\source\cmsis\system_rtl8762c.c (815)
        0x00207cde:    b510        ..      PUSH     {r4,lr}
        0x00207ce0:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207ce2:    07e0        ..      LSLS     r0,r4,#31
        0x00207ce4:    d001        ..      BEQ      0x207cea ; GPIO_Group0_Handler + 14
;;;816        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;817    
;;;818        //Check exact IRQ function
;;;819        if (GPIOIrqStatus & BIT0)
;;;820        {
;;;821            GPIO0_Handler();
        0x00207ce6:    f208f50d    ....    BL       ADC_Handler ; 0x810704
;;;822        }
;;;823        if (GPIOIrqStatus & BIT8)
        0x00207cea:    05e0        ..      LSLS     r0,r4,#23
        0x00207cec:    d501        ..      BPL      0x207cf2 ; GPIO_Group0_Handler + 22
;;;824        {
;;;825            GPIO8_Handler();
        0x00207cee:    f208f509    ....    BL       ADC_Handler ; 0x810704
;;;826        }
;;;827        if (GPIOIrqStatus & BIT12)
        0x00207cf2:    04e0        ..      LSLS     r0,r4,#19
        0x00207cf4:    d501        ..      BPL      0x207cfa ; GPIO_Group0_Handler + 30
;;;828        {
;;;829            GPIO12_Handler();
        0x00207cf6:    f208f505    ....    BL       ADC_Handler ; 0x810704
;;;830        }
;;;831        if (GPIOIrqStatus & BIT16)
        0x00207cfa:    03e0        ..      LSLS     r0,r4,#15
        0x00207cfc:    d501        ..      BPL      0x207d02 ; GPIO_Group0_Handler + 38
;;;832        {
;;;833            GPIO16_Handler();
        0x00207cfe:    f208f501    ....    BL       ADC_Handler ; 0x810704
;;;834        }
;;;835        if (GPIOIrqStatus & BIT20)
        0x00207d02:    02e0        ..      LSLS     r0,r4,#11
        0x00207d04:    d501        ..      BPL      0x207d0a ; GPIO_Group0_Handler + 46
;;;836        {
;;;837            GPIO20_Handler();
        0x00207d06:    f206f6c3    ....    BL       GPIO20_Handler ; 0x80ea90
;;;838        }
;;;839        if (GPIOIrqStatus & BIT24)
        0x00207d0a:    01e0        ..      LSLS     r0,r4,#7
        0x00207d0c:    d501        ..      BPL      0x207d12 ; GPIO_Group0_Handler + 54
;;;840        {
;;;841            GPIO24_Handler();
        0x00207d0e:    f208f4f9    ....    BL       ADC_Handler ; 0x810704
;;;842        }
;;;843        if (GPIOIrqStatus & BIT28)
        0x00207d12:    00e0        ..      LSLS     r0,r4,#3
        0x00207d14:    d503        ..      BPL      0x207d1e ; GPIO_Group0_Handler + 66
;;;844        {
;;;845            GPIO28_Handler();
        0x00207d16:    e8bd4010    ...@    POP      {r4,lr}
        0x00207d1a:    f208b4f3    ....    B.W      ADC_Handler ; 0x810704
;;;846        }
;;;847    }
        0x00207d1e:    bd10        ..      POP      {r4,pc}
    $d
        0x00207d20:    40001000    ...@    DCD    1073745920
    $t
    .ram.dataon.data
    DLPS_IO_EnterDlpsCb
;;; .\..\source\peripheral\rtl876x_io_dlps.c
;;;1650   {
        0x00207d24:    b57c        |.      PUSH     {r2-r6,lr}
;;; ..\include\SDK\platform\cmsis\core_cm4.h
;;;1659       NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
        0x00207d26:    2400        .$      MOVS     r4,#0
        0x00207d28:    f04f20e0    O..     MOV      r0,#0xe000e000
        0x00207d2c:    2101        .!      MOVS     r1,#1
        0x00207d2e:    f8c01180    ....    STR      r1,[r0,#0x180]
;;; .\..\source\peripheral\rtl876x_io_dlps.c
;;;51         CPU_StoreReg[0] = NVIC->ISER[0];
        0x00207d32:    f8d02100    ...!    LDR      r2,[r0,#0x100]
        0x00207d36:    497f        .I      LDR      r1,[pc,#508] ; [0x207f34] = 0x20805c
;;;52         CPU_StoreReg[1] = NVIC->ISPR[0];
        0x00207d38:    600a        .`      STR      r2,[r1,#0]
        0x00207d3a:    f8d02200    ..."    LDR      r2,[r0,#0x200]
;;;53         CPU_StoreReg[2] = NVIC->IABR[0];
        0x00207d3e:    604a        J`      STR      r2,[r1,#4]
        0x00207d40:    f8d00300    ....    LDR      r0,[r0,#0x300]
;;;54     
;;;55         //The priority of system on interrupt is 0 at first DLPS ENTER CB, so store and restore is skipped
;;;56         for (i = 3; i < 32; ++i)  //skip System_IRQn, WDG_IRQn, BTMAC_IRQn which are handled in rom
        0x00207d44:    6088        .`      STR      r0,[r1,#8]
        0x00207d46:    2003        .       MOVS     r0,#3
;;;57         {
;;;58             CPU_StoreReg[i] = NVIC->IP[i];
        0x00207d48:    f10022e0    ..."    ADD      r2,r0,#0xe000e000
        0x00207d4c:    f8922400    ...$    LDRB     r2,[r2,#0x400]
        0x00207d50:    f8412020    A.      STR      r2,[r1,r0,LSL #2]
        0x00207d54:    1c40        @.      ADDS     r0,r0,#1
;;; .\..\source\peripheral\rtl876x_io_dlps.c (56)
        0x00207d56:    2820         (      CMP      r0,#0x20
        0x00207d58:    d3f6        ..      BCC      0x207d48 ; DLPS_IO_EnterDlpsCb + 36
;;;57         {
;;;58             CPU_StoreReg[i] = NVIC->IP[i];
;;;59         }
;;;60     
;;;61         CPU_StoreReg[32] = SCB->VTOR;
        0x00207d5a:    4877        wH      LDR      r0,[pc,#476] ; [0x207f38] = 0xe000ed08
        0x00207d5c:    6800        .h      LDR      r0,[r0,#0]
;;;62         /* Save Vendor register */
;;;63         PeriIntStoreReg = PERIPHINT->EN;
        0x00207d5e:    f8c10080    ....    STR      r0,[r1,#0x80]
        0x00207d62:    4876        vH      LDR      r0,[pc,#472] ; [0x207f3c] = 0x40006000
        0x00207d64:    68c0        .h      LDR      r0,[r0,#0xc]
        0x00207d66:    4b73        sK      LDR      r3,[pc,#460] ; [0x207f34] = 0x20805c
        0x00207d68:    3b0c        .;      SUBS     r3,r3,#0xc
;;;64     
;;;65         return;
;;;66     }
;;;67     
;;;68     /**
;;;69       * @brief  CPU exit dlps callback function(Resume CPU register values when system exit DLPS)
;;;70       * @param  None
;;;71       * @retval None
;;;72       */
;;;73     DATA_RAM_FUNCTION __STATIC_INLINE  void CPU_DLPS_Exit(void)
;;;74     {
;;;75         //NVIC restore
;;;76         uint32_t i;
;;;77     
;;;78         //Don't restore NVIC pending register, but report warning
;;;79         //NVIC->ISPR[0] = CPU_StoreReg[1];
;;;80         if (CPU_StoreReg[1] & 0xFFFFFFFE)
;;;81         {
;;;82             /* During enter and exit dlps, system will disable all interrupts. If any interrupt occurs during this period, this log will be printed.
;;;83             Every bit of pending register corresponds to an interrupt. Please refer to IRQn_Type from System_IRQn to UART2_IRQn.
;;;84             For example:  "miss interrupt: pending register: 0x42000"
;;;85             It means that RTC and ADC interrupt occur during dlps store and restore flow. But because all interrupts are masked, these interrupts are pending.
;;;86             */
;;;87             DLPS_PRINT_WARN1("miss interrupt: pending register: 0x%x", CPU_StoreReg[1]);
;;;88         }
;;;89     //    NVIC->IABR[0] = CPU_StoreReg[2];
;;;90     
;;;91         //The priority of system on interrupt is 0 at first DLPS ENTER CB, so store and restore is skipped
;;;92         for (i = 3; i < 32; ++i) //skip System_IRQn, WDG_IRQn, BTMAC_IRQn which are handled in rom
;;;93         {
;;;94             NVIC->IP[i] = CPU_StoreReg[i];
;;;95         }
;;;96     
;;;97         SCB->VTOR = CPU_StoreReg[32];
;;;98         PERIPHINT->EN = PeriIntStoreReg;
;;;99         NVIC->ISER[0] = CPU_StoreReg[0];
;;;100    
;;;101    #if (DEBUG_WATCHPOINT_ENABLE == 1)
;;;102        void debug_monitor_enable(void);
;;;103        debug_monitor_enable();
;;;104    #endif
;;;105    
;;;106        return;
;;;107    }
;;;108    
;;;109    /**
;;;110      * @brief  PINMUX enter dlps callback function(Save PINMUX register values when system enter DLPS)
;;;111      * @param  None
;;;112      * @retval None
;;;113      */
;;;114    DATA_RAM_FUNCTION __STATIC_INLINE  void Pinmux_DLPS_Enter(void)
;;;115    {
;;;116        uint8_t i = 0;
;;;117    
;;;118        for (i = 0; i < 10; i++)
;;;119        {
;;;120            Pinmux_StoreReg[i] = PINMUX->CFG[i];
        0x00207d6a:    f1030190    ....    ADD      r1,r3,#0x90
;;; .\..\source\peripheral\rtl876x_io_dlps.c (116)
        0x00207d6e:    6018        .`      STR      r0,[r3,#0]
        0x00207d70:    2000        .       MOVS     r0,#0
;;;117    
;;;118        for (i = 0; i < 10; i++)
;;;119        {
;;;120            Pinmux_StoreReg[i] = PINMUX->CFG[i];
        0x00207d72:    0082        ..      LSLS     r2,r0,#2
        0x00207d74:    f1024280    ...B    ADD      r2,r2,#0x40000000
        0x00207d78:    f8d22280    ..."    LDR      r2,[r2,#0x280]
        0x00207d7c:    f8412020    A.      STR      r2,[r1,r0,LSL #2]
        0x00207d80:    1c40        @.      ADDS     r0,r0,#1
;;; .\..\source\peripheral\rtl876x_io_dlps.c (118)
        0x00207d82:    b2c0        ..      UXTB     r0,r0
;;; .\..\source\peripheral\rtl876x_io_dlps.c (118)
        0x00207d84:    280a        .(      CMP      r0,#0xa
        0x00207d86:    d3f4        ..      BCC      0x207d72 ; DLPS_IO_EnterDlpsCb + 78
;;;119        {
;;;120            Pinmux_StoreReg[i] = PINMUX->CFG[i];
;;;121        }
;;;122    
;;;123        return;
;;;124    }
;;;125    
;;;126    /**
;;;127      * @brief  PINMUX exit dlps callback function(Resume PINMUX register values when system exit DLPS)
;;;128      * @param  None
;;;129      * @retval None
;;;130      */
;;;131    DATA_RAM_FUNCTION __STATIC_INLINE  void Pinmux_DLPS_Exit(void)
;;;132    {
;;;133        uint8_t i;
;;;134    
;;;135        for (i = 0; i < 10; i++)
;;;136        {
;;;137            PINMUX->CFG[i] = Pinmux_StoreReg[i];
;;;138        }
;;;139    
;;;140        return;
;;;141    }
;;;142    #endif
;;;143    
;;;144    /********************************************** ********************************************************/
;;;145    /**************************************** [GPIO DLPS] **************************************************/
;;;146    /*******************************************************************************************************/
;;;147    /*******************************************************************************************************/
;;;148    #if USE_GPIO_DLPS
;;;149    
;;;150    __STATIC_INLINE void GPIO_DLPS_Enter(void);
;;;151    __STATIC_INLINE void GPIO_DLPS_Exit(void);
;;;152    
;;;153    uint32_t GPIO_StoreReg[9];         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;154    
;;;155    /**
;;;156      * @brief  GPIO enter dlps callback function(Save GPIO register values when system enter DLPS)
;;;157      * @param  None
;;;158      * @retval None
;;;159      */
;;;160    DATA_RAM_FUNCTION __STATIC_INLINE void GPIO_DLPS_Enter(void)
;;;161    {
;;;162        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;163        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;164    
;;;165        GPIO_StoreReg[0] = GPIO->DATAOUT;
;;;166        GPIO_StoreReg[1] = GPIO->DATADIR;
;;;167        GPIO_StoreReg[2] = GPIO->DATASRC;
;;;168        GPIO_StoreReg[3] = GPIO->INTEN;
;;;169        GPIO_StoreReg[4] = GPIO->INTMASK;
;;;170        GPIO_StoreReg[5] = GPIO->INTTYPE;
;;;171        GPIO_StoreReg[6] = GPIO->INTPOLARITY;
;;;172        GPIO_StoreReg[7] = GPIO->DEBOUNCE;
;;;173        GPIO_StoreReg[8] = *(__IO uint32_t *)(0x40000344UL);
;;;174    
;;;175        return;
;;;176    }
;;;177    
;;;178    /**
;;;179      * @brief  GPIO exit dlps callback function(Resume GPIO register values when system exit DLPS)
;;;180      * @param  None
;;;181      * @retval None
;;;182      */
;;;183    DATA_RAM_FUNCTION __STATIC_INLINE void GPIO_DLPS_Exit(void)
;;;184    {
;;;185        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;186        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;187    
;;;188        GPIO->DATADIR       = GPIO_StoreReg[1];
;;;189        GPIO->DATASRC       = GPIO_StoreReg[2];
;;;190        GPIO->INTMASK       = GPIO_StoreReg[4];
;;;191        GPIO->INTTYPE       = GPIO_StoreReg[5];
;;;192        GPIO->INTPOLARITY   = GPIO_StoreReg[6];
;;;193        GPIO->DEBOUNCE      = GPIO_StoreReg[7];
;;;194        GPIO->DATAOUT       = GPIO_StoreReg[0];
;;;195        GPIO->INTCLR        = ~(GPIO_StoreReg[1]);
;;;196        GPIO->INTEN         = GPIO_StoreReg[3];
;;;197        *(__IO uint32_t *)(0x40000344UL) = GPIO_StoreReg[8];
;;;198    
;;;199        return;
;;;200    }
;;;201    #endif  /* USE_GPIO_DLPS */
;;;202    
;;;203    
;;;204    /********************************************** ********************************************************/
;;;205    /**************************************** [KEYSCAN DLPS] ***********************************************/
;;;206    /*******************************************************************************************************/
;;;207    /*******************************************************************************************************/
;;;208    #if USE_KEYSCAN_DLPS
;;;209    __STATIC_INLINE void KeyScan_DLPS_Enter(void);
;;;210    __STATIC_INLINE void KeyScan_DLPS_Exit(void);
;;;211    
;;;212    uint32_t KeyScan_StoreReg[7];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;213    
;;;214    /**
;;;215      * @brief  KEYSCAN enter dlps callback function(Save KEYSCAN register values when system enter DLPS)
;;;216      * @param  None
;;;217      * @retval None
;;;218      */
;;;219    DATA_RAM_FUNCTION __STATIC_INLINE void KeyScan_DLPS_Enter(void)
;;;220    {
;;;221        /*Open 5M clock source*/
;;;222        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;223        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;224    
;;;225        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;226        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;227    
;;;228        KeyScan_StoreReg[0] = KEYSCAN->CLKDIV;               /* 0x00 */
;;;229        KeyScan_StoreReg[1] = KEYSCAN->TIMERCR;              /* 0x04 */
;;;230        KeyScan_StoreReg[2] = KEYSCAN->CR;                   /* 0x08 */
;;;231        KeyScan_StoreReg[3] = KEYSCAN->COLCR;                /* 0x0C */
;;;232        KeyScan_StoreReg[4] = KEYSCAN->ROWCR;                /* 0x10 */
;;;233        KeyScan_StoreReg[6] = KEYSCAN->INTMASK;              /* 0x18 */
;;;234    
;;;235        return;
;;;236    }
;;;237    
;;;238    /**
;;;239      * @brief  KEYSCAN exit dlps callback function(Resume KEYSCAN register values when system exit DLPS)
;;;240      * @param  None
;;;241      * @retval None
;;;242      */
;;;243    DATA_RAM_FUNCTION __STATIC_INLINE void KeyScan_DLPS_Exit(void)
;;;244    {
;;;245        /*Open 5M clock source*/
;;;246        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;247        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;248    
;;;249        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;250        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;251    
;;;252        /* Set FSM to idle state */
;;;253        KEYSCAN->CR &= ~BIT31;
;;;254        KEYSCAN->CLKDIV = KeyScan_StoreReg[0];
;;;255        KEYSCAN->CR = (KeyScan_StoreReg[2] & (~(BIT31)));
;;;256        KEYSCAN->TIMERCR = KeyScan_StoreReg[1];
;;;257        KEYSCAN->COLCR = KeyScan_StoreReg[3];
;;;258        KEYSCAN->ROWCR = KeyScan_StoreReg[4];
;;;259        KEYSCAN->INTMASK = KeyScan_StoreReg[6];
;;;260        KEYSCAN->CR |= (KeyScan_StoreReg[2] & ((BIT31)));
;;;261    
;;;262        return;
;;;263    }
;;;264    #endif /* USE_KEYSCAN_DLPS */
;;;265    
;;;266    
;;;267    /********************************************** ********************************************************/
;;;268    /**************************************** [QDEC DLPS] **************************************************/
;;;269    /*******************************************************************************************************/
;;;270    /*******************************************************************************************************/
;;;271    #if USE_QDECODER_DLPS
;;;272    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void);
;;;273    __STATIC_INLINE void QuadDecoder_DLPS_Exit(void);
;;;274    
;;;275    uint32_t QuadDecoder_StoreReg[5];  /*  This array should be placed in RAM ON/Buffer ON.    */
;;;276    
;;;277    /**
;;;278      * @brief  QDEC enter dlps callback function(Save QDEC register values when system enter DLPS)
;;;279      * @param  None
;;;280      * @retval None
;;;281      */
;;;282    DATA_RAM_FUNCTION __STATIC_INLINE void QuadDecoder_DLPS_Enter(void)
;;;283    {
;;;284        /*Open 20M clock source*/
;;;285        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;286        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;287        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;288        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;289    
;;;290        QuadDecoder_StoreReg[0] = QDEC->REG_DIV;
;;;291        QuadDecoder_StoreReg[1] = QDEC->REG_CR_X;
;;;292        QuadDecoder_StoreReg[2] = QDEC->REG_CR_Y;
;;;293        QuadDecoder_StoreReg[3] = QDEC->REG_CR_Z;
;;;294        QuadDecoder_StoreReg[4] = QDEC->INT_MASK;
;;;295    
;;;296        return;
;;;297    }
;;;298    
;;;299    /**
;;;300      * @brief  QDEC exit dlps callback function(Resume QDEC register values when system exit DLPS)
;;;301      * @param  None
;;;302      * @retval None
;;;303      */
;;;304    DATA_RAM_FUNCTION __STATIC_INLINE void QuadDecoder_DLPS_Exit(void)
;;;305    {
;;;306        /*Open 20M clock source*/
;;;307        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;308        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;309        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;310        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;311    
;;;312        //clear flags
;;;313        QDEC->REG_DIV  = QuadDecoder_StoreReg[0];
;;;314        QDEC->REG_CR_X = QuadDecoder_StoreReg[1];
;;;315        QDEC->REG_CR_Y = QuadDecoder_StoreReg[2];
;;;316        QDEC->REG_CR_Z = QuadDecoder_StoreReg[3];
;;;317        QDEC->INT_MASK = QuadDecoder_StoreReg[4];
;;;318    
;;;319        return;
;;;320    }
;;;321    #endif
;;;322    
;;;323    /********************************************** ********************************************************/
;;;324    /**************************************** [SPI0 DLPS] **************************************************/
;;;325    /*******************************************************************************************************/
;;;326    /*******************************************************************************************************/
;;;327    #if USE_SPI0_DLPS
;;;328    __STATIC_INLINE void SPI0_DLPS_Enter(void);
;;;329    __STATIC_INLINE void SPI0_DLPS_Exit(void);
;;;330    
;;;331    uint32_t SPI0_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;332    
;;;333    /**
;;;334      * @brief  SPI0 enter dlps callback function(Save SPI0 register values when system enter DLPS)
;;;335      * @param  None
;;;336      * @retval None
;;;337      */
;;;338    DATA_RAM_FUNCTION __STATIC_INLINE void SPI0_DLPS_Enter(void)
;;;339    {
;;;340        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;341        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;342    
;;;343        SPI0_StoreReg[0] = SPI0->CTRLR0;
;;;344        SPI0_StoreReg[1] = SPI0->CTRLR1;
;;;345        SPI0_StoreReg[2] = SPI0->SSIENR;
;;;346        SPI0_StoreReg[3] = SPI0->SER;
;;;347        SPI0_StoreReg[4] = SPI0->BAUDR;
;;;348        SPI0_StoreReg[5] = SPI0->TXFTLR;
;;;349        SPI0_StoreReg[6] = SPI0->RXFTLR;
;;;350        SPI0_StoreReg[7] = SPI0->IMR;
;;;351        SPI0_StoreReg[8] = SPI0->DMACR;
;;;352        SPI0_StoreReg[9] = SPI0->DMATDLR;
;;;353        SPI0_StoreReg[10] = SPI0->DMARDLR;
;;;354        SPI0_StoreReg[11] = SPI0->RX_SAMPLE_DLY;
;;;355        SPI0_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;356        SPI0_StoreReg[13] = *(volatile uint32_t *)0x4000035CUL;
;;;357    }
;;;358    
;;;359    /**
;;;360      * @brief  SPI0 exit dlps callback function(Resume SPI0 register values when system exit DLPS)
;;;361      * @param  None
;;;362      * @retval None
;;;363      */
;;;364    DATA_RAM_FUNCTION __STATIC_INLINE void SPI0_DLPS_Exit(void)
;;;365    {
;;;366        *(volatile uint32_t *)0x4000035CUL = SPI0_StoreReg[13];
;;;367        *(volatile uint32_t *)0x40000308 = SPI0_StoreReg[12];
;;;368        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;369        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;370    
;;;371        SPI0->CTRLR0 = SPI0_StoreReg[0];
;;;372        SPI0->CTRLR1 = SPI0_StoreReg[1];
;;;373        SPI0->SER = SPI0_StoreReg[3];
;;;374        SPI0->BAUDR = SPI0_StoreReg[4];
;;;375        SPI0->TXFTLR = SPI0_StoreReg[5];
;;;376        SPI0->RXFTLR = SPI0_StoreReg[6];
;;;377        SPI0->IMR = SPI0_StoreReg[7];
;;;378        SPI0->DMACR = SPI0_StoreReg[8];
;;;379        SPI0->DMATDLR = SPI0_StoreReg[9];
;;;380        SPI0->DMARDLR = SPI0_StoreReg[10];
;;;381        SPI0->RX_SAMPLE_DLY = SPI0_StoreReg[11];
;;;382    
;;;383        /* Enable the selected SPI peripheral */
;;;384        SPI0->SSIENR = SPI0_StoreReg[2];
;;;385    }
;;;386    #endif
;;;387    
;;;388    
;;;389    /********************************************** ********************************************************/
;;;390    /**************************************** [SPI1 DLPS] **************************************************/
;;;391    /*******************************************************************************************************/
;;;392    /*******************************************************************************************************/
;;;393    #if USE_SPI1_DLPS
;;;394    __STATIC_INLINE void SPI1_DLPS_Enter(void);
;;;395    __STATIC_INLINE void SPI1_DLPS_Exit(void);
;;;396    
;;;397    uint32_t SPI1_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;398    
;;;399    /**
;;;400      * @brief  SPI1 enter dlps callback function(Save SPI1 register values when system enter DLPS)
;;;401      * @param  None
;;;402      * @retval None
;;;403      */
;;;404    DATA_RAM_FUNCTION __STATIC_INLINE void SPI1_DLPS_Enter(void)
;;;405    {
;;;406        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;407        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;408    
;;;409        SPI1_StoreReg[0] = SPI1->CTRLR0;
;;;410        SPI1_StoreReg[1] = SPI1->CTRLR1;
;;;411        SPI1_StoreReg[2] = SPI1->SSIENR;
;;;412        SPI1_StoreReg[3] = SPI1->SER;
;;;413        SPI1_StoreReg[4] = SPI1->BAUDR;
;;;414        SPI1_StoreReg[5] = SPI1->TXFTLR;
;;;415        SPI1_StoreReg[6] = SPI1->RXFTLR;
;;;416        SPI1_StoreReg[7] = SPI1->IMR;
;;;417        SPI1_StoreReg[8] = SPI1->DMACR;
;;;418        SPI1_StoreReg[9] = SPI1->DMATDLR;
;;;419        SPI1_StoreReg[10] = SPI1->DMARDLR;
;;;420        SPI1_StoreReg[11] = SPI1->RX_SAMPLE_DLY;
;;;421        SPI1_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;422        SPI1_StoreReg[13] = *(volatile uint32_t *)0x4000035CUL;
;;;423    }
;;;424    
;;;425    /**
;;;426      * @brief  SPI1 exit dlps callback function(Resume SPI1 register values when system exit DLPS)
;;;427      * @param  None
;;;428      * @retval None
;;;429      */
;;;430    DATA_RAM_FUNCTION __STATIC_INLINE void SPI1_DLPS_Exit(void)
;;;431    {
;;;432        *(volatile uint32_t *)0x4000035CUL = SPI1_StoreReg[13];
;;;433        *(volatile uint32_t *)0x40000308 = SPI1_StoreReg[12];
;;;434        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;435        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;436    
;;;437        SPI1->CTRLR0 = SPI1_StoreReg[0];
;;;438        SPI1->CTRLR1 = SPI1_StoreReg[1];
;;;439        SPI1->SER = SPI1_StoreReg[3];
;;;440        SPI1->BAUDR = SPI1_StoreReg[4];
;;;441        SPI1->TXFTLR = SPI1_StoreReg[5];
;;;442        SPI1->RXFTLR = SPI1_StoreReg[6];
;;;443        SPI1->IMR = SPI1_StoreReg[7];
;;;444        SPI1->DMACR = SPI1_StoreReg[8];
;;;445        SPI1->DMATDLR = SPI1_StoreReg[9];
;;;446        SPI1->DMARDLR = SPI1_StoreReg[10];
;;;447        SPI1->RX_SAMPLE_DLY = SPI1_StoreReg[11];
;;;448    
;;;449        /* Enable the selected SPI peripheral */
;;;450        SPI1->SSIENR = SPI1_StoreReg[2];
;;;451    }
;;;452    #endif
;;;453    
;;;454    /********************************************** ********************************************************/
;;;455    /**************************************** [SPI2W DLPS] **************************************************/
;;;456    /*******************************************************************************************************/
;;;457    /*******************************************************************************************************/
;;;458    #if USE_SPI2W_DLPS
;;;459    __STATIC_INLINE void SPI2W_DLPS_Enter(void);
;;;460    __STATIC_INLINE void SPI2W_DLPS_Exit(void);
;;;461    
;;;462    uint32_t SPI2W_StoreReg[1];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;463    
;;;464    /**
;;;465      * @brief  SPI2W enter dlps callback function(Save SPI2W register values when system enter DLPS)
;;;466      * @param  None
;;;467      * @retval None
;;;468      */
;;;469    DATA_RAM_FUNCTION __STATIC_INLINE void SPI2W_DLPS_Enter(void)
;;;470    {
;;;471        /*Open 20M clock source*/
;;;472        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;473        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;474    
;;;475        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;476        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;477    
;;;478        SPI2W_StoreReg[0] = SPI3WIRE->CFGR;
;;;479    }
;;;480    
;;;481    /**
;;;482      * @brief  SPI2W exit dlps callback function(Resume SPI2W register values when system exit DLPS)
;;;483      * @param  None
;;;484      * @retval None
;;;485      */
;;;486    DATA_RAM_FUNCTION __STATIC_INLINE void SPI2W_DLPS_Exit(void)
;;;487    {
;;;488        /*Open 20M clock source*/
;;;489        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;490        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;491    
;;;492        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;493        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;494    
;;;495        SPI3WIRE->CFGR = SPI2W_StoreReg[0];
;;;496    }
;;;497    #endif
;;;498    
;;;499    /********************************************** ********************************************************/
;;;500    /**************************************** [I2C0 DLPS] **************************************************/
;;;501    /*******************************************************************************************************/
;;;502    /*******************************************************************************************************/
;;;503    #if USE_I2C0_DLPS
;;;504    __STATIC_INLINE void I2C0_DLPS_Enter(void);
;;;505    __STATIC_INLINE void I2C0_DLPS_Exit(void);
;;;506    
;;;507    uint32_t I2C0_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;508    
;;;509    /**
;;;510      * @brief  I2C0 enter dlps callback function(Save I2C0 register values when system enter DLPS)
;;;511      * @param  None
;;;512      * @retval None
;;;513      */
;;;514    DATA_RAM_FUNCTION __STATIC_INLINE void I2C0_DLPS_Enter(void)
;;;515    {
;;;516        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;517        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;518    
;;;519        I2C0_StoreReg[0] = I2C0->IC_CON;
;;;520        I2C0_StoreReg[1] = I2C0->IC_TAR;
;;;521        I2C0_StoreReg[2] = I2C0->IC_SAR;
;;;522        I2C0_StoreReg[3] = I2C0->IC_HS_MADDR;
;;;523    
;;;524        I2C0_StoreReg[4] = I2C0->IC_SS_SCL_HCNT;
;;;525        I2C0_StoreReg[5] = I2C0->IC_SS_SCL_LCNT;
;;;526        I2C0_StoreReg[6] = I2C0->IC_FS_SCL_HCNT;
;;;527        I2C0_StoreReg[7] = I2C0->IC_FS_SCL_LCNT;
;;;528        I2C0_StoreReg[8] = I2C0->IC_HS_SCL_HCNT;
;;;529        I2C0_StoreReg[9] = I2C0->IC_HS_SCL_LCNT;
;;;530    
;;;531        I2C0_StoreReg[10] = I2C0->IC_INTR_MASK;
;;;532        I2C0_StoreReg[11] = I2C0->IC_RX_TL;
;;;533        I2C0_StoreReg[12] = I2C0->IC_TX_TL;
;;;534        I2C0_StoreReg[13] = I2C0->IC_ENABLE;
;;;535        I2C0_StoreReg[14] = I2C0->IC_SDA_HOLD;
;;;536        I2C0_StoreReg[15] = I2C0->IC_SLV_DATA_NACK_ONLY;
;;;537        I2C0_StoreReg[16] = I2C0->IC_DMA_CR;
;;;538        I2C0_StoreReg[17] = I2C0->IC_DMA_TDLR;
;;;539        I2C0_StoreReg[18] = I2C0->IC_DMA_RDLR;
;;;540    
;;;541        I2C0_StoreReg[19] = I2C0->IC_SDA_SETUP;
;;;542    }
;;;543    
;;;544    /**
;;;545      * @brief  I2C0 exit dlps callback function(Resume I2C0 register values when system exit DLPS)
;;;546      * @param  None
;;;547      * @retval None
;;;548      */
;;;549    DATA_RAM_FUNCTION __STATIC_INLINE void I2C0_DLPS_Exit(void)
;;;550    {
;;;551        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;552        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;553    
;;;554        I2C0->IC_CON = I2C0_StoreReg[0];
;;;555        I2C0->IC_TAR = I2C0_StoreReg[1];
;;;556        I2C0->IC_SAR = I2C0_StoreReg[2];
;;;557        I2C0->IC_HS_MADDR = I2C0_StoreReg[3];
;;;558    
;;;559        I2C0->IC_SS_SCL_HCNT = I2C0_StoreReg[4];
;;;560        I2C0->IC_SS_SCL_LCNT = I2C0_StoreReg[5];
;;;561        I2C0->IC_FS_SCL_HCNT = I2C0_StoreReg[6];
;;;562        I2C0->IC_FS_SCL_LCNT = I2C0_StoreReg[7];
;;;563        I2C0->IC_HS_SCL_HCNT = I2C0_StoreReg[8];
;;;564        I2C0->IC_HS_SCL_LCNT = I2C0_StoreReg[9];
;;;565    
;;;566        I2C0->IC_INTR_MASK = I2C0_StoreReg[10];
;;;567        I2C0->IC_RX_TL = I2C0_StoreReg[11];
;;;568        I2C0->IC_TX_TL = I2C0_StoreReg[12];
;;;569        I2C0->IC_SDA_HOLD = I2C0_StoreReg[14];
;;;570        I2C0->IC_SLV_DATA_NACK_ONLY = I2C0_StoreReg[15];
;;;571        I2C0->IC_DMA_CR = I2C0_StoreReg[16];
;;;572        I2C0->IC_DMA_TDLR = I2C0_StoreReg[17];
;;;573        I2C0->IC_DMA_RDLR = I2C0_StoreReg[18];
;;;574        I2C0->IC_SDA_SETUP = I2C0_StoreReg[19];
;;;575    
;;;576        I2C0->IC_ENABLE = I2C0_StoreReg[13];
;;;577    }
;;;578    #endif
;;;579    
;;;580    /********************************************** ********************************************************/
;;;581    /**************************************** [I2C1 DLPS] **************************************************/
;;;582    /*******************************************************************************************************/
;;;583    /*******************************************************************************************************/
;;;584    #if USE_I2C1_DLPS
;;;585    __STATIC_INLINE void I2C1_DLPS_Enter(void);
;;;586    __STATIC_INLINE void I2C1_DLPS_Exit(void);
;;;587    
;;;588    uint32_t I2C1_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;589    
;;;590    /**
;;;591      * @brief  I2C1 enter dlps callback function(Save I2C1 register values when system enter DLPS)
;;;592      * @param  None
;;;593      * @retval None
;;;594      */
;;;595    DATA_RAM_FUNCTION __STATIC_INLINE void I2C1_DLPS_Enter(void)
;;;596    {
;;;597        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;598        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;599    
;;;600        I2C1_StoreReg[0] = I2C1->IC_CON;
;;;601        I2C1_StoreReg[1] = I2C1->IC_TAR;
;;;602        I2C1_StoreReg[2] = I2C1->IC_SAR;
;;;603        I2C1_StoreReg[3] = I2C1->IC_HS_MADDR;
;;;604    
;;;605        I2C1_StoreReg[4] = I2C1->IC_SS_SCL_HCNT;
;;;606        I2C1_StoreReg[5] = I2C1->IC_SS_SCL_LCNT;
;;;607        I2C1_StoreReg[6] = I2C1->IC_FS_SCL_HCNT;
;;;608        I2C1_StoreReg[7] = I2C1->IC_FS_SCL_LCNT;
;;;609        I2C1_StoreReg[8] = I2C1->IC_HS_SCL_HCNT;
;;;610        I2C1_StoreReg[9] = I2C1->IC_HS_SCL_LCNT;
;;;611    
;;;612        I2C1_StoreReg[10] = I2C1->IC_INTR_MASK;
;;;613        I2C1_StoreReg[11] = I2C1->IC_RX_TL;
;;;614        I2C1_StoreReg[12] = I2C1->IC_TX_TL;
;;;615        I2C1_StoreReg[13] = I2C1->IC_ENABLE;
;;;616        I2C1_StoreReg[14] = I2C1->IC_SDA_HOLD;
;;;617        I2C1_StoreReg[15] = I2C1->IC_SLV_DATA_NACK_ONLY;
;;;618        I2C1_StoreReg[16] = I2C1->IC_DMA_CR;
;;;619        I2C1_StoreReg[17] = I2C1->IC_DMA_TDLR;
;;;620        I2C1_StoreReg[18] = I2C1->IC_DMA_RDLR;
;;;621    
;;;622        I2C1_StoreReg[19] = I2C1->IC_SDA_SETUP;
;;;623    }
;;;624    
;;;625    /**
;;;626      * @brief  I2C1 exit dlps callback function(Resume I2C1 register values when system exit DLPS)
;;;627      * @param  None
;;;628      * @retval None
;;;629      */
;;;630    DATA_RAM_FUNCTION __STATIC_INLINE void I2C1_DLPS_Exit(void)
;;;631    {
;;;632        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;633        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;634    
;;;635        I2C1->IC_CON = I2C1_StoreReg[0];
;;;636        I2C1->IC_TAR = I2C1_StoreReg[1];
;;;637        I2C1->IC_SAR = I2C1_StoreReg[2];
;;;638        I2C0->IC_HS_MADDR = I2C1_StoreReg[3];
;;;639    
;;;640        I2C1->IC_SS_SCL_HCNT = I2C1_StoreReg[4];
;;;641        I2C1->IC_SS_SCL_LCNT = I2C1_StoreReg[5];
;;;642        I2C1->IC_FS_SCL_HCNT = I2C1_StoreReg[6];
;;;643        I2C1->IC_FS_SCL_LCNT = I2C1_StoreReg[7];
;;;644        I2C1->IC_HS_SCL_HCNT = I2C1_StoreReg[8];
;;;645        I2C1->IC_HS_SCL_LCNT = I2C1_StoreReg[9];
;;;646    
;;;647        I2C1->IC_INTR_MASK = I2C1_StoreReg[10];
;;;648        I2C1->IC_RX_TL = I2C1_StoreReg[11];
;;;649        I2C1->IC_TX_TL = I2C1_StoreReg[12];
;;;650        I2C1->IC_SDA_HOLD = I2C1_StoreReg[14];
;;;651        I2C1->IC_SLV_DATA_NACK_ONLY = I2C1_StoreReg[15];
;;;652        I2C1->IC_DMA_CR = I2C1_StoreReg[16];
;;;653        I2C1->IC_DMA_TDLR = I2C1_StoreReg[17];
;;;654        I2C1->IC_DMA_RDLR = I2C1_StoreReg[18];
;;;655        I2C1->IC_SDA_SETUP = I2C1_StoreReg[19];
;;;656    
;;;657        I2C1->IC_ENABLE = I2C1_StoreReg[13];
;;;658    }
;;;659    #endif
;;;660    
;;;661    /********************************************** ********************************************************/
;;;662    /**************************************** [Timer & PWM DLPS] *******************************************/
;;;663    /*******************************************************************************************************/
;;;664    /*******************************************************************************************************/
;;;665    #if USE_TIM_DLPS
;;;666    #include "rtl876x_tim.h"
;;;667    __STATIC_INLINE void TIM_DLPS_Enter(void);
;;;668    __STATIC_INLINE void TIM_DLPS_Exit(void);
;;;669    
;;;670    uint32_t TIM_StoreReg[26];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;671    
;;;672    /* PWM, use with timer */
;;;673    uint32_t PWM0_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;674    
;;;675    uint32_t PWM1_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;676    
;;;677    /**
;;;678      * @brief  TIMER enter dlps callback function(Save TIMER register values when system enter DLPS)
;;;679      * @param  None
;;;680      * @retval None
;;;681      */
;;;682    DATA_RAM_FUNCTION __STATIC_INLINE void TIM_DLPS_Enter(void)
;;;683    {
;;;684        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;685        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;686    
;;;687        TIM_StoreReg[0] = TIM0->LoadCount;
;;;688        TIM_StoreReg[1] = TIM0->ControlReg;
;;;689        TIM_StoreReg[2] = TIMER0_LOAD_COUNT2;
;;;690    
;;;691        TIM_StoreReg[3] = TIM1->LoadCount;
;;;692        TIM_StoreReg[4] = TIM1->ControlReg;
;;;693        TIM_StoreReg[5] = TIMER1_LOAD_COUNT2;
;;;694    
;;;695        TIM_StoreReg[6] = TIM2->LoadCount;
;;;696        TIM_StoreReg[7] = TIM2->ControlReg;
;;;697        TIM_StoreReg[8] = TIMER2_LOAD_COUNT2;
;;;698    
;;;699        TIM_StoreReg[9] = TIM3->LoadCount;
;;;700        TIM_StoreReg[10] = TIM3->ControlReg;
;;;701        TIM_StoreReg[11] = TIMER3_LOAD_COUNT2;
;;;702    
;;;703        TIM_StoreReg[12] = TIM4->LoadCount;
;;;704        TIM_StoreReg[13] = TIM4->ControlReg;
;;;705        TIM_StoreReg[14] = TIMER4_LOAD_COUNT2;
;;;706    
;;;707        TIM_StoreReg[15] = TIM5->LoadCount;
;;;708        TIM_StoreReg[16] = TIM5->ControlReg;
;;;709        TIM_StoreReg[17] = TIMER5_LOAD_COUNT2;
;;;710    
;;;711        TIM_StoreReg[18] = TIM6->LoadCount;
;;;712        TIM_StoreReg[19] = TIM6->ControlReg;
;;;713        TIM_StoreReg[20] = TIMER6_LOAD_COUNT2;
;;;714    
;;;715        TIM_StoreReg[21] = TIM7->LoadCount;
;;;716        TIM_StoreReg[22] = TIM7->ControlReg;
;;;717        TIM_StoreReg[23] = TIMER7_LOAD_COUNT2;
;;;718    
;;;719        TIM_StoreReg[24] = *((volatile uint32_t *)0x4000035CUL);
;;;720        TIM_StoreReg[25] = *((volatile uint32_t *)0x40000360UL);
;;;721    
;;;722        PWM0_StoreReg = TIMER_PWM0_CR;
;;;723    
;;;724        PWM1_StoreReg = TIMER_PWM1_CR;
;;;725    }
;;;726    
;;;727    /**
;;;728      * @brief  TIMER exit dlps callback function(Resume TIMER register values when system exit DLPS)
;;;729      * @param  None
;;;730      * @retval None
;;;731      */
;;;732    DATA_RAM_FUNCTION __STATIC_INLINE void TIM_DLPS_Exit(void)
;;;733    {
;;;734        /* Enable timer IP clock and function */
;;;735        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;736        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;737    
;;;738        *((volatile uint32_t *)0x4000035CUL) = TIM_StoreReg[24];
;;;739        *((volatile uint32_t *)0x40000360UL) = TIM_StoreReg[25];
;;;740    
;;;741        TIM0->LoadCount = TIM_StoreReg[0];
;;;742        TIM0->ControlReg = TIM_StoreReg[1];
;;;743        TIMER0_LOAD_COUNT2 = TIM_StoreReg[2];
;;;744    
;;;745        TIM1->LoadCount = TIM_StoreReg[3];
;;;746        TIM1->ControlReg = TIM_StoreReg[4];
;;;747        TIMER1_LOAD_COUNT2 = TIM_StoreReg[5];
;;;748    
;;;749        TIM2->LoadCount = TIM_StoreReg[6];
;;;750        TIM2->ControlReg = TIM_StoreReg[7];
;;;751        TIMER2_LOAD_COUNT2 = TIM_StoreReg[8];
;;;752    
;;;753        TIM3->LoadCount = TIM_StoreReg[9];
;;;754        TIM3->ControlReg = TIM_StoreReg[10];
;;;755        TIMER3_LOAD_COUNT2 = TIM_StoreReg[11];
;;;756    
;;;757        TIM4->LoadCount = TIM_StoreReg[12];
;;;758        TIM4->ControlReg = TIM_StoreReg[13];
;;;759        TIMER4_LOAD_COUNT2 = TIM_StoreReg[14];
;;;760    
;;;761        TIM5->LoadCount = TIM_StoreReg[15];
;;;762        TIM5->ControlReg = TIM_StoreReg[16];
;;;763        TIMER5_LOAD_COUNT2 = TIM_StoreReg[17];
;;;764    
;;;765        TIM6->LoadCount = TIM_StoreReg[18];
;;;766        TIM6->ControlReg = TIM_StoreReg[19];
;;;767        TIMER6_LOAD_COUNT2 = TIM_StoreReg[20];
;;;768    
;;;769        TIM7->LoadCount = TIM_StoreReg[21];
;;;770        TIM7->ControlReg = TIM_StoreReg[22];
;;;771        TIMER7_LOAD_COUNT2 = TIM_StoreReg[23];
;;;772    
;;;773        TIMER_PWM0_CR = PWM0_StoreReg;
;;;774    
;;;775        TIMER_PWM1_CR = PWM1_StoreReg;
;;;776    }
;;;777    #endif  /* USE_TIM_DLPS */
;;;778    
;;;779    
;;;780    /********************************************** ********************************************************/
;;;781    /**************************************** [UART DLPS] **************************************************/
;;;782    /*******************************************************************************************************/
;;;783    /*******************************************************************************************************/
;;;784    #if USE_UART_DLPS
;;;785    #include "rtl876x_uart.h"
;;;786    
;;;787    __STATIC_INLINE void UART_DLPS_Enter(void);
;;;788    __STATIC_INLINE void UART_DLPS_Exit(void);
;;;789    
;;;790    uint32_t UART_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;791    
;;;792    /**
;;;793      * @brief  UART enter dlps callback function(Save UART register values when system enter DLPS)
;;;794      * @param  None
;;;795      * @retval None
;;;796      */
;;;797    DATA_RAM_FUNCTION __STATIC_INLINE void UART_DLPS_Enter(void)
;;;798    {
;;;799        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;800        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;801    
;;;802        //access DLH and DLL
;;;803        UART->LCR |= (1 << 7);
;;;804        UART_StoreReg[0] = UART->DLL;
;;;805        UART_StoreReg[1] = UART->DLH_INTCR;
;;;806        UART->LCR &= (~(1 << 7));
;;;807    
;;;808        //save other registers
;;;809        UART_StoreReg[2] = UART->DLH_INTCR;
;;;810        UART_StoreReg[4] = UART->LCR;
;;;811        UART_StoreReg[5] = UART->MCR;
;;;812        UART_StoreReg[6] = UART->SPR;
;;;813        UART_StoreReg[7] = UART->STSR;
;;;814        UART_StoreReg[8] = UART->RX_IDLE_INTTCR;
;;;815        UART_StoreReg[9] = UART->RXIDLE_INTCR;
;;;816        UART_StoreReg[10] = UART->MISCR;
;;;817    
;;;818        return;
;;;819    }
;;;820    
;;;821    /**
;;;822      * @brief  UART exit dlps callback function(Resume UART register values when system exit DLPS)
;;;823      * @param  None
;;;824      * @retval None
;;;825      */
;;;826    DATA_RAM_FUNCTION __STATIC_INLINE void UART_DLPS_Exit(void)
;;;827    {
;;;828        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;829        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;830    
;;;831        //access DLH and DLL
;;;832        UART->LCR |= (1 << 7);
;;;833        UART->DLL = UART_StoreReg[0];
;;;834        UART->DLH_INTCR =  UART_StoreReg[1];
;;;835        UART->LCR &= (~(1 << 7));
;;;836    
;;;837        //access other registers
;;;838        UART->INTID_FCR = (((UART_StoreReg[7] & BIT24) >> 21) | ((UART_StoreReg[7] & 0x7C000000) >> 18) |
;;;839                           (1));
;;;840        UART->LCR = UART_StoreReg[4];
;;;841        UART->MCR = UART_StoreReg[5];
;;;842        UART->SPR = UART_StoreReg[6];
;;;843        UART->STSR = UART_StoreReg[7];
;;;844        UART->DLH_INTCR = UART_StoreReg[2];
;;;845        UART->RX_IDLE_INTTCR = UART_StoreReg[8];
;;;846        UART->RXIDLE_INTCR = UART_StoreReg[9];
;;;847        UART->MISCR = UART_StoreReg[10];
;;;848    
;;;849        return;
;;;850    }
;;;851    #endif
;;;852    
;;;853    
;;;854    #if USE_UART1_DLPS
;;;855    
;;;856    __STATIC_INLINE void UART1_DLPS_Enter(void);
;;;857    __STATIC_INLINE void UART1_DLPS_Exit(void);
;;;858    
;;;859    uint32_t UART1_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;860    
;;;861    /**
;;;862      * @brief  UART1 enter dlps callback function(Save UART1 register values when system enter DLPS)
;;;863      * @param  None
;;;864      * @retval None
;;;865      */
;;;866    DATA_RAM_FUNCTION __STATIC_INLINE void UART1_DLPS_Enter(void)
;;;867    {
;;;868        //enable log uart peripheral & clock
;;;869        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;870        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;871    
;;;872        //access DLH and DLL
;;;873        UART1->LCR |= (1 << 7);
;;;874        UART1_StoreReg[0] = UART1->DLL;
;;;875        UART1_StoreReg[1] = UART1->DLH_INTCR;
;;;876        UART1->LCR &= (~(1 << 7));
;;;877    
;;;878        //save other registers
;;;879        UART1_StoreReg[2] = UART1->DLH_INTCR;
;;;880        UART1_StoreReg[4] = UART1->LCR;
;;;881        UART1_StoreReg[5] = UART1->MCR;
;;;882        UART1_StoreReg[6] = UART1->SPR;
;;;883        UART1_StoreReg[7] = UART1->STSR;
;;;884        UART1_StoreReg[8] = UART1->RX_IDLE_INTTCR;
;;;885        UART1_StoreReg[9] = UART1->RXIDLE_INTCR;
;;;886        UART1_StoreReg[10] = UART1->MISCR;
;;;887    
;;;888        return;
;;;889    }
;;;890    
;;;891    /**
;;;892      * @brief  UART1 exit dlps callback function(Resume UART1 register values when system exit DLPS)
;;;893      * @param  None
;;;894      * @retval None
;;;895      */
;;;896    DATA_RAM_FUNCTION __STATIC_INLINE void UART1_DLPS_Exit(void)
;;;897    {
;;;898        //enable log uart peripheral & clock
;;;899        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;900        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;901    
;;;902        //access DLH and DLL
;;;903        UART1->LCR |= (1 << 7);
;;;904        UART1->DLL = UART1_StoreReg[0];
;;;905        UART1->DLH_INTCR =  UART1_StoreReg[1];
;;;906        UART1->LCR &= (~(1 << 7));
;;;907    
;;;908        //access other registers
;;;909        UART1->INTID_FCR = (((UART1_StoreReg[7] & BIT24) >> 21) | ((UART1_StoreReg[7] & 0x7C000000)
;;;910                                                                   >> 18) | (1));
;;;911        UART1->LCR = UART1_StoreReg[4];
;;;912        UART1->MCR = UART1_StoreReg[5];
;;;913        UART1->SPR = UART1_StoreReg[6];
;;;914        UART1->STSR = UART1_StoreReg[7];
;;;915        UART1->DLH_INTCR = UART1_StoreReg[2];
;;;916        UART1->RX_IDLE_INTTCR = UART1_StoreReg[8];
;;;917        UART1->RXIDLE_INTCR = UART1_StoreReg[9];
;;;918        UART1->MISCR = UART1_StoreReg[10];
;;;919    
;;;920        return;
;;;921    }
;;;922    #endif
;;;923    
;;;924    #if USE_UART2_DLPS
;;;925    
;;;926    __STATIC_INLINE void UART2_DLPS_Enter(void);
;;;927    __STATIC_INLINE void UART2_DLPS_Exit(void);
;;;928    
;;;929    uint32_t UART2_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;930    
;;;931    /**
;;;932      * @brief  UART2 enter dlps callback function(Save UART2 register values when system enter DLPS)
;;;933      * @param  None
;;;934      * @retval None
;;;935      */
;;;936    DATA_RAM_FUNCTION __STATIC_INLINE void UART2_DLPS_Enter(void)
;;;937    {
;;;938        //enable log uart peripheral & clock
;;;939        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;940        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;941    
;;;942        //access DLH and DLL
;;;943        UART2->LCR |= (1 << 7);
;;;944        UART2_StoreReg[0] = UART2->DLL;
;;;945        UART2_StoreReg[1] = UART2->DLH_INTCR;
;;;946        UART2->LCR &= (~(1 << 7));
;;;947    
;;;948        //save other registers
;;;949        UART2_StoreReg[2] = UART2->DLH_INTCR;
;;;950        UART2_StoreReg[4] = UART2->LCR;
;;;951        UART2_StoreReg[5] = UART2->MCR;
;;;952        UART2_StoreReg[6] = UART2->SPR;
;;;953        UART2_StoreReg[7] = UART2->STSR;
;;;954        UART2_StoreReg[8] = UART2->RX_IDLE_INTTCR;
;;;955        UART2_StoreReg[9] = UART2->RXIDLE_INTCR;
;;;956        UART2_StoreReg[10] = UART2->MISCR;
;;;957    
;;;958        return;
;;;959    }
;;;960    
;;;961    /**
;;;962      * @brief  UART2 exit dlps callback function(Resume UART2 register values when system exit DLPS)
;;;963      * @param  None
;;;964      * @retval None
;;;965      */
;;;966    DATA_RAM_FUNCTION __STATIC_INLINE void UART2_DLPS_Exit(void)
;;;967    {
;;;968        //enable log uart peripheral & clock
;;;969        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;970        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;971    
;;;972        //access DLH and DLL
;;;973        UART2->LCR |= (1 << 7);
;;;974        UART2->DLL = UART2_StoreReg[0];
;;;975        UART2->DLH_INTCR =  UART2_StoreReg[1];
;;;976        UART2->LCR &= (~(1 << 7));
;;;977    
;;;978        //access other registers
;;;979        UART2->INTID_FCR = (((UART2_StoreReg[7] & BIT24) >> 21) | ((UART2_StoreReg[7] & 0x7C000000)
;;;980                                                                   >> 18) | (1));
;;;981        UART2->LCR = UART2_StoreReg[4];
;;;982        UART2->MCR = UART2_StoreReg[5];
;;;983        UART2->SPR = UART2_StoreReg[6];
;;;984        UART2->STSR = UART2_StoreReg[7];
;;;985        UART2->DLH_INTCR = UART2_StoreReg[2];
;;;986        UART2->RX_IDLE_INTTCR = UART2_StoreReg[8];
;;;987        UART2->RXIDLE_INTCR = UART2_StoreReg[9];
;;;988        UART2->MISCR = UART2_StoreReg[10];
;;;989    
;;;990        return;
;;;991    }
;;;992    #endif
;;;993    
;;;994    
;;;995    /********************************************** ********************************************************/
;;;996    /**************************************** [ADC DLPS] **************************************************/
;;;997    /*******************************************************************************************************/
;;;998    /*******************************************************************************************************/
;;;999    
;;;1000   #if USE_ADC_DLPS
;;;1001   __STATIC_INLINE void ADC_DLPS_Enter(void);
;;;1002   __STATIC_INLINE void ADC_DLPS_Exit(void);
;;;1003   
;;;1004   uint32_t ADC_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1005   
;;;1006   /**
;;;1007     * @brief  ADC enter dlps callback function(Save ADC register values when system enter DLPS)
;;;1008     * @param  None
;;;1009     * @retval None
;;;1010     */
;;;1011   DATA_RAM_FUNCTION __STATIC_INLINE void ADC_DLPS_Enter(void)
;;;1012   {
;;;1013       /*Open 10M clock source*/
;;;1014       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1015       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1016   
;;;1017       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1018       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1019   
;;;1020       ADC_StoreReg[0] =  ADC->CR;          //0x04
;;;1021       ADC_StoreReg[1] =  ADC->SCHCR;       //0x08
;;;1022       ADC_StoreReg[2] =  ADC->INTCR;       //0x0C
;;;1023       ADC_StoreReg[3] =  ADC->SCHTAB0;     //0x10
;;;1024       ADC_StoreReg[4] =  ADC->SCHTAB1;     //0x14
;;;1025       ADC_StoreReg[5] =  ADC->SCHTAB2;     //0x18
;;;1026       ADC_StoreReg[6] =  ADC->SCHTAB3;     //0x1C
;;;1027       ADC_StoreReg[7] =  ADC->SCHTAB4;     //0x20
;;;1028       ADC_StoreReg[8] =  ADC->SCHTAB5;     //0x24
;;;1029       ADC_StoreReg[9] =  ADC->SCHTAB6;     //0x28
;;;1030       ADC_StoreReg[10] =  ADC->SCHTAB6;    //0x2C
;;;1031       ADC_StoreReg[11] =  ADC->PWRDLY;
;;;1032       ADC_StoreReg[12] =  ADC->DATCLK;
;;;1033       ADC_StoreReg[13] =  ADC->ANACTL;
;;;1034   
;;;1035       uint8_t reg_value = 0;
;;;1036       reg_value = btaon_fast_read_safe(0x110);
;;;1037       btaon_fast_write(0x110, reg_value & (~0x04));
;;;1038   
;;;1039       return;
;;;1040   }
;;;1041   
;;;1042   /**
;;;1043     * @brief  ADC exit dlps callback function(Resume ADC register values when system exit DLPS)
;;;1044     * @param  None
;;;1045     * @retval None
;;;1046     */
;;;1047   DATA_RAM_FUNCTION __STATIC_INLINE void ADC_DLPS_Exit(void)
;;;1048   {
;;;1049       /*Open 10M clock source*/
;;;1050       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1051       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1052   
;;;1053       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1054       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1055   
;;;1056   #if 0
;;;1057       //Todo
;;;1058       ADC->PWRDLY = ADC_StoreReg[10];
;;;1059       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1060       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1061       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1062       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1063       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1064       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1065       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1066       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1067       ADC->SCHCR = ADC_StoreReg[1];
;;;1068       ADC->INTCR = (ADC_StoreReg[2] & 0x1F);
;;;1069   #else
;;;1070       /*Disable all interrupt.*/
;;;1071       ADC->INTCR &= (~0x1f);
;;;1072   
;;;1073       /* Set power mode first */
;;;1074       ADC->PWRDLY = ADC_StoreReg[11];
;;;1075   
;;;1076       /* Disable schedule table */
;;;1077       ADC->SCHCR &= (~0xffff);
;;;1078   
;;;1079       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1080       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1081       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1082       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1083       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1084       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1085       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1086       ADC->SCHTAB7 = ADC_StoreReg[10];
;;;1087       ADC->SCHCR   = ADC_StoreReg[1];
;;;1088       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1089       ADC->DATCLK = ADC_StoreReg[12];
;;;1090       ADC->ANACTL = ADC_StoreReg[13];
;;;1091   
;;;1092       /*Clear ADC FIFO */
;;;1093       ADC->CR |= BIT26;
;;;1094       /* Clear all interrupt */
;;;1095       ADC->INTCR |= (0x1f << 8);
;;;1096   
;;;1097       /* Restore specify interrupt */
;;;1098       ADC->INTCR = ADC_StoreReg[2];
;;;1099   
;;;1100   #endif
;;;1101   
;;;1102       uint8_t reg_value = 0;
;;;1103       reg_value = btaon_fast_read_safe(0x110);
;;;1104       btaon_fast_write(0x110, reg_value | 0x04);
;;;1105   
;;;1106       return;
;;;1107   }
;;;1108   
;;;1109   #endif
;;;1110   
;;;1111   /********************************************** ********************************************************/
;;;1112   /**************************************** [IR DLPS] **************************************************/
;;;1113   /*******************************************************************************************************/
;;;1114   /*******************************************************************************************************/
;;;1115   
;;;1116   #if USE_IR_DLPS
;;;1117   __STATIC_INLINE void IR_DLPS_Enter(void);
;;;1118   __STATIC_INLINE void IR_DLPS_Exit(void);
;;;1119   
;;;1120   uint32_t IR_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1121   
;;;1122   /**
;;;1123     * @brief  IR enter dlps callback function(Save IR register values when system enter DLPS)
;;;1124     * @param  None
;;;1125     * @retval None
;;;1126     */
;;;1127   DATA_RAM_FUNCTION __STATIC_INLINE void IR_DLPS_Enter(void)
;;;1128   {
;;;1129       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1130       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1131   
;;;1132       IR_StoreReg[0] = IR->CLK_DIV;
;;;1133       IR_StoreReg[1] = IR->TX_CONFIG;
;;;1134       IR_StoreReg[2] = IR->RX_CONFIG;
;;;1135       IR_StoreReg[3] = IR->RX_CNT_INT_SEL;
;;;1136   
;;;1137   
;;;1138       return;
;;;1139   }
;;;1140   
;;;1141   /**
;;;1142     * @brief  IR exit dlps callback function(Resume IR register values when system exit DLPS)
;;;1143     * @param  None
;;;1144     * @retval None
;;;1145     */
;;;1146   DATA_RAM_FUNCTION __STATIC_INLINE void IR_DLPS_Exit(void)
;;;1147   {
;;;1148       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1149       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1150   
;;;1151       IR->CLK_DIV = IR_StoreReg[0];
;;;1152       if (IR_StoreReg[1] & BIT31)
;;;1153       {
;;;1154           /* RX MODE */
;;;1155           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1156           IR->RX_CONFIG  = IR_StoreReg[2];
;;;1157           IR->RX_CNT_INT_SEL  = IR_StoreReg[3];
;;;1158       }
;;;1159       else
;;;1160       {
;;;1161           /* TX MODE */
;;;1162           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1163           /* If IR TX mode is idle, must write one data firstly */
;;;1164           IR->TX_FIFO = 0;
;;;1165       }
;;;1166   
;;;1167       return;
;;;1168   }
;;;1169   
;;;1170   #endif
;;;1171   
;;;1172   /********************************************** ********************************************************/
;;;1173   /**************************************** [LCD DLPS] ************************************************/
;;;1174   /*******************************************************************************************************/
;;;1175   /*******************************************************************************************************/
;;;1176   #if USE_LCD_DLPS
;;;1177   
;;;1178   uint32_t LCD_StoreReg[5];
;;;1179   
;;;1180   /**
;;;1181     * @brief  LCD enter dlps callback function(Save LCD register values when system enter DLPS)
;;;1182     * @param  None
;;;1183     * @retval None
;;;1184     */
;;;1185   DATA_RAM_FUNCTION __STATIC_INLINE void LCD_DLPS_Enter(void)
;;;1186   {
;;;1187       /* Enable LCD 8080 interface controller function */
;;;1188       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1189       /* Enable LCD 8080 interface controller clock */
;;;1190       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1191   
;;;1192       LCD_StoreReg[0] = *((volatile uint32_t *)0x400002A8UL) & (0x03 << 28);
;;;1193       LCD_StoreReg[1] = LCD->IMR;
;;;1194       LCD_StoreReg[2] = LCD->CTRL0;
;;;1195       LCD_StoreReg[3] = LCD->CTRL1;
;;;1196       LCD_StoreReg[4] = LCD->CFG;
;;;1197   
;;;1198   }
;;;1199   
;;;1200   /**
;;;1201     * @brief  LCD exit dlps callback function(Resume LCD register values when system exit DLPS)
;;;1202     * @param  None
;;;1203     * @retval None
;;;1204     */
;;;1205   DATA_RAM_FUNCTION __STATIC_INLINE void LCD_DLPS_Exit(void)
;;;1206   {
;;;1207       /* Enable LCD 8080 interface controller function */
;;;1208       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1209       /* Enable LCD 8080 interface controller clock */
;;;1210       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1211   
;;;1212       /* Restore Dedicated SDIO pin option */
;;;1213       *((volatile uint32_t *)0x400002A8UL) &= ~(0x03 << 28);
;;;1214       *((volatile uint32_t *)0x400002A8UL) |= LCD_StoreReg[0];
;;;1215   
;;;1216       /* Initialize LCD */
;;;1217   
;;;1218       LCD->IMR    = LCD_StoreReg[1];
;;;1219       LCD->CTRL1  = LCD_StoreReg[3];
;;;1220       LCD->CFG    = LCD_StoreReg[4];
;;;1221       LCD->CTRL0  = LCD_StoreReg[2];
;;;1222   }
;;;1223   #endif
;;;1224   
;;;1225   /********************************************** ********************************************************/
;;;1226   /**************************************** [I2S0 DLPS] **************************************************/
;;;1227   /*******************************************************************************************************/
;;;1228   /*******************************************************************************************************/
;;;1229   #if USE_I2S0_DLPS
;;;1230   
;;;1231   uint32_t I2S0_StoreReg[4];
;;;1232   
;;;1233   /**
;;;1234     * @brief  I2S0 enter dlps callback function(Save I2S0 register values when system enter DLPS)
;;;1235     * @param  None
;;;1236     * @retval None
;;;1237     */
;;;1238   DATA_RAM_FUNCTION __STATIC_INLINE void I2S0_DLPS_Enter(void)
;;;1239   {
;;;1240       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1241   
;;;1242       I2S0_StoreReg[0] = I2S0->BCLK_DIV;
;;;1243       I2S0_StoreReg[1] = I2S0->CTRL0;
;;;1244       I2S0_StoreReg[2] = I2S0->CTRL1;
;;;1245       I2S0_StoreReg[3] = I2S0->DMA_TRDLR;
;;;1246   }
;;;1247   
;;;1248   /**
;;;1249     * @brief  I2S0 exit dlps callback function(Resume I2S0 register values when system exit DLPS)
;;;1250     * @param  None
;;;1251     * @retval None
;;;1252     */
;;;1253   DATA_RAM_FUNCTION __STATIC_INLINE void I2S0_DLPS_Exit(void)
;;;1254   {
;;;1255       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1256   
;;;1257       /* Reset I2S0 module */
;;;1258       I2S0->CTRL0 |= 1 << 0;
;;;1259       I2S0->CTRL0 &= ~(1 << 0);
;;;1260   
;;;1261       /* Initialize I2S0 */
;;;1262       I2S0->BCLK_DIV  = I2S0_StoreReg[0];
;;;1263       I2S0->CTRL1     = I2S0_StoreReg[2];
;;;1264       I2S0->DMA_TRDLR = I2S0_StoreReg[3];
;;;1265       I2S0->CTRL0     = I2S0_StoreReg[1];
;;;1266   }
;;;1267   #endif
;;;1268   
;;;1269   /********************************************** ********************************************************/
;;;1270   /**************************************** [I2S1 DLPS] **************************************************/
;;;1271   /*******************************************************************************************************/
;;;1272   /*******************************************************************************************************/
;;;1273   #if USE_I2S1_DLPS
;;;1274   
;;;1275   uint32_t I2S1_StoreReg[4];
;;;1276   
;;;1277   /**
;;;1278     * @brief  I2S1 enter dlps callback function(Save I2S1 register values when system enter DLPS)
;;;1279     * @param  None
;;;1280     * @retval None
;;;1281     */
;;;1282   DATA_RAM_FUNCTION __STATIC_INLINE void I2S1_DLPS_Enter(void)
;;;1283   {
;;;1284       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1285   
;;;1286       I2S1_StoreReg[0] = I2S1->BCLK_DIV;
;;;1287       I2S1_StoreReg[1] = I2S1->CTRL0;
;;;1288       I2S1_StoreReg[2] = I2S1->CTRL1;
;;;1289       I2S1_StoreReg[3] = I2S1->DMA_TRDLR;
;;;1290   }
;;;1291   
;;;1292   /**
;;;1293     * @brief  I2S1 exit dlps callback function(Resume I2S1 register values when system exit DLPS)
;;;1294     * @param  None
;;;1295     * @retval None
;;;1296     */
;;;1297   DATA_RAM_FUNCTION __STATIC_INLINE void I2S1_DLPS_Exit(void)
;;;1298   {
;;;1299       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1300   
;;;1301       /* Reset I2S1 module */
;;;1302       I2S1->CTRL0 |= 1 << 0;
;;;1303       I2S1->CTRL0 &= ~(1 << 0);
;;;1304   
;;;1305       /* Initialize I2S1 */
;;;1306       I2S1->BCLK_DIV  = I2S1_StoreReg[0];
;;;1307       I2S1->CTRL1     = I2S1_StoreReg[2];
;;;1308       I2S1->DMA_TRDLR = I2S1_StoreReg[3];
;;;1309       I2S1->CTRL0     = I2S1_StoreReg[1];
;;;1310   }
;;;1311   #endif
;;;1312   
;;;1313   /********************************************** ********************************************************/
;;;1314   /**************************************** [CODEC DLPS] ************************************************/
;;;1315   /*******************************************************************************************************/
;;;1316   /*******************************************************************************************************/
;;;1317   #if USE_CODEC_DLPS
;;;1318   
;;;1319   uint32_t CODEC_StoreReg[7];
;;;1320   
;;;1321   /**
;;;1322     * @brief  CODEC enter dlps callback function(Save CODEC register values when system enter DLPS)
;;;1323     * @param  None
;;;1324     * @retval None
;;;1325     */
;;;1326   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_DLPS_Enter(void)
;;;1327   {
;;;1328       /* Enable codec function and clock */
;;;1329       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1330   
;;;1331       CODEC_StoreReg[0] = CODEC->CR0;
;;;1332       CODEC_StoreReg[1] = CODEC->CR1;
;;;1333       CODEC_StoreReg[2] = CODEC->CR2;
;;;1334       CODEC_StoreReg[3] = CODEC->CLK_CTRL;
;;;1335       CODEC_StoreReg[4] = CODEC->I2S_CTRL;
;;;1336       CODEC_StoreReg[5] = CODEC->ADC_CTRL;
;;;1337       CODEC_StoreReg[6] = CODEC->DAC_CTRL;
;;;1338   }
;;;1339   
;;;1340   /**
;;;1341     * @brief  CODEC exit dlps callback function(Resume CODEC register values when system exit DLPS)
;;;1342     * @param  None
;;;1343     * @retval None
;;;1344     */
;;;1345   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_DLPS_Exit(void)
;;;1346   {
;;;1347       /* Enable codec function and clock */
;;;1348       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1349   
;;;1350       /* Initialize CODEC */
;;;1351       if ((CODEC_StoreReg[3] & 0x900) == 0x900)
;;;1352       {
;;;1353           /* Configure AMIC parameters */
;;;1354           CODEC->CR0 = CODEC_StoreReg[0];
;;;1355           CODEC->CR1 = CODEC_StoreReg[1];
;;;1356           CODEC->CR2 = CODEC_StoreReg[2];
;;;1357       }
;;;1358   
;;;1359       /*  Reset audio digital IP */
;;;1360       CODEC->AUDIO_CTRL = 0;
;;;1361       CODEC->AUDIO_CTRL = 1;
;;;1362   
;;;1363       CODEC->CLK_CTRL = CODEC_StoreReg[3];
;;;1364       CODEC->I2S_CTRL = CODEC_StoreReg[4];
;;;1365       CODEC->ADC_CTRL = CODEC_StoreReg[5];
;;;1366       CODEC->DAC_CTRL = CODEC_StoreReg[6];
;;;1367   }
;;;1368   #endif
;;;1369   
;;;1370   /********************************************** ********************************************************/
;;;1371   /**************************************** [CODEC_EQ1 DLPS] ************************************************/
;;;1372   /*******************************************************************************************************/
;;;1373   /*******************************************************************************************************/
;;;1374   #if USE_CODEC_EQ1_DLPS
;;;1375   
;;;1376   uint32_t CODEC_EQ1_StoreReg[5];
;;;1377   
;;;1378   /**
;;;1379     * @brief  CODEC_EQ1 enter dlps callback function(Save CODEC_EQ1 register values when system enter DLPS)
;;;1380     * @param  None
;;;1381     * @retval None
;;;1382     */
;;;1383   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ1_DLPS_Enter(void)
;;;1384   {
;;;1385       /* Enable codec function and clock */
;;;1386       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1387   
;;;1388       CODEC_EQ1_StoreReg[0] = CODEC_EQ1->EQ_H0;
;;;1389       CODEC_EQ1_StoreReg[1] = CODEC_EQ1->EQ_B1;
;;;1390       CODEC_EQ1_StoreReg[2] = CODEC_EQ1->EQ_B2;
;;;1391       CODEC_EQ1_StoreReg[3] = CODEC_EQ1->EQ_A1;
;;;1392       CODEC_EQ1_StoreReg[4] = CODEC_EQ1->EQ_A2;
;;;1393   }
;;;1394   
;;;1395   /**
;;;1396     * @brief  CODEC_EQ1 exit dlps callback function(Resume CODEC_EQ1 register values when system exit DLPS)
;;;1397     * @param  None
;;;1398     * @retval None
;;;1399     */
;;;1400   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ1_DLPS_Exit(void)
;;;1401   {
;;;1402       /* Enable codec function and clock */
;;;1403       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1404   
;;;1405       CODEC_EQ1->EQ_H0 = CODEC_EQ1_StoreReg[0];
;;;1406       CODEC_EQ1->EQ_B1 = CODEC_EQ1_StoreReg[1];
;;;1407       CODEC_EQ1->EQ_B2 = CODEC_EQ1_StoreReg[2];
;;;1408       CODEC_EQ1->EQ_A1 = CODEC_EQ1_StoreReg[3];
;;;1409       CODEC_EQ1->EQ_A2 = CODEC_EQ1_StoreReg[4];
;;;1410   }
;;;1411   #endif
;;;1412   
;;;1413   /********************************************** ********************************************************/
;;;1414   /**************************************** [CODEC_EQ2 DLPS] ************************************************/
;;;1415   /*******************************************************************************************************/
;;;1416   /*******************************************************************************************************/
;;;1417   #if USE_CODEC_EQ2_DLPS
;;;1418   
;;;1419   uint32_t CODEC_EQ2_StoreReg[5];
;;;1420   
;;;1421   /**
;;;1422     * @brief  CODEC_EQ2 enter dlps callback function(Save CODEC_EQ2 register values when system enter DLPS)
;;;1423     * @param  None
;;;1424     * @retval None
;;;1425     */
;;;1426   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ2_DLPS_Enter(void)
;;;1427   {
;;;1428       /* Enable codec function and clock */
;;;1429       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1430   
;;;1431       CODEC_EQ2_StoreReg[0] = CODEC_EQ2->EQ_H0;
;;;1432       CODEC_EQ2_StoreReg[1] = CODEC_EQ2->EQ_B1;
;;;1433       CODEC_EQ2_StoreReg[2] = CODEC_EQ2->EQ_B2;
;;;1434       CODEC_EQ2_StoreReg[3] = CODEC_EQ2->EQ_A1;
;;;1435       CODEC_EQ2_StoreReg[4] = CODEC_EQ2->EQ_A2;
;;;1436   }
;;;1437   
;;;1438   /**
;;;1439     * @brief  CODEC_EQ2 exit dlps callback function(Resume CODEC_EQ2 register values when system exit DLPS)
;;;1440     * @param  None
;;;1441     * @retval None
;;;1442     */
;;;1443   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ2_DLPS_Exit(void)
;;;1444   {
;;;1445       /* Enable codec function and clock */
;;;1446       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1447   
;;;1448       CODEC_EQ2->EQ_H0 = CODEC_EQ2_StoreReg[0];
;;;1449       CODEC_EQ2->EQ_B1 = CODEC_EQ2_StoreReg[1];
;;;1450       CODEC_EQ2->EQ_B2 = CODEC_EQ2_StoreReg[2];
;;;1451       CODEC_EQ2->EQ_A1 = CODEC_EQ2_StoreReg[3];
;;;1452       CODEC_EQ2->EQ_A2 = CODEC_EQ2_StoreReg[4];
;;;1453   }
;;;1454   #endif
;;;1455   
;;;1456   /********************************************** ********************************************************/
;;;1457   /**************************************** [CODEC_EQ3 DLPS] ************************************************/
;;;1458   /*******************************************************************************************************/
;;;1459   /*******************************************************************************************************/
;;;1460   #if USE_CODEC_EQ3_DLPS
;;;1461   
;;;1462   uint32_t CODEC_EQ3_StoreReg[5];
;;;1463   
;;;1464   /**
;;;1465     * @brief  CODEC_EQ3 enter dlps callback function(Save CODEC_EQ3 register values when system enter DLPS)
;;;1466     * @param  None
;;;1467     * @retval None
;;;1468     */
;;;1469   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ3_DLPS_Enter(void)
;;;1470   {
;;;1471       /* Enable codec function and clock */
;;;1472       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1473   
;;;1474       CODEC_EQ3_StoreReg[0] = CODEC_EQ3->EQ_H0;
;;;1475       CODEC_EQ3_StoreReg[1] = CODEC_EQ3->EQ_B1;
;;;1476       CODEC_EQ3_StoreReg[2] = CODEC_EQ3->EQ_B2;
;;;1477       CODEC_EQ3_StoreReg[3] = CODEC_EQ3->EQ_A1;
;;;1478       CODEC_EQ3_StoreReg[4] = CODEC_EQ3->EQ_A2;
;;;1479   }
;;;1480   
;;;1481   /**
;;;1482     * @brief  CODEC_EQ3 exit dlps callback function(Resume CODEC_EQ3 register values when system exit DLPS)
;;;1483     * @param  None
;;;1484     * @retval None
;;;1485     */
;;;1486   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ3_DLPS_Exit(void)
;;;1487   {
;;;1488       /* Enable codec function and clock */
;;;1489       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1490   
;;;1491       CODEC_EQ3->EQ_H0 = CODEC_EQ3_StoreReg[0];
;;;1492       CODEC_EQ3->EQ_B1 = CODEC_EQ3_StoreReg[1];
;;;1493       CODEC_EQ3->EQ_B2 = CODEC_EQ3_StoreReg[2];
;;;1494       CODEC_EQ3->EQ_A1 = CODEC_EQ3_StoreReg[3];
;;;1495       CODEC_EQ3->EQ_A2 = CODEC_EQ3_StoreReg[4];
;;;1496   }
;;;1497   #endif
;;;1498   
;;;1499   /********************************************** ********************************************************/
;;;1500   /**************************************** [CODEC_EQ4 DLPS] ************************************************/
;;;1501   /*******************************************************************************************************/
;;;1502   /*******************************************************************************************************/
;;;1503   #if USE_CODEC_EQ4_DLPS
;;;1504   
;;;1505   uint32_t CODEC_EQ4_StoreReg[5];
;;;1506   
;;;1507   /**
;;;1508     * @brief  CODEC_EQ4 enter dlps callback function(Save CODEC_EQ4 register values when system enter DLPS)
;;;1509     * @param  None
;;;1510     * @retval None
;;;1511     */
;;;1512   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ4_DLPS_Enter(void)
;;;1513   {
;;;1514       /* Enable codec function and clock */
;;;1515       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1516   
;;;1517       CODEC_EQ4_StoreReg[0] = CODEC_EQ4->EQ_H0;
;;;1518       CODEC_EQ4_StoreReg[1] = CODEC_EQ4->EQ_B1;
;;;1519       CODEC_EQ4_StoreReg[2] = CODEC_EQ4->EQ_B2;
;;;1520       CODEC_EQ4_StoreReg[3] = CODEC_EQ4->EQ_A1;
;;;1521       CODEC_EQ4_StoreReg[4] = CODEC_EQ4->EQ_A2;
;;;1522   }
;;;1523   
;;;1524   /**
;;;1525     * @brief  CODEC_EQ4 exit dlps callback function(Resume CODEC_EQ4 register values when system exit DLPS)
;;;1526     * @param  None
;;;1527     * @retval None
;;;1528     */
;;;1529   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ4_DLPS_Exit(void)
;;;1530   {
;;;1531       /* Enable codec function and clock */
;;;1532       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1533   
;;;1534       CODEC_EQ4->EQ_H0 = CODEC_EQ4_StoreReg[0];
;;;1535       CODEC_EQ4->EQ_B1 = CODEC_EQ4_StoreReg[1];
;;;1536       CODEC_EQ4->EQ_B2 = CODEC_EQ4_StoreReg[2];
;;;1537       CODEC_EQ4->EQ_A1 = CODEC_EQ4_StoreReg[3];
;;;1538       CODEC_EQ4->EQ_A2 = CODEC_EQ4_StoreReg[4];
;;;1539   }
;;;1540   #endif
;;;1541   
;;;1542   /********************************************** ********************************************************/
;;;1543   /**************************************** [CODEC_EQ5 DLPS] ************************************************/
;;;1544   /*******************************************************************************************************/
;;;1545   /*******************************************************************************************************/
;;;1546   #if USE_CODEC_EQ5_DLPS
;;;1547   
;;;1548   uint32_t CODEC_EQ5_StoreReg[5];
;;;1549   
;;;1550   /**
;;;1551     * @brief  CODEC_EQ5 enter dlps callback function(Save CODEC_EQ5 register values when system enter DLPS)
;;;1552     * @param  None
;;;1553     * @retval None
;;;1554     */
;;;1555   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ5_DLPS_Enter(void)
;;;1556   {
;;;1557       /* Enable codec function and clock */
;;;1558       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1559   
;;;1560       CODEC_EQ5_StoreReg[0] = CODEC_EQ5->EQ_H0;
;;;1561       CODEC_EQ5_StoreReg[1] = CODEC_EQ5->EQ_B1;
;;;1562       CODEC_EQ5_StoreReg[2] = CODEC_EQ5->EQ_B2;
;;;1563       CODEC_EQ5_StoreReg[3] = CODEC_EQ5->EQ_A1;
;;;1564       CODEC_EQ5_StoreReg[4] = CODEC_EQ5->EQ_A2;
;;;1565   }
;;;1566   
;;;1567   /**
;;;1568     * @brief  CODEC_EQ5 exit dlps callback function(Resume CODEC_EQ5 register values when system exit DLPS)
;;;1569     * @param  None
;;;1570     * @retval None
;;;1571     */
;;;1572   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ5_DLPS_Exit(void)
;;;1573   {
;;;1574       /* Enable codec function and clock */
;;;1575       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1576   
;;;1577       CODEC_EQ5->EQ_H0 = CODEC_EQ5_StoreReg[0];
;;;1578       CODEC_EQ5->EQ_B1 = CODEC_EQ5_StoreReg[1];
;;;1579       CODEC_EQ5->EQ_B2 = CODEC_EQ5_StoreReg[2];
;;;1580       CODEC_EQ5->EQ_A1 = CODEC_EQ5_StoreReg[3];
;;;1581       CODEC_EQ5->EQ_A2 = CODEC_EQ5_StoreReg[4];
;;;1582   }
;;;1583   #endif
;;;1584   
;;;1585   /**
;;;1586     * @brief  Set Log and SWD pins to SW mode.
;;;1587     * @param  void.
;;;1588     * @retval void.
;;;1589     */
;;;1590   DATA_RAM_FUNCTION __STATIC_INLINE void Log_SWD_DLPS_Enter(void)
;;;1591   {
;;;1592       if (OTP->SWD_ENABLE)
;;;1593       {
;;;1594           Pad_Config(P1_0, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1595           Pad_Config(P1_1, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1596       }
;;;1597   
;;;1598       Pad_Config(OTP->logPin, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1599   
;;;1600   }
;;;1601   
;;;1602   /**
;;;1603     * @brief  Set Log and SWD pins to PINMUX mode.
;;;1604     * @param  void.
;;;1605     * @retval void.
;;;1606     */
;;;1607   DATA_RAM_FUNCTION __STATIC_INLINE void Log_SWD_DLPS_Exit(void)
;;;1608   {
;;;1609       Pad_Config(OTP->logPin, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1610   
;;;1611       if (OTP->SWD_ENABLE)
;;;1612       {
;;;1613           Pad_Config(P1_0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1614           Pad_Config(P1_1, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1615       }
;;;1616   }
;;;1617   
;;;1618   /********************************************** ********************************************************/
;;;1619   /*********************************** [USER Exit DLPS CALLBACK FUCN] *****************************************/
;;;1620   /*******************************************************************************************************/
;;;1621   /*******************************************************************************************************/
;;;1622   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;1623   
;;;1624   DLPS_IO_ExitDlpsCB User_IO_ExitDlpsCB = NULL;
;;;1625   
;;;1626   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1627   
;;;1628   /********************************************** ********************************************************/
;;;1629   /*********************************** [USER Enter DLPS CALLBACK FUCN] *****************************************/
;;;1630   /*******************************************************************************************************/
;;;1631   /*******************************************************************************************************/
;;;1632   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1633   
;;;1634   DLPS_IO_EnterDlpsCB User_IO_EnterDlpsCB = NULL;
;;;1635   
;;;1636   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1637   
;;;1638   /********************************************** ********************************************************/
;;;1639   /*********************************** [Enter & Exit DLPS CALLBACK FUNC] *********************************/
;;;1640   /*******************************************************************************************************/
;;;1641   /*******************************************************************************************************/
;;;1642   #if USE_IO_DRIVER_DLPS
;;;1643   
;;;1644   /**
;;;1645     * @brief  IO enter dlps callback function
;;;1646     * @param  None
;;;1647     * @retval None
;;;1648     */
;;;1649   DATA_RAM_FUNCTION void DLPS_IO_EnterDlpsCb(void)
;;;1650   {
;;;1651       /* low stack do it instead */
;;;1652   //    Pad_ClearAllWakeupINT();
;;;1653   
;;;1654   //    DBG_DIRECT("DLPS_IO_EnterDlpsCb");
;;;1655       NVIC_DisableIRQ(System_IRQn);
;;;1656       CPU_DLPS_Enter();
;;;1657   
;;;1658       Pinmux_DLPS_Enter();
;;;1659   
;;;1660   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1661       if (User_IO_EnterDlpsCB)
        0x00207d88:    6898        .h      LDR      r0,[r3,#8]
        0x00207d8a:    b100        ..      CBZ      r0,0x207d8e ; DLPS_IO_EnterDlpsCb + 106
;;;1662       {
;;;1663           User_IO_EnterDlpsCB();
        0x00207d8c:    4780        .G      BLX      r0
;;; .\..\source\peripheral\rtl876x_io_dlps.c (162)
        0x00207d8e:    f04f4280    O..B    MOV      r2,#0x40000000
        0x00207d92:    f8d2021c    ....    LDR      r0,[r2,#0x21c]
        0x00207d96:    f4407080    @..p    ORR      r0,r0,#0x100
        0x00207d9a:    f8c2021c    ....    STR      r0,[r2,#0x21c]
;;;163        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
        0x00207d9e:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x00207da2:    f0407040    @.@p    ORR      r0,r0,#0x3000000
        0x00207da6:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;164    
;;;165        GPIO_StoreReg[0] = GPIO->DATAOUT;
        0x00207daa:    4965        eI      LDR      r1,[pc,#404] ; [0x207f40] = 0x40001000
        0x00207dac:    680b        .h      LDR      r3,[r1,#0]
        0x00207dae:    4861        aH      LDR      r0,[pc,#388] ; [0x207f34] = 0x20805c
        0x00207db0:    30ac        .0      ADDS     r0,r0,#0xac
;;;166        GPIO_StoreReg[1] = GPIO->DATADIR;
        0x00207db2:    6003        .`      STR      r3,[r0,#0]
        0x00207db4:    684b        Kh      LDR      r3,[r1,#4]
;;;167        GPIO_StoreReg[2] = GPIO->DATASRC;
        0x00207db6:    6043        C`      STR      r3,[r0,#4]
        0x00207db8:    688b        .h      LDR      r3,[r1,#8]
;;;168        GPIO_StoreReg[3] = GPIO->INTEN;
        0x00207dba:    6083        .`      STR      r3,[r0,#8]
        0x00207dbc:    6b0b        .k      LDR      r3,[r1,#0x30]
;;;169        GPIO_StoreReg[4] = GPIO->INTMASK;
        0x00207dbe:    60c3        .`      STR      r3,[r0,#0xc]
        0x00207dc0:    6b4b        Kk      LDR      r3,[r1,#0x34]
;;;170        GPIO_StoreReg[5] = GPIO->INTTYPE;
        0x00207dc2:    6103        .a      STR      r3,[r0,#0x10]
        0x00207dc4:    6b8b        .k      LDR      r3,[r1,#0x38]
;;;171        GPIO_StoreReg[6] = GPIO->INTPOLARITY;
        0x00207dc6:    6143        Ca      STR      r3,[r0,#0x14]
        0x00207dc8:    6bcb        .k      LDR      r3,[r1,#0x3c]
;;;172        GPIO_StoreReg[7] = GPIO->DEBOUNCE;
        0x00207dca:    6183        .a      STR      r3,[r0,#0x18]
        0x00207dcc:    6c89        .l      LDR      r1,[r1,#0x48]
;;;173        GPIO_StoreReg[8] = *(__IO uint32_t *)(0x40000344UL);
        0x00207dce:    61c1        .a      STR      r1,[r0,#0x1c]
        0x00207dd0:    f8d21344    ..D.    LDR      r1,[r2,#0x344]
;;;174    
;;;175        return;
;;;176    }
;;;177    
;;;178    /**
;;;179      * @brief  GPIO exit dlps callback function(Resume GPIO register values when system exit DLPS)
;;;180      * @param  None
;;;181      * @retval None
;;;182      */
;;;183    DATA_RAM_FUNCTION __STATIC_INLINE void GPIO_DLPS_Exit(void)
;;;184    {
;;;185        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;186        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;187    
;;;188        GPIO->DATADIR       = GPIO_StoreReg[1];
;;;189        GPIO->DATASRC       = GPIO_StoreReg[2];
;;;190        GPIO->INTMASK       = GPIO_StoreReg[4];
;;;191        GPIO->INTTYPE       = GPIO_StoreReg[5];
;;;192        GPIO->INTPOLARITY   = GPIO_StoreReg[6];
;;;193        GPIO->DEBOUNCE      = GPIO_StoreReg[7];
;;;194        GPIO->DATAOUT       = GPIO_StoreReg[0];
;;;195        GPIO->INTCLR        = ~(GPIO_StoreReg[1]);
;;;196        GPIO->INTEN         = GPIO_StoreReg[3];
;;;197        *(__IO uint32_t *)(0x40000344UL) = GPIO_StoreReg[8];
;;;198    
;;;199        return;
;;;200    }
;;;201    #endif  /* USE_GPIO_DLPS */
;;;202    
;;;203    
;;;204    /********************************************** ********************************************************/
;;;205    /**************************************** [KEYSCAN DLPS] ***********************************************/
;;;206    /*******************************************************************************************************/
;;;207    /*******************************************************************************************************/
;;;208    #if USE_KEYSCAN_DLPS
;;;209    __STATIC_INLINE void KeyScan_DLPS_Enter(void);
;;;210    __STATIC_INLINE void KeyScan_DLPS_Exit(void);
;;;211    
;;;212    uint32_t KeyScan_StoreReg[7];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;213    
;;;214    /**
;;;215      * @brief  KEYSCAN enter dlps callback function(Save KEYSCAN register values when system enter DLPS)
;;;216      * @param  None
;;;217      * @retval None
;;;218      */
;;;219    DATA_RAM_FUNCTION __STATIC_INLINE void KeyScan_DLPS_Enter(void)
;;;220    {
;;;221        /*Open 5M clock source*/
;;;222        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;223        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;224    
;;;225        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;226        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;227    
;;;228        KeyScan_StoreReg[0] = KEYSCAN->CLKDIV;               /* 0x00 */
;;;229        KeyScan_StoreReg[1] = KEYSCAN->TIMERCR;              /* 0x04 */
;;;230        KeyScan_StoreReg[2] = KEYSCAN->CR;                   /* 0x08 */
;;;231        KeyScan_StoreReg[3] = KEYSCAN->COLCR;                /* 0x0C */
;;;232        KeyScan_StoreReg[4] = KEYSCAN->ROWCR;                /* 0x10 */
;;;233        KeyScan_StoreReg[6] = KEYSCAN->INTMASK;              /* 0x18 */
;;;234    
;;;235        return;
;;;236    }
;;;237    
;;;238    /**
;;;239      * @brief  KEYSCAN exit dlps callback function(Resume KEYSCAN register values when system exit DLPS)
;;;240      * @param  None
;;;241      * @retval None
;;;242      */
;;;243    DATA_RAM_FUNCTION __STATIC_INLINE void KeyScan_DLPS_Exit(void)
;;;244    {
;;;245        /*Open 5M clock source*/
;;;246        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;247        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;248    
;;;249        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;250        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;251    
;;;252        /* Set FSM to idle state */
;;;253        KEYSCAN->CR &= ~BIT31;
;;;254        KEYSCAN->CLKDIV = KeyScan_StoreReg[0];
;;;255        KEYSCAN->CR = (KeyScan_StoreReg[2] & (~(BIT31)));
;;;256        KEYSCAN->TIMERCR = KeyScan_StoreReg[1];
;;;257        KEYSCAN->COLCR = KeyScan_StoreReg[3];
;;;258        KEYSCAN->ROWCR = KeyScan_StoreReg[4];
;;;259        KEYSCAN->INTMASK = KeyScan_StoreReg[6];
;;;260        KEYSCAN->CR |= (KeyScan_StoreReg[2] & ((BIT31)));
;;;261    
;;;262        return;
;;;263    }
;;;264    #endif /* USE_KEYSCAN_DLPS */
;;;265    
;;;266    
;;;267    /********************************************** ********************************************************/
;;;268    /**************************************** [QDEC DLPS] **************************************************/
;;;269    /*******************************************************************************************************/
;;;270    /*******************************************************************************************************/
;;;271    #if USE_QDECODER_DLPS
;;;272    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void);
;;;273    __STATIC_INLINE void QuadDecoder_DLPS_Exit(void);
;;;274    
;;;275    uint32_t QuadDecoder_StoreReg[5];  /*  This array should be placed in RAM ON/Buffer ON.    */
;;;276    
;;;277    /**
;;;278      * @brief  QDEC enter dlps callback function(Save QDEC register values when system enter DLPS)
;;;279      * @param  None
;;;280      * @retval None
;;;281      */
;;;282    DATA_RAM_FUNCTION __STATIC_INLINE void QuadDecoder_DLPS_Enter(void)
;;;283    {
;;;284        /*Open 20M clock source*/
;;;285        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;286        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;287        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;288        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;289    
;;;290        QuadDecoder_StoreReg[0] = QDEC->REG_DIV;
;;;291        QuadDecoder_StoreReg[1] = QDEC->REG_CR_X;
;;;292        QuadDecoder_StoreReg[2] = QDEC->REG_CR_Y;
;;;293        QuadDecoder_StoreReg[3] = QDEC->REG_CR_Z;
;;;294        QuadDecoder_StoreReg[4] = QDEC->INT_MASK;
;;;295    
;;;296        return;
;;;297    }
;;;298    
;;;299    /**
;;;300      * @brief  QDEC exit dlps callback function(Resume QDEC register values when system exit DLPS)
;;;301      * @param  None
;;;302      * @retval None
;;;303      */
;;;304    DATA_RAM_FUNCTION __STATIC_INLINE void QuadDecoder_DLPS_Exit(void)
;;;305    {
;;;306        /*Open 20M clock source*/
;;;307        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;308        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;309        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;310        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;311    
;;;312        //clear flags
;;;313        QDEC->REG_DIV  = QuadDecoder_StoreReg[0];
;;;314        QDEC->REG_CR_X = QuadDecoder_StoreReg[1];
;;;315        QDEC->REG_CR_Y = QuadDecoder_StoreReg[2];
;;;316        QDEC->REG_CR_Z = QuadDecoder_StoreReg[3];
;;;317        QDEC->INT_MASK = QuadDecoder_StoreReg[4];
;;;318    
;;;319        return;
;;;320    }
;;;321    #endif
;;;322    
;;;323    /********************************************** ********************************************************/
;;;324    /**************************************** [SPI0 DLPS] **************************************************/
;;;325    /*******************************************************************************************************/
;;;326    /*******************************************************************************************************/
;;;327    #if USE_SPI0_DLPS
;;;328    __STATIC_INLINE void SPI0_DLPS_Enter(void);
;;;329    __STATIC_INLINE void SPI0_DLPS_Exit(void);
;;;330    
;;;331    uint32_t SPI0_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;332    
;;;333    /**
;;;334      * @brief  SPI0 enter dlps callback function(Save SPI0 register values when system enter DLPS)
;;;335      * @param  None
;;;336      * @retval None
;;;337      */
;;;338    DATA_RAM_FUNCTION __STATIC_INLINE void SPI0_DLPS_Enter(void)
;;;339    {
;;;340        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;341        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;342    
;;;343        SPI0_StoreReg[0] = SPI0->CTRLR0;
;;;344        SPI0_StoreReg[1] = SPI0->CTRLR1;
;;;345        SPI0_StoreReg[2] = SPI0->SSIENR;
;;;346        SPI0_StoreReg[3] = SPI0->SER;
;;;347        SPI0_StoreReg[4] = SPI0->BAUDR;
;;;348        SPI0_StoreReg[5] = SPI0->TXFTLR;
;;;349        SPI0_StoreReg[6] = SPI0->RXFTLR;
;;;350        SPI0_StoreReg[7] = SPI0->IMR;
;;;351        SPI0_StoreReg[8] = SPI0->DMACR;
;;;352        SPI0_StoreReg[9] = SPI0->DMATDLR;
;;;353        SPI0_StoreReg[10] = SPI0->DMARDLR;
;;;354        SPI0_StoreReg[11] = SPI0->RX_SAMPLE_DLY;
;;;355        SPI0_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;356        SPI0_StoreReg[13] = *(volatile uint32_t *)0x4000035CUL;
;;;357    }
;;;358    
;;;359    /**
;;;360      * @brief  SPI0 exit dlps callback function(Resume SPI0 register values when system exit DLPS)
;;;361      * @param  None
;;;362      * @retval None
;;;363      */
;;;364    DATA_RAM_FUNCTION __STATIC_INLINE void SPI0_DLPS_Exit(void)
;;;365    {
;;;366        *(volatile uint32_t *)0x4000035CUL = SPI0_StoreReg[13];
;;;367        *(volatile uint32_t *)0x40000308 = SPI0_StoreReg[12];
;;;368        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;369        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;370    
;;;371        SPI0->CTRLR0 = SPI0_StoreReg[0];
;;;372        SPI0->CTRLR1 = SPI0_StoreReg[1];
;;;373        SPI0->SER = SPI0_StoreReg[3];
;;;374        SPI0->BAUDR = SPI0_StoreReg[4];
;;;375        SPI0->TXFTLR = SPI0_StoreReg[5];
;;;376        SPI0->RXFTLR = SPI0_StoreReg[6];
;;;377        SPI0->IMR = SPI0_StoreReg[7];
;;;378        SPI0->DMACR = SPI0_StoreReg[8];
;;;379        SPI0->DMATDLR = SPI0_StoreReg[9];
;;;380        SPI0->DMARDLR = SPI0_StoreReg[10];
;;;381        SPI0->RX_SAMPLE_DLY = SPI0_StoreReg[11];
;;;382    
;;;383        /* Enable the selected SPI peripheral */
;;;384        SPI0->SSIENR = SPI0_StoreReg[2];
;;;385    }
;;;386    #endif
;;;387    
;;;388    
;;;389    /********************************************** ********************************************************/
;;;390    /**************************************** [SPI1 DLPS] **************************************************/
;;;391    /*******************************************************************************************************/
;;;392    /*******************************************************************************************************/
;;;393    #if USE_SPI1_DLPS
;;;394    __STATIC_INLINE void SPI1_DLPS_Enter(void);
;;;395    __STATIC_INLINE void SPI1_DLPS_Exit(void);
;;;396    
;;;397    uint32_t SPI1_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;398    
;;;399    /**
;;;400      * @brief  SPI1 enter dlps callback function(Save SPI1 register values when system enter DLPS)
;;;401      * @param  None
;;;402      * @retval None
;;;403      */
;;;404    DATA_RAM_FUNCTION __STATIC_INLINE void SPI1_DLPS_Enter(void)
;;;405    {
;;;406        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;407        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;408    
;;;409        SPI1_StoreReg[0] = SPI1->CTRLR0;
;;;410        SPI1_StoreReg[1] = SPI1->CTRLR1;
;;;411        SPI1_StoreReg[2] = SPI1->SSIENR;
;;;412        SPI1_StoreReg[3] = SPI1->SER;
;;;413        SPI1_StoreReg[4] = SPI1->BAUDR;
;;;414        SPI1_StoreReg[5] = SPI1->TXFTLR;
;;;415        SPI1_StoreReg[6] = SPI1->RXFTLR;
;;;416        SPI1_StoreReg[7] = SPI1->IMR;
;;;417        SPI1_StoreReg[8] = SPI1->DMACR;
;;;418        SPI1_StoreReg[9] = SPI1->DMATDLR;
;;;419        SPI1_StoreReg[10] = SPI1->DMARDLR;
;;;420        SPI1_StoreReg[11] = SPI1->RX_SAMPLE_DLY;
;;;421        SPI1_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;422        SPI1_StoreReg[13] = *(volatile uint32_t *)0x4000035CUL;
;;;423    }
;;;424    
;;;425    /**
;;;426      * @brief  SPI1 exit dlps callback function(Resume SPI1 register values when system exit DLPS)
;;;427      * @param  None
;;;428      * @retval None
;;;429      */
;;;430    DATA_RAM_FUNCTION __STATIC_INLINE void SPI1_DLPS_Exit(void)
;;;431    {
;;;432        *(volatile uint32_t *)0x4000035CUL = SPI1_StoreReg[13];
;;;433        *(volatile uint32_t *)0x40000308 = SPI1_StoreReg[12];
;;;434        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;435        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;436    
;;;437        SPI1->CTRLR0 = SPI1_StoreReg[0];
;;;438        SPI1->CTRLR1 = SPI1_StoreReg[1];
;;;439        SPI1->SER = SPI1_StoreReg[3];
;;;440        SPI1->BAUDR = SPI1_StoreReg[4];
;;;441        SPI1->TXFTLR = SPI1_StoreReg[5];
;;;442        SPI1->RXFTLR = SPI1_StoreReg[6];
;;;443        SPI1->IMR = SPI1_StoreReg[7];
;;;444        SPI1->DMACR = SPI1_StoreReg[8];
;;;445        SPI1->DMATDLR = SPI1_StoreReg[9];
;;;446        SPI1->DMARDLR = SPI1_StoreReg[10];
;;;447        SPI1->RX_SAMPLE_DLY = SPI1_StoreReg[11];
;;;448    
;;;449        /* Enable the selected SPI peripheral */
;;;450        SPI1->SSIENR = SPI1_StoreReg[2];
;;;451    }
;;;452    #endif
;;;453    
;;;454    /********************************************** ********************************************************/
;;;455    /**************************************** [SPI2W DLPS] **************************************************/
;;;456    /*******************************************************************************************************/
;;;457    /*******************************************************************************************************/
;;;458    #if USE_SPI2W_DLPS
;;;459    __STATIC_INLINE void SPI2W_DLPS_Enter(void);
;;;460    __STATIC_INLINE void SPI2W_DLPS_Exit(void);
;;;461    
;;;462    uint32_t SPI2W_StoreReg[1];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;463    
;;;464    /**
;;;465      * @brief  SPI2W enter dlps callback function(Save SPI2W register values when system enter DLPS)
;;;466      * @param  None
;;;467      * @retval None
;;;468      */
;;;469    DATA_RAM_FUNCTION __STATIC_INLINE void SPI2W_DLPS_Enter(void)
;;;470    {
;;;471        /*Open 20M clock source*/
;;;472        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;473        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;474    
;;;475        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;476        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;477    
;;;478        SPI2W_StoreReg[0] = SPI3WIRE->CFGR;
;;;479    }
;;;480    
;;;481    /**
;;;482      * @brief  SPI2W exit dlps callback function(Resume SPI2W register values when system exit DLPS)
;;;483      * @param  None
;;;484      * @retval None
;;;485      */
;;;486    DATA_RAM_FUNCTION __STATIC_INLINE void SPI2W_DLPS_Exit(void)
;;;487    {
;;;488        /*Open 20M clock source*/
;;;489        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;490        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;491    
;;;492        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;493        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;494    
;;;495        SPI3WIRE->CFGR = SPI2W_StoreReg[0];
;;;496    }
;;;497    #endif
;;;498    
;;;499    /********************************************** ********************************************************/
;;;500    /**************************************** [I2C0 DLPS] **************************************************/
;;;501    /*******************************************************************************************************/
;;;502    /*******************************************************************************************************/
;;;503    #if USE_I2C0_DLPS
;;;504    __STATIC_INLINE void I2C0_DLPS_Enter(void);
;;;505    __STATIC_INLINE void I2C0_DLPS_Exit(void);
;;;506    
;;;507    uint32_t I2C0_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;508    
;;;509    /**
;;;510      * @brief  I2C0 enter dlps callback function(Save I2C0 register values when system enter DLPS)
;;;511      * @param  None
;;;512      * @retval None
;;;513      */
;;;514    DATA_RAM_FUNCTION __STATIC_INLINE void I2C0_DLPS_Enter(void)
;;;515    {
;;;516        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;517        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;518    
;;;519        I2C0_StoreReg[0] = I2C0->IC_CON;
;;;520        I2C0_StoreReg[1] = I2C0->IC_TAR;
;;;521        I2C0_StoreReg[2] = I2C0->IC_SAR;
;;;522        I2C0_StoreReg[3] = I2C0->IC_HS_MADDR;
;;;523    
;;;524        I2C0_StoreReg[4] = I2C0->IC_SS_SCL_HCNT;
;;;525        I2C0_StoreReg[5] = I2C0->IC_SS_SCL_LCNT;
;;;526        I2C0_StoreReg[6] = I2C0->IC_FS_SCL_HCNT;
;;;527        I2C0_StoreReg[7] = I2C0->IC_FS_SCL_LCNT;
;;;528        I2C0_StoreReg[8] = I2C0->IC_HS_SCL_HCNT;
;;;529        I2C0_StoreReg[9] = I2C0->IC_HS_SCL_LCNT;
;;;530    
;;;531        I2C0_StoreReg[10] = I2C0->IC_INTR_MASK;
;;;532        I2C0_StoreReg[11] = I2C0->IC_RX_TL;
;;;533        I2C0_StoreReg[12] = I2C0->IC_TX_TL;
;;;534        I2C0_StoreReg[13] = I2C0->IC_ENABLE;
;;;535        I2C0_StoreReg[14] = I2C0->IC_SDA_HOLD;
;;;536        I2C0_StoreReg[15] = I2C0->IC_SLV_DATA_NACK_ONLY;
;;;537        I2C0_StoreReg[16] = I2C0->IC_DMA_CR;
;;;538        I2C0_StoreReg[17] = I2C0->IC_DMA_TDLR;
;;;539        I2C0_StoreReg[18] = I2C0->IC_DMA_RDLR;
;;;540    
;;;541        I2C0_StoreReg[19] = I2C0->IC_SDA_SETUP;
;;;542    }
;;;543    
;;;544    /**
;;;545      * @brief  I2C0 exit dlps callback function(Resume I2C0 register values when system exit DLPS)
;;;546      * @param  None
;;;547      * @retval None
;;;548      */
;;;549    DATA_RAM_FUNCTION __STATIC_INLINE void I2C0_DLPS_Exit(void)
;;;550    {
;;;551        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;552        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;553    
;;;554        I2C0->IC_CON = I2C0_StoreReg[0];
;;;555        I2C0->IC_TAR = I2C0_StoreReg[1];
;;;556        I2C0->IC_SAR = I2C0_StoreReg[2];
;;;557        I2C0->IC_HS_MADDR = I2C0_StoreReg[3];
;;;558    
;;;559        I2C0->IC_SS_SCL_HCNT = I2C0_StoreReg[4];
;;;560        I2C0->IC_SS_SCL_LCNT = I2C0_StoreReg[5];
;;;561        I2C0->IC_FS_SCL_HCNT = I2C0_StoreReg[6];
;;;562        I2C0->IC_FS_SCL_LCNT = I2C0_StoreReg[7];
;;;563        I2C0->IC_HS_SCL_HCNT = I2C0_StoreReg[8];
;;;564        I2C0->IC_HS_SCL_LCNT = I2C0_StoreReg[9];
;;;565    
;;;566        I2C0->IC_INTR_MASK = I2C0_StoreReg[10];
;;;567        I2C0->IC_RX_TL = I2C0_StoreReg[11];
;;;568        I2C0->IC_TX_TL = I2C0_StoreReg[12];
;;;569        I2C0->IC_SDA_HOLD = I2C0_StoreReg[14];
;;;570        I2C0->IC_SLV_DATA_NACK_ONLY = I2C0_StoreReg[15];
;;;571        I2C0->IC_DMA_CR = I2C0_StoreReg[16];
;;;572        I2C0->IC_DMA_TDLR = I2C0_StoreReg[17];
;;;573        I2C0->IC_DMA_RDLR = I2C0_StoreReg[18];
;;;574        I2C0->IC_SDA_SETUP = I2C0_StoreReg[19];
;;;575    
;;;576        I2C0->IC_ENABLE = I2C0_StoreReg[13];
;;;577    }
;;;578    #endif
;;;579    
;;;580    /********************************************** ********************************************************/
;;;581    /**************************************** [I2C1 DLPS] **************************************************/
;;;582    /*******************************************************************************************************/
;;;583    /*******************************************************************************************************/
;;;584    #if USE_I2C1_DLPS
;;;585    __STATIC_INLINE void I2C1_DLPS_Enter(void);
;;;586    __STATIC_INLINE void I2C1_DLPS_Exit(void);
;;;587    
;;;588    uint32_t I2C1_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;589    
;;;590    /**
;;;591      * @brief  I2C1 enter dlps callback function(Save I2C1 register values when system enter DLPS)
;;;592      * @param  None
;;;593      * @retval None
;;;594      */
;;;595    DATA_RAM_FUNCTION __STATIC_INLINE void I2C1_DLPS_Enter(void)
;;;596    {
;;;597        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;598        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;599    
;;;600        I2C1_StoreReg[0] = I2C1->IC_CON;
;;;601        I2C1_StoreReg[1] = I2C1->IC_TAR;
;;;602        I2C1_StoreReg[2] = I2C1->IC_SAR;
;;;603        I2C1_StoreReg[3] = I2C1->IC_HS_MADDR;
;;;604    
;;;605        I2C1_StoreReg[4] = I2C1->IC_SS_SCL_HCNT;
;;;606        I2C1_StoreReg[5] = I2C1->IC_SS_SCL_LCNT;
;;;607        I2C1_StoreReg[6] = I2C1->IC_FS_SCL_HCNT;
;;;608        I2C1_StoreReg[7] = I2C1->IC_FS_SCL_LCNT;
;;;609        I2C1_StoreReg[8] = I2C1->IC_HS_SCL_HCNT;
;;;610        I2C1_StoreReg[9] = I2C1->IC_HS_SCL_LCNT;
;;;611    
;;;612        I2C1_StoreReg[10] = I2C1->IC_INTR_MASK;
;;;613        I2C1_StoreReg[11] = I2C1->IC_RX_TL;
;;;614        I2C1_StoreReg[12] = I2C1->IC_TX_TL;
;;;615        I2C1_StoreReg[13] = I2C1->IC_ENABLE;
;;;616        I2C1_StoreReg[14] = I2C1->IC_SDA_HOLD;
;;;617        I2C1_StoreReg[15] = I2C1->IC_SLV_DATA_NACK_ONLY;
;;;618        I2C1_StoreReg[16] = I2C1->IC_DMA_CR;
;;;619        I2C1_StoreReg[17] = I2C1->IC_DMA_TDLR;
;;;620        I2C1_StoreReg[18] = I2C1->IC_DMA_RDLR;
;;;621    
;;;622        I2C1_StoreReg[19] = I2C1->IC_SDA_SETUP;
;;;623    }
;;;624    
;;;625    /**
;;;626      * @brief  I2C1 exit dlps callback function(Resume I2C1 register values when system exit DLPS)
;;;627      * @param  None
;;;628      * @retval None
;;;629      */
;;;630    DATA_RAM_FUNCTION __STATIC_INLINE void I2C1_DLPS_Exit(void)
;;;631    {
;;;632        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;633        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;634    
;;;635        I2C1->IC_CON = I2C1_StoreReg[0];
;;;636        I2C1->IC_TAR = I2C1_StoreReg[1];
;;;637        I2C1->IC_SAR = I2C1_StoreReg[2];
;;;638        I2C0->IC_HS_MADDR = I2C1_StoreReg[3];
;;;639    
;;;640        I2C1->IC_SS_SCL_HCNT = I2C1_StoreReg[4];
;;;641        I2C1->IC_SS_SCL_LCNT = I2C1_StoreReg[5];
;;;642        I2C1->IC_FS_SCL_HCNT = I2C1_StoreReg[6];
;;;643        I2C1->IC_FS_SCL_LCNT = I2C1_StoreReg[7];
;;;644        I2C1->IC_HS_SCL_HCNT = I2C1_StoreReg[8];
;;;645        I2C1->IC_HS_SCL_LCNT = I2C1_StoreReg[9];
;;;646    
;;;647        I2C1->IC_INTR_MASK = I2C1_StoreReg[10];
;;;648        I2C1->IC_RX_TL = I2C1_StoreReg[11];
;;;649        I2C1->IC_TX_TL = I2C1_StoreReg[12];
;;;650        I2C1->IC_SDA_HOLD = I2C1_StoreReg[14];
;;;651        I2C1->IC_SLV_DATA_NACK_ONLY = I2C1_StoreReg[15];
;;;652        I2C1->IC_DMA_CR = I2C1_StoreReg[16];
;;;653        I2C1->IC_DMA_TDLR = I2C1_StoreReg[17];
;;;654        I2C1->IC_DMA_RDLR = I2C1_StoreReg[18];
;;;655        I2C1->IC_SDA_SETUP = I2C1_StoreReg[19];
;;;656    
;;;657        I2C1->IC_ENABLE = I2C1_StoreReg[13];
;;;658    }
;;;659    #endif
;;;660    
;;;661    /********************************************** ********************************************************/
;;;662    /**************************************** [Timer & PWM DLPS] *******************************************/
;;;663    /*******************************************************************************************************/
;;;664    /*******************************************************************************************************/
;;;665    #if USE_TIM_DLPS
;;;666    #include "rtl876x_tim.h"
;;;667    __STATIC_INLINE void TIM_DLPS_Enter(void);
;;;668    __STATIC_INLINE void TIM_DLPS_Exit(void);
;;;669    
;;;670    uint32_t TIM_StoreReg[26];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;671    
;;;672    /* PWM, use with timer */
;;;673    uint32_t PWM0_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;674    
;;;675    uint32_t PWM1_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;676    
;;;677    /**
;;;678      * @brief  TIMER enter dlps callback function(Save TIMER register values when system enter DLPS)
;;;679      * @param  None
;;;680      * @retval None
;;;681      */
;;;682    DATA_RAM_FUNCTION __STATIC_INLINE void TIM_DLPS_Enter(void)
;;;683    {
;;;684        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;685        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;686    
;;;687        TIM_StoreReg[0] = TIM0->LoadCount;
;;;688        TIM_StoreReg[1] = TIM0->ControlReg;
;;;689        TIM_StoreReg[2] = TIMER0_LOAD_COUNT2;
;;;690    
;;;691        TIM_StoreReg[3] = TIM1->LoadCount;
;;;692        TIM_StoreReg[4] = TIM1->ControlReg;
;;;693        TIM_StoreReg[5] = TIMER1_LOAD_COUNT2;
;;;694    
;;;695        TIM_StoreReg[6] = TIM2->LoadCount;
;;;696        TIM_StoreReg[7] = TIM2->ControlReg;
;;;697        TIM_StoreReg[8] = TIMER2_LOAD_COUNT2;
;;;698    
;;;699        TIM_StoreReg[9] = TIM3->LoadCount;
;;;700        TIM_StoreReg[10] = TIM3->ControlReg;
;;;701        TIM_StoreReg[11] = TIMER3_LOAD_COUNT2;
;;;702    
;;;703        TIM_StoreReg[12] = TIM4->LoadCount;
;;;704        TIM_StoreReg[13] = TIM4->ControlReg;
;;;705        TIM_StoreReg[14] = TIMER4_LOAD_COUNT2;
;;;706    
;;;707        TIM_StoreReg[15] = TIM5->LoadCount;
;;;708        TIM_StoreReg[16] = TIM5->ControlReg;
;;;709        TIM_StoreReg[17] = TIMER5_LOAD_COUNT2;
;;;710    
;;;711        TIM_StoreReg[18] = TIM6->LoadCount;
;;;712        TIM_StoreReg[19] = TIM6->ControlReg;
;;;713        TIM_StoreReg[20] = TIMER6_LOAD_COUNT2;
;;;714    
;;;715        TIM_StoreReg[21] = TIM7->LoadCount;
;;;716        TIM_StoreReg[22] = TIM7->ControlReg;
;;;717        TIM_StoreReg[23] = TIMER7_LOAD_COUNT2;
;;;718    
;;;719        TIM_StoreReg[24] = *((volatile uint32_t *)0x4000035CUL);
;;;720        TIM_StoreReg[25] = *((volatile uint32_t *)0x40000360UL);
;;;721    
;;;722        PWM0_StoreReg = TIMER_PWM0_CR;
;;;723    
;;;724        PWM1_StoreReg = TIMER_PWM1_CR;
;;;725    }
;;;726    
;;;727    /**
;;;728      * @brief  TIMER exit dlps callback function(Resume TIMER register values when system exit DLPS)
;;;729      * @param  None
;;;730      * @retval None
;;;731      */
;;;732    DATA_RAM_FUNCTION __STATIC_INLINE void TIM_DLPS_Exit(void)
;;;733    {
;;;734        /* Enable timer IP clock and function */
;;;735        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;736        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;737    
;;;738        *((volatile uint32_t *)0x4000035CUL) = TIM_StoreReg[24];
;;;739        *((volatile uint32_t *)0x40000360UL) = TIM_StoreReg[25];
;;;740    
;;;741        TIM0->LoadCount = TIM_StoreReg[0];
;;;742        TIM0->ControlReg = TIM_StoreReg[1];
;;;743        TIMER0_LOAD_COUNT2 = TIM_StoreReg[2];
;;;744    
;;;745        TIM1->LoadCount = TIM_StoreReg[3];
;;;746        TIM1->ControlReg = TIM_StoreReg[4];
;;;747        TIMER1_LOAD_COUNT2 = TIM_StoreReg[5];
;;;748    
;;;749        TIM2->LoadCount = TIM_StoreReg[6];
;;;750        TIM2->ControlReg = TIM_StoreReg[7];
;;;751        TIMER2_LOAD_COUNT2 = TIM_StoreReg[8];
;;;752    
;;;753        TIM3->LoadCount = TIM_StoreReg[9];
;;;754        TIM3->ControlReg = TIM_StoreReg[10];
;;;755        TIMER3_LOAD_COUNT2 = TIM_StoreReg[11];
;;;756    
;;;757        TIM4->LoadCount = TIM_StoreReg[12];
;;;758        TIM4->ControlReg = TIM_StoreReg[13];
;;;759        TIMER4_LOAD_COUNT2 = TIM_StoreReg[14];
;;;760    
;;;761        TIM5->LoadCount = TIM_StoreReg[15];
;;;762        TIM5->ControlReg = TIM_StoreReg[16];
;;;763        TIMER5_LOAD_COUNT2 = TIM_StoreReg[17];
;;;764    
;;;765        TIM6->LoadCount = TIM_StoreReg[18];
;;;766        TIM6->ControlReg = TIM_StoreReg[19];
;;;767        TIMER6_LOAD_COUNT2 = TIM_StoreReg[20];
;;;768    
;;;769        TIM7->LoadCount = TIM_StoreReg[21];
;;;770        TIM7->ControlReg = TIM_StoreReg[22];
;;;771        TIMER7_LOAD_COUNT2 = TIM_StoreReg[23];
;;;772    
;;;773        TIMER_PWM0_CR = PWM0_StoreReg;
;;;774    
;;;775        TIMER_PWM1_CR = PWM1_StoreReg;
;;;776    }
;;;777    #endif  /* USE_TIM_DLPS */
;;;778    
;;;779    
;;;780    /********************************************** ********************************************************/
;;;781    /**************************************** [UART DLPS] **************************************************/
;;;782    /*******************************************************************************************************/
;;;783    /*******************************************************************************************************/
;;;784    #if USE_UART_DLPS
;;;785    #include "rtl876x_uart.h"
;;;786    
;;;787    __STATIC_INLINE void UART_DLPS_Enter(void);
;;;788    __STATIC_INLINE void UART_DLPS_Exit(void);
;;;789    
;;;790    uint32_t UART_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;791    
;;;792    /**
;;;793      * @brief  UART enter dlps callback function(Save UART register values when system enter DLPS)
;;;794      * @param  None
;;;795      * @retval None
;;;796      */
;;;797    DATA_RAM_FUNCTION __STATIC_INLINE void UART_DLPS_Enter(void)
;;;798    {
;;;799        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;800        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;801    
;;;802        //access DLH and DLL
;;;803        UART->LCR |= (1 << 7);
;;;804        UART_StoreReg[0] = UART->DLL;
;;;805        UART_StoreReg[1] = UART->DLH_INTCR;
;;;806        UART->LCR &= (~(1 << 7));
;;;807    
;;;808        //save other registers
;;;809        UART_StoreReg[2] = UART->DLH_INTCR;
;;;810        UART_StoreReg[4] = UART->LCR;
;;;811        UART_StoreReg[5] = UART->MCR;
;;;812        UART_StoreReg[6] = UART->SPR;
;;;813        UART_StoreReg[7] = UART->STSR;
;;;814        UART_StoreReg[8] = UART->RX_IDLE_INTTCR;
;;;815        UART_StoreReg[9] = UART->RXIDLE_INTCR;
;;;816        UART_StoreReg[10] = UART->MISCR;
;;;817    
;;;818        return;
;;;819    }
;;;820    
;;;821    /**
;;;822      * @brief  UART exit dlps callback function(Resume UART register values when system exit DLPS)
;;;823      * @param  None
;;;824      * @retval None
;;;825      */
;;;826    DATA_RAM_FUNCTION __STATIC_INLINE void UART_DLPS_Exit(void)
;;;827    {
;;;828        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;829        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;830    
;;;831        //access DLH and DLL
;;;832        UART->LCR |= (1 << 7);
;;;833        UART->DLL = UART_StoreReg[0];
;;;834        UART->DLH_INTCR =  UART_StoreReg[1];
;;;835        UART->LCR &= (~(1 << 7));
;;;836    
;;;837        //access other registers
;;;838        UART->INTID_FCR = (((UART_StoreReg[7] & BIT24) >> 21) | ((UART_StoreReg[7] & 0x7C000000) >> 18) |
;;;839                           (1));
;;;840        UART->LCR = UART_StoreReg[4];
;;;841        UART->MCR = UART_StoreReg[5];
;;;842        UART->SPR = UART_StoreReg[6];
;;;843        UART->STSR = UART_StoreReg[7];
;;;844        UART->DLH_INTCR = UART_StoreReg[2];
;;;845        UART->RX_IDLE_INTTCR = UART_StoreReg[8];
;;;846        UART->RXIDLE_INTCR = UART_StoreReg[9];
;;;847        UART->MISCR = UART_StoreReg[10];
;;;848    
;;;849        return;
;;;850    }
;;;851    #endif
;;;852    
;;;853    
;;;854    #if USE_UART1_DLPS
;;;855    
;;;856    __STATIC_INLINE void UART1_DLPS_Enter(void);
;;;857    __STATIC_INLINE void UART1_DLPS_Exit(void);
;;;858    
;;;859    uint32_t UART1_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;860    
;;;861    /**
;;;862      * @brief  UART1 enter dlps callback function(Save UART1 register values when system enter DLPS)
;;;863      * @param  None
;;;864      * @retval None
;;;865      */
;;;866    DATA_RAM_FUNCTION __STATIC_INLINE void UART1_DLPS_Enter(void)
;;;867    {
;;;868        //enable log uart peripheral & clock
;;;869        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;870        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;871    
;;;872        //access DLH and DLL
;;;873        UART1->LCR |= (1 << 7);
;;;874        UART1_StoreReg[0] = UART1->DLL;
;;;875        UART1_StoreReg[1] = UART1->DLH_INTCR;
;;;876        UART1->LCR &= (~(1 << 7));
;;;877    
;;;878        //save other registers
;;;879        UART1_StoreReg[2] = UART1->DLH_INTCR;
;;;880        UART1_StoreReg[4] = UART1->LCR;
;;;881        UART1_StoreReg[5] = UART1->MCR;
;;;882        UART1_StoreReg[6] = UART1->SPR;
;;;883        UART1_StoreReg[7] = UART1->STSR;
;;;884        UART1_StoreReg[8] = UART1->RX_IDLE_INTTCR;
;;;885        UART1_StoreReg[9] = UART1->RXIDLE_INTCR;
;;;886        UART1_StoreReg[10] = UART1->MISCR;
;;;887    
;;;888        return;
;;;889    }
;;;890    
;;;891    /**
;;;892      * @brief  UART1 exit dlps callback function(Resume UART1 register values when system exit DLPS)
;;;893      * @param  None
;;;894      * @retval None
;;;895      */
;;;896    DATA_RAM_FUNCTION __STATIC_INLINE void UART1_DLPS_Exit(void)
;;;897    {
;;;898        //enable log uart peripheral & clock
;;;899        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;900        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;901    
;;;902        //access DLH and DLL
;;;903        UART1->LCR |= (1 << 7);
;;;904        UART1->DLL = UART1_StoreReg[0];
;;;905        UART1->DLH_INTCR =  UART1_StoreReg[1];
;;;906        UART1->LCR &= (~(1 << 7));
;;;907    
;;;908        //access other registers
;;;909        UART1->INTID_FCR = (((UART1_StoreReg[7] & BIT24) >> 21) | ((UART1_StoreReg[7] & 0x7C000000)
;;;910                                                                   >> 18) | (1));
;;;911        UART1->LCR = UART1_StoreReg[4];
;;;912        UART1->MCR = UART1_StoreReg[5];
;;;913        UART1->SPR = UART1_StoreReg[6];
;;;914        UART1->STSR = UART1_StoreReg[7];
;;;915        UART1->DLH_INTCR = UART1_StoreReg[2];
;;;916        UART1->RX_IDLE_INTTCR = UART1_StoreReg[8];
;;;917        UART1->RXIDLE_INTCR = UART1_StoreReg[9];
;;;918        UART1->MISCR = UART1_StoreReg[10];
;;;919    
;;;920        return;
;;;921    }
;;;922    #endif
;;;923    
;;;924    #if USE_UART2_DLPS
;;;925    
;;;926    __STATIC_INLINE void UART2_DLPS_Enter(void);
;;;927    __STATIC_INLINE void UART2_DLPS_Exit(void);
;;;928    
;;;929    uint32_t UART2_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;930    
;;;931    /**
;;;932      * @brief  UART2 enter dlps callback function(Save UART2 register values when system enter DLPS)
;;;933      * @param  None
;;;934      * @retval None
;;;935      */
;;;936    DATA_RAM_FUNCTION __STATIC_INLINE void UART2_DLPS_Enter(void)
;;;937    {
;;;938        //enable log uart peripheral & clock
;;;939        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;940        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;941    
;;;942        //access DLH and DLL
;;;943        UART2->LCR |= (1 << 7);
;;;944        UART2_StoreReg[0] = UART2->DLL;
;;;945        UART2_StoreReg[1] = UART2->DLH_INTCR;
;;;946        UART2->LCR &= (~(1 << 7));
;;;947    
;;;948        //save other registers
;;;949        UART2_StoreReg[2] = UART2->DLH_INTCR;
;;;950        UART2_StoreReg[4] = UART2->LCR;
;;;951        UART2_StoreReg[5] = UART2->MCR;
;;;952        UART2_StoreReg[6] = UART2->SPR;
;;;953        UART2_StoreReg[7] = UART2->STSR;
;;;954        UART2_StoreReg[8] = UART2->RX_IDLE_INTTCR;
;;;955        UART2_StoreReg[9] = UART2->RXIDLE_INTCR;
;;;956        UART2_StoreReg[10] = UART2->MISCR;
;;;957    
;;;958        return;
;;;959    }
;;;960    
;;;961    /**
;;;962      * @brief  UART2 exit dlps callback function(Resume UART2 register values when system exit DLPS)
;;;963      * @param  None
;;;964      * @retval None
;;;965      */
;;;966    DATA_RAM_FUNCTION __STATIC_INLINE void UART2_DLPS_Exit(void)
;;;967    {
;;;968        //enable log uart peripheral & clock
;;;969        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;970        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;971    
;;;972        //access DLH and DLL
;;;973        UART2->LCR |= (1 << 7);
;;;974        UART2->DLL = UART2_StoreReg[0];
;;;975        UART2->DLH_INTCR =  UART2_StoreReg[1];
;;;976        UART2->LCR &= (~(1 << 7));
;;;977    
;;;978        //access other registers
;;;979        UART2->INTID_FCR = (((UART2_StoreReg[7] & BIT24) >> 21) | ((UART2_StoreReg[7] & 0x7C000000)
;;;980                                                                   >> 18) | (1));
;;;981        UART2->LCR = UART2_StoreReg[4];
;;;982        UART2->MCR = UART2_StoreReg[5];
;;;983        UART2->SPR = UART2_StoreReg[6];
;;;984        UART2->STSR = UART2_StoreReg[7];
;;;985        UART2->DLH_INTCR = UART2_StoreReg[2];
;;;986        UART2->RX_IDLE_INTTCR = UART2_StoreReg[8];
;;;987        UART2->RXIDLE_INTCR = UART2_StoreReg[9];
;;;988        UART2->MISCR = UART2_StoreReg[10];
;;;989    
;;;990        return;
;;;991    }
;;;992    #endif
;;;993    
;;;994    
;;;995    /********************************************** ********************************************************/
;;;996    /**************************************** [ADC DLPS] **************************************************/
;;;997    /*******************************************************************************************************/
;;;998    /*******************************************************************************************************/
;;;999    
;;;1000   #if USE_ADC_DLPS
;;;1001   __STATIC_INLINE void ADC_DLPS_Enter(void);
;;;1002   __STATIC_INLINE void ADC_DLPS_Exit(void);
;;;1003   
;;;1004   uint32_t ADC_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1005   
;;;1006   /**
;;;1007     * @brief  ADC enter dlps callback function(Save ADC register values when system enter DLPS)
;;;1008     * @param  None
;;;1009     * @retval None
;;;1010     */
;;;1011   DATA_RAM_FUNCTION __STATIC_INLINE void ADC_DLPS_Enter(void)
;;;1012   {
;;;1013       /*Open 10M clock source*/
;;;1014       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1015       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1016   
;;;1017       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1018       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1019   
;;;1020       ADC_StoreReg[0] =  ADC->CR;          //0x04
;;;1021       ADC_StoreReg[1] =  ADC->SCHCR;       //0x08
;;;1022       ADC_StoreReg[2] =  ADC->INTCR;       //0x0C
;;;1023       ADC_StoreReg[3] =  ADC->SCHTAB0;     //0x10
;;;1024       ADC_StoreReg[4] =  ADC->SCHTAB1;     //0x14
;;;1025       ADC_StoreReg[5] =  ADC->SCHTAB2;     //0x18
;;;1026       ADC_StoreReg[6] =  ADC->SCHTAB3;     //0x1C
;;;1027       ADC_StoreReg[7] =  ADC->SCHTAB4;     //0x20
;;;1028       ADC_StoreReg[8] =  ADC->SCHTAB5;     //0x24
;;;1029       ADC_StoreReg[9] =  ADC->SCHTAB6;     //0x28
;;;1030       ADC_StoreReg[10] =  ADC->SCHTAB6;    //0x2C
;;;1031       ADC_StoreReg[11] =  ADC->PWRDLY;
;;;1032       ADC_StoreReg[12] =  ADC->DATCLK;
;;;1033       ADC_StoreReg[13] =  ADC->ANACTL;
;;;1034   
;;;1035       uint8_t reg_value = 0;
;;;1036       reg_value = btaon_fast_read_safe(0x110);
;;;1037       btaon_fast_write(0x110, reg_value & (~0x04));
;;;1038   
;;;1039       return;
;;;1040   }
;;;1041   
;;;1042   /**
;;;1043     * @brief  ADC exit dlps callback function(Resume ADC register values when system exit DLPS)
;;;1044     * @param  None
;;;1045     * @retval None
;;;1046     */
;;;1047   DATA_RAM_FUNCTION __STATIC_INLINE void ADC_DLPS_Exit(void)
;;;1048   {
;;;1049       /*Open 10M clock source*/
;;;1050       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1051       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1052   
;;;1053       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1054       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1055   
;;;1056   #if 0
;;;1057       //Todo
;;;1058       ADC->PWRDLY = ADC_StoreReg[10];
;;;1059       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1060       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1061       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1062       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1063       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1064       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1065       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1066       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1067       ADC->SCHCR = ADC_StoreReg[1];
;;;1068       ADC->INTCR = (ADC_StoreReg[2] & 0x1F);
;;;1069   #else
;;;1070       /*Disable all interrupt.*/
;;;1071       ADC->INTCR &= (~0x1f);
;;;1072   
;;;1073       /* Set power mode first */
;;;1074       ADC->PWRDLY = ADC_StoreReg[11];
;;;1075   
;;;1076       /* Disable schedule table */
;;;1077       ADC->SCHCR &= (~0xffff);
;;;1078   
;;;1079       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1080       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1081       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1082       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1083       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1084       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1085       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1086       ADC->SCHTAB7 = ADC_StoreReg[10];
;;;1087       ADC->SCHCR   = ADC_StoreReg[1];
;;;1088       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1089       ADC->DATCLK = ADC_StoreReg[12];
;;;1090       ADC->ANACTL = ADC_StoreReg[13];
;;;1091   
;;;1092       /*Clear ADC FIFO */
;;;1093       ADC->CR |= BIT26;
;;;1094       /* Clear all interrupt */
;;;1095       ADC->INTCR |= (0x1f << 8);
;;;1096   
;;;1097       /* Restore specify interrupt */
;;;1098       ADC->INTCR = ADC_StoreReg[2];
;;;1099   
;;;1100   #endif
;;;1101   
;;;1102       uint8_t reg_value = 0;
;;;1103       reg_value = btaon_fast_read_safe(0x110);
;;;1104       btaon_fast_write(0x110, reg_value | 0x04);
;;;1105   
;;;1106       return;
;;;1107   }
;;;1108   
;;;1109   #endif
;;;1110   
;;;1111   /********************************************** ********************************************************/
;;;1112   /**************************************** [IR DLPS] **************************************************/
;;;1113   /*******************************************************************************************************/
;;;1114   /*******************************************************************************************************/
;;;1115   
;;;1116   #if USE_IR_DLPS
;;;1117   __STATIC_INLINE void IR_DLPS_Enter(void);
;;;1118   __STATIC_INLINE void IR_DLPS_Exit(void);
;;;1119   
;;;1120   uint32_t IR_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1121   
;;;1122   /**
;;;1123     * @brief  IR enter dlps callback function(Save IR register values when system enter DLPS)
;;;1124     * @param  None
;;;1125     * @retval None
;;;1126     */
;;;1127   DATA_RAM_FUNCTION __STATIC_INLINE void IR_DLPS_Enter(void)
;;;1128   {
;;;1129       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1130       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1131   
;;;1132       IR_StoreReg[0] = IR->CLK_DIV;
;;;1133       IR_StoreReg[1] = IR->TX_CONFIG;
;;;1134       IR_StoreReg[2] = IR->RX_CONFIG;
;;;1135       IR_StoreReg[3] = IR->RX_CNT_INT_SEL;
;;;1136   
;;;1137   
;;;1138       return;
;;;1139   }
;;;1140   
;;;1141   /**
;;;1142     * @brief  IR exit dlps callback function(Resume IR register values when system exit DLPS)
;;;1143     * @param  None
;;;1144     * @retval None
;;;1145     */
;;;1146   DATA_RAM_FUNCTION __STATIC_INLINE void IR_DLPS_Exit(void)
;;;1147   {
;;;1148       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1149       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1150   
;;;1151       IR->CLK_DIV = IR_StoreReg[0];
;;;1152       if (IR_StoreReg[1] & BIT31)
;;;1153       {
;;;1154           /* RX MODE */
;;;1155           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1156           IR->RX_CONFIG  = IR_StoreReg[2];
;;;1157           IR->RX_CNT_INT_SEL  = IR_StoreReg[3];
;;;1158       }
;;;1159       else
;;;1160       {
;;;1161           /* TX MODE */
;;;1162           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1163           /* If IR TX mode is idle, must write one data firstly */
;;;1164           IR->TX_FIFO = 0;
;;;1165       }
;;;1166   
;;;1167       return;
;;;1168   }
;;;1169   
;;;1170   #endif
;;;1171   
;;;1172   /********************************************** ********************************************************/
;;;1173   /**************************************** [LCD DLPS] ************************************************/
;;;1174   /*******************************************************************************************************/
;;;1175   /*******************************************************************************************************/
;;;1176   #if USE_LCD_DLPS
;;;1177   
;;;1178   uint32_t LCD_StoreReg[5];
;;;1179   
;;;1180   /**
;;;1181     * @brief  LCD enter dlps callback function(Save LCD register values when system enter DLPS)
;;;1182     * @param  None
;;;1183     * @retval None
;;;1184     */
;;;1185   DATA_RAM_FUNCTION __STATIC_INLINE void LCD_DLPS_Enter(void)
;;;1186   {
;;;1187       /* Enable LCD 8080 interface controller function */
;;;1188       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1189       /* Enable LCD 8080 interface controller clock */
;;;1190       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1191   
;;;1192       LCD_StoreReg[0] = *((volatile uint32_t *)0x400002A8UL) & (0x03 << 28);
;;;1193       LCD_StoreReg[1] = LCD->IMR;
;;;1194       LCD_StoreReg[2] = LCD->CTRL0;
;;;1195       LCD_StoreReg[3] = LCD->CTRL1;
;;;1196       LCD_StoreReg[4] = LCD->CFG;
;;;1197   
;;;1198   }
;;;1199   
;;;1200   /**
;;;1201     * @brief  LCD exit dlps callback function(Resume LCD register values when system exit DLPS)
;;;1202     * @param  None
;;;1203     * @retval None
;;;1204     */
;;;1205   DATA_RAM_FUNCTION __STATIC_INLINE void LCD_DLPS_Exit(void)
;;;1206   {
;;;1207       /* Enable LCD 8080 interface controller function */
;;;1208       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1209       /* Enable LCD 8080 interface controller clock */
;;;1210       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1211   
;;;1212       /* Restore Dedicated SDIO pin option */
;;;1213       *((volatile uint32_t *)0x400002A8UL) &= ~(0x03 << 28);
;;;1214       *((volatile uint32_t *)0x400002A8UL) |= LCD_StoreReg[0];
;;;1215   
;;;1216       /* Initialize LCD */
;;;1217   
;;;1218       LCD->IMR    = LCD_StoreReg[1];
;;;1219       LCD->CTRL1  = LCD_StoreReg[3];
;;;1220       LCD->CFG    = LCD_StoreReg[4];
;;;1221       LCD->CTRL0  = LCD_StoreReg[2];
;;;1222   }
;;;1223   #endif
;;;1224   
;;;1225   /********************************************** ********************************************************/
;;;1226   /**************************************** [I2S0 DLPS] **************************************************/
;;;1227   /*******************************************************************************************************/
;;;1228   /*******************************************************************************************************/
;;;1229   #if USE_I2S0_DLPS
;;;1230   
;;;1231   uint32_t I2S0_StoreReg[4];
;;;1232   
;;;1233   /**
;;;1234     * @brief  I2S0 enter dlps callback function(Save I2S0 register values when system enter DLPS)
;;;1235     * @param  None
;;;1236     * @retval None
;;;1237     */
;;;1238   DATA_RAM_FUNCTION __STATIC_INLINE void I2S0_DLPS_Enter(void)
;;;1239   {
;;;1240       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1241   
;;;1242       I2S0_StoreReg[0] = I2S0->BCLK_DIV;
;;;1243       I2S0_StoreReg[1] = I2S0->CTRL0;
;;;1244       I2S0_StoreReg[2] = I2S0->CTRL1;
;;;1245       I2S0_StoreReg[3] = I2S0->DMA_TRDLR;
;;;1246   }
;;;1247   
;;;1248   /**
;;;1249     * @brief  I2S0 exit dlps callback function(Resume I2S0 register values when system exit DLPS)
;;;1250     * @param  None
;;;1251     * @retval None
;;;1252     */
;;;1253   DATA_RAM_FUNCTION __STATIC_INLINE void I2S0_DLPS_Exit(void)
;;;1254   {
;;;1255       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1256   
;;;1257       /* Reset I2S0 module */
;;;1258       I2S0->CTRL0 |= 1 << 0;
;;;1259       I2S0->CTRL0 &= ~(1 << 0);
;;;1260   
;;;1261       /* Initialize I2S0 */
;;;1262       I2S0->BCLK_DIV  = I2S0_StoreReg[0];
;;;1263       I2S0->CTRL1     = I2S0_StoreReg[2];
;;;1264       I2S0->DMA_TRDLR = I2S0_StoreReg[3];
;;;1265       I2S0->CTRL0     = I2S0_StoreReg[1];
;;;1266   }
;;;1267   #endif
;;;1268   
;;;1269   /********************************************** ********************************************************/
;;;1270   /**************************************** [I2S1 DLPS] **************************************************/
;;;1271   /*******************************************************************************************************/
;;;1272   /*******************************************************************************************************/
;;;1273   #if USE_I2S1_DLPS
;;;1274   
;;;1275   uint32_t I2S1_StoreReg[4];
;;;1276   
;;;1277   /**
;;;1278     * @brief  I2S1 enter dlps callback function(Save I2S1 register values when system enter DLPS)
;;;1279     * @param  None
;;;1280     * @retval None
;;;1281     */
;;;1282   DATA_RAM_FUNCTION __STATIC_INLINE void I2S1_DLPS_Enter(void)
;;;1283   {
;;;1284       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1285   
;;;1286       I2S1_StoreReg[0] = I2S1->BCLK_DIV;
;;;1287       I2S1_StoreReg[1] = I2S1->CTRL0;
;;;1288       I2S1_StoreReg[2] = I2S1->CTRL1;
;;;1289       I2S1_StoreReg[3] = I2S1->DMA_TRDLR;
;;;1290   }
;;;1291   
;;;1292   /**
;;;1293     * @brief  I2S1 exit dlps callback function(Resume I2S1 register values when system exit DLPS)
;;;1294     * @param  None
;;;1295     * @retval None
;;;1296     */
;;;1297   DATA_RAM_FUNCTION __STATIC_INLINE void I2S1_DLPS_Exit(void)
;;;1298   {
;;;1299       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1300   
;;;1301       /* Reset I2S1 module */
;;;1302       I2S1->CTRL0 |= 1 << 0;
;;;1303       I2S1->CTRL0 &= ~(1 << 0);
;;;1304   
;;;1305       /* Initialize I2S1 */
;;;1306       I2S1->BCLK_DIV  = I2S1_StoreReg[0];
;;;1307       I2S1->CTRL1     = I2S1_StoreReg[2];
;;;1308       I2S1->DMA_TRDLR = I2S1_StoreReg[3];
;;;1309       I2S1->CTRL0     = I2S1_StoreReg[1];
;;;1310   }
;;;1311   #endif
;;;1312   
;;;1313   /********************************************** ********************************************************/
;;;1314   /**************************************** [CODEC DLPS] ************************************************/
;;;1315   /*******************************************************************************************************/
;;;1316   /*******************************************************************************************************/
;;;1317   #if USE_CODEC_DLPS
;;;1318   
;;;1319   uint32_t CODEC_StoreReg[7];
;;;1320   
;;;1321   /**
;;;1322     * @brief  CODEC enter dlps callback function(Save CODEC register values when system enter DLPS)
;;;1323     * @param  None
;;;1324     * @retval None
;;;1325     */
;;;1326   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_DLPS_Enter(void)
;;;1327   {
;;;1328       /* Enable codec function and clock */
;;;1329       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1330   
;;;1331       CODEC_StoreReg[0] = CODEC->CR0;
;;;1332       CODEC_StoreReg[1] = CODEC->CR1;
;;;1333       CODEC_StoreReg[2] = CODEC->CR2;
;;;1334       CODEC_StoreReg[3] = CODEC->CLK_CTRL;
;;;1335       CODEC_StoreReg[4] = CODEC->I2S_CTRL;
;;;1336       CODEC_StoreReg[5] = CODEC->ADC_CTRL;
;;;1337       CODEC_StoreReg[6] = CODEC->DAC_CTRL;
;;;1338   }
;;;1339   
;;;1340   /**
;;;1341     * @brief  CODEC exit dlps callback function(Resume CODEC register values when system exit DLPS)
;;;1342     * @param  None
;;;1343     * @retval None
;;;1344     */
;;;1345   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_DLPS_Exit(void)
;;;1346   {
;;;1347       /* Enable codec function and clock */
;;;1348       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1349   
;;;1350       /* Initialize CODEC */
;;;1351       if ((CODEC_StoreReg[3] & 0x900) == 0x900)
;;;1352       {
;;;1353           /* Configure AMIC parameters */
;;;1354           CODEC->CR0 = CODEC_StoreReg[0];
;;;1355           CODEC->CR1 = CODEC_StoreReg[1];
;;;1356           CODEC->CR2 = CODEC_StoreReg[2];
;;;1357       }
;;;1358   
;;;1359       /*  Reset audio digital IP */
;;;1360       CODEC->AUDIO_CTRL = 0;
;;;1361       CODEC->AUDIO_CTRL = 1;
;;;1362   
;;;1363       CODEC->CLK_CTRL = CODEC_StoreReg[3];
;;;1364       CODEC->I2S_CTRL = CODEC_StoreReg[4];
;;;1365       CODEC->ADC_CTRL = CODEC_StoreReg[5];
;;;1366       CODEC->DAC_CTRL = CODEC_StoreReg[6];
;;;1367   }
;;;1368   #endif
;;;1369   
;;;1370   /********************************************** ********************************************************/
;;;1371   /**************************************** [CODEC_EQ1 DLPS] ************************************************/
;;;1372   /*******************************************************************************************************/
;;;1373   /*******************************************************************************************************/
;;;1374   #if USE_CODEC_EQ1_DLPS
;;;1375   
;;;1376   uint32_t CODEC_EQ1_StoreReg[5];
;;;1377   
;;;1378   /**
;;;1379     * @brief  CODEC_EQ1 enter dlps callback function(Save CODEC_EQ1 register values when system enter DLPS)
;;;1380     * @param  None
;;;1381     * @retval None
;;;1382     */
;;;1383   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ1_DLPS_Enter(void)
;;;1384   {
;;;1385       /* Enable codec function and clock */
;;;1386       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1387   
;;;1388       CODEC_EQ1_StoreReg[0] = CODEC_EQ1->EQ_H0;
;;;1389       CODEC_EQ1_StoreReg[1] = CODEC_EQ1->EQ_B1;
;;;1390       CODEC_EQ1_StoreReg[2] = CODEC_EQ1->EQ_B2;
;;;1391       CODEC_EQ1_StoreReg[3] = CODEC_EQ1->EQ_A1;
;;;1392       CODEC_EQ1_StoreReg[4] = CODEC_EQ1->EQ_A2;
;;;1393   }
;;;1394   
;;;1395   /**
;;;1396     * @brief  CODEC_EQ1 exit dlps callback function(Resume CODEC_EQ1 register values when system exit DLPS)
;;;1397     * @param  None
;;;1398     * @retval None
;;;1399     */
;;;1400   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ1_DLPS_Exit(void)
;;;1401   {
;;;1402       /* Enable codec function and clock */
;;;1403       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1404   
;;;1405       CODEC_EQ1->EQ_H0 = CODEC_EQ1_StoreReg[0];
;;;1406       CODEC_EQ1->EQ_B1 = CODEC_EQ1_StoreReg[1];
;;;1407       CODEC_EQ1->EQ_B2 = CODEC_EQ1_StoreReg[2];
;;;1408       CODEC_EQ1->EQ_A1 = CODEC_EQ1_StoreReg[3];
;;;1409       CODEC_EQ1->EQ_A2 = CODEC_EQ1_StoreReg[4];
;;;1410   }
;;;1411   #endif
;;;1412   
;;;1413   /********************************************** ********************************************************/
;;;1414   /**************************************** [CODEC_EQ2 DLPS] ************************************************/
;;;1415   /*******************************************************************************************************/
;;;1416   /*******************************************************************************************************/
;;;1417   #if USE_CODEC_EQ2_DLPS
;;;1418   
;;;1419   uint32_t CODEC_EQ2_StoreReg[5];
;;;1420   
;;;1421   /**
;;;1422     * @brief  CODEC_EQ2 enter dlps callback function(Save CODEC_EQ2 register values when system enter DLPS)
;;;1423     * @param  None
;;;1424     * @retval None
;;;1425     */
;;;1426   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ2_DLPS_Enter(void)
;;;1427   {
;;;1428       /* Enable codec function and clock */
;;;1429       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1430   
;;;1431       CODEC_EQ2_StoreReg[0] = CODEC_EQ2->EQ_H0;
;;;1432       CODEC_EQ2_StoreReg[1] = CODEC_EQ2->EQ_B1;
;;;1433       CODEC_EQ2_StoreReg[2] = CODEC_EQ2->EQ_B2;
;;;1434       CODEC_EQ2_StoreReg[3] = CODEC_EQ2->EQ_A1;
;;;1435       CODEC_EQ2_StoreReg[4] = CODEC_EQ2->EQ_A2;
;;;1436   }
;;;1437   
;;;1438   /**
;;;1439     * @brief  CODEC_EQ2 exit dlps callback function(Resume CODEC_EQ2 register values when system exit DLPS)
;;;1440     * @param  None
;;;1441     * @retval None
;;;1442     */
;;;1443   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ2_DLPS_Exit(void)
;;;1444   {
;;;1445       /* Enable codec function and clock */
;;;1446       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1447   
;;;1448       CODEC_EQ2->EQ_H0 = CODEC_EQ2_StoreReg[0];
;;;1449       CODEC_EQ2->EQ_B1 = CODEC_EQ2_StoreReg[1];
;;;1450       CODEC_EQ2->EQ_B2 = CODEC_EQ2_StoreReg[2];
;;;1451       CODEC_EQ2->EQ_A1 = CODEC_EQ2_StoreReg[3];
;;;1452       CODEC_EQ2->EQ_A2 = CODEC_EQ2_StoreReg[4];
;;;1453   }
;;;1454   #endif
;;;1455   
;;;1456   /********************************************** ********************************************************/
;;;1457   /**************************************** [CODEC_EQ3 DLPS] ************************************************/
;;;1458   /*******************************************************************************************************/
;;;1459   /*******************************************************************************************************/
;;;1460   #if USE_CODEC_EQ3_DLPS
;;;1461   
;;;1462   uint32_t CODEC_EQ3_StoreReg[5];
;;;1463   
;;;1464   /**
;;;1465     * @brief  CODEC_EQ3 enter dlps callback function(Save CODEC_EQ3 register values when system enter DLPS)
;;;1466     * @param  None
;;;1467     * @retval None
;;;1468     */
;;;1469   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ3_DLPS_Enter(void)
;;;1470   {
;;;1471       /* Enable codec function and clock */
;;;1472       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1473   
;;;1474       CODEC_EQ3_StoreReg[0] = CODEC_EQ3->EQ_H0;
;;;1475       CODEC_EQ3_StoreReg[1] = CODEC_EQ3->EQ_B1;
;;;1476       CODEC_EQ3_StoreReg[2] = CODEC_EQ3->EQ_B2;
;;;1477       CODEC_EQ3_StoreReg[3] = CODEC_EQ3->EQ_A1;
;;;1478       CODEC_EQ3_StoreReg[4] = CODEC_EQ3->EQ_A2;
;;;1479   }
;;;1480   
;;;1481   /**
;;;1482     * @brief  CODEC_EQ3 exit dlps callback function(Resume CODEC_EQ3 register values when system exit DLPS)
;;;1483     * @param  None
;;;1484     * @retval None
;;;1485     */
;;;1486   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ3_DLPS_Exit(void)
;;;1487   {
;;;1488       /* Enable codec function and clock */
;;;1489       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1490   
;;;1491       CODEC_EQ3->EQ_H0 = CODEC_EQ3_StoreReg[0];
;;;1492       CODEC_EQ3->EQ_B1 = CODEC_EQ3_StoreReg[1];
;;;1493       CODEC_EQ3->EQ_B2 = CODEC_EQ3_StoreReg[2];
;;;1494       CODEC_EQ3->EQ_A1 = CODEC_EQ3_StoreReg[3];
;;;1495       CODEC_EQ3->EQ_A2 = CODEC_EQ3_StoreReg[4];
;;;1496   }
;;;1497   #endif
;;;1498   
;;;1499   /********************************************** ********************************************************/
;;;1500   /**************************************** [CODEC_EQ4 DLPS] ************************************************/
;;;1501   /*******************************************************************************************************/
;;;1502   /*******************************************************************************************************/
;;;1503   #if USE_CODEC_EQ4_DLPS
;;;1504   
;;;1505   uint32_t CODEC_EQ4_StoreReg[5];
;;;1506   
;;;1507   /**
;;;1508     * @brief  CODEC_EQ4 enter dlps callback function(Save CODEC_EQ4 register values when system enter DLPS)
;;;1509     * @param  None
;;;1510     * @retval None
;;;1511     */
;;;1512   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ4_DLPS_Enter(void)
;;;1513   {
;;;1514       /* Enable codec function and clock */
;;;1515       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1516   
;;;1517       CODEC_EQ4_StoreReg[0] = CODEC_EQ4->EQ_H0;
;;;1518       CODEC_EQ4_StoreReg[1] = CODEC_EQ4->EQ_B1;
;;;1519       CODEC_EQ4_StoreReg[2] = CODEC_EQ4->EQ_B2;
;;;1520       CODEC_EQ4_StoreReg[3] = CODEC_EQ4->EQ_A1;
;;;1521       CODEC_EQ4_StoreReg[4] = CODEC_EQ4->EQ_A2;
;;;1522   }
;;;1523   
;;;1524   /**
;;;1525     * @brief  CODEC_EQ4 exit dlps callback function(Resume CODEC_EQ4 register values when system exit DLPS)
;;;1526     * @param  None
;;;1527     * @retval None
;;;1528     */
;;;1529   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ4_DLPS_Exit(void)
;;;1530   {
;;;1531       /* Enable codec function and clock */
;;;1532       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1533   
;;;1534       CODEC_EQ4->EQ_H0 = CODEC_EQ4_StoreReg[0];
;;;1535       CODEC_EQ4->EQ_B1 = CODEC_EQ4_StoreReg[1];
;;;1536       CODEC_EQ4->EQ_B2 = CODEC_EQ4_StoreReg[2];
;;;1537       CODEC_EQ4->EQ_A1 = CODEC_EQ4_StoreReg[3];
;;;1538       CODEC_EQ4->EQ_A2 = CODEC_EQ4_StoreReg[4];
;;;1539   }
;;;1540   #endif
;;;1541   
;;;1542   /********************************************** ********************************************************/
;;;1543   /**************************************** [CODEC_EQ5 DLPS] ************************************************/
;;;1544   /*******************************************************************************************************/
;;;1545   /*******************************************************************************************************/
;;;1546   #if USE_CODEC_EQ5_DLPS
;;;1547   
;;;1548   uint32_t CODEC_EQ5_StoreReg[5];
;;;1549   
;;;1550   /**
;;;1551     * @brief  CODEC_EQ5 enter dlps callback function(Save CODEC_EQ5 register values when system enter DLPS)
;;;1552     * @param  None
;;;1553     * @retval None
;;;1554     */
;;;1555   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ5_DLPS_Enter(void)
;;;1556   {
;;;1557       /* Enable codec function and clock */
;;;1558       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1559   
;;;1560       CODEC_EQ5_StoreReg[0] = CODEC_EQ5->EQ_H0;
;;;1561       CODEC_EQ5_StoreReg[1] = CODEC_EQ5->EQ_B1;
;;;1562       CODEC_EQ5_StoreReg[2] = CODEC_EQ5->EQ_B2;
;;;1563       CODEC_EQ5_StoreReg[3] = CODEC_EQ5->EQ_A1;
;;;1564       CODEC_EQ5_StoreReg[4] = CODEC_EQ5->EQ_A2;
;;;1565   }
;;;1566   
;;;1567   /**
;;;1568     * @brief  CODEC_EQ5 exit dlps callback function(Resume CODEC_EQ5 register values when system exit DLPS)
;;;1569     * @param  None
;;;1570     * @retval None
;;;1571     */
;;;1572   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ5_DLPS_Exit(void)
;;;1573   {
;;;1574       /* Enable codec function and clock */
;;;1575       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1576   
;;;1577       CODEC_EQ5->EQ_H0 = CODEC_EQ5_StoreReg[0];
;;;1578       CODEC_EQ5->EQ_B1 = CODEC_EQ5_StoreReg[1];
;;;1579       CODEC_EQ5->EQ_B2 = CODEC_EQ5_StoreReg[2];
;;;1580       CODEC_EQ5->EQ_A1 = CODEC_EQ5_StoreReg[3];
;;;1581       CODEC_EQ5->EQ_A2 = CODEC_EQ5_StoreReg[4];
;;;1582   }
;;;1583   #endif
;;;1584   
;;;1585   /**
;;;1586     * @brief  Set Log and SWD pins to SW mode.
;;;1587     * @param  void.
;;;1588     * @retval void.
;;;1589     */
;;;1590   DATA_RAM_FUNCTION __STATIC_INLINE void Log_SWD_DLPS_Enter(void)
;;;1591   {
;;;1592       if (OTP->SWD_ENABLE)
        0x00207dd4:    1255        U.      ASRS     r5,r2,#9
        0x00207dd6:    6201        .b      STR      r1,[r0,#0x20]
        0x00207dd8:    f8950334    ..4.    LDRB     r0,[r5,#0x334]
        0x00207ddc:    07c0        ..      LSLS     r0,r0,#31
        0x00207dde:    d00f        ..      BEQ      0x207e00 ; DLPS_IO_EnterDlpsCb + 220
;;;1593       {
;;;1594           Pad_Config(P1_0, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00207de0:    9400        ..      STR      r4,[sp,#0]
        0x00207de2:    2302        .#      MOVS     r3,#2
        0x00207de4:    2201        ."      MOVS     r2,#1
        0x00207de6:    2100        .!      MOVS     r1,#0
        0x00207de8:    2008        .       MOVS     r0,#8
        0x00207dea:    9401        ..      STR      r4,[sp,#4]
        0x00207dec:    f609faf6    ....    BL       Pad_Config ; 0x113dc
;;;1595           Pad_Config(P1_1, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00207df0:    9400        ..      STR      r4,[sp,#0]
        0x00207df2:    2302        .#      MOVS     r3,#2
        0x00207df4:    2201        ."      MOVS     r2,#1
        0x00207df6:    2100        .!      MOVS     r1,#0
        0x00207df8:    2009        .       MOVS     r0,#9
        0x00207dfa:    9401        ..      STR      r4,[sp,#4]
        0x00207dfc:    f609faee    ....    BL       Pad_Config ; 0x113dc
;;;1596       }
;;;1597   
;;;1598       Pad_Config(OTP->logPin, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00207e00:    9400        ..      STR      r4,[sp,#0]
        0x00207e02:    9401        ..      STR      r4,[sp,#4]
        0x00207e04:    f8950398    ....    LDRB     r0,[r5,#0x398]
        0x00207e08:    2301        .#      MOVS     r3,#1
        0x00207e0a:    f000003f    ..?.    AND      r0,r0,#0x3f
        0x00207e0e:    461a        .F      MOV      r2,r3
        0x00207e10:    2100        .!      MOVS     r1,#0
        0x00207e12:    f609fae3    ....    BL       Pad_Config ; 0x113dc
;;;1599   
;;;1600   }
;;;1601   
;;;1602   /**
;;;1603     * @brief  Set Log and SWD pins to PINMUX mode.
;;;1604     * @param  void.
;;;1605     * @retval void.
;;;1606     */
;;;1607   DATA_RAM_FUNCTION __STATIC_INLINE void Log_SWD_DLPS_Exit(void)
;;;1608   {
;;;1609       Pad_Config(OTP->logPin, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1610   
;;;1611       if (OTP->SWD_ENABLE)
;;;1612       {
;;;1613           Pad_Config(P1_0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1614           Pad_Config(P1_1, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1615       }
;;;1616   }
;;;1617   
;;;1618   /********************************************** ********************************************************/
;;;1619   /*********************************** [USER Exit DLPS CALLBACK FUCN] *****************************************/
;;;1620   /*******************************************************************************************************/
;;;1621   /*******************************************************************************************************/
;;;1622   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;1623   
;;;1624   DLPS_IO_ExitDlpsCB User_IO_ExitDlpsCB = NULL;
;;;1625   
;;;1626   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1627   
;;;1628   /********************************************** ********************************************************/
;;;1629   /*********************************** [USER Enter DLPS CALLBACK FUCN] *****************************************/
;;;1630   /*******************************************************************************************************/
;;;1631   /*******************************************************************************************************/
;;;1632   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1633   
;;;1634   DLPS_IO_EnterDlpsCB User_IO_EnterDlpsCB = NULL;
;;;1635   
;;;1636   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1637   
;;;1638   /********************************************** ********************************************************/
;;;1639   /*********************************** [Enter & Exit DLPS CALLBACK FUNC] *********************************/
;;;1640   /*******************************************************************************************************/
;;;1641   /*******************************************************************************************************/
;;;1642   #if USE_IO_DRIVER_DLPS
;;;1643   
;;;1644   /**
;;;1645     * @brief  IO enter dlps callback function
;;;1646     * @param  None
;;;1647     * @retval None
;;;1648     */
;;;1649   DATA_RAM_FUNCTION void DLPS_IO_EnterDlpsCb(void)
;;;1650   {
;;;1651       /* low stack do it instead */
;;;1652   //    Pad_ClearAllWakeupINT();
;;;1653   
;;;1654   //    DBG_DIRECT("DLPS_IO_EnterDlpsCb");
;;;1655       NVIC_DisableIRQ(System_IRQn);
;;;1656       CPU_DLPS_Enter();
;;;1657   
;;;1658       Pinmux_DLPS_Enter();
;;;1659   
;;;1660   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1661       if (User_IO_EnterDlpsCB)
;;;1662       {
;;;1663           User_IO_EnterDlpsCB();
;;;1664       }
;;;1665   #endif
;;;1666   
;;;1667   #if USE_I2C0_DLPS
;;;1668       I2C0_DLPS_Enter();
;;;1669   #endif
;;;1670   
;;;1671   #if USE_I2C1_DLPS
;;;1672       I2C1_DLPS_Enter();
;;;1673   #endif
;;;1674   
;;;1675   #if USE_TIM_DLPS
;;;1676       TIM_DLPS_Enter();
;;;1677   #endif
;;;1678   
;;;1679   #if USE_QDECODER_DLPS
;;;1680       QuadDecoder_DLPS_Enter();
;;;1681   #endif
;;;1682   
;;;1683   #if USE_IR_DLPS
;;;1684       IR_DLPS_Enter();
;;;1685   #endif
;;;1686   
;;;1687   #if USE_UART_DLPS
;;;1688       UART_DLPS_Enter();
;;;1689   #endif
;;;1690   
;;;1691   #if USE_UART1_DLPS
;;;1692       UART1_DLPS_Enter();
;;;1693   #endif
;;;1694   
;;;1695   #if USE_UART2_DLPS
;;;1696       UART2_DLPS_Enter();
;;;1697   #endif
;;;1698   
;;;1699   #if USE_SPI0_DLPS
;;;1700       SPI0_DLPS_Enter();
;;;1701   #endif
;;;1702   
;;;1703   #if USE_SPI1_DLPS
;;;1704       SPI1_DLPS_Enter();
;;;1705   #endif
;;;1706   
;;;1707   #if USE_SPI2W_DLPS
;;;1708       SPI2W_DLPS_Enter();
;;;1709   #endif
;;;1710   
;;;1711   #if USE_KEYSCAN_DLPS
;;;1712       KeyScan_DLPS_Enter();
;;;1713   #endif
;;;1714   
;;;1715   #if USE_GPIO_DLPS
;;;1716       GPIO_DLPS_Enter();
;;;1717   #endif
;;;1718   
;;;1719   #if USE_ADC_DLPS
;;;1720       ADC_DLPS_Enter();
;;;1721   #endif
;;;1722   
;;;1723   #if USE_LCD_DLPS
;;;1724       LCD_DLPS_Enter();
;;;1725   #endif
;;;1726   
;;;1727   #if USE_I2S0_DLPS
;;;1728       I2S0_DLPS_Enter();
;;;1729   #endif
;;;1730   
;;;1731   #if USE_I2S1_DLPS
;;;1732       I2S1_DLPS_Enter();
;;;1733   #endif
;;;1734   
;;;1735   #if USE_CODEC_DLPS
;;;1736       CODEC_DLPS_Enter();
;;;1737   #endif
;;;1738   
;;;1739   #if USE_CODEC_EQ1_DLPS
;;;1740       CODEC_EQ1_DLPS_Enter();
;;;1741   #endif
;;;1742   
;;;1743   #if USE_CODEC_EQ2_DLPS
;;;1744       CODEC_EQ2_DLPS_Enter();
;;;1745   #endif
;;;1746   
;;;1747   #if USE_CODEC_EQ3_DLPS
;;;1748       CODEC_EQ3_DLPS_Enter();
;;;1749   #endif
;;;1750   
;;;1751   #if USE_CODEC_EQ4_DLPS
;;;1752       CODEC_EQ4_DLPS_Enter();
;;;1753   #endif
;;;1754   
;;;1755   #if USE_CODEC_EQ5_DLPS
;;;1756       CODEC_EQ5_DLPS_Enter();
;;;1757   #endif
;;;1758   
;;;1759       Log_SWD_DLPS_Enter();
;;;1760   
;;;1761   }
        0x00207e16:    bd7c        |.      POP      {r2-r6,pc}
    DLPS_IO_ExitDlpsCb
;;;1762   #endif  /* USE_IO_DRIVER_DLPS */
;;;1763   
;;;1764   #if USE_IO_DRIVER_DLPS
;;;1765   /**
;;;1766     * @brief  IO exit dlps callback function.
;;;1767     * @param  None
;;;1768     * @retval None
;;;1769     */
;;;1770   DATA_RAM_FUNCTION void DLPS_IO_ExitDlpsCb(void)
;;;1771   {
        0x00207e18:    b530        0.      PUSH     {r4,r5,lr}
        0x00207e1a:    4946        FI      LDR      r1,[pc,#280] ; [0x207f34] = 0x20805c
;;; .\..\source\peripheral\rtl876x_io_dlps.c (135)
        0x00207e1c:    2000        .       MOVS     r0,#0
        0x00207e1e:    b085        ..      SUB      sp,sp,#0x14
        0x00207e20:    3184        .1      ADDS     r1,r1,#0x84
        0x00207e22:    0082        ..      LSLS     r2,r0,#2
        0x00207e24:    f1024280    ...B    ADD      r2,r2,#0x40000000
        0x00207e28:    f8513020    Q. 0    LDR      r3,[r1,r0,LSL #2]
        0x00207e2c:    f8c23280    ...2    STR      r3,[r2,#0x280]
        0x00207e30:    1c40        @.      ADDS     r0,r0,#1
        0x00207e32:    b2c0        ..      UXTB     r0,r0
        0x00207e34:    280a        .(      CMP      r0,#0xa
        0x00207e36:    d3f4        ..      BCC      0x207e22 ; DLPS_IO_ExitDlpsCb + 10
;;;136        {
;;;137            PINMUX->CFG[i] = Pinmux_StoreReg[i];
;;;138        }
;;;139    
;;;140        return;
;;;141    }
;;;142    #endif
;;;143    
;;;144    /********************************************** ********************************************************/
;;;145    /**************************************** [GPIO DLPS] **************************************************/
;;;146    /*******************************************************************************************************/
;;;147    /*******************************************************************************************************/
;;;148    #if USE_GPIO_DLPS
;;;149    
;;;150    __STATIC_INLINE void GPIO_DLPS_Enter(void);
;;;151    __STATIC_INLINE void GPIO_DLPS_Exit(void);
;;;152    
;;;153    uint32_t GPIO_StoreReg[9];         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;154    
;;;155    /**
;;;156      * @brief  GPIO enter dlps callback function(Save GPIO register values when system enter DLPS)
;;;157      * @param  None
;;;158      * @retval None
;;;159      */
;;;160    DATA_RAM_FUNCTION __STATIC_INLINE void GPIO_DLPS_Enter(void)
;;;161    {
;;;162        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;163        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;164    
;;;165        GPIO_StoreReg[0] = GPIO->DATAOUT;
;;;166        GPIO_StoreReg[1] = GPIO->DATADIR;
;;;167        GPIO_StoreReg[2] = GPIO->DATASRC;
;;;168        GPIO_StoreReg[3] = GPIO->INTEN;
;;;169        GPIO_StoreReg[4] = GPIO->INTMASK;
;;;170        GPIO_StoreReg[5] = GPIO->INTTYPE;
;;;171        GPIO_StoreReg[6] = GPIO->INTPOLARITY;
;;;172        GPIO_StoreReg[7] = GPIO->DEBOUNCE;
;;;173        GPIO_StoreReg[8] = *(__IO uint32_t *)(0x40000344UL);
;;;174    
;;;175        return;
;;;176    }
;;;177    
;;;178    /**
;;;179      * @brief  GPIO exit dlps callback function(Resume GPIO register values when system exit DLPS)
;;;180      * @param  None
;;;181      * @retval None
;;;182      */
;;;183    DATA_RAM_FUNCTION __STATIC_INLINE void GPIO_DLPS_Exit(void)
;;;184    {
;;;185        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;186        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;187    
;;;188        GPIO->DATADIR       = GPIO_StoreReg[1];
;;;189        GPIO->DATASRC       = GPIO_StoreReg[2];
;;;190        GPIO->INTMASK       = GPIO_StoreReg[4];
;;;191        GPIO->INTTYPE       = GPIO_StoreReg[5];
;;;192        GPIO->INTPOLARITY   = GPIO_StoreReg[6];
;;;193        GPIO->DEBOUNCE      = GPIO_StoreReg[7];
;;;194        GPIO->DATAOUT       = GPIO_StoreReg[0];
;;;195        GPIO->INTCLR        = ~(GPIO_StoreReg[1]);
;;;196        GPIO->INTEN         = GPIO_StoreReg[3];
;;;197        *(__IO uint32_t *)(0x40000344UL) = GPIO_StoreReg[8];
;;;198    
;;;199        return;
;;;200    }
;;;201    #endif  /* USE_GPIO_DLPS */
;;;202    
;;;203    
;;;204    /********************************************** ********************************************************/
;;;205    /**************************************** [KEYSCAN DLPS] ***********************************************/
;;;206    /*******************************************************************************************************/
;;;207    /*******************************************************************************************************/
;;;208    #if USE_KEYSCAN_DLPS
;;;209    __STATIC_INLINE void KeyScan_DLPS_Enter(void);
;;;210    __STATIC_INLINE void KeyScan_DLPS_Exit(void);
;;;211    
;;;212    uint32_t KeyScan_StoreReg[7];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;213    
;;;214    /**
;;;215      * @brief  KEYSCAN enter dlps callback function(Save KEYSCAN register values when system enter DLPS)
;;;216      * @param  None
;;;217      * @retval None
;;;218      */
;;;219    DATA_RAM_FUNCTION __STATIC_INLINE void KeyScan_DLPS_Enter(void)
;;;220    {
;;;221        /*Open 5M clock source*/
;;;222        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;223        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;224    
;;;225        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;226        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;227    
;;;228        KeyScan_StoreReg[0] = KEYSCAN->CLKDIV;               /* 0x00 */
;;;229        KeyScan_StoreReg[1] = KEYSCAN->TIMERCR;              /* 0x04 */
;;;230        KeyScan_StoreReg[2] = KEYSCAN->CR;                   /* 0x08 */
;;;231        KeyScan_StoreReg[3] = KEYSCAN->COLCR;                /* 0x0C */
;;;232        KeyScan_StoreReg[4] = KEYSCAN->ROWCR;                /* 0x10 */
;;;233        KeyScan_StoreReg[6] = KEYSCAN->INTMASK;              /* 0x18 */
;;;234    
;;;235        return;
;;;236    }
;;;237    
;;;238    /**
;;;239      * @brief  KEYSCAN exit dlps callback function(Resume KEYSCAN register values when system exit DLPS)
;;;240      * @param  None
;;;241      * @retval None
;;;242      */
;;;243    DATA_RAM_FUNCTION __STATIC_INLINE void KeyScan_DLPS_Exit(void)
;;;244    {
;;;245        /*Open 5M clock source*/
;;;246        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;247        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;248    
;;;249        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;250        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;251    
;;;252        /* Set FSM to idle state */
;;;253        KEYSCAN->CR &= ~BIT31;
;;;254        KEYSCAN->CLKDIV = KeyScan_StoreReg[0];
;;;255        KEYSCAN->CR = (KeyScan_StoreReg[2] & (~(BIT31)));
;;;256        KEYSCAN->TIMERCR = KeyScan_StoreReg[1];
;;;257        KEYSCAN->COLCR = KeyScan_StoreReg[3];
;;;258        KEYSCAN->ROWCR = KeyScan_StoreReg[4];
;;;259        KEYSCAN->INTMASK = KeyScan_StoreReg[6];
;;;260        KEYSCAN->CR |= (KeyScan_StoreReg[2] & ((BIT31)));
;;;261    
;;;262        return;
;;;263    }
;;;264    #endif /* USE_KEYSCAN_DLPS */
;;;265    
;;;266    
;;;267    /********************************************** ********************************************************/
;;;268    /**************************************** [QDEC DLPS] **************************************************/
;;;269    /*******************************************************************************************************/
;;;270    /*******************************************************************************************************/
;;;271    #if USE_QDECODER_DLPS
;;;272    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void);
;;;273    __STATIC_INLINE void QuadDecoder_DLPS_Exit(void);
;;;274    
;;;275    uint32_t QuadDecoder_StoreReg[5];  /*  This array should be placed in RAM ON/Buffer ON.    */
;;;276    
;;;277    /**
;;;278      * @brief  QDEC enter dlps callback function(Save QDEC register values when system enter DLPS)
;;;279      * @param  None
;;;280      * @retval None
;;;281      */
;;;282    DATA_RAM_FUNCTION __STATIC_INLINE void QuadDecoder_DLPS_Enter(void)
;;;283    {
;;;284        /*Open 20M clock source*/
;;;285        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;286        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;287        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;288        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;289    
;;;290        QuadDecoder_StoreReg[0] = QDEC->REG_DIV;
;;;291        QuadDecoder_StoreReg[1] = QDEC->REG_CR_X;
;;;292        QuadDecoder_StoreReg[2] = QDEC->REG_CR_Y;
;;;293        QuadDecoder_StoreReg[3] = QDEC->REG_CR_Z;
;;;294        QuadDecoder_StoreReg[4] = QDEC->INT_MASK;
;;;295    
;;;296        return;
;;;297    }
;;;298    
;;;299    /**
;;;300      * @brief  QDEC exit dlps callback function(Resume QDEC register values when system exit DLPS)
;;;301      * @param  None
;;;302      * @retval None
;;;303      */
;;;304    DATA_RAM_FUNCTION __STATIC_INLINE void QuadDecoder_DLPS_Exit(void)
;;;305    {
;;;306        /*Open 20M clock source*/
;;;307        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;308        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;309        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;310        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;311    
;;;312        //clear flags
;;;313        QDEC->REG_DIV  = QuadDecoder_StoreReg[0];
;;;314        QDEC->REG_CR_X = QuadDecoder_StoreReg[1];
;;;315        QDEC->REG_CR_Y = QuadDecoder_StoreReg[2];
;;;316        QDEC->REG_CR_Z = QuadDecoder_StoreReg[3];
;;;317        QDEC->INT_MASK = QuadDecoder_StoreReg[4];
;;;318    
;;;319        return;
;;;320    }
;;;321    #endif
;;;322    
;;;323    /********************************************** ********************************************************/
;;;324    /**************************************** [SPI0 DLPS] **************************************************/
;;;325    /*******************************************************************************************************/
;;;326    /*******************************************************************************************************/
;;;327    #if USE_SPI0_DLPS
;;;328    __STATIC_INLINE void SPI0_DLPS_Enter(void);
;;;329    __STATIC_INLINE void SPI0_DLPS_Exit(void);
;;;330    
;;;331    uint32_t SPI0_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;332    
;;;333    /**
;;;334      * @brief  SPI0 enter dlps callback function(Save SPI0 register values when system enter DLPS)
;;;335      * @param  None
;;;336      * @retval None
;;;337      */
;;;338    DATA_RAM_FUNCTION __STATIC_INLINE void SPI0_DLPS_Enter(void)
;;;339    {
;;;340        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;341        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;342    
;;;343        SPI0_StoreReg[0] = SPI0->CTRLR0;
;;;344        SPI0_StoreReg[1] = SPI0->CTRLR1;
;;;345        SPI0_StoreReg[2] = SPI0->SSIENR;
;;;346        SPI0_StoreReg[3] = SPI0->SER;
;;;347        SPI0_StoreReg[4] = SPI0->BAUDR;
;;;348        SPI0_StoreReg[5] = SPI0->TXFTLR;
;;;349        SPI0_StoreReg[6] = SPI0->RXFTLR;
;;;350        SPI0_StoreReg[7] = SPI0->IMR;
;;;351        SPI0_StoreReg[8] = SPI0->DMACR;
;;;352        SPI0_StoreReg[9] = SPI0->DMATDLR;
;;;353        SPI0_StoreReg[10] = SPI0->DMARDLR;
;;;354        SPI0_StoreReg[11] = SPI0->RX_SAMPLE_DLY;
;;;355        SPI0_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;356        SPI0_StoreReg[13] = *(volatile uint32_t *)0x4000035CUL;
;;;357    }
;;;358    
;;;359    /**
;;;360      * @brief  SPI0 exit dlps callback function(Resume SPI0 register values when system exit DLPS)
;;;361      * @param  None
;;;362      * @retval None
;;;363      */
;;;364    DATA_RAM_FUNCTION __STATIC_INLINE void SPI0_DLPS_Exit(void)
;;;365    {
;;;366        *(volatile uint32_t *)0x4000035CUL = SPI0_StoreReg[13];
;;;367        *(volatile uint32_t *)0x40000308 = SPI0_StoreReg[12];
;;;368        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;369        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;370    
;;;371        SPI0->CTRLR0 = SPI0_StoreReg[0];
;;;372        SPI0->CTRLR1 = SPI0_StoreReg[1];
;;;373        SPI0->SER = SPI0_StoreReg[3];
;;;374        SPI0->BAUDR = SPI0_StoreReg[4];
;;;375        SPI0->TXFTLR = SPI0_StoreReg[5];
;;;376        SPI0->RXFTLR = SPI0_StoreReg[6];
;;;377        SPI0->IMR = SPI0_StoreReg[7];
;;;378        SPI0->DMACR = SPI0_StoreReg[8];
;;;379        SPI0->DMATDLR = SPI0_StoreReg[9];
;;;380        SPI0->DMARDLR = SPI0_StoreReg[10];
;;;381        SPI0->RX_SAMPLE_DLY = SPI0_StoreReg[11];
;;;382    
;;;383        /* Enable the selected SPI peripheral */
;;;384        SPI0->SSIENR = SPI0_StoreReg[2];
;;;385    }
;;;386    #endif
;;;387    
;;;388    
;;;389    /********************************************** ********************************************************/
;;;390    /**************************************** [SPI1 DLPS] **************************************************/
;;;391    /*******************************************************************************************************/
;;;392    /*******************************************************************************************************/
;;;393    #if USE_SPI1_DLPS
;;;394    __STATIC_INLINE void SPI1_DLPS_Enter(void);
;;;395    __STATIC_INLINE void SPI1_DLPS_Exit(void);
;;;396    
;;;397    uint32_t SPI1_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;398    
;;;399    /**
;;;400      * @brief  SPI1 enter dlps callback function(Save SPI1 register values when system enter DLPS)
;;;401      * @param  None
;;;402      * @retval None
;;;403      */
;;;404    DATA_RAM_FUNCTION __STATIC_INLINE void SPI1_DLPS_Enter(void)
;;;405    {
;;;406        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;407        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;408    
;;;409        SPI1_StoreReg[0] = SPI1->CTRLR0;
;;;410        SPI1_StoreReg[1] = SPI1->CTRLR1;
;;;411        SPI1_StoreReg[2] = SPI1->SSIENR;
;;;412        SPI1_StoreReg[3] = SPI1->SER;
;;;413        SPI1_StoreReg[4] = SPI1->BAUDR;
;;;414        SPI1_StoreReg[5] = SPI1->TXFTLR;
;;;415        SPI1_StoreReg[6] = SPI1->RXFTLR;
;;;416        SPI1_StoreReg[7] = SPI1->IMR;
;;;417        SPI1_StoreReg[8] = SPI1->DMACR;
;;;418        SPI1_StoreReg[9] = SPI1->DMATDLR;
;;;419        SPI1_StoreReg[10] = SPI1->DMARDLR;
;;;420        SPI1_StoreReg[11] = SPI1->RX_SAMPLE_DLY;
;;;421        SPI1_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;422        SPI1_StoreReg[13] = *(volatile uint32_t *)0x4000035CUL;
;;;423    }
;;;424    
;;;425    /**
;;;426      * @brief  SPI1 exit dlps callback function(Resume SPI1 register values when system exit DLPS)
;;;427      * @param  None
;;;428      * @retval None
;;;429      */
;;;430    DATA_RAM_FUNCTION __STATIC_INLINE void SPI1_DLPS_Exit(void)
;;;431    {
;;;432        *(volatile uint32_t *)0x4000035CUL = SPI1_StoreReg[13];
;;;433        *(volatile uint32_t *)0x40000308 = SPI1_StoreReg[12];
;;;434        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;435        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;436    
;;;437        SPI1->CTRLR0 = SPI1_StoreReg[0];
;;;438        SPI1->CTRLR1 = SPI1_StoreReg[1];
;;;439        SPI1->SER = SPI1_StoreReg[3];
;;;440        SPI1->BAUDR = SPI1_StoreReg[4];
;;;441        SPI1->TXFTLR = SPI1_StoreReg[5];
;;;442        SPI1->RXFTLR = SPI1_StoreReg[6];
;;;443        SPI1->IMR = SPI1_StoreReg[7];
;;;444        SPI1->DMACR = SPI1_StoreReg[8];
;;;445        SPI1->DMATDLR = SPI1_StoreReg[9];
;;;446        SPI1->DMARDLR = SPI1_StoreReg[10];
;;;447        SPI1->RX_SAMPLE_DLY = SPI1_StoreReg[11];
;;;448    
;;;449        /* Enable the selected SPI peripheral */
;;;450        SPI1->SSIENR = SPI1_StoreReg[2];
;;;451    }
;;;452    #endif
;;;453    
;;;454    /********************************************** ********************************************************/
;;;455    /**************************************** [SPI2W DLPS] **************************************************/
;;;456    /*******************************************************************************************************/
;;;457    /*******************************************************************************************************/
;;;458    #if USE_SPI2W_DLPS
;;;459    __STATIC_INLINE void SPI2W_DLPS_Enter(void);
;;;460    __STATIC_INLINE void SPI2W_DLPS_Exit(void);
;;;461    
;;;462    uint32_t SPI2W_StoreReg[1];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;463    
;;;464    /**
;;;465      * @brief  SPI2W enter dlps callback function(Save SPI2W register values when system enter DLPS)
;;;466      * @param  None
;;;467      * @retval None
;;;468      */
;;;469    DATA_RAM_FUNCTION __STATIC_INLINE void SPI2W_DLPS_Enter(void)
;;;470    {
;;;471        /*Open 20M clock source*/
;;;472        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;473        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;474    
;;;475        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;476        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;477    
;;;478        SPI2W_StoreReg[0] = SPI3WIRE->CFGR;
;;;479    }
;;;480    
;;;481    /**
;;;482      * @brief  SPI2W exit dlps callback function(Resume SPI2W register values when system exit DLPS)
;;;483      * @param  None
;;;484      * @retval None
;;;485      */
;;;486    DATA_RAM_FUNCTION __STATIC_INLINE void SPI2W_DLPS_Exit(void)
;;;487    {
;;;488        /*Open 20M clock source*/
;;;489        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;490        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;491    
;;;492        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;493        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;494    
;;;495        SPI3WIRE->CFGR = SPI2W_StoreReg[0];
;;;496    }
;;;497    #endif
;;;498    
;;;499    /********************************************** ********************************************************/
;;;500    /**************************************** [I2C0 DLPS] **************************************************/
;;;501    /*******************************************************************************************************/
;;;502    /*******************************************************************************************************/
;;;503    #if USE_I2C0_DLPS
;;;504    __STATIC_INLINE void I2C0_DLPS_Enter(void);
;;;505    __STATIC_INLINE void I2C0_DLPS_Exit(void);
;;;506    
;;;507    uint32_t I2C0_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;508    
;;;509    /**
;;;510      * @brief  I2C0 enter dlps callback function(Save I2C0 register values when system enter DLPS)
;;;511      * @param  None
;;;512      * @retval None
;;;513      */
;;;514    DATA_RAM_FUNCTION __STATIC_INLINE void I2C0_DLPS_Enter(void)
;;;515    {
;;;516        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;517        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;518    
;;;519        I2C0_StoreReg[0] = I2C0->IC_CON;
;;;520        I2C0_StoreReg[1] = I2C0->IC_TAR;
;;;521        I2C0_StoreReg[2] = I2C0->IC_SAR;
;;;522        I2C0_StoreReg[3] = I2C0->IC_HS_MADDR;
;;;523    
;;;524        I2C0_StoreReg[4] = I2C0->IC_SS_SCL_HCNT;
;;;525        I2C0_StoreReg[5] = I2C0->IC_SS_SCL_LCNT;
;;;526        I2C0_StoreReg[6] = I2C0->IC_FS_SCL_HCNT;
;;;527        I2C0_StoreReg[7] = I2C0->IC_FS_SCL_LCNT;
;;;528        I2C0_StoreReg[8] = I2C0->IC_HS_SCL_HCNT;
;;;529        I2C0_StoreReg[9] = I2C0->IC_HS_SCL_LCNT;
;;;530    
;;;531        I2C0_StoreReg[10] = I2C0->IC_INTR_MASK;
;;;532        I2C0_StoreReg[11] = I2C0->IC_RX_TL;
;;;533        I2C0_StoreReg[12] = I2C0->IC_TX_TL;
;;;534        I2C0_StoreReg[13] = I2C0->IC_ENABLE;
;;;535        I2C0_StoreReg[14] = I2C0->IC_SDA_HOLD;
;;;536        I2C0_StoreReg[15] = I2C0->IC_SLV_DATA_NACK_ONLY;
;;;537        I2C0_StoreReg[16] = I2C0->IC_DMA_CR;
;;;538        I2C0_StoreReg[17] = I2C0->IC_DMA_TDLR;
;;;539        I2C0_StoreReg[18] = I2C0->IC_DMA_RDLR;
;;;540    
;;;541        I2C0_StoreReg[19] = I2C0->IC_SDA_SETUP;
;;;542    }
;;;543    
;;;544    /**
;;;545      * @brief  I2C0 exit dlps callback function(Resume I2C0 register values when system exit DLPS)
;;;546      * @param  None
;;;547      * @retval None
;;;548      */
;;;549    DATA_RAM_FUNCTION __STATIC_INLINE void I2C0_DLPS_Exit(void)
;;;550    {
;;;551        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;552        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;553    
;;;554        I2C0->IC_CON = I2C0_StoreReg[0];
;;;555        I2C0->IC_TAR = I2C0_StoreReg[1];
;;;556        I2C0->IC_SAR = I2C0_StoreReg[2];
;;;557        I2C0->IC_HS_MADDR = I2C0_StoreReg[3];
;;;558    
;;;559        I2C0->IC_SS_SCL_HCNT = I2C0_StoreReg[4];
;;;560        I2C0->IC_SS_SCL_LCNT = I2C0_StoreReg[5];
;;;561        I2C0->IC_FS_SCL_HCNT = I2C0_StoreReg[6];
;;;562        I2C0->IC_FS_SCL_LCNT = I2C0_StoreReg[7];
;;;563        I2C0->IC_HS_SCL_HCNT = I2C0_StoreReg[8];
;;;564        I2C0->IC_HS_SCL_LCNT = I2C0_StoreReg[9];
;;;565    
;;;566        I2C0->IC_INTR_MASK = I2C0_StoreReg[10];
;;;567        I2C0->IC_RX_TL = I2C0_StoreReg[11];
;;;568        I2C0->IC_TX_TL = I2C0_StoreReg[12];
;;;569        I2C0->IC_SDA_HOLD = I2C0_StoreReg[14];
;;;570        I2C0->IC_SLV_DATA_NACK_ONLY = I2C0_StoreReg[15];
;;;571        I2C0->IC_DMA_CR = I2C0_StoreReg[16];
;;;572        I2C0->IC_DMA_TDLR = I2C0_StoreReg[17];
;;;573        I2C0->IC_DMA_RDLR = I2C0_StoreReg[18];
;;;574        I2C0->IC_SDA_SETUP = I2C0_StoreReg[19];
;;;575    
;;;576        I2C0->IC_ENABLE = I2C0_StoreReg[13];
;;;577    }
;;;578    #endif
;;;579    
;;;580    /********************************************** ********************************************************/
;;;581    /**************************************** [I2C1 DLPS] **************************************************/
;;;582    /*******************************************************************************************************/
;;;583    /*******************************************************************************************************/
;;;584    #if USE_I2C1_DLPS
;;;585    __STATIC_INLINE void I2C1_DLPS_Enter(void);
;;;586    __STATIC_INLINE void I2C1_DLPS_Exit(void);
;;;587    
;;;588    uint32_t I2C1_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;589    
;;;590    /**
;;;591      * @brief  I2C1 enter dlps callback function(Save I2C1 register values when system enter DLPS)
;;;592      * @param  None
;;;593      * @retval None
;;;594      */
;;;595    DATA_RAM_FUNCTION __STATIC_INLINE void I2C1_DLPS_Enter(void)
;;;596    {
;;;597        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;598        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;599    
;;;600        I2C1_StoreReg[0] = I2C1->IC_CON;
;;;601        I2C1_StoreReg[1] = I2C1->IC_TAR;
;;;602        I2C1_StoreReg[2] = I2C1->IC_SAR;
;;;603        I2C1_StoreReg[3] = I2C1->IC_HS_MADDR;
;;;604    
;;;605        I2C1_StoreReg[4] = I2C1->IC_SS_SCL_HCNT;
;;;606        I2C1_StoreReg[5] = I2C1->IC_SS_SCL_LCNT;
;;;607        I2C1_StoreReg[6] = I2C1->IC_FS_SCL_HCNT;
;;;608        I2C1_StoreReg[7] = I2C1->IC_FS_SCL_LCNT;
;;;609        I2C1_StoreReg[8] = I2C1->IC_HS_SCL_HCNT;
;;;610        I2C1_StoreReg[9] = I2C1->IC_HS_SCL_LCNT;
;;;611    
;;;612        I2C1_StoreReg[10] = I2C1->IC_INTR_MASK;
;;;613        I2C1_StoreReg[11] = I2C1->IC_RX_TL;
;;;614        I2C1_StoreReg[12] = I2C1->IC_TX_TL;
;;;615        I2C1_StoreReg[13] = I2C1->IC_ENABLE;
;;;616        I2C1_StoreReg[14] = I2C1->IC_SDA_HOLD;
;;;617        I2C1_StoreReg[15] = I2C1->IC_SLV_DATA_NACK_ONLY;
;;;618        I2C1_StoreReg[16] = I2C1->IC_DMA_CR;
;;;619        I2C1_StoreReg[17] = I2C1->IC_DMA_TDLR;
;;;620        I2C1_StoreReg[18] = I2C1->IC_DMA_RDLR;
;;;621    
;;;622        I2C1_StoreReg[19] = I2C1->IC_SDA_SETUP;
;;;623    }
;;;624    
;;;625    /**
;;;626      * @brief  I2C1 exit dlps callback function(Resume I2C1 register values when system exit DLPS)
;;;627      * @param  None
;;;628      * @retval None
;;;629      */
;;;630    DATA_RAM_FUNCTION __STATIC_INLINE void I2C1_DLPS_Exit(void)
;;;631    {
;;;632        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;633        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;634    
;;;635        I2C1->IC_CON = I2C1_StoreReg[0];
;;;636        I2C1->IC_TAR = I2C1_StoreReg[1];
;;;637        I2C1->IC_SAR = I2C1_StoreReg[2];
;;;638        I2C0->IC_HS_MADDR = I2C1_StoreReg[3];
;;;639    
;;;640        I2C1->IC_SS_SCL_HCNT = I2C1_StoreReg[4];
;;;641        I2C1->IC_SS_SCL_LCNT = I2C1_StoreReg[5];
;;;642        I2C1->IC_FS_SCL_HCNT = I2C1_StoreReg[6];
;;;643        I2C1->IC_FS_SCL_LCNT = I2C1_StoreReg[7];
;;;644        I2C1->IC_HS_SCL_HCNT = I2C1_StoreReg[8];
;;;645        I2C1->IC_HS_SCL_LCNT = I2C1_StoreReg[9];
;;;646    
;;;647        I2C1->IC_INTR_MASK = I2C1_StoreReg[10];
;;;648        I2C1->IC_RX_TL = I2C1_StoreReg[11];
;;;649        I2C1->IC_TX_TL = I2C1_StoreReg[12];
;;;650        I2C1->IC_SDA_HOLD = I2C1_StoreReg[14];
;;;651        I2C1->IC_SLV_DATA_NACK_ONLY = I2C1_StoreReg[15];
;;;652        I2C1->IC_DMA_CR = I2C1_StoreReg[16];
;;;653        I2C1->IC_DMA_TDLR = I2C1_StoreReg[17];
;;;654        I2C1->IC_DMA_RDLR = I2C1_StoreReg[18];
;;;655        I2C1->IC_SDA_SETUP = I2C1_StoreReg[19];
;;;656    
;;;657        I2C1->IC_ENABLE = I2C1_StoreReg[13];
;;;658    }
;;;659    #endif
;;;660    
;;;661    /********************************************** ********************************************************/
;;;662    /**************************************** [Timer & PWM DLPS] *******************************************/
;;;663    /*******************************************************************************************************/
;;;664    /*******************************************************************************************************/
;;;665    #if USE_TIM_DLPS
;;;666    #include "rtl876x_tim.h"
;;;667    __STATIC_INLINE void TIM_DLPS_Enter(void);
;;;668    __STATIC_INLINE void TIM_DLPS_Exit(void);
;;;669    
;;;670    uint32_t TIM_StoreReg[26];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;671    
;;;672    /* PWM, use with timer */
;;;673    uint32_t PWM0_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;674    
;;;675    uint32_t PWM1_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;676    
;;;677    /**
;;;678      * @brief  TIMER enter dlps callback function(Save TIMER register values when system enter DLPS)
;;;679      * @param  None
;;;680      * @retval None
;;;681      */
;;;682    DATA_RAM_FUNCTION __STATIC_INLINE void TIM_DLPS_Enter(void)
;;;683    {
;;;684        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;685        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;686    
;;;687        TIM_StoreReg[0] = TIM0->LoadCount;
;;;688        TIM_StoreReg[1] = TIM0->ControlReg;
;;;689        TIM_StoreReg[2] = TIMER0_LOAD_COUNT2;
;;;690    
;;;691        TIM_StoreReg[3] = TIM1->LoadCount;
;;;692        TIM_StoreReg[4] = TIM1->ControlReg;
;;;693        TIM_StoreReg[5] = TIMER1_LOAD_COUNT2;
;;;694    
;;;695        TIM_StoreReg[6] = TIM2->LoadCount;
;;;696        TIM_StoreReg[7] = TIM2->ControlReg;
;;;697        TIM_StoreReg[8] = TIMER2_LOAD_COUNT2;
;;;698    
;;;699        TIM_StoreReg[9] = TIM3->LoadCount;
;;;700        TIM_StoreReg[10] = TIM3->ControlReg;
;;;701        TIM_StoreReg[11] = TIMER3_LOAD_COUNT2;
;;;702    
;;;703        TIM_StoreReg[12] = TIM4->LoadCount;
;;;704        TIM_StoreReg[13] = TIM4->ControlReg;
;;;705        TIM_StoreReg[14] = TIMER4_LOAD_COUNT2;
;;;706    
;;;707        TIM_StoreReg[15] = TIM5->LoadCount;
;;;708        TIM_StoreReg[16] = TIM5->ControlReg;
;;;709        TIM_StoreReg[17] = TIMER5_LOAD_COUNT2;
;;;710    
;;;711        TIM_StoreReg[18] = TIM6->LoadCount;
;;;712        TIM_StoreReg[19] = TIM6->ControlReg;
;;;713        TIM_StoreReg[20] = TIMER6_LOAD_COUNT2;
;;;714    
;;;715        TIM_StoreReg[21] = TIM7->LoadCount;
;;;716        TIM_StoreReg[22] = TIM7->ControlReg;
;;;717        TIM_StoreReg[23] = TIMER7_LOAD_COUNT2;
;;;718    
;;;719        TIM_StoreReg[24] = *((volatile uint32_t *)0x4000035CUL);
;;;720        TIM_StoreReg[25] = *((volatile uint32_t *)0x40000360UL);
;;;721    
;;;722        PWM0_StoreReg = TIMER_PWM0_CR;
;;;723    
;;;724        PWM1_StoreReg = TIMER_PWM1_CR;
;;;725    }
;;;726    
;;;727    /**
;;;728      * @brief  TIMER exit dlps callback function(Resume TIMER register values when system exit DLPS)
;;;729      * @param  None
;;;730      * @retval None
;;;731      */
;;;732    DATA_RAM_FUNCTION __STATIC_INLINE void TIM_DLPS_Exit(void)
;;;733    {
;;;734        /* Enable timer IP clock and function */
;;;735        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;736        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;737    
;;;738        *((volatile uint32_t *)0x4000035CUL) = TIM_StoreReg[24];
;;;739        *((volatile uint32_t *)0x40000360UL) = TIM_StoreReg[25];
;;;740    
;;;741        TIM0->LoadCount = TIM_StoreReg[0];
;;;742        TIM0->ControlReg = TIM_StoreReg[1];
;;;743        TIMER0_LOAD_COUNT2 = TIM_StoreReg[2];
;;;744    
;;;745        TIM1->LoadCount = TIM_StoreReg[3];
;;;746        TIM1->ControlReg = TIM_StoreReg[4];
;;;747        TIMER1_LOAD_COUNT2 = TIM_StoreReg[5];
;;;748    
;;;749        TIM2->LoadCount = TIM_StoreReg[6];
;;;750        TIM2->ControlReg = TIM_StoreReg[7];
;;;751        TIMER2_LOAD_COUNT2 = TIM_StoreReg[8];
;;;752    
;;;753        TIM3->LoadCount = TIM_StoreReg[9];
;;;754        TIM3->ControlReg = TIM_StoreReg[10];
;;;755        TIMER3_LOAD_COUNT2 = TIM_StoreReg[11];
;;;756    
;;;757        TIM4->LoadCount = TIM_StoreReg[12];
;;;758        TIM4->ControlReg = TIM_StoreReg[13];
;;;759        TIMER4_LOAD_COUNT2 = TIM_StoreReg[14];
;;;760    
;;;761        TIM5->LoadCount = TIM_StoreReg[15];
;;;762        TIM5->ControlReg = TIM_StoreReg[16];
;;;763        TIMER5_LOAD_COUNT2 = TIM_StoreReg[17];
;;;764    
;;;765        TIM6->LoadCount = TIM_StoreReg[18];
;;;766        TIM6->ControlReg = TIM_StoreReg[19];
;;;767        TIMER6_LOAD_COUNT2 = TIM_StoreReg[20];
;;;768    
;;;769        TIM7->LoadCount = TIM_StoreReg[21];
;;;770        TIM7->ControlReg = TIM_StoreReg[22];
;;;771        TIMER7_LOAD_COUNT2 = TIM_StoreReg[23];
;;;772    
;;;773        TIMER_PWM0_CR = PWM0_StoreReg;
;;;774    
;;;775        TIMER_PWM1_CR = PWM1_StoreReg;
;;;776    }
;;;777    #endif  /* USE_TIM_DLPS */
;;;778    
;;;779    
;;;780    /********************************************** ********************************************************/
;;;781    /**************************************** [UART DLPS] **************************************************/
;;;782    /*******************************************************************************************************/
;;;783    /*******************************************************************************************************/
;;;784    #if USE_UART_DLPS
;;;785    #include "rtl876x_uart.h"
;;;786    
;;;787    __STATIC_INLINE void UART_DLPS_Enter(void);
;;;788    __STATIC_INLINE void UART_DLPS_Exit(void);
;;;789    
;;;790    uint32_t UART_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;791    
;;;792    /**
;;;793      * @brief  UART enter dlps callback function(Save UART register values when system enter DLPS)
;;;794      * @param  None
;;;795      * @retval None
;;;796      */
;;;797    DATA_RAM_FUNCTION __STATIC_INLINE void UART_DLPS_Enter(void)
;;;798    {
;;;799        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;800        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;801    
;;;802        //access DLH and DLL
;;;803        UART->LCR |= (1 << 7);
;;;804        UART_StoreReg[0] = UART->DLL;
;;;805        UART_StoreReg[1] = UART->DLH_INTCR;
;;;806        UART->LCR &= (~(1 << 7));
;;;807    
;;;808        //save other registers
;;;809        UART_StoreReg[2] = UART->DLH_INTCR;
;;;810        UART_StoreReg[4] = UART->LCR;
;;;811        UART_StoreReg[5] = UART->MCR;
;;;812        UART_StoreReg[6] = UART->SPR;
;;;813        UART_StoreReg[7] = UART->STSR;
;;;814        UART_StoreReg[8] = UART->RX_IDLE_INTTCR;
;;;815        UART_StoreReg[9] = UART->RXIDLE_INTCR;
;;;816        UART_StoreReg[10] = UART->MISCR;
;;;817    
;;;818        return;
;;;819    }
;;;820    
;;;821    /**
;;;822      * @brief  UART exit dlps callback function(Resume UART register values when system exit DLPS)
;;;823      * @param  None
;;;824      * @retval None
;;;825      */
;;;826    DATA_RAM_FUNCTION __STATIC_INLINE void UART_DLPS_Exit(void)
;;;827    {
;;;828        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;829        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;830    
;;;831        //access DLH and DLL
;;;832        UART->LCR |= (1 << 7);
;;;833        UART->DLL = UART_StoreReg[0];
;;;834        UART->DLH_INTCR =  UART_StoreReg[1];
;;;835        UART->LCR &= (~(1 << 7));
;;;836    
;;;837        //access other registers
;;;838        UART->INTID_FCR = (((UART_StoreReg[7] & BIT24) >> 21) | ((UART_StoreReg[7] & 0x7C000000) >> 18) |
;;;839                           (1));
;;;840        UART->LCR = UART_StoreReg[4];
;;;841        UART->MCR = UART_StoreReg[5];
;;;842        UART->SPR = UART_StoreReg[6];
;;;843        UART->STSR = UART_StoreReg[7];
;;;844        UART->DLH_INTCR = UART_StoreReg[2];
;;;845        UART->RX_IDLE_INTTCR = UART_StoreReg[8];
;;;846        UART->RXIDLE_INTCR = UART_StoreReg[9];
;;;847        UART->MISCR = UART_StoreReg[10];
;;;848    
;;;849        return;
;;;850    }
;;;851    #endif
;;;852    
;;;853    
;;;854    #if USE_UART1_DLPS
;;;855    
;;;856    __STATIC_INLINE void UART1_DLPS_Enter(void);
;;;857    __STATIC_INLINE void UART1_DLPS_Exit(void);
;;;858    
;;;859    uint32_t UART1_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;860    
;;;861    /**
;;;862      * @brief  UART1 enter dlps callback function(Save UART1 register values when system enter DLPS)
;;;863      * @param  None
;;;864      * @retval None
;;;865      */
;;;866    DATA_RAM_FUNCTION __STATIC_INLINE void UART1_DLPS_Enter(void)
;;;867    {
;;;868        //enable log uart peripheral & clock
;;;869        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;870        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;871    
;;;872        //access DLH and DLL
;;;873        UART1->LCR |= (1 << 7);
;;;874        UART1_StoreReg[0] = UART1->DLL;
;;;875        UART1_StoreReg[1] = UART1->DLH_INTCR;
;;;876        UART1->LCR &= (~(1 << 7));
;;;877    
;;;878        //save other registers
;;;879        UART1_StoreReg[2] = UART1->DLH_INTCR;
;;;880        UART1_StoreReg[4] = UART1->LCR;
;;;881        UART1_StoreReg[5] = UART1->MCR;
;;;882        UART1_StoreReg[6] = UART1->SPR;
;;;883        UART1_StoreReg[7] = UART1->STSR;
;;;884        UART1_StoreReg[8] = UART1->RX_IDLE_INTTCR;
;;;885        UART1_StoreReg[9] = UART1->RXIDLE_INTCR;
;;;886        UART1_StoreReg[10] = UART1->MISCR;
;;;887    
;;;888        return;
;;;889    }
;;;890    
;;;891    /**
;;;892      * @brief  UART1 exit dlps callback function(Resume UART1 register values when system exit DLPS)
;;;893      * @param  None
;;;894      * @retval None
;;;895      */
;;;896    DATA_RAM_FUNCTION __STATIC_INLINE void UART1_DLPS_Exit(void)
;;;897    {
;;;898        //enable log uart peripheral & clock
;;;899        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;900        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;901    
;;;902        //access DLH and DLL
;;;903        UART1->LCR |= (1 << 7);
;;;904        UART1->DLL = UART1_StoreReg[0];
;;;905        UART1->DLH_INTCR =  UART1_StoreReg[1];
;;;906        UART1->LCR &= (~(1 << 7));
;;;907    
;;;908        //access other registers
;;;909        UART1->INTID_FCR = (((UART1_StoreReg[7] & BIT24) >> 21) | ((UART1_StoreReg[7] & 0x7C000000)
;;;910                                                                   >> 18) | (1));
;;;911        UART1->LCR = UART1_StoreReg[4];
;;;912        UART1->MCR = UART1_StoreReg[5];
;;;913        UART1->SPR = UART1_StoreReg[6];
;;;914        UART1->STSR = UART1_StoreReg[7];
;;;915        UART1->DLH_INTCR = UART1_StoreReg[2];
;;;916        UART1->RX_IDLE_INTTCR = UART1_StoreReg[8];
;;;917        UART1->RXIDLE_INTCR = UART1_StoreReg[9];
;;;918        UART1->MISCR = UART1_StoreReg[10];
;;;919    
;;;920        return;
;;;921    }
;;;922    #endif
;;;923    
;;;924    #if USE_UART2_DLPS
;;;925    
;;;926    __STATIC_INLINE void UART2_DLPS_Enter(void);
;;;927    __STATIC_INLINE void UART2_DLPS_Exit(void);
;;;928    
;;;929    uint32_t UART2_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;930    
;;;931    /**
;;;932      * @brief  UART2 enter dlps callback function(Save UART2 register values when system enter DLPS)
;;;933      * @param  None
;;;934      * @retval None
;;;935      */
;;;936    DATA_RAM_FUNCTION __STATIC_INLINE void UART2_DLPS_Enter(void)
;;;937    {
;;;938        //enable log uart peripheral & clock
;;;939        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;940        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;941    
;;;942        //access DLH and DLL
;;;943        UART2->LCR |= (1 << 7);
;;;944        UART2_StoreReg[0] = UART2->DLL;
;;;945        UART2_StoreReg[1] = UART2->DLH_INTCR;
;;;946        UART2->LCR &= (~(1 << 7));
;;;947    
;;;948        //save other registers
;;;949        UART2_StoreReg[2] = UART2->DLH_INTCR;
;;;950        UART2_StoreReg[4] = UART2->LCR;
;;;951        UART2_StoreReg[5] = UART2->MCR;
;;;952        UART2_StoreReg[6] = UART2->SPR;
;;;953        UART2_StoreReg[7] = UART2->STSR;
;;;954        UART2_StoreReg[8] = UART2->RX_IDLE_INTTCR;
;;;955        UART2_StoreReg[9] = UART2->RXIDLE_INTCR;
;;;956        UART2_StoreReg[10] = UART2->MISCR;
;;;957    
;;;958        return;
;;;959    }
;;;960    
;;;961    /**
;;;962      * @brief  UART2 exit dlps callback function(Resume UART2 register values when system exit DLPS)
;;;963      * @param  None
;;;964      * @retval None
;;;965      */
;;;966    DATA_RAM_FUNCTION __STATIC_INLINE void UART2_DLPS_Exit(void)
;;;967    {
;;;968        //enable log uart peripheral & clock
;;;969        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;970        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;971    
;;;972        //access DLH and DLL
;;;973        UART2->LCR |= (1 << 7);
;;;974        UART2->DLL = UART2_StoreReg[0];
;;;975        UART2->DLH_INTCR =  UART2_StoreReg[1];
;;;976        UART2->LCR &= (~(1 << 7));
;;;977    
;;;978        //access other registers
;;;979        UART2->INTID_FCR = (((UART2_StoreReg[7] & BIT24) >> 21) | ((UART2_StoreReg[7] & 0x7C000000)
;;;980                                                                   >> 18) | (1));
;;;981        UART2->LCR = UART2_StoreReg[4];
;;;982        UART2->MCR = UART2_StoreReg[5];
;;;983        UART2->SPR = UART2_StoreReg[6];
;;;984        UART2->STSR = UART2_StoreReg[7];
;;;985        UART2->DLH_INTCR = UART2_StoreReg[2];
;;;986        UART2->RX_IDLE_INTTCR = UART2_StoreReg[8];
;;;987        UART2->RXIDLE_INTCR = UART2_StoreReg[9];
;;;988        UART2->MISCR = UART2_StoreReg[10];
;;;989    
;;;990        return;
;;;991    }
;;;992    #endif
;;;993    
;;;994    
;;;995    /********************************************** ********************************************************/
;;;996    /**************************************** [ADC DLPS] **************************************************/
;;;997    /*******************************************************************************************************/
;;;998    /*******************************************************************************************************/
;;;999    
;;;1000   #if USE_ADC_DLPS
;;;1001   __STATIC_INLINE void ADC_DLPS_Enter(void);
;;;1002   __STATIC_INLINE void ADC_DLPS_Exit(void);
;;;1003   
;;;1004   uint32_t ADC_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1005   
;;;1006   /**
;;;1007     * @brief  ADC enter dlps callback function(Save ADC register values when system enter DLPS)
;;;1008     * @param  None
;;;1009     * @retval None
;;;1010     */
;;;1011   DATA_RAM_FUNCTION __STATIC_INLINE void ADC_DLPS_Enter(void)
;;;1012   {
;;;1013       /*Open 10M clock source*/
;;;1014       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1015       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1016   
;;;1017       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1018       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1019   
;;;1020       ADC_StoreReg[0] =  ADC->CR;          //0x04
;;;1021       ADC_StoreReg[1] =  ADC->SCHCR;       //0x08
;;;1022       ADC_StoreReg[2] =  ADC->INTCR;       //0x0C
;;;1023       ADC_StoreReg[3] =  ADC->SCHTAB0;     //0x10
;;;1024       ADC_StoreReg[4] =  ADC->SCHTAB1;     //0x14
;;;1025       ADC_StoreReg[5] =  ADC->SCHTAB2;     //0x18
;;;1026       ADC_StoreReg[6] =  ADC->SCHTAB3;     //0x1C
;;;1027       ADC_StoreReg[7] =  ADC->SCHTAB4;     //0x20
;;;1028       ADC_StoreReg[8] =  ADC->SCHTAB5;     //0x24
;;;1029       ADC_StoreReg[9] =  ADC->SCHTAB6;     //0x28
;;;1030       ADC_StoreReg[10] =  ADC->SCHTAB6;    //0x2C
;;;1031       ADC_StoreReg[11] =  ADC->PWRDLY;
;;;1032       ADC_StoreReg[12] =  ADC->DATCLK;
;;;1033       ADC_StoreReg[13] =  ADC->ANACTL;
;;;1034   
;;;1035       uint8_t reg_value = 0;
;;;1036       reg_value = btaon_fast_read_safe(0x110);
;;;1037       btaon_fast_write(0x110, reg_value & (~0x04));
;;;1038   
;;;1039       return;
;;;1040   }
;;;1041   
;;;1042   /**
;;;1043     * @brief  ADC exit dlps callback function(Resume ADC register values when system exit DLPS)
;;;1044     * @param  None
;;;1045     * @retval None
;;;1046     */
;;;1047   DATA_RAM_FUNCTION __STATIC_INLINE void ADC_DLPS_Exit(void)
;;;1048   {
;;;1049       /*Open 10M clock source*/
;;;1050       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1051       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1052   
;;;1053       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1054       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1055   
;;;1056   #if 0
;;;1057       //Todo
;;;1058       ADC->PWRDLY = ADC_StoreReg[10];
;;;1059       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1060       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1061       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1062       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1063       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1064       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1065       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1066       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1067       ADC->SCHCR = ADC_StoreReg[1];
;;;1068       ADC->INTCR = (ADC_StoreReg[2] & 0x1F);
;;;1069   #else
;;;1070       /*Disable all interrupt.*/
;;;1071       ADC->INTCR &= (~0x1f);
;;;1072   
;;;1073       /* Set power mode first */
;;;1074       ADC->PWRDLY = ADC_StoreReg[11];
;;;1075   
;;;1076       /* Disable schedule table */
;;;1077       ADC->SCHCR &= (~0xffff);
;;;1078   
;;;1079       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1080       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1081       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1082       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1083       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1084       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1085       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1086       ADC->SCHTAB7 = ADC_StoreReg[10];
;;;1087       ADC->SCHCR   = ADC_StoreReg[1];
;;;1088       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1089       ADC->DATCLK = ADC_StoreReg[12];
;;;1090       ADC->ANACTL = ADC_StoreReg[13];
;;;1091   
;;;1092       /*Clear ADC FIFO */
;;;1093       ADC->CR |= BIT26;
;;;1094       /* Clear all interrupt */
;;;1095       ADC->INTCR |= (0x1f << 8);
;;;1096   
;;;1097       /* Restore specify interrupt */
;;;1098       ADC->INTCR = ADC_StoreReg[2];
;;;1099   
;;;1100   #endif
;;;1101   
;;;1102       uint8_t reg_value = 0;
;;;1103       reg_value = btaon_fast_read_safe(0x110);
;;;1104       btaon_fast_write(0x110, reg_value | 0x04);
;;;1105   
;;;1106       return;
;;;1107   }
;;;1108   
;;;1109   #endif
;;;1110   
;;;1111   /********************************************** ********************************************************/
;;;1112   /**************************************** [IR DLPS] **************************************************/
;;;1113   /*******************************************************************************************************/
;;;1114   /*******************************************************************************************************/
;;;1115   
;;;1116   #if USE_IR_DLPS
;;;1117   __STATIC_INLINE void IR_DLPS_Enter(void);
;;;1118   __STATIC_INLINE void IR_DLPS_Exit(void);
;;;1119   
;;;1120   uint32_t IR_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1121   
;;;1122   /**
;;;1123     * @brief  IR enter dlps callback function(Save IR register values when system enter DLPS)
;;;1124     * @param  None
;;;1125     * @retval None
;;;1126     */
;;;1127   DATA_RAM_FUNCTION __STATIC_INLINE void IR_DLPS_Enter(void)
;;;1128   {
;;;1129       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1130       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1131   
;;;1132       IR_StoreReg[0] = IR->CLK_DIV;
;;;1133       IR_StoreReg[1] = IR->TX_CONFIG;
;;;1134       IR_StoreReg[2] = IR->RX_CONFIG;
;;;1135       IR_StoreReg[3] = IR->RX_CNT_INT_SEL;
;;;1136   
;;;1137   
;;;1138       return;
;;;1139   }
;;;1140   
;;;1141   /**
;;;1142     * @brief  IR exit dlps callback function(Resume IR register values when system exit DLPS)
;;;1143     * @param  None
;;;1144     * @retval None
;;;1145     */
;;;1146   DATA_RAM_FUNCTION __STATIC_INLINE void IR_DLPS_Exit(void)
;;;1147   {
;;;1148       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1149       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1150   
;;;1151       IR->CLK_DIV = IR_StoreReg[0];
;;;1152       if (IR_StoreReg[1] & BIT31)
;;;1153       {
;;;1154           /* RX MODE */
;;;1155           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1156           IR->RX_CONFIG  = IR_StoreReg[2];
;;;1157           IR->RX_CNT_INT_SEL  = IR_StoreReg[3];
;;;1158       }
;;;1159       else
;;;1160       {
;;;1161           /* TX MODE */
;;;1162           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1163           /* If IR TX mode is idle, must write one data firstly */
;;;1164           IR->TX_FIFO = 0;
;;;1165       }
;;;1166   
;;;1167       return;
;;;1168   }
;;;1169   
;;;1170   #endif
;;;1171   
;;;1172   /********************************************** ********************************************************/
;;;1173   /**************************************** [LCD DLPS] ************************************************/
;;;1174   /*******************************************************************************************************/
;;;1175   /*******************************************************************************************************/
;;;1176   #if USE_LCD_DLPS
;;;1177   
;;;1178   uint32_t LCD_StoreReg[5];
;;;1179   
;;;1180   /**
;;;1181     * @brief  LCD enter dlps callback function(Save LCD register values when system enter DLPS)
;;;1182     * @param  None
;;;1183     * @retval None
;;;1184     */
;;;1185   DATA_RAM_FUNCTION __STATIC_INLINE void LCD_DLPS_Enter(void)
;;;1186   {
;;;1187       /* Enable LCD 8080 interface controller function */
;;;1188       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1189       /* Enable LCD 8080 interface controller clock */
;;;1190       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1191   
;;;1192       LCD_StoreReg[0] = *((volatile uint32_t *)0x400002A8UL) & (0x03 << 28);
;;;1193       LCD_StoreReg[1] = LCD->IMR;
;;;1194       LCD_StoreReg[2] = LCD->CTRL0;
;;;1195       LCD_StoreReg[3] = LCD->CTRL1;
;;;1196       LCD_StoreReg[4] = LCD->CFG;
;;;1197   
;;;1198   }
;;;1199   
;;;1200   /**
;;;1201     * @brief  LCD exit dlps callback function(Resume LCD register values when system exit DLPS)
;;;1202     * @param  None
;;;1203     * @retval None
;;;1204     */
;;;1205   DATA_RAM_FUNCTION __STATIC_INLINE void LCD_DLPS_Exit(void)
;;;1206   {
;;;1207       /* Enable LCD 8080 interface controller function */
;;;1208       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1209       /* Enable LCD 8080 interface controller clock */
;;;1210       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1211   
;;;1212       /* Restore Dedicated SDIO pin option */
;;;1213       *((volatile uint32_t *)0x400002A8UL) &= ~(0x03 << 28);
;;;1214       *((volatile uint32_t *)0x400002A8UL) |= LCD_StoreReg[0];
;;;1215   
;;;1216       /* Initialize LCD */
;;;1217   
;;;1218       LCD->IMR    = LCD_StoreReg[1];
;;;1219       LCD->CTRL1  = LCD_StoreReg[3];
;;;1220       LCD->CFG    = LCD_StoreReg[4];
;;;1221       LCD->CTRL0  = LCD_StoreReg[2];
;;;1222   }
;;;1223   #endif
;;;1224   
;;;1225   /********************************************** ********************************************************/
;;;1226   /**************************************** [I2S0 DLPS] **************************************************/
;;;1227   /*******************************************************************************************************/
;;;1228   /*******************************************************************************************************/
;;;1229   #if USE_I2S0_DLPS
;;;1230   
;;;1231   uint32_t I2S0_StoreReg[4];
;;;1232   
;;;1233   /**
;;;1234     * @brief  I2S0 enter dlps callback function(Save I2S0 register values when system enter DLPS)
;;;1235     * @param  None
;;;1236     * @retval None
;;;1237     */
;;;1238   DATA_RAM_FUNCTION __STATIC_INLINE void I2S0_DLPS_Enter(void)
;;;1239   {
;;;1240       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1241   
;;;1242       I2S0_StoreReg[0] = I2S0->BCLK_DIV;
;;;1243       I2S0_StoreReg[1] = I2S0->CTRL0;
;;;1244       I2S0_StoreReg[2] = I2S0->CTRL1;
;;;1245       I2S0_StoreReg[3] = I2S0->DMA_TRDLR;
;;;1246   }
;;;1247   
;;;1248   /**
;;;1249     * @brief  I2S0 exit dlps callback function(Resume I2S0 register values when system exit DLPS)
;;;1250     * @param  None
;;;1251     * @retval None
;;;1252     */
;;;1253   DATA_RAM_FUNCTION __STATIC_INLINE void I2S0_DLPS_Exit(void)
;;;1254   {
;;;1255       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1256   
;;;1257       /* Reset I2S0 module */
;;;1258       I2S0->CTRL0 |= 1 << 0;
;;;1259       I2S0->CTRL0 &= ~(1 << 0);
;;;1260   
;;;1261       /* Initialize I2S0 */
;;;1262       I2S0->BCLK_DIV  = I2S0_StoreReg[0];
;;;1263       I2S0->CTRL1     = I2S0_StoreReg[2];
;;;1264       I2S0->DMA_TRDLR = I2S0_StoreReg[3];
;;;1265       I2S0->CTRL0     = I2S0_StoreReg[1];
;;;1266   }
;;;1267   #endif
;;;1268   
;;;1269   /********************************************** ********************************************************/
;;;1270   /**************************************** [I2S1 DLPS] **************************************************/
;;;1271   /*******************************************************************************************************/
;;;1272   /*******************************************************************************************************/
;;;1273   #if USE_I2S1_DLPS
;;;1274   
;;;1275   uint32_t I2S1_StoreReg[4];
;;;1276   
;;;1277   /**
;;;1278     * @brief  I2S1 enter dlps callback function(Save I2S1 register values when system enter DLPS)
;;;1279     * @param  None
;;;1280     * @retval None
;;;1281     */
;;;1282   DATA_RAM_FUNCTION __STATIC_INLINE void I2S1_DLPS_Enter(void)
;;;1283   {
;;;1284       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1285   
;;;1286       I2S1_StoreReg[0] = I2S1->BCLK_DIV;
;;;1287       I2S1_StoreReg[1] = I2S1->CTRL0;
;;;1288       I2S1_StoreReg[2] = I2S1->CTRL1;
;;;1289       I2S1_StoreReg[3] = I2S1->DMA_TRDLR;
;;;1290   }
;;;1291   
;;;1292   /**
;;;1293     * @brief  I2S1 exit dlps callback function(Resume I2S1 register values when system exit DLPS)
;;;1294     * @param  None
;;;1295     * @retval None
;;;1296     */
;;;1297   DATA_RAM_FUNCTION __STATIC_INLINE void I2S1_DLPS_Exit(void)
;;;1298   {
;;;1299       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1300   
;;;1301       /* Reset I2S1 module */
;;;1302       I2S1->CTRL0 |= 1 << 0;
;;;1303       I2S1->CTRL0 &= ~(1 << 0);
;;;1304   
;;;1305       /* Initialize I2S1 */
;;;1306       I2S1->BCLK_DIV  = I2S1_StoreReg[0];
;;;1307       I2S1->CTRL1     = I2S1_StoreReg[2];
;;;1308       I2S1->DMA_TRDLR = I2S1_StoreReg[3];
;;;1309       I2S1->CTRL0     = I2S1_StoreReg[1];
;;;1310   }
;;;1311   #endif
;;;1312   
;;;1313   /********************************************** ********************************************************/
;;;1314   /**************************************** [CODEC DLPS] ************************************************/
;;;1315   /*******************************************************************************************************/
;;;1316   /*******************************************************************************************************/
;;;1317   #if USE_CODEC_DLPS
;;;1318   
;;;1319   uint32_t CODEC_StoreReg[7];
;;;1320   
;;;1321   /**
;;;1322     * @brief  CODEC enter dlps callback function(Save CODEC register values when system enter DLPS)
;;;1323     * @param  None
;;;1324     * @retval None
;;;1325     */
;;;1326   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_DLPS_Enter(void)
;;;1327   {
;;;1328       /* Enable codec function and clock */
;;;1329       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1330   
;;;1331       CODEC_StoreReg[0] = CODEC->CR0;
;;;1332       CODEC_StoreReg[1] = CODEC->CR1;
;;;1333       CODEC_StoreReg[2] = CODEC->CR2;
;;;1334       CODEC_StoreReg[3] = CODEC->CLK_CTRL;
;;;1335       CODEC_StoreReg[4] = CODEC->I2S_CTRL;
;;;1336       CODEC_StoreReg[5] = CODEC->ADC_CTRL;
;;;1337       CODEC_StoreReg[6] = CODEC->DAC_CTRL;
;;;1338   }
;;;1339   
;;;1340   /**
;;;1341     * @brief  CODEC exit dlps callback function(Resume CODEC register values when system exit DLPS)
;;;1342     * @param  None
;;;1343     * @retval None
;;;1344     */
;;;1345   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_DLPS_Exit(void)
;;;1346   {
;;;1347       /* Enable codec function and clock */
;;;1348       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1349   
;;;1350       /* Initialize CODEC */
;;;1351       if ((CODEC_StoreReg[3] & 0x900) == 0x900)
;;;1352       {
;;;1353           /* Configure AMIC parameters */
;;;1354           CODEC->CR0 = CODEC_StoreReg[0];
;;;1355           CODEC->CR1 = CODEC_StoreReg[1];
;;;1356           CODEC->CR2 = CODEC_StoreReg[2];
;;;1357       }
;;;1358   
;;;1359       /*  Reset audio digital IP */
;;;1360       CODEC->AUDIO_CTRL = 0;
;;;1361       CODEC->AUDIO_CTRL = 1;
;;;1362   
;;;1363       CODEC->CLK_CTRL = CODEC_StoreReg[3];
;;;1364       CODEC->I2S_CTRL = CODEC_StoreReg[4];
;;;1365       CODEC->ADC_CTRL = CODEC_StoreReg[5];
;;;1366       CODEC->DAC_CTRL = CODEC_StoreReg[6];
;;;1367   }
;;;1368   #endif
;;;1369   
;;;1370   /********************************************** ********************************************************/
;;;1371   /**************************************** [CODEC_EQ1 DLPS] ************************************************/
;;;1372   /*******************************************************************************************************/
;;;1373   /*******************************************************************************************************/
;;;1374   #if USE_CODEC_EQ1_DLPS
;;;1375   
;;;1376   uint32_t CODEC_EQ1_StoreReg[5];
;;;1377   
;;;1378   /**
;;;1379     * @brief  CODEC_EQ1 enter dlps callback function(Save CODEC_EQ1 register values when system enter DLPS)
;;;1380     * @param  None
;;;1381     * @retval None
;;;1382     */
;;;1383   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ1_DLPS_Enter(void)
;;;1384   {
;;;1385       /* Enable codec function and clock */
;;;1386       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1387   
;;;1388       CODEC_EQ1_StoreReg[0] = CODEC_EQ1->EQ_H0;
;;;1389       CODEC_EQ1_StoreReg[1] = CODEC_EQ1->EQ_B1;
;;;1390       CODEC_EQ1_StoreReg[2] = CODEC_EQ1->EQ_B2;
;;;1391       CODEC_EQ1_StoreReg[3] = CODEC_EQ1->EQ_A1;
;;;1392       CODEC_EQ1_StoreReg[4] = CODEC_EQ1->EQ_A2;
;;;1393   }
;;;1394   
;;;1395   /**
;;;1396     * @brief  CODEC_EQ1 exit dlps callback function(Resume CODEC_EQ1 register values when system exit DLPS)
;;;1397     * @param  None
;;;1398     * @retval None
;;;1399     */
;;;1400   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ1_DLPS_Exit(void)
;;;1401   {
;;;1402       /* Enable codec function and clock */
;;;1403       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1404   
;;;1405       CODEC_EQ1->EQ_H0 = CODEC_EQ1_StoreReg[0];
;;;1406       CODEC_EQ1->EQ_B1 = CODEC_EQ1_StoreReg[1];
;;;1407       CODEC_EQ1->EQ_B2 = CODEC_EQ1_StoreReg[2];
;;;1408       CODEC_EQ1->EQ_A1 = CODEC_EQ1_StoreReg[3];
;;;1409       CODEC_EQ1->EQ_A2 = CODEC_EQ1_StoreReg[4];
;;;1410   }
;;;1411   #endif
;;;1412   
;;;1413   /********************************************** ********************************************************/
;;;1414   /**************************************** [CODEC_EQ2 DLPS] ************************************************/
;;;1415   /*******************************************************************************************************/
;;;1416   /*******************************************************************************************************/
;;;1417   #if USE_CODEC_EQ2_DLPS
;;;1418   
;;;1419   uint32_t CODEC_EQ2_StoreReg[5];
;;;1420   
;;;1421   /**
;;;1422     * @brief  CODEC_EQ2 enter dlps callback function(Save CODEC_EQ2 register values when system enter DLPS)
;;;1423     * @param  None
;;;1424     * @retval None
;;;1425     */
;;;1426   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ2_DLPS_Enter(void)
;;;1427   {
;;;1428       /* Enable codec function and clock */
;;;1429       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1430   
;;;1431       CODEC_EQ2_StoreReg[0] = CODEC_EQ2->EQ_H0;
;;;1432       CODEC_EQ2_StoreReg[1] = CODEC_EQ2->EQ_B1;
;;;1433       CODEC_EQ2_StoreReg[2] = CODEC_EQ2->EQ_B2;
;;;1434       CODEC_EQ2_StoreReg[3] = CODEC_EQ2->EQ_A1;
;;;1435       CODEC_EQ2_StoreReg[4] = CODEC_EQ2->EQ_A2;
;;;1436   }
;;;1437   
;;;1438   /**
;;;1439     * @brief  CODEC_EQ2 exit dlps callback function(Resume CODEC_EQ2 register values when system exit DLPS)
;;;1440     * @param  None
;;;1441     * @retval None
;;;1442     */
;;;1443   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ2_DLPS_Exit(void)
;;;1444   {
;;;1445       /* Enable codec function and clock */
;;;1446       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1447   
;;;1448       CODEC_EQ2->EQ_H0 = CODEC_EQ2_StoreReg[0];
;;;1449       CODEC_EQ2->EQ_B1 = CODEC_EQ2_StoreReg[1];
;;;1450       CODEC_EQ2->EQ_B2 = CODEC_EQ2_StoreReg[2];
;;;1451       CODEC_EQ2->EQ_A1 = CODEC_EQ2_StoreReg[3];
;;;1452       CODEC_EQ2->EQ_A2 = CODEC_EQ2_StoreReg[4];
;;;1453   }
;;;1454   #endif
;;;1455   
;;;1456   /********************************************** ********************************************************/
;;;1457   /**************************************** [CODEC_EQ3 DLPS] ************************************************/
;;;1458   /*******************************************************************************************************/
;;;1459   /*******************************************************************************************************/
;;;1460   #if USE_CODEC_EQ3_DLPS
;;;1461   
;;;1462   uint32_t CODEC_EQ3_StoreReg[5];
;;;1463   
;;;1464   /**
;;;1465     * @brief  CODEC_EQ3 enter dlps callback function(Save CODEC_EQ3 register values when system enter DLPS)
;;;1466     * @param  None
;;;1467     * @retval None
;;;1468     */
;;;1469   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ3_DLPS_Enter(void)
;;;1470   {
;;;1471       /* Enable codec function and clock */
;;;1472       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1473   
;;;1474       CODEC_EQ3_StoreReg[0] = CODEC_EQ3->EQ_H0;
;;;1475       CODEC_EQ3_StoreReg[1] = CODEC_EQ3->EQ_B1;
;;;1476       CODEC_EQ3_StoreReg[2] = CODEC_EQ3->EQ_B2;
;;;1477       CODEC_EQ3_StoreReg[3] = CODEC_EQ3->EQ_A1;
;;;1478       CODEC_EQ3_StoreReg[4] = CODEC_EQ3->EQ_A2;
;;;1479   }
;;;1480   
;;;1481   /**
;;;1482     * @brief  CODEC_EQ3 exit dlps callback function(Resume CODEC_EQ3 register values when system exit DLPS)
;;;1483     * @param  None
;;;1484     * @retval None
;;;1485     */
;;;1486   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ3_DLPS_Exit(void)
;;;1487   {
;;;1488       /* Enable codec function and clock */
;;;1489       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1490   
;;;1491       CODEC_EQ3->EQ_H0 = CODEC_EQ3_StoreReg[0];
;;;1492       CODEC_EQ3->EQ_B1 = CODEC_EQ3_StoreReg[1];
;;;1493       CODEC_EQ3->EQ_B2 = CODEC_EQ3_StoreReg[2];
;;;1494       CODEC_EQ3->EQ_A1 = CODEC_EQ3_StoreReg[3];
;;;1495       CODEC_EQ3->EQ_A2 = CODEC_EQ3_StoreReg[4];
;;;1496   }
;;;1497   #endif
;;;1498   
;;;1499   /********************************************** ********************************************************/
;;;1500   /**************************************** [CODEC_EQ4 DLPS] ************************************************/
;;;1501   /*******************************************************************************************************/
;;;1502   /*******************************************************************************************************/
;;;1503   #if USE_CODEC_EQ4_DLPS
;;;1504   
;;;1505   uint32_t CODEC_EQ4_StoreReg[5];
;;;1506   
;;;1507   /**
;;;1508     * @brief  CODEC_EQ4 enter dlps callback function(Save CODEC_EQ4 register values when system enter DLPS)
;;;1509     * @param  None
;;;1510     * @retval None
;;;1511     */
;;;1512   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ4_DLPS_Enter(void)
;;;1513   {
;;;1514       /* Enable codec function and clock */
;;;1515       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1516   
;;;1517       CODEC_EQ4_StoreReg[0] = CODEC_EQ4->EQ_H0;
;;;1518       CODEC_EQ4_StoreReg[1] = CODEC_EQ4->EQ_B1;
;;;1519       CODEC_EQ4_StoreReg[2] = CODEC_EQ4->EQ_B2;
;;;1520       CODEC_EQ4_StoreReg[3] = CODEC_EQ4->EQ_A1;
;;;1521       CODEC_EQ4_StoreReg[4] = CODEC_EQ4->EQ_A2;
;;;1522   }
;;;1523   
;;;1524   /**
;;;1525     * @brief  CODEC_EQ4 exit dlps callback function(Resume CODEC_EQ4 register values when system exit DLPS)
;;;1526     * @param  None
;;;1527     * @retval None
;;;1528     */
;;;1529   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ4_DLPS_Exit(void)
;;;1530   {
;;;1531       /* Enable codec function and clock */
;;;1532       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1533   
;;;1534       CODEC_EQ4->EQ_H0 = CODEC_EQ4_StoreReg[0];
;;;1535       CODEC_EQ4->EQ_B1 = CODEC_EQ4_StoreReg[1];
;;;1536       CODEC_EQ4->EQ_B2 = CODEC_EQ4_StoreReg[2];
;;;1537       CODEC_EQ4->EQ_A1 = CODEC_EQ4_StoreReg[3];
;;;1538       CODEC_EQ4->EQ_A2 = CODEC_EQ4_StoreReg[4];
;;;1539   }
;;;1540   #endif
;;;1541   
;;;1542   /********************************************** ********************************************************/
;;;1543   /**************************************** [CODEC_EQ5 DLPS] ************************************************/
;;;1544   /*******************************************************************************************************/
;;;1545   /*******************************************************************************************************/
;;;1546   #if USE_CODEC_EQ5_DLPS
;;;1547   
;;;1548   uint32_t CODEC_EQ5_StoreReg[5];
;;;1549   
;;;1550   /**
;;;1551     * @brief  CODEC_EQ5 enter dlps callback function(Save CODEC_EQ5 register values when system enter DLPS)
;;;1552     * @param  None
;;;1553     * @retval None
;;;1554     */
;;;1555   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ5_DLPS_Enter(void)
;;;1556   {
;;;1557       /* Enable codec function and clock */
;;;1558       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1559   
;;;1560       CODEC_EQ5_StoreReg[0] = CODEC_EQ5->EQ_H0;
;;;1561       CODEC_EQ5_StoreReg[1] = CODEC_EQ5->EQ_B1;
;;;1562       CODEC_EQ5_StoreReg[2] = CODEC_EQ5->EQ_B2;
;;;1563       CODEC_EQ5_StoreReg[3] = CODEC_EQ5->EQ_A1;
;;;1564       CODEC_EQ5_StoreReg[4] = CODEC_EQ5->EQ_A2;
;;;1565   }
;;;1566   
;;;1567   /**
;;;1568     * @brief  CODEC_EQ5 exit dlps callback function(Resume CODEC_EQ5 register values when system exit DLPS)
;;;1569     * @param  None
;;;1570     * @retval None
;;;1571     */
;;;1572   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ5_DLPS_Exit(void)
;;;1573   {
;;;1574       /* Enable codec function and clock */
;;;1575       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1576   
;;;1577       CODEC_EQ5->EQ_H0 = CODEC_EQ5_StoreReg[0];
;;;1578       CODEC_EQ5->EQ_B1 = CODEC_EQ5_StoreReg[1];
;;;1579       CODEC_EQ5->EQ_B2 = CODEC_EQ5_StoreReg[2];
;;;1580       CODEC_EQ5->EQ_A1 = CODEC_EQ5_StoreReg[3];
;;;1581       CODEC_EQ5->EQ_A2 = CODEC_EQ5_StoreReg[4];
;;;1582   }
;;;1583   #endif
;;;1584   
;;;1585   /**
;;;1586     * @brief  Set Log and SWD pins to SW mode.
;;;1587     * @param  void.
;;;1588     * @retval void.
;;;1589     */
;;;1590   DATA_RAM_FUNCTION __STATIC_INLINE void Log_SWD_DLPS_Enter(void)
;;;1591   {
;;;1592       if (OTP->SWD_ENABLE)
;;;1593       {
;;;1594           Pad_Config(P1_0, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1595           Pad_Config(P1_1, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1596       }
;;;1597   
;;;1598       Pad_Config(OTP->logPin, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1599   
;;;1600   }
;;;1601   
;;;1602   /**
;;;1603     * @brief  Set Log and SWD pins to PINMUX mode.
;;;1604     * @param  void.
;;;1605     * @retval void.
;;;1606     */
;;;1607   DATA_RAM_FUNCTION __STATIC_INLINE void Log_SWD_DLPS_Exit(void)
;;;1608   {
;;;1609       Pad_Config(OTP->logPin, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00207e38:    2400        .$      MOVS     r4,#0
        0x00207e3a:    f44f1500    O...    MOV      r5,#0x200000
        0x00207e3e:    9400        ..      STR      r4,[sp,#0]
        0x00207e40:    9401        ..      STR      r4,[sp,#4]
        0x00207e42:    f8950398    ....    LDRB     r0,[r5,#0x398]
        0x00207e46:    2201        ."      MOVS     r2,#1
        0x00207e48:    f000003f    ..?.    AND      r0,r0,#0x3f
        0x00207e4c:    4623        #F      MOV      r3,r4
        0x00207e4e:    4611        .F      MOV      r1,r2
        0x00207e50:    f5057566    ..fu    ADD      r5,r5,#0x398
        0x00207e54:    f609fac2    ....    BL       Pad_Config ; 0x113dc
;;;1610   
;;;1611       if (OTP->SWD_ENABLE)
        0x00207e58:    f8150c64    ..d.    LDRB     r0,[r5,#-0x64]
        0x00207e5c:    07c0        ..      LSLS     r0,r0,#31
        0x00207e5e:    d00f        ..      BEQ      0x207e80 ; DLPS_IO_ExitDlpsCb + 104
;;;1612       {
;;;1613           Pad_Config(P1_0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00207e60:    2301        .#      MOVS     r3,#1
        0x00207e62:    9400        ..      STR      r4,[sp,#0]
        0x00207e64:    461a        .F      MOV      r2,r3
        0x00207e66:    4619        .F      MOV      r1,r3
        0x00207e68:    2008        .       MOVS     r0,#8
        0x00207e6a:    9401        ..      STR      r4,[sp,#4]
        0x00207e6c:    f609fab6    ....    BL       Pad_Config ; 0x113dc
;;;1614           Pad_Config(P1_1, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00207e70:    2301        .#      MOVS     r3,#1
        0x00207e72:    9400        ..      STR      r4,[sp,#0]
        0x00207e74:    461a        .F      MOV      r2,r3
        0x00207e76:    4619        .F      MOV      r1,r3
        0x00207e78:    2009        .       MOVS     r0,#9
        0x00207e7a:    9401        ..      STR      r4,[sp,#4]
        0x00207e7c:    f609faae    ....    BL       Pad_Config ; 0x113dc
;;;1615       }
;;;1616   }
;;;1617   
;;;1618   /********************************************** ********************************************************/
;;;1619   /*********************************** [USER Exit DLPS CALLBACK FUCN] *****************************************/
;;;1620   /*******************************************************************************************************/
;;;1621   /*******************************************************************************************************/
;;;1622   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;1623   
;;;1624   DLPS_IO_ExitDlpsCB User_IO_ExitDlpsCB = NULL;
;;;1625   
;;;1626   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1627   
;;;1628   /********************************************** ********************************************************/
;;;1629   /*********************************** [USER Enter DLPS CALLBACK FUCN] *****************************************/
;;;1630   /*******************************************************************************************************/
;;;1631   /*******************************************************************************************************/
;;;1632   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1633   
;;;1634   DLPS_IO_EnterDlpsCB User_IO_EnterDlpsCB = NULL;
;;;1635   
;;;1636   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1637   
;;;1638   /********************************************** ********************************************************/
;;;1639   /*********************************** [Enter & Exit DLPS CALLBACK FUNC] *********************************/
;;;1640   /*******************************************************************************************************/
;;;1641   /*******************************************************************************************************/
;;;1642   #if USE_IO_DRIVER_DLPS
;;;1643   
;;;1644   /**
;;;1645     * @brief  IO enter dlps callback function
;;;1646     * @param  None
;;;1647     * @retval None
;;;1648     */
;;;1649   DATA_RAM_FUNCTION void DLPS_IO_EnterDlpsCb(void)
;;;1650   {
;;;1651       /* low stack do it instead */
;;;1652   //    Pad_ClearAllWakeupINT();
;;;1653   
;;;1654   //    DBG_DIRECT("DLPS_IO_EnterDlpsCb");
;;;1655       NVIC_DisableIRQ(System_IRQn);
;;;1656       CPU_DLPS_Enter();
;;;1657   
;;;1658       Pinmux_DLPS_Enter();
;;;1659   
;;;1660   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1661       if (User_IO_EnterDlpsCB)
;;;1662       {
;;;1663           User_IO_EnterDlpsCB();
;;;1664       }
;;;1665   #endif
;;;1666   
;;;1667   #if USE_I2C0_DLPS
;;;1668       I2C0_DLPS_Enter();
;;;1669   #endif
;;;1670   
;;;1671   #if USE_I2C1_DLPS
;;;1672       I2C1_DLPS_Enter();
;;;1673   #endif
;;;1674   
;;;1675   #if USE_TIM_DLPS
;;;1676       TIM_DLPS_Enter();
;;;1677   #endif
;;;1678   
;;;1679   #if USE_QDECODER_DLPS
;;;1680       QuadDecoder_DLPS_Enter();
;;;1681   #endif
;;;1682   
;;;1683   #if USE_IR_DLPS
;;;1684       IR_DLPS_Enter();
;;;1685   #endif
;;;1686   
;;;1687   #if USE_UART_DLPS
;;;1688       UART_DLPS_Enter();
;;;1689   #endif
;;;1690   
;;;1691   #if USE_UART1_DLPS
;;;1692       UART1_DLPS_Enter();
;;;1693   #endif
;;;1694   
;;;1695   #if USE_UART2_DLPS
;;;1696       UART2_DLPS_Enter();
;;;1697   #endif
;;;1698   
;;;1699   #if USE_SPI0_DLPS
;;;1700       SPI0_DLPS_Enter();
;;;1701   #endif
;;;1702   
;;;1703   #if USE_SPI1_DLPS
;;;1704       SPI1_DLPS_Enter();
;;;1705   #endif
;;;1706   
;;;1707   #if USE_SPI2W_DLPS
;;;1708       SPI2W_DLPS_Enter();
;;;1709   #endif
;;;1710   
;;;1711   #if USE_KEYSCAN_DLPS
;;;1712       KeyScan_DLPS_Enter();
;;;1713   #endif
;;;1714   
;;;1715   #if USE_GPIO_DLPS
;;;1716       GPIO_DLPS_Enter();
;;;1717   #endif
;;;1718   
;;;1719   #if USE_ADC_DLPS
;;;1720       ADC_DLPS_Enter();
;;;1721   #endif
;;;1722   
;;;1723   #if USE_LCD_DLPS
;;;1724       LCD_DLPS_Enter();
;;;1725   #endif
;;;1726   
;;;1727   #if USE_I2S0_DLPS
;;;1728       I2S0_DLPS_Enter();
;;;1729   #endif
;;;1730   
;;;1731   #if USE_I2S1_DLPS
;;;1732       I2S1_DLPS_Enter();
;;;1733   #endif
;;;1734   
;;;1735   #if USE_CODEC_DLPS
;;;1736       CODEC_DLPS_Enter();
;;;1737   #endif
;;;1738   
;;;1739   #if USE_CODEC_EQ1_DLPS
;;;1740       CODEC_EQ1_DLPS_Enter();
;;;1741   #endif
;;;1742   
;;;1743   #if USE_CODEC_EQ2_DLPS
;;;1744       CODEC_EQ2_DLPS_Enter();
;;;1745   #endif
;;;1746   
;;;1747   #if USE_CODEC_EQ3_DLPS
;;;1748       CODEC_EQ3_DLPS_Enter();
;;;1749   #endif
;;;1750   
;;;1751   #if USE_CODEC_EQ4_DLPS
;;;1752       CODEC_EQ4_DLPS_Enter();
;;;1753   #endif
;;;1754   
;;;1755   #if USE_CODEC_EQ5_DLPS
;;;1756       CODEC_EQ5_DLPS_Enter();
;;;1757   #endif
;;;1758   
;;;1759       Log_SWD_DLPS_Enter();
;;;1760   
;;;1761   }
;;;1762   #endif  /* USE_IO_DRIVER_DLPS */
;;;1763   
;;;1764   #if USE_IO_DRIVER_DLPS
;;;1765   /**
;;;1766     * @brief  IO exit dlps callback function.
;;;1767     * @param  None
;;;1768     * @retval None
;;;1769     */
;;;1770   DATA_RAM_FUNCTION void DLPS_IO_ExitDlpsCb(void)
;;;1771   {
;;;1772   
;;;1773   //    DBG_BUFFER(TYPE_BUMBLEBEE3, SUBTYPE_FORMAT, MODULE_DLPS, LEVEL_INFO,
;;;1774   //               "DLPS_IO_ExitDlpsCb",0);
;;;1775   
;;;1776       Pinmux_DLPS_Exit();
;;;1777   
;;;1778       Log_SWD_DLPS_Exit();
;;;1779   
;;;1780   #if USE_I2C0_DLPS
;;;1781       I2C0_DLPS_Exit();
;;;1782   #endif
;;;1783   
;;;1784   #if USE_I2C1_DLPS
;;;1785       I2C1_DLPS_Exit();
;;;1786   #endif
;;;1787   
;;;1788   #if USE_TIM_DLPS
;;;1789       TIM_DLPS_Exit();
;;;1790   #endif
;;;1791   
;;;1792   #if USE_QDECODER_DLPS
;;;1793       QuadDecoder_DLPS_Exit();
;;;1794   #endif
;;;1795   
;;;1796   #if USE_IR_DLPS
;;;1797       IR_DLPS_Exit();
;;;1798   #endif
;;;1799   
;;;1800   #if USE_UART_DLPS
;;;1801       UART_DLPS_Exit();
;;;1802   #endif
;;;1803   
;;;1804   #if USE_UART1_DLPS
;;;1805       UART1_DLPS_Exit();
;;;1806   #endif
;;;1807   
;;;1808   #if USE_UART2_DLPS
;;;1809       UART2_DLPS_Exit();
;;;1810   #endif
;;;1811   
;;;1812   #if USE_SPI0_DLPS
;;;1813       SPI0_DLPS_Exit();
;;;1814   #endif
;;;1815   
;;;1816   #if USE_SPI1_DLPS
;;;1817       SPI1_DLPS_Exit();
;;;1818   #endif
;;;1819   
;;;1820   #if USE_SPI2W_DLPS
;;;1821       SPI2W_DLPS_Exit();
;;;1822   #endif
;;;1823   
;;;1824   #if USE_KEYSCAN_DLPS
;;;1825       KeyScan_DLPS_Exit();
;;;1826   #endif
;;;1827   
;;;1828   #if USE_GPIO_DLPS
;;;1829       GPIO_DLPS_Exit();
        0x00207e80:    f000f830    ..0.    BL       GPIO_DLPS_Exit ; 0x207ee4
;;;1830   #endif
;;;1831   
;;;1832   #if USE_ADC_DLPS
;;;1833       ADC_DLPS_Exit();
;;;1834   #endif
;;;1835   
;;;1836   #if USE_LCD_DLPS
;;;1837       LCD_DLPS_Exit();
;;;1838   #endif
;;;1839   
;;;1840   #if USE_I2S0_DLPS
;;;1841       I2S0_DLPS_Exit();
;;;1842   #endif
;;;1843   
;;;1844   #if USE_I2S1_DLPS
;;;1845       I2S1_DLPS_Exit();
;;;1846   #endif
;;;1847   
;;;1848   #if USE_CODEC_DLPS
;;;1849       CODEC_DLPS_Exit();
;;;1850   #endif
;;;1851   
;;;1852   #if USE_CODEC_EQ1_DLPS
;;;1853       CODEC_EQ1_DLPS_Exit();
;;;1854   #endif
;;;1855   
;;;1856   #if USE_CODEC_EQ2_DLPS
;;;1857       CODEC_EQ2_DLPS_Exit();
;;;1858   #endif
;;;1859   
;;;1860   #if USE_CODEC_EQ3_DLPS
;;;1861       CODEC_EQ3_DLPS_Exit();
;;;1862   #endif
;;;1863   
;;;1864   #if USE_CODEC_EQ4_DLPS
;;;1865       CODEC_EQ4_DLPS_Exit();
;;;1866   #endif
;;;1867   
;;;1868   #if USE_CODEC_EQ5_DLPS
;;;1869       CODEC_EQ5_DLPS_Exit();
;;;1870   #endif
;;;1871   
;;;1872   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;1873       if (User_IO_ExitDlpsCB)
        0x00207e84:    4d2b        +M      LDR      r5,[pc,#172] ; [0x207f34] = 0x20805c
        0x00207e86:    3d0c        .=      SUBS     r5,r5,#0xc
        0x00207e88:    6868        hh      LDR      r0,[r5,#4]
        0x00207e8a:    b100        ..      CBZ      r0,0x207e8e ; DLPS_IO_ExitDlpsCb + 118
;;;1874       {
;;;1875           User_IO_ExitDlpsCB();
        0x00207e8c:    4780        .G      BLX      r0
;;;1876       }
;;;1877   #endif
;;;1878   
;;;1879       NVIC_InitTypeDef nvic_init_struct;
;;;1880       nvic_init_struct.NVIC_IRQChannel         = System_IRQn;
;;;1881       nvic_init_struct.NVIC_IRQChannelCmd      = (FunctionalState)ENABLE;
        0x00207e8e:    2001        .       MOVS     r0,#1
        0x00207e90:    f88d0010    ....    STRB     r0,[sp,#0x10]
;;;1882       nvic_init_struct.NVIC_IRQChannelPriority = 3;
        0x00207e94:    2003        .       MOVS     r0,#3
;;;1883       NVIC_Init(&nvic_init_struct); //Enable SYSTEM_ON Interrupt
        0x00207e96:    9003        ..      STR      r0,[sp,#0xc]
        0x00207e98:    f88d4008    ...@    STRB     r4,[sp,#8]
        0x00207e9c:    a802        ..      ADD      r0,sp,#8
        0x00207e9e:    f609fa0f    ....    BL       NVIC_Init ; 0x112c0
        0x00207ea2:    4c24        $L      LDR      r4,[pc,#144] ; [0x207f34] = 0x20805c
        0x00207ea4:    6863        ch      LDR      r3,[r4,#4]
        0x00207ea6:    0858        X.      LSRS     r0,r3,#1
        0x00207ea8:    d004        ..      BEQ      0x207eb4 ; DLPS_IO_ExitDlpsCb + 156
        0x00207eaa:    2201        ."      MOVS     r2,#1
        0x00207eac:    4925        %I      LDR      r1,[pc,#148] ; [0x207f44] = 0x8800230
        0x00207eae:    4826        &H      LDR      r0,[pc,#152] ; [0x207f48] = 0x21100401
        0x00207eb0:    f5fffdd5    ....    BL       log_buffer ; 0x7a5e
        0x00207eb4:    2003        .       MOVS     r0,#3
        0x00207eb6:    f10022e0    ..."    ADD      r2,r0,#0xe000e000
        0x00207eba:    f8141020    .. .    LDRB     r1,[r4,r0,LSL #2]
        0x00207ebe:    f8821400    ....    STRB     r1,[r2,#0x400]
        0x00207ec2:    1c40        @.      ADDS     r0,r0,#1
        0x00207ec4:    2820         (      CMP      r0,#0x20
        0x00207ec6:    d3f6        ..      BCC      0x207eb6 ; DLPS_IO_ExitDlpsCb + 158
        0x00207ec8:    491b        .I      LDR      r1,[pc,#108] ; [0x207f38] = 0xe000ed08
        0x00207eca:    f8d40080    ....    LDR      r0,[r4,#0x80]
        0x00207ece:    6008        .`      STR      r0,[r1,#0]
        0x00207ed0:    491a        .I      LDR      r1,[pc,#104] ; [0x207f3c] = 0x40006000
        0x00207ed2:    6828        (h      LDR      r0,[r5,#0]
        0x00207ed4:    60c8        .`      STR      r0,[r1,#0xc]
        0x00207ed6:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x00207eda:    6820         h      LDR      r0,[r4,#0]
        0x00207edc:    f8c10100    ....    STR      r0,[r1,#0x100]
;;;1884   
;;;1885       CPU_DLPS_Exit();
;;;1886   }
        0x00207ee0:    b005        ..      ADD      sp,sp,#0x14
        0x00207ee2:    bd30        0.      POP      {r4,r5,pc}
    GPIO_DLPS_Exit
        0x00207ee4:    b510        ..      PUSH     {r4,lr}
;;; .\..\source\peripheral\rtl876x_io_dlps.c (185)
        0x00207ee6:    f04f4280    O..B    MOV      r2,#0x40000000
        0x00207eea:    f8d2021c    ....    LDR      r0,[r2,#0x21c]
        0x00207eee:    f4407080    @..p    ORR      r0,r0,#0x100
        0x00207ef2:    f8c2021c    ....    STR      r0,[r2,#0x21c]
;;;186        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
        0x00207ef6:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x00207efa:    f0407040    @.@p    ORR      r0,r0,#0x3000000
        0x00207efe:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;187    
;;;188        GPIO->DATADIR       = GPIO_StoreReg[1];
        0x00207f02:    480c        .H      LDR      r0,[pc,#48] ; [0x207f34] = 0x20805c
        0x00207f04:    490e        .I      LDR      r1,[pc,#56] ; [0x207f40] = 0x40001000
        0x00207f06:    30ac        .0      ADDS     r0,r0,#0xac
        0x00207f08:    6843        Ch      LDR      r3,[r0,#4]
        0x00207f0a:    604b        K`      STR      r3,[r1,#4]
;;;189        GPIO->DATASRC       = GPIO_StoreReg[2];
        0x00207f0c:    6884        .h      LDR      r4,[r0,#8]
        0x00207f0e:    608c        .`      STR      r4,[r1,#8]
;;;190        GPIO->INTMASK       = GPIO_StoreReg[4];
        0x00207f10:    6904        .i      LDR      r4,[r0,#0x10]
        0x00207f12:    634c        Lc      STR      r4,[r1,#0x34]
;;;191        GPIO->INTTYPE       = GPIO_StoreReg[5];
        0x00207f14:    6944        Di      LDR      r4,[r0,#0x14]
        0x00207f16:    638c        .c      STR      r4,[r1,#0x38]
;;;192        GPIO->INTPOLARITY   = GPIO_StoreReg[6];
        0x00207f18:    6984        .i      LDR      r4,[r0,#0x18]
        0x00207f1a:    63cc        .c      STR      r4,[r1,#0x3c]
;;;193        GPIO->DEBOUNCE      = GPIO_StoreReg[7];
        0x00207f1c:    69c4        .i      LDR      r4,[r0,#0x1c]
        0x00207f1e:    648c        .d      STR      r4,[r1,#0x48]
;;;194        GPIO->DATAOUT       = GPIO_StoreReg[0];
        0x00207f20:    6804        .h      LDR      r4,[r0,#0]
        0x00207f22:    600c        .`      STR      r4,[r1,#0]
;;;195        GPIO->INTCLR        = ~(GPIO_StoreReg[1]);
        0x00207f24:    43db        .C      MVNS     r3,r3
        0x00207f26:    64cb        .d      STR      r3,[r1,#0x4c]
;;;196        GPIO->INTEN         = GPIO_StoreReg[3];
        0x00207f28:    68c3        .h      LDR      r3,[r0,#0xc]
        0x00207f2a:    630b        .c      STR      r3,[r1,#0x30]
;;;197        *(__IO uint32_t *)(0x40000344UL) = GPIO_StoreReg[8];
        0x00207f2c:    6a00        .j      LDR      r0,[r0,#0x20]
        0x00207f2e:    f8c20344    ..D.    STR      r0,[r2,#0x344]
;;;198    
;;;199        return;
;;;200    }
        0x00207f32:    bd10        ..      POP      {r4,pc}
    $d
        0x00207f34:    0020805c    \. .    DCD    2130012
        0x00207f38:    e000ed08    ....    DCD    3758157064
        0x00207f3c:    40006000    .`.@    DCD    1073766400
        0x00207f40:    40001000    ...@    DCD    1073745920
        0x00207f44:    08800230    0...    DCD    142606896
        0x00207f48:    21100401    ...!    DCD    554697729

** Section #6 'RAM_DATA_ON' (SHT_PROGBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 208 bytes (alignment 4)
    Address: 0x00207f4c

    0x207f4c:   74 65 72 01 1e 00 00 00 0e 01 5d 00 00 00 00 01    ter.......].....
    0x207f5c:   00 01 02 00 00 03 04 05 fe 00 65 78 70 65 72 69    ..........experi
    0x207f6c:   6d 65 6e 74 61 6c 00 00 00 00 00 00 00 00 00 00    mental..........
    0x207f7c:   00 00 00 00 00 00 01 03 19 40 02 09 09 42 4c 42    .........@...BLB
    0x207f8c:   5f 50 52 4f 58 02 01 06 11 07 a6 f6 f6 07 4d c4    _PROX.........M.
    0x207f9c:   9d 98 6d 45 29 bb d0 ff 00 00 00 00 01 00 00 00    ..mE)...........
    0x207fac:   1e 00 00 00 70 13 81 00 cc 18 81 00 8c 19 81 00    ....p...........
    0x207fbc:   c8 82 20 00 88 83 20 00 88 83 20 00 c0 00 00 00    .. ... ... .....
    0x207fcc:   00 00 00 00 00 00 00 00 60 13 81 00 8c 19 81 00    ........`.......
    0x207fdc:   8c 19 81 00 c8 82 20 00 c8 82 20 00 c8 82 20 00    ...... ... ... .
    0x207fec:   00 00 00 00 00 00 00 00 00 00 00 00 68 13 81 00    ............h...
    0x207ffc:   8c 19 81 00 8c 19 81 00 c8 82 20 00 c8 82 20 00    .......... ... .
    0x20800c:   c8 82 20 00 00 00 00 00 00 00 00 00 00 00 00 00    .. .............


** Section #7 'RAM_DATA_ON' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 684 bytes (alignment 4)
    Address: 0x0020801c


** Section #8 'OVERLAY_A' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 192 bytes (alignment 4)
    Address: 0x002082c8

    $t
    .app.overlay_a
    AppUpdateVectorTable
;;; .\..\source\cmsis\system_rtl8762c.c
;;;628    static void AppUpdateVectorTable(void)
;;;628    {
        0x002082c8:    e92d43f0    -..C    PUSH     {r4-r9,lr}
        0x002082cc:    b0bd        ..      SUB      sp,sp,#0xf4
;;;629        extern uint32_t Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;630        extern uint32_t Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;631        extern void Default_Handler(void);
;;;632        const char *SysException[] =
        0x002082ce:    2240        @"      MOVS     r2,#0x40
        0x002082d0:    4926        &I      LDR      r1,[pc,#152] ; [0x20836c] = 0x810b7c
        0x002082d2:    a82d        -.      ADD      r0,sp,#0xb4
        0x002082d4:    f651fe68    Q.h.    BL       __aeabi_memcpy4 ; 0x59fa8
;;;633        {
;;;634            "InitialSP", "Reset", "NMI", "HardFault", "MemManage", "BusFault", "UsageFault", "Rsvd",
;;;635            "Rsvd", "Rsvd", "Rsvd", "SVC", "DebugMon", "Rsvd", "PendSV", "SysTick"
;;;636        };
;;;637        const char *ExtIrq[] =
        0x002082d8:    4924        $I      LDR      r1,[pc,#144] ; [0x20836c] = 0x810b7c
        0x002082da:    22b4        ."      MOVS     r2,#0xb4
        0x002082dc:    3140        @1      ADDS     r1,r1,#0x40
        0x002082de:    4668        hF      MOV      r0,sp
        0x002082e0:    f651fe62    Q.b.    BL       __aeabi_memcpy4 ; 0x59fa8
        0x002082e4:    4924        $I      LDR      r1,[pc,#144] ; [0x208378] = 0xe000ed08
;;;638        {
;;;639            "System", "WDG", "BTMAC", "TIM3", "TIM2", "Platform", "I2S0_TX", "I2S0_RX", "Timer4-7",
;;;640            "GPIO4", "GPIO5", "UART1", "UART0", "RTC", "SPI0", "SPI1", "I2C0", "I2C1", "ADC",
;;;641            "Peripheral", "GDMA0 Channel0", "GDMA0 Channel1", "GDMA0 Channel2", "GDMA0 Channel3",
;;;642            "GDMA0 Channel4", "GDMA0 Channel5", "GPIO_Group3", "GPIO_Group2", "IR", "GPIO_Group1",
;;;643            "GPIO_Group0", "UART2", "TIM4", "TIM5", "TIM6", "TIM7", "SPI_Flash", "Qdecode",
;;;644            "Keyscan", "SPI2W", "LPCOMP", "PTA_Mailbox", "SPORT1 TX", "SPORT1 RX", "LCD"
;;;645        };
;;;646    
;;;647        IRQ_Fun *pRamVector    = (IRQ_Fun *)VTOR_RAM_ADDR;
        0x002082e6:    f44f1000    O...    MOV      r0,#0x200000
        0x002082ea:    4d21        !M      LDR      r5,[pc,#132] ; [0x208370] = 0x8113bc
        0x002082ec:    4f21        !O      LDR      r7,[pc,#132] ; [0x208374] = 0xf4
        0x002082ee:    6809        .h      LDR      r1,[r1,#0]
        0x002082f0:    4606        .F      MOV      r6,r0
;;;648        IRQ_Fun *pAppVector    = (IRQ_Fun *)&Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;649        uint32_t AppVectorSize = (uint32_t)&Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;650        uint32_t i             = 0;
        0x002082f2:    2400        .$      MOVS     r4,#0
;;;651    
;;;652        if (SCB->VTOR != VTOR_RAM_ADDR)
        0x002082f4:    42b1        .B      CMP      r1,r6
        0x002082f6:    d001        ..      BEQ      0x2082fc ; AppUpdateVectorTable + 52
;;;653        {
;;;654            RamVectorTableInit(VTOR_RAM_ADDR);
        0x002082f8:    f5fcfcd6    ....    BL       RamVectorTableInit ; 0x4ca8
        0x002082fc:    f04f5805    O..X    MOV      r8,#0x21400000
        0x00208300:    f8df9078    ..x.    LDR      r9,[pc,#120] ; [0x20837c] = 0x21100101
;;;655        }
;;;656    
;;;657        /* Update APP defined handlers */
;;;658        for (i = 0; i < AppVectorSize / 4; ++i)
        0x00208304:    e027        '.      B        0x208356 ; AppUpdateVectorTable + 142
;;;659        {
;;;660            if (i == 1) //skip reset_handler remap
        0x00208306:    2c01        .,      CMP      r4,#1
        0x00208308:    d024        $.      BEQ      0x208354 ; AppUpdateVectorTable + 140
;;;661            {
;;;662                continue;
;;;663            }
;;;664    
;;;665            if ((pAppVector[i] != Default_Handler) && (pAppVector[i] != 0))
        0x0020830a:    f8550024    U.$.    LDR      r0,[r5,r4,LSL #2]
        0x0020830e:    491c        .I      LDR      r1,[pc,#112] ; [0x208380] = 0x810705
        0x00208310:    4288        .B      CMP      r0,r1
        0x00208312:    d01f        ..      BEQ      0x208354 ; AppUpdateVectorTable + 140
        0x00208314:    b1f0        ..      CBZ      r0,0x208354 ; AppUpdateVectorTable + 140
;;;666            {
;;;667                if (i < System_VECTORn)
        0x00208316:    2c10        .,      CMP      r4,#0x10
        0x00208318:    d209        ..      BCS      0x20832e ; AppUpdateVectorTable + 102
;;;668                {
;;;669                    OS_PRINT_WARN1("Warning! %s is updated by APP!", TRACE_STRING(SysException[i]));
        0x0020831a:    a82d        -.      ADD      r0,sp,#0xb4
        0x0020831c:    f8501024    P.$.    LDR      r1,[r0,r4,LSL #2]
        0x00208320:    4640        @F      MOV      r0,r8
        0x00208322:    f5fffda2    ....    BL       trace_string ; 0x7e6a
        0x00208326:    4603        .F      MOV      r3,r0
        0x00208328:    2201        ."      MOVS     r2,#1
        0x0020832a:    4916        .I      LDR      r1,[pc,#88] ; [0x208384] = 0x880009c
        0x0020832c:    e00b        ..      B        0x208346 ; AppUpdateVectorTable + 126
;;;670                }
;;;671                else
;;;672                {
;;;673                    OS_PRINT_WARN1("Warning! ISR %s is updated by APP!",
        0x0020832e:    4668        hF      MOV      r0,sp
        0x00208330:    eb000084    ....    ADD      r0,r0,r4,LSL #2
        0x00208334:    f8501c40    P.@.    LDR      r1,[r0,#-0x40]
        0x00208338:    4640        @F      MOV      r0,r8
        0x0020833a:    f5fffd96    ....    BL       trace_string ; 0x7e6a
        0x0020833e:    4911        .I      LDR      r1,[pc,#68] ; [0x208384] = 0x880009c
        0x00208340:    2201        ."      MOVS     r2,#1
        0x00208342:    4603        .F      MOV      r3,r0
        0x00208344:    3124        $1      ADDS     r1,r1,#0x24
        0x00208346:    4648        HF      MOV      r0,r9
        0x00208348:    f5fffb89    ....    BL       log_buffer ; 0x7a5e
;;;674                                   TRACE_STRING(ExtIrq[i - System_VECTORn]));
;;;675                }
;;;676    
;;;677                pRamVector[i] = pAppVector[i];
        0x0020834c:    f8550024    U.$.    LDR      r0,[r5,r4,LSL #2]
        0x00208350:    f8460024    F.$.    STR      r0,[r6,r4,LSL #2]
        0x00208354:    1c64        d.      ADDS     r4,r4,#1
        0x00208356:    ebb40f97    ....    CMP      r4,r7,LSR #2
        0x0020835a:    d3d4        ..      BCC      0x208306 ; AppUpdateVectorTable + 62
;;;678            }
;;;679        }
;;;680    
;;;681        __DMB();
        0x0020835c:    f3bf8f5f    .._.    DMB      
;;;682        __DSB();
        0x00208360:    f3bf8f4f    ..O.    DSB      
;;;683    }
        0x00208364:    b03d        =.      ADD      sp,sp,#0xf4
        0x00208366:    e8bd83f0    ....    POP      {r4-r9,pc}
    $d
        0x0020836a:    0000        ..      DCW    0
        0x0020836c:    00810b7c    |...    DCD    8457084
        0x00208370:    008113bc    ....    DCD    8459196
        0x00208374:    000000f4    ....    DCD    244
        0x00208378:    e000ed08    ....    DCD    3758157064
        0x0020837c:    21100101    ...!    DCD    554696961
        0x00208380:    00810705    ....    DCD    8455941
        0x00208384:    0880009c    ....    DCD    142606492

** Section #9 'App.trace' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 4456 bytes (alignment 4)
    Address: 0x08800000

    0x8800000:   21 2a 2a 52 45 53 45 54 20 52 65 61 73 6f 6e 3a    !**RESET Reason:
    0x8800010:   20 48 57 20 6f 72 20 4f 54 41 00 00 21 2a 2a 52     HW or OTA..!**R
    0x8800020:   45 53 45 54 20 52 65 61 73 6f 6e 3a 20 53 57 28    ESET Reason: SW(
    0x8800030:   72 65 73 65 74 20 65 78 63 65 70 74 20 61 6f 6e    reset except aon
    0x8800040:   29 2c 20 54 59 50 45 20 30 78 25 78 00 00 00 00    ), TYPE 0x%x....
    0x8800050:   21 2a 2a 52 45 53 45 54 20 52 65 61 73 6f 6e 3a    !**RESET Reason:
    0x8800060:   20 53 57 28 72 65 73 65 74 20 61 6c 6c 29 2c 20     SW(reset all), 
    0x8800070:   54 59 50 45 20 30 78 25 78 00 00 00 21 21 21 53    TYPE 0x%x...!!!S
    0x8800080:   44 4b 20 56 65 72 3a 20 25 73 2c 20 42 75 69 6c    DK Ver: %s, Buil
    0x8800090:   64 20 54 69 6d 65 3a 20 25 73 00 00 21 21 2a 57    d Time: %s..!!*W
    0x88000a0:   61 72 6e 69 6e 67 21 20 25 73 20 69 73 20 75 70    arning! %s is up
    0x88000b0:   64 61 74 65 64 20 62 79 20 41 50 50 21 00 00 00    dated by APP!...
    0x88000c0:   21 21 2a 57 61 72 6e 69 6e 67 21 20 49 53 52 20    !!*Warning! ISR 
    0x88000d0:   25 73 20 69 73 20 75 70 64 61 74 65 64 20 62 79    %s is updated by
    0x88000e0:   20 41 50 50 21 00 00 00 21 21 21 73 65 6e 64 5f     APP!...!!!send_
    0x88000f0:   69 6f 5f 6d 73 67 5f 74 6f 5f 61 70 70 20 66 61    io_msg_to_app fa
    0x8800100:   69 6c 00 00 21 21 21 73 65 6e 64 5f 65 76 74 5f    il..!!!send_evt_
    0x8800110:   6d 73 67 5f 74 6f 5f 61 70 70 20 66 61 69 6c 00    msg_to_app fail.
    0x8800120:   21 21 21 45 6e 74 65 72 20 47 50 49 4f 35 5f 48    !!!Enter GPIO5_H
    0x8800130:   61 6e 64 6c 65 72 21 00 21 21 21 4d 53 47 5f 53    andler!.!!!MSG_S
    0x8800140:   48 4f 52 54 5f 50 52 45 53 53 00 00 21 21 21 45    HORT_PRESS..!!!E
    0x8800150:   52 52 4f 52 20 49 4f 20 53 54 41 54 55 53 00 00    RROR IO STATUS..
    0x8800160:   21 21 21 4d 53 47 5f 4c 4f 4e 47 5f 50 52 45 53    !!!MSG_LONG_PRES
    0x8800170:   53 00 00 00 21 21 21 45 52 52 4f 52 20 50 4f 57    S...!!!ERROR POW
    0x8800180:   45 52 20 53 54 41 54 55 53 00 00 00 21 21 21 45    ER STATUS...!!!E
    0x8800190:   52 52 4f 52 20 50 4f 57 45 52 20 53 54 41 54 55    RROR POWER STATU
    0x88001a0:   53 00 00 00 21 21 21 45 52 52 4f 52 20 50 4f 57    S...!!!ERROR POW
    0x88001b0:   45 52 20 53 54 41 54 55 53 00 00 00 21 21 21 45    ER STATUS...!!!E
    0x88001c0:   52 52 4f 52 20 49 4f 20 4d 4f 44 45 00 00 00 00    RROR IO MODE....
    0x88001d0:   21 2a 2a 78 54 69 6d 65 72 50 78 70 49 4f 20 6f    !**xTimerPxpIO o
    0x88001e0:   73 5f 74 69 6d 65 72 5f 72 65 73 74 61 72 74 2e    s_timer_restart.
    0x88001f0:   00 00 00 00 21 2a 2a 78 54 69 6d 65 72 41 6c 65    ....!**xTimerAle
    0x8800200:   72 74 20 72 65 74 76 61 6c 20 69 73 20 25 64 00    rt retval is %d.
    0x8800210:   21 2a 2a 78 54 69 6d 65 72 4c 6f 6e 67 50 72 65    !**xTimerLongPre
    0x8800220:   73 73 20 72 65 74 76 61 6c 20 69 73 20 25 64 00    ss retval is %d.
    0x8800230:   21 21 2a 6d 69 73 73 20 69 6e 74 65 72 72 75 70    !!*miss interrup
    0x8800240:   74 3a 20 70 65 6e 64 69 6e 67 20 72 65 67 69 73    t: pending regis
    0x8800250:   74 65 72 3a 20 30 78 25 78 00 00 00 21 21 21 69    ter: 0x%x...!!!i
    0x8800260:   61 73 5f 61 74 74 72 5f 77 72 69 74 65 5f 63 62    as_attr_write_cb
    0x8800270:   3a 20 70 5f 76 61 6c 75 65 20 25 70 20 6c 65 6e    : p_value %p len
    0x8800280:   67 74 68 3d 20 30 78 25 78 00 00 00 21 21 21 69    gth= 0x%x...!!!i
    0x8800290:   61 73 5f 61 64 64 5f 73 65 72 76 69 63 65 3a 20    as_add_service: 
    0x88002a0:   73 65 72 76 69 63 65 5f 69 64 20 25 64 00 00 00    service_id %d...
    0x88002b0:   21 21 21 6c 6c 73 5f 73 65 74 5f 70 61 72 61 6d    !!!lls_set_param
    0x88002c0:   65 74 65 72 3a 20 6c 6c 73 20 61 6c 65 72 74 20    eter: lls alert 
    0x88002d0:   6c 65 76 65 6c 20 70 61 72 61 6d 65 74 65 72 20    level parameter 
    0x88002e0:   73 65 74 20 66 61 69 6c 65 64 00 00 21 21 21 6c    set failed..!!!l
    0x88002f0:   6c 73 5f 61 74 74 72 5f 72 65 61 64 5f 63 62 20    ls_attr_read_cb 
    0x8800300:   64 65 66 61 75 6c 74 3a 61 74 74 72 69 62 5f 69    default:attrib_i
    0x8800310:   6e 64 65 78 20 25 64 00 21 2a 2a 6c 6c 73 5f 61    ndex %d.!**lls_a
    0x8800320:   74 74 72 5f 72 65 61 64 5f 63 62 3a 20 61 74 74    ttr_read_cb: att
    0x8800330:   72 69 62 5f 69 6e 64 65 78 20 25 64 2c 20 6c 65    rib_index %d, le
    0x8800340:   6e 67 74 68 20 25 64 00 21 21 21 6c 6c 73 5f 61    ngth %d.!!!lls_a
    0x8800350:   74 74 72 5f 77 72 69 74 65 5f 63 62 3a 20 70 5f    ttr_write_cb: p_
    0x8800360:   76 61 6c 75 65 20 25 70 2c 20 6c 65 6e 67 74 68    value %p, length
    0x8800370:   20 30 78 25 78 00 00 00 21 21 21 6c 6c 73 5f 61     0x%x...!!!lls_a
    0x8800380:   64 64 5f 73 65 72 76 69 63 65 3a 20 73 65 72 76    dd_service: serv
    0x8800390:   69 63 65 5f 69 64 20 25 64 00 00 00 21 21 21 74    ice_id %d...!!!t
    0x88003a0:   70 73 5f 73 65 74 5f 70 61 72 61 6d 65 74 65 72    ps_set_parameter
    0x88003b0:   3a 20 54 50 53 20 70 61 72 61 6d 65 74 65 72 20    : TPS parameter 
    0x88003c0:   73 65 74 20 66 61 69 6c 65 64 00 00 21 21 21 74    set failed..!!!t
    0x88003d0:   70 73 5f 61 74 74 72 5f 72 65 61 64 5f 63 62 3a    ps_attr_read_cb:
    0x88003e0:   20 61 74 74 72 69 62 5f 69 6e 64 65 78 20 25 64     attrib_index %d
    0x88003f0:   00 00 00 00 21 2a 2a 74 70 73 5f 61 74 74 72 5f    ....!**tps_attr_
    0x8800400:   72 65 61 64 5f 63 62 3a 20 61 74 74 72 69 62 5f    read_cb: attrib_
    0x8800410:   69 6e 64 65 78 20 25 64 2c 20 2a 6c 65 6e 67 74    index %d, *lengt
    0x8800420:   68 5f 70 74 72 20 25 64 00 00 00 00 21 21 21 74    h_ptr %d....!!!t
    0x8800430:   70 73 5f 61 64 64 5f 73 65 72 76 69 63 65 3a 20    ps_add_service: 
    0x8800440:   73 65 72 76 69 63 65 5f 69 64 20 25 64 00 00 00    service_id %d...
    0x8800450:   21 21 21 62 61 73 5f 73 65 74 5f 70 61 72 61 6d    !!!bas_set_param
    0x8800460:   65 74 65 72 20 66 61 69 6c 65 64 00 21 2a 2a 62    eter failed.!**b
    0x8800470:   61 73 5f 61 74 74 72 5f 72 65 61 64 5f 63 62 20    as_attr_read_cb 
    0x8800480:   61 74 74 72 69 62 5f 69 6e 64 65 78 20 3d 20 25    attrib_index = %
    0x8800490:   64 20 6f 66 66 73 65 74 20 25 78 00 21 21 21 62    d offset %x.!!!b
    0x88004a0:   61 73 5f 61 74 74 72 5f 72 65 61 64 5f 63 62 20    as_attr_read_cb 
    0x88004b0:   61 74 74 72 69 62 5f 69 6e 64 65 78 20 3d 20 25    attrib_index = %
    0x88004c0:   64 20 6e 6f 74 20 66 6f 75 6e 64 00 21 2a 2a 62    d not found.!**b
    0x88004d0:   61 73 5f 63 63 63 64 5f 75 70 64 61 74 65 5f 63    as_cccd_update_c
    0x88004e0:   62 20 69 6e 64 65 78 20 3d 20 25 64 20 63 63 63    b index = %d ccc
    0x88004f0:   5f 62 69 74 73 20 25 78 00 00 00 00 21 21 21 62    _bits %x....!!!b
    0x8800500:   61 73 5f 61 64 64 5f 73 65 72 76 69 63 65 3a 20    as_add_service: 
    0x8800510:   73 65 72 76 69 63 65 5f 69 64 20 25 64 00 00 00    service_id %d...
    0x8800520:   21 21 21 62 61 73 5f 73 65 74 5f 70 61 72 61 6d    !!!bas_set_param
    0x8800530:   65 74 65 72 20 66 61 69 6c 65 64 00 21 21 21 6b    eter failed.!!!k
    0x8800540:   6e 73 5f 61 74 74 72 5f 72 65 61 64 5f 63 62 20    ns_attr_read_cb 
    0x8800550:   61 74 74 72 69 62 5f 69 6e 64 65 78 20 3d 20 25    attrib_index = %
    0x8800560:   64 20 6e 6f 74 20 66 6f 75 6e 64 00 21 2a 2a 3c    d not found.!**<
    0x8800570:   2d 2d 20 67 61 74 74 20 67 65 74 20 50 78 70 45    -- gatt get PxpE
    0x8800580:   78 74 65 6e 64 65 64 20 61 74 74 72 69 62 75 74    xtended attribut
    0x8800590:   65 20 76 61 6c 75 65 3a 20 41 74 74 72 69 62 49    e value: AttribI
    0x88005a0:   6e 64 65 78 2d 2d 25 64 2c 20 6c 65 6e 67 74 68    ndex--%d, length
    0x88005b0:   2d 2d 25 64 00 00 00 00 21 21 21 6b 6e 73 5f 61    --%d....!!!kns_a
    0x88005c0:   74 74 72 5f 77 72 69 74 65 5f 63 62 3a 20 70 5f    ttr_write_cb: p_
    0x88005d0:   76 61 6c 75 65 20 25 70 2c 20 6c 65 6e 67 74 68    value %p, length
    0x88005e0:   20 30 78 25 78 00 00 00 21 2a 2a 6b 6e 73 5f 63     0x%x...!**kns_c
    0x88005f0:   63 63 64 5f 75 70 64 61 74 65 5f 63 62 20 69 6e    ccd_update_cb in
    0x8800600:   64 65 78 20 3d 20 25 64 20 63 63 63 5f 62 69 74    dex = %d ccc_bit
    0x8800610:   73 20 25 78 00 00 00 00 21 21 21 6b 6e 73 5f 61    s %x....!!!kns_a
    0x8800620:   64 64 5f 73 65 72 76 69 63 65 3a 20 73 65 72 76    dd_service: serv
    0x8800630:   69 63 65 5f 69 64 20 25 64 00 00 00 21 21 21 44    ice_id %d...!!!D
    0x8800640:   49 53 20 70 61 72 61 6d 65 74 65 72 20 73 65 74    IS parameter set
    0x8800650:   20 66 61 69 6c 65 64 00 21 21 21 64 69 73 5f 61     failed.!!!dis_a
    0x8800660:   74 74 72 5f 72 65 61 64 5f 63 62 3a 20 61 74 74    ttr_read_cb: att
    0x8800670:   72 69 62 5f 69 6e 64 65 78 20 25 64 00 00 00 00    rib_index %d....
    0x8800680:   21 2a 2a 64 69 73 5f 61 74 74 72 5f 72 65 61 64    !**dis_attr_read
    0x8800690:   5f 63 62 3a 20 61 74 74 72 69 62 5f 69 6e 64 65    _cb: attrib_inde
    0x88006a0:   78 20 25 64 2c 20 2a 6c 65 6e 67 74 68 5f 70 74    x %d, *length_pt
    0x88006b0:   72 20 25 64 00 00 00 00 21 21 21 64 69 73 5f 61    r %d....!!!dis_a
    0x88006c0:   64 64 5f 73 65 72 76 69 63 65 3a 20 73 65 72 76    dd_service: serv
    0x88006d0:   69 63 65 5f 69 64 20 25 64 00 00 00 21 2a 2a 53    ice_id %d...!**S
    0x88006e0:   79 73 74 65 6d 5f 48 61 6e 64 6c 65 72 00 00 00    ystem_Handler...
    0x88006f0:   21 2a 2a 5b 57 44 47 5d 20 57 61 74 63 68 20 44    !**[WDG] Watch D
    0x8800700:   6f 67 20 52 73 65 74 20 54 69 6d 65 72 00 00 00    og Rset Timer...
    0x8800710:   21 2a 2a 61 70 70 5f 68 61 6e 64 6c 65 5f 64 65    !**app_handle_de
    0x8800720:   76 5f 73 74 61 74 65 5f 65 76 74 3a 20 69 6e 69    v_state_evt: ini
    0x8800730:   74 20 73 74 61 74 65 20 25 64 2c 20 61 64 76 20    t state %d, adv 
    0x8800740:   73 74 61 74 65 20 25 64 2c 20 63 61 75 73 65 20    state %d, cause 
    0x8800750:   30 78 25 78 00 00 00 00 21 2a 2a 47 41 50 20 73    0x%x....!**GAP s
    0x8800760:   74 61 63 6b 20 72 65 61 64 79 00 00 21 2a 2a 47    tack ready..!**G
    0x8800770:   41 50 20 61 64 76 20 73 74 6f 70 65 64 3a 20 62    AP adv stoped: b
    0x8800780:   65 63 61 75 73 65 20 63 6f 6e 6e 65 63 74 69 6f    ecause connectio
    0x8800790:   6e 20 63 72 65 61 74 65 64 00 00 00 21 2a 2a 47    n created...!**G
    0x88007a0:   41 50 20 61 64 76 20 73 74 6f 70 65 64 00 00 00    AP adv stoped...
    0x88007b0:   21 2a 2a 47 41 50 20 61 64 76 20 73 74 61 72 74    !**GAP adv start
    0x88007c0:   00 00 00 00 21 2a 2a 61 70 70 5f 68 61 6e 64 6c    ....!**app_handl
    0x88007d0:   65 5f 63 6f 6e 6e 5f 73 74 61 74 65 5f 65 76 74    e_conn_state_evt
    0x88007e0:   3a 20 63 6f 6e 6e 5f 69 64 20 25 64 20 6f 6c 64    : conn_id %d old
    0x88007f0:   5f 73 74 61 74 65 20 25 64 20 6e 65 77 5f 73 74    _state %d new_st
    0x8800800:   61 74 65 20 25 64 2c 20 64 69 73 63 5f 63 61 75    ate %d, disc_cau
    0x8800810:   73 65 20 30 78 25 78 00 21 21 21 61 70 70 5f 68    se 0x%x.!!!app_h
    0x8800820:   61 6e 64 6c 65 5f 63 6f 6e 6e 5f 73 74 61 74 65    andle_conn_state
    0x8800830:   5f 65 76 74 3a 20 63 6f 6e 6e 65 63 74 69 6f 6e    _evt: connection
    0x8800840:   20 6c 6f 73 74 20 63 61 75 73 65 20 30 78 25 78     lost cause 0x%x
    0x8800850:   00 00 00 00 21 21 21 67 5f 70 78 70 5f 6c 69 6e    ....!!!g_pxp_lin
    0x8800860:   6b 6c 6f 73 73 5f 61 6c 65 72 74 5f 6c 65 76 65    kloss_alert_leve
    0x8800870:   6c 20 69 73 20 25 64 00 21 2a 2a 47 41 50 5f 43    l is %d.!**GAP_C
    0x8800880:   4f 4e 4e 5f 53 54 41 54 45 5f 43 4f 4e 4e 45 43    ONN_STATE_CONNEC
    0x8800890:   54 45 44 3a 72 65 6d 6f 74 65 5f 62 64 20 25 73    TED:remote_bd %s
    0x88008a0:   2c 20 72 65 6d 6f 74 65 5f 61 64 64 72 5f 74 79    , remote_addr_ty
    0x88008b0:   70 65 20 25 64 2c 20 63 6f 6e 6e 5f 69 6e 74 65    pe %d, conn_inte
    0x88008c0:   72 76 61 6c 20 30 78 25 78 2c 20 63 6f 6e 6e 5f    rval 0x%x, conn_
    0x88008d0:   6c 61 74 65 6e 63 79 20 30 78 25 78 2c 20 63 6f    latency 0x%x, co
    0x88008e0:   6e 6e 5f 73 75 70 65 72 76 69 73 69 6f 6e 5f 74    nn_supervision_t
    0x88008f0:   69 6d 65 6f 75 74 20 30 78 25 78 00 21 2a 2a 61    imeout 0x%x.!**a
    0x8800900:   70 70 5f 68 61 6e 64 6c 65 5f 61 75 74 68 65 6e    pp_handle_authen
    0x8800910:   5f 73 74 61 74 65 5f 65 76 74 3a 63 6f 6e 6e 5f    _state_evt:conn_
    0x8800920:   69 64 20 25 64 2c 20 63 61 75 73 65 20 30 78 25    id %d, cause 0x%
    0x8800930:   78 00 00 00 21 2a 2a 61 70 70 5f 68 61 6e 64 6c    x...!**app_handl
    0x8800940:   65 5f 61 75 74 68 65 6e 5f 73 74 61 74 65 5f 65    e_authen_state_e
    0x8800950:   76 74 3a 20 47 41 50 5f 41 55 54 48 45 4e 5f 53    vt: GAP_AUTHEN_S
    0x8800960:   54 41 54 45 5f 53 54 41 52 54 45 44 00 00 00 00    TATE_STARTED....
    0x8800970:   21 2a 2a 61 70 70 5f 68 61 6e 64 6c 65 5f 61 75    !**app_handle_au
    0x8800980:   74 68 65 6e 5f 73 74 61 74 65 5f 65 76 74 3a 20    then_state_evt: 
    0x8800990:   47 41 50 5f 41 55 54 48 45 4e 5f 53 54 41 54 45    GAP_AUTHEN_STATE
    0x88009a0:   5f 43 4f 4d 50 4c 45 54 45 20 70 61 69 72 20 73    _COMPLETE pair s
    0x88009b0:   75 63 63 65 73 73 00 00 21 2a 2a 61 70 70 5f 68    uccess..!**app_h
    0x88009c0:   61 6e 64 6c 65 5f 61 75 74 68 65 6e 5f 73 74 61    andle_authen_sta
    0x88009d0:   74 65 5f 65 76 74 3a 20 47 41 50 5f 41 55 54 48    te_evt: GAP_AUTH
    0x88009e0:   45 4e 5f 53 54 41 54 45 5f 43 4f 4d 50 4c 45 54    EN_STATE_COMPLET
    0x88009f0:   45 20 70 61 69 72 20 66 61 69 6c 65 64 00 00 00    E pair failed...
    0x8800a00:   21 21 21 61 70 70 5f 68 61 6e 64 6c 65 5f 61 75    !!!app_handle_au
    0x8800a10:   74 68 65 6e 5f 73 74 61 74 65 5f 65 76 74 3a 20    then_state_evt: 
    0x8800a20:   75 6e 6b 6e 6f 77 6e 20 6e 65 77 73 74 61 74 65    unknown newstate
    0x8800a30:   20 25 64 00 21 2a 2a 61 70 70 5f 68 61 6e 64 6c     %d.!**app_handl
    0x8800a40:   65 5f 63 6f 6e 6e 5f 6d 74 75 5f 69 6e 66 6f 5f    e_conn_mtu_info_
    0x8800a50:   65 76 74 3a 20 63 6f 6e 6e 5f 69 64 20 25 64 2c    evt: conn_id %d,
    0x8800a60:   20 6d 74 75 5f 73 69 7a 65 20 25 64 00 00 00 00     mtu_size %d....
    0x8800a70:   21 2a 2a 61 70 70 5f 68 61 6e 64 6c 65 5f 63 6f    !**app_handle_co
    0x8800a80:   6e 6e 5f 70 61 72 61 6d 5f 75 70 64 61 74 65 5f    nn_param_update_
    0x8800a90:   65 76 74 20 75 70 64 61 74 65 20 73 75 63 63 65    evt update succe
    0x8800aa0:   73 73 3a 63 6f 6e 6e 5f 69 6e 74 65 72 76 61 6c    ss:conn_interval
    0x8800ab0:   20 30 78 25 78 2c 20 63 6f 6e 6e 5f 73 6c 61 76     0x%x, conn_slav
    0x8800ac0:   65 5f 6c 61 74 65 6e 63 79 20 30 78 25 78 2c 20    e_latency 0x%x, 
    0x8800ad0:   63 6f 6e 6e 5f 73 75 70 65 72 76 69 73 69 6f 6e    conn_supervision
    0x8800ae0:   5f 74 69 6d 65 6f 75 74 20 30 78 25 78 00 00 00    _timeout 0x%x...
    0x8800af0:   21 21 21 61 70 70 5f 68 61 6e 64 6c 65 5f 63 6f    !!!app_handle_co
    0x8800b00:   6e 6e 5f 70 61 72 61 6d 5f 75 70 64 61 74 65 5f    nn_param_update_
    0x8800b10:   65 76 74 20 75 70 64 61 74 65 20 66 61 69 6c 65    evt update faile
    0x8800b20:   64 3a 20 63 61 75 73 65 20 30 78 25 78 00 00 00    d: cause 0x%x...
    0x8800b30:   21 2a 2a 61 70 70 5f 68 61 6e 64 6c 65 5f 63 6f    !**app_handle_co
    0x8800b40:   6e 6e 5f 70 61 72 61 6d 5f 75 70 64 61 74 65 5f    nn_param_update_
    0x8800b50:   65 76 74 20 75 70 64 61 74 65 20 70 65 6e 64 69    evt update pendi
    0x8800b60:   6e 67 2e 00 61 70 70 5f 68 61 6e 64 6c 65 5f 67    ng..app_handle_g
    0x8800b70:   61 70 5f 6d 73 67 3a 20 73 75 62 74 79 70 65 20    ap_msg: subtype 
    0x8800b80:   25 64 00 00 21 2a 2a 47 41 50 5f 4d 53 47 5f 4c    %d..!**GAP_MSG_L
    0x8800b90:   45 5f 42 4f 4e 44 5f 4a 55 53 54 5f 57 4f 52 4b    E_BOND_JUST_WORK
    0x8800ba0:   00 00 00 00 21 2a 2a 47 41 50 5f 4d 53 47 5f 4c    ....!**GAP_MSG_L
    0x8800bb0:   45 5f 42 4f 4e 44 5f 50 41 53 53 4b 45 59 5f 44    E_BOND_PASSKEY_D
    0x8800bc0:   49 53 50 4c 41 59 3a 70 61 73 73 6b 65 79 20 25    ISPLAY:passkey %
    0x8800bd0:   64 00 00 00 21 2a 2a 47 41 50 5f 4d 53 47 5f 4c    d...!**GAP_MSG_L
    0x8800be0:   45 5f 42 4f 4e 44 5f 55 53 45 52 5f 43 4f 4e 46    E_BOND_USER_CONF
    0x8800bf0:   49 52 4d 41 54 49 4f 4e 3a 20 70 61 73 73 6b 65    IRMATION: passke
    0x8800c00:   79 20 25 64 00 00 00 00 21 2a 2a 47 41 50 5f 4d    y %d....!**GAP_M
    0x8800c10:   53 47 5f 4c 45 5f 42 4f 4e 44 5f 50 41 53 53 4b    SG_LE_BOND_PASSK
    0x8800c20:   45 59 5f 49 4e 50 55 54 3a 20 63 6f 6e 6e 5f 69    EY_INPUT: conn_i
    0x8800c30:   64 20 25 64 00 00 00 00 21 2a 2a 47 41 50 5f 4d    d %d....!**GAP_M
    0x8800c40:   53 47 5f 4c 45 5f 42 4f 4e 44 5f 4f 4f 42 5f 49    SG_LE_BOND_OOB_I
    0x8800c50:   4e 50 55 54 00 00 00 00 21 21 21 61 70 70 5f 68    NPUT....!!!app_h
    0x8800c60:   61 6e 64 6c 65 5f 67 61 70 5f 6d 73 67 3a 20 75    andle_gap_msg: u
    0x8800c70:   6e 6b 6e 6f 77 6e 20 73 75 62 74 79 70 65 20 25    nknown subtype %
    0x8800c80:   64 00 00 00 21 2a 2a 47 41 50 5f 4d 53 47 5f 4c    d...!**GAP_MSG_L
    0x8800c90:   45 5f 44 41 54 41 5f 4c 45 4e 5f 43 48 41 4e 47    E_DATA_LEN_CHANG
    0x8800ca0:   45 5f 49 4e 46 4f 3a 20 63 6f 6e 6e 5f 69 64 20    E_INFO: conn_id 
    0x8800cb0:   25 64 2c 20 74 78 20 6f 63 74 65 74 73 20 30 78    %d, tx octets 0x
    0x8800cc0:   25 78 2c 20 6d 61 78 5f 74 78 5f 74 69 6d 65 20    %x, max_tx_time 
    0x8800cd0:   30 78 25 78 00 00 00 00 21 2a 2a 47 41 50 5f 4d    0x%x....!**GAP_M
    0x8800ce0:   53 47 5f 4c 45 5f 4d 4f 44 49 46 59 5f 57 48 49    SG_LE_MODIFY_WHI
    0x8800cf0:   54 45 5f 4c 49 53 54 3a 20 6f 70 65 72 61 74 69    TE_LIST: operati
    0x8800d00:   6f 6e 20 25 64 2c 20 63 61 75 73 65 20 30 78 25    on %d, cause 0x%
    0x8800d10:   78 00 00 00 21 21 21 61 70 70 5f 67 61 70 5f 63    x...!!!app_gap_c
    0x8800d20:   61 6c 6c 62 61 63 6b 3a 20 75 6e 68 61 6e 64 6c    allback: unhandl
    0x8800d30:   65 64 20 63 62 5f 74 79 70 65 20 30 78 25 78 00    ed cb_type 0x%x.
    0x8800d40:   21 2a 2a 50 52 4f 46 49 4c 45 5f 45 56 54 5f 53    !**PROFILE_EVT_S
    0x8800d50:   52 56 5f 52 45 47 5f 43 4f 4d 50 4c 45 54 45 3a    RV_REG_COMPLETE:
    0x8800d60:   20 72 65 73 75 6c 74 20 25 64 00 00 21 2a 2a 50     result %d..!**P
    0x8800d70:   52 4f 46 49 4c 45 5f 45 56 54 5f 53 45 4e 44 5f    ROFILE_EVT_SEND_
    0x8800d80:   44 41 54 41 5f 43 4f 4d 50 4c 45 54 45 3a 20 63    DATA_COMPLETE: c
    0x8800d90:   6f 6e 6e 5f 69 64 20 25 64 2c 20 63 61 75 73 65    onn_id %d, cause
    0x8800da0:   20 30 78 25 78 2c 20 73 65 72 76 69 63 65 5f 69     0x%x, service_i
    0x8800db0:   64 20 25 64 2c 20 61 74 74 72 69 62 5f 69 64 78    d %d, attrib_idx
    0x8800dc0:   20 30 78 25 78 2c 20 63 72 65 64 69 74 73 20 25     0x%x, credits %
    0x8800dd0:   64 00 00 00 21 2a 2a 50 52 4f 46 49 4c 45 5f 45    d...!**PROFILE_E
    0x8800de0:   56 54 5f 53 45 4e 44 5f 44 41 54 41 5f 43 4f 4d    VT_SEND_DATA_COM
    0x8800df0:   50 4c 45 54 45 20 73 75 63 63 65 73 73 00 00 00    PLETE success...
    0x8800e00:   21 21 21 50 52 4f 46 49 4c 45 5f 45 56 54 5f 53    !!!PROFILE_EVT_S
    0x8800e10:   45 4e 44 5f 44 41 54 41 5f 43 4f 4d 50 4c 45 54    END_DATA_COMPLET
    0x8800e20:   45 20 66 61 69 6c 65 64 00 00 00 00 21 21 21 49    E failed....!!!I
    0x8800e30:   41 53 20 43 61 6c 6c 42 61 63 6b 2e 00 00 00 00    AS CallBack.....
    0x8800e40:   21 2a 2a 4b 4e 53 5f 4e 4f 54 49 46 59 5f 45 4e    !**KNS_NOTIFY_EN
    0x8800e50:   41 42 4c 45 00 00 00 00 21 2a 2a 4b 4e 53 5f 4e    ABLE....!**KNS_N
    0x8800e60:   4f 54 49 46 59 5f 44 49 53 41 42 4c 45 00 00 00    OTIFY_DISABLE...
    0x8800e70:   21 2a 2a 4b 4e 53 5f 52 45 41 44 5f 50 41 52 41    !**KNS_READ_PARA
    0x8800e80:   00 00 00 00 21 2a 2a 4b 4e 53 5f 57 52 49 54 45    ....!**KNS_WRITE
    0x8800e90:   5f 50 41 52 41 20 25 78 00 00 00 00 21 2a 2a 42    _PARA %x....!**B
    0x8800ea0:   41 53 5f 4e 4f 54 49 46 59 5f 42 41 54 54 45 52    AS_NOTIFY_BATTER
    0x8800eb0:   59 5f 4c 45 56 45 4c 5f 45 4e 41 42 4c 45 00 00    Y_LEVEL_ENABLE..
    0x8800ec0:   21 2a 2a 42 41 53 5f 4e 4f 54 49 46 59 5f 42 41    !**BAS_NOTIFY_BA
    0x8800ed0:   54 54 45 52 59 5f 4c 45 56 45 4c 5f 44 49 53 41    TTERY_LEVEL_DISA
    0x8800ee0:   42 4c 45 00 21 2a 2a 42 41 53 5f 52 45 41 44 5f    BLE.!**BAS_READ_
    0x8800ef0:   42 41 54 54 45 52 59 5f 4c 45 56 45 4c 3a 20 62    BATTERY_LEVEL: b
    0x8800f00:   61 74 74 65 72 79 5f 6c 65 76 65 6c 20 25 64 00    attery_level %d.
    0x8800f10:   21 21 21 67 61 70 5f 6c 69 62 5f 69 6e 69 74 3a    !!!gap_lib_init:
    0x8800f20:   20 76 65 72 20 25 64 2c 20 46 5f 42 54 5f 4c 45     ver %d, F_BT_LE
    0x8800f30:   5f 35 5f 30 5f 53 55 50 50 4f 52 54 20 25 64 2c    _5_0_SUPPORT %d,
    0x8800f40:   20 46 5f 42 54 5f 4c 45 5f 35 5f 30 5f 41 45 5f     F_BT_LE_5_0_AE_
    0x8800f50:   41 44 56 5f 53 55 50 50 4f 52 54 20 25 64 2c 20    ADV_SUPPORT %d, 
    0x8800f60:   46 5f 42 54 5f 4c 45 5f 35 5f 30 5f 41 45 5f 53    F_BT_LE_5_0_AE_S
    0x8800f70:   43 41 4e 5f 53 55 50 50 4f 52 54 20 25 64 2c 20    CAN_SUPPORT %d, 
    0x8800f80:   46 5f 42 54 5f 4c 45 5f 34 5f 31 5f 43 42 43 5f    F_BT_LE_4_1_CBC_
    0x8800f90:   53 55 50 50 4f 52 54 20 25 64 2c 20 46 5f 42 54    SUPPORT %d, F_BT
    0x8800fa0:   5f 56 45 4e 44 4f 52 5f 46 45 41 54 55 52 45 5f    _VENDOR_FEATURE_
    0x8800fb0:   53 55 50 50 4f 52 54 20 25 64 2c 20 46 5f 42 54    SUPPORT %d, F_BT
    0x8800fc0:   5f 4c 45 5f 36 5f 30 5f 41 4f 41 5f 41 4f 44 5f    _LE_6_0_AOA_AOD_
    0x8800fd0:   53 55 50 50 4f 52 54 20 25 64 2c 20 46 5f 42 54    SUPPORT %d, F_BT
    0x8800fe0:   5f 4c 45 5f 36 5f 30 5f 41 4f 58 5f 43 4f 4e 4e    _LE_6_0_AOX_CONN
    0x8800ff0:   4c 45 53 53 5f 53 55 50 50 4f 52 54 20 25 64 00    LESS_SUPPORT %d.
    0x8801000:   21 21 21 67 61 70 5f 6c 69 62 5f 69 6e 69 74 3a    !!!gap_lib_init:
    0x8801010:   20 46 5f 42 54 5f 4c 45 5f 53 4d 50 5f 53 43 5f     F_BT_LE_SMP_SC_
    0x8801020:   4f 4f 42 5f 53 55 50 50 4f 52 54 20 25 64 2c 20    OOB_SUPPORT %d, 
    0x8801030:   46 5f 42 54 5f 53 57 5f 52 45 53 45 54 5f 53 55    F_BT_SW_RESET_SU
    0x8801040:   50 50 4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 50    PPORT %d, F_BT_P
    0x8801050:   41 54 43 48 5f 46 4f 52 5f 43 48 41 4e 47 45 5f    ATCH_FOR_CHANGE_
    0x8801060:   41 50 49 20 25 64 2c 20 46 5f 42 54 5f 44 4c 50    API %d, F_BT_DLP
    0x8801070:   53 5f 41 50 49 20 25 64 2c 20 46 5f 42 54 5f 43    S_API %d, F_BT_C
    0x8801080:   4f 4e 46 49 47 5f 41 50 49 20 25 64 2c 20 46 5f    ONFIG_API %d, F_
    0x8801090:   42 54 5f 56 45 4e 44 4f 52 5f 41 50 49 20 25 64    BT_VENDOR_API %d
    0x88010a0:   00 00 00 00 21 2a 2a 6c 65 5f 63 68 65 63 6b 5f    ....!**le_check_
    0x88010b0:   70 72 69 76 61 63 79 5f 62 6f 6e 64 3a 20 69 64    privacy_bond: id
    0x88010c0:   78 20 25 64 20 70 72 69 76 61 63 79 20 64 65 76    x %d privacy dev
    0x88010d0:   69 63 65 00 21 2a 2a 6c 65 5f 63 68 65 63 6b 5f    ice.!**le_check_
    0x88010e0:   70 72 69 76 61 63 79 5f 62 6f 6e 64 3a 20 6e 6f    privacy_bond: no
    0x88010f0:   74 20 70 72 69 76 61 63 79 20 64 65 76 69 63 65    t privacy device
    0x8801100:   2c 20 63 61 75 73 65 20 25 64 00 00 21 2a 2a 6c    , cause %d..!**l
    0x8801110:   65 5f 67 65 6e 5f 72 61 6e 64 5f 61 64 64 72 3a    e_gen_rand_addr:
    0x8801120:   20 67 61 70 5f 6c 69 62 2c 20 72 61 6e 64 6f 6d     gap_lib, random
    0x8801130:   20 61 64 64 72 20 25 73 2c 20 61 64 64 72 20 74     addr %s, addr t
    0x8801140:   79 70 65 20 25 64 00 00 21 2a 2a 6c 65 5f 62 6f    ype %d..!**le_bo
    0x8801150:   6e 64 5f 67 65 74 5f 73 65 63 5f 6c 65 76 65 6c    nd_get_sec_level
    0x8801160:   3a 20 25 64 00 00 00 00                            : %d....


** Section #10 '.debug_abbrev' (SHT_PROGBITS)
    Size   : 1476 bytes


** Section #11 '.debug_frame' (SHT_PROGBITS)
    Size   : 4412 bytes


** Section #12 '.debug_info' (SHT_PROGBITS)
    Size   : 181136 bytes


** Section #13 '.debug_line' (SHT_PROGBITS)
    Size   : 23608 bytes


** Section #14 '.debug_loc' (SHT_PROGBITS)
    Size   : 10224 bytes


** Section #15 '.debug_macinfo' (SHT_PROGBITS)
    Size   : 114048 bytes


** Section #16 '.debug_pubnames' (SHT_PROGBITS)
    Size   : 6254 bytes


** Section #17 '.symtab' (SHT_SYMTAB)
    Size   : 21040 bytes (alignment 4)
    String table #18 '.strtab'
    Last local symbol no. 480


** Section #18 '.strtab' (SHT_STRTAB)
    Size   : 19108 bytes


** Section #19 '.note' (SHT_NOTE)
    Size   : 52 bytes (alignment 4)


** Section #20 '.comment' (SHT_PROGBITS)
    Size   : 22064 bytes


** Section #21 '.shstrtab' (SHT_STRTAB)
    Size   : 276 bytes


address     size       variable name                            type
0x00207fb0  0x6c       overlay_sections                         array[3] of T_OVERLAY_SECTION

address     size       variable name                            type
0x002081dc  0x8        scenario_name                            array[8] of char

address     size       variable name                            type
0x002081d9  0x1        bas_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x002081da  0x1        dis_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x002081d1  0x1        gIoState                                 IoState

address     size       variable name                            type
0x002081d2  0x1        gPowerFlg                                _Bool

address     size       variable name                            type
0x002081d0  0x1        gPxpState                                PxpState

address     size       variable name                            type
0x00207fac  0x4        gTimeParaValue                           uint32_t

address     size       variable name                            type
0x002081db  0x1        g_pxp_immediate_alert_level              uint8_t

address     size       variable name                            type
0x00207fa8  0x1        g_pxp_linkloss_alert_level               uint8_t

address     size       variable name                            type
0x002081d4  0x1        gap_conn_state                           T_GAP_CONN_STATE

address     size       variable name                            type
0x002081d3  0x1        gap_dev_state                            T_GAP_DEV_STATE
0x002081d3  0x1(7:1)   gap_dev_state.gap_init_state             uint8_t
0x002081d3  0x1(6:1)   gap_dev_state.gap_adv_sub_state          uint8_t
0x002081d3  0x1(4:2)   gap_dev_state.gap_adv_state              uint8_t
0x002081d3  0x1(2:2)   gap_dev_state.gap_scan_state             uint8_t
0x002081d3  0x1(0:2)   gap_dev_state.gap_conn_state             uint8_t

address     size       variable name                            type
0x002081d5  0x1        ias_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x002081d8  0x1        kns_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x002081d6  0x1        lls_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x002081d7  0x1        tps_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x00207f91  0x15       adv_data                                 array[21] of uint8_t

address     size       variable name                            type
0x00207f82  0x1        allowedPxpEnterDlps                      _Bool

address     size       variable name                            type
0x00207f83  0xe        scan_rsp_data                            array[14] of uint8_t

address     size       variable name                            type
0x00810ef8  0x214      dis_attr_tbl                             array[19] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00000000  0x2        dis_attr_tbl_size                        const uint16_t

address     size       variable name                            type
0x0081110c  0xc        dis_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x0081110c  0x4        dis_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00811110  0x4        dis_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00811114  0x4        dis_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x002081a8  0x14       dis_firmware_rev                         array[20] of uint8_t

address     size       variable name                            type
0x00208150  0x1        dis_firmware_rev_len                     uint8_t

address     size       variable name                            type
0x00208194  0x14       dis_hardware_rev                         array[20] of uint8_t

address     size       variable name                            type
0x0020814f  0x1        dis_hardware_rev_len                     uint8_t

address     size       variable name                            type
0x00207f64  0x1e       dis_ieee_data_list                       array[30] of uint8_t

address     size       variable name                            type
0x00207f54  0x1        dis_ieee_data_list_len                   uint8_t

address     size       variable name                            type
0x00208158  0x14       dis_manufacturer_name                    array[20] of uint8_t

address     size       variable name                            type
0x0020814c  0x1        dis_manufacturer_name_len                uint8_t

address     size       variable name                            type
0x0020816c  0x14       dis_model_number                         array[20] of uint8_t

address     size       variable name                            type
0x0020814d  0x1        dis_model_number_len                     uint8_t

address     size       variable name                            type
0x00207f55  0x7        dis_pnp_id                               array[7] of uint8_t

address     size       variable name                            type
0x00208180  0x14       dis_serial_number                        array[20] of uint8_t

address     size       variable name                            type
0x0020814e  0x1        dis_serial_number_len                    uint8_t

address     size       variable name                            type
0x002081bc  0x14       dis_software_rev                         array[20] of uint8_t

address     size       variable name                            type
0x00208151  0x1        dis_software_rev_len                     uint8_t

address     size       variable name                            type
0x00207f5c  0x8        dis_system_id                            array[8] of uint8_t

address     size       variable name                            type
0x00208154  0x4        pfn_dis_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x00810e34  0x10       GATT_UUID128_KNS_SERVICE                 array[16] of const uint8_t

address     size       variable name                            type
0x00207f50  0x4        gParaValue                               uint32_t

address     size       variable name                            type
0x00810e44  0xa8       kns_attr_tbl                             array[6] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00000000  0x2        kns_attr_tbl_size                        const uint16_t

address     size       variable name                            type
0x00810eec  0xc        kns_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x00810eec  0x4        kns_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00810ef0  0x4        kns_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00810ef4  0x4        kns_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x00208148  0x4        pfn_kns_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x00810db8  0x70       bas_attr_tbl                             array[4] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00810e28  0xc        bas_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x00810e28  0x4        bas_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00810e2c  0x4        bas_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00810e30  0x4        bas_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x00208141  0x1        bas_read_battery_level_pending           _Bool

address     size       variable name                            type
0x00208140  0x1        battery_level                            uint8_t

address     size       variable name                            type
0x00208144  0x4        pfn_bas_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x0020813c  0x4        pfn_tps_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x00810d58  0x54       tps_attr_tbl                             array[3] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00810dac  0xc        tps_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x00810dac  0x4        tps_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00810db0  0x4        tps_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00810db4  0x4        tps_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x00208138  0x1        tx_power_value                           uint8_t

address     size       variable name                            type
0x00208130  0x1        lls_alert_level                          uint8_t

address     size       variable name                            type
0x00810cf8  0x54       lls_attr_tbl                             array[3] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00000000  0x4        lls_attr_tbl_size                        const int

address     size       variable name                            type
0x00810d4c  0xc        lls_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x00810d4c  0x4        lls_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00810d50  0x4        lls_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00810d54  0x4        lls_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x00208134  0x4        pfn_lls_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x00810c98  0x54       ias_attr_tbl                             array[3] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00000000  0x4        ias_attr_tbl_size                        const int

address     size       variable name                            type
0x00810cec  0xc        ias_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x00810cec  0x4        ias_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00810cf0  0x4        ias_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00810cf4  0x4        ias_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x0020812c  0x4        pfn_ias_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x0020805c  0x84       CPU_StoreReg                             array[33] of uint32_t

address     size       variable name                            type
0x00208108  0x24       GPIO_StoreReg                            array[9] of uint32_t

address     size       variable name                            type
0x00208050  0x4        PeriIntStoreReg                          uint32_t

address     size       variable name                            type
0x002080e0  0x28       Pinmux_StoreReg                          array[10] of uint32_t

address     size       variable name                            type
0x00208058  0x4        User_IO_EnterDlpsCB                      DLPS_IO_EnterDlpsCB

address     size       variable name                            type
0x00208054  0x4        User_IO_ExitDlpsCB                       DLPS_IO_ExitDlpsCB

address     size       variable name                            type
0x00208044  0x4        gActCnt                                  uint32_t

address     size       variable name                            type
0x00208038  0x1        gIoMode                                  uint8_t

address     size       variable name                            type
0x00208039  0x1        gKeyStatus                               KeyStatus

address     size       variable name                            type
0x0020803a  0x1        keystatus                                uint8_t

address     size       variable name                            type
0x00208040  0x4        xPeriodHigh                              uint32_t

address     size       variable name                            type
0x0020803c  0x4        xPeriodLow                               uint32_t

address     size       variable name                            type
0x0020804c  0x4        xTimerLongPress                          TimerHandle_t

address     size       variable name                            type
0x00208048  0x4        xTimerPxpIO                              TimerHandle_t

address     size       variable name                            type
0x0020802c  0x4        app_task_handle                          pointer to unknown Type 

address     size       variable name                            type
0x00208030  0x4        evt_queue_handle                         pointer to unknown Type 

address     size       variable name                            type
0x00208034  0x4        io_queue_handle                          pointer to unknown Type 

address     size       variable name                            type
0x00810b44  0x20       app_cb_table                             const T_APP_CB_TABLE
0x00810b44  0x4        app_cb_table.app_cb_signature            uint32_t
0x00810b48  0x4        app_cb_table.app_cb_numbers              uint32_t
0x00810b4c  0x18       app_cb_table.app_cb_addr                 array[6] of uint32_t

address     size       variable name                            type
0x00208024  0x4        app_pre_main_cb                          USER_CALL_BACK

address     size       variable name                            type
0x0080e1e0  0x220      auth_header                              const T_AUTH_HEADER_FORMAT
0x0080e1e0  0x100      auth_header.payload_signature            array[256] of uint8_t
0x0080e2e0  0x10       auth_header.payload_mac                  array[16] of uint8_t
0x0080e2f0  0x100      auth_header.header_signature             array[256] of uint8_t
0x0080e3f0  0x10       auth_header.header_mac                   array[16] of uint8_t

address     size       variable name                            type
0x00207f4c  0x4        check_reset_ram                          T_CHECK_RESET_RAM_RECORD
0x00207f4c  0x4(8:24)  check_reset_ram.check_reset_ram_pattern  uint32_t
0x00207f4c  0x4(0:8)   check_reset_ram.check_reset_ram_type     uint32_t

address     size       variable name                            type
0x0080e000  0x1e0      img_header                               const T_IMG_HEADER_FORMAT
0x0080e000  0xc        img_header.ctrl_header                   T_IMG_CTRL_HEADER_FORMAT
0x0080e000  0x1        img_header.ctrl_header.ic_type           uint8_t
0x0080e001  0x1        img_header.ctrl_header.secure_version    uint8_t
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag         anonymous
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag.value   uint16_t
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag.flag_value anonymous
0x0080e002  0x2(15:1)  img_header.ctrl_header.ctrl_flag.flag_value.xip uint16_t
0x0080e002  0x2(14:1)  img_header.ctrl_header.ctrl_flag.flag_value.enc uint16_t
0x0080e002  0x2(13:1)  img_header.ctrl_header.ctrl_flag.flag_value.load_when_boot uint16_t
0x0080e002  0x2(12:1)  img_header.ctrl_header.ctrl_flag.flag_value.enc_load uint16_t
0x0080e002  0x2(9:3)   img_header.ctrl_header.ctrl_flag.flag_value.enc_key_select uint16_t
0x0080e002  0x2(8:1)   img_header.ctrl_header.ctrl_flag.flag_value.not_ready uint16_t
0x0080e002  0x2(7:1)   img_header.ctrl_header.ctrl_flag.flag_value.not_obsolete uint16_t
0x0080e002  0x2(6:1)   img_header.ctrl_header.ctrl_flag.flag_value.integrity_check_en_in_boot uint16_t
0x0080e002  0x2(0:6)   img_header.ctrl_header.ctrl_flag.flag_value.rsvd uint16_t
0x0080e004  0x2        img_header.ctrl_header.image_id          uint16_t
0x0080e006  0x2        img_header.ctrl_header.crc16             uint16_t
0x0080e008  0x4        img_header.ctrl_header.payload_len       uint32_t
0x0080e00c  0x10       img_header.uuid                          array[16] of uint8_t
0x0080e01c  0x4        img_header.exe_base                      uint32_t
0x0080e020  0x4        img_header.load_base                     uint32_t
0x0080e024  0x4        img_header.load_len                      uint32_t
0x0080e028  0x4        img_header.img_base                      uint32_t
0x0080e02c  0x4        img_header.rsvd0                         array[4] of uint8_t
0x0080e030  0x4        img_header.magic_pattern                 uint32_t
0x0080e034  0x10       img_header.dec_key                       array[16] of uint8_t
0x0080e044  0x1c       img_header.rsvd1                         array[28] of uint8_t
0x0080e060  0x10       img_header.git_ver                       T_VERSION_FORMAT
0x0080e060  0x4        img_header.git_ver.ver_info              anonymous
0x0080e060  0x4        img_header.git_ver.ver_info.version      uint32_t
0x0080e060  0x4        img_header.git_ver.ver_info.sub_version  anonymous
0x0080e060  0x4(28:4)  img_header.git_ver.ver_info.sub_version._version_major uint32_t
0x0080e060  0x4(20:8)  img_header.git_ver.ver_info.sub_version._version_minor uint32_t
0x0080e060  0x4(5:15)  img_header.git_ver.ver_info.sub_version._version_revision uint32_t
0x0080e060  0x4(0:5)   img_header.git_ver.ver_info.sub_version._version_reserve uint32_t
0x0080e064  0x4        img_header.git_ver._version_commitid     uint32_t
0x0080e068  0x8        img_header.git_ver._customer_name        array[8] of uint8_t
0x0080e070  0x104      img_header.rsaPubKey                     T_RSA_PUBLIC_KEY
0x0080e070  0x100      img_header.rsaPubKey.N                   array[256] of uint8_t
0x0080e170  0x4        img_header.rsaPubKey.E                   array[4] of uint8_t
0x0080e174  0x20       img_header.sha256                        array[32] of uint8_t
0x0080e194  0x44       img_header.rsvd2                         array[68] of uint8_t
0x0080e1d8  0x4        img_header.app_cb_signature              uint32_t
0x0080e1dc  0x4        img_header.app_cb_table_base_address     uint32_t

address     size       variable name                            type
0x00208028  0x4        random_seed_value                        uint32_t

address     size       variable name                            type
0x00208020  0x4        user_dfu_status_cb                       BOOL_DFU_STATUS_CB

address     size       variable name                            type
0x0020801c  0x4        user_wdg_cb                              BOOL_WDG_CB


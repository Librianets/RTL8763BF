
========================================================================

** ELF Header Information

    File Name: W:\git\RTL8763BF\project\keilproject\Objects\rtp8763_demo.axf

    Machine class: ELFCLASS32 (32-bit)
    Data encoding: ELFDATA2LSB (Little endian)
    Header version: EV_CURRENT (Current version)
    Operating System ABI: none
    ABI Version: 0
    File Type: ET_EXEC (Executable) (2)
    Machine: EM_ARM (ARM)

    Image Entry point: 0x0080e409
    Flags: EF_ARM_HASENTRY + EF_ARM_ABI_FLOAT_HARD (0x05000402)

    ARM ELF revision: 5 (ABI version 2)

    Conforms to Hard float procedure-call standard

    Built with
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armasm [4d35cf]
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armlink [4d35d2]

    Header size: 52 bytes (0x34)
    Program header entry size: 32 bytes (0x20)
    Section header entry size: 40 bytes (0x28)

    Program header entries: 2
    Section header entries: 22

    Program header offset: 388340 (0x0005ecf4)
    Section header offset: 388404 (0x0005ed34)

    Section header string table index: 21

========================================================================

** Program header #0 (PT_LOAD) [PF_X + PF_W + PF_R + PF_ARM_ENTRY]
    Size : 14240 bytes (13796 bytes in file)
    Virtual address: 0x0080e000 (Alignment 4)


====================================

** Program header #1 (PT_LOAD) [PF_R]
    Size : 4228 bytes
    Virtual address: 0x08800000 (Alignment 4)


========================================================================

** Section #1 'app.bin' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 1024 bytes (alignment 4)
    Address: 0x0080e000

    0x80e000:   05 00 01 01 93 27 00 00 00 01 00 00 6d 67 de f1    .....'......mg..
    0x80e010:   3e 33 e8 11 b1 02 4d 2d f4 0c de 01 00 e4 80 00    >3....M-........
    0x80e020:   00 e4 80 00 00 00 00 00 00 e0 80 00 00 00 00 00    ................
    0x80e030:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e040:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e050:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e060:   01 20 00 00 a8 ac 83 2a 73 64 6b 23 23 23 23 23    . .....*sdk#####
    0x80e070:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e080:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e090:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e100:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e110:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e120:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e130:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e140:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e150:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e160:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e170:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e180:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e190:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1d0:   00 00 00 00 00 00 00 00 01 d1 85 0e bc 08 81 00    ................
    0x80e1e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e200:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e210:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e220:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e230:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e240:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e250:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e260:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e270:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e280:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e290:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2e0:   ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................
    0x80e2f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e300:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e310:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e320:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e330:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e340:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e350:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e360:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e370:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e380:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e390:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3f0:   ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................


** Section #2 'FLASH_START_ADDR' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 8 bytes (alignment 4)
    Address: 0x0080e400

    $t
    RESET
    $v0
    Reset_Handler
;;; ..\\include\\SDK\\src\\mcu\\rtl876x\\arm\\startup_rtl8762c.s
;;;96                     IMPORT SystemInit
;;;96                     LDR    R0, =SystemInit
        0x0080e400:    4800        .H      LDR      r0,[pc,#0] ; [0x80e404] = 0x80e527
;;;97                     BX     R0
        0x0080e402:    4700        .G      BX       r0
    $d
        0x0080e404:    0080e527    '...    DCD    8447271

** Section #3 'FLASH_TEXT' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 11520 bytes (alignment 4)
    Address: 0x0080e408

    $t
    !!!main
    __main
        0x0080e408:    f000f802    ....    BL       __scatterload ; 0x80e410
        0x0080e40c:    f000f83a    ..:.    BL       __rt_entry ; 0x80e484
    !!!scatter
    __scatterload
    __scatterload_rt2
    __scatterload_rt2_thumb_only
        0x0080e410:    a00a        ..      ADR      r0,{pc}+0x2c ; 0x80e43c
        0x0080e412:    e8900c00    ....    LDM      r0,{r10,r11}
        0x0080e416:    4482        .D      ADD      r10,r10,r0
        0x0080e418:    4483        .D      ADD      r11,r11,r0
        0x0080e41a:    f1aa0701    ....    SUB      r7,r10,#1
    __scatterload_null
        0x0080e41e:    45da        .E      CMP      r10,r11
        0x0080e420:    d101        ..      BNE      0x80e426 ; __scatterload_null + 8
        0x0080e422:    f000f82f    ../.    BL       __rt_entry ; 0x80e484
        0x0080e426:    f2af0e09    ....    ADR      lr,{pc}-7 ; 0x80e41f
        0x0080e42a:    e8ba000f    ....    LDM      r10!,{r0-r3}
        0x0080e42e:    f0130f01    ....    TST      r3,#1
        0x0080e432:    bf18        ..      IT       NE
        0x0080e434:    1afb        ..      SUBNE    r3,r7,r3
        0x0080e436:    f0430301    C...    ORR      r3,r3,#1
        0x0080e43a:    4718        .G      BX       r3
    $d
        0x0080e43c:    00002c8c    .,..    DCD    11404
        0x0080e440:    00002ccc    .,..    DCD    11468
    $t
    !!handler_copy
    __scatterload_copy
        0x0080e444:    3a10        .:      SUBS     r2,r2,#0x10
        0x0080e446:    bf24        $.      ITT      CS
        0x0080e448:    c878        x.      LDMCS    r0!,{r3-r6}
        0x0080e44a:    c178        x.      STMCS    r1!,{r3-r6}
        0x0080e44c:    d8fa        ..      BHI      __scatterload_copy ; 0x80e444
        0x0080e44e:    0752        R.      LSLS     r2,r2,#29
        0x0080e450:    bf24        $.      ITT      CS
        0x0080e452:    c830        0.      LDMCS    r0!,{r4,r5}
        0x0080e454:    c130        0.      STMCS    r1!,{r4,r5}
        0x0080e456:    bf44        D.      ITT      MI
        0x0080e458:    6804        .h      LDRMI    r4,[r0,#0]
        0x0080e45a:    600c        .`      STRMI    r4,[r1,#0]
        0x0080e45c:    4770        pG      BX       lr
        0x0080e45e:    0000        ..      MOVS     r0,r0
    !!handler_zi
    __scatterload_zeroinit
        0x0080e460:    2300        .#      MOVS     r3,#0
        0x0080e462:    2400        .$      MOVS     r4,#0
        0x0080e464:    2500        .%      MOVS     r5,#0
        0x0080e466:    2600        .&      MOVS     r6,#0
        0x0080e468:    3a10        .:      SUBS     r2,r2,#0x10
        0x0080e46a:    bf28        (.      IT       CS
        0x0080e46c:    c178        x.      STMCS    r1!,{r3-r6}
        0x0080e46e:    d8fb        ..      BHI      0x80e468 ; __scatterload_zeroinit + 8
        0x0080e470:    0752        R.      LSLS     r2,r2,#29
        0x0080e472:    bf28        (.      IT       CS
        0x0080e474:    c130        0.      STMCS    r1!,{r4,r5}
        0x0080e476:    bf48        H.      IT       MI
        0x0080e478:    600b        .`      STRMI    r3,[r1,#0]
        0x0080e47a:    4770        pG      BX       lr
    .ARM.Collect$$libinit$$00000000
    __rt_lib_init
        0x0080e47c:    b51f        ..      PUSH     {r0-r4,lr}
    .ARM.Collect$$libinit$$00000001
    __rt_lib_init_fp_1
        0x0080e47e:    f002fa17    ....    BL       _fp_init ; 0x8108b0
    .ARM.Collect$$libinit$$00000004
    .ARM.Collect$$libinit$$0000000A
    .ARM.Collect$$libinit$$0000000C
    .ARM.Collect$$libinit$$0000000E
    .ARM.Collect$$libinit$$00000011
    .ARM.Collect$$libinit$$00000013
    .ARM.Collect$$libinit$$00000015
    .ARM.Collect$$libinit$$00000017
    .ARM.Collect$$libinit$$00000019
    .ARM.Collect$$libinit$$0000001B
    .ARM.Collect$$libinit$$0000001D
    .ARM.Collect$$libinit$$0000001F
    .ARM.Collect$$libinit$$00000021
    .ARM.Collect$$libinit$$00000023
    .ARM.Collect$$libinit$$00000025
    .ARM.Collect$$libinit$$0000002C
    .ARM.Collect$$libinit$$0000002E
    .ARM.Collect$$libinit$$00000030
    .ARM.Collect$$libinit$$00000032
    .ARM.Collect$$libinit$$00000033
    __rt_lib_init_alloca_1
    __rt_lib_init_argv_1
    __rt_lib_init_atexit_1
    __rt_lib_init_clock_1
    __rt_lib_init_cpp_1
    __rt_lib_init_exceptions_1
    __rt_lib_init_fp_trap_1
    __rt_lib_init_getenv_1
    __rt_lib_init_heap_1
    __rt_lib_init_lc_collate_1
    __rt_lib_init_lc_ctype_1
    __rt_lib_init_lc_monetary_1
    __rt_lib_init_lc_numeric_1
    __rt_lib_init_lc_time_1
    __rt_lib_init_preinit_1
    __rt_lib_init_rand_1
    __rt_lib_init_return
    __rt_lib_init_signal_1
    __rt_lib_init_stdio_1
    __rt_lib_init_user_alloc_1
        0x0080e482:    bd1f        ..      POP      {r0-r4,pc}
    .ARM.Collect$$rtentry$$00000000
    .ARM.Collect$$rtentry$$00000002
    .ARM.Collect$$rtentry$$00000004
    __rt_entry
    __rt_entry_presh_1
    __rt_entry_sh
        0x0080e484:    f000f8da    ....    BL       __user_setup_stackheap ; 0x80e63c
        0x0080e488:    4611        .F      MOV      r1,r2
    .ARM.Collect$$rtentry$$00000009
    .ARM.Collect$$rtentry$$0000000A
    __rt_entry_li
    __rt_entry_postsh_1
        0x0080e48a:    f7fffff7    ....    BL       __rt_lib_init ; 0x80e47c
    .ARM.Collect$$rtentry$$0000000C
    .ARM.Collect$$rtentry$$0000000D
    __rt_entry_main
    __rt_entry_postli_1
        0x0080e48e:    f001fca3    ....    BL       main ; 0x80fdd8
        0x0080e492:    f44cf4c7    L...    BL       exit ; 0x5ae24
        0x0080e496:    0000        ..      MOVS     r0,r0
    .app.flash.text
    debug_monitor_enable
;;;1734           SCB->SHP[((uint32_t)(IRQn) & 0xF) - 4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);
        0x0080e498:    4945        EI      LDR      r1,[pc,#276] ; [0x80e5b0] = 0xe000e00c
        0x0080e49a:    2060        `       MOVS     r0,#0x60
        0x0080e49c:    f8810d14    ....    STRB     r0,[r1,#0xd14]
;;; .\..\include\SDK\src\mcu\rtl876x\system_rtl8762c.c
;;;298        CoreDebug->DEMCR |= CoreDebug_DEMCR_MON_EN_Msk | CoreDebug_DEMCR_TRCENA_Msk;
        0x0080e4a0:    4844        DH      LDR      r0,[pc,#272] ; [0x80e5b4] = 0xe000edfc
        0x0080e4a2:    6801        .h      LDR      r1,[r0,#0]
        0x0080e4a4:    4a44        DJ      LDR      r2,[pc,#272] ; [0x80e5b8] = 0x1010000
        0x0080e4a6:    4311        .C      ORRS     r1,r1,r2
        0x0080e4a8:    6001        .`      STR      r1,[r0,#0]
;;;299    
;;;300        //set DWT compare registers (max 4 comparators)
;;;301        //watch_point_0_setting(0x1000180C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_WRITE);
;;;302        //watch_point_1_setting(0x10000004, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;303        //watch_point_2_setting(0x10000008, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;304        //watch_point_3_setting(0x1000000C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;305    
;;;306        //enable DWT control register
;;;307        DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
        0x0080e4aa:    4844        DH      LDR      r0,[pc,#272] ; [0x80e5bc] = 0xe0001000
        0x0080e4ac:    6801        .h      LDR      r1,[r0,#0]
        0x0080e4ae:    f0410101    A...    ORR      r1,r1,#1
        0x0080e4b2:    6001        .`      STR      r1,[r0,#0]
;;;308    
;;;309        return;
;;;310    }
        0x0080e4b4:    4770        pG      BX       lr
    ram_init
;;;311    
;;;312    APP_FLASH_TEXT_SECTION
;;;313    void ram_init(void)
;;;314    {
        0x0080e4b6:    b510        ..      PUSH     {r4,lr}
;;;315        //copy data on ro
;;;316        extern char Image$$RAM_DATA_ON$$RO$$Base[];
;;;317        extern char Load$$RAM_DATA_ON$$RO$$Base[];
;;;318        extern unsigned int Image$$RAM_DATA_ON$$RO$$Length;
;;;319    
;;;320        memcpy(Image$$RAM_DATA_ON$$RO$$Base,
        0x0080e4b8:    4a41        AJ      LDR      r2,[pc,#260] ; [0x80e5c0] = 0x25c
        0x0080e4ba:    4942        BI      LDR      r1,[pc,#264] ; [0x80e5c4] = 0x8111fc
        0x0080e4bc:    4842        BH      LDR      r0,[pc,#264] ; [0x80e5c8] = 0x207c00
        0x0080e4be:    f44bf4ec    K...    BL       __aeabi_memcpy ; 0x59e9a
;;;321               Load$$RAM_DATA_ON$$RO$$Base,
;;;322               (unsigned int)&Image$$RAM_DATA_ON$$RO$$Length);
;;;323    
;;;324        //copy data on rw
;;;325        extern char Image$$RAM_DATA_ON$$RW$$Base[];
;;;326        extern char Load$$RAM_DATA_ON$$RW$$Base[];
;;;327        extern unsigned int Image$$RAM_DATA_ON$$RW$$Length;
;;;328    
;;;329        memcpy(Image$$RAM_DATA_ON$$RW$$Base,
        0x0080e4c2:    4a42        BJ      LDR      r2,[pc,#264] ; [0x80e5cc] = 0xcc
        0x0080e4c4:    4942        BI      LDR      r1,[pc,#264] ; [0x80e5d0] = 0x811458
        0x0080e4c6:    4843        CH      LDR      r0,[pc,#268] ; [0x80e5d4] = 0x207e5c
        0x0080e4c8:    f44bf4e7    K...    BL       __aeabi_memcpy ; 0x59e9a
;;;330               Load$$RAM_DATA_ON$$RW$$Base,
;;;331               (unsigned int)&Image$$RAM_DATA_ON$$RW$$Length);
;;;332    
;;;333        //clear data on zi
;;;334        extern char Image$$RAM_DATA_ON$$ZI$$Base[];
;;;335        extern unsigned int Image$$RAM_DATA_ON$$ZI$$Length;
;;;336    
;;;337        memset(Image$$RAM_DATA_ON$$ZI$$Base,
        0x0080e4cc:    4942        BI      LDR      r1,[pc,#264] ; [0x80e5d8] = 0x1bc
        0x0080e4ce:    4843        CH      LDR      r0,[pc,#268] ; [0x80e5dc] = 0x207f28
        0x0080e4d0:    f44bf5a4    K...    BL       __aeabi_memclr ; 0x5a01c
;;;338               0,
;;;339               (unsigned int)&Image$$RAM_DATA_ON$$ZI$$Length);
;;;340    
;;;341        //copy cache ro
;;;342        extern char Image$$CACHE_DATA_ON$$RO$$Base[];
;;;343        extern char Load$$CACHE_DATA_ON$$RO$$Base[];
;;;344        extern unsigned int Image$$CACHE_DATA_ON$$RO$$Length;
;;;345    
;;;346        memcpy(Image$$CACHE_DATA_ON$$RO$$Base,
        0x0080e4d4:    e8bd4010    ...@    POP      {r4,lr}
        0x0080e4d8:    4a41        AJ      LDR      r2,[pc,#260] ; [0x80e5e0] = 0
        0x0080e4da:    4942        BI      LDR      r1,[pc,#264] ; [0x80e5e4] = 0x8115e4
        0x0080e4dc:    4842        BH      LDR      r0,[pc,#264] ; [0x80e5e8] = 0x21c000
        0x0080e4de:    f44bb4dc    K...    B        __aeabi_memcpy ; 0x59e9a
    pre_main
;;;347               Load$$CACHE_DATA_ON$$RO$$Base,
;;;348               (unsigned int)&Image$$CACHE_DATA_ON$$RO$$Length);
;;;349    }
;;;350    
;;;351    APP_FLASH_TEXT_SECTION
;;;352    void SystemInit(void)
;;;353    {
;;;354        //init pre_main and main functions
;;;355        extern void pre_main(void);
;;;356        app_pre_main = (APP_MAIN_FUNC)pre_main;
;;;357        app_main = (APP_MAIN_FUNC)common_main;
;;;358    
;;;359        /******** update otp here**********/
;;;360        //ram config
;;;361        OTP->appDataSize = APP_GLOBAL_SIZE;
;;;362        OTP->heapDataONSize = HEAP_DATA_ON_SIZE;
;;;363        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;364    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;365        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
;;;366    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;367        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;368    #else
;;;369        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;370    #endif
;;;371    
;;;372    
;;;373        //flash config
;;;374        /*config enable flash block proect depending on flash layout and flash id*/
;;;375    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;376        OTP->bp_enable = 1;
;;;377    #else
;;;378        OTP->bp_enable = 0;
;;;379    #endif
;;;380        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
;;;381    
;;;382    
;;;383        //os config
;;;384        /*config enable check task stack overflow*/
;;;385    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;386        OTP->checkForStackOverflow = 1;
;;;387    #else
;;;388        OTP->checkForStackOverflow = 0;
;;;389    #endif
;;;390    
;;;391    
;;;392        //platform config
;;;393        /*config enable platform assert*/
;;;394    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;395        OTP->enableASSERT = 1;
;;;396    #else
;;;397        OTP->enableASSERT = 0;
;;;398    #endif
;;;399    
;;;400        /*Print all log in log buffer before entering DLPS */
;;;401    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;402        OTP->printAllLogBeforeEnterDLPS = 1;
;;;403    #else
;;;404        OTP->printAllLogBeforeEnterDLPS = 0;
;;;405    #endif
;;;406    
;;;407        /*config enable log or not*/
;;;408    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;409        OTP->logDisable = 0;
;;;410    #else
;;;411        OTP->logDisable = 1;
;;;412    #endif
;;;413    
;;;414        /*config enable swd pinmux*/
;;;415    #if (SWD_PINMUX_ENABLE == 1)
;;;416        OTP->SWD_ENABLE = 1;
;;;417    #else
;;;418        OTP->SWD_ENABLE = 0;
;;;419    #endif
;;;420    
;;;421        /*config enable watch dog in rom*/
;;;422    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;423        OTP->wdgEnableInRom = 1;
;;;424    #else
;;;425        OTP->wdgEnableInRom = 0;
;;;426    #endif
;;;427    
;;;428        /*config watch dog mode in rom, defualt reset all*/
;;;429        OTP->wdgMode = ROM_WATCH_DOG_MODE;
;;;430    
;;;431    
;;;432        //app config
;;;433        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
;;;434        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
;;;435        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
;;;436        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
;;;437    
;;;438        /*config bt stack parameters in rom*/
;;;439    #ifdef BT_STACK_CONFIG_ENABLE
;;;440        bt_stack_config_init();
;;;441    #endif
;;;442    
;;;443    //add more otp config here
;;;444    }
;;;445    
;;;446    APP_FLASH_TEXT_SECTION
;;;447    void pre_main(void)
;;;448    {
        0x0080e4e2:    b538        8.      PUSH     {r3-r5,lr}
;;;449        __disable_irq();
        0x0080e4e4:    b672        r.      CPSID    i
;;;450    
;;;451        ram_init();
        0x0080e4e6:    f7ffffe6    ....    BL       ram_init ; 0x80e4b6
;;;452    
;;;453        load_overlay(OVERLAY_SCENARIO_BOOT_ONCE);
        0x0080e4ea:    2000        .       MOVS     r0,#0
        0x0080e4ec:    f002f89c    ....    BL       load_overlay ; 0x810628
;;;454    
;;;455        setlocale(LC_ALL, "C");
        0x0080e4f0:    a13e        >.      ADR      r1,{pc}+0xfc ; 0x80e5ec
        0x0080e4f2:    201f        .       MOVS     r0,#0x1f
        0x0080e4f4:    f44bf47e    K.~.    BL       setlocale ; 0x59df4
;;;456    
;;;457        BOOT_PRINT_ERROR2("SDK Ver: %s, Build Time: %s",
        0x0080e4f8:    f04f5505    O..U    MOV      r5,#0x21400000
        0x0080e4fc:    a13c        <.      ADR      r1,{pc}+0xf4 ; 0x80e5f0
        0x0080e4fe:    4628        (F      MOV      r0,r5
        0x0080e500:    f7f9dcb3    ....    BL       trace_string ; 0x7e6a
        0x0080e504:    4604        .F      MOV      r4,r0
        0x0080e506:    a141        A.      ADR      r1,{pc}+0x106 ; 0x80e60c
        0x0080e508:    4628        (F      MOV      r0,r5
        0x0080e50a:    f7f9dcae    ....    BL       trace_string ; 0x7e6a
        0x0080e50e:    4603        .F      MOV      r3,r0
        0x0080e510:    2202        ."      MOVS     r2,#2
        0x0080e512:    4940        @I      LDR      r1,[pc,#256] ; [0x80e614] = 0x8800000
        0x0080e514:    4840        @H      LDR      r0,[pc,#256] ; [0x80e618] = 0x21100300
        0x0080e516:    9400        ..      STR      r4,[sp,#0]
        0x0080e518:    f7f9daa1    ....    BL       log_buffer ; 0x7a5e
;;;458                          TRACE_STRING(VERSION_BUILD_STR),
;;;459                          TRACE_STRING(BUILDING_TIME));
;;;460    
;;;461        AppUpdateVectorTable();
        0x0080e51c:    f5f9f5e2    ....    BL       AppUpdateVectorTable ; 0x2080e4
;;;462    
;;;463        debug_monitor_enable();
        0x0080e520:    e8bd4038    ..8@    POP      {r3-r5,lr}
        0x0080e524:    e7b8        ..      B        debug_monitor_enable ; 0x80e498
    SystemInit
;;; .\..\include\SDK\src\mcu\rtl876x\system_rtl8762c.c (356)
        0x0080e526:    f2af0045    ..E.    ADR      r0,{pc}-0x43 ; 0x80e4e3
        0x0080e52a:    493c        <I      LDR      r1,[pc,#240] ; [0x80e61c] = 0x200c38
;;;357        app_main = (APP_MAIN_FUNC)common_main;
        0x0080e52c:    6008        .`      STR      r0,[r1,#0]
        0x0080e52e:    493d        =I      LDR      r1,[pc,#244] ; [0x80e624] = 0x200c3c
        0x0080e530:    483b        ;H      LDR      r0,[pc,#236] ; [0x80e620] = 0x80e67d
;;;358    
;;;359        /******** update otp here**********/
;;;360        //ram config
;;;361        OTP->appDataSize = APP_GLOBAL_SIZE;
        0x0080e532:    6008        .`      STR      r0,[r1,#0]
        0x0080e534:    f44f1000    O...    MOV      r0,#0x200000
        0x0080e538:    f44f410c    O..A    MOV      r1,#0x8c00
;;;362        OTP->heapDataONSize = HEAP_DATA_ON_SIZE;
        0x0080e53c:    f8c01384    ....    STR      r1,[r0,#0x384]
        0x0080e540:    f44f41f0    O..A    MOV      r1,#0x7800
;;;363        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;364    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;365        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
        0x0080e544:    f8c01388    ....    STR      r1,[r0,#0x388]
        0x0080e548:    4937        7I      LDR      r1,[pc,#220] ; [0x80e628] = 0xa2aa0003
;;;366    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;367        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;368    #else
;;;369        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;370    #endif
;;;371    
;;;372    
;;;373        //flash config
;;;374        /*config enable flash block proect depending on flash layout and flash id*/
;;;375    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;376        OTP->bp_enable = 1;
;;;377    #else
;;;378        OTP->bp_enable = 0;
        0x0080e54a:    f8c013cc    ....    STR      r1,[r0,#0x3cc]
        0x0080e54e:    f890134d    ..M.    LDRB     r1,[r0,#0x34d]
        0x0080e552:    f0210108    !...    BIC      r1,r1,#8
        0x0080e556:    f880134d    ..M.    STRB     r1,[r0,#0x34d]
;;;379    #endif
;;;380        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
        0x0080e55a:    2106        .!      MOVS     r1,#6
        0x0080e55c:    f880134f    ..O.    STRB     r1,[r0,#0x34f]
;;;381    
;;;382    
;;;383        //os config
;;;384        /*config enable check task stack overflow*/
;;;385    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;386        OTP->checkForStackOverflow = 1;
        0x0080e560:    f8901378    ..x.    LDRB     r1,[r0,#0x378]
;;;387    #else
;;;388        OTP->checkForStackOverflow = 0;
;;;389    #endif
;;;390    
;;;391    
;;;392        //platform config
;;;393        /*config enable platform assert*/
;;;394    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;395        OTP->enableASSERT = 1;
;;;396    #else
;;;397        OTP->enableASSERT = 0;
;;;398    #endif
;;;399    
;;;400        /*Print all log in log buffer before entering DLPS */
;;;401    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;402        OTP->printAllLogBeforeEnterDLPS = 1;
        0x0080e564:    f0410126    A.&.    ORR      r1,r1,#0x26
        0x0080e568:    f8801378    ..x.    STRB     r1,[r0,#0x378]
;;;403    #else
;;;404        OTP->printAllLogBeforeEnterDLPS = 0;
;;;405    #endif
;;;406    
;;;407        /*config enable log or not*/
;;;408    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;409        OTP->logDisable = 0;
        0x0080e56c:    f890139a    ....    LDRB     r1,[r0,#0x39a]
        0x0080e570:    f0210101    !...    BIC      r1,r1,#1
        0x0080e574:    f880139a    ....    STRB     r1,[r0,#0x39a]
;;;410    #else
;;;411        OTP->logDisable = 1;
;;;412    #endif
;;;413    
;;;414        /*config enable swd pinmux*/
;;;415    #if (SWD_PINMUX_ENABLE == 1)
;;;416        OTP->SWD_ENABLE = 1;
        0x0080e578:    f8901334    ..4.    LDRB     r1,[r0,#0x334]
        0x0080e57c:    f0410101    A...    ORR      r1,r1,#1
        0x0080e580:    f8801334    ..4.    STRB     r1,[r0,#0x334]
;;;417    #else
;;;418        OTP->SWD_ENABLE = 0;
;;;419    #endif
;;;420    
;;;421        /*config enable watch dog in rom*/
;;;422    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;423        OTP->wdgEnableInRom = 1;
;;;424    #else
;;;425        OTP->wdgEnableInRom = 0;
        0x0080e584:    f890137a    ..z.    LDRB     r1,[r0,#0x37a]
        0x0080e588:    f0210110    !...    BIC      r1,r1,#0x10
;;;426    #endif
;;;427    
;;;428        /*config watch dog mode in rom, defualt reset all*/
;;;429        OTP->wdgMode = ROM_WATCH_DOG_MODE;
        0x0080e58c:    f04101c0    A...    ORR      r1,r1,#0xc0
        0x0080e590:    f880137a    ..z.    STRB     r1,[r0,#0x37a]
;;;430    
;;;431    
;;;432        //app config
;;;433        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
        0x0080e594:    21b4        .!      MOVS     r1,#0xb4
        0x0080e596:    f8801320    .. .    STRB     r1,[r0,#0x320]
;;;434        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
        0x0080e59a:    213c        <!      MOVS     r1,#0x3c
        0x0080e59c:    f8801321    ..!.    STRB     r1,[r0,#0x321]
;;;435        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
        0x0080e5a0:    2164        d!      MOVS     r1,#0x64
        0x0080e5a2:    f8801322    ..".    STRB     r1,[r0,#0x322]
;;;436        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
        0x0080e5a6:    21ff        .!      MOVS     r1,#0xff
        0x0080e5a8:    f8801323    ..#.    STRB     r1,[r0,#0x323]
;;;437    
;;;438        /*config bt stack parameters in rom*/
;;;439    #ifdef BT_STACK_CONFIG_ENABLE
;;;440        bt_stack_config_init();
;;;441    #endif
;;;442    
;;;443    //add more otp config here
;;;444    }
        0x0080e5ac:    4770        pG      BX       lr
    $d
        0x0080e5ae:    0000        ..      DCW    0
        0x0080e5b0:    e000e00c    ....    DCD    3758153740
        0x0080e5b4:    e000edfc    ....    DCD    3758157308
        0x0080e5b8:    01010000    ....    DCD    16842752
        0x0080e5bc:    e0001000    ....    DCD    3758100480
        0x0080e5c0:    0000025c    \...    DCD    604
        0x0080e5c4:    008111fc    ....    DCD    8458748
        0x0080e5c8:    00207c00    .| .    DCD    2128896
        0x0080e5cc:    000000cc    ....    DCD    204
        0x0080e5d0:    00811458    X...    DCD    8459352
        0x0080e5d4:    00207e5c    \~ .    DCD    2129500
        0x0080e5d8:    000001bc    ....    DCD    444
        0x0080e5dc:    00207f28    (. .    DCD    2129704
        0x0080e5e0:    00000000    ....    DCD    0
        0x0080e5e4:    008115e4    ....    DCD    8459748
        0x0080e5e8:    0021c000    ..!.    DCD    2211840
        0x0080e5ec:    00000043    C...    DCD    67
        0x0080e5f0:    20697246    Fri     DCD    543781446
        0x0080e5f4:    20706553    Sep     DCD    544236883
        0x0080e5f8:    31203132    21 1    DCD    824193330
        0x0080e5fc:    31303a33    3:01    DCD    825244211
        0x0080e600:    2037313a    :17     DCD    540487994
        0x0080e604:    38313032    2018    DCD    942747698
        0x0080e608:    00000000    ....    DCD    0
        0x0080e60c:    2e302e31    1.0.    DCD    774909489
        0x0080e610:    00302e32    2.0.    DCD    3157554
        0x0080e614:    08800000    ....    DCD    142606336
        0x0080e618:    21100300    ...!    DCD    554697472
        0x0080e61c:    00200c38    8. .    DCD    2100280
        0x0080e620:    0080e67d    }...    DCD    8447613
        0x0080e624:    00200c3c    <. .    DCD    2100284
        0x0080e628:    a2aa0003    ....    DCD    2729050115
    $t
    .text
    $v0
    ADC_Handler
    BTMAC_Handler
    BusFault_Handler
    DebugMon_Handler
    Default_Handler
    GDMA0_Channel0_Handler
    GDMA0_Channel1_Handler
    GDMA0_Channel2_Handler
    GDMA0_Channel3_Handler
    GDMA0_Channel4_Handler
    GDMA0_Channel5_Handler
    GPIO0_Handler
    GPIO10_Handler
    GPIO11_Handler
    GPIO12_Handler
    GPIO13_Handler
    GPIO14_Handler
    GPIO15_Handler
    GPIO16_Handler
    GPIO17_Handler
    GPIO18_Handler
    GPIO19_Handler
    GPIO1_Handler
    GPIO21_Handler
    GPIO22_Handler
    GPIO23_Handler
    GPIO24_Handler
    GPIO25_Handler
    GPIO26_Handler
    GPIO27_Handler
    GPIO28_Handler
    GPIO29_Handler
    GPIO2_Handler
    GPIO30_Handler
    GPIO31_Handler
    GPIO3_Handler
    GPIO4_Handler
    GPIO5_Handler
    GPIO6_Handler
    GPIO7_Handler
    GPIO8_Handler
    GPIO9_Handler
    HardFault_Handler
    I2C0_Handler
    I2C1_Handler
    I2S0_RX_Handler
    I2S0_TX_Handler
    I2S1_RX_Handler
    I2S1_TX_Handler
    IR_Handler
    Keyscan_Handler
    LCD_Handler
    LPCOMP_Handler
    MemManage_Handler
    NMI_Handler
    PTA_Mailbox_Handler
    PendSV_Handler
    Peripheral_Handler
    Qdecode_Handler
    RTC_Handler
    SPI0_Handler
    SPI1_Handler
    SPI2W_Handler
    SPI_Flash_Handler
    SVC_Handler
    SysTick_Handler
    Timer2_Handler
    Timer3_Handler
    Timer4_7_Handler
    Timer4_Handler
    Timer5_Handler
    Timer6_Handler
    Timer7_Handler
    UART0_Handler
    UART1_Handler
    UART2_Handler
    UsageFault_Handler
    WDG_Handler
;;; ..\\include\\SDK\\src\\mcu\\rtl876x\\arm\\startup_rtl8762c.s
;;;276                    LDR    R0, =0x20000000
        0x0080e62c:    f04f5000    O..P    MOV      r0,#0x20000000
;;;277                    LDR    R1, =DEFAULT_HANDLER_TXT
        0x0080e630:    4910        .I      LDR      r1,[pc,#64] ; [0x80e674] = 0x80e63e
;;;278                    MRS    R2, IPSR
        0x0080e632:    f3ef8205    ....    MRS      r2,IPSR
;;;279                    LDR    R3, =log_direct
        0x0080e636:    4b10        .K      LDR      r3,[pc,#64] ; [0x80e678] = 0x79b1
;;;280                    BLX    R3
        0x0080e638:    4798        .G      BLX      r3
;;;281                    B      .
        0x0080e63a:    e7fe        ..      B        0x80e63a ; ADC_Handler + 14
    __user_setup_stackheap
;;;282    
;;;283                    ENDP
;;;284    
;;;285    
;;;286    ; User Initial Stack
;;;287                    EXPORT  __user_setup_stackheap
;;;288    __user_setup_stackheap PROC
;;;289                    BX      LR
        0x0080e63c:    4770        pG      BX       lr
    $d
    DEFAULT_HANDLER_TXT
        0x0080e63e:    7245        Er      DCW    29253
        0x0080e640:    21726f72    ror!    DCD    561147762
        0x0080e644:    656c5020     Ple    DCD    1701597216
        0x0080e648:    20657361    ase     DCD    543519585
        0x0080e64c:    6c706d69    impl    DCD    1819307369
        0x0080e650:    6e656d65    emen    DCD    1852140901
        0x0080e654:    6f792074    t yo    DCD    1870209140
        0x0080e658:    49207275    ur I    DCD    1226863221
        0x0080e65c:    48205253    SR H    DCD    1210077779
        0x0080e660:    6c646e61    andl    DCD    1818521185
        0x0080e664:    66207265    er f    DCD    1713402469
        0x0080e668:    4920726f    or I    DCD    1226863215
        0x0080e66c:    25205152    RQ %    DCD    622874962
        0x0080e670:    000a2164    d!..    DCD    663908
        0x0080e674:    0080e63e    >...    DCD    8447550
        0x0080e678:    000079b1    .y..    DCD    31153
    $t
    .text
    common_main
;;; .\..\include\SDK\src\mcu\rtl876x\system_rtl8762c.c
;;;253    {
        0x0080e67c:    b510        ..      PUSH     {r4,lr}
;;;254    //add common system code here before enter user defined main function
;;;255        OTP->run_in_app = 1;
        0x0080e67e:    f44f1000    O...    MOV      r0,#0x200000
        0x0080e682:    f890139b    ....    LDRB     r1,[r0,#0x39b]
        0x0080e686:    f0410180    A...    ORR      r1,r1,#0x80
        0x0080e68a:    f880139b    ....    STRB     r1,[r0,#0x39b]
;;;256    
;;;257    #if (RUN_APP_IN_HCIMODE_ENABLE == 0)
;;;258        if (OTP->stack_en)
        0x0080e68e:    f89002dc    ....    LDRB     r0,[r0,#0x2dc]
        0x0080e692:    07c1        ..      LSLS     r1,r0,#31
;;;259        {
;;;260            DBG_DIRECT("In SoC Mode");
        0x0080e694:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0080e698:    d003        ..      BEQ      0x80e6a2 ; common_main + 38
        0x0080e69a:    a119        ..      ADR      r1,{pc}+0x66 ; 0x80e700
        0x0080e69c:    f7f9d988    ....    BL       log_direct ; 0x79b0
        0x0080e6a0:    e006        ..      B        0x80e6b0 ; common_main + 52
;;;261        }
;;;262        else
;;;263        {
;;;264            DBG_DIRECT("WARNING: In HCI Mode, will not run APP Task");
        0x0080e6a2:    a11a        ..      ADR      r1,{pc}+0x6a ; 0x80e70c
        0x0080e6a4:    f7f9d984    ....    BL       log_direct ; 0x79b0
;;;265    		WDG_Disable();
        0x0080e6a8:    f403f14b    ..K.    BL       WDG_Disable ; 0x11942
;;;266            os_sched_start();
        0x0080e6ac:    f418f089    ....    BL       os_sched_start ; 0x267c2
;;;267        }
;;;268    #endif
;;;269    
;;;270    #if (DEBUG_TASK_HANG_ENABLE == 1)
;;;271        extern void DebugTaskHang(void);  //defined in debug_platform.c
;;;272        DebugTaskHang();
;;;273    #endif
;;;274    
;;;275    #if (DEBUG_DLPS_ERROR_IN_APP_ENABLE == 1)
;;;276        void dlps_debug_swtimer_init(void);  //defined in debug_platform.c
;;;277        dlps_debug_swtimer_init();
;;;278    #endif
;;;279    
;;;280        extern int main(void);
;;;281        main();
        0x0080e6b0:    e8bd4010    ...@    POP      {r4,lr}
        0x0080e6b4:    f001bb90    ....    B.W      main ; 0x80fdd8
    WDG_SystemReset
;;;282    }
;;;283    /**
;;;284     * @brief  Enable Debug Monitor Function (include NVIC Enable and DWT configuration)
;;;285     * @param  none
;;;286     * @return none
;;;287     */
;;;288    
;;;289    APP_FLASH_TEXT_SECTION
;;;290    void debug_monitor_enable(void)
;;;291    {
;;;292        //DBG_DIRECT("debug_monitor_enable");
;;;293    
;;;294        //set debug monitor priority
;;;295        NVIC_SetPriority(DebugMonitor_IRQn, 3);
;;;296    
;;;297        //enable exception and monitor control register
;;;298        CoreDebug->DEMCR |= CoreDebug_DEMCR_MON_EN_Msk | CoreDebug_DEMCR_TRCENA_Msk;
;;;299    
;;;300        //set DWT compare registers (max 4 comparators)
;;;301        //watch_point_0_setting(0x1000180C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_WRITE);
;;;302        //watch_point_1_setting(0x10000004, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;303        //watch_point_2_setting(0x10000008, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;304        //watch_point_3_setting(0x1000000C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;305    
;;;306        //enable DWT control register
;;;307        DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
;;;308    
;;;309        return;
;;;310    }
;;;311    
;;;312    APP_FLASH_TEXT_SECTION
;;;313    void ram_init(void)
;;;314    {
;;;315        //copy data on ro
;;;316        extern char Image$$RAM_DATA_ON$$RO$$Base[];
;;;317        extern char Load$$RAM_DATA_ON$$RO$$Base[];
;;;318        extern unsigned int Image$$RAM_DATA_ON$$RO$$Length;
;;;319    
;;;320        memcpy(Image$$RAM_DATA_ON$$RO$$Base,
;;;321               Load$$RAM_DATA_ON$$RO$$Base,
;;;322               (unsigned int)&Image$$RAM_DATA_ON$$RO$$Length);
;;;323    
;;;324        //copy data on rw
;;;325        extern char Image$$RAM_DATA_ON$$RW$$Base[];
;;;326        extern char Load$$RAM_DATA_ON$$RW$$Base[];
;;;327        extern unsigned int Image$$RAM_DATA_ON$$RW$$Length;
;;;328    
;;;329        memcpy(Image$$RAM_DATA_ON$$RW$$Base,
;;;330               Load$$RAM_DATA_ON$$RW$$Base,
;;;331               (unsigned int)&Image$$RAM_DATA_ON$$RW$$Length);
;;;332    
;;;333        //clear data on zi
;;;334        extern char Image$$RAM_DATA_ON$$ZI$$Base[];
;;;335        extern unsigned int Image$$RAM_DATA_ON$$ZI$$Length;
;;;336    
;;;337        memset(Image$$RAM_DATA_ON$$ZI$$Base,
;;;338               0,
;;;339               (unsigned int)&Image$$RAM_DATA_ON$$ZI$$Length);
;;;340    
;;;341        //copy cache ro
;;;342        extern char Image$$CACHE_DATA_ON$$RO$$Base[];
;;;343        extern char Load$$CACHE_DATA_ON$$RO$$Base[];
;;;344        extern unsigned int Image$$CACHE_DATA_ON$$RO$$Length;
;;;345    
;;;346        memcpy(Image$$CACHE_DATA_ON$$RO$$Base,
;;;347               Load$$CACHE_DATA_ON$$RO$$Base,
;;;348               (unsigned int)&Image$$CACHE_DATA_ON$$RO$$Length);
;;;349    }
;;;350    
;;;351    APP_FLASH_TEXT_SECTION
;;;352    void SystemInit(void)
;;;353    {
;;;354        //init pre_main and main functions
;;;355        extern void pre_main(void);
;;;356        app_pre_main = (APP_MAIN_FUNC)pre_main;
;;;357        app_main = (APP_MAIN_FUNC)common_main;
;;;358    
;;;359        /******** update otp here**********/
;;;360        //ram config
;;;361        OTP->appDataSize = APP_GLOBAL_SIZE;
;;;362        OTP->heapDataONSize = HEAP_DATA_ON_SIZE;
;;;363        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;364    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;365        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
;;;366    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;367        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;368    #else
;;;369        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;370    #endif
;;;371    
;;;372    
;;;373        //flash config
;;;374        /*config enable flash block proect depending on flash layout and flash id*/
;;;375    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;376        OTP->bp_enable = 1;
;;;377    #else
;;;378        OTP->bp_enable = 0;
;;;379    #endif
;;;380        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
;;;381    
;;;382    
;;;383        //os config
;;;384        /*config enable check task stack overflow*/
;;;385    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;386        OTP->checkForStackOverflow = 1;
;;;387    #else
;;;388        OTP->checkForStackOverflow = 0;
;;;389    #endif
;;;390    
;;;391    
;;;392        //platform config
;;;393        /*config enable platform assert*/
;;;394    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;395        OTP->enableASSERT = 1;
;;;396    #else
;;;397        OTP->enableASSERT = 0;
;;;398    #endif
;;;399    
;;;400        /*Print all log in log buffer before entering DLPS */
;;;401    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;402        OTP->printAllLogBeforeEnterDLPS = 1;
;;;403    #else
;;;404        OTP->printAllLogBeforeEnterDLPS = 0;
;;;405    #endif
;;;406    
;;;407        /*config enable log or not*/
;;;408    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;409        OTP->logDisable = 0;
;;;410    #else
;;;411        OTP->logDisable = 1;
;;;412    #endif
;;;413    
;;;414        /*config enable swd pinmux*/
;;;415    #if (SWD_PINMUX_ENABLE == 1)
;;;416        OTP->SWD_ENABLE = 1;
;;;417    #else
;;;418        OTP->SWD_ENABLE = 0;
;;;419    #endif
;;;420    
;;;421        /*config enable watch dog in rom*/
;;;422    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;423        OTP->wdgEnableInRom = 1;
;;;424    #else
;;;425        OTP->wdgEnableInRom = 0;
;;;426    #endif
;;;427    
;;;428        /*config watch dog mode in rom, defualt reset all*/
;;;429        OTP->wdgMode = ROM_WATCH_DOG_MODE;
;;;430    
;;;431    
;;;432        //app config
;;;433        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
;;;434        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
;;;435        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
;;;436        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
;;;437    
;;;438        /*config bt stack parameters in rom*/
;;;439    #ifdef BT_STACK_CONFIG_ENABLE
;;;440        bt_stack_config_init();
;;;441    #endif
;;;442    
;;;443    //add more otp config here
;;;444    }
;;;445    
;;;446    APP_FLASH_TEXT_SECTION
;;;447    void pre_main(void)
;;;448    {
;;;449        __disable_irq();
;;;450    
;;;451        ram_init();
;;;452    
;;;453        load_overlay(OVERLAY_SCENARIO_BOOT_ONCE);
;;;454    
;;;455        setlocale(LC_ALL, "C");
;;;456    
;;;457        BOOT_PRINT_ERROR2("SDK Ver: %s, Build Time: %s",
;;;458                          TRACE_STRING(VERSION_BUILD_STR),
;;;459                          TRACE_STRING(BUILDING_TIME));
;;;460    
;;;461        AppUpdateVectorTable();
;;;462    
;;;463        debug_monitor_enable();
;;;464    
;;;465        return;
;;;466    }
;;;467    /**
;;;468     * @brief  update vector table in app
;;;469     * @param  none
;;;470     * @return none
;;;471      */
;;;472    OVERLAY_SECTION_BOOT_ONCE
;;;473    static void AppUpdateVectorTable(void)
;;;474    {
;;;475        extern uint32_t Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;476        extern uint32_t Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;477        extern void Default_Handler(void);
;;;478        const char *SysException[] =
;;;479        {
;;;480            "InitialSP", "Reset", "NMI", "HardFault", "MemManage", "BusFault", "UsageFault", "Rsvd",
;;;481            "Rsvd", "Rsvd", "Rsvd", "SVC", "DebugMon", "Rsvd", "PendSV", "SysTick"
;;;482        };
;;;483        const char *ExtIrq[] =
;;;484        {
;;;485            "System", "WDG", "BTMAC", "TIM3", "TIM2", "Platform", "I2S0_TX", "I2S0_RX", "Timer4-7",
;;;486            "GPIO4", "GPIO5", "UART1", "UART0", "RTC", "SPI0", "SPI1", "I2C0", "I2C1", "ADC",
;;;487            "Peripheral", "GDMA0 Channel0", "GDMA0 Channel1", "GDMA0 Channel2", "GDMA0 Channel3",
;;;488            "GDMA0 Channel4", "GDMA0 Channel5", "GPIO_Group3", "GPIO_Group2", "IR", "GPIO_Group1",
;;;489            "GPIO_Group0", "UART2", "TIM4", "TIM5", "TIM6", "TIM7", "SPI_Flash", "Qdecode",
;;;490            "Keyscan", "SPI2W", "LPCOMP", "PTA_Mailbox", "SPORT1 TX", "SPORT1 RX", "LCD"
;;;491        };
;;;492    
;;;493        IRQ_Fun *pRamVector    = (IRQ_Fun *)VTOR_RAM_ADDR;
;;;494        IRQ_Fun *pAppVector    = (IRQ_Fun *)&Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;495        uint32_t AppVectorSize = (uint32_t)&Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;496        uint32_t i             = 0;
;;;497    
;;;498        if (SCB->VTOR != VTOR_RAM_ADDR)
;;;499        {
;;;500            RamVectorTableInit(VTOR_RAM_ADDR);
;;;501        }
;;;502    
;;;503        /* Update APP defined handlers */
;;;504        for (i = 0; i < AppVectorSize / 4; ++i)
;;;505        {
;;;506            if (i == 1) //skip reset_handler remap
;;;507            {
;;;508                continue;
;;;509            }
;;;510    
;;;511            if ((pAppVector[i] != Default_Handler) && (pAppVector[i] != 0))
;;;512            {
;;;513                if (i < System_VECTORn)
;;;514                {
;;;515                    OS_PRINT_WARN1("Warning! %s is updated by APP!", TRACE_STRING(SysException[i]));
;;;516                }
;;;517                else
;;;518                {
;;;519                    OS_PRINT_WARN1("Warning! ISR %s is updated by APP!",
;;;520                                   TRACE_STRING(ExtIrq[i - System_VECTORn]));
;;;521                }
;;;522    
;;;523                pRamVector[i] = pAppVector[i];
;;;524            }
;;;525        }
;;;526    
;;;527        __DMB();
;;;528        __DSB();
;;;529    }
;;;530    /**
;;;531     * @brief  GPIO Group3 Handler
;;;532     * @param  none
;;;533     * @return none
;;;534      */
;;;535    DATA_RAM_FUNCTION void GPIO_Group3_Handler(void)
;;;536    {
;;;537        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;538    
;;;539        //Check exact IRQ function
;;;540        if (GPIOIrqStatus & BIT3)
;;;541        {
;;;542            GPIO3_Handler();
;;;543        }
;;;544        if (GPIOIrqStatus & BIT7)
;;;545        {
;;;546            GPIO7_Handler();
;;;547        }
;;;548        if (GPIOIrqStatus & BIT11)
;;;549        {
;;;550            GPIO11_Handler();
;;;551        }
;;;552        if (GPIOIrqStatus & BIT15)
;;;553        {
;;;554            GPIO15_Handler();
;;;555        }
;;;556        if (GPIOIrqStatus & BIT19)
;;;557        {
;;;558            GPIO19_Handler();
;;;559        }
;;;560        if (GPIOIrqStatus & BIT23)
;;;561        {
;;;562            GPIO23_Handler();
;;;563        }
;;;564        if (GPIOIrqStatus & BIT27)
;;;565        {
;;;566            GPIO27_Handler();
;;;567        }
;;;568        if (GPIOIrqStatus & BIT31)
;;;569        {
;;;570            GPIO31_Handler();
;;;571        }
;;;572    }
;;;573    /**
;;;574     * @brief  GPIO Group2 Handler
;;;575     * @param  none
;;;576     * @return none
;;;577      */
;;;578    DATA_RAM_FUNCTION void GPIO_Group2_Handler(void)
;;;579    {
;;;580        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;581    
;;;582        //Check exact IRQ function
;;;583        if (GPIOIrqStatus & BIT2)
;;;584        {
;;;585            GPIO2_Handler();
;;;586        }
;;;587        if (GPIOIrqStatus & BIT6)
;;;588        {
;;;589            GPIO6_Handler();
;;;590        }
;;;591        if (GPIOIrqStatus & BIT10)
;;;592        {
;;;593            GPIO10_Handler();
;;;594        }
;;;595        if (GPIOIrqStatus & BIT14)
;;;596        {
;;;597            GPIO14_Handler();
;;;598        }
;;;599        if (GPIOIrqStatus & BIT18)
;;;600        {
;;;601            GPIO18_Handler();
;;;602        }
;;;603        if (GPIOIrqStatus & BIT22)
;;;604        {
;;;605            GPIO22_Handler();
;;;606        }
;;;607        if (GPIOIrqStatus & BIT26)
;;;608        {
;;;609            GPIO26_Handler();
;;;610        }
;;;611        if (GPIOIrqStatus & BIT30)
;;;612        {
;;;613            GPIO30_Handler();
;;;614        }
;;;615    }
;;;616    /**
;;;617     * @brief  GPIO Group1 Handler
;;;618     * @param  none
;;;619     * @return none
;;;620      */
;;;621    DATA_RAM_FUNCTION void GPIO_Group1_Handler(void)
;;;622    {
;;;623        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;624    
;;;625        //Check exact IRQ function
;;;626        if (GPIOIrqStatus & BIT1)
;;;627        {
;;;628            GPIO1_Handler();
;;;629        }
;;;630        if (GPIOIrqStatus & BIT9)
;;;631        {
;;;632            GPIO9_Handler();
;;;633        }
;;;634        if (GPIOIrqStatus & BIT13)
;;;635        {
;;;636            GPIO13_Handler();
;;;637        }
;;;638        if (GPIOIrqStatus & BIT17)
;;;639        {
;;;640            GPIO17_Handler();
;;;641        }
;;;642        if (GPIOIrqStatus & BIT21)
;;;643        {
;;;644            GPIO21_Handler();
;;;645        }
;;;646        if (GPIOIrqStatus & BIT25)
;;;647        {
;;;648            GPIO25_Handler();
;;;649        }
;;;650        if (GPIOIrqStatus & BIT29)
;;;651        {
;;;652            GPIO29_Handler();
;;;653        }
;;;654    }
;;;655    /**
;;;656     * @brief  GPIO Group0 Handler
;;;657     * @param  none
;;;658     * @return none
;;;659      */
;;;660    DATA_RAM_FUNCTION void GPIO_Group0_Handler(void)
;;;661    {
;;;662        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;663    
;;;664        //Check exact IRQ function
;;;665        if (GPIOIrqStatus & BIT0)
;;;666        {
;;;667            GPIO0_Handler();
;;;668        }
;;;669        if (GPIOIrqStatus & BIT8)
;;;670        {
;;;671            GPIO8_Handler();
;;;672        }
;;;673        if (GPIOIrqStatus & BIT12)
;;;674        {
;;;675            GPIO12_Handler();
;;;676        }
;;;677        if (GPIOIrqStatus & BIT16)
;;;678        {
;;;679            GPIO16_Handler();
;;;680        }
;;;681        if (GPIOIrqStatus & BIT20)
;;;682        {
;;;683            GPIO20_Handler();
;;;684        }
;;;685        if (GPIOIrqStatus & BIT24)
;;;686        {
;;;687            GPIO24_Handler();
;;;688        }
;;;689        if (GPIOIrqStatus & BIT28)
;;;690        {
;;;691            GPIO28_Handler();
;;;692        }
;;;693    }
;;;694    
;;;695    void WDG_SystemReset(T_WDG_MODE wdg_mode, T_SW_RESET_REASON reset_reason)
;;;696    {
;;;697        uint32_t parm = wdg_mode | (reset_reason << 8);
        0x0080e6b8:    ea402101    @..!    ORR      r1,r0,r1,LSL #8
;;;698        SystemCall(SYSTEM_CALL_WDG_RESET, parm);
        0x0080e6bc:    2001        .       MOVS     r0,#1
        0x0080e6be:    f7f89def    ....    B        SystemCall ; 0x72a0
    flash_try_high_speed
;;;699    }
;;;700    
;;;701    /**
;;;702     * @brief  flash try to switch to high speed bit mode
;;;703     * @note  switch back to 1 bit mode, if flash switch to high speed bit mode fail
;;;704     * @param  bit_mode config bit mode @ref T_FLASH_MODE
;;;705     * @retval 0 fail
;;;706     * @retval 1 success
;;;707      */
;;;708    uint32_t flash_try_high_speed(T_FLASH_MODE bit_mode)
;;;709    {
        0x0080e6c2:    b510        ..      PUSH     {r4,lr}
;;;710        uint32_t result = 0;
;;;711        OTP->bit_mode = bit_mode;
        0x0080e6c4:    f44f1400    O...    MOV      r4,#0x200000
        0x0080e6c8:    2200        ."      MOVS     r2,#0
        0x0080e6ca:    f894134c    ..L.    LDRB     r1,[r4,#0x34c]
        0x0080e6ce:    f3600101    `...    BFI      r1,r0,#0,#2
        0x0080e6d2:    f884134c    ..L.    STRB     r1,[r4,#0x34c]
;;;712        result = flash_ioctl(flash_ioctrl_try_high_speed, 0, 0);
        0x0080e6d6:    4611        .F      MOV      r1,r2
        0x0080e6d8:    f2450002    E...    MOV      r0,#0x5002
        0x0080e6dc:    f7fddcc9    ....    BL       flash_ioctl ; 0xc072
;;;713        //if try fail, set back OTP->bit_mode to one bit mode
;;;714        if (!result)
        0x0080e6e0:    2800        .(      CMP      r0,#0
        0x0080e6e2:    d105        ..      BNE      0x80e6f0 ; flash_try_high_speed + 46
;;;715        {
;;;716            OTP->bit_mode = FLASH_MODE_1BIT;
        0x0080e6e4:    f894134c    ..L.    LDRB     r1,[r4,#0x34c]
        0x0080e6e8:    f0210103    !...    BIC      r1,r1,#3
        0x0080e6ec:    f884134c    ..L.    STRB     r1,[r4,#0x34c]
;;;717        }
;;;718        return result;
;;;719    }
        0x0080e6f0:    bd10        ..      POP      {r4,pc}
    app_cb0_wdg_reset
        0x0080e6f2:    4a11        .J      LDR      r2,[pc,#68] ; [0x80e738] = 0x207f28
        0x0080e6f4:    6812        .h      LDR      r2,[r2,#0]
;;;720    
;;;721    void app_cb0_wdg_reset(T_WDG_MODE wdg_mode, T_SW_RESET_REASON reset_reason)
;;;722    {
        0x0080e6f6:    2a00        .*      CMP      r2,#0
        0x0080e6f8:    d000        ..      BEQ      0x80e6fc ; app_cb0_wdg_reset + 10
;;;723        if (user_wdg_cb)
;;;724        {
;;;725            if (user_wdg_cb(wdg_mode, reset_reason))
        0x0080e6fa:    4710        .G      BX       r2
;;;726            {
;;;727                return;
;;;728            }
;;;729        }
;;;730    
;;;731        //do something necessary before watch dog reset
;;;732    }
        0x0080e6fc:    4770        pG      BX       lr
    $d
        0x0080e6fe:    0000        ..      DCW    0
        0x0080e700:    53206e49    In S    DCD    1394634313
        0x0080e704:    4d20436f    oC M    DCD    1293960047
        0x0080e708:    0065646f    ode.    DCD    6644847
        0x0080e70c:    4e524157    WARN    DCD    1314013527
        0x0080e710:    3a474e49    ING:    DCD    977751625
        0x0080e714:    206e4920     In     DCD    544098592
        0x0080e718:    20494348    HCI     DCD    541672264
        0x0080e71c:    65646f4d    Mode    DCD    1701080909
        0x0080e720:    6977202c    , wi    DCD    1769414700
        0x0080e724:    6e206c6c    ll n    DCD    1847618668
        0x0080e728:    7220746f    ot r    DCD    1914729583
        0x0080e72c:    41206e75    un A    DCD    1092644469
        0x0080e730:    54205050    PP T    DCD    1411403856
        0x0080e734:    006b7361    ask.    DCD    7041889
        0x0080e738:    00207f28    (. .    DCD    2129704
    $t
    .text
    DLPS_IO_EnterDlpsCb
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_io_dlps.c
;;;1832   {
        0x0080e73c:    b57c        |.      PUSH     {r2-r6,lr}
;;; ..\include\SDK\inc\platform\cmsis\core_cm4.h
;;;1659       NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
        0x0080e73e:    2400        .$      MOVS     r4,#0
        0x0080e740:    f04f20e0    O..     MOV      r0,#0xe000e000
        0x0080e744:    2101        .!      MOVS     r1,#1
        0x0080e746:    f8c01180    ....    STR      r1,[r0,#0x180]
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_io_dlps.c
;;;51         CPU_StoreReg[0] = NVIC->ISER[0];
        0x0080e74a:    f8d02100    ...!    LDR      r2,[r0,#0x100]
        0x0080e74e:    493e        >I      LDR      r1,[pc,#248] ; [0x80e848] = 0x207f38
;;;52         CPU_StoreReg[1] = NVIC->ISPR[0];
        0x0080e750:    600a        .`      STR      r2,[r1,#0]
        0x0080e752:    f8d02200    ..."    LDR      r2,[r0,#0x200]
;;;53         CPU_StoreReg[2] = NVIC->IABR[0];
        0x0080e756:    604a        J`      STR      r2,[r1,#4]
        0x0080e758:    f8d00300    ....    LDR      r0,[r0,#0x300]
;;;54     
;;;55         //The priority of system on interrupt is 0 at first DLPS ENTER CB, so store and restore is skipped
;;;56         for (i = 3; i < 32; ++i)  //skip System_IRQn, WDG_IRQn, BTMAC_IRQn which are handled in rom
        0x0080e75c:    6088        .`      STR      r0,[r1,#8]
        0x0080e75e:    2003        .       MOVS     r0,#3
;;;57         {
;;;58             CPU_StoreReg[i] = NVIC->IP[i];
        0x0080e760:    f10022e0    ..."    ADD      r2,r0,#0xe000e000
        0x0080e764:    f8922400    ...$    LDRB     r2,[r2,#0x400]
        0x0080e768:    f8412020    A.      STR      r2,[r1,r0,LSL #2]
        0x0080e76c:    1c40        @.      ADDS     r0,r0,#1
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_io_dlps.c (56)
        0x0080e76e:    2820         (      CMP      r0,#0x20
        0x0080e770:    d3f6        ..      BCC      0x80e760 ; DLPS_IO_EnterDlpsCb + 36
;;;57         {
;;;58             CPU_StoreReg[i] = NVIC->IP[i];
;;;59         }
;;;60     
;;;61         CPU_StoreReg[32] = SCB->VTOR;
        0x0080e772:    4836        6H      LDR      r0,[pc,#216] ; [0x80e84c] = 0xe000ed08
        0x0080e774:    6800        .h      LDR      r0,[r0,#0]
;;;62         /* Save Vendor register */
;;;63         PeriIntStoreReg = PERIPHINT->EN;
        0x0080e776:    f8c10080    ....    STR      r0,[r1,#0x80]
        0x0080e77a:    4835        5H      LDR      r0,[pc,#212] ; [0x80e850] = 0x40006000
        0x0080e77c:    68c0        .h      LDR      r0,[r0,#0xc]
        0x0080e77e:    4b32        2K      LDR      r3,[pc,#200] ; [0x80e848] = 0x207f38
        0x0080e780:    3b0c        .;      SUBS     r3,r3,#0xc
;;;64     
;;;65         return;
;;;66     }
;;;67     
;;;68     /**
;;;69       * @brief  CPU exit dlps callback function(Resume CPU register values when system exit DLPS)
;;;70       * @param  None
;;;71       * @retval None
;;;72       */
;;;73     DATA_RAM_FUNCTION __STATIC_INLINE  void CPU_DLPS_Exit(void)
;;;74     {
;;;75         //NVIC restore
;;;76         uint32_t i;
;;;77     
;;;78         //Don't restore NVIC pending register, but report warning
;;;79         //NVIC->ISPR[0] = CPU_StoreReg[1];
;;;80         if (CPU_StoreReg[1])
;;;81         {
;;;82             DLPS_PRINT_WARN1("miss interrupt: pending register: 0x%x", CPU_StoreReg[1]);
;;;83         }
;;;84     //    NVIC->IABR[0] = CPU_StoreReg[2];
;;;85     
;;;86         //The priority of system on interrupt is 0 at first DLPS ENTER CB, so store and restore is skipped
;;;87         for (i = 3; i < 32; ++i) //skip System_IRQn, WDG_IRQn, BTMAC_IRQn which are handled in rom
;;;88         {
;;;89             NVIC->IP[i] = CPU_StoreReg[i];
;;;90         }
;;;91     
;;;92         SCB->VTOR = CPU_StoreReg[32];
;;;93         PERIPHINT->EN = PeriIntStoreReg;
;;;94         NVIC->ISER[0] = CPU_StoreReg[0];
;;;95     
;;;96         void debug_monitor_enable(void);
;;;97         debug_monitor_enable();
;;;98         return;
;;;99     }
;;;100    
;;;101    /**
;;;102      * @brief  PINMUX enter dlps callback function(Save PINMUX register values when system enter DLPS)
;;;103      * @param  None
;;;104      * @retval None
;;;105      */
;;;106    __STATIC_INLINE  void Pinmux_DLPS_Enter(void)
;;;107    {
;;;108        uint8_t i = 0;
;;;109    
;;;110        for (i = 0; i < 10; i++)
;;;111        {
;;;112            Pinmux_StoreReg[i] = PINMUX->CFG[i];
        0x0080e782:    f1030190    ....    ADD      r1,r3,#0x90
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_io_dlps.c (108)
        0x0080e786:    6018        .`      STR      r0,[r3,#0]
        0x0080e788:    2000        .       MOVS     r0,#0
;;;109    
;;;110        for (i = 0; i < 10; i++)
;;;111        {
;;;112            Pinmux_StoreReg[i] = PINMUX->CFG[i];
        0x0080e78a:    0082        ..      LSLS     r2,r0,#2
        0x0080e78c:    f1024280    ...B    ADD      r2,r2,#0x40000000
        0x0080e790:    f8d22280    ..."    LDR      r2,[r2,#0x280]
        0x0080e794:    f8412020    A.      STR      r2,[r1,r0,LSL #2]
        0x0080e798:    1c40        @.      ADDS     r0,r0,#1
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_io_dlps.c (110)
        0x0080e79a:    b2c0        ..      UXTB     r0,r0
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_io_dlps.c (110)
        0x0080e79c:    280a        .(      CMP      r0,#0xa
        0x0080e79e:    d3f4        ..      BCC      0x80e78a ; DLPS_IO_EnterDlpsCb + 78
;;;111        {
;;;112            Pinmux_StoreReg[i] = PINMUX->CFG[i];
;;;113        }
;;;114    
;;;115        return;
;;;116    }
;;;117    
;;;118    /**
;;;119      * @brief  PINMUX exit dlps callback function(Resume PINMUX register values when system exit DLPS)
;;;120      * @param  None
;;;121      * @retval None
;;;122      */
;;;123    DATA_RAM_FUNCTION __STATIC_INLINE  void Pinmux_DLPS_Exit(void)
;;;124    {
;;;125        uint8_t i;
;;;126    
;;;127        for (i = 0; i < 10; i++)
;;;128        {
;;;129            PINMUX->CFG[i] = Pinmux_StoreReg[i];
;;;130        }
;;;131    
;;;132        return;
;;;133    }
;;;134    #endif
;;;135    
;;;136    /********************************************** ********************************************************/
;;;137    /**************************************** [GPIO DLPS] **************************************************/
;;;138    /*******************************************************************************************************/
;;;139    /*******************************************************************************************************/
;;;140    #if USE_GPIO_DLPS
;;;141    
;;;142    __STATIC_INLINE void GPIO_DLPS_Enter(void);
;;;143    __STATIC_INLINE void GPIO_DLPS_Exit(void);
;;;144    
;;;145    uint32_t GPIO_StoreReg[9];         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;146    
;;;147    /**
;;;148      * @brief  GPIO enter dlps callback function(Save GPIO register values when system enter DLPS)
;;;149      * @param  None
;;;150      * @retval None
;;;151      */
;;;152    __STATIC_INLINE void GPIO_DLPS_Enter(void)
;;;153    {
;;;154        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;155        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;156    
;;;157        GPIO_StoreReg[0] = GPIO->DATAOUT;
;;;158        GPIO_StoreReg[1] = GPIO->DATADIR;
;;;159        GPIO_StoreReg[2] = GPIO->DATASRC;
;;;160        GPIO_StoreReg[3] = GPIO->INTEN;
;;;161        GPIO_StoreReg[4] = GPIO->INTMASK;
;;;162        GPIO_StoreReg[5] = GPIO->INTTYPE;
;;;163        GPIO_StoreReg[6] = GPIO->INTPOLARITY;
;;;164        GPIO_StoreReg[7] = GPIO->DEBOUNCE;
;;;165        GPIO_StoreReg[8] = *(__IO uint32_t *)(0x40000344UL);
;;;166    
;;;167        return;
;;;168    }
;;;169    
;;;170    /**
;;;171      * @brief  GPIO exit dlps callback function(Resume GPIO register values when system exit DLPS)
;;;172      * @param  None
;;;173      * @retval None
;;;174      */
;;;175    DATA_RAM_FUNCTION __STATIC_INLINE void GPIO_DLPS_Exit(void)
;;;176    {
;;;177        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;178        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;179    
;;;180        GPIO->DATADIR       = GPIO_StoreReg[1];
;;;181        GPIO->DATASRC       = GPIO_StoreReg[2];
;;;182        GPIO->INTMASK       = GPIO_StoreReg[4];
;;;183        GPIO->INTTYPE       = GPIO_StoreReg[5];
;;;184        GPIO->INTPOLARITY   = GPIO_StoreReg[6];
;;;185        GPIO->DEBOUNCE      = GPIO_StoreReg[7];
;;;186        GPIO->DATAOUT       = GPIO_StoreReg[0];
;;;187        GPIO->INTCLR        = ~(GPIO_StoreReg[1]);
;;;188        GPIO->INTEN         = GPIO_StoreReg[3];
;;;189        *(__IO uint32_t *)(0x40000344UL) = GPIO_StoreReg[8];
;;;190    
;;;191        return;
;;;192    }
;;;193    #endif  /* USE_GPIO_DLPS */
;;;194    
;;;195    
;;;196    /********************************************** ********************************************************/
;;;197    /**************************************** [KEYSCAN DLPS] ***********************************************/
;;;198    /*******************************************************************************************************/
;;;199    /*******************************************************************************************************/
;;;200    #if USE_KEYSCAN_DLPS
;;;201    __STATIC_INLINE void KeyScan_DLPS_Enter(void);
;;;202    __STATIC_INLINE void KeyScan_DLPS_Exit(void);
;;;203    
;;;204    uint32_t KeyScan_StoreReg[7];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;205    
;;;206    /**
;;;207      * @brief  KEYSCAN enter dlps callback function(Save KEYSCAN register values when system enter DLPS)
;;;208      * @param  None
;;;209      * @retval None
;;;210      */
;;;211    __STATIC_INLINE void KeyScan_DLPS_Enter(void)
;;;212    {
;;;213        /*Open 5M clock source*/
;;;214        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;215        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;216    
;;;217        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;218        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;219    
;;;220        KeyScan_StoreReg[0] = KEYSCAN->CLKDIV;               /* 0x00 */
;;;221        KeyScan_StoreReg[1] = KEYSCAN->TIMERCR;              /* 0x04 */
;;;222        KeyScan_StoreReg[2] = KEYSCAN->CR;                   /* 0x08 */
;;;223        KeyScan_StoreReg[3] = KEYSCAN->COLCR;                /* 0x0C */
;;;224        KeyScan_StoreReg[4] = KEYSCAN->ROWCR;                /* 0x10 */
;;;225        KeyScan_StoreReg[6] = KEYSCAN->INTMASK;              /* 0x18 */
;;;226    
;;;227        return;
;;;228    }
;;;229    
;;;230    /**
;;;231      * @brief  KEYSCAN exit dlps callback function(Resume KEYSCAN register values when system exit DLPS)
;;;232      * @param  None
;;;233      * @retval None
;;;234      */
;;;235    DATA_RAM_FUNCTION __STATIC_INLINE void KeyScan_DLPS_Exit(void)
;;;236    {
;;;237        /*Open 5M clock source*/
;;;238        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;239        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;240    
;;;241        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;242        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;243    
;;;244        /* Set FSM to idle state */
;;;245        KEYSCAN->CR &= ~BIT31;
;;;246        KEYSCAN->CLKDIV = KeyScan_StoreReg[0];
;;;247        KEYSCAN->CR = (KeyScan_StoreReg[2] & (~(BIT31)));
;;;248        KEYSCAN->TIMERCR = KeyScan_StoreReg[1];
;;;249        KEYSCAN->COLCR = KeyScan_StoreReg[3];
;;;250        KEYSCAN->ROWCR = KeyScan_StoreReg[4];
;;;251        KEYSCAN->INTMASK = KeyScan_StoreReg[6];
;;;252        KEYSCAN->CR |= (KeyScan_StoreReg[2] & ((BIT31)));
;;;253    
;;;254        return;
;;;255    }
;;;256    #endif /* USE_KEYSCAN_DLPS */
;;;257    
;;;258    
;;;259    /********************************************** ********************************************************/
;;;260    /**************************************** [QDEC DLPS] **************************************************/
;;;261    /*******************************************************************************************************/
;;;262    /*******************************************************************************************************/
;;;263    #if USE_QDECODER_DLPS
;;;264    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void);
;;;265    __STATIC_INLINE void QuadDecoder_DLPS_Exit(void);
;;;266    
;;;267    uint32_t QuadDecoder_StoreReg[5];  /*  This array should be placed in RAM ON/Buffer ON.    */
;;;268    
;;;269    /**
;;;270      * @brief  QDEC enter dlps callback function(Save QDEC register values when system enter DLPS)
;;;271      * @param  None
;;;272      * @retval None
;;;273      */
;;;274    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void)
;;;275    {
;;;276        /*Open 20M clock source*/
;;;277        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;278        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;279        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;280        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;281    
;;;282        QuadDecoder_StoreReg[0] = QDEC->REG_DIV;
;;;283        QuadDecoder_StoreReg[1] = QDEC->REG_CR_X;
;;;284        QuadDecoder_StoreReg[2] = QDEC->REG_CR_Y;
;;;285        QuadDecoder_StoreReg[3] = QDEC->REG_CR_Z;
;;;286        QuadDecoder_StoreReg[4] = QDEC->INT_MASK;
;;;287    
;;;288        return;
;;;289    }
;;;290    
;;;291    /**
;;;292      * @brief  QDEC exit dlps callback function(Resume QDEC register values when system exit DLPS)
;;;293      * @param  None
;;;294      * @retval None
;;;295      */
;;;296    DATA_RAM_FUNCTION __STATIC_INLINE void QuadDecoder_DLPS_Exit(void)
;;;297    {
;;;298        /*Open 20M clock source*/
;;;299        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;300        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;301        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;302        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;303    
;;;304        //clear flags
;;;305        QDEC->REG_DIV  = QuadDecoder_StoreReg[0];
;;;306        QDEC->REG_CR_X = QuadDecoder_StoreReg[1];
;;;307        QDEC->REG_CR_Y = QuadDecoder_StoreReg[2];
;;;308        QDEC->REG_CR_Z = QuadDecoder_StoreReg[3];
;;;309        QDEC->INT_MASK = QuadDecoder_StoreReg[4];
;;;310    
;;;311        return;
;;;312    }
;;;313    #endif
;;;314    
;;;315    /********************************************** ********************************************************/
;;;316    /**************************************** [SPI0 DLPS] **************************************************/
;;;317    /*******************************************************************************************************/
;;;318    /*******************************************************************************************************/
;;;319    #if USE_SPI0_DLPS
;;;320    __STATIC_INLINE void SPI0_DLPS_Enter(void);
;;;321    __STATIC_INLINE void SPI0_DLPS_Exit(void);
;;;322    
;;;323    uint32_t SPI0_StoreReg[13];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;324    
;;;325    /**
;;;326      * @brief  SPI0 enter dlps callback function(Save SPI0 register values when system enter DLPS)
;;;327      * @param  None
;;;328      * @retval None
;;;329      */
;;;330    __STATIC_INLINE void SPI0_DLPS_Enter(void)
;;;331    {
;;;332        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;333        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;334    
;;;335        SPI0_StoreReg[0] = SPI0->CTRLR0;
;;;336        SPI0_StoreReg[1] = SPI0->CTRLR1;
;;;337        SPI0_StoreReg[2] = SPI0->SSIENR;
;;;338        SPI0_StoreReg[3] = SPI0->SER;
;;;339        SPI0_StoreReg[4] = SPI0->BAUDR;
;;;340        SPI0_StoreReg[5] = SPI0->TXFTLR;
;;;341        SPI0_StoreReg[6] = SPI0->RXFTLR;
;;;342        SPI0_StoreReg[7] = SPI0->IMR;
;;;343        SPI0_StoreReg[8] = SPI0->DMACR;
;;;344        SPI0_StoreReg[9] = SPI0->DMATDLR;
;;;345        SPI0_StoreReg[10] = SPI0->DMARDLR;
;;;346        SPI0_StoreReg[11] = SPI0->RX_SAMPLE_DLY;
;;;347        SPI0_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;348    }
;;;349    
;;;350    /**
;;;351      * @brief  SPI0 exit dlps callback function(Resume SPI0 register values when system exit DLPS)
;;;352      * @param  None
;;;353      * @retval None
;;;354      */
;;;355    DATA_RAM_FUNCTION __STATIC_INLINE void SPI0_DLPS_Exit(void)
;;;356    {
;;;357        *(volatile uint32_t *)0x40000308 = SPI0_StoreReg[12];
;;;358        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;359        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;360    
;;;361        SPI0->CTRLR0 = SPI0_StoreReg[0];
;;;362        SPI0->CTRLR1 = SPI0_StoreReg[1];
;;;363        SPI0->SER = SPI0_StoreReg[3];
;;;364        SPI0->BAUDR = SPI0_StoreReg[4];
;;;365        SPI0->TXFTLR = SPI0_StoreReg[5];
;;;366        SPI0->RXFTLR = SPI0_StoreReg[6];
;;;367        SPI0->IMR = SPI0_StoreReg[7];
;;;368        SPI0->DMACR = SPI0_StoreReg[8];
;;;369        SPI0->DMATDLR = SPI0_StoreReg[9];
;;;370        SPI0->DMARDLR = SPI0_StoreReg[10];
;;;371        SPI0->RX_SAMPLE_DLY = SPI0_StoreReg[11];
;;;372    
;;;373        /* Enable the selected SPI peripheral */
;;;374        SPI0->SSIENR = SPI0_StoreReg[2];
;;;375    }
;;;376    #endif
;;;377    
;;;378    
;;;379    /********************************************** ********************************************************/
;;;380    /**************************************** [SPI1 DLPS] **************************************************/
;;;381    /*******************************************************************************************************/
;;;382    /*******************************************************************************************************/
;;;383    #if USE_SPI1_DLPS
;;;384    __STATIC_INLINE void SPI1_DLPS_Enter(void);
;;;385    __STATIC_INLINE void SPI1_DLPS_Exit(void);
;;;386    
;;;387    uint32_t SPI1_StoreReg[13];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;388    
;;;389    /**
;;;390      * @brief  SPI1 enter dlps callback function(Save SPI1 register values when system enter DLPS)
;;;391      * @param  None
;;;392      * @retval None
;;;393      */
;;;394    __STATIC_INLINE void SPI1_DLPS_Enter(void)
;;;395    {
;;;396        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;397        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;398    
;;;399        SPI1_StoreReg[0] = SPI1->CTRLR0;
;;;400        SPI1_StoreReg[1] = SPI1->CTRLR1;
;;;401        SPI1_StoreReg[2] = SPI1->SSIENR;
;;;402        SPI1_StoreReg[3] = SPI1->SER;
;;;403        SPI1_StoreReg[4] = SPI1->BAUDR;
;;;404        SPI1_StoreReg[5] = SPI1->TXFTLR;
;;;405        SPI1_StoreReg[6] = SPI1->RXFTLR;
;;;406        SPI1_StoreReg[7] = SPI1->IMR;
;;;407        SPI1_StoreReg[8] = SPI1->DMACR;
;;;408        SPI1_StoreReg[9] = SPI1->DMATDLR;
;;;409        SPI1_StoreReg[10] = SPI1->DMARDLR;
;;;410        SPI1_StoreReg[11] = SPI1->RX_SAMPLE_DLY;
;;;411        SPI1_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;412    }
;;;413    
;;;414    /**
;;;415      * @brief  SPI1 exit dlps callback function(Resume SPI1 register values when system exit DLPS)
;;;416      * @param  None
;;;417      * @retval None
;;;418      */
;;;419    DATA_RAM_FUNCTION __STATIC_INLINE void SPI1_DLPS_Exit(void)
;;;420    {
;;;421        *(volatile uint32_t *)0x40000308 = SPI1_StoreReg[12];
;;;422        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;423        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;424    
;;;425        SPI1->CTRLR0 = SPI1_StoreReg[0];
;;;426        SPI1->CTRLR1 = SPI1_StoreReg[1];
;;;427        SPI1->SER = SPI1_StoreReg[3];
;;;428        SPI1->BAUDR = SPI1_StoreReg[4];
;;;429        SPI1->TXFTLR = SPI1_StoreReg[5];
;;;430        SPI1->RXFTLR = SPI1_StoreReg[6];
;;;431        SPI1->IMR = SPI1_StoreReg[7];
;;;432        SPI1->DMACR = SPI1_StoreReg[8];
;;;433        SPI1->DMATDLR = SPI1_StoreReg[9];
;;;434        SPI1->DMARDLR = SPI1_StoreReg[10];
;;;435        SPI1->RX_SAMPLE_DLY = SPI1_StoreReg[11];
;;;436    
;;;437        /* Enable the selected SPI peripheral */
;;;438        SPI1->SSIENR = SPI1_StoreReg[2];
;;;439    }
;;;440    #endif
;;;441    
;;;442    /********************************************** ********************************************************/
;;;443    /**************************************** [SPI2W DLPS] **************************************************/
;;;444    /*******************************************************************************************************/
;;;445    /*******************************************************************************************************/
;;;446    #if USE_SPI2W_DLPS
;;;447    __STATIC_INLINE void SPI2W_DLPS_Enter(void);
;;;448    __STATIC_INLINE void SPI2W_DLPS_Exit(void);
;;;449    
;;;450    uint32_t SPI2W_StoreReg[1];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;451    
;;;452    /**
;;;453      * @brief  SPI2W enter dlps callback function(Save SPI2W register values when system enter DLPS)
;;;454      * @param  None
;;;455      * @retval None
;;;456      */
;;;457    __STATIC_INLINE void SPI2W_DLPS_Enter(void)
;;;458    {
;;;459        /*Open 20M clock source*/
;;;460        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;461        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;462    
;;;463        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;464        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;465    
;;;466        SPI2W_StoreReg[0] = SPI3WIRE->CFGR;
;;;467    }
;;;468    
;;;469    /**
;;;470      * @brief  SPI2W exit dlps callback function(Resume SPI2W register values when system exit DLPS)
;;;471      * @param  None
;;;472      * @retval None
;;;473      */
;;;474    DATA_RAM_FUNCTION __STATIC_INLINE void SPI2W_DLPS_Exit(void)
;;;475    {
;;;476        /*Open 20M clock source*/
;;;477        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;478        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;479    
;;;480        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;481        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;482    
;;;483        SPI3WIRE->CFGR = SPI2W_StoreReg[0];
;;;484    }
;;;485    #endif
;;;486    
;;;487    /********************************************** ********************************************************/
;;;488    /**************************************** [I2C0 DLPS] **************************************************/
;;;489    /*******************************************************************************************************/
;;;490    /*******************************************************************************************************/
;;;491    #if USE_I2C0_DLPS
;;;492    __STATIC_INLINE void I2C0_DLPS_Enter(void);
;;;493    __STATIC_INLINE void I2C0_DLPS_Exit(void);
;;;494    
;;;495    uint32_t I2C0_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;496    
;;;497    /**
;;;498      * @brief  I2C0 enter dlps callback function(Save I2C0 register values when system enter DLPS)
;;;499      * @param  None
;;;500      * @retval None
;;;501      */
;;;502    __STATIC_INLINE void I2C0_DLPS_Enter(void)
;;;503    {
;;;504        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;505        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;506    
;;;507        I2C0_StoreReg[0] = I2C0->IC_CON;
;;;508        I2C0_StoreReg[1] = I2C0->IC_TAR;
;;;509        I2C0_StoreReg[2] = I2C0->IC_SAR;
;;;510        I2C0_StoreReg[3] = I2C0->IC_HS_MADDR;
;;;511    
;;;512        I2C0_StoreReg[4] = I2C0->IC_SS_SCL_HCNT;
;;;513        I2C0_StoreReg[5] = I2C0->IC_SS_SCL_LCNT;
;;;514        I2C0_StoreReg[6] = I2C0->IC_FS_SCL_HCNT;
;;;515        I2C0_StoreReg[7] = I2C0->IC_FS_SCL_LCNT;
;;;516        I2C0_StoreReg[8] = I2C0->IC_HS_SCL_HCNT;
;;;517        I2C0_StoreReg[9] = I2C0->IC_HS_SCL_LCNT;
;;;518    
;;;519        I2C0_StoreReg[10] = I2C0->IC_INTR_MASK;
;;;520        I2C0_StoreReg[11] = I2C0->IC_RX_TL;
;;;521        I2C0_StoreReg[12] = I2C0->IC_TX_TL;
;;;522        I2C0_StoreReg[13] = I2C0->IC_ENABLE;
;;;523        I2C0_StoreReg[14] = I2C0->IC_SDA_HOLD;
;;;524        I2C0_StoreReg[15] = I2C0->IC_SLV_DATA_NACK_ONLY;
;;;525        I2C0_StoreReg[16] = I2C0->IC_DMA_CR;
;;;526        I2C0_StoreReg[17] = I2C0->IC_DMA_TDLR;
;;;527        I2C0_StoreReg[18] = I2C0->IC_DMA_RDLR;
;;;528    
;;;529        I2C0_StoreReg[19] = I2C0->IC_SDA_SETUP;
;;;530    }
;;;531    
;;;532    /**
;;;533      * @brief  I2C0 exit dlps callback function(Resume I2C0 register values when system exit DLPS)
;;;534      * @param  None
;;;535      * @retval None
;;;536      */
;;;537    DATA_RAM_FUNCTION __STATIC_INLINE void I2C0_DLPS_Exit(void)
;;;538    {
;;;539        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;540        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;541    
;;;542        I2C0->IC_CON = I2C0_StoreReg[0];
;;;543        I2C0->IC_TAR = I2C0_StoreReg[1];
;;;544        I2C0->IC_SAR = I2C0_StoreReg[2];
;;;545        I2C0->IC_HS_MADDR = I2C0_StoreReg[3];
;;;546    
;;;547        I2C0->IC_SS_SCL_HCNT = I2C0_StoreReg[4];
;;;548        I2C0->IC_SS_SCL_LCNT = I2C0_StoreReg[5];
;;;549        I2C0->IC_FS_SCL_HCNT = I2C0_StoreReg[6];
;;;550        I2C0->IC_FS_SCL_LCNT = I2C0_StoreReg[7];
;;;551        I2C0->IC_HS_SCL_HCNT = I2C0_StoreReg[8];
;;;552        I2C0->IC_HS_SCL_LCNT = I2C0_StoreReg[9];
;;;553    
;;;554        I2C0->IC_INTR_MASK = I2C0_StoreReg[10];
;;;555        I2C0->IC_RX_TL = I2C0_StoreReg[11];
;;;556        I2C0->IC_TX_TL = I2C0_StoreReg[12];
;;;557        I2C0->IC_SDA_HOLD = I2C0_StoreReg[14];
;;;558        I2C0->IC_SLV_DATA_NACK_ONLY = I2C0_StoreReg[15];
;;;559        I2C0->IC_DMA_CR = I2C0_StoreReg[16];
;;;560        I2C0->IC_DMA_TDLR = I2C0_StoreReg[17];
;;;561        I2C0->IC_DMA_RDLR = I2C0_StoreReg[18];
;;;562        I2C0->IC_SDA_SETUP = I2C0_StoreReg[19];
;;;563    
;;;564        I2C0->IC_ENABLE = I2C0_StoreReg[13];
;;;565    }
;;;566    #endif
;;;567    
;;;568    /********************************************** ********************************************************/
;;;569    /**************************************** [I2C1 DLPS] **************************************************/
;;;570    /*******************************************************************************************************/
;;;571    /*******************************************************************************************************/
;;;572    #if USE_I2C1_DLPS
;;;573    __STATIC_INLINE void I2C1_DLPS_Enter(void);
;;;574    __STATIC_INLINE void I2C1_DLPS_Exit(void);
;;;575    
;;;576    uint32_t I2C1_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;577    
;;;578    /**
;;;579      * @brief  I2C1 enter dlps callback function(Save I2C1 register values when system enter DLPS)
;;;580      * @param  None
;;;581      * @retval None
;;;582      */
;;;583    __STATIC_INLINE void I2C1_DLPS_Enter(void)
;;;584    {
;;;585        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;586        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;587    
;;;588        I2C1_StoreReg[0] = I2C1->IC_CON;
;;;589        I2C1_StoreReg[1] = I2C1->IC_TAR;
;;;590        I2C1_StoreReg[2] = I2C1->IC_SAR;
;;;591        I2C1_StoreReg[3] = I2C1->IC_HS_MADDR;
;;;592    
;;;593        I2C1_StoreReg[4] = I2C1->IC_SS_SCL_HCNT;
;;;594        I2C1_StoreReg[5] = I2C1->IC_SS_SCL_LCNT;
;;;595        I2C1_StoreReg[6] = I2C1->IC_FS_SCL_HCNT;
;;;596        I2C1_StoreReg[7] = I2C1->IC_FS_SCL_LCNT;
;;;597        I2C1_StoreReg[8] = I2C1->IC_HS_SCL_HCNT;
;;;598        I2C1_StoreReg[9] = I2C1->IC_HS_SCL_LCNT;
;;;599    
;;;600        I2C1_StoreReg[10] = I2C1->IC_INTR_MASK;
;;;601        I2C1_StoreReg[11] = I2C1->IC_RX_TL;
;;;602        I2C1_StoreReg[12] = I2C1->IC_TX_TL;
;;;603        I2C1_StoreReg[13] = I2C1->IC_ENABLE;
;;;604        I2C1_StoreReg[14] = I2C1->IC_SDA_HOLD;
;;;605        I2C1_StoreReg[15] = I2C1->IC_SLV_DATA_NACK_ONLY;
;;;606        I2C1_StoreReg[16] = I2C1->IC_DMA_CR;
;;;607        I2C1_StoreReg[17] = I2C1->IC_DMA_TDLR;
;;;608        I2C1_StoreReg[18] = I2C1->IC_DMA_RDLR;
;;;609    
;;;610        I2C1_StoreReg[19] = I2C1->IC_SDA_SETUP;
;;;611    }
;;;612    
;;;613    /**
;;;614      * @brief  I2C1 exit dlps callback function(Resume I2C1 register values when system exit DLPS)
;;;615      * @param  None
;;;616      * @retval None
;;;617      */
;;;618    DATA_RAM_FUNCTION __STATIC_INLINE void I2C1_DLPS_Exit(void)
;;;619    {
;;;620        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;621        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;622    
;;;623        I2C1->IC_CON = I2C1_StoreReg[0];
;;;624        I2C1->IC_TAR = I2C1_StoreReg[1];
;;;625        I2C1->IC_SAR = I2C1_StoreReg[2];
;;;626        I2C0->IC_HS_MADDR = I2C1_StoreReg[3];
;;;627    
;;;628        I2C1->IC_SS_SCL_HCNT = I2C1_StoreReg[4];
;;;629        I2C1->IC_SS_SCL_LCNT = I2C1_StoreReg[5];
;;;630        I2C1->IC_FS_SCL_HCNT = I2C1_StoreReg[6];
;;;631        I2C1->IC_FS_SCL_LCNT = I2C1_StoreReg[7];
;;;632        I2C1->IC_HS_SCL_HCNT = I2C1_StoreReg[8];
;;;633        I2C1->IC_HS_SCL_LCNT = I2C1_StoreReg[9];
;;;634    
;;;635        I2C1->IC_INTR_MASK = I2C1_StoreReg[10];
;;;636        I2C1->IC_RX_TL = I2C1_StoreReg[11];
;;;637        I2C1->IC_TX_TL = I2C1_StoreReg[12];
;;;638        I2C1->IC_SDA_HOLD = I2C1_StoreReg[14];
;;;639        I2C1->IC_SLV_DATA_NACK_ONLY = I2C1_StoreReg[15];
;;;640        I2C1->IC_DMA_CR = I2C1_StoreReg[16];
;;;641        I2C1->IC_DMA_TDLR = I2C1_StoreReg[17];
;;;642        I2C1->IC_DMA_RDLR = I2C1_StoreReg[18];
;;;643        I2C1->IC_SDA_SETUP = I2C1_StoreReg[19];
;;;644    
;;;645        I2C1->IC_ENABLE = I2C1_StoreReg[13];
;;;646    }
;;;647    #endif
;;;648    
;;;649    /********************************************** ********************************************************/
;;;650    /**************************************** [Timer & PWM DLPS] *******************************************/
;;;651    /*******************************************************************************************************/
;;;652    /*******************************************************************************************************/
;;;653    #if USE_TIM_DLPS
;;;654    #include "rtl876x_tim.h"
;;;655    __STATIC_INLINE void TIM_DLPS_Enter(void);
;;;656    __STATIC_INLINE void TIM_DLPS_Exit(void);
;;;657    
;;;658    uint32_t TIM_StoreReg[26];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;659    
;;;660    /* PWM, use with timer */
;;;661    uint32_t PWM0_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;662    
;;;663    uint32_t PWM1_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;664    
;;;665    /**
;;;666      * @brief  TIMER enter dlps callback function(Save TIMER register values when system enter DLPS)
;;;667      * @param  None
;;;668      * @retval None
;;;669      */
;;;670    __STATIC_INLINE void TIM_DLPS_Enter(void)
;;;671    {
;;;672        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;673        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;674    
;;;675        TIM_StoreReg[0] = TIM0->LoadCount;
;;;676        TIM_StoreReg[1] = TIM0->ControlReg;
;;;677        TIM_StoreReg[2] = TIMER0_LOAD_COUNT2;
;;;678    
;;;679        TIM_StoreReg[3] = TIM1->LoadCount;
;;;680        TIM_StoreReg[4] = TIM1->ControlReg;
;;;681        TIM_StoreReg[5] = TIMER1_LOAD_COUNT2;
;;;682    
;;;683        TIM_StoreReg[6] = TIM2->LoadCount;
;;;684        TIM_StoreReg[7] = TIM2->ControlReg;
;;;685        TIM_StoreReg[8] = TIMER2_LOAD_COUNT2;
;;;686    
;;;687        TIM_StoreReg[9] = TIM3->LoadCount;
;;;688        TIM_StoreReg[10] = TIM3->ControlReg;
;;;689        TIM_StoreReg[11] = TIMER3_LOAD_COUNT2;
;;;690    
;;;691        TIM_StoreReg[12] = TIM4->LoadCount;
;;;692        TIM_StoreReg[13] = TIM4->ControlReg;
;;;693        TIM_StoreReg[14] = TIMER4_LOAD_COUNT2;
;;;694    
;;;695        TIM_StoreReg[15] = TIM5->LoadCount;
;;;696        TIM_StoreReg[16] = TIM5->ControlReg;
;;;697        TIM_StoreReg[17] = TIMER5_LOAD_COUNT2;
;;;698    
;;;699        TIM_StoreReg[18] = TIM6->LoadCount;
;;;700        TIM_StoreReg[19] = TIM6->ControlReg;
;;;701        TIM_StoreReg[20] = TIMER6_LOAD_COUNT2;
;;;702    
;;;703        TIM_StoreReg[21] = TIM7->LoadCount;
;;;704        TIM_StoreReg[22] = TIM7->ControlReg;
;;;705        TIM_StoreReg[23] = TIMER7_LOAD_COUNT2;
;;;706    
;;;707        TIM_StoreReg[24] = *((volatile uint32_t *)0x4000035CUL);
;;;708        TIM_StoreReg[25] = *((volatile uint32_t *)0x40000360UL);
;;;709    
;;;710        PWM0_StoreReg = TIMER_PWM0_CR;
;;;711    
;;;712        PWM1_StoreReg = TIMER_PWM1_CR;
;;;713    }
;;;714    
;;;715    /**
;;;716      * @brief  TIMER exit dlps callback function(Resume TIMER register values when system exit DLPS)
;;;717      * @param  None
;;;718      * @retval None
;;;719      */
;;;720    DATA_RAM_FUNCTION __STATIC_INLINE void TIM_DLPS_Exit(void)
;;;721    {
;;;722        /* Enable timer IP clock and function */
;;;723        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;724        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;725    
;;;726        *((volatile uint32_t *)0x4000035CUL) = TIM_StoreReg[24];
;;;727        *((volatile uint32_t *)0x40000360UL) = TIM_StoreReg[25];
;;;728    
;;;729        TIM0->LoadCount = TIM_StoreReg[0];
;;;730        TIM0->ControlReg = TIM_StoreReg[1];
;;;731        TIMER0_LOAD_COUNT2 = TIM_StoreReg[2];
;;;732    
;;;733        TIM1->LoadCount = TIM_StoreReg[3];
;;;734        TIM1->ControlReg = TIM_StoreReg[4];
;;;735        TIMER1_LOAD_COUNT2 = TIM_StoreReg[5];
;;;736    
;;;737        TIM2->LoadCount = TIM_StoreReg[6];
;;;738        TIM2->ControlReg = TIM_StoreReg[7];
;;;739        TIMER2_LOAD_COUNT2 = TIM_StoreReg[8];
;;;740    
;;;741        TIM3->LoadCount = TIM_StoreReg[9];
;;;742        TIM3->ControlReg = TIM_StoreReg[10];
;;;743        TIMER3_LOAD_COUNT2 = TIM_StoreReg[11];
;;;744    
;;;745        TIM4->LoadCount = TIM_StoreReg[12];
;;;746        TIM4->ControlReg = TIM_StoreReg[13];
;;;747        TIMER4_LOAD_COUNT2 = TIM_StoreReg[14];
;;;748    
;;;749        TIM5->LoadCount = TIM_StoreReg[15];
;;;750        TIM5->ControlReg = TIM_StoreReg[16];
;;;751        TIMER5_LOAD_COUNT2 = TIM_StoreReg[17];
;;;752    
;;;753        TIM6->LoadCount = TIM_StoreReg[18];
;;;754        TIM6->ControlReg = TIM_StoreReg[19];
;;;755        TIMER6_LOAD_COUNT2 = TIM_StoreReg[20];
;;;756    
;;;757        TIM7->LoadCount = TIM_StoreReg[21];
;;;758        TIM7->ControlReg = TIM_StoreReg[22];
;;;759        TIMER7_LOAD_COUNT2 = TIM_StoreReg[23];
;;;760    
;;;761        TIMER_PWM0_CR = PWM0_StoreReg;
;;;762    
;;;763        TIMER_PWM1_CR = PWM1_StoreReg;
;;;764    }
;;;765    #endif  /* USE_TIM_DLPS */
;;;766    
;;;767    
;;;768    /********************************************** ********************************************************/
;;;769    /**************************************** [UART DLPS] **************************************************/
;;;770    /*******************************************************************************************************/
;;;771    /*******************************************************************************************************/
;;;772    #if USE_UART_DLPS
;;;773    #include "rtl876x_uart.h"
;;;774    
;;;775    __STATIC_INLINE void UART_DLPS_Enter(void);
;;;776    __STATIC_INLINE void UART_DLPS_Exit(void);
;;;777    
;;;778    uint32_t UART_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;779    
;;;780    /**
;;;781      * @brief  UART enter dlps callback function(Save UART register values when system enter DLPS)
;;;782      * @param  None
;;;783      * @retval None
;;;784      */
;;;785    __STATIC_INLINE void UART_DLPS_Enter(void)
;;;786    {
;;;787        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;788        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;789    
;;;790        //access DLH and DLL
;;;791        UART->LCR |= (1 << 7);
;;;792        UART_StoreReg[0] = UART->DLL;
;;;793        UART_StoreReg[1] = UART->DLH_INTCR;
;;;794        UART->LCR &= (~(1 << 7));
;;;795    
;;;796        //save other registers
;;;797        UART_StoreReg[2] = UART->DLH_INTCR;
;;;798        UART_StoreReg[4] = UART->LCR;
;;;799        UART_StoreReg[5] = UART->MCR;
;;;800        UART_StoreReg[6] = UART->SPR;
;;;801        UART_StoreReg[7] = UART->STSR;
;;;802        UART_StoreReg[8] = UART->RX_IDLE_INTTCR;
;;;803        UART_StoreReg[9] = UART->RXIDLE_INTCR;
;;;804        UART_StoreReg[10] = UART->MISCR;
;;;805    
;;;806        return;
;;;807    }
;;;808    
;;;809    /**
;;;810      * @brief  UART exit dlps callback function(Resume UART register values when system exit DLPS)
;;;811      * @param  None
;;;812      * @retval None
;;;813      */
;;;814    DATA_RAM_FUNCTION __STATIC_INLINE void UART_DLPS_Exit(void)
;;;815    {
;;;816        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;817        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;818    
;;;819        //access DLH and DLL
;;;820        UART->LCR |= (1 << 7);
;;;821        UART->DLL = UART_StoreReg[0];
;;;822        UART->DLH_INTCR =  UART_StoreReg[1];
;;;823        UART->LCR &= (~(1 << 7));
;;;824    
;;;825        //access other registers
;;;826        UART->INTID_FCR = (((UART_StoreReg[7] & BIT24) >> 21) | ((UART_StoreReg[7] & 0x7C000000) >> 18) |
;;;827                           (1));
;;;828        UART->LCR = UART_StoreReg[4];
;;;829        UART->MCR = UART_StoreReg[5];
;;;830        UART->SPR = UART_StoreReg[6];
;;;831        UART->STSR = UART_StoreReg[7];
;;;832        UART->DLH_INTCR = UART_StoreReg[2];
;;;833        UART->RX_IDLE_INTTCR = UART_StoreReg[8];
;;;834        UART->RXIDLE_INTCR = UART_StoreReg[9];
;;;835        UART->MISCR = UART_StoreReg[10];
;;;836    
;;;837        return;
;;;838    }
;;;839    #endif
;;;840    
;;;841    
;;;842    #if USE_UART1_DLPS
;;;843    
;;;844    __STATIC_INLINE void UART1_DLPS_Enter(void);
;;;845    __STATIC_INLINE void UART1_DLPS_Exit(void);
;;;846    
;;;847    uint32_t UART1_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;848    
;;;849    /**
;;;850      * @brief  UART1 enter dlps callback function(Save UART1 register values when system enter DLPS)
;;;851      * @param  None
;;;852      * @retval None
;;;853      */
;;;854    __STATIC_INLINE void UART1_DLPS_Enter(void)
;;;855    {
;;;856        //enable log uart peripheral & clock
;;;857        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;858        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;859    
;;;860        //access DLH and DLL
;;;861        UART1->LCR |= (1 << 7);
;;;862        UART1_StoreReg[0] = UART1->DLL;
;;;863        UART1_StoreReg[1] = UART1->DLH_INTCR;
;;;864        UART1->LCR &= (~(1 << 7));
;;;865    
;;;866        //save other registers
;;;867        UART1_StoreReg[2] = UART1->DLH_INTCR;
;;;868        UART1_StoreReg[4] = UART1->LCR;
;;;869        UART1_StoreReg[5] = UART1->MCR;
;;;870        UART1_StoreReg[6] = UART1->SPR;
;;;871        UART1_StoreReg[7] = UART1->STSR;
;;;872        UART1_StoreReg[8] = UART1->RX_IDLE_INTTCR;
;;;873        UART1_StoreReg[9] = UART1->RXIDLE_INTCR;
;;;874        UART1_StoreReg[10] = UART1->MISCR;
;;;875    
;;;876        return;
;;;877    }
;;;878    
;;;879    /**
;;;880      * @brief  UART1 exit dlps callback function(Resume UART1 register values when system exit DLPS)
;;;881      * @param  None
;;;882      * @retval None
;;;883      */
;;;884    DATA_RAM_FUNCTION __STATIC_INLINE void UART1_DLPS_Exit(void)
;;;885    {
;;;886        //enable log uart peripheral & clock
;;;887        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;888        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;889    
;;;890        //access DLH and DLL
;;;891        UART1->LCR |= (1 << 7);
;;;892        UART1->DLL = UART1_StoreReg[0];
;;;893        UART1->DLH_INTCR =  UART1_StoreReg[1];
;;;894        UART1->LCR &= (~(1 << 7));
;;;895    
;;;896        //access other registers
;;;897        UART1->INTID_FCR = (((UART1_StoreReg[7] & BIT24) >> 21) | ((UART1_StoreReg[7] & 0x7C000000)
;;;898                                                                   >> 18) | (1));
;;;899        UART1->LCR = UART1_StoreReg[4];
;;;900        UART1->MCR = UART1_StoreReg[5];
;;;901        UART1->SPR = UART1_StoreReg[6];
;;;902        UART1->STSR = UART1_StoreReg[7];
;;;903        UART1->DLH_INTCR = UART1_StoreReg[2];
;;;904        UART1->RX_IDLE_INTTCR = UART1_StoreReg[8];
;;;905        UART1->RXIDLE_INTCR = UART1_StoreReg[9];
;;;906        UART1->MISCR = UART1_StoreReg[10];
;;;907    
;;;908        return;
;;;909    }
;;;910    #endif
;;;911    
;;;912    #if USE_UART2_DLPS
;;;913    
;;;914    __STATIC_INLINE void UART2_DLPS_Enter(void);
;;;915    __STATIC_INLINE void UART2_DLPS_Exit(void);
;;;916    
;;;917    uint32_t UART2_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;918    
;;;919    /**
;;;920      * @brief  UART2 enter dlps callback function(Save UART2 register values when system enter DLPS)
;;;921      * @param  None
;;;922      * @retval None
;;;923      */
;;;924    __STATIC_INLINE void UART2_DLPS_Enter(void)
;;;925    {
;;;926        //enable log uart peripheral & clock
;;;927        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;928        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;929    
;;;930        //access DLH and DLL
;;;931        UART2->LCR |= (1 << 7);
;;;932        UART2_StoreReg[0] = UART2->DLL;
;;;933        UART2_StoreReg[1] = UART2->DLH_INTCR;
;;;934        UART2->LCR &= (~(1 << 7));
;;;935    
;;;936        //save other registers
;;;937        UART2_StoreReg[2] = UART2->DLH_INTCR;
;;;938        UART2_StoreReg[4] = UART2->LCR;
;;;939        UART2_StoreReg[5] = UART2->MCR;
;;;940        UART2_StoreReg[6] = UART2->SPR;
;;;941        UART2_StoreReg[7] = UART2->STSR;
;;;942        UART2_StoreReg[8] = UART2->RX_IDLE_INTTCR;
;;;943        UART2_StoreReg[9] = UART2->RXIDLE_INTCR;
;;;944        UART2_StoreReg[10] = UART2->MISCR;
;;;945    
;;;946        return;
;;;947    }
;;;948    
;;;949    /**
;;;950      * @brief  UART2 exit dlps callback function(Resume UART2 register values when system exit DLPS)
;;;951      * @param  None
;;;952      * @retval None
;;;953      */
;;;954    DATA_RAM_FUNCTION __STATIC_INLINE void UART2_DLPS_Exit(void)
;;;955    {
;;;956        //enable log uart peripheral & clock
;;;957        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;958        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;959    
;;;960        //access DLH and DLL
;;;961        UART2->LCR |= (1 << 7);
;;;962        UART2->DLL = UART2_StoreReg[0];
;;;963        UART2->DLH_INTCR =  UART2_StoreReg[1];
;;;964        UART2->LCR &= (~(1 << 7));
;;;965    
;;;966        //access other registers
;;;967        UART2->INTID_FCR = (((UART2_StoreReg[7] & BIT24) >> 21) | ((UART2_StoreReg[7] & 0x7C000000)
;;;968                                                                   >> 18) | (1));
;;;969        UART2->LCR = UART2_StoreReg[4];
;;;970        UART2->MCR = UART2_StoreReg[5];
;;;971        UART2->SPR = UART2_StoreReg[6];
;;;972        UART2->STSR = UART2_StoreReg[7];
;;;973        UART2->DLH_INTCR = UART2_StoreReg[2];
;;;974        UART2->RX_IDLE_INTTCR = UART2_StoreReg[8];
;;;975        UART2->RXIDLE_INTCR = UART2_StoreReg[9];
;;;976        UART2->MISCR = UART2_StoreReg[10];
;;;977    
;;;978        return;
;;;979    }
;;;980    #endif
;;;981    
;;;982    
;;;983    /********************************************** ********************************************************/
;;;984    /**************************************** [ADC DLPS] **************************************************/
;;;985    /*******************************************************************************************************/
;;;986    /*******************************************************************************************************/
;;;987    
;;;988    #if USE_ADC_DLPS
;;;989    __STATIC_INLINE void ADC_DLPS_Enter(void);
;;;990    __STATIC_INLINE void ADC_DLPS_Exit(void);
;;;991    
;;;992    uint32_t ADC_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;993    
;;;994    /**
;;;995      * @brief  ADC enter dlps callback function(Save ADC register values when system enter DLPS)
;;;996      * @param  None
;;;997      * @retval None
;;;998      */
;;;999    __STATIC_INLINE void ADC_DLPS_Enter(void)
;;;1000   {
;;;1001       /*Open 10M clock source*/
;;;1002       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1003       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1004   
;;;1005       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1006       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1007   
;;;1008       ADC_StoreReg[0] =  ADC->CR;          //0x04
;;;1009       ADC_StoreReg[1] =  ADC->SCHCR;       //0x08
;;;1010       ADC_StoreReg[2] =  ADC->INTCR;       //0x0C
;;;1011       ADC_StoreReg[3] =  ADC->SCHTAB0;     //0x10
;;;1012       ADC_StoreReg[4] =  ADC->SCHTAB1;     //0x14
;;;1013       ADC_StoreReg[5] =  ADC->SCHTAB2;     //0x18
;;;1014       ADC_StoreReg[6] =  ADC->SCHTAB3;     //0x1C
;;;1015       ADC_StoreReg[7] =  ADC->SCHTAB4;     //0x20
;;;1016       ADC_StoreReg[8] =  ADC->SCHTAB5;     //0x24
;;;1017       ADC_StoreReg[9] =  ADC->SCHTAB6;     //0x28
;;;1018       ADC_StoreReg[10] =  ADC->SCHTAB6;    //0x2C
;;;1019       ADC_StoreReg[11] =  ADC->PWRDLY;
;;;1020       ADC_StoreReg[12] =  ADC->DATCLK;
;;;1021       ADC_StoreReg[13] =  ADC->ANACTL;
;;;1022   
;;;1023       uint8_t reg_value = 0;
;;;1024       reg_value = btaon_fast_read_safe(0x110);
;;;1025       btaon_fast_write(0x110, reg_value & (~0x04));
;;;1026   
;;;1027       return;
;;;1028   }
;;;1029   
;;;1030   /**
;;;1031     * @brief  ADC exit dlps callback function(Resume ADC register values when system exit DLPS)
;;;1032     * @param  None
;;;1033     * @retval None
;;;1034     */
;;;1035   DATA_RAM_FUNCTION __STATIC_INLINE void ADC_DLPS_Exit(void)
;;;1036   {
;;;1037       /*Open 10M clock source*/
;;;1038       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1039       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1040   
;;;1041       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1042       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1043   
;;;1044   #if 0
;;;1045       //Todo
;;;1046       ADC->PWRDLY = ADC_StoreReg[10];
;;;1047       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1048       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1049       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1050       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1051       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1052       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1053       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1054       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1055       ADC->SCHCR = ADC_StoreReg[1];
;;;1056       ADC->INTCR = (ADC_StoreReg[2] & 0x1F);
;;;1057   #else
;;;1058       /*Disable all interrupt.*/
;;;1059       ADC->INTCR &= (~0x1f);
;;;1060   
;;;1061       /* Set power mode first */
;;;1062       ADC->PWRDLY = ADC_StoreReg[11];
;;;1063   
;;;1064       /* Disable schedule table */
;;;1065       ADC->SCHCR &= (~0xffff);
;;;1066   
;;;1067       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1068       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1069       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1070       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1071       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1072       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1073       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1074       ADC->SCHTAB7 = ADC_StoreReg[10];
;;;1075       ADC->SCHCR   = ADC_StoreReg[1];
;;;1076       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1077       ADC->DATCLK = ADC_StoreReg[12];
;;;1078       ADC->ANACTL = ADC_StoreReg[13];
;;;1079   
;;;1080       /*Clear ADC FIFO */
;;;1081       ADC->CR |= BIT26;
;;;1082       /* Clear all interrupt */
;;;1083       ADC->INTCR |= (0x1f << 8);
;;;1084   
;;;1085       /* Restore specify interrupt */
;;;1086       ADC->INTCR = ADC_StoreReg[2];
;;;1087   
;;;1088   #endif
;;;1089   
;;;1090       uint8_t reg_value = 0;
;;;1091       reg_value = btaon_fast_read_safe(0x110);
;;;1092       btaon_fast_write(0x110, reg_value | 0x04);
;;;1093   
;;;1094       return;
;;;1095   }
;;;1096   
;;;1097   #endif
;;;1098   
;;;1099   /********************************************** ********************************************************/
;;;1100   /**************************************** [IR DLPS] **************************************************/
;;;1101   /*******************************************************************************************************/
;;;1102   /*******************************************************************************************************/
;;;1103   
;;;1104   #if USE_IR_DLPS
;;;1105   __STATIC_INLINE void IR_DLPS_Enter(void);
;;;1106   __STATIC_INLINE void IR_DLPS_Exit(void);
;;;1107   
;;;1108   uint32_t IR_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1109   
;;;1110   /**
;;;1111     * @brief  IR enter dlps callback function(Save IR register values when system enter DLPS)
;;;1112     * @param  None
;;;1113     * @retval None
;;;1114     */
;;;1115   __STATIC_INLINE void IR_DLPS_Enter(void)
;;;1116   {
;;;1117       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1118       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1119   
;;;1120       IR_StoreReg[0] = IR->CLK_DIV;
;;;1121       IR_StoreReg[1] = IR->TX_CONFIG;
;;;1122       IR_StoreReg[2] = IR->RX_CONFIG;
;;;1123       IR_StoreReg[3] = IR->RX_CNT_INT_SEL;
;;;1124   
;;;1125   
;;;1126       return;
;;;1127   }
;;;1128   
;;;1129   /**
;;;1130     * @brief  IR exit dlps callback function(Resume IR register values when system exit DLPS)
;;;1131     * @param  None
;;;1132     * @retval None
;;;1133     */
;;;1134   DATA_RAM_FUNCTION __STATIC_INLINE void IR_DLPS_Exit(void)
;;;1135   {
;;;1136       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1137       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1138   
;;;1139       IR->CLK_DIV = IR_StoreReg[0];
;;;1140       if (IR_StoreReg[1] & BIT31)
;;;1141       {
;;;1142           /* RX MODE */
;;;1143           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1144           IR->RX_CONFIG  = IR_StoreReg[2];
;;;1145           IR->RX_CNT_INT_SEL  = IR_StoreReg[3];
;;;1146       }
;;;1147       else
;;;1148       {
;;;1149           /* TX MODE */
;;;1150           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1151           /* If IR TX mode is idle, must write one data firstly */
;;;1152           IR->TX_FIFO = 0;
;;;1153       }
;;;1154   
;;;1155       return;
;;;1156   }
;;;1157   
;;;1158   #endif
;;;1159   
;;;1160   /********************************************** ********************************************************/
;;;1161   /**************************************** [GDMA DLPS] **************************************************/
;;;1162   /*******************************************************************************************************/
;;;1163   /*******************************************************************************************************/
;;;1164   
;;;1165   #if USE_GDMA_DLPS
;;;1166   
;;;1167   __STATIC_INLINE void GDMA_DLPS_Enter(void);
;;;1168   __STATIC_INLINE void GDMA_DLPS_Exit(void);
;;;1169   uint32_t GDMA_StoreReg[7];         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1170   
;;;1171   #endif
;;;1172   
;;;1173   #if USE_GDMACHANNEL0_DLPS
;;;1174   uint32_t GDMAChannel0_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1175   #endif
;;;1176   
;;;1177   #if USE_GDMACHANNEL1_DLPS
;;;1178   uint32_t GDMAChannel1_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1179   #endif
;;;1180   
;;;1181   #if USE_GDMACHANNEL2_DLPS
;;;1182   uint32_t GDMAChannel2_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1183   #endif
;;;1184   
;;;1185   #if USE_GDMACHANNEL3_DLPS
;;;1186   uint32_t GDMAChannel3_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1187   #endif
;;;1188   
;;;1189   #if USE_GDMACHANNEL4_DLPS
;;;1190   uint32_t GDMAChannel4_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1191   #endif
;;;1192   
;;;1193   #if USE_GDMACHANNEL5_DLPS
;;;1194   uint32_t GDMAChannel5_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1195   #endif
;;;1196   
;;;1197   #if USE_GDMA_DLPS
;;;1198   /**
;;;1199     * @brief  GDMA enter dlps callback function(Save GDMA register values when system enter DLPS)
;;;1200     * @param  None
;;;1201     * @retval None
;;;1202     */
;;;1203   __STATIC_INLINE void GDMA_DLPS_Enter(void)
;;;1204   {
;;;1205       SYSBLKCTRL->u_210.SOC_FUNC_EN |= SYSBLK_GDMA0_EN_Msk;
;;;1206       PERIPH->PERI_CLK_CTRL |= (SYSBLK_ACTCK_GDMA0_EN_Msk | SYSBLK_SLPCK_GDMA0_EN_Msk);
;;;1207   
;;;1208       GDMA_StoreReg[0] = GDMA_BASE->DmaCfgReg;
;;;1209       GDMA_StoreReg[1] = GDMA_BASE->ChEnReg;
;;;1210       GDMA_StoreReg[2] = GDMA_BASE->MASK_TFR;
;;;1211       GDMA_StoreReg[3] = GDMA_BASE->MASK_BLOCK;
;;;1212       GDMA_StoreReg[4] = GDMA_BASE->MASK_SRC_TRAN;
;;;1213       GDMA_StoreReg[5] = GDMA_BASE->MASK_DST_TRAN;
;;;1214       GDMA_StoreReg[6] = GDMA_BASE->MASK_ERR;
;;;1215   
;;;1216   #if USE_GDMACHANNEL0_DLPS
;;;1217       GDMAChannel0_StoreReg[0] = GDMA_Channel0->SAR;
;;;1218       GDMAChannel0_StoreReg[1] = GDMA_Channel0->DAR;
;;;1219       GDMAChannel0_StoreReg[2] = GDMA_Channel0->CTL_LOW;
;;;1220       GDMAChannel0_StoreReg[3] = GDMA_Channel0->CTL_HIGH;
;;;1221       GDMAChannel0_StoreReg[4] = GDMA_Channel0->CFG_LOW;
;;;1222       GDMAChannel0_StoreReg[5] = GDMA_Channel0->CFG_HIGH;
;;;1223   #endif
;;;1224   #if USE_GDMACHANNEL1_DLPS
;;;1225       GDMAChannel1_StoreReg[0] = GDMA_Channel1->SAR;
;;;1226       GDMAChannel1_StoreReg[1] = GDMA_Channel1->DAR;
;;;1227       GDMAChannel1_StoreReg[2] = GDMA_Channel1->CTL_LOW;
;;;1228       GDMAChannel1_StoreReg[3] = GDMA_Channel1->CTL_HIGH;
;;;1229       GDMAChannel1_StoreReg[4] = GDMA_Channel1->CFG_LOW;
;;;1230       GDMAChannel1_StoreReg[5] = GDMA_Channel1->CFG_HIGH;
;;;1231   #endif
;;;1232   #if USE_GDMACHANNEL2_DLPS
;;;1233       GDMAChannel2_StoreReg[0] = GDMA_Channel2->SAR;
;;;1234       GDMAChannel2_StoreReg[1] = GDMA_Channel2->DAR;
;;;1235       GDMAChannel2_StoreReg[2] = GDMA_Channel2->CTL_LOW;
;;;1236       GDMAChannel2_StoreReg[3] = GDMA_Channel2->CTL_HIGH;
;;;1237       GDMAChannel2_StoreReg[4] = GDMA_Channel2->CFG_LOW;
;;;1238       GDMAChannel2_StoreReg[5] = GDMA_Channel2->CFG_HIGH;
;;;1239   #endif
;;;1240   #if USE_GDMACHANNEL3_DLPS
;;;1241       GDMAChannel3_StoreReg[0] = GDMA_Channel3->SAR;
;;;1242       GDMAChannel3_StoreReg[1] = GDMA_Channel3->DAR;
;;;1243       GDMAChannel3_StoreReg[2] = GDMA_Channel3->CTL_LOW;
;;;1244       GDMAChannel3_StoreReg[3] = GDMA_Channel3->CTL_HIGH;
;;;1245       GDMAChannel3_StoreReg[4] = GDMA_Channel3->CFG_LOW;
;;;1246       GDMAChannel3_StoreReg[5] = GDMA_Channel3->CFG_HIGH;
;;;1247   #endif
;;;1248   #if USE_GDMACHANNEL4_DLPS
;;;1249       GDMAChannel4_StoreReg[0] = GDMA_Channel4->SAR;
;;;1250       GDMAChannel4_StoreReg[1] = GDMA_Channel4->DAR;
;;;1251       GDMAChannel4_StoreReg[2] = GDMA_Channel4->CTL_LOW;
;;;1252       GDMAChannel4_StoreReg[3] = GDMA_Channel4->CTL_HIGH;
;;;1253       GDMAChannel4_StoreReg[4] = GDMA_Channel4->CFG_LOW;
;;;1254       GDMAChannel4_StoreReg[5] = GDMA_Channel4->CFG_HIGH;
;;;1255   #endif
;;;1256   #if USE_GDMACHANNEL5_DLPS
;;;1257       GDMAChannel5_StoreReg[0] = GDMA_Channel5->SAR;
;;;1258       GDMAChannel5_StoreReg[1] = GDMA_Channel5->DAR;
;;;1259       GDMAChannel5_StoreReg[2] = GDMA_Channel5->CTL_LOW;
;;;1260       GDMAChannel5_StoreReg[3] = GDMA_Channel5->CTL_HIGH;
;;;1261       GDMAChannel5_StoreReg[4] = GDMA_Channel5->CFG_LOW;
;;;1262       GDMAChannel5_StoreReg[5] = GDMA_Channel5->CFG_HIGH;
;;;1263   #endif
;;;1264   }
;;;1265   
;;;1266   /**
;;;1267     * @brief  GDMA exit dlps callback function(Resume GDMA register values when system exit DLPS)
;;;1268     * @param  None
;;;1269     * @retval None
;;;1270     */
;;;1271   DATA_RAM_FUNCTION __STATIC_INLINE void GDMA_DLPS_Exit(void)
;;;1272   {
;;;1273       SYSBLKCTRL->u_210.SOC_FUNC_EN |= SYSBLK_GDMA0_EN_Msk;
;;;1274       PERIPH->PERI_CLK_CTRL |= (SYSBLK_ACTCK_GDMA0_EN_Msk | SYSBLK_SLPCK_GDMA0_EN_Msk);
;;;1275   
;;;1276       /* Enable GDMA in DmaCfgReg*/
;;;1277       GDMA_BASE->DmaCfgReg = GDMA_StoreReg[0];
;;;1278   
;;;1279       /*----------clear pending all interrupts of GDMA channel-----------*/
;;;1280       GDMA_BASE->CLEAR_TFR = 0xff;
;;;1281       GDMA_BASE->CLEAR_BLOCK = 0xff;
;;;1282       GDMA_BASE->CLEAR_DST_TRAN = 0xff;
;;;1283       GDMA_BASE->CLEAR_SRC_TRAN = 0xff;
;;;1284       GDMA_BASE->CLEAR_ERR = 0xff;
;;;1285   
;;;1286       /*--------------------mask interrupt-------- -----------------*/
;;;1287       GDMA_BASE->MASK_TFR = (GDMA_StoreReg[2] | ((GDMA_StoreReg[2] & 0xff) << 8));
;;;1288       GDMA_BASE->MASK_BLOCK = (GDMA_StoreReg[3] | ((GDMA_StoreReg[3] & 0xff) << 8));
;;;1289       GDMA_BASE->MASK_SRC_TRAN = (GDMA_StoreReg[4] | ((GDMA_StoreReg[4] & 0xff) << 8));
;;;1290       GDMA_BASE->MASK_DST_TRAN = (GDMA_StoreReg[5] | ((GDMA_StoreReg[5] & 0xff) << 8));
;;;1291       GDMA_BASE->MASK_ERR = (GDMA_StoreReg[6] | ((GDMA_StoreReg[6] & 0xff) << 8));
;;;1292   
;;;1293   #if USE_GDMACHANNEL0_DLPS
;;;1294       GDMA_Channel0->SAR      = GDMAChannel0_StoreReg[0];
;;;1295       GDMA_Channel0->DAR      = GDMAChannel0_StoreReg[1];
;;;1296       GDMA_Channel0->CTL_LOW  = GDMAChannel0_StoreReg[2];
;;;1297       GDMA_Channel0->CTL_HIGH = GDMAChannel0_StoreReg[3];
;;;1298       GDMA_Channel0->CFG_LOW  = GDMAChannel0_StoreReg[4];
;;;1299       GDMA_Channel0->CFG_HIGH = GDMAChannel0_StoreReg[5];
;;;1300   #endif
;;;1301   #if USE_GDMACHANNEL1_DLPS
;;;1302       GDMA_Channel1->SAR      = GDMAChannel1_StoreReg[0];
;;;1303       GDMA_Channel1->DAR      = GDMAChannel1_StoreReg[1];
;;;1304       GDMA_Channel1->CTL_LOW  = GDMAChannel1_StoreReg[2];
;;;1305       GDMA_Channel1->CTL_HIGH = GDMAChannel1_StoreReg[3];
;;;1306       GDMA_Channel1->CFG_LOW  = GDMAChannel1_StoreReg[4];
;;;1307       GDMA_Channel1->CFG_HIGH = GDMAChannel1_StoreReg[5];
;;;1308   #endif
;;;1309   #if USE_GDMACHANNEL2_DLPS
;;;1310       GDMA_Channel2->SAR      = GDMAChannel2_StoreReg[0];
;;;1311       GDMA_Channel2->DAR      = GDMAChannel2_StoreReg[1];
;;;1312       GDMA_Channel2->CTL_LOW  = GDMAChannel2_StoreReg[2];
;;;1313       GDMA_Channel2->CTL_HIGH = GDMAChannel2_StoreReg[3];
;;;1314       GDMA_Channel2->CFG_LOW  = GDMAChannel2_StoreReg[4];
;;;1315       GDMA_Channel2->CFG_HIGH = GDMAChannel2_StoreReg[5];
;;;1316   #endif
;;;1317   #if USE_GDMACHANNEL3_DLPS
;;;1318       GDMA_Channel3->SAR      = GDMAChannel3_StoreReg[0];
;;;1319       GDMA_Channel3->DAR      = GDMAChannel3_StoreReg[1];
;;;1320       GDMA_Channel3->CTL_LOW  = GDMAChannel3_StoreReg[2];
;;;1321       GDMA_Channel3->CTL_HIGH = GDMAChannel3_StoreReg[3];
;;;1322       GDMA_Channel3->CFG_LOW  = GDMAChannel3_StoreReg[4];
;;;1323       GDMA_Channel3->CFG_HIGH = GDMAChannel3_StoreReg[5];
;;;1324   #endif
;;;1325   #if USE_GDMACHANNEL4_DLPS
;;;1326       GDMA_Channel4->SAR      = GDMAChannel4_StoreReg[0];
;;;1327       GDMA_Channel4->DAR      = GDMAChannel4_StoreReg[1];
;;;1328       GDMA_Channel4->CTL_LOW  = GDMAChannel4_StoreReg[2];
;;;1329       GDMA_Channel4->CTL_HIGH = GDMAChannel4_StoreReg[3];
;;;1330       GDMA_Channel4->CFG_LOW  = GDMAChannel4_StoreReg[4];
;;;1331       GDMA_Channel4->CFG_HIGH = GDMAChannel4_StoreReg[5];
;;;1332   #endif
;;;1333   #if USE_GDMACHANNEL5_DLPS
;;;1334       GDMA_Channel5->SAR      = GDMAChannel5_StoreReg[0];
;;;1335       GDMA_Channel5->DAR      = GDMAChannel5_StoreReg[1];
;;;1336       GDMA_Channel5->CTL_LOW  = GDMAChannel5_StoreReg[2];
;;;1337       GDMA_Channel5->CTL_HIGH = GDMAChannel5_StoreReg[3];
;;;1338       GDMA_Channel5->CFG_LOW  = GDMAChannel5_StoreReg[4];
;;;1339       GDMA_Channel5->CFG_HIGH = GDMAChannel5_StoreReg[5];
;;;1340   #endif
;;;1341   
;;;1342       /*----------clear pending all interrupts of GDMA channel before enable channel-----------*/
;;;1343       GDMA_BASE->CLEAR_TFR = 0x3f;
;;;1344       GDMA_BASE->CLEAR_BLOCK = 0x3f;
;;;1345       GDMA_BASE->CLEAR_DST_TRAN = 0x3f;
;;;1346       GDMA_BASE->CLEAR_SRC_TRAN = 0x3f;
;;;1347       GDMA_BASE->CLEAR_ERR = 0x3f;
;;;1348   
;;;1349       /* Enable the selected DMA Channelx */
;;;1350   //    GDMA_BASE->ChEnReg = GDMA_StoreReg[1];
;;;1351   }
;;;1352   #endif
;;;1353   
;;;1354   /********************************************** ********************************************************/
;;;1355   /**************************************** [LCD DLPS] ************************************************/
;;;1356   /*******************************************************************************************************/
;;;1357   /*******************************************************************************************************/
;;;1358   #if USE_LCD_DLPS
;;;1359   
;;;1360   uint32_t LCD_StoreReg[5];
;;;1361   
;;;1362   /**
;;;1363     * @brief  LCD enter dlps callback function(Save LCD register values when system enter DLPS)
;;;1364     * @param  None
;;;1365     * @retval None
;;;1366     */
;;;1367   __STATIC_INLINE void LCD_DLPS_Enter(void)
;;;1368   {
;;;1369       /* Enable LCD 8080 interface controller function */
;;;1370       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1371       /* Enable LCD 8080 interface controller clock */
;;;1372       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1373   
;;;1374       LCD_StoreReg[0] = *((volatile uint32_t *)0x400002A8UL) & (0x03 << 28);
;;;1375       LCD_StoreReg[1] = LCD->IMR;
;;;1376       LCD_StoreReg[2] = LCD->CTRL0;
;;;1377       LCD_StoreReg[3] = LCD->CTRL1;
;;;1378       LCD_StoreReg[4] = LCD->CFG;
;;;1379   
;;;1380   }
;;;1381   
;;;1382   /**
;;;1383     * @brief  LCD exit dlps callback function(Resume LCD register values when system exit DLPS)
;;;1384     * @param  None
;;;1385     * @retval None
;;;1386     */
;;;1387   DATA_RAM_FUNCTION __STATIC_INLINE void LCD_DLPS_Exit(void)
;;;1388   {
;;;1389       /* Enable LCD 8080 interface controller function */
;;;1390       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1391       /* Enable LCD 8080 interface controller clock */
;;;1392       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1393   
;;;1394       /* Restore Dedicated SDIO pin option */
;;;1395       *((volatile uint32_t *)0x400002A8UL) &= ~(0x03 << 28);
;;;1396       *((volatile uint32_t *)0x400002A8UL) |= LCD_StoreReg[0];
;;;1397   
;;;1398       /* Initialize LCD */
;;;1399   
;;;1400       LCD->IMR    = LCD_StoreReg[1];
;;;1401       LCD->CTRL1  = LCD_StoreReg[3];
;;;1402       LCD->CFG    = LCD_StoreReg[4];
;;;1403       LCD->CTRL0  = LCD_StoreReg[2];
;;;1404   }
;;;1405   #endif
;;;1406   
;;;1407   /********************************************** ********************************************************/
;;;1408   /**************************************** [I2S0 DLPS] **************************************************/
;;;1409   /*******************************************************************************************************/
;;;1410   /*******************************************************************************************************/
;;;1411   #if USE_I2S0_DLPS
;;;1412   
;;;1413   uint32_t I2S0_StoreReg[4];
;;;1414   
;;;1415   /**
;;;1416     * @brief  I2S0 enter dlps callback function(Save I2S0 register values when system enter DLPS)
;;;1417     * @param  None
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void I2S0_DLPS_Enter(void)
;;;1421   {
;;;1422       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1423   
;;;1424       I2S0_StoreReg[0] = I2S0->BCLK_DIV;
;;;1425       I2S0_StoreReg[1] = I2S0->CTRL0;
;;;1426       I2S0_StoreReg[2] = I2S0->CTRL1;
;;;1427       I2S0_StoreReg[3] = I2S0->DMA_TRDLR;
;;;1428   }
;;;1429   
;;;1430   /**
;;;1431     * @brief  I2S0 exit dlps callback function(Resume I2S0 register values when system exit DLPS)
;;;1432     * @param  None
;;;1433     * @retval None
;;;1434     */
;;;1435   DATA_RAM_FUNCTION __STATIC_INLINE void I2S0_DLPS_Exit(void)
;;;1436   {
;;;1437       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1438   
;;;1439       /* Reset I2S0 module */
;;;1440       I2S0->CTRL0 |= 1 << 0;
;;;1441       I2S0->CTRL0 &= ~(1 << 0);
;;;1442   
;;;1443       /* Initialize I2S0 */
;;;1444       I2S0->BCLK_DIV  = I2S0_StoreReg[0];
;;;1445       I2S0->CTRL1     = I2S0_StoreReg[2];
;;;1446       I2S0->DMA_TRDLR = I2S0_StoreReg[3];
;;;1447       I2S0->CTRL0     = I2S0_StoreReg[1];
;;;1448   }
;;;1449   #endif
;;;1450   
;;;1451   /********************************************** ********************************************************/
;;;1452   /**************************************** [I2S1 DLPS] **************************************************/
;;;1453   /*******************************************************************************************************/
;;;1454   /*******************************************************************************************************/
;;;1455   #if USE_I2S1_DLPS
;;;1456   
;;;1457   uint32_t I2S1_StoreReg[4];
;;;1458   
;;;1459   /**
;;;1460     * @brief  I2S1 enter dlps callback function(Save I2S1 register values when system enter DLPS)
;;;1461     * @param  None
;;;1462     * @retval None
;;;1463     */
;;;1464   __STATIC_INLINE void I2S1_DLPS_Enter(void)
;;;1465   {
;;;1466       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1467   
;;;1468       I2S1_StoreReg[0] = I2S1->BCLK_DIV;
;;;1469       I2S1_StoreReg[1] = I2S1->CTRL0;
;;;1470       I2S1_StoreReg[2] = I2S1->CTRL1;
;;;1471       I2S1_StoreReg[3] = I2S1->DMA_TRDLR;
;;;1472   }
;;;1473   
;;;1474   /**
;;;1475     * @brief  I2S1 exit dlps callback function(Resume I2S1 register values when system exit DLPS)
;;;1476     * @param  None
;;;1477     * @retval None
;;;1478     */
;;;1479   DATA_RAM_FUNCTION __STATIC_INLINE void I2S1_DLPS_Exit(void)
;;;1480   {
;;;1481       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1482   
;;;1483       /* Reset I2S1 module */
;;;1484       I2S1->CTRL0 |= 1 << 0;
;;;1485       I2S1->CTRL0 &= ~(1 << 0);
;;;1486   
;;;1487       /* Initialize I2S1 */
;;;1488       I2S1->BCLK_DIV  = I2S1_StoreReg[0];
;;;1489       I2S1->CTRL1     = I2S1_StoreReg[2];
;;;1490       I2S1->DMA_TRDLR = I2S1_StoreReg[3];
;;;1491       I2S1->CTRL0     = I2S1_StoreReg[1];
;;;1492   }
;;;1493   #endif
;;;1494   
;;;1495   /********************************************** ********************************************************/
;;;1496   /**************************************** [CODEC DLPS] ************************************************/
;;;1497   /*******************************************************************************************************/
;;;1498   /*******************************************************************************************************/
;;;1499   #if USE_CODEC_DLPS
;;;1500   
;;;1501   uint32_t CODEC_StoreReg[7];
;;;1502   
;;;1503   /**
;;;1504     * @brief  CODEC enter dlps callback function(Save CODEC register values when system enter DLPS)
;;;1505     * @param  None
;;;1506     * @retval None
;;;1507     */
;;;1508   __STATIC_INLINE void CODEC_DLPS_Enter(void)
;;;1509   {
;;;1510       /* Enable codec function and clock */
;;;1511       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1512   
;;;1513       CODEC_StoreReg[0] = CODEC->CR0;
;;;1514       CODEC_StoreReg[1] = CODEC->CR1;
;;;1515       CODEC_StoreReg[2] = CODEC->CR2;
;;;1516       CODEC_StoreReg[3] = CODEC->CLK_CTRL;
;;;1517       CODEC_StoreReg[4] = CODEC->I2S_CTRL;
;;;1518       CODEC_StoreReg[5] = CODEC->ADC_CTRL;
;;;1519       CODEC_StoreReg[6] = CODEC->DAC_CTRL;
;;;1520   }
;;;1521   
;;;1522   /**
;;;1523     * @brief  CODEC exit dlps callback function(Resume CODEC register values when system exit DLPS)
;;;1524     * @param  None
;;;1525     * @retval None
;;;1526     */
;;;1527   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_DLPS_Exit(void)
;;;1528   {
;;;1529       /* Enable codec function and clock */
;;;1530       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1531   
;;;1532       /* Initialize CODEC */
;;;1533       if ((CODEC_StoreReg[3] & 0x900) == 0x900)
;;;1534       {
;;;1535           /* Configure AMIC parameters */
;;;1536           CODEC->CR0 = CODEC_StoreReg[0];
;;;1537           CODEC->CR1 = CODEC_StoreReg[1];
;;;1538           CODEC->CR2 = CODEC_StoreReg[2];
;;;1539       }
;;;1540   
;;;1541       /*  Reset audio digital IP */
;;;1542       CODEC->AUDIO_CTRL = 0;
;;;1543       CODEC->AUDIO_CTRL = 1;
;;;1544   
;;;1545       CODEC->CLK_CTRL = CODEC_StoreReg[3];
;;;1546       CODEC->I2S_CTRL = CODEC_StoreReg[4];
;;;1547       CODEC->ADC_CTRL = CODEC_StoreReg[5];
;;;1548       CODEC->DAC_CTRL = CODEC_StoreReg[6];
;;;1549   }
;;;1550   #endif
;;;1551   
;;;1552   /********************************************** ********************************************************/
;;;1553   /**************************************** [CODEC_EQ1 DLPS] ************************************************/
;;;1554   /*******************************************************************************************************/
;;;1555   /*******************************************************************************************************/
;;;1556   #if USE_CODEC_EQ1_DLPS
;;;1557   
;;;1558   uint32_t CODEC_EQ1_StoreReg[5];
;;;1559   
;;;1560   /**
;;;1561     * @brief  CODEC_EQ1 enter dlps callback function(Save CODEC_EQ1 register values when system enter DLPS)
;;;1562     * @param  None
;;;1563     * @retval None
;;;1564     */
;;;1565   __STATIC_INLINE void CODEC_EQ1_DLPS_Enter(void)
;;;1566   {
;;;1567       /* Enable codec function and clock */
;;;1568       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1569   
;;;1570       CODEC_EQ1_StoreReg[0] = CODEC_EQ1->EQ_H0;
;;;1571       CODEC_EQ1_StoreReg[1] = CODEC_EQ1->EQ_B1;
;;;1572       CODEC_EQ1_StoreReg[2] = CODEC_EQ1->EQ_B2;
;;;1573       CODEC_EQ1_StoreReg[3] = CODEC_EQ1->EQ_A1;
;;;1574       CODEC_EQ1_StoreReg[4] = CODEC_EQ1->EQ_A2;
;;;1575   }
;;;1576   
;;;1577   /**
;;;1578     * @brief  CODEC_EQ1 exit dlps callback function(Resume CODEC_EQ1 register values when system exit DLPS)
;;;1579     * @param  None
;;;1580     * @retval None
;;;1581     */
;;;1582   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ1_DLPS_Exit(void)
;;;1583   {
;;;1584       /* Enable codec function and clock */
;;;1585       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1586   
;;;1587       CODEC_EQ1->EQ_H0 = CODEC_EQ1_StoreReg[0];
;;;1588       CODEC_EQ1->EQ_B1 = CODEC_EQ1_StoreReg[1];
;;;1589       CODEC_EQ1->EQ_B2 = CODEC_EQ1_StoreReg[2];
;;;1590       CODEC_EQ1->EQ_A1 = CODEC_EQ1_StoreReg[3];
;;;1591       CODEC_EQ1->EQ_A2 = CODEC_EQ1_StoreReg[4];
;;;1592   }
;;;1593   #endif
;;;1594   
;;;1595   /********************************************** ********************************************************/
;;;1596   /**************************************** [CODEC_EQ2 DLPS] ************************************************/
;;;1597   /*******************************************************************************************************/
;;;1598   /*******************************************************************************************************/
;;;1599   #if USE_CODEC_EQ2_DLPS
;;;1600   
;;;1601   uint32_t CODEC_EQ2_StoreReg[5];
;;;1602   
;;;1603   /**
;;;1604     * @brief  CODEC_EQ2 enter dlps callback function(Save CODEC_EQ2 register values when system enter DLPS)
;;;1605     * @param  None
;;;1606     * @retval None
;;;1607     */
;;;1608   __STATIC_INLINE void CODEC_EQ2_DLPS_Enter(void)
;;;1609   {
;;;1610       /* Enable codec function and clock */
;;;1611       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1612   
;;;1613       CODEC_EQ2_StoreReg[0] = CODEC_EQ2->EQ_H0;
;;;1614       CODEC_EQ2_StoreReg[1] = CODEC_EQ2->EQ_B1;
;;;1615       CODEC_EQ2_StoreReg[2] = CODEC_EQ2->EQ_B2;
;;;1616       CODEC_EQ2_StoreReg[3] = CODEC_EQ2->EQ_A1;
;;;1617       CODEC_EQ2_StoreReg[4] = CODEC_EQ2->EQ_A2;
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  CODEC_EQ2 exit dlps callback function(Resume CODEC_EQ2 register values when system exit DLPS)
;;;1622     * @param  None
;;;1623     * @retval None
;;;1624     */
;;;1625   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ2_DLPS_Exit(void)
;;;1626   {
;;;1627       /* Enable codec function and clock */
;;;1628       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1629   
;;;1630       CODEC_EQ2->EQ_H0 = CODEC_EQ2_StoreReg[0];
;;;1631       CODEC_EQ2->EQ_B1 = CODEC_EQ2_StoreReg[1];
;;;1632       CODEC_EQ2->EQ_B2 = CODEC_EQ2_StoreReg[2];
;;;1633       CODEC_EQ2->EQ_A1 = CODEC_EQ2_StoreReg[3];
;;;1634       CODEC_EQ2->EQ_A2 = CODEC_EQ2_StoreReg[4];
;;;1635   }
;;;1636   #endif
;;;1637   
;;;1638   /********************************************** ********************************************************/
;;;1639   /**************************************** [CODEC_EQ3 DLPS] ************************************************/
;;;1640   /*******************************************************************************************************/
;;;1641   /*******************************************************************************************************/
;;;1642   #if USE_CODEC_EQ3_DLPS
;;;1643   
;;;1644   uint32_t CODEC_EQ3_StoreReg[5];
;;;1645   
;;;1646   /**
;;;1647     * @brief  CODEC_EQ3 enter dlps callback function(Save CODEC_EQ3 register values when system enter DLPS)
;;;1648     * @param  None
;;;1649     * @retval None
;;;1650     */
;;;1651   __STATIC_INLINE void CODEC_EQ3_DLPS_Enter(void)
;;;1652   {
;;;1653       /* Enable codec function and clock */
;;;1654       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1655   
;;;1656       CODEC_EQ3_StoreReg[0] = CODEC_EQ3->EQ_H0;
;;;1657       CODEC_EQ3_StoreReg[1] = CODEC_EQ3->EQ_B1;
;;;1658       CODEC_EQ3_StoreReg[2] = CODEC_EQ3->EQ_B2;
;;;1659       CODEC_EQ3_StoreReg[3] = CODEC_EQ3->EQ_A1;
;;;1660       CODEC_EQ3_StoreReg[4] = CODEC_EQ3->EQ_A2;
;;;1661   }
;;;1662   
;;;1663   /**
;;;1664     * @brief  CODEC_EQ3 exit dlps callback function(Resume CODEC_EQ3 register values when system exit DLPS)
;;;1665     * @param  None
;;;1666     * @retval None
;;;1667     */
;;;1668   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ3_DLPS_Exit(void)
;;;1669   {
;;;1670       /* Enable codec function and clock */
;;;1671       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1672   
;;;1673       CODEC_EQ3->EQ_H0 = CODEC_EQ3_StoreReg[0];
;;;1674       CODEC_EQ3->EQ_B1 = CODEC_EQ3_StoreReg[1];
;;;1675       CODEC_EQ3->EQ_B2 = CODEC_EQ3_StoreReg[2];
;;;1676       CODEC_EQ3->EQ_A1 = CODEC_EQ3_StoreReg[3];
;;;1677       CODEC_EQ3->EQ_A2 = CODEC_EQ3_StoreReg[4];
;;;1678   }
;;;1679   #endif
;;;1680   
;;;1681   /********************************************** ********************************************************/
;;;1682   /**************************************** [CODEC_EQ4 DLPS] ************************************************/
;;;1683   /*******************************************************************************************************/
;;;1684   /*******************************************************************************************************/
;;;1685   #if USE_CODEC_EQ4_DLPS
;;;1686   
;;;1687   uint32_t CODEC_EQ4_StoreReg[5];
;;;1688   
;;;1689   /**
;;;1690     * @brief  CODEC_EQ4 enter dlps callback function(Save CODEC_EQ4 register values when system enter DLPS)
;;;1691     * @param  None
;;;1692     * @retval None
;;;1693     */
;;;1694   __STATIC_INLINE void CODEC_EQ4_DLPS_Enter(void)
;;;1695   {
;;;1696       /* Enable codec function and clock */
;;;1697       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1698   
;;;1699       CODEC_EQ4_StoreReg[0] = CODEC_EQ4->EQ_H0;
;;;1700       CODEC_EQ4_StoreReg[1] = CODEC_EQ4->EQ_B1;
;;;1701       CODEC_EQ4_StoreReg[2] = CODEC_EQ4->EQ_B2;
;;;1702       CODEC_EQ4_StoreReg[3] = CODEC_EQ4->EQ_A1;
;;;1703       CODEC_EQ4_StoreReg[4] = CODEC_EQ4->EQ_A2;
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  CODEC_EQ4 exit dlps callback function(Resume CODEC_EQ4 register values when system exit DLPS)
;;;1708     * @param  None
;;;1709     * @retval None
;;;1710     */
;;;1711   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ4_DLPS_Exit(void)
;;;1712   {
;;;1713       /* Enable codec function and clock */
;;;1714       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1715   
;;;1716       CODEC_EQ4->EQ_H0 = CODEC_EQ4_StoreReg[0];
;;;1717       CODEC_EQ4->EQ_B1 = CODEC_EQ4_StoreReg[1];
;;;1718       CODEC_EQ4->EQ_B2 = CODEC_EQ4_StoreReg[2];
;;;1719       CODEC_EQ4->EQ_A1 = CODEC_EQ4_StoreReg[3];
;;;1720       CODEC_EQ4->EQ_A2 = CODEC_EQ4_StoreReg[4];
;;;1721   }
;;;1722   #endif
;;;1723   
;;;1724   /********************************************** ********************************************************/
;;;1725   /**************************************** [CODEC_EQ5 DLPS] ************************************************/
;;;1726   /*******************************************************************************************************/
;;;1727   /*******************************************************************************************************/
;;;1728   #if USE_CODEC_EQ5_DLPS
;;;1729   
;;;1730   uint32_t CODEC_EQ5_StoreReg[5];
;;;1731   
;;;1732   /**
;;;1733     * @brief  CODEC_EQ5 enter dlps callback function(Save CODEC_EQ5 register values when system enter DLPS)
;;;1734     * @param  None
;;;1735     * @retval None
;;;1736     */
;;;1737   __STATIC_INLINE void CODEC_EQ5_DLPS_Enter(void)
;;;1738   {
;;;1739       /* Enable codec function and clock */
;;;1740       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1741   
;;;1742       CODEC_EQ5_StoreReg[0] = CODEC_EQ5->EQ_H0;
;;;1743       CODEC_EQ5_StoreReg[1] = CODEC_EQ5->EQ_B1;
;;;1744       CODEC_EQ5_StoreReg[2] = CODEC_EQ5->EQ_B2;
;;;1745       CODEC_EQ5_StoreReg[3] = CODEC_EQ5->EQ_A1;
;;;1746       CODEC_EQ5_StoreReg[4] = CODEC_EQ5->EQ_A2;
;;;1747   }
;;;1748   
;;;1749   /**
;;;1750     * @brief  CODEC_EQ5 exit dlps callback function(Resume CODEC_EQ5 register values when system exit DLPS)
;;;1751     * @param  None
;;;1752     * @retval None
;;;1753     */
;;;1754   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ5_DLPS_Exit(void)
;;;1755   {
;;;1756       /* Enable codec function and clock */
;;;1757       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1758   
;;;1759       CODEC_EQ5->EQ_H0 = CODEC_EQ5_StoreReg[0];
;;;1760       CODEC_EQ5->EQ_B1 = CODEC_EQ5_StoreReg[1];
;;;1761       CODEC_EQ5->EQ_B2 = CODEC_EQ5_StoreReg[2];
;;;1762       CODEC_EQ5->EQ_A1 = CODEC_EQ5_StoreReg[3];
;;;1763       CODEC_EQ5->EQ_A2 = CODEC_EQ5_StoreReg[4];
;;;1764   }
;;;1765   #endif
;;;1766   
;;;1767   /**
;;;1768     * @brief  Set Log and SWD pins to SW mode.
;;;1769     * @param  void.
;;;1770     * @retval void.
;;;1771     */
;;;1772   __STATIC_INLINE void Log_SWD_DLPS_Enter(void)
;;;1773   {
;;;1774       if (OTP->SWD_ENABLE)
;;;1775       {
;;;1776           Pad_Config(P1_0, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1777           Pad_Config(P1_1, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1778       }
;;;1779   
;;;1780       Pad_Config(OTP->logPin, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1781   
;;;1782   }
;;;1783   
;;;1784   /**
;;;1785     * @brief  Set Log and SWD pins to PINMUX mode.
;;;1786     * @param  void.
;;;1787     * @retval void.
;;;1788     */
;;;1789   DATA_RAM_FUNCTION __STATIC_INLINE void Log_SWD_DLPS_Exit(void)
;;;1790   {
;;;1791       Pad_Config(OTP->logPin, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1792   
;;;1793       if (OTP->SWD_ENABLE)
;;;1794       {
;;;1795           Pad_Config(P1_0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1796           Pad_Config(P1_1, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1797       }
;;;1798   }
;;;1799   
;;;1800   /********************************************** ********************************************************/
;;;1801   /*********************************** [USER Exit DLPS CALLBACK FUCN] *****************************************/
;;;1802   /*******************************************************************************************************/
;;;1803   /*******************************************************************************************************/
;;;1804   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;1805   
;;;1806   DLPS_IO_ExitDlpsCB User_IO_ExitDlpsCB = NULL;
;;;1807   
;;;1808   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1809   
;;;1810   /********************************************** ********************************************************/
;;;1811   /*********************************** [USER Enter DLPS CALLBACK FUCN] *****************************************/
;;;1812   /*******************************************************************************************************/
;;;1813   /*******************************************************************************************************/
;;;1814   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1815   
;;;1816   DLPS_IO_EnterDlpsCB User_IO_EnterDlpsCB = NULL;
;;;1817   
;;;1818   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1819   
;;;1820   /********************************************** ********************************************************/
;;;1821   /*********************************** [Enter & Exit DLPS CALLBACK FUNC] *********************************/
;;;1822   /*******************************************************************************************************/
;;;1823   /*******************************************************************************************************/
;;;1824   #if USE_IO_DRIVER_DLPS
;;;1825   
;;;1826   /**
;;;1827     * @brief  IO enter dlps callback function
;;;1828     * @param  None
;;;1829     * @retval None
;;;1830     */
;;;1831   void DLPS_IO_EnterDlpsCb(void)
;;;1832   {
;;;1833       /* low stack do it instead */
;;;1834   //    Pad_ClearAllWakeupINT();
;;;1835   
;;;1836   //    DBG_DIRECT("DLPS_IO_EnterDlpsCb");
;;;1837       NVIC_DisableIRQ(System_IRQn);
;;;1838       CPU_DLPS_Enter();
;;;1839   
;;;1840       Pinmux_DLPS_Enter();
;;;1841   
;;;1842   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1843       if (User_IO_EnterDlpsCB)
        0x0080e7a0:    6898        .h      LDR      r0,[r3,#8]
        0x0080e7a2:    b100        ..      CBZ      r0,0x80e7a6 ; DLPS_IO_EnterDlpsCb + 106
;;;1844       {
;;;1845           User_IO_EnterDlpsCB();
        0x0080e7a4:    4780        .G      BLX      r0
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_io_dlps.c (154)
        0x0080e7a6:    f04f4280    O..B    MOV      r2,#0x40000000
        0x0080e7aa:    f8d2021c    ....    LDR      r0,[r2,#0x21c]
        0x0080e7ae:    f4407080    @..p    ORR      r0,r0,#0x100
        0x0080e7b2:    f8c2021c    ....    STR      r0,[r2,#0x21c]
;;;155        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
        0x0080e7b6:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x0080e7ba:    f0407040    @.@p    ORR      r0,r0,#0x3000000
        0x0080e7be:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;156    
;;;157        GPIO_StoreReg[0] = GPIO->DATAOUT;
        0x0080e7c2:    4924        $I      LDR      r1,[pc,#144] ; [0x80e854] = 0x40001000
        0x0080e7c4:    680b        .h      LDR      r3,[r1,#0]
        0x0080e7c6:    4820         H      LDR      r0,[pc,#128] ; [0x80e848] = 0x207f38
        0x0080e7c8:    30ac        .0      ADDS     r0,r0,#0xac
;;;158        GPIO_StoreReg[1] = GPIO->DATADIR;
        0x0080e7ca:    6003        .`      STR      r3,[r0,#0]
        0x0080e7cc:    684b        Kh      LDR      r3,[r1,#4]
;;;159        GPIO_StoreReg[2] = GPIO->DATASRC;
        0x0080e7ce:    6043        C`      STR      r3,[r0,#4]
        0x0080e7d0:    688b        .h      LDR      r3,[r1,#8]
;;;160        GPIO_StoreReg[3] = GPIO->INTEN;
        0x0080e7d2:    6083        .`      STR      r3,[r0,#8]
        0x0080e7d4:    6b0b        .k      LDR      r3,[r1,#0x30]
;;;161        GPIO_StoreReg[4] = GPIO->INTMASK;
        0x0080e7d6:    60c3        .`      STR      r3,[r0,#0xc]
        0x0080e7d8:    6b4b        Kk      LDR      r3,[r1,#0x34]
;;;162        GPIO_StoreReg[5] = GPIO->INTTYPE;
        0x0080e7da:    6103        .a      STR      r3,[r0,#0x10]
        0x0080e7dc:    6b8b        .k      LDR      r3,[r1,#0x38]
;;;163        GPIO_StoreReg[6] = GPIO->INTPOLARITY;
        0x0080e7de:    6143        Ca      STR      r3,[r0,#0x14]
        0x0080e7e0:    6bcb        .k      LDR      r3,[r1,#0x3c]
;;;164        GPIO_StoreReg[7] = GPIO->DEBOUNCE;
        0x0080e7e2:    6183        .a      STR      r3,[r0,#0x18]
        0x0080e7e4:    6c89        .l      LDR      r1,[r1,#0x48]
;;;165        GPIO_StoreReg[8] = *(__IO uint32_t *)(0x40000344UL);
        0x0080e7e6:    61c1        .a      STR      r1,[r0,#0x1c]
        0x0080e7e8:    f8d21344    ..D.    LDR      r1,[r2,#0x344]
;;;166    
;;;167        return;
;;;168    }
;;;169    
;;;170    /**
;;;171      * @brief  GPIO exit dlps callback function(Resume GPIO register values when system exit DLPS)
;;;172      * @param  None
;;;173      * @retval None
;;;174      */
;;;175    DATA_RAM_FUNCTION __STATIC_INLINE void GPIO_DLPS_Exit(void)
;;;176    {
;;;177        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;178        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;179    
;;;180        GPIO->DATADIR       = GPIO_StoreReg[1];
;;;181        GPIO->DATASRC       = GPIO_StoreReg[2];
;;;182        GPIO->INTMASK       = GPIO_StoreReg[4];
;;;183        GPIO->INTTYPE       = GPIO_StoreReg[5];
;;;184        GPIO->INTPOLARITY   = GPIO_StoreReg[6];
;;;185        GPIO->DEBOUNCE      = GPIO_StoreReg[7];
;;;186        GPIO->DATAOUT       = GPIO_StoreReg[0];
;;;187        GPIO->INTCLR        = ~(GPIO_StoreReg[1]);
;;;188        GPIO->INTEN         = GPIO_StoreReg[3];
;;;189        *(__IO uint32_t *)(0x40000344UL) = GPIO_StoreReg[8];
;;;190    
;;;191        return;
;;;192    }
;;;193    #endif  /* USE_GPIO_DLPS */
;;;194    
;;;195    
;;;196    /********************************************** ********************************************************/
;;;197    /**************************************** [KEYSCAN DLPS] ***********************************************/
;;;198    /*******************************************************************************************************/
;;;199    /*******************************************************************************************************/
;;;200    #if USE_KEYSCAN_DLPS
;;;201    __STATIC_INLINE void KeyScan_DLPS_Enter(void);
;;;202    __STATIC_INLINE void KeyScan_DLPS_Exit(void);
;;;203    
;;;204    uint32_t KeyScan_StoreReg[7];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;205    
;;;206    /**
;;;207      * @brief  KEYSCAN enter dlps callback function(Save KEYSCAN register values when system enter DLPS)
;;;208      * @param  None
;;;209      * @retval None
;;;210      */
;;;211    __STATIC_INLINE void KeyScan_DLPS_Enter(void)
;;;212    {
;;;213        /*Open 5M clock source*/
;;;214        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;215        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;216    
;;;217        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;218        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;219    
;;;220        KeyScan_StoreReg[0] = KEYSCAN->CLKDIV;               /* 0x00 */
;;;221        KeyScan_StoreReg[1] = KEYSCAN->TIMERCR;              /* 0x04 */
;;;222        KeyScan_StoreReg[2] = KEYSCAN->CR;                   /* 0x08 */
;;;223        KeyScan_StoreReg[3] = KEYSCAN->COLCR;                /* 0x0C */
;;;224        KeyScan_StoreReg[4] = KEYSCAN->ROWCR;                /* 0x10 */
;;;225        KeyScan_StoreReg[6] = KEYSCAN->INTMASK;              /* 0x18 */
;;;226    
;;;227        return;
;;;228    }
;;;229    
;;;230    /**
;;;231      * @brief  KEYSCAN exit dlps callback function(Resume KEYSCAN register values when system exit DLPS)
;;;232      * @param  None
;;;233      * @retval None
;;;234      */
;;;235    DATA_RAM_FUNCTION __STATIC_INLINE void KeyScan_DLPS_Exit(void)
;;;236    {
;;;237        /*Open 5M clock source*/
;;;238        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;239        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;240    
;;;241        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;242        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;243    
;;;244        /* Set FSM to idle state */
;;;245        KEYSCAN->CR &= ~BIT31;
;;;246        KEYSCAN->CLKDIV = KeyScan_StoreReg[0];
;;;247        KEYSCAN->CR = (KeyScan_StoreReg[2] & (~(BIT31)));
;;;248        KEYSCAN->TIMERCR = KeyScan_StoreReg[1];
;;;249        KEYSCAN->COLCR = KeyScan_StoreReg[3];
;;;250        KEYSCAN->ROWCR = KeyScan_StoreReg[4];
;;;251        KEYSCAN->INTMASK = KeyScan_StoreReg[6];
;;;252        KEYSCAN->CR |= (KeyScan_StoreReg[2] & ((BIT31)));
;;;253    
;;;254        return;
;;;255    }
;;;256    #endif /* USE_KEYSCAN_DLPS */
;;;257    
;;;258    
;;;259    /********************************************** ********************************************************/
;;;260    /**************************************** [QDEC DLPS] **************************************************/
;;;261    /*******************************************************************************************************/
;;;262    /*******************************************************************************************************/
;;;263    #if USE_QDECODER_DLPS
;;;264    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void);
;;;265    __STATIC_INLINE void QuadDecoder_DLPS_Exit(void);
;;;266    
;;;267    uint32_t QuadDecoder_StoreReg[5];  /*  This array should be placed in RAM ON/Buffer ON.    */
;;;268    
;;;269    /**
;;;270      * @brief  QDEC enter dlps callback function(Save QDEC register values when system enter DLPS)
;;;271      * @param  None
;;;272      * @retval None
;;;273      */
;;;274    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void)
;;;275    {
;;;276        /*Open 20M clock source*/
;;;277        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;278        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;279        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;280        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;281    
;;;282        QuadDecoder_StoreReg[0] = QDEC->REG_DIV;
;;;283        QuadDecoder_StoreReg[1] = QDEC->REG_CR_X;
;;;284        QuadDecoder_StoreReg[2] = QDEC->REG_CR_Y;
;;;285        QuadDecoder_StoreReg[3] = QDEC->REG_CR_Z;
;;;286        QuadDecoder_StoreReg[4] = QDEC->INT_MASK;
;;;287    
;;;288        return;
;;;289    }
;;;290    
;;;291    /**
;;;292      * @brief  QDEC exit dlps callback function(Resume QDEC register values when system exit DLPS)
;;;293      * @param  None
;;;294      * @retval None
;;;295      */
;;;296    DATA_RAM_FUNCTION __STATIC_INLINE void QuadDecoder_DLPS_Exit(void)
;;;297    {
;;;298        /*Open 20M clock source*/
;;;299        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;300        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;301        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;302        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;303    
;;;304        //clear flags
;;;305        QDEC->REG_DIV  = QuadDecoder_StoreReg[0];
;;;306        QDEC->REG_CR_X = QuadDecoder_StoreReg[1];
;;;307        QDEC->REG_CR_Y = QuadDecoder_StoreReg[2];
;;;308        QDEC->REG_CR_Z = QuadDecoder_StoreReg[3];
;;;309        QDEC->INT_MASK = QuadDecoder_StoreReg[4];
;;;310    
;;;311        return;
;;;312    }
;;;313    #endif
;;;314    
;;;315    /********************************************** ********************************************************/
;;;316    /**************************************** [SPI0 DLPS] **************************************************/
;;;317    /*******************************************************************************************************/
;;;318    /*******************************************************************************************************/
;;;319    #if USE_SPI0_DLPS
;;;320    __STATIC_INLINE void SPI0_DLPS_Enter(void);
;;;321    __STATIC_INLINE void SPI0_DLPS_Exit(void);
;;;322    
;;;323    uint32_t SPI0_StoreReg[13];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;324    
;;;325    /**
;;;326      * @brief  SPI0 enter dlps callback function(Save SPI0 register values when system enter DLPS)
;;;327      * @param  None
;;;328      * @retval None
;;;329      */
;;;330    __STATIC_INLINE void SPI0_DLPS_Enter(void)
;;;331    {
;;;332        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;333        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;334    
;;;335        SPI0_StoreReg[0] = SPI0->CTRLR0;
;;;336        SPI0_StoreReg[1] = SPI0->CTRLR1;
;;;337        SPI0_StoreReg[2] = SPI0->SSIENR;
;;;338        SPI0_StoreReg[3] = SPI0->SER;
;;;339        SPI0_StoreReg[4] = SPI0->BAUDR;
;;;340        SPI0_StoreReg[5] = SPI0->TXFTLR;
;;;341        SPI0_StoreReg[6] = SPI0->RXFTLR;
;;;342        SPI0_StoreReg[7] = SPI0->IMR;
;;;343        SPI0_StoreReg[8] = SPI0->DMACR;
;;;344        SPI0_StoreReg[9] = SPI0->DMATDLR;
;;;345        SPI0_StoreReg[10] = SPI0->DMARDLR;
;;;346        SPI0_StoreReg[11] = SPI0->RX_SAMPLE_DLY;
;;;347        SPI0_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;348    }
;;;349    
;;;350    /**
;;;351      * @brief  SPI0 exit dlps callback function(Resume SPI0 register values when system exit DLPS)
;;;352      * @param  None
;;;353      * @retval None
;;;354      */
;;;355    DATA_RAM_FUNCTION __STATIC_INLINE void SPI0_DLPS_Exit(void)
;;;356    {
;;;357        *(volatile uint32_t *)0x40000308 = SPI0_StoreReg[12];
;;;358        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;359        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;360    
;;;361        SPI0->CTRLR0 = SPI0_StoreReg[0];
;;;362        SPI0->CTRLR1 = SPI0_StoreReg[1];
;;;363        SPI0->SER = SPI0_StoreReg[3];
;;;364        SPI0->BAUDR = SPI0_StoreReg[4];
;;;365        SPI0->TXFTLR = SPI0_StoreReg[5];
;;;366        SPI0->RXFTLR = SPI0_StoreReg[6];
;;;367        SPI0->IMR = SPI0_StoreReg[7];
;;;368        SPI0->DMACR = SPI0_StoreReg[8];
;;;369        SPI0->DMATDLR = SPI0_StoreReg[9];
;;;370        SPI0->DMARDLR = SPI0_StoreReg[10];
;;;371        SPI0->RX_SAMPLE_DLY = SPI0_StoreReg[11];
;;;372    
;;;373        /* Enable the selected SPI peripheral */
;;;374        SPI0->SSIENR = SPI0_StoreReg[2];
;;;375    }
;;;376    #endif
;;;377    
;;;378    
;;;379    /********************************************** ********************************************************/
;;;380    /**************************************** [SPI1 DLPS] **************************************************/
;;;381    /*******************************************************************************************************/
;;;382    /*******************************************************************************************************/
;;;383    #if USE_SPI1_DLPS
;;;384    __STATIC_INLINE void SPI1_DLPS_Enter(void);
;;;385    __STATIC_INLINE void SPI1_DLPS_Exit(void);
;;;386    
;;;387    uint32_t SPI1_StoreReg[13];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;388    
;;;389    /**
;;;390      * @brief  SPI1 enter dlps callback function(Save SPI1 register values when system enter DLPS)
;;;391      * @param  None
;;;392      * @retval None
;;;393      */
;;;394    __STATIC_INLINE void SPI1_DLPS_Enter(void)
;;;395    {
;;;396        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;397        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;398    
;;;399        SPI1_StoreReg[0] = SPI1->CTRLR0;
;;;400        SPI1_StoreReg[1] = SPI1->CTRLR1;
;;;401        SPI1_StoreReg[2] = SPI1->SSIENR;
;;;402        SPI1_StoreReg[3] = SPI1->SER;
;;;403        SPI1_StoreReg[4] = SPI1->BAUDR;
;;;404        SPI1_StoreReg[5] = SPI1->TXFTLR;
;;;405        SPI1_StoreReg[6] = SPI1->RXFTLR;
;;;406        SPI1_StoreReg[7] = SPI1->IMR;
;;;407        SPI1_StoreReg[8] = SPI1->DMACR;
;;;408        SPI1_StoreReg[9] = SPI1->DMATDLR;
;;;409        SPI1_StoreReg[10] = SPI1->DMARDLR;
;;;410        SPI1_StoreReg[11] = SPI1->RX_SAMPLE_DLY;
;;;411        SPI1_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;412    }
;;;413    
;;;414    /**
;;;415      * @brief  SPI1 exit dlps callback function(Resume SPI1 register values when system exit DLPS)
;;;416      * @param  None
;;;417      * @retval None
;;;418      */
;;;419    DATA_RAM_FUNCTION __STATIC_INLINE void SPI1_DLPS_Exit(void)
;;;420    {
;;;421        *(volatile uint32_t *)0x40000308 = SPI1_StoreReg[12];
;;;422        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;423        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;424    
;;;425        SPI1->CTRLR0 = SPI1_StoreReg[0];
;;;426        SPI1->CTRLR1 = SPI1_StoreReg[1];
;;;427        SPI1->SER = SPI1_StoreReg[3];
;;;428        SPI1->BAUDR = SPI1_StoreReg[4];
;;;429        SPI1->TXFTLR = SPI1_StoreReg[5];
;;;430        SPI1->RXFTLR = SPI1_StoreReg[6];
;;;431        SPI1->IMR = SPI1_StoreReg[7];
;;;432        SPI1->DMACR = SPI1_StoreReg[8];
;;;433        SPI1->DMATDLR = SPI1_StoreReg[9];
;;;434        SPI1->DMARDLR = SPI1_StoreReg[10];
;;;435        SPI1->RX_SAMPLE_DLY = SPI1_StoreReg[11];
;;;436    
;;;437        /* Enable the selected SPI peripheral */
;;;438        SPI1->SSIENR = SPI1_StoreReg[2];
;;;439    }
;;;440    #endif
;;;441    
;;;442    /********************************************** ********************************************************/
;;;443    /**************************************** [SPI2W DLPS] **************************************************/
;;;444    /*******************************************************************************************************/
;;;445    /*******************************************************************************************************/
;;;446    #if USE_SPI2W_DLPS
;;;447    __STATIC_INLINE void SPI2W_DLPS_Enter(void);
;;;448    __STATIC_INLINE void SPI2W_DLPS_Exit(void);
;;;449    
;;;450    uint32_t SPI2W_StoreReg[1];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;451    
;;;452    /**
;;;453      * @brief  SPI2W enter dlps callback function(Save SPI2W register values when system enter DLPS)
;;;454      * @param  None
;;;455      * @retval None
;;;456      */
;;;457    __STATIC_INLINE void SPI2W_DLPS_Enter(void)
;;;458    {
;;;459        /*Open 20M clock source*/
;;;460        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;461        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;462    
;;;463        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;464        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;465    
;;;466        SPI2W_StoreReg[0] = SPI3WIRE->CFGR;
;;;467    }
;;;468    
;;;469    /**
;;;470      * @brief  SPI2W exit dlps callback function(Resume SPI2W register values when system exit DLPS)
;;;471      * @param  None
;;;472      * @retval None
;;;473      */
;;;474    DATA_RAM_FUNCTION __STATIC_INLINE void SPI2W_DLPS_Exit(void)
;;;475    {
;;;476        /*Open 20M clock source*/
;;;477        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;478        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;479    
;;;480        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;481        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;482    
;;;483        SPI3WIRE->CFGR = SPI2W_StoreReg[0];
;;;484    }
;;;485    #endif
;;;486    
;;;487    /********************************************** ********************************************************/
;;;488    /**************************************** [I2C0 DLPS] **************************************************/
;;;489    /*******************************************************************************************************/
;;;490    /*******************************************************************************************************/
;;;491    #if USE_I2C0_DLPS
;;;492    __STATIC_INLINE void I2C0_DLPS_Enter(void);
;;;493    __STATIC_INLINE void I2C0_DLPS_Exit(void);
;;;494    
;;;495    uint32_t I2C0_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;496    
;;;497    /**
;;;498      * @brief  I2C0 enter dlps callback function(Save I2C0 register values when system enter DLPS)
;;;499      * @param  None
;;;500      * @retval None
;;;501      */
;;;502    __STATIC_INLINE void I2C0_DLPS_Enter(void)
;;;503    {
;;;504        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;505        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;506    
;;;507        I2C0_StoreReg[0] = I2C0->IC_CON;
;;;508        I2C0_StoreReg[1] = I2C0->IC_TAR;
;;;509        I2C0_StoreReg[2] = I2C0->IC_SAR;
;;;510        I2C0_StoreReg[3] = I2C0->IC_HS_MADDR;
;;;511    
;;;512        I2C0_StoreReg[4] = I2C0->IC_SS_SCL_HCNT;
;;;513        I2C0_StoreReg[5] = I2C0->IC_SS_SCL_LCNT;
;;;514        I2C0_StoreReg[6] = I2C0->IC_FS_SCL_HCNT;
;;;515        I2C0_StoreReg[7] = I2C0->IC_FS_SCL_LCNT;
;;;516        I2C0_StoreReg[8] = I2C0->IC_HS_SCL_HCNT;
;;;517        I2C0_StoreReg[9] = I2C0->IC_HS_SCL_LCNT;
;;;518    
;;;519        I2C0_StoreReg[10] = I2C0->IC_INTR_MASK;
;;;520        I2C0_StoreReg[11] = I2C0->IC_RX_TL;
;;;521        I2C0_StoreReg[12] = I2C0->IC_TX_TL;
;;;522        I2C0_StoreReg[13] = I2C0->IC_ENABLE;
;;;523        I2C0_StoreReg[14] = I2C0->IC_SDA_HOLD;
;;;524        I2C0_StoreReg[15] = I2C0->IC_SLV_DATA_NACK_ONLY;
;;;525        I2C0_StoreReg[16] = I2C0->IC_DMA_CR;
;;;526        I2C0_StoreReg[17] = I2C0->IC_DMA_TDLR;
;;;527        I2C0_StoreReg[18] = I2C0->IC_DMA_RDLR;
;;;528    
;;;529        I2C0_StoreReg[19] = I2C0->IC_SDA_SETUP;
;;;530    }
;;;531    
;;;532    /**
;;;533      * @brief  I2C0 exit dlps callback function(Resume I2C0 register values when system exit DLPS)
;;;534      * @param  None
;;;535      * @retval None
;;;536      */
;;;537    DATA_RAM_FUNCTION __STATIC_INLINE void I2C0_DLPS_Exit(void)
;;;538    {
;;;539        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;540        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;541    
;;;542        I2C0->IC_CON = I2C0_StoreReg[0];
;;;543        I2C0->IC_TAR = I2C0_StoreReg[1];
;;;544        I2C0->IC_SAR = I2C0_StoreReg[2];
;;;545        I2C0->IC_HS_MADDR = I2C0_StoreReg[3];
;;;546    
;;;547        I2C0->IC_SS_SCL_HCNT = I2C0_StoreReg[4];
;;;548        I2C0->IC_SS_SCL_LCNT = I2C0_StoreReg[5];
;;;549        I2C0->IC_FS_SCL_HCNT = I2C0_StoreReg[6];
;;;550        I2C0->IC_FS_SCL_LCNT = I2C0_StoreReg[7];
;;;551        I2C0->IC_HS_SCL_HCNT = I2C0_StoreReg[8];
;;;552        I2C0->IC_HS_SCL_LCNT = I2C0_StoreReg[9];
;;;553    
;;;554        I2C0->IC_INTR_MASK = I2C0_StoreReg[10];
;;;555        I2C0->IC_RX_TL = I2C0_StoreReg[11];
;;;556        I2C0->IC_TX_TL = I2C0_StoreReg[12];
;;;557        I2C0->IC_SDA_HOLD = I2C0_StoreReg[14];
;;;558        I2C0->IC_SLV_DATA_NACK_ONLY = I2C0_StoreReg[15];
;;;559        I2C0->IC_DMA_CR = I2C0_StoreReg[16];
;;;560        I2C0->IC_DMA_TDLR = I2C0_StoreReg[17];
;;;561        I2C0->IC_DMA_RDLR = I2C0_StoreReg[18];
;;;562        I2C0->IC_SDA_SETUP = I2C0_StoreReg[19];
;;;563    
;;;564        I2C0->IC_ENABLE = I2C0_StoreReg[13];
;;;565    }
;;;566    #endif
;;;567    
;;;568    /********************************************** ********************************************************/
;;;569    /**************************************** [I2C1 DLPS] **************************************************/
;;;570    /*******************************************************************************************************/
;;;571    /*******************************************************************************************************/
;;;572    #if USE_I2C1_DLPS
;;;573    __STATIC_INLINE void I2C1_DLPS_Enter(void);
;;;574    __STATIC_INLINE void I2C1_DLPS_Exit(void);
;;;575    
;;;576    uint32_t I2C1_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;577    
;;;578    /**
;;;579      * @brief  I2C1 enter dlps callback function(Save I2C1 register values when system enter DLPS)
;;;580      * @param  None
;;;581      * @retval None
;;;582      */
;;;583    __STATIC_INLINE void I2C1_DLPS_Enter(void)
;;;584    {
;;;585        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;586        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;587    
;;;588        I2C1_StoreReg[0] = I2C1->IC_CON;
;;;589        I2C1_StoreReg[1] = I2C1->IC_TAR;
;;;590        I2C1_StoreReg[2] = I2C1->IC_SAR;
;;;591        I2C1_StoreReg[3] = I2C1->IC_HS_MADDR;
;;;592    
;;;593        I2C1_StoreReg[4] = I2C1->IC_SS_SCL_HCNT;
;;;594        I2C1_StoreReg[5] = I2C1->IC_SS_SCL_LCNT;
;;;595        I2C1_StoreReg[6] = I2C1->IC_FS_SCL_HCNT;
;;;596        I2C1_StoreReg[7] = I2C1->IC_FS_SCL_LCNT;
;;;597        I2C1_StoreReg[8] = I2C1->IC_HS_SCL_HCNT;
;;;598        I2C1_StoreReg[9] = I2C1->IC_HS_SCL_LCNT;
;;;599    
;;;600        I2C1_StoreReg[10] = I2C1->IC_INTR_MASK;
;;;601        I2C1_StoreReg[11] = I2C1->IC_RX_TL;
;;;602        I2C1_StoreReg[12] = I2C1->IC_TX_TL;
;;;603        I2C1_StoreReg[13] = I2C1->IC_ENABLE;
;;;604        I2C1_StoreReg[14] = I2C1->IC_SDA_HOLD;
;;;605        I2C1_StoreReg[15] = I2C1->IC_SLV_DATA_NACK_ONLY;
;;;606        I2C1_StoreReg[16] = I2C1->IC_DMA_CR;
;;;607        I2C1_StoreReg[17] = I2C1->IC_DMA_TDLR;
;;;608        I2C1_StoreReg[18] = I2C1->IC_DMA_RDLR;
;;;609    
;;;610        I2C1_StoreReg[19] = I2C1->IC_SDA_SETUP;
;;;611    }
;;;612    
;;;613    /**
;;;614      * @brief  I2C1 exit dlps callback function(Resume I2C1 register values when system exit DLPS)
;;;615      * @param  None
;;;616      * @retval None
;;;617      */
;;;618    DATA_RAM_FUNCTION __STATIC_INLINE void I2C1_DLPS_Exit(void)
;;;619    {
;;;620        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;621        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;622    
;;;623        I2C1->IC_CON = I2C1_StoreReg[0];
;;;624        I2C1->IC_TAR = I2C1_StoreReg[1];
;;;625        I2C1->IC_SAR = I2C1_StoreReg[2];
;;;626        I2C0->IC_HS_MADDR = I2C1_StoreReg[3];
;;;627    
;;;628        I2C1->IC_SS_SCL_HCNT = I2C1_StoreReg[4];
;;;629        I2C1->IC_SS_SCL_LCNT = I2C1_StoreReg[5];
;;;630        I2C1->IC_FS_SCL_HCNT = I2C1_StoreReg[6];
;;;631        I2C1->IC_FS_SCL_LCNT = I2C1_StoreReg[7];
;;;632        I2C1->IC_HS_SCL_HCNT = I2C1_StoreReg[8];
;;;633        I2C1->IC_HS_SCL_LCNT = I2C1_StoreReg[9];
;;;634    
;;;635        I2C1->IC_INTR_MASK = I2C1_StoreReg[10];
;;;636        I2C1->IC_RX_TL = I2C1_StoreReg[11];
;;;637        I2C1->IC_TX_TL = I2C1_StoreReg[12];
;;;638        I2C1->IC_SDA_HOLD = I2C1_StoreReg[14];
;;;639        I2C1->IC_SLV_DATA_NACK_ONLY = I2C1_StoreReg[15];
;;;640        I2C1->IC_DMA_CR = I2C1_StoreReg[16];
;;;641        I2C1->IC_DMA_TDLR = I2C1_StoreReg[17];
;;;642        I2C1->IC_DMA_RDLR = I2C1_StoreReg[18];
;;;643        I2C1->IC_SDA_SETUP = I2C1_StoreReg[19];
;;;644    
;;;645        I2C1->IC_ENABLE = I2C1_StoreReg[13];
;;;646    }
;;;647    #endif
;;;648    
;;;649    /********************************************** ********************************************************/
;;;650    /**************************************** [Timer & PWM DLPS] *******************************************/
;;;651    /*******************************************************************************************************/
;;;652    /*******************************************************************************************************/
;;;653    #if USE_TIM_DLPS
;;;654    #include "rtl876x_tim.h"
;;;655    __STATIC_INLINE void TIM_DLPS_Enter(void);
;;;656    __STATIC_INLINE void TIM_DLPS_Exit(void);
;;;657    
;;;658    uint32_t TIM_StoreReg[26];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;659    
;;;660    /* PWM, use with timer */
;;;661    uint32_t PWM0_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;662    
;;;663    uint32_t PWM1_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;664    
;;;665    /**
;;;666      * @brief  TIMER enter dlps callback function(Save TIMER register values when system enter DLPS)
;;;667      * @param  None
;;;668      * @retval None
;;;669      */
;;;670    __STATIC_INLINE void TIM_DLPS_Enter(void)
;;;671    {
;;;672        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;673        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;674    
;;;675        TIM_StoreReg[0] = TIM0->LoadCount;
;;;676        TIM_StoreReg[1] = TIM0->ControlReg;
;;;677        TIM_StoreReg[2] = TIMER0_LOAD_COUNT2;
;;;678    
;;;679        TIM_StoreReg[3] = TIM1->LoadCount;
;;;680        TIM_StoreReg[4] = TIM1->ControlReg;
;;;681        TIM_StoreReg[5] = TIMER1_LOAD_COUNT2;
;;;682    
;;;683        TIM_StoreReg[6] = TIM2->LoadCount;
;;;684        TIM_StoreReg[7] = TIM2->ControlReg;
;;;685        TIM_StoreReg[8] = TIMER2_LOAD_COUNT2;
;;;686    
;;;687        TIM_StoreReg[9] = TIM3->LoadCount;
;;;688        TIM_StoreReg[10] = TIM3->ControlReg;
;;;689        TIM_StoreReg[11] = TIMER3_LOAD_COUNT2;
;;;690    
;;;691        TIM_StoreReg[12] = TIM4->LoadCount;
;;;692        TIM_StoreReg[13] = TIM4->ControlReg;
;;;693        TIM_StoreReg[14] = TIMER4_LOAD_COUNT2;
;;;694    
;;;695        TIM_StoreReg[15] = TIM5->LoadCount;
;;;696        TIM_StoreReg[16] = TIM5->ControlReg;
;;;697        TIM_StoreReg[17] = TIMER5_LOAD_COUNT2;
;;;698    
;;;699        TIM_StoreReg[18] = TIM6->LoadCount;
;;;700        TIM_StoreReg[19] = TIM6->ControlReg;
;;;701        TIM_StoreReg[20] = TIMER6_LOAD_COUNT2;
;;;702    
;;;703        TIM_StoreReg[21] = TIM7->LoadCount;
;;;704        TIM_StoreReg[22] = TIM7->ControlReg;
;;;705        TIM_StoreReg[23] = TIMER7_LOAD_COUNT2;
;;;706    
;;;707        TIM_StoreReg[24] = *((volatile uint32_t *)0x4000035CUL);
;;;708        TIM_StoreReg[25] = *((volatile uint32_t *)0x40000360UL);
;;;709    
;;;710        PWM0_StoreReg = TIMER_PWM0_CR;
;;;711    
;;;712        PWM1_StoreReg = TIMER_PWM1_CR;
;;;713    }
;;;714    
;;;715    /**
;;;716      * @brief  TIMER exit dlps callback function(Resume TIMER register values when system exit DLPS)
;;;717      * @param  None
;;;718      * @retval None
;;;719      */
;;;720    DATA_RAM_FUNCTION __STATIC_INLINE void TIM_DLPS_Exit(void)
;;;721    {
;;;722        /* Enable timer IP clock and function */
;;;723        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;724        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;725    
;;;726        *((volatile uint32_t *)0x4000035CUL) = TIM_StoreReg[24];
;;;727        *((volatile uint32_t *)0x40000360UL) = TIM_StoreReg[25];
;;;728    
;;;729        TIM0->LoadCount = TIM_StoreReg[0];
;;;730        TIM0->ControlReg = TIM_StoreReg[1];
;;;731        TIMER0_LOAD_COUNT2 = TIM_StoreReg[2];
;;;732    
;;;733        TIM1->LoadCount = TIM_StoreReg[3];
;;;734        TIM1->ControlReg = TIM_StoreReg[4];
;;;735        TIMER1_LOAD_COUNT2 = TIM_StoreReg[5];
;;;736    
;;;737        TIM2->LoadCount = TIM_StoreReg[6];
;;;738        TIM2->ControlReg = TIM_StoreReg[7];
;;;739        TIMER2_LOAD_COUNT2 = TIM_StoreReg[8];
;;;740    
;;;741        TIM3->LoadCount = TIM_StoreReg[9];
;;;742        TIM3->ControlReg = TIM_StoreReg[10];
;;;743        TIMER3_LOAD_COUNT2 = TIM_StoreReg[11];
;;;744    
;;;745        TIM4->LoadCount = TIM_StoreReg[12];
;;;746        TIM4->ControlReg = TIM_StoreReg[13];
;;;747        TIMER4_LOAD_COUNT2 = TIM_StoreReg[14];
;;;748    
;;;749        TIM5->LoadCount = TIM_StoreReg[15];
;;;750        TIM5->ControlReg = TIM_StoreReg[16];
;;;751        TIMER5_LOAD_COUNT2 = TIM_StoreReg[17];
;;;752    
;;;753        TIM6->LoadCount = TIM_StoreReg[18];
;;;754        TIM6->ControlReg = TIM_StoreReg[19];
;;;755        TIMER6_LOAD_COUNT2 = TIM_StoreReg[20];
;;;756    
;;;757        TIM7->LoadCount = TIM_StoreReg[21];
;;;758        TIM7->ControlReg = TIM_StoreReg[22];
;;;759        TIMER7_LOAD_COUNT2 = TIM_StoreReg[23];
;;;760    
;;;761        TIMER_PWM0_CR = PWM0_StoreReg;
;;;762    
;;;763        TIMER_PWM1_CR = PWM1_StoreReg;
;;;764    }
;;;765    #endif  /* USE_TIM_DLPS */
;;;766    
;;;767    
;;;768    /********************************************** ********************************************************/
;;;769    /**************************************** [UART DLPS] **************************************************/
;;;770    /*******************************************************************************************************/
;;;771    /*******************************************************************************************************/
;;;772    #if USE_UART_DLPS
;;;773    #include "rtl876x_uart.h"
;;;774    
;;;775    __STATIC_INLINE void UART_DLPS_Enter(void);
;;;776    __STATIC_INLINE void UART_DLPS_Exit(void);
;;;777    
;;;778    uint32_t UART_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;779    
;;;780    /**
;;;781      * @brief  UART enter dlps callback function(Save UART register values when system enter DLPS)
;;;782      * @param  None
;;;783      * @retval None
;;;784      */
;;;785    __STATIC_INLINE void UART_DLPS_Enter(void)
;;;786    {
;;;787        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;788        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;789    
;;;790        //access DLH and DLL
;;;791        UART->LCR |= (1 << 7);
;;;792        UART_StoreReg[0] = UART->DLL;
;;;793        UART_StoreReg[1] = UART->DLH_INTCR;
;;;794        UART->LCR &= (~(1 << 7));
;;;795    
;;;796        //save other registers
;;;797        UART_StoreReg[2] = UART->DLH_INTCR;
;;;798        UART_StoreReg[4] = UART->LCR;
;;;799        UART_StoreReg[5] = UART->MCR;
;;;800        UART_StoreReg[6] = UART->SPR;
;;;801        UART_StoreReg[7] = UART->STSR;
;;;802        UART_StoreReg[8] = UART->RX_IDLE_INTTCR;
;;;803        UART_StoreReg[9] = UART->RXIDLE_INTCR;
;;;804        UART_StoreReg[10] = UART->MISCR;
;;;805    
;;;806        return;
;;;807    }
;;;808    
;;;809    /**
;;;810      * @brief  UART exit dlps callback function(Resume UART register values when system exit DLPS)
;;;811      * @param  None
;;;812      * @retval None
;;;813      */
;;;814    DATA_RAM_FUNCTION __STATIC_INLINE void UART_DLPS_Exit(void)
;;;815    {
;;;816        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;817        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;818    
;;;819        //access DLH and DLL
;;;820        UART->LCR |= (1 << 7);
;;;821        UART->DLL = UART_StoreReg[0];
;;;822        UART->DLH_INTCR =  UART_StoreReg[1];
;;;823        UART->LCR &= (~(1 << 7));
;;;824    
;;;825        //access other registers
;;;826        UART->INTID_FCR = (((UART_StoreReg[7] & BIT24) >> 21) | ((UART_StoreReg[7] & 0x7C000000) >> 18) |
;;;827                           (1));
;;;828        UART->LCR = UART_StoreReg[4];
;;;829        UART->MCR = UART_StoreReg[5];
;;;830        UART->SPR = UART_StoreReg[6];
;;;831        UART->STSR = UART_StoreReg[7];
;;;832        UART->DLH_INTCR = UART_StoreReg[2];
;;;833        UART->RX_IDLE_INTTCR = UART_StoreReg[8];
;;;834        UART->RXIDLE_INTCR = UART_StoreReg[9];
;;;835        UART->MISCR = UART_StoreReg[10];
;;;836    
;;;837        return;
;;;838    }
;;;839    #endif
;;;840    
;;;841    
;;;842    #if USE_UART1_DLPS
;;;843    
;;;844    __STATIC_INLINE void UART1_DLPS_Enter(void);
;;;845    __STATIC_INLINE void UART1_DLPS_Exit(void);
;;;846    
;;;847    uint32_t UART1_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;848    
;;;849    /**
;;;850      * @brief  UART1 enter dlps callback function(Save UART1 register values when system enter DLPS)
;;;851      * @param  None
;;;852      * @retval None
;;;853      */
;;;854    __STATIC_INLINE void UART1_DLPS_Enter(void)
;;;855    {
;;;856        //enable log uart peripheral & clock
;;;857        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;858        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;859    
;;;860        //access DLH and DLL
;;;861        UART1->LCR |= (1 << 7);
;;;862        UART1_StoreReg[0] = UART1->DLL;
;;;863        UART1_StoreReg[1] = UART1->DLH_INTCR;
;;;864        UART1->LCR &= (~(1 << 7));
;;;865    
;;;866        //save other registers
;;;867        UART1_StoreReg[2] = UART1->DLH_INTCR;
;;;868        UART1_StoreReg[4] = UART1->LCR;
;;;869        UART1_StoreReg[5] = UART1->MCR;
;;;870        UART1_StoreReg[6] = UART1->SPR;
;;;871        UART1_StoreReg[7] = UART1->STSR;
;;;872        UART1_StoreReg[8] = UART1->RX_IDLE_INTTCR;
;;;873        UART1_StoreReg[9] = UART1->RXIDLE_INTCR;
;;;874        UART1_StoreReg[10] = UART1->MISCR;
;;;875    
;;;876        return;
;;;877    }
;;;878    
;;;879    /**
;;;880      * @brief  UART1 exit dlps callback function(Resume UART1 register values when system exit DLPS)
;;;881      * @param  None
;;;882      * @retval None
;;;883      */
;;;884    DATA_RAM_FUNCTION __STATIC_INLINE void UART1_DLPS_Exit(void)
;;;885    {
;;;886        //enable log uart peripheral & clock
;;;887        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;888        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;889    
;;;890        //access DLH and DLL
;;;891        UART1->LCR |= (1 << 7);
;;;892        UART1->DLL = UART1_StoreReg[0];
;;;893        UART1->DLH_INTCR =  UART1_StoreReg[1];
;;;894        UART1->LCR &= (~(1 << 7));
;;;895    
;;;896        //access other registers
;;;897        UART1->INTID_FCR = (((UART1_StoreReg[7] & BIT24) >> 21) | ((UART1_StoreReg[7] & 0x7C000000)
;;;898                                                                   >> 18) | (1));
;;;899        UART1->LCR = UART1_StoreReg[4];
;;;900        UART1->MCR = UART1_StoreReg[5];
;;;901        UART1->SPR = UART1_StoreReg[6];
;;;902        UART1->STSR = UART1_StoreReg[7];
;;;903        UART1->DLH_INTCR = UART1_StoreReg[2];
;;;904        UART1->RX_IDLE_INTTCR = UART1_StoreReg[8];
;;;905        UART1->RXIDLE_INTCR = UART1_StoreReg[9];
;;;906        UART1->MISCR = UART1_StoreReg[10];
;;;907    
;;;908        return;
;;;909    }
;;;910    #endif
;;;911    
;;;912    #if USE_UART2_DLPS
;;;913    
;;;914    __STATIC_INLINE void UART2_DLPS_Enter(void);
;;;915    __STATIC_INLINE void UART2_DLPS_Exit(void);
;;;916    
;;;917    uint32_t UART2_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;918    
;;;919    /**
;;;920      * @brief  UART2 enter dlps callback function(Save UART2 register values when system enter DLPS)
;;;921      * @param  None
;;;922      * @retval None
;;;923      */
;;;924    __STATIC_INLINE void UART2_DLPS_Enter(void)
;;;925    {
;;;926        //enable log uart peripheral & clock
;;;927        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;928        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;929    
;;;930        //access DLH and DLL
;;;931        UART2->LCR |= (1 << 7);
;;;932        UART2_StoreReg[0] = UART2->DLL;
;;;933        UART2_StoreReg[1] = UART2->DLH_INTCR;
;;;934        UART2->LCR &= (~(1 << 7));
;;;935    
;;;936        //save other registers
;;;937        UART2_StoreReg[2] = UART2->DLH_INTCR;
;;;938        UART2_StoreReg[4] = UART2->LCR;
;;;939        UART2_StoreReg[5] = UART2->MCR;
;;;940        UART2_StoreReg[6] = UART2->SPR;
;;;941        UART2_StoreReg[7] = UART2->STSR;
;;;942        UART2_StoreReg[8] = UART2->RX_IDLE_INTTCR;
;;;943        UART2_StoreReg[9] = UART2->RXIDLE_INTCR;
;;;944        UART2_StoreReg[10] = UART2->MISCR;
;;;945    
;;;946        return;
;;;947    }
;;;948    
;;;949    /**
;;;950      * @brief  UART2 exit dlps callback function(Resume UART2 register values when system exit DLPS)
;;;951      * @param  None
;;;952      * @retval None
;;;953      */
;;;954    DATA_RAM_FUNCTION __STATIC_INLINE void UART2_DLPS_Exit(void)
;;;955    {
;;;956        //enable log uart peripheral & clock
;;;957        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;958        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;959    
;;;960        //access DLH and DLL
;;;961        UART2->LCR |= (1 << 7);
;;;962        UART2->DLL = UART2_StoreReg[0];
;;;963        UART2->DLH_INTCR =  UART2_StoreReg[1];
;;;964        UART2->LCR &= (~(1 << 7));
;;;965    
;;;966        //access other registers
;;;967        UART2->INTID_FCR = (((UART2_StoreReg[7] & BIT24) >> 21) | ((UART2_StoreReg[7] & 0x7C000000)
;;;968                                                                   >> 18) | (1));
;;;969        UART2->LCR = UART2_StoreReg[4];
;;;970        UART2->MCR = UART2_StoreReg[5];
;;;971        UART2->SPR = UART2_StoreReg[6];
;;;972        UART2->STSR = UART2_StoreReg[7];
;;;973        UART2->DLH_INTCR = UART2_StoreReg[2];
;;;974        UART2->RX_IDLE_INTTCR = UART2_StoreReg[8];
;;;975        UART2->RXIDLE_INTCR = UART2_StoreReg[9];
;;;976        UART2->MISCR = UART2_StoreReg[10];
;;;977    
;;;978        return;
;;;979    }
;;;980    #endif
;;;981    
;;;982    
;;;983    /********************************************** ********************************************************/
;;;984    /**************************************** [ADC DLPS] **************************************************/
;;;985    /*******************************************************************************************************/
;;;986    /*******************************************************************************************************/
;;;987    
;;;988    #if USE_ADC_DLPS
;;;989    __STATIC_INLINE void ADC_DLPS_Enter(void);
;;;990    __STATIC_INLINE void ADC_DLPS_Exit(void);
;;;991    
;;;992    uint32_t ADC_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;993    
;;;994    /**
;;;995      * @brief  ADC enter dlps callback function(Save ADC register values when system enter DLPS)
;;;996      * @param  None
;;;997      * @retval None
;;;998      */
;;;999    __STATIC_INLINE void ADC_DLPS_Enter(void)
;;;1000   {
;;;1001       /*Open 10M clock source*/
;;;1002       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1003       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1004   
;;;1005       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1006       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1007   
;;;1008       ADC_StoreReg[0] =  ADC->CR;          //0x04
;;;1009       ADC_StoreReg[1] =  ADC->SCHCR;       //0x08
;;;1010       ADC_StoreReg[2] =  ADC->INTCR;       //0x0C
;;;1011       ADC_StoreReg[3] =  ADC->SCHTAB0;     //0x10
;;;1012       ADC_StoreReg[4] =  ADC->SCHTAB1;     //0x14
;;;1013       ADC_StoreReg[5] =  ADC->SCHTAB2;     //0x18
;;;1014       ADC_StoreReg[6] =  ADC->SCHTAB3;     //0x1C
;;;1015       ADC_StoreReg[7] =  ADC->SCHTAB4;     //0x20
;;;1016       ADC_StoreReg[8] =  ADC->SCHTAB5;     //0x24
;;;1017       ADC_StoreReg[9] =  ADC->SCHTAB6;     //0x28
;;;1018       ADC_StoreReg[10] =  ADC->SCHTAB6;    //0x2C
;;;1019       ADC_StoreReg[11] =  ADC->PWRDLY;
;;;1020       ADC_StoreReg[12] =  ADC->DATCLK;
;;;1021       ADC_StoreReg[13] =  ADC->ANACTL;
;;;1022   
;;;1023       uint8_t reg_value = 0;
;;;1024       reg_value = btaon_fast_read_safe(0x110);
;;;1025       btaon_fast_write(0x110, reg_value & (~0x04));
;;;1026   
;;;1027       return;
;;;1028   }
;;;1029   
;;;1030   /**
;;;1031     * @brief  ADC exit dlps callback function(Resume ADC register values when system exit DLPS)
;;;1032     * @param  None
;;;1033     * @retval None
;;;1034     */
;;;1035   DATA_RAM_FUNCTION __STATIC_INLINE void ADC_DLPS_Exit(void)
;;;1036   {
;;;1037       /*Open 10M clock source*/
;;;1038       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1039       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1040   
;;;1041       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1042       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1043   
;;;1044   #if 0
;;;1045       //Todo
;;;1046       ADC->PWRDLY = ADC_StoreReg[10];
;;;1047       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1048       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1049       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1050       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1051       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1052       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1053       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1054       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1055       ADC->SCHCR = ADC_StoreReg[1];
;;;1056       ADC->INTCR = (ADC_StoreReg[2] & 0x1F);
;;;1057   #else
;;;1058       /*Disable all interrupt.*/
;;;1059       ADC->INTCR &= (~0x1f);
;;;1060   
;;;1061       /* Set power mode first */
;;;1062       ADC->PWRDLY = ADC_StoreReg[11];
;;;1063   
;;;1064       /* Disable schedule table */
;;;1065       ADC->SCHCR &= (~0xffff);
;;;1066   
;;;1067       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1068       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1069       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1070       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1071       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1072       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1073       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1074       ADC->SCHTAB7 = ADC_StoreReg[10];
;;;1075       ADC->SCHCR   = ADC_StoreReg[1];
;;;1076       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1077       ADC->DATCLK = ADC_StoreReg[12];
;;;1078       ADC->ANACTL = ADC_StoreReg[13];
;;;1079   
;;;1080       /*Clear ADC FIFO */
;;;1081       ADC->CR |= BIT26;
;;;1082       /* Clear all interrupt */
;;;1083       ADC->INTCR |= (0x1f << 8);
;;;1084   
;;;1085       /* Restore specify interrupt */
;;;1086       ADC->INTCR = ADC_StoreReg[2];
;;;1087   
;;;1088   #endif
;;;1089   
;;;1090       uint8_t reg_value = 0;
;;;1091       reg_value = btaon_fast_read_safe(0x110);
;;;1092       btaon_fast_write(0x110, reg_value | 0x04);
;;;1093   
;;;1094       return;
;;;1095   }
;;;1096   
;;;1097   #endif
;;;1098   
;;;1099   /********************************************** ********************************************************/
;;;1100   /**************************************** [IR DLPS] **************************************************/
;;;1101   /*******************************************************************************************************/
;;;1102   /*******************************************************************************************************/
;;;1103   
;;;1104   #if USE_IR_DLPS
;;;1105   __STATIC_INLINE void IR_DLPS_Enter(void);
;;;1106   __STATIC_INLINE void IR_DLPS_Exit(void);
;;;1107   
;;;1108   uint32_t IR_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1109   
;;;1110   /**
;;;1111     * @brief  IR enter dlps callback function(Save IR register values when system enter DLPS)
;;;1112     * @param  None
;;;1113     * @retval None
;;;1114     */
;;;1115   __STATIC_INLINE void IR_DLPS_Enter(void)
;;;1116   {
;;;1117       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1118       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1119   
;;;1120       IR_StoreReg[0] = IR->CLK_DIV;
;;;1121       IR_StoreReg[1] = IR->TX_CONFIG;
;;;1122       IR_StoreReg[2] = IR->RX_CONFIG;
;;;1123       IR_StoreReg[3] = IR->RX_CNT_INT_SEL;
;;;1124   
;;;1125   
;;;1126       return;
;;;1127   }
;;;1128   
;;;1129   /**
;;;1130     * @brief  IR exit dlps callback function(Resume IR register values when system exit DLPS)
;;;1131     * @param  None
;;;1132     * @retval None
;;;1133     */
;;;1134   DATA_RAM_FUNCTION __STATIC_INLINE void IR_DLPS_Exit(void)
;;;1135   {
;;;1136       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1137       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1138   
;;;1139       IR->CLK_DIV = IR_StoreReg[0];
;;;1140       if (IR_StoreReg[1] & BIT31)
;;;1141       {
;;;1142           /* RX MODE */
;;;1143           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1144           IR->RX_CONFIG  = IR_StoreReg[2];
;;;1145           IR->RX_CNT_INT_SEL  = IR_StoreReg[3];
;;;1146       }
;;;1147       else
;;;1148       {
;;;1149           /* TX MODE */
;;;1150           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1151           /* If IR TX mode is idle, must write one data firstly */
;;;1152           IR->TX_FIFO = 0;
;;;1153       }
;;;1154   
;;;1155       return;
;;;1156   }
;;;1157   
;;;1158   #endif
;;;1159   
;;;1160   /********************************************** ********************************************************/
;;;1161   /**************************************** [GDMA DLPS] **************************************************/
;;;1162   /*******************************************************************************************************/
;;;1163   /*******************************************************************************************************/
;;;1164   
;;;1165   #if USE_GDMA_DLPS
;;;1166   
;;;1167   __STATIC_INLINE void GDMA_DLPS_Enter(void);
;;;1168   __STATIC_INLINE void GDMA_DLPS_Exit(void);
;;;1169   uint32_t GDMA_StoreReg[7];         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1170   
;;;1171   #endif
;;;1172   
;;;1173   #if USE_GDMACHANNEL0_DLPS
;;;1174   uint32_t GDMAChannel0_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1175   #endif
;;;1176   
;;;1177   #if USE_GDMACHANNEL1_DLPS
;;;1178   uint32_t GDMAChannel1_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1179   #endif
;;;1180   
;;;1181   #if USE_GDMACHANNEL2_DLPS
;;;1182   uint32_t GDMAChannel2_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1183   #endif
;;;1184   
;;;1185   #if USE_GDMACHANNEL3_DLPS
;;;1186   uint32_t GDMAChannel3_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1187   #endif
;;;1188   
;;;1189   #if USE_GDMACHANNEL4_DLPS
;;;1190   uint32_t GDMAChannel4_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1191   #endif
;;;1192   
;;;1193   #if USE_GDMACHANNEL5_DLPS
;;;1194   uint32_t GDMAChannel5_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1195   #endif
;;;1196   
;;;1197   #if USE_GDMA_DLPS
;;;1198   /**
;;;1199     * @brief  GDMA enter dlps callback function(Save GDMA register values when system enter DLPS)
;;;1200     * @param  None
;;;1201     * @retval None
;;;1202     */
;;;1203   __STATIC_INLINE void GDMA_DLPS_Enter(void)
;;;1204   {
;;;1205       SYSBLKCTRL->u_210.SOC_FUNC_EN |= SYSBLK_GDMA0_EN_Msk;
;;;1206       PERIPH->PERI_CLK_CTRL |= (SYSBLK_ACTCK_GDMA0_EN_Msk | SYSBLK_SLPCK_GDMA0_EN_Msk);
;;;1207   
;;;1208       GDMA_StoreReg[0] = GDMA_BASE->DmaCfgReg;
;;;1209       GDMA_StoreReg[1] = GDMA_BASE->ChEnReg;
;;;1210       GDMA_StoreReg[2] = GDMA_BASE->MASK_TFR;
;;;1211       GDMA_StoreReg[3] = GDMA_BASE->MASK_BLOCK;
;;;1212       GDMA_StoreReg[4] = GDMA_BASE->MASK_SRC_TRAN;
;;;1213       GDMA_StoreReg[5] = GDMA_BASE->MASK_DST_TRAN;
;;;1214       GDMA_StoreReg[6] = GDMA_BASE->MASK_ERR;
;;;1215   
;;;1216   #if USE_GDMACHANNEL0_DLPS
;;;1217       GDMAChannel0_StoreReg[0] = GDMA_Channel0->SAR;
;;;1218       GDMAChannel0_StoreReg[1] = GDMA_Channel0->DAR;
;;;1219       GDMAChannel0_StoreReg[2] = GDMA_Channel0->CTL_LOW;
;;;1220       GDMAChannel0_StoreReg[3] = GDMA_Channel0->CTL_HIGH;
;;;1221       GDMAChannel0_StoreReg[4] = GDMA_Channel0->CFG_LOW;
;;;1222       GDMAChannel0_StoreReg[5] = GDMA_Channel0->CFG_HIGH;
;;;1223   #endif
;;;1224   #if USE_GDMACHANNEL1_DLPS
;;;1225       GDMAChannel1_StoreReg[0] = GDMA_Channel1->SAR;
;;;1226       GDMAChannel1_StoreReg[1] = GDMA_Channel1->DAR;
;;;1227       GDMAChannel1_StoreReg[2] = GDMA_Channel1->CTL_LOW;
;;;1228       GDMAChannel1_StoreReg[3] = GDMA_Channel1->CTL_HIGH;
;;;1229       GDMAChannel1_StoreReg[4] = GDMA_Channel1->CFG_LOW;
;;;1230       GDMAChannel1_StoreReg[5] = GDMA_Channel1->CFG_HIGH;
;;;1231   #endif
;;;1232   #if USE_GDMACHANNEL2_DLPS
;;;1233       GDMAChannel2_StoreReg[0] = GDMA_Channel2->SAR;
;;;1234       GDMAChannel2_StoreReg[1] = GDMA_Channel2->DAR;
;;;1235       GDMAChannel2_StoreReg[2] = GDMA_Channel2->CTL_LOW;
;;;1236       GDMAChannel2_StoreReg[3] = GDMA_Channel2->CTL_HIGH;
;;;1237       GDMAChannel2_StoreReg[4] = GDMA_Channel2->CFG_LOW;
;;;1238       GDMAChannel2_StoreReg[5] = GDMA_Channel2->CFG_HIGH;
;;;1239   #endif
;;;1240   #if USE_GDMACHANNEL3_DLPS
;;;1241       GDMAChannel3_StoreReg[0] = GDMA_Channel3->SAR;
;;;1242       GDMAChannel3_StoreReg[1] = GDMA_Channel3->DAR;
;;;1243       GDMAChannel3_StoreReg[2] = GDMA_Channel3->CTL_LOW;
;;;1244       GDMAChannel3_StoreReg[3] = GDMA_Channel3->CTL_HIGH;
;;;1245       GDMAChannel3_StoreReg[4] = GDMA_Channel3->CFG_LOW;
;;;1246       GDMAChannel3_StoreReg[5] = GDMA_Channel3->CFG_HIGH;
;;;1247   #endif
;;;1248   #if USE_GDMACHANNEL4_DLPS
;;;1249       GDMAChannel4_StoreReg[0] = GDMA_Channel4->SAR;
;;;1250       GDMAChannel4_StoreReg[1] = GDMA_Channel4->DAR;
;;;1251       GDMAChannel4_StoreReg[2] = GDMA_Channel4->CTL_LOW;
;;;1252       GDMAChannel4_StoreReg[3] = GDMA_Channel4->CTL_HIGH;
;;;1253       GDMAChannel4_StoreReg[4] = GDMA_Channel4->CFG_LOW;
;;;1254       GDMAChannel4_StoreReg[5] = GDMA_Channel4->CFG_HIGH;
;;;1255   #endif
;;;1256   #if USE_GDMACHANNEL5_DLPS
;;;1257       GDMAChannel5_StoreReg[0] = GDMA_Channel5->SAR;
;;;1258       GDMAChannel5_StoreReg[1] = GDMA_Channel5->DAR;
;;;1259       GDMAChannel5_StoreReg[2] = GDMA_Channel5->CTL_LOW;
;;;1260       GDMAChannel5_StoreReg[3] = GDMA_Channel5->CTL_HIGH;
;;;1261       GDMAChannel5_StoreReg[4] = GDMA_Channel5->CFG_LOW;
;;;1262       GDMAChannel5_StoreReg[5] = GDMA_Channel5->CFG_HIGH;
;;;1263   #endif
;;;1264   }
;;;1265   
;;;1266   /**
;;;1267     * @brief  GDMA exit dlps callback function(Resume GDMA register values when system exit DLPS)
;;;1268     * @param  None
;;;1269     * @retval None
;;;1270     */
;;;1271   DATA_RAM_FUNCTION __STATIC_INLINE void GDMA_DLPS_Exit(void)
;;;1272   {
;;;1273       SYSBLKCTRL->u_210.SOC_FUNC_EN |= SYSBLK_GDMA0_EN_Msk;
;;;1274       PERIPH->PERI_CLK_CTRL |= (SYSBLK_ACTCK_GDMA0_EN_Msk | SYSBLK_SLPCK_GDMA0_EN_Msk);
;;;1275   
;;;1276       /* Enable GDMA in DmaCfgReg*/
;;;1277       GDMA_BASE->DmaCfgReg = GDMA_StoreReg[0];
;;;1278   
;;;1279       /*----------clear pending all interrupts of GDMA channel-----------*/
;;;1280       GDMA_BASE->CLEAR_TFR = 0xff;
;;;1281       GDMA_BASE->CLEAR_BLOCK = 0xff;
;;;1282       GDMA_BASE->CLEAR_DST_TRAN = 0xff;
;;;1283       GDMA_BASE->CLEAR_SRC_TRAN = 0xff;
;;;1284       GDMA_BASE->CLEAR_ERR = 0xff;
;;;1285   
;;;1286       /*--------------------mask interrupt-------- -----------------*/
;;;1287       GDMA_BASE->MASK_TFR = (GDMA_StoreReg[2] | ((GDMA_StoreReg[2] & 0xff) << 8));
;;;1288       GDMA_BASE->MASK_BLOCK = (GDMA_StoreReg[3] | ((GDMA_StoreReg[3] & 0xff) << 8));
;;;1289       GDMA_BASE->MASK_SRC_TRAN = (GDMA_StoreReg[4] | ((GDMA_StoreReg[4] & 0xff) << 8));
;;;1290       GDMA_BASE->MASK_DST_TRAN = (GDMA_StoreReg[5] | ((GDMA_StoreReg[5] & 0xff) << 8));
;;;1291       GDMA_BASE->MASK_ERR = (GDMA_StoreReg[6] | ((GDMA_StoreReg[6] & 0xff) << 8));
;;;1292   
;;;1293   #if USE_GDMACHANNEL0_DLPS
;;;1294       GDMA_Channel0->SAR      = GDMAChannel0_StoreReg[0];
;;;1295       GDMA_Channel0->DAR      = GDMAChannel0_StoreReg[1];
;;;1296       GDMA_Channel0->CTL_LOW  = GDMAChannel0_StoreReg[2];
;;;1297       GDMA_Channel0->CTL_HIGH = GDMAChannel0_StoreReg[3];
;;;1298       GDMA_Channel0->CFG_LOW  = GDMAChannel0_StoreReg[4];
;;;1299       GDMA_Channel0->CFG_HIGH = GDMAChannel0_StoreReg[5];
;;;1300   #endif
;;;1301   #if USE_GDMACHANNEL1_DLPS
;;;1302       GDMA_Channel1->SAR      = GDMAChannel1_StoreReg[0];
;;;1303       GDMA_Channel1->DAR      = GDMAChannel1_StoreReg[1];
;;;1304       GDMA_Channel1->CTL_LOW  = GDMAChannel1_StoreReg[2];
;;;1305       GDMA_Channel1->CTL_HIGH = GDMAChannel1_StoreReg[3];
;;;1306       GDMA_Channel1->CFG_LOW  = GDMAChannel1_StoreReg[4];
;;;1307       GDMA_Channel1->CFG_HIGH = GDMAChannel1_StoreReg[5];
;;;1308   #endif
;;;1309   #if USE_GDMACHANNEL2_DLPS
;;;1310       GDMA_Channel2->SAR      = GDMAChannel2_StoreReg[0];
;;;1311       GDMA_Channel2->DAR      = GDMAChannel2_StoreReg[1];
;;;1312       GDMA_Channel2->CTL_LOW  = GDMAChannel2_StoreReg[2];
;;;1313       GDMA_Channel2->CTL_HIGH = GDMAChannel2_StoreReg[3];
;;;1314       GDMA_Channel2->CFG_LOW  = GDMAChannel2_StoreReg[4];
;;;1315       GDMA_Channel2->CFG_HIGH = GDMAChannel2_StoreReg[5];
;;;1316   #endif
;;;1317   #if USE_GDMACHANNEL3_DLPS
;;;1318       GDMA_Channel3->SAR      = GDMAChannel3_StoreReg[0];
;;;1319       GDMA_Channel3->DAR      = GDMAChannel3_StoreReg[1];
;;;1320       GDMA_Channel3->CTL_LOW  = GDMAChannel3_StoreReg[2];
;;;1321       GDMA_Channel3->CTL_HIGH = GDMAChannel3_StoreReg[3];
;;;1322       GDMA_Channel3->CFG_LOW  = GDMAChannel3_StoreReg[4];
;;;1323       GDMA_Channel3->CFG_HIGH = GDMAChannel3_StoreReg[5];
;;;1324   #endif
;;;1325   #if USE_GDMACHANNEL4_DLPS
;;;1326       GDMA_Channel4->SAR      = GDMAChannel4_StoreReg[0];
;;;1327       GDMA_Channel4->DAR      = GDMAChannel4_StoreReg[1];
;;;1328       GDMA_Channel4->CTL_LOW  = GDMAChannel4_StoreReg[2];
;;;1329       GDMA_Channel4->CTL_HIGH = GDMAChannel4_StoreReg[3];
;;;1330       GDMA_Channel4->CFG_LOW  = GDMAChannel4_StoreReg[4];
;;;1331       GDMA_Channel4->CFG_HIGH = GDMAChannel4_StoreReg[5];
;;;1332   #endif
;;;1333   #if USE_GDMACHANNEL5_DLPS
;;;1334       GDMA_Channel5->SAR      = GDMAChannel5_StoreReg[0];
;;;1335       GDMA_Channel5->DAR      = GDMAChannel5_StoreReg[1];
;;;1336       GDMA_Channel5->CTL_LOW  = GDMAChannel5_StoreReg[2];
;;;1337       GDMA_Channel5->CTL_HIGH = GDMAChannel5_StoreReg[3];
;;;1338       GDMA_Channel5->CFG_LOW  = GDMAChannel5_StoreReg[4];
;;;1339       GDMA_Channel5->CFG_HIGH = GDMAChannel5_StoreReg[5];
;;;1340   #endif
;;;1341   
;;;1342       /*----------clear pending all interrupts of GDMA channel before enable channel-----------*/
;;;1343       GDMA_BASE->CLEAR_TFR = 0x3f;
;;;1344       GDMA_BASE->CLEAR_BLOCK = 0x3f;
;;;1345       GDMA_BASE->CLEAR_DST_TRAN = 0x3f;
;;;1346       GDMA_BASE->CLEAR_SRC_TRAN = 0x3f;
;;;1347       GDMA_BASE->CLEAR_ERR = 0x3f;
;;;1348   
;;;1349       /* Enable the selected DMA Channelx */
;;;1350   //    GDMA_BASE->ChEnReg = GDMA_StoreReg[1];
;;;1351   }
;;;1352   #endif
;;;1353   
;;;1354   /********************************************** ********************************************************/
;;;1355   /**************************************** [LCD DLPS] ************************************************/
;;;1356   /*******************************************************************************************************/
;;;1357   /*******************************************************************************************************/
;;;1358   #if USE_LCD_DLPS
;;;1359   
;;;1360   uint32_t LCD_StoreReg[5];
;;;1361   
;;;1362   /**
;;;1363     * @brief  LCD enter dlps callback function(Save LCD register values when system enter DLPS)
;;;1364     * @param  None
;;;1365     * @retval None
;;;1366     */
;;;1367   __STATIC_INLINE void LCD_DLPS_Enter(void)
;;;1368   {
;;;1369       /* Enable LCD 8080 interface controller function */
;;;1370       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1371       /* Enable LCD 8080 interface controller clock */
;;;1372       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1373   
;;;1374       LCD_StoreReg[0] = *((volatile uint32_t *)0x400002A8UL) & (0x03 << 28);
;;;1375       LCD_StoreReg[1] = LCD->IMR;
;;;1376       LCD_StoreReg[2] = LCD->CTRL0;
;;;1377       LCD_StoreReg[3] = LCD->CTRL1;
;;;1378       LCD_StoreReg[4] = LCD->CFG;
;;;1379   
;;;1380   }
;;;1381   
;;;1382   /**
;;;1383     * @brief  LCD exit dlps callback function(Resume LCD register values when system exit DLPS)
;;;1384     * @param  None
;;;1385     * @retval None
;;;1386     */
;;;1387   DATA_RAM_FUNCTION __STATIC_INLINE void LCD_DLPS_Exit(void)
;;;1388   {
;;;1389       /* Enable LCD 8080 interface controller function */
;;;1390       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1391       /* Enable LCD 8080 interface controller clock */
;;;1392       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1393   
;;;1394       /* Restore Dedicated SDIO pin option */
;;;1395       *((volatile uint32_t *)0x400002A8UL) &= ~(0x03 << 28);
;;;1396       *((volatile uint32_t *)0x400002A8UL) |= LCD_StoreReg[0];
;;;1397   
;;;1398       /* Initialize LCD */
;;;1399   
;;;1400       LCD->IMR    = LCD_StoreReg[1];
;;;1401       LCD->CTRL1  = LCD_StoreReg[3];
;;;1402       LCD->CFG    = LCD_StoreReg[4];
;;;1403       LCD->CTRL0  = LCD_StoreReg[2];
;;;1404   }
;;;1405   #endif
;;;1406   
;;;1407   /********************************************** ********************************************************/
;;;1408   /**************************************** [I2S0 DLPS] **************************************************/
;;;1409   /*******************************************************************************************************/
;;;1410   /*******************************************************************************************************/
;;;1411   #if USE_I2S0_DLPS
;;;1412   
;;;1413   uint32_t I2S0_StoreReg[4];
;;;1414   
;;;1415   /**
;;;1416     * @brief  I2S0 enter dlps callback function(Save I2S0 register values when system enter DLPS)
;;;1417     * @param  None
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void I2S0_DLPS_Enter(void)
;;;1421   {
;;;1422       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1423   
;;;1424       I2S0_StoreReg[0] = I2S0->BCLK_DIV;
;;;1425       I2S0_StoreReg[1] = I2S0->CTRL0;
;;;1426       I2S0_StoreReg[2] = I2S0->CTRL1;
;;;1427       I2S0_StoreReg[3] = I2S0->DMA_TRDLR;
;;;1428   }
;;;1429   
;;;1430   /**
;;;1431     * @brief  I2S0 exit dlps callback function(Resume I2S0 register values when system exit DLPS)
;;;1432     * @param  None
;;;1433     * @retval None
;;;1434     */
;;;1435   DATA_RAM_FUNCTION __STATIC_INLINE void I2S0_DLPS_Exit(void)
;;;1436   {
;;;1437       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1438   
;;;1439       /* Reset I2S0 module */
;;;1440       I2S0->CTRL0 |= 1 << 0;
;;;1441       I2S0->CTRL0 &= ~(1 << 0);
;;;1442   
;;;1443       /* Initialize I2S0 */
;;;1444       I2S0->BCLK_DIV  = I2S0_StoreReg[0];
;;;1445       I2S0->CTRL1     = I2S0_StoreReg[2];
;;;1446       I2S0->DMA_TRDLR = I2S0_StoreReg[3];
;;;1447       I2S0->CTRL0     = I2S0_StoreReg[1];
;;;1448   }
;;;1449   #endif
;;;1450   
;;;1451   /********************************************** ********************************************************/
;;;1452   /**************************************** [I2S1 DLPS] **************************************************/
;;;1453   /*******************************************************************************************************/
;;;1454   /*******************************************************************************************************/
;;;1455   #if USE_I2S1_DLPS
;;;1456   
;;;1457   uint32_t I2S1_StoreReg[4];
;;;1458   
;;;1459   /**
;;;1460     * @brief  I2S1 enter dlps callback function(Save I2S1 register values when system enter DLPS)
;;;1461     * @param  None
;;;1462     * @retval None
;;;1463     */
;;;1464   __STATIC_INLINE void I2S1_DLPS_Enter(void)
;;;1465   {
;;;1466       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1467   
;;;1468       I2S1_StoreReg[0] = I2S1->BCLK_DIV;
;;;1469       I2S1_StoreReg[1] = I2S1->CTRL0;
;;;1470       I2S1_StoreReg[2] = I2S1->CTRL1;
;;;1471       I2S1_StoreReg[3] = I2S1->DMA_TRDLR;
;;;1472   }
;;;1473   
;;;1474   /**
;;;1475     * @brief  I2S1 exit dlps callback function(Resume I2S1 register values when system exit DLPS)
;;;1476     * @param  None
;;;1477     * @retval None
;;;1478     */
;;;1479   DATA_RAM_FUNCTION __STATIC_INLINE void I2S1_DLPS_Exit(void)
;;;1480   {
;;;1481       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1482   
;;;1483       /* Reset I2S1 module */
;;;1484       I2S1->CTRL0 |= 1 << 0;
;;;1485       I2S1->CTRL0 &= ~(1 << 0);
;;;1486   
;;;1487       /* Initialize I2S1 */
;;;1488       I2S1->BCLK_DIV  = I2S1_StoreReg[0];
;;;1489       I2S1->CTRL1     = I2S1_StoreReg[2];
;;;1490       I2S1->DMA_TRDLR = I2S1_StoreReg[3];
;;;1491       I2S1->CTRL0     = I2S1_StoreReg[1];
;;;1492   }
;;;1493   #endif
;;;1494   
;;;1495   /********************************************** ********************************************************/
;;;1496   /**************************************** [CODEC DLPS] ************************************************/
;;;1497   /*******************************************************************************************************/
;;;1498   /*******************************************************************************************************/
;;;1499   #if USE_CODEC_DLPS
;;;1500   
;;;1501   uint32_t CODEC_StoreReg[7];
;;;1502   
;;;1503   /**
;;;1504     * @brief  CODEC enter dlps callback function(Save CODEC register values when system enter DLPS)
;;;1505     * @param  None
;;;1506     * @retval None
;;;1507     */
;;;1508   __STATIC_INLINE void CODEC_DLPS_Enter(void)
;;;1509   {
;;;1510       /* Enable codec function and clock */
;;;1511       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1512   
;;;1513       CODEC_StoreReg[0] = CODEC->CR0;
;;;1514       CODEC_StoreReg[1] = CODEC->CR1;
;;;1515       CODEC_StoreReg[2] = CODEC->CR2;
;;;1516       CODEC_StoreReg[3] = CODEC->CLK_CTRL;
;;;1517       CODEC_StoreReg[4] = CODEC->I2S_CTRL;
;;;1518       CODEC_StoreReg[5] = CODEC->ADC_CTRL;
;;;1519       CODEC_StoreReg[6] = CODEC->DAC_CTRL;
;;;1520   }
;;;1521   
;;;1522   /**
;;;1523     * @brief  CODEC exit dlps callback function(Resume CODEC register values when system exit DLPS)
;;;1524     * @param  None
;;;1525     * @retval None
;;;1526     */
;;;1527   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_DLPS_Exit(void)
;;;1528   {
;;;1529       /* Enable codec function and clock */
;;;1530       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1531   
;;;1532       /* Initialize CODEC */
;;;1533       if ((CODEC_StoreReg[3] & 0x900) == 0x900)
;;;1534       {
;;;1535           /* Configure AMIC parameters */
;;;1536           CODEC->CR0 = CODEC_StoreReg[0];
;;;1537           CODEC->CR1 = CODEC_StoreReg[1];
;;;1538           CODEC->CR2 = CODEC_StoreReg[2];
;;;1539       }
;;;1540   
;;;1541       /*  Reset audio digital IP */
;;;1542       CODEC->AUDIO_CTRL = 0;
;;;1543       CODEC->AUDIO_CTRL = 1;
;;;1544   
;;;1545       CODEC->CLK_CTRL = CODEC_StoreReg[3];
;;;1546       CODEC->I2S_CTRL = CODEC_StoreReg[4];
;;;1547       CODEC->ADC_CTRL = CODEC_StoreReg[5];
;;;1548       CODEC->DAC_CTRL = CODEC_StoreReg[6];
;;;1549   }
;;;1550   #endif
;;;1551   
;;;1552   /********************************************** ********************************************************/
;;;1553   /**************************************** [CODEC_EQ1 DLPS] ************************************************/
;;;1554   /*******************************************************************************************************/
;;;1555   /*******************************************************************************************************/
;;;1556   #if USE_CODEC_EQ1_DLPS
;;;1557   
;;;1558   uint32_t CODEC_EQ1_StoreReg[5];
;;;1559   
;;;1560   /**
;;;1561     * @brief  CODEC_EQ1 enter dlps callback function(Save CODEC_EQ1 register values when system enter DLPS)
;;;1562     * @param  None
;;;1563     * @retval None
;;;1564     */
;;;1565   __STATIC_INLINE void CODEC_EQ1_DLPS_Enter(void)
;;;1566   {
;;;1567       /* Enable codec function and clock */
;;;1568       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1569   
;;;1570       CODEC_EQ1_StoreReg[0] = CODEC_EQ1->EQ_H0;
;;;1571       CODEC_EQ1_StoreReg[1] = CODEC_EQ1->EQ_B1;
;;;1572       CODEC_EQ1_StoreReg[2] = CODEC_EQ1->EQ_B2;
;;;1573       CODEC_EQ1_StoreReg[3] = CODEC_EQ1->EQ_A1;
;;;1574       CODEC_EQ1_StoreReg[4] = CODEC_EQ1->EQ_A2;
;;;1575   }
;;;1576   
;;;1577   /**
;;;1578     * @brief  CODEC_EQ1 exit dlps callback function(Resume CODEC_EQ1 register values when system exit DLPS)
;;;1579     * @param  None
;;;1580     * @retval None
;;;1581     */
;;;1582   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ1_DLPS_Exit(void)
;;;1583   {
;;;1584       /* Enable codec function and clock */
;;;1585       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1586   
;;;1587       CODEC_EQ1->EQ_H0 = CODEC_EQ1_StoreReg[0];
;;;1588       CODEC_EQ1->EQ_B1 = CODEC_EQ1_StoreReg[1];
;;;1589       CODEC_EQ1->EQ_B2 = CODEC_EQ1_StoreReg[2];
;;;1590       CODEC_EQ1->EQ_A1 = CODEC_EQ1_StoreReg[3];
;;;1591       CODEC_EQ1->EQ_A2 = CODEC_EQ1_StoreReg[4];
;;;1592   }
;;;1593   #endif
;;;1594   
;;;1595   /********************************************** ********************************************************/
;;;1596   /**************************************** [CODEC_EQ2 DLPS] ************************************************/
;;;1597   /*******************************************************************************************************/
;;;1598   /*******************************************************************************************************/
;;;1599   #if USE_CODEC_EQ2_DLPS
;;;1600   
;;;1601   uint32_t CODEC_EQ2_StoreReg[5];
;;;1602   
;;;1603   /**
;;;1604     * @brief  CODEC_EQ2 enter dlps callback function(Save CODEC_EQ2 register values when system enter DLPS)
;;;1605     * @param  None
;;;1606     * @retval None
;;;1607     */
;;;1608   __STATIC_INLINE void CODEC_EQ2_DLPS_Enter(void)
;;;1609   {
;;;1610       /* Enable codec function and clock */
;;;1611       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1612   
;;;1613       CODEC_EQ2_StoreReg[0] = CODEC_EQ2->EQ_H0;
;;;1614       CODEC_EQ2_StoreReg[1] = CODEC_EQ2->EQ_B1;
;;;1615       CODEC_EQ2_StoreReg[2] = CODEC_EQ2->EQ_B2;
;;;1616       CODEC_EQ2_StoreReg[3] = CODEC_EQ2->EQ_A1;
;;;1617       CODEC_EQ2_StoreReg[4] = CODEC_EQ2->EQ_A2;
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  CODEC_EQ2 exit dlps callback function(Resume CODEC_EQ2 register values when system exit DLPS)
;;;1622     * @param  None
;;;1623     * @retval None
;;;1624     */
;;;1625   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ2_DLPS_Exit(void)
;;;1626   {
;;;1627       /* Enable codec function and clock */
;;;1628       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1629   
;;;1630       CODEC_EQ2->EQ_H0 = CODEC_EQ2_StoreReg[0];
;;;1631       CODEC_EQ2->EQ_B1 = CODEC_EQ2_StoreReg[1];
;;;1632       CODEC_EQ2->EQ_B2 = CODEC_EQ2_StoreReg[2];
;;;1633       CODEC_EQ2->EQ_A1 = CODEC_EQ2_StoreReg[3];
;;;1634       CODEC_EQ2->EQ_A2 = CODEC_EQ2_StoreReg[4];
;;;1635   }
;;;1636   #endif
;;;1637   
;;;1638   /********************************************** ********************************************************/
;;;1639   /**************************************** [CODEC_EQ3 DLPS] ************************************************/
;;;1640   /*******************************************************************************************************/
;;;1641   /*******************************************************************************************************/
;;;1642   #if USE_CODEC_EQ3_DLPS
;;;1643   
;;;1644   uint32_t CODEC_EQ3_StoreReg[5];
;;;1645   
;;;1646   /**
;;;1647     * @brief  CODEC_EQ3 enter dlps callback function(Save CODEC_EQ3 register values when system enter DLPS)
;;;1648     * @param  None
;;;1649     * @retval None
;;;1650     */
;;;1651   __STATIC_INLINE void CODEC_EQ3_DLPS_Enter(void)
;;;1652   {
;;;1653       /* Enable codec function and clock */
;;;1654       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1655   
;;;1656       CODEC_EQ3_StoreReg[0] = CODEC_EQ3->EQ_H0;
;;;1657       CODEC_EQ3_StoreReg[1] = CODEC_EQ3->EQ_B1;
;;;1658       CODEC_EQ3_StoreReg[2] = CODEC_EQ3->EQ_B2;
;;;1659       CODEC_EQ3_StoreReg[3] = CODEC_EQ3->EQ_A1;
;;;1660       CODEC_EQ3_StoreReg[4] = CODEC_EQ3->EQ_A2;
;;;1661   }
;;;1662   
;;;1663   /**
;;;1664     * @brief  CODEC_EQ3 exit dlps callback function(Resume CODEC_EQ3 register values when system exit DLPS)
;;;1665     * @param  None
;;;1666     * @retval None
;;;1667     */
;;;1668   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ3_DLPS_Exit(void)
;;;1669   {
;;;1670       /* Enable codec function and clock */
;;;1671       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1672   
;;;1673       CODEC_EQ3->EQ_H0 = CODEC_EQ3_StoreReg[0];
;;;1674       CODEC_EQ3->EQ_B1 = CODEC_EQ3_StoreReg[1];
;;;1675       CODEC_EQ3->EQ_B2 = CODEC_EQ3_StoreReg[2];
;;;1676       CODEC_EQ3->EQ_A1 = CODEC_EQ3_StoreReg[3];
;;;1677       CODEC_EQ3->EQ_A2 = CODEC_EQ3_StoreReg[4];
;;;1678   }
;;;1679   #endif
;;;1680   
;;;1681   /********************************************** ********************************************************/
;;;1682   /**************************************** [CODEC_EQ4 DLPS] ************************************************/
;;;1683   /*******************************************************************************************************/
;;;1684   /*******************************************************************************************************/
;;;1685   #if USE_CODEC_EQ4_DLPS
;;;1686   
;;;1687   uint32_t CODEC_EQ4_StoreReg[5];
;;;1688   
;;;1689   /**
;;;1690     * @brief  CODEC_EQ4 enter dlps callback function(Save CODEC_EQ4 register values when system enter DLPS)
;;;1691     * @param  None
;;;1692     * @retval None
;;;1693     */
;;;1694   __STATIC_INLINE void CODEC_EQ4_DLPS_Enter(void)
;;;1695   {
;;;1696       /* Enable codec function and clock */
;;;1697       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1698   
;;;1699       CODEC_EQ4_StoreReg[0] = CODEC_EQ4->EQ_H0;
;;;1700       CODEC_EQ4_StoreReg[1] = CODEC_EQ4->EQ_B1;
;;;1701       CODEC_EQ4_StoreReg[2] = CODEC_EQ4->EQ_B2;
;;;1702       CODEC_EQ4_StoreReg[3] = CODEC_EQ4->EQ_A1;
;;;1703       CODEC_EQ4_StoreReg[4] = CODEC_EQ4->EQ_A2;
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  CODEC_EQ4 exit dlps callback function(Resume CODEC_EQ4 register values when system exit DLPS)
;;;1708     * @param  None
;;;1709     * @retval None
;;;1710     */
;;;1711   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ4_DLPS_Exit(void)
;;;1712   {
;;;1713       /* Enable codec function and clock */
;;;1714       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1715   
;;;1716       CODEC_EQ4->EQ_H0 = CODEC_EQ4_StoreReg[0];
;;;1717       CODEC_EQ4->EQ_B1 = CODEC_EQ4_StoreReg[1];
;;;1718       CODEC_EQ4->EQ_B2 = CODEC_EQ4_StoreReg[2];
;;;1719       CODEC_EQ4->EQ_A1 = CODEC_EQ4_StoreReg[3];
;;;1720       CODEC_EQ4->EQ_A2 = CODEC_EQ4_StoreReg[4];
;;;1721   }
;;;1722   #endif
;;;1723   
;;;1724   /********************************************** ********************************************************/
;;;1725   /**************************************** [CODEC_EQ5 DLPS] ************************************************/
;;;1726   /*******************************************************************************************************/
;;;1727   /*******************************************************************************************************/
;;;1728   #if USE_CODEC_EQ5_DLPS
;;;1729   
;;;1730   uint32_t CODEC_EQ5_StoreReg[5];
;;;1731   
;;;1732   /**
;;;1733     * @brief  CODEC_EQ5 enter dlps callback function(Save CODEC_EQ5 register values when system enter DLPS)
;;;1734     * @param  None
;;;1735     * @retval None
;;;1736     */
;;;1737   __STATIC_INLINE void CODEC_EQ5_DLPS_Enter(void)
;;;1738   {
;;;1739       /* Enable codec function and clock */
;;;1740       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1741   
;;;1742       CODEC_EQ5_StoreReg[0] = CODEC_EQ5->EQ_H0;
;;;1743       CODEC_EQ5_StoreReg[1] = CODEC_EQ5->EQ_B1;
;;;1744       CODEC_EQ5_StoreReg[2] = CODEC_EQ5->EQ_B2;
;;;1745       CODEC_EQ5_StoreReg[3] = CODEC_EQ5->EQ_A1;
;;;1746       CODEC_EQ5_StoreReg[4] = CODEC_EQ5->EQ_A2;
;;;1747   }
;;;1748   
;;;1749   /**
;;;1750     * @brief  CODEC_EQ5 exit dlps callback function(Resume CODEC_EQ5 register values when system exit DLPS)
;;;1751     * @param  None
;;;1752     * @retval None
;;;1753     */
;;;1754   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ5_DLPS_Exit(void)
;;;1755   {
;;;1756       /* Enable codec function and clock */
;;;1757       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1758   
;;;1759       CODEC_EQ5->EQ_H0 = CODEC_EQ5_StoreReg[0];
;;;1760       CODEC_EQ5->EQ_B1 = CODEC_EQ5_StoreReg[1];
;;;1761       CODEC_EQ5->EQ_B2 = CODEC_EQ5_StoreReg[2];
;;;1762       CODEC_EQ5->EQ_A1 = CODEC_EQ5_StoreReg[3];
;;;1763       CODEC_EQ5->EQ_A2 = CODEC_EQ5_StoreReg[4];
;;;1764   }
;;;1765   #endif
;;;1766   
;;;1767   /**
;;;1768     * @brief  Set Log and SWD pins to SW mode.
;;;1769     * @param  void.
;;;1770     * @retval void.
;;;1771     */
;;;1772   __STATIC_INLINE void Log_SWD_DLPS_Enter(void)
;;;1773   {
;;;1774       if (OTP->SWD_ENABLE)
        0x0080e7ec:    1255        U.      ASRS     r5,r2,#9
        0x0080e7ee:    6201        .b      STR      r1,[r0,#0x20]
        0x0080e7f0:    f8950334    ..4.    LDRB     r0,[r5,#0x334]
        0x0080e7f4:    07c0        ..      LSLS     r0,r0,#31
        0x0080e7f6:    d00f        ..      BEQ      0x80e818 ; DLPS_IO_EnterDlpsCb + 220
;;;1775       {
;;;1776           Pad_Config(P1_0, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0080e7f8:    9400        ..      STR      r4,[sp,#0]
        0x0080e7fa:    2302        .#      MOVS     r3,#2
        0x0080e7fc:    2201        ."      MOVS     r2,#1
        0x0080e7fe:    2100        .!      MOVS     r1,#0
        0x0080e800:    2008        .       MOVS     r0,#8
        0x0080e802:    9401        ..      STR      r4,[sp,#4]
        0x0080e804:    f402f5ea    ....    BL       Pad_Config ; 0x113dc
;;;1777           Pad_Config(P1_1, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0080e808:    9400        ..      STR      r4,[sp,#0]
        0x0080e80a:    2302        .#      MOVS     r3,#2
        0x0080e80c:    2201        ."      MOVS     r2,#1
        0x0080e80e:    2100        .!      MOVS     r1,#0
        0x0080e810:    2009        .       MOVS     r0,#9
        0x0080e812:    9401        ..      STR      r4,[sp,#4]
        0x0080e814:    f402f5e2    ....    BL       Pad_Config ; 0x113dc
;;;1778       }
;;;1779   
;;;1780       Pad_Config(OTP->logPin, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0080e818:    9400        ..      STR      r4,[sp,#0]
        0x0080e81a:    9401        ..      STR      r4,[sp,#4]
        0x0080e81c:    f8950398    ....    LDRB     r0,[r5,#0x398]
        0x0080e820:    2301        .#      MOVS     r3,#1
        0x0080e822:    f000003f    ..?.    AND      r0,r0,#0x3f
        0x0080e826:    461a        .F      MOV      r2,r3
        0x0080e828:    2100        .!      MOVS     r1,#0
        0x0080e82a:    f402f5d7    ....    BL       Pad_Config ; 0x113dc
;;;1781   
;;;1782   }
;;;1783   
;;;1784   /**
;;;1785     * @brief  Set Log and SWD pins to PINMUX mode.
;;;1786     * @param  void.
;;;1787     * @retval void.
;;;1788     */
;;;1789   DATA_RAM_FUNCTION __STATIC_INLINE void Log_SWD_DLPS_Exit(void)
;;;1790   {
;;;1791       Pad_Config(OTP->logPin, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1792   
;;;1793       if (OTP->SWD_ENABLE)
;;;1794       {
;;;1795           Pad_Config(P1_0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1796           Pad_Config(P1_1, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1797       }
;;;1798   }
;;;1799   
;;;1800   /********************************************** ********************************************************/
;;;1801   /*********************************** [USER Exit DLPS CALLBACK FUCN] *****************************************/
;;;1802   /*******************************************************************************************************/
;;;1803   /*******************************************************************************************************/
;;;1804   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;1805   
;;;1806   DLPS_IO_ExitDlpsCB User_IO_ExitDlpsCB = NULL;
;;;1807   
;;;1808   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1809   
;;;1810   /********************************************** ********************************************************/
;;;1811   /*********************************** [USER Enter DLPS CALLBACK FUCN] *****************************************/
;;;1812   /*******************************************************************************************************/
;;;1813   /*******************************************************************************************************/
;;;1814   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1815   
;;;1816   DLPS_IO_EnterDlpsCB User_IO_EnterDlpsCB = NULL;
;;;1817   
;;;1818   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1819   
;;;1820   /********************************************** ********************************************************/
;;;1821   /*********************************** [Enter & Exit DLPS CALLBACK FUNC] *********************************/
;;;1822   /*******************************************************************************************************/
;;;1823   /*******************************************************************************************************/
;;;1824   #if USE_IO_DRIVER_DLPS
;;;1825   
;;;1826   /**
;;;1827     * @brief  IO enter dlps callback function
;;;1828     * @param  None
;;;1829     * @retval None
;;;1830     */
;;;1831   void DLPS_IO_EnterDlpsCb(void)
;;;1832   {
;;;1833       /* low stack do it instead */
;;;1834   //    Pad_ClearAllWakeupINT();
;;;1835   
;;;1836   //    DBG_DIRECT("DLPS_IO_EnterDlpsCb");
;;;1837       NVIC_DisableIRQ(System_IRQn);
;;;1838       CPU_DLPS_Enter();
;;;1839   
;;;1840       Pinmux_DLPS_Enter();
;;;1841   
;;;1842   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1843       if (User_IO_EnterDlpsCB)
;;;1844       {
;;;1845           User_IO_EnterDlpsCB();
;;;1846       }
;;;1847   #endif
;;;1848   
;;;1849   #if USE_I2C0_DLPS
;;;1850       I2C0_DLPS_Enter();
;;;1851   #endif
;;;1852   
;;;1853   #if USE_I2C1_DLPS
;;;1854       I2C1_DLPS_Enter();
;;;1855   #endif
;;;1856   
;;;1857   #if USE_TIM_DLPS
;;;1858       TIM_DLPS_Enter();
;;;1859   #endif
;;;1860   
;;;1861   #if USE_QDECODER_DLPS
;;;1862       QuadDecoder_DLPS_Enter();
;;;1863   #endif
;;;1864   
;;;1865   #if USE_IR_DLPS
;;;1866       IR_DLPS_Enter();
;;;1867   #endif
;;;1868   
;;;1869   #if USE_UART_DLPS
;;;1870       UART_DLPS_Enter();
;;;1871   #endif
;;;1872   
;;;1873   #if USE_UART1_DLPS
;;;1874       UART1_DLPS_Enter();
;;;1875   #endif
;;;1876   
;;;1877   #if USE_UART2_DLPS
;;;1878       UART2_DLPS_Enter();
;;;1879   #endif
;;;1880   
;;;1881   #if USE_SPI0_DLPS
;;;1882       SPI0_DLPS_Enter();
;;;1883   #endif
;;;1884   
;;;1885   #if USE_SPI1_DLPS
;;;1886       SPI1_DLPS_Enter();
;;;1887   #endif
;;;1888   
;;;1889   #if USE_SPI2W_DLPS
;;;1890       SPI2W_DLPS_Enter();
;;;1891   #endif
;;;1892   
;;;1893   #if USE_KEYSCAN_DLPS
;;;1894       KeyScan_DLPS_Enter();
;;;1895   #endif
;;;1896   
;;;1897   #if USE_GPIO_DLPS
;;;1898       GPIO_DLPS_Enter();
;;;1899   #endif
;;;1900   
;;;1901   #if USE_ADC_DLPS
;;;1902       ADC_DLPS_Enter();
;;;1903   #endif
;;;1904   
;;;1905   #if USE_LCD_DLPS
;;;1906       LCD_DLPS_Enter();
;;;1907   #endif
;;;1908   
;;;1909   #if USE_I2S0_DLPS
;;;1910       I2S0_DLPS_Enter();
;;;1911   #endif
;;;1912   
;;;1913   #if USE_I2S1_DLPS
;;;1914       I2S1_DLPS_Enter();
;;;1915   #endif
;;;1916   
;;;1917   #if USE_CODEC_DLPS
;;;1918       CODEC_DLPS_Enter();
;;;1919   #endif
;;;1920   
;;;1921   #if USE_CODEC_EQ1_DLPS
;;;1922       CODEC_EQ1_DLPS_Enter();
;;;1923   #endif
;;;1924   
;;;1925   #if USE_CODEC_EQ2_DLPS
;;;1926       CODEC_EQ2_DLPS_Enter();
;;;1927   #endif
;;;1928   
;;;1929   #if USE_CODEC_EQ3_DLPS
;;;1930       CODEC_EQ3_DLPS_Enter();
;;;1931   #endif
;;;1932   
;;;1933   #if USE_CODEC_EQ4_DLPS
;;;1934       CODEC_EQ4_DLPS_Enter();
;;;1935   #endif
;;;1936   
;;;1937   #if USE_CODEC_EQ5_DLPS
;;;1938       CODEC_EQ5_DLPS_Enter();
;;;1939   #endif
;;;1940   
;;;1941   #if USE_GDMA_DLPS
;;;1942       GDMA_DLPS_Enter();
;;;1943   #endif
;;;1944   
;;;1945       Log_SWD_DLPS_Enter();
;;;1946   
;;;1947   }
        0x0080e82e:    bd7c        |.      POP      {r2-r6,pc}
    DLPS_IORegister
;;;1948   #endif  /* USE_IO_DRIVER_DLPS */
;;;1949   
;;;1950   #if USE_IO_DRIVER_DLPS
;;;1951   /**
;;;1952     * @brief  IO exit dlps callback function.
;;;1953     * @param  None
;;;1954     * @retval None
;;;1955     */
;;;1956   DATA_RAM_FUNCTION void DLPS_IO_ExitDlpsCb(void)
;;;1957   {
;;;1958   
;;;1959   //    DBG_BUFFER(TYPE_BUMBLEBEE3, SUBTYPE_FORMAT, MODULE_DLPS, LEVEL_INFO,
;;;1960   //               "DLPS_IO_ExitDlpsCb",0);
;;;1961   
;;;1962       Pinmux_DLPS_Exit();
;;;1963   
;;;1964       Log_SWD_DLPS_Exit();
;;;1965   
;;;1966   #if USE_I2C0_DLPS
;;;1967       I2C0_DLPS_Exit();
;;;1968   #endif
;;;1969   
;;;1970   #if USE_I2C1_DLPS
;;;1971       I2C1_DLPS_Exit();
;;;1972   #endif
;;;1973   
;;;1974   #if USE_TIM_DLPS
;;;1975       TIM_DLPS_Exit();
;;;1976   #endif
;;;1977   
;;;1978   #if USE_QDECODER_DLPS
;;;1979       QuadDecoder_DLPS_Exit();
;;;1980   #endif
;;;1981   
;;;1982   #if USE_IR_DLPS
;;;1983       IR_DLPS_Exit();
;;;1984   #endif
;;;1985   
;;;1986   #if USE_UART_DLPS
;;;1987       UART_DLPS_Exit();
;;;1988   #endif
;;;1989   
;;;1990   #if USE_UART1_DLPS
;;;1991       UART1_DLPS_Exit();
;;;1992   #endif
;;;1993   
;;;1994   #if USE_UART2_DLPS
;;;1995       UART2_DLPS_Exit();
;;;1996   #endif
;;;1997   
;;;1998   #if USE_SPI0_DLPS
;;;1999       SPI0_DLPS_Exit();
;;;2000   #endif
;;;2001   
;;;2002   #if USE_SPI1_DLPS
;;;2003       SPI1_DLPS_Exit();
;;;2004   #endif
;;;2005   
;;;2006   #if USE_SPI2W_DLPS
;;;2007       SPI2W_DLPS_Exit();
;;;2008   #endif
;;;2009   
;;;2010   #if USE_KEYSCAN_DLPS
;;;2011       KeyScan_DLPS_Exit();
;;;2012   #endif
;;;2013   
;;;2014   #if USE_GPIO_DLPS
;;;2015       GPIO_DLPS_Exit();
;;;2016   #endif
;;;2017   
;;;2018   #if USE_ADC_DLPS
;;;2019       ADC_DLPS_Exit();
;;;2020   #endif
;;;2021   
;;;2022   #if USE_LCD_DLPS
;;;2023       LCD_DLPS_Exit();
;;;2024   #endif
;;;2025   
;;;2026   #if USE_I2S0_DLPS
;;;2027       I2S0_DLPS_Exit();
;;;2028   #endif
;;;2029   
;;;2030   #if USE_I2S1_DLPS
;;;2031       I2S1_DLPS_Exit();
;;;2032   #endif
;;;2033   
;;;2034   #if USE_CODEC_DLPS
;;;2035       CODEC_DLPS_Exit();
;;;2036   #endif
;;;2037   
;;;2038   #if USE_CODEC_EQ1_DLPS
;;;2039       CODEC_EQ1_DLPS_Exit();
;;;2040   #endif
;;;2041   
;;;2042   #if USE_CODEC_EQ2_DLPS
;;;2043       CODEC_EQ2_DLPS_Exit();
;;;2044   #endif
;;;2045   
;;;2046   #if USE_CODEC_EQ3_DLPS
;;;2047       CODEC_EQ3_DLPS_Exit();
;;;2048   #endif
;;;2049   
;;;2050   #if USE_CODEC_EQ4_DLPS
;;;2051       CODEC_EQ4_DLPS_Exit();
;;;2052   #endif
;;;2053   
;;;2054   #if USE_CODEC_EQ5_DLPS
;;;2055       CODEC_EQ5_DLPS_Exit();
;;;2056   #endif
;;;2057   
;;;2058   #if USE_GDMA_DLPS
;;;2059       GDMA_DLPS_Exit();
;;;2060   #endif
;;;2061   
;;;2062   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;2063       if (User_IO_ExitDlpsCB)
;;;2064       {
;;;2065           User_IO_ExitDlpsCB();
;;;2066       }
;;;2067   #endif
;;;2068   
;;;2069       NVIC_InitTypeDef nvic_init_struct;
;;;2070       nvic_init_struct.NVIC_IRQChannel         = System_IRQn;
;;;2071       nvic_init_struct.NVIC_IRQChannelCmd      = (FunctionalState)ENABLE;
;;;2072       nvic_init_struct.NVIC_IRQChannelPriority = 3;
;;;2073       NVIC_Init(&nvic_init_struct); //Enable SYSTEM_ON Interrupt
;;;2074   
;;;2075       CPU_DLPS_Exit();
;;;2076   }
;;;2077   
;;;2078   /**
;;;2079     * @brief  register IO DLPS callback function
;;;2080     * @param  None
;;;2081     * @retval None
;;;2082     */
;;;2083   void DLPS_IORegister(void)
;;;2084   {
        0x0080e830:    b510        ..      PUSH     {r4,lr}
;;;2085       dlps_hw_control_cb_reg(DLPS_IO_EnterDlpsCb, DLPS_ENTER);
        0x0080e832:    2100        .!      MOVS     r1,#0
        0x0080e834:    f2af00fb    ....    ADR      r0,{pc}-0xf7 ; 0x80e73d
        0x0080e838:    f7f9df59    ..Y.    BL       dlps_hw_control_cb_reg ; 0x86ee
;;;2086       dlps_hw_control_cb_reg(DLPS_IO_ExitDlpsCb, DLPS_EXIT4_BT_READY);
        0x0080e83c:    e8bd4010    ...@    POP      {r4,lr}
        0x0080e840:    2104        .!      MOVS     r1,#4
        0x0080e842:    4805        .H      LDR      r0,[pc,#20] ; [0x80e858] = 0x207d25
        0x0080e844:    f7f99f53    ..S.    B        dlps_hw_control_cb_reg ; 0x86ee
    $d
        0x0080e848:    00207f38    8. .    DCD    2129720
        0x0080e84c:    e000ed08    ....    DCD    3758157064
        0x0080e850:    40006000    .`.@    DCD    1073766400
        0x0080e854:    40001000    ...@    DCD    1073745920
        0x0080e858:    00207d25    %} .    DCD    2129189
    $t
    .text
    GPIO_DeInit
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_gpio.c
;;;33         RCC_PeriphClockCmd(APBPeriph_GPIO, APBPeriph_GPIO_CLOCK, DISABLE);
        0x0080e85c:    2200        ."      MOVS     r2,#0
        0x0080e85e:    f04f5104    O..Q    MOV      r1,#0x21000000
        0x0080e862:    485d        ]H      LDR      r0,[pc,#372] ; [0x80e9d8] = 0xc000100
        0x0080e864:    f000b8bc    ....    B.W      RCC_PeriphClockCmd ; 0x80e9e0
    GPIO_Init
;;;34     }
;;;35     
;;;36     /**
;;;37       * @brief  Initializes the GPIO peripheral according to the specified
;;;38       *         parameters in the GPIO_InitStruct.
;;;39       * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
;;;40       *         contains the configuration information for the specified GPIO peripheral.
;;;41       * @retval None
;;;42       */
;;;43     void GPIO_Init(GPIO_InitTypeDef *GPIO_InitStruct)
;;;44     {
;;;45         /* Check the parameters */
;;;46         assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;47         assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;48         assert_param(IS_GPIOIT_LEVEL_TYPE(GPIO_InitStruct->GPIO_ITTrigger));
;;;49         assert_param(IS_GPIOIT_POLARITY_TYPE(GPIO_InitStruct->GPIO_ITPolarity));
;;;50         assert_param(IS_GPIOIT_DEBOUNCE_TYPE(GPIO_InitStruct->GPIO_ITDebounce));
;;;51     
;;;52         /* GPIO configure */
;;;53         if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT)
        0x0080e868:    7903        .y      LDRB     r3,[r0,#4]
        0x0080e86a:    495c        \I      LDR      r1,[pc,#368] ; [0x80e9dc] = 0x40001000
        0x0080e86c:    2b01        .+      CMP      r3,#1
        0x0080e86e:    6802        .h      LDR      r2,[r0,#0]
        0x0080e870:    684b        Kh      LDR      r3,[r1,#4]
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_gpio.c (44)
        0x0080e872:    d030        0.      BEQ      0x80e8d6 ; GPIO_Init + 110
;;;45         /* Check the parameters */
;;;46         assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;47         assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;48         assert_param(IS_GPIOIT_LEVEL_TYPE(GPIO_InitStruct->GPIO_ITTrigger));
;;;49         assert_param(IS_GPIOIT_POLARITY_TYPE(GPIO_InitStruct->GPIO_ITPolarity));
;;;50         assert_param(IS_GPIOIT_DEBOUNCE_TYPE(GPIO_InitStruct->GPIO_ITDebounce));
;;;51     
;;;52         /* GPIO configure */
;;;53         if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT)
;;;54         {
;;;55             GPIO->DATADIR |= GPIO_InitStruct->GPIO_Pin;
;;;56     
;;;57             if (GPIO_InitStruct->GPIO_ControlMode == GPIO_SOFTWARE_MODE)
;;;58             {
;;;59                 /* Config GPIO control software mode */
;;;60                 GPIO->DATASRC &= (~GPIO_InitStruct->GPIO_Pin);
;;;61             }
;;;62             else
;;;63             {
;;;64                 /* Config GPIO hardware control mode */
;;;65                 GPIO->DATASRC |= (GPIO_InitStruct->GPIO_Pin);
;;;66             }
;;;67     
;;;68         }
;;;69         else
;;;70         {
;;;71             /*Configure GPIO input mode */
;;;72             GPIO->DATADIR = GPIO->DATADIR & (~GPIO_InitStruct->GPIO_Pin);
        0x0080e874:    4393        .C      BICS     r3,r3,r2
        0x0080e876:    604b        K`      STR      r3,[r1,#4]
;;;73     
;;;74             if (GPIO_InitStruct->GPIO_ITCmd == ENABLE)
        0x0080e878:    7942        By      LDRB     r2,[r0,#5]
        0x0080e87a:    2a01        .*      CMP      r2,#1
        0x0080e87c:    d12a        *.      BNE      0x80e8d4 ; GPIO_Init + 108
;;;75             {
;;;76     
;;;77                 GPIO->INTMASK = ~GPIO_Pin_All;
        0x0080e87e:    2200        ."      MOVS     r2,#0
        0x0080e880:    634a        Jc      STR      r2,[r1,#0x34]
;;;78     
;;;79                 /* configure GPIO interrupt trigger type */
;;;80                 if (GPIO_InitStruct->GPIO_ITTrigger == GPIO_INT_Trigger_LEVEL)
        0x0080e882:    7982        .y      LDRB     r2,[r0,#6]
        0x0080e884:    b38a        ..      CBZ      r2,0x80e8ea ; GPIO_Init + 130
;;;81                 {
;;;82                     GPIO->INTTYPE = GPIO->INTTYPE & (~GPIO_InitStruct->GPIO_Pin);
;;;83     
;;;84                     /* Level-sensitive synchronization enable register */
;;;85                     GPIO->LSSYNC |= GPIO_InitStruct->GPIO_Pin;
;;;86                 }
;;;87                 else if (GPIO_InitStruct->GPIO_ITTrigger == GPIO_INT_Trigger_EDGE)
        0x0080e886:    2a01        .*      CMP      r2,#1
        0x0080e888:    d03d        =.      BEQ      0x80e906 ; GPIO_Init + 158
;;;88                 {
;;;89                     GPIO->INTTYPE = (GPIO->INTTYPE & (~GPIO_InitStruct->GPIO_Pin))
;;;90                                     | GPIO_InitStruct->GPIO_Pin;
;;;91                 }
;;;92                 else
;;;93                 {
;;;94                     GPIO->INTBOTHEDGE |= GPIO_InitStruct->GPIO_Pin;
        0x0080e88a:    6e8a        .n      LDR      r2,[r1,#0x68]
        0x0080e88c:    6803        .h      LDR      r3,[r0,#0]
        0x0080e88e:    431a        .C      ORRS     r2,r2,r3
        0x0080e890:    668a        .f      STR      r2,[r1,#0x68]
;;;95                 }
;;;96     
;;;97                 /* configure Interrupt polarity register */
;;;98                 if (GPIO_InitStruct->GPIO_ITPolarity == GPIO_INT_POLARITY_ACTIVE_LOW)
        0x0080e892:    79c2        .y      LDRB     r2,[r0,#7]
        0x0080e894:    b352        R.      CBZ      r2,0x80e8ec ; GPIO_Init + 132
;;;99                 {
;;;100                    GPIO->INTPOLARITY = GPIO->INTPOLARITY & (~GPIO_InitStruct->GPIO_Pin);
;;;101                }
;;;102                else
;;;103                {
;;;104                    GPIO->INTPOLARITY = (GPIO->INTPOLARITY & (~GPIO_InitStruct->GPIO_Pin))
        0x0080e896:    6bcb        .k      LDR      r3,[r1,#0x3c]
        0x0080e898:    6802        .h      LDR      r2,[r0,#0]
        0x0080e89a:    4393        .C      BICS     r3,r3,r2
        0x0080e89c:    4313        .C      ORRS     r3,r3,r2
        0x0080e89e:    63cb        .c      STR      r3,[r1,#0x3c]
;;;105                                        | GPIO_InitStruct->GPIO_Pin;
;;;106                }
;;;107                /* Configure Debounce enable register */
;;;108                if (GPIO_InitStruct->GPIO_ITDebounce == GPIO_INT_DEBOUNCE_DISABLE)
        0x0080e8a0:    7a02        .z      LDRB     r2,[r0,#8]
        0x0080e8a2:    b37a        z.      CBZ      r2,0x80e904 ; GPIO_Init + 156
;;;109                {
;;;110                    GPIO->DEBOUNCE = GPIO->DEBOUNCE & (~GPIO_InitStruct->GPIO_Pin);
;;;111                }
;;;112                else
;;;113                {
;;;114                    GPIO->DEBOUNCE = (GPIO->DEBOUNCE & (~GPIO_InitStruct->GPIO_Pin))
        0x0080e8a4:    6c8b        .l      LDR      r3,[r1,#0x48]
        0x0080e8a6:    6802        .h      LDR      r2,[r0,#0]
        0x0080e8a8:    4393        .C      BICS     r3,r3,r2
        0x0080e8aa:    4313        .C      ORRS     r3,r3,r2
        0x0080e8ac:    648b        .d      STR      r3,[r1,#0x48]
;;;115                                     | GPIO_InitStruct->GPIO_Pin;
;;;116    
;;;117    #ifdef _IS_ASIC_
;;;118                    /* Config debounce time , default debounce DIV is 14*/
;;;119                    GPIO_DBCLK_DIV = (((0xd) << 8) | (1 << 12));
;;;120                    GPIO_DBCLK_DIV |= ((((GPIO_InitStruct->GPIO_DebounceTime) * (GPIO_CLOCK_SOURCE_KHZ) >>
;;;121                                         (14)) - 1) & 0xff);
;;;122    #else
;;;123                    /* Config debounce time , default debounce DIV is 13*/
;;;124                    GPIO_DBCLK_DIV = (((0x3) << 10) | (1 << 12));
        0x0080e8ae:    f04f4180    O..A    MOV      r1,#0x40000000
        0x0080e8b2:    f44f52e0    O..R    MOV      r2,#0x1c00
        0x0080e8b6:    f8c12344    ..D#    STR      r2,[r1,#0x344]
;;;125                    GPIO_DBCLK_DIV |= ((((GPIO_InitStruct->GPIO_DebounceTime) * (GPIO_CLOCK_SOURCE_KHZ) >>
        0x0080e8ba:    f8d12344    ..D#    LDR      r2,[r1,#0x344]
        0x0080e8be:    68c0        .h      LDR      r0,[r0,#0xc]
        0x0080e8c0:    f6446320    D. c    MOV      r3,#0x4e20
        0x0080e8c4:    4358        XC      MULS     r0,r3,r0
        0x0080e8c6:    23ff        .#      MOVS     r3,#0xff
        0x0080e8c8:    eb033050    ..P0    ADD      r0,r3,r0,LSR #13
        0x0080e8cc:    b2c0        ..      UXTB     r0,r0
        0x0080e8ce:    4302        .C      ORRS     r2,r2,r0
        0x0080e8d0:    f8c12344    ..D#    STR      r2,[r1,#0x344]
;;;126                                         (13)) - 1) & 0xff);
;;;127    #endif
;;;128                }
;;;129    
;;;130                /* Configure Interrupt enable register */
;;;131                //GPIO->INTEN |= GPIO_InitStruct->GPIO_Pin;
;;;132            }
;;;133        }
;;;134    }
        0x0080e8d4:    4770        pG      BX       lr
        0x0080e8d6:    4313        .C      ORRS     r3,r3,r2
        0x0080e8d8:    604b        K`      STR      r3,[r1,#4]
        0x0080e8da:    7a42        Bz      LDRB     r2,[r0,#9]
        0x0080e8dc:    2a00        .*      CMP      r2,#0
        0x0080e8de:    688a        .h      LDR      r2,[r1,#8]
        0x0080e8e0:    6800        .h      LDR      r0,[r0,#0]
        0x0080e8e2:    d004        ..      BEQ      0x80e8ee ; GPIO_Init + 134
        0x0080e8e4:    4302        .C      ORRS     r2,r2,r0
        0x0080e8e6:    608a        .`      STR      r2,[r1,#8]
        0x0080e8e8:    4770        pG      BX       lr
        0x0080e8ea:    e002        ..      B        0x80e8f2 ; GPIO_Init + 138
        0x0080e8ec:    e011        ..      B        0x80e912 ; GPIO_Init + 170
        0x0080e8ee:    4382        .C      BICS     r2,r2,r0
        0x0080e8f0:    e7f9        ..      B        0x80e8e6 ; GPIO_Init + 126
        0x0080e8f2:    6b8a        .k      LDR      r2,[r1,#0x38]
        0x0080e8f4:    6803        .h      LDR      r3,[r0,#0]
        0x0080e8f6:    439a        .C      BICS     r2,r2,r3
        0x0080e8f8:    638a        .c      STR      r2,[r1,#0x38]
        0x0080e8fa:    6e0a        .n      LDR      r2,[r1,#0x60]
        0x0080e8fc:    6803        .h      LDR      r3,[r0,#0]
        0x0080e8fe:    431a        .C      ORRS     r2,r2,r3
        0x0080e900:    660a        .f      STR      r2,[r1,#0x60]
        0x0080e902:    e7c6        ..      B        0x80e892 ; GPIO_Init + 42
        0x0080e904:    e00a        ..      B        0x80e91c ; GPIO_Init + 180
        0x0080e906:    6b8b        .k      LDR      r3,[r1,#0x38]
        0x0080e908:    6802        .h      LDR      r2,[r0,#0]
        0x0080e90a:    4393        .C      BICS     r3,r3,r2
        0x0080e90c:    4313        .C      ORRS     r3,r3,r2
        0x0080e90e:    638b        .c      STR      r3,[r1,#0x38]
        0x0080e910:    e7bf        ..      B        0x80e892 ; GPIO_Init + 42
        0x0080e912:    6bca        .k      LDR      r2,[r1,#0x3c]
        0x0080e914:    6803        .h      LDR      r3,[r0,#0]
        0x0080e916:    439a        .C      BICS     r2,r2,r3
        0x0080e918:    63ca        .c      STR      r2,[r1,#0x3c]
        0x0080e91a:    e7c1        ..      B        0x80e8a0 ; GPIO_Init + 56
        0x0080e91c:    6c8a        .l      LDR      r2,[r1,#0x48]
        0x0080e91e:    6800        .h      LDR      r0,[r0,#0]
        0x0080e920:    4382        .C      BICS     r2,r2,r0
        0x0080e922:    648a        .d      STR      r2,[r1,#0x48]
        0x0080e924:    e7e0        ..      B        0x80e8e8 ; GPIO_Init + 128
    GPIO_StructInit
;;;135    
;;;136    /**
;;;137      * @brief    Fills each GPIO_InitStruct member with its default value.
;;;138      * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will
;;;139      *    be initialized.
;;;140      * @retval None
;;;141      */
;;;142    void GPIO_StructInit(GPIO_InitTypeDef *GPIO_InitStruct)
;;;143    {
;;;144        /* Reset GPIO init structure parameters values */
;;;145        GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
        0x0080e926:    f04f31ff    O..1    MOV      r1,#0xffffffff
;;;146        GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
        0x0080e92a:    6001        .`      STR      r1,[r0,#0]
        0x0080e92c:    2100        .!      MOVS     r1,#0
        0x0080e92e:    7101        .q      STRB     r1,[r0,#4]
;;;147        GPIO_InitStruct->GPIO_ITCmd = DISABLE;
        0x0080e930:    7141        Aq      STRB     r1,[r0,#5]
;;;148        GPIO_InitStruct->GPIO_ITTrigger = GPIO_INT_Trigger_LEVEL;
        0x0080e932:    7181        .q      STRB     r1,[r0,#6]
;;;149        GPIO_InitStruct->GPIO_ITPolarity = GPIO_INT_POLARITY_ACTIVE_LOW;
        0x0080e934:    71c1        .q      STRB     r1,[r0,#7]
;;;150        GPIO_InitStruct->GPIO_ITDebounce = GPIO_INT_DEBOUNCE_DISABLE;
        0x0080e936:    7201        .r      STRB     r1,[r0,#8]
;;;151        GPIO_InitStruct->GPIO_ControlMode = GPIO_SOFTWARE_MODE;
        0x0080e938:    7241        Ar      STRB     r1,[r0,#9]
;;;152        GPIO_InitStruct->GPIO_DebounceTime = 20;                 /* ms , can be 1~64 ms */
        0x0080e93a:    2114        .!      MOVS     r1,#0x14
        0x0080e93c:    60c1        .`      STR      r1,[r0,#0xc]
;;;153    }
        0x0080e93e:    e7d3        ..      B        0x80e8e8 ; GPIO_Init + 128
    GPIO_INTConfig
;;;154    
;;;155    /**
;;;156      * @brief enable the specified GPIO interrupt.
;;;157      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;158      * @retval None
;;;159      */
;;;160    void GPIO_INTConfig(uint32_t GPIO_Pin, FunctionalState NewState)
;;;161    {
;;;162        /* Check the parameters */
;;;163        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;164        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;165    
;;;166        if (NewState != DISABLE)
;;;167        {
;;;168            /* Enable the selected GPIO pin interrupts */
;;;169            GPIO->INTEN |= GPIO_Pin;
        0x0080e940:    4a26        &J      LDR      r2,[pc,#152] ; [0x80e9dc] = 0x40001000
        0x0080e942:    2900        .)      CMP      r1,#0
        0x0080e944:    6b11        .k      LDR      r1,[r2,#0x30]
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_gpio.c (161)
        0x0080e946:    d001        ..      BEQ      0x80e94c ; GPIO_INTConfig + 12
;;;162        /* Check the parameters */
;;;163        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;164        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;165    
;;;166        if (NewState != DISABLE)
;;;167        {
;;;168            /* Enable the selected GPIO pin interrupts */
;;;169            GPIO->INTEN |= GPIO_Pin;
        0x0080e948:    4301        .C      ORRS     r1,r1,r0
        0x0080e94a:    e000        ..      B        0x80e94e ; GPIO_INTConfig + 14
        0x0080e94c:    4381        .C      BICS     r1,r1,r0
        0x0080e94e:    6311        .c      STR      r1,[r2,#0x30]
;;;170        }
;;;171        else
;;;172        {
;;;173            /* Disable the selected GPIO pin interrupts */
;;;174            GPIO->INTEN &= ~GPIO_Pin;
;;;175        }
;;;176    }
        0x0080e950:    e7ca        ..      B        0x80e8e8 ; GPIO_Init + 128
    GPIO_ClearINTPendingBit
;;;177    
;;;178    /**
;;;179      * @brief clear the specified GPIO interrupt.
;;;180      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;181      * @retval None
;;;182      */
;;;183    void GPIO_ClearINTPendingBit(uint32_t GPIO_Pin)
;;;184    {
;;;185        /* Check the parameters */
;;;186        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;187    
;;;188        GPIO->INTCLR = GPIO_Pin;
        0x0080e952:    4922        "I      LDR      r1,[pc,#136] ; [0x80e9dc] = 0x40001000
        0x0080e954:    64c8        .d      STR      r0,[r1,#0x4c]
;;;189    }
        0x0080e956:    e7c7        ..      B        0x80e8e8 ; GPIO_Init + 128
    GPIO_MaskINTConfig
;;;190    
;;;191    /**
;;;192      * @brief mask the specified GPIO interrupt.
;;;193      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;194      * @retval None
;;;195      */
;;;196    void GPIO_MaskINTConfig(uint32_t GPIO_Pin, FunctionalState NewState)
;;;197    {
;;;198        /* Check the parameters */
;;;199        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;200        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;201    
;;;202        if (NewState != DISABLE)
;;;203        {
;;;204            GPIO->INTMASK |= GPIO_Pin;
        0x0080e958:    4a20         J      LDR      r2,[pc,#128] ; [0x80e9dc] = 0x40001000
        0x0080e95a:    2900        .)      CMP      r1,#0
        0x0080e95c:    6b51        Qk      LDR      r1,[r2,#0x34]
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_gpio.c (197)
        0x0080e95e:    d001        ..      BEQ      0x80e964 ; GPIO_MaskINTConfig + 12
;;;198        /* Check the parameters */
;;;199        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;200        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;201    
;;;202        if (NewState != DISABLE)
;;;203        {
;;;204            GPIO->INTMASK |= GPIO_Pin;
        0x0080e960:    4301        .C      ORRS     r1,r1,r0
        0x0080e962:    e000        ..      B        0x80e966 ; GPIO_MaskINTConfig + 14
        0x0080e964:    4381        .C      BICS     r1,r1,r0
        0x0080e966:    6351        Qc      STR      r1,[r2,#0x34]
;;;205        }
;;;206        else
;;;207        {
;;;208            GPIO->INTMASK &= ~(GPIO_Pin);
;;;209        }
;;;210    }
        0x0080e968:    e7be        ..      B        0x80e8e8 ; GPIO_Init + 128
    GPIO_GetPin
        0x0080e96a:    2101        .!      MOVS     r1,#1
        0x0080e96c:    281e        .(      CMP      r0,#0x1e
;;;211    
;;;212    /**
;;;213      * @brief get the specified GPIO pin.
;;;214      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;215      * @retval  GPIO pin for GPIO initialization.
;;;216      */
;;;217    uint32_t GPIO_GetPin(uint8_t Pin_num)
;;;218    {
        0x0080e96e:    d90e        ..      BLS      0x80e98e ; GPIO_GetPin + 36
;;;219        /* Check the parameters */
;;;220        assert_param(IS_PIN_NUM(Pin_num));
;;;221    
;;;222        if (Pin_num <= P3_6)
;;;223        {
;;;224            return  BIT(Pin_num);
;;;225        }
;;;226        else if ((Pin_num <= P4_3) && (Pin_num >= P4_0))
        0x0080e970:    f1a00220    .. .    SUB      r2,r0,#0x20
        0x0080e974:    2a03        .*      CMP      r2,#3
        0x0080e976:    d801        ..      BHI      0x80e97c ; GPIO_GetPin + 18
        0x0080e978:    1f00        ..      SUBS     r0,r0,#4
;;;227        {
;;;228            return BIT(Pin_num - 4);
        0x0080e97a:    e008        ..      B        0x80e98e ; GPIO_GetPin + 36
;;;229        }
;;;230        else if ((Pin_num == H_0) || (Pin_num == H_1) || (Pin_num == H_2))
        0x0080e97c:    2824        $(      CMP      r0,#0x24
        0x0080e97e:    d005        ..      BEQ      0x80e98c ; GPIO_GetPin + 34
        0x0080e980:    2825        %(      CMP      r0,#0x25
        0x0080e982:    d003        ..      BEQ      0x80e98c ; GPIO_GetPin + 34
        0x0080e984:    2826        &(      CMP      r0,#0x26
        0x0080e986:    d001        ..      BEQ      0x80e98c ; GPIO_GetPin + 34
        0x0080e988:    20ff        .       MOVS     r0,#0xff
        0x0080e98a:    e7ad        ..      B        0x80e8e8 ; GPIO_Init + 128
        0x0080e98c:    380b        .8      SUBS     r0,r0,#0xb
;;;231        {
;;;232            return BIT(Pin_num - 11);
        0x0080e98e:    fa01f000    ....    LSL      r0,r1,r0
;;;233        }
;;;234    
;;;235        return 0xFF;
;;;236    }
        0x0080e992:    e7a9        ..      B        0x80e8e8 ; GPIO_Init + 128
    GPIO_GetNum
;;;237    
;;;238    /**
;;;239      * @brief get the specified GPIO pin number.
;;;240      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;241      * @retval  GPIO pin number.
;;;242      */
;;;243    uint8_t GPIO_GetNum(uint8_t Pin_num)
;;;244    {
;;;245        /* Check the parameters */
;;;246        assert_param(IS_PIN_NUM(Pin_num));
;;;247    
;;;248        if (Pin_num <= P3_6)
        0x0080e994:    281e        .(      CMP      r0,#0x1e
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_gpio.c (244)
        0x0080e996:    d9a7        ..      BLS      0x80e8e8 ; GPIO_Init + 128
;;;245        /* Check the parameters */
;;;246        assert_param(IS_PIN_NUM(Pin_num));
;;;247    
;;;248        if (Pin_num <= P3_6)
;;;249        {
;;;250            return (Pin_num);
;;;251        }
;;;252        else if ((Pin_num <= P4_3) && (Pin_num >= P4_0))
        0x0080e998:    f1a00120    .. .    SUB      r1,r0,#0x20
        0x0080e99c:    2903        .)      CMP      r1,#3
        0x0080e99e:    d801        ..      BHI      0x80e9a4 ; GPIO_GetNum + 16
        0x0080e9a0:    1f00        ..      SUBS     r0,r0,#4
;;;253        {
;;;254            return (Pin_num - 4);
        0x0080e9a2:    e008        ..      B        0x80e9b6 ; GPIO_GetNum + 34
;;;255        }
;;;256        else if ((Pin_num == H_0) || (Pin_num == H_1) || (Pin_num == H_2))
        0x0080e9a4:    2824        $(      CMP      r0,#0x24
        0x0080e9a6:    d005        ..      BEQ      0x80e9b4 ; GPIO_GetNum + 32
        0x0080e9a8:    2825        %(      CMP      r0,#0x25
        0x0080e9aa:    d003        ..      BEQ      0x80e9b4 ; GPIO_GetNum + 32
        0x0080e9ac:    2826        &(      CMP      r0,#0x26
        0x0080e9ae:    d001        ..      BEQ      0x80e9b4 ; GPIO_GetNum + 32
        0x0080e9b0:    20ff        .       MOVS     r0,#0xff
        0x0080e9b2:    e799        ..      B        0x80e8e8 ; GPIO_Init + 128
        0x0080e9b4:    380b        .8      SUBS     r0,r0,#0xb
;;;257        {
;;;258            return (Pin_num - 11);
        0x0080e9b6:    b2c0        ..      UXTB     r0,r0
;;;259        }
;;;260    
;;;261        return 0xFF;
;;;262    }
        0x0080e9b8:    e796        ..      B        0x80e8e8 ; GPIO_Init + 128
    GPIO_DBClkCmd
        0x0080e9ba:    f04f4180    O..A    MOV      r1,#0x40000000
        0x0080e9be:    2800        .(      CMP      r0,#0
        0x0080e9c0:    f8d10344    ..D.    LDR      r0,[r1,#0x344]
;;;263    
;;;264    /**
;;;265      * @brief get the specified GPIO pin number.
;;;266      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;267      * @retval  GPIO pin number.
;;;268      */
;;;269    void GPIO_DBClkCmd(FunctionalState NewState)
;;;270    {
        0x0080e9c4:    d002        ..      BEQ      0x80e9cc ; GPIO_DBClkCmd + 18
;;;271        if (NewState != DISABLE)
;;;272        {
;;;273            GPIO_DBCLK_DIV |= BIT12;
        0x0080e9c6:    f4405080    @..P    ORR      r0,r0,#0x1000
        0x0080e9ca:    e001        ..      B        0x80e9d0 ; GPIO_DBClkCmd + 22
        0x0080e9cc:    f4205080     ..P    BIC      r0,r0,#0x1000
        0x0080e9d0:    f8c10344    ..D.    STR      r0,[r1,#0x344]
;;;274        }
;;;275        else
;;;276        {
;;;277            GPIO_DBCLK_DIV &= ~BIT12;
;;;278        }
;;;279    }
        0x0080e9d4:    e788        ..      B        0x80e8e8 ; GPIO_Init + 128
    $d
        0x0080e9d6:    0000        ..      DCW    0
        0x0080e9d8:    0c000100    ....    DCD    201326848
        0x0080e9dc:    40001000    ...@    DCD    1073745920
    $t
    .text
    RCC_PeriphClockCmd
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_rcc.c
;;;66     {
        0x0080e9e0:    b5f0        ..      PUSH     {r4-r7,lr}
        0x0080e9e2:    f44f7790    O..w    MOV      r7,#0x120
        0x0080e9e6:    067b        {.      LSLS     r3,r7,#25
;;;67         /* Check the parameters */
;;;68         assert_param(IS_APB_PERIPH(APBPeriph));
;;;69         assert_param(IS_APB_PERIPH_CLOCK(APBPeriph_Clock));
;;;70         assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;71     
;;;72         uint32_t apbRegOff = ((APBPeriph & (0x03 << 26)) >> 26);
        0x0080e9e8:    f3c06681    ...f    UBFX     r6,r0,#26,#2
;;;73         uint32_t clkRegOff = ((APBPeriph_Clock & (0x03 << 29)) >> 29);
        0x0080e9ec:    f3c17541    ..Au    UBFX     r5,r1,#29,#2
        0x0080e9f0:    f44f7ea0    O..~    MOV      lr,#0x140
        0x0080e9f4:    ea400401    @...    ORR      r4,r0,r1
;;;74     
;;;75         /*Open clock gating first*/
;;;76         if (NewState == ENABLE)
        0x0080e9f8:    2a01        .*      CMP      r2,#1
        0x0080e9fa:    d006        ..      BEQ      0x80ea0a ; RCC_PeriphClockCmd + 42
        0x0080e9fc:    42b9        .B      CMP      r1,r7
        0x0080e9fe:    d06f        o.      BEQ      0x80eae0 ; RCC_PeriphClockCmd + 256
        0x0080ea00:    4571        qE      CMP      r1,lr
        0x0080ea02:    d06d        m.      BEQ      0x80eae0 ; RCC_PeriphClockCmd + 256
        0x0080ea04:    2910        .)      CMP      r1,#0x10
        0x0080ea06:    d06b        k.      BEQ      0x80eae0 ; RCC_PeriphClockCmd + 256
        0x0080ea08:    e04b        K.      B        0x80eaa2 ; RCC_PeriphClockCmd + 194
;;;77         {
;;;78             if (APBPeriph_Clock == APBPeriph_KEYSCAN_CLOCK)
        0x0080ea0a:    f1a14cc0    ...L    SUB      r12,r1,#0x60000000
        0x0080ea0e:    f1bc0c40    ..@.    SUBS     r12,r12,#0x40
        0x0080ea12:    d018        ..      BEQ      0x80ea46 ; RCC_PeriphClockCmd + 102
        0x0080ea14:    f1b14fc2    ...O    CMP      r1,#0x61000000
        0x0080ea18:    d020         .      BEQ      0x80ea5c ; RCC_PeriphClockCmd + 124
        0x0080ea1a:    f1a14cc0    ...L    SUB      r12,r1,#0x60000000
        0x0080ea1e:    f1bc0c10    ....    SUBS     r12,r12,#0x10
        0x0080ea22:    d003        ..      BEQ      0x80ea2c ; RCC_PeriphClockCmd + 76
        0x0080ea24:    f8dfc2f0    ....    LDR      r12,[pc,#752] ; [0x80ed18] = 0x60010000
        0x0080ea28:    4561        aE      CMP      r1,r12
        0x0080ea2a:    d124        $.      BNE      0x80ea76 ; RCC_PeriphClockCmd + 150
        0x0080ea2c:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x0080ea30:    f04c6c80    L..l    ORR      r12,r12,#0x4000000
        0x0080ea34:    f8c3c20c    ....    STR      r12,[r3,#0x20c]
        0x0080ea38:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x0080ea3c:    f04c6c00    L..l    ORR      r12,r12,#0x8000000
        0x0080ea40:    f8c3c20c    ....    STR      r12,[r3,#0x20c]
        0x0080ea44:    e027        '.      B        0x80ea96 ; RCC_PeriphClockCmd + 182
;;;79             {
;;;80                 /*Open 5M clock source*/
;;;81                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
        0x0080ea46:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x0080ea4a:    f04c6c80    L..l    ORR      r12,r12,#0x4000000
        0x0080ea4e:    f8c3c20c    ....    STR      r12,[r3,#0x20c]
;;;82                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
        0x0080ea52:    f8d3c20c    ....    LDR      r12,[r3,#0x20c]
        0x0080ea56:    f04c5c00    L..\    ORR      r12,r12,#0x20000000
        0x0080ea5a:    e7f1        ..      B        0x80ea40 ; RCC_PeriphClockCmd + 96
;;;83             }
;;;84             else if (APBPeriph_Clock == APBPeriph_ADC_CLOCK)
;;;85             {
;;;86                 /*Open 10M clock source*/
;;;87                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
        0x0080ea5c:    f8d3420c    ...B    LDR      r4,[r3,#0x20c]
        0x0080ea60:    f0446480    D..d    ORR      r4,r4,#0x4000000
        0x0080ea64:    f8c3420c    ...B    STR      r4,[r3,#0x20c]
;;;88                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
        0x0080ea68:    f8d3420c    ...B    LDR      r4,[r3,#0x20c]
        0x0080ea6c:    f0445480    D..T    ORR      r4,r4,#0x10000000
        0x0080ea70:    f8c3420c    ...B    STR      r4,[r3,#0x20c]
        0x0080ea74:    e015        ..      B        0x80eaa2 ; RCC_PeriphClockCmd + 194
;;;89             }
;;;90             else if ((APBPeriph_Clock == APBPeriph_QDEC_CLOCK) || (APBPeriph_Clock == APBPeriph_SPI2W_CLOCK))
;;;91             {
;;;92                 /*Open 20M clock source*/
;;;93                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;94                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;95             }
;;;96             else if (APBPeriph_Clock == APBPeriph_TIMER_CLOCK)
        0x0080ea76:    f8dfc2a4    ....    LDR      r12,[pc,#676] ; [0x80ed1c] = 0x20004000
        0x0080ea7a:    4561        aE      CMP      r1,r12
        0x0080ea7c:    d10b        ..      BNE      0x80ea96 ; RCC_PeriphClockCmd + 182
;;;97             {
;;;98                 /* Enable TIM0~1 fixed 40M */
;;;99                 CLK_SOURCE_REG_2 |= BIT9;
        0x0080ea7e:    f8d3c360    ..`.    LDR      r12,[r3,#0x360]
        0x0080ea82:    f44c7c00    L..|    ORR      r12,r12,#0x200
        0x0080ea86:    f8c3c360    ..`.    STR      r12,[r3,#0x360]
;;;100                /* enable TIM2~7 ICG*/
;;;101                CLK_SOURCE_REG_0 |= BIT4;
        0x0080ea8a:    f8d3c348    ..H.    LDR      r12,[r3,#0x348]
        0x0080ea8e:    f04c0c10    L...    ORR      r12,r12,#0x10
        0x0080ea92:    f8c3c348    ..H.    STR      r12,[r3,#0x348]
;;;102            }
;;;103        }
;;;104    
;;;105        /* Special register handle */
;;;106        if (NewState == ENABLE)
;;;107        {
;;;108            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
        0x0080ea96:    42b9        .B      CMP      r1,r7
        0x0080ea98:    d01d        ..      BEQ      0x80ead6 ; RCC_PeriphClockCmd + 246
        0x0080ea9a:    4571        qE      CMP      r1,lr
        0x0080ea9c:    d01b        ..      BEQ      0x80ead6 ; RCC_PeriphClockCmd + 246
;;;109                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
        0x0080ea9e:    2910        .)      CMP      r1,#0x10
        0x0080eaa0:    d019        ..      BEQ      0x80ead6 ; RCC_PeriphClockCmd + 246
;;;110            {
;;;111                SYSBLKCTRL->u_220 |= APBPeriph | APBPeriph_Clock;
;;;112                return;
;;;113            }
;;;114        }
;;;115        else
;;;116        {
;;;117            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
;;;118                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
;;;119            {
;;;120                SYSBLKCTRL->u_220 &= ~(APBPeriph | APBPeriph_Clock);
;;;121                return;
;;;122            }
;;;123        }
;;;124    
;;;125        /* clear flag */
;;;126        APBPeriph &= (~(0x03 << 26));
        0x0080eaa2:    f0206340     .@c    BIC      r3,r0,#0xc000000
;;;127        APBPeriph_Clock &= (~(0x03 << 29));
        0x0080eaa6:    f02140c0    !..@    BIC      r0,r1,#0x60000000
        0x0080eaaa:    ea4f0186    O...    LSL      r1,r6,#2
        0x0080eaae:    f1014180    ...A    ADD      r1,r1,#0x40000000
;;;128    
;;;129        if (NewState == ENABLE)
        0x0080eab2:    2a01        .*      CMP      r2,#1
        0x0080eab4:    f8d12210    ..."    LDR      r2,[r1,#0x210]
        0x0080eab8:    d018        ..      BEQ      0x80eaec ; RCC_PeriphClockCmd + 268
;;;130        {
;;;131            //enable peripheral
;;;132            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) |= APBPeriph;
;;;133            //enable peripheral clock
;;;134            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= APBPeriph_Clock;
;;;135            //enable peripheral clock in sleep mode
;;;136            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= (APBPeriph_Clock << 1);
;;;137        }
;;;138        else
;;;139        {
;;;140            //disable peripheral
;;;141            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) &= (~APBPeriph);
        0x0080eaba:    439a        .C      BICS     r2,r2,r3
;;;142            //disable peripheral clock
;;;143            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~APBPeriph_Clock);
        0x0080eabc:    f8c12210    ..."    STR      r2,[r1,#0x210]
        0x0080eac0:    00a9        ..      LSLS     r1,r5,#2
        0x0080eac2:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x0080eac6:    f8d1222c    ..,"    LDR      r2,[r1,#0x22c]
        0x0080eaca:    4382        .C      BICS     r2,r2,r0
;;;144            //disable peripheral clock in sleep mode
;;;145            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~(APBPeriph_Clock << 1));
        0x0080eacc:    ea220040    ".@.    BIC      r0,r2,r0,LSL #1
        0x0080ead0:    f8c1022c    ..,.    STR      r0,[r1,#0x22c]
;;;146        }
;;;147    
;;;148        return;
;;;149    }
        0x0080ead4:    bdf0        ..      POP      {r4-r7,pc}
        0x0080ead6:    f8d30220    .. .    LDR      r0,[r3,#0x220]
        0x0080eada:    4320         C      ORRS     r0,r0,r4
        0x0080eadc:    e003        ..      B        0x80eae6 ; RCC_PeriphClockCmd + 262
        0x0080eade:    e7ff        ..      B        0x80eae0 ; RCC_PeriphClockCmd + 256
        0x0080eae0:    f8d30220    .. .    LDR      r0,[r3,#0x220]
        0x0080eae4:    43a0        .C      BICS     r0,r0,r4
        0x0080eae6:    f8c30220    .. .    STR      r0,[r3,#0x220]
        0x0080eaea:    bdf0        ..      POP      {r4-r7,pc}
        0x0080eaec:    431a        .C      ORRS     r2,r2,r3
        0x0080eaee:    f8c12210    ..."    STR      r2,[r1,#0x210]
        0x0080eaf2:    00a9        ..      LSLS     r1,r5,#2
        0x0080eaf4:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x0080eaf8:    f8d1222c    ..,"    LDR      r2,[r1,#0x22c]
        0x0080eafc:    4302        .C      ORRS     r2,r2,r0
        0x0080eafe:    ea420040    B.@.    ORR      r0,r2,r0,LSL #1
        0x0080eb02:    e7e5        ..      B        0x80ead0 ; RCC_PeriphClockCmd + 240
    RCC_SPIClkDivConfig
;;;150    
;;;151    /**
;;;152      * @brief  SPI clock divider config.
;;;153      * @param  SPIx: where x can be 0 or 1 to select the SPI peripheral.
;;;154      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;155      *      this parameter can be one of the following values:
;;;156      *     @arg SPI_CLOCK_DIV_1
;;;157      *     @arg SPI_CLOCK_DIV_2
;;;158      *     @arg SPI_CLOCK_DIV_4
;;;159      *     @arg SPI_CLOCK_DIV_8
;;;160      * @retval None
;;;161      */
;;;162    void RCC_SPIClkDivConfig(SPI_TypeDef *SPIx, uint16_t ClockDiv)
;;;163    {
;;;164        assert_param(IS_SPI_DIV(ClockDiv));
;;;165    
;;;166        /* Config I2C clock divider */
;;;167        if (SPIx == SPI0)
        0x0080eb04:    4b86        .K      LDR      r3,[pc,#536] ; [0x80ed20] = 0x40013000
        0x0080eb06:    f04f4280    O..B    MOV      r2,#0x40000000
        0x0080eb0a:    4298        .B      CMP      r0,r3
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_rcc.c (163)
        0x0080eb0c:    d116        ..      BNE      0x80eb3c ; RCC_SPIClkDivConfig + 56
;;;164        assert_param(IS_SPI_DIV(ClockDiv));
;;;165    
;;;166        /* Config I2C clock divider */
;;;167        if (SPIx == SPI0)
;;;168        {
;;;169            /* disable clock first */
;;;170            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_SPI0_EN_Msk;
        0x0080eb0e:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x0080eb12:    f4203080     ..0    BIC      r0,r0,#0x10000
        0x0080eb16:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;171            //platform_delay_us(1);
;;;172    
;;;173            CLK_SOURCE_REG_1 &= ~(0x03 << 19);
        0x0080eb1a:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080eb1e:    f42010c0     ...    BIC      r0,r0,#0x180000
        0x0080eb22:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;174            CLK_SOURCE_REG_1 |= (ClockDiv << 19);
        0x0080eb26:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080eb2a:    ea4040c1    @..@    ORR      r0,r0,r1,LSL #19
        0x0080eb2e:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;175    
;;;176            //platform_delay_us(1);
;;;177            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_SPI0_EN_Msk;
        0x0080eb32:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x0080eb36:    f4403080    @..0    ORR      r0,r0,#0x10000
        0x0080eb3a:    e018        ..      B        0x80eb6e ; RCC_SPIClkDivConfig + 106
;;;178        }
;;;179        else if (SPIx == SPI1)
        0x0080eb3c:    4b79        yK      LDR      r3,[pc,#484] ; [0x80ed24] = 0x40013400
        0x0080eb3e:    4298        .B      CMP      r0,r3
        0x0080eb40:    d117        ..      BNE      0x80eb72 ; RCC_SPIClkDivConfig + 110
;;;180        {
;;;181            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_SPI1_EN_Msk;
        0x0080eb42:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x0080eb46:    f4202080     ..     BIC      r0,r0,#0x40000
        0x0080eb4a:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;182            //platform_delay_us(1);
;;;183    
;;;184            CLK_SOURCE_REG_1 &= ~(0x03 << 21);
        0x0080eb4e:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080eb52:    f42000c0     ...    BIC      r0,r0,#0x600000
        0x0080eb56:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;185            CLK_SOURCE_REG_1 |= (ClockDiv << 21);
        0x0080eb5a:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080eb5e:    ea405041    @.AP    ORR      r0,r0,r1,LSL #21
        0x0080eb62:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;186    
;;;187            //platform_delay_us(1);
;;;188            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_SPI1_EN_Msk;
        0x0080eb66:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x0080eb6a:    f4402080    @..     ORR      r0,r0,#0x40000
        0x0080eb6e:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;189        }
;;;190        return;
;;;191    }
        0x0080eb72:    4770        pG      BX       lr
    RCC_I2CClkDivConfig
;;;192    
;;;193    /**
;;;194      * @brief  I2C clock divider config.
;;;195      * @param  I2Cx: where x can be 0 or 1 to select the I2C peripheral.
;;;196      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;197      *      this parameter can be one of the following values:
;;;198      *     @arg I2C_CLOCK_DIV_1
;;;199      *     @arg I2C_CLOCK_DIV_2
;;;200      *     @arg I2C_CLOCK_DIV_4
;;;201      *     @arg I2C_CLOCK_DIV_8
;;;202      * @retval None
;;;203      */
;;;204    void RCC_I2CClkDivConfig(I2C_TypeDef *I2Cx, uint16_t ClockDiv)
;;;205    {
;;;206        assert_param(IS_I2C_DIV(ClockDiv));
;;;207    
;;;208        /* Config I2C clock divider */
;;;209        if (I2Cx == I2C0)
        0x0080eb74:    4b6c        lK      LDR      r3,[pc,#432] ; [0x80ed28] = 0x40015000
        0x0080eb76:    049a        ..      LSLS     r2,r3,#18
        0x0080eb78:    4298        .B      CMP      r0,r3
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_rcc.c (205)
        0x0080eb7a:    d116        ..      BNE      0x80ebaa ; RCC_I2CClkDivConfig + 54
;;;206        assert_param(IS_I2C_DIV(ClockDiv));
;;;207    
;;;208        /* Config I2C clock divider */
;;;209        if (I2Cx == I2C0)
;;;210        {
;;;211            /* disable clock first */
;;;212            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 &= ~SYSBLK_ACTCK_I2C0_EN_Msk;
        0x0080eb7c:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x0080eb80:    f0200001     ...    BIC      r0,r0,#1
        0x0080eb84:    f8c20238    ..8.    STR      r0,[r2,#0x238]
;;;213            //platform_delay_us(1);
;;;214    
;;;215            CLK_SOURCE_REG_1 &= ~(0x03 << 15);
        0x0080eb88:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080eb8c:    f42030c0     ..0    BIC      r0,r0,#0x18000
        0x0080eb90:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;216            CLK_SOURCE_REG_1 |= (ClockDiv << 15);
        0x0080eb94:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080eb98:    ea4030c1    @..0    ORR      r0,r0,r1,LSL #15
        0x0080eb9c:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;217    
;;;218            //platform_delay_us(1);
;;;219            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= SYSBLK_ACTCK_I2C0_EN_Msk;
        0x0080eba0:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x0080eba4:    f0400001    @...    ORR      r0,r0,#1
        0x0080eba8:    e018        ..      B        0x80ebdc ; RCC_I2CClkDivConfig + 104
;;;220        }
;;;221        else if (I2Cx == I2C1)
        0x0080ebaa:    4b60        `K      LDR      r3,[pc,#384] ; [0x80ed2c] = 0x40015400
        0x0080ebac:    4298        .B      CMP      r0,r3
        0x0080ebae:    d117        ..      BNE      0x80ebe0 ; RCC_I2CClkDivConfig + 108
;;;222        {
;;;223            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 &= ~SYSBLK_ACTCK_I2C1_EN_Msk;
        0x0080ebb0:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x0080ebb4:    f0200004     ...    BIC      r0,r0,#4
        0x0080ebb8:    f8c20238    ..8.    STR      r0,[r2,#0x238]
;;;224            //platform_delay_us(1);
;;;225    
;;;226            CLK_SOURCE_REG_1 &= ~(0x03 << 17);
        0x0080ebbc:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080ebc0:    f42020c0     ..     BIC      r0,r0,#0x60000
        0x0080ebc4:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;227            CLK_SOURCE_REG_1 |= (ClockDiv << 17);
        0x0080ebc8:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080ebcc:    ea404041    @.A@    ORR      r0,r0,r1,LSL #17
        0x0080ebd0:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;228    
;;;229            //platform_delay_us(1);
;;;230            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= SYSBLK_ACTCK_I2C1_EN_Msk;
        0x0080ebd4:    f8d20238    ..8.    LDR      r0,[r2,#0x238]
        0x0080ebd8:    f0400004    @...    ORR      r0,r0,#4
        0x0080ebdc:    f8c20238    ..8.    STR      r0,[r2,#0x238]
;;;231        }
;;;232    
;;;233        return;
;;;234    }
        0x0080ebe0:    4770        pG      BX       lr
    RCC_UARTClkDivConfig
        0x0080ebe2:    4b53        SK      LDR      r3,[pc,#332] ; [0x80ed30] = 0x40012000
        0x0080ebe4:    045a        Z.      LSLS     r2,r3,#17
        0x0080ebe6:    4298        .B      CMP      r0,r3
;;;235    
;;;236    /**
;;;237      * @brief  UART clock divider config.
;;;238      * @param  UARTx: selected UART peripheral.
;;;239      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;240      *      this parameter can be one of the following values:
;;;241      *     @arg UART_CLOCK_DIV_1
;;;242      *     @arg UART_CLOCK_DIV_2
;;;243      *     @arg UART_CLOCK_DIV_4
;;;244      *     @arg UART_CLOCK_DIV_16
;;;245      * @retval None
;;;246      */
;;;247    void RCC_UARTClkDivConfig(UART_TypeDef *UARTx, uint16_t ClockDiv)
;;;248    {
        0x0080ebe8:    d118        ..      BNE      0x80ec1c ; RCC_UARTClkDivConfig + 58
;;;249        assert_param(IS_UART_DIV(ClockDiv));
;;;250    
;;;251        /* Config UART clock divider */
;;;252        if (UARTx == UART)
;;;253        {
;;;254            /* disable clock first */
;;;255            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_UART0DATA_EN_Msk;
        0x0080ebea:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x0080ebee:    f0200001     ...    BIC      r0,r0,#1
        0x0080ebf2:    f8c20234    ..4.    STR      r0,[r2,#0x234]
;;;256            //platform_delay_us(1);
;;;257    
;;;258            CLK_SOURCE_REG_1 &= ~(0x03 << 9);
        0x0080ebf6:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080ebfa:    f42060c0     ..`    BIC      r0,r0,#0x600
        0x0080ebfe:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;259            CLK_SOURCE_REG_1 |= (ClockDiv << 9);
        0x0080ec02:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080ec06:    ea402041    @.A     ORR      r0,r0,r1,LSL #9
        0x0080ec0a:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;260    
;;;261            //platform_delay_us(1);
;;;262            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_UART0DATA_EN_Msk;
        0x0080ec0e:    f8d20234    ..4.    LDR      r0,[r2,#0x234]
        0x0080ec12:    f0400001    @...    ORR      r0,r0,#1
        0x0080ec16:    f8c20234    ..4.    STR      r0,[r2,#0x234]
        0x0080ec1a:    4770        pG      BX       lr
;;;263        }
;;;264        else if (UARTx == UART1)
        0x0080ec1c:    4b45        EK      LDR      r3,[pc,#276] ; [0x80ed34] = 0x40011000
        0x0080ec1e:    4298        .B      CMP      r0,r3
        0x0080ec20:    d1fb        ..      BNE      0x80ec1a ; RCC_UARTClkDivConfig + 56
;;;265        {
;;;266            SYSBLKCTRL->u_230.CLK_CTRL &= ~SYSBLK_ACTCK_LOGUART_EN_Msk;
        0x0080ec22:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x0080ec26:    f4205080     ..P    BIC      r0,r0,#0x1000
        0x0080ec2a:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;267            //platform_delay_us(1);
;;;268    
;;;269            CLK_SOURCE_REG_1 &= ~(0x03 << 11);
        0x0080ec2e:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080ec32:    f42050c0     ..P    BIC      r0,r0,#0x1800
        0x0080ec36:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;270            CLK_SOURCE_REG_1 |= (ClockDiv << 11);
        0x0080ec3a:    f8d2035c    ..\.    LDR      r0,[r2,#0x35c]
        0x0080ec3e:    ea4020c1    @..     ORR      r0,r0,r1,LSL #11
        0x0080ec42:    f8c2035c    ..\.    STR      r0,[r2,#0x35c]
;;;271    
;;;272            //platform_delay_us(1);
;;;273            SYSBLKCTRL->u_230.CLK_CTRL |= SYSBLK_ACTCK_LOGUART_EN_Msk;
        0x0080ec46:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x0080ec4a:    f4405080    @..P    ORR      r0,r0,#0x1000
        0x0080ec4e:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;274        }
;;;275    
;;;276        return;
;;;277    }
        0x0080ec52:    4770        pG      BX       lr
    RCC_PeriClockConfig
;;;278    
;;;279    /**
;;;280      * @brief  Enables or disables the APB peripheral clock.
;;;281      * @param  APBPeriph_Clock: specifies the APB peripheral clock config.
;;;282      *      this parameter can be one of the following values(must be the same with APBPeriph):
;;;283      *     @arg APBPeriph_TIMER_CLOCK
;;;284      *     @arg APBPeriph_GDMA_CLOCK
;;;285      *     @arg APBPeriph_SPI2W_CLOCK
;;;286      *     @arg APBPeriph_KEYSCAN_CLOCK
;;;287      *     @arg APBPeriph_QDEC_CLOCK
;;;288      *     @arg APBPeriph_I2C1_CLOCK
;;;289      *     @arg APBPeriph_I2C0_CLOCK
;;;290      *     @arg APBPeriph_IR_CLOCK
;;;291      *     @arg APBPeriph_SPI1_CLOCK
;;;292      *     @arg APBPeriph_SPI0_CLOCK
;;;293      *     @arg APBPeriph_UART0_CLOCK
;;;294      *     @arg APBPeriph_UART1_CLOCK
;;;295      *     @arg APBPeriph_UART2_CLOCK
;;;296      *     @arg APBPeriph_GPIO_CLOCK
;;;297      *     @arg APBPeriph_ADC_CLOCK
;;;298      *     @arg APBPeriph_I2S0_CLOCK
;;;299      *     @arg APBPeriph_I2S1_CLOCK
;;;300      *     @arg APBPeriph_CODEC_CLOCK
;;;301      * @param  NewState: new state of the specified peripheral clock.
;;;302      *   This parameter can be: ENABLE or DISABLE.
;;;303      * @retval None
;;;304      */
;;;305    void RCC_PeriClockConfig(uint32_t APBPeriph_Clock, FunctionalState NewState)
;;;306    {
        0x0080ec54:    b530        0.      PUSH     {r4,r5,lr}
        0x0080ec56:    f44f74a0    O..t    MOV      r4,#0x140
        0x0080ec5a:    0623        #.      LSLS     r3,r4,#24
        0x0080ec5c:    f3c07241    ..Ar    UBFX     r2,r0,#29,#2
        0x0080ec60:    f44f7590    O..u    MOV      r5,#0x120
        0x0080ec64:    2901        .)      CMP      r1,#1
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_rcc.c (306)
        0x0080ec66:    d006        ..      BEQ      0x80ec76 ; RCC_PeriClockConfig + 34
        0x0080ec68:    42a8        .B      CMP      r0,r5
        0x0080ec6a:    d01e        ..      BEQ      0x80ecaa ; RCC_PeriClockConfig + 86
        0x0080ec6c:    42a0        .B      CMP      r0,r4
        0x0080ec6e:    d01c        ..      BEQ      0x80ecaa ; RCC_PeriClockConfig + 86
        0x0080ec70:    2810        .(      CMP      r0,#0x10
        0x0080ec72:    d01a        ..      BEQ      0x80ecaa ; RCC_PeriClockConfig + 86
        0x0080ec74:    e005        ..      B        0x80ec82 ; RCC_PeriClockConfig + 46
;;;307        /* Check the parameters */
;;;308        assert_param(IS_APB_PERIPH_CLOCK(APBPeriph_Clock));
;;;309        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;310    
;;;311        uint32_t clkRegOff = ((APBPeriph_Clock & (0x03 << 29)) >> 29);
;;;312    
;;;313        /* Special register handle */
;;;314        if (NewState == ENABLE)
;;;315        {
;;;316            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
        0x0080ec76:    42a8        .B      CMP      r0,r5
        0x0080ec78:    d013        ..      BEQ      0x80eca2 ; RCC_PeriClockConfig + 78
        0x0080ec7a:    42a0        .B      CMP      r0,r4
        0x0080ec7c:    d011        ..      BEQ      0x80eca2 ; RCC_PeriClockConfig + 78
;;;317                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
        0x0080ec7e:    2810        .(      CMP      r0,#0x10
        0x0080ec80:    d00f        ..      BEQ      0x80eca2 ; RCC_PeriClockConfig + 78
        0x0080ec82:    2901        .)      CMP      r1,#1
        0x0080ec84:    ea4f0182    O...    LSL      r1,r2,#2
        0x0080ec88:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x0080ec8c:    f02040c0     ..@    BIC      r0,r0,#0x60000000
        0x0080ec90:    f8d1222c    ..,"    LDR      r2,[r1,#0x22c]
        0x0080ec94:    d00f        ..      BEQ      0x80ecb6 ; RCC_PeriClockConfig + 98
        0x0080ec96:    4382        .C      BICS     r2,r2,r0
        0x0080ec98:    ea220040    ".@.    BIC      r0,r2,r0,LSL #1
        0x0080ec9c:    f8c1022c    ..,.    STR      r0,[r1,#0x22c]
        0x0080eca0:    bd30        0.      POP      {r4,r5,pc}
;;;318            {
;;;319                SYSBLKCTRL->u_220 |= APBPeriph_Clock;
        0x0080eca2:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x0080eca6:    4301        .C      ORRS     r1,r1,r0
;;;320                return;
        0x0080eca8:    e002        ..      B        0x80ecb0 ; RCC_PeriClockConfig + 92
;;;321            }
;;;322        }
;;;323        else
;;;324        {
;;;325            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
;;;326                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
;;;327            {
;;;328                SYSBLKCTRL->u_220 &= ~(APBPeriph_Clock);
        0x0080ecaa:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x0080ecae:    4381        .C      BICS     r1,r1,r0
        0x0080ecb0:    f8c31220    .. .    STR      r1,[r3,#0x220]
        0x0080ecb4:    bd30        0.      POP      {r4,r5,pc}
;;;329                return;
;;;330            }
;;;331        }
;;;332    
;;;333        APBPeriph_Clock &= (~(0x03 << 29));
;;;334    
;;;335        if (NewState == ENABLE)
;;;336        {
;;;337            //enable peripheral clock
;;;338            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= APBPeriph_Clock;
        0x0080ecb6:    4302        .C      ORRS     r2,r2,r0
;;;339            //enable peripheral clock in sleep mode
;;;340            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= (APBPeriph_Clock << 1);
        0x0080ecb8:    ea420040    B.@.    ORR      r0,r2,r0,LSL #1
        0x0080ecbc:    e7ee        ..      B        0x80ec9c ; RCC_PeriClockConfig + 72
    RCC_PeriFunctionConfig
        0x0080ecbe:    f3c06281    ...b    UBFX     r2,r0,#26,#2
        0x0080ecc2:    f04f4380    O..C    MOV      r3,#0x40000000
        0x0080ecc6:    2901        .)      CMP      r1,#1
;;;341        }
;;;342        else
;;;343        {
;;;344            //disable peripheral clock
;;;345            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~APBPeriph_Clock);
;;;346            //disable peripheral clock in sleep mode
;;;347            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~(APBPeriph_Clock << 1));
;;;348        }
;;;349    
;;;350        return;
;;;351    }
;;;352    
;;;353    /**
;;;354      * @brief  Enables or disables the APB peripheral clock.
;;;355      * @param  APBPeriph: specifies the APB peripheral to gates its clock.
;;;356      *      this parameter can be one of the following values:
;;;357      *     @arg APBPeriph_TIMER
;;;358      *     @arg APBPeriph_GDMA
;;;359      *     @arg APBPeriph_LCD
;;;360      *     @arg APBPeriph_SPI2W
;;;361      *     @arg APBPeriph_KEYSCAN
;;;362      *     @arg APBPeriph_QDEC
;;;363      *     @arg APBPeriph_I2C1
;;;364      *     @arg APBPeriph_I2C0
;;;365      *     @arg APBPeriph_IR
;;;366      *     @arg APBPeriph_SPI1
;;;367      *     @arg APBPeriph_SPI0
;;;368      *     @arg APBPeriph_UART0
;;;369      *     @arg APBPeriph_UART1
;;;370      *     @arg APBPeriph_UART2
;;;371      *     @arg APBPeriph_GPIO
;;;372      *     @arg APBPeriph_ADC
;;;373      *     @arg APBPeriph_I2S0
;;;374      *     @arg APBPeriph_I2S1
;;;375      *     @arg APBPeriph_CODEC
;;;376      * @param  NewState: new state of the specified peripheral clock.
;;;377      *   This parameter can be: ENABLE or DISABLE.
;;;378      * @retval None
;;;379      */
;;;380    void RCC_PeriFunctionConfig(uint32_t APBPeriph, FunctionalState NewState)
;;;381    {
        0x0080ecc8:    d006        ..      BEQ      0x80ecd8 ; RCC_PeriFunctionConfig + 26
        0x0080ecca:    2802        .(      CMP      r0,#2
        0x0080eccc:    d01c        ..      BEQ      0x80ed08 ; RCC_PeriFunctionConfig + 74
        0x0080ecce:    2804        .(      CMP      r0,#4
        0x0080ecd0:    d01a        ..      BEQ      0x80ed08 ; RCC_PeriFunctionConfig + 74
        0x0080ecd2:    2801        .(      CMP      r0,#1
        0x0080ecd4:    d018        ..      BEQ      0x80ed08 ; RCC_PeriFunctionConfig + 74
        0x0080ecd6:    e005        ..      B        0x80ece4 ; RCC_PeriFunctionConfig + 38
;;;382        /* Check the parameters */
;;;383        assert_param(IS_APB_PERIPH(APBPeriph));
;;;384        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;385    
;;;386        uint32_t apbRegOff = ((APBPeriph & (0x03 << 26)) >> 26);
;;;387    
;;;388        /* Special register handle */
;;;389        if (NewState == ENABLE)
;;;390        {
;;;391            if ((APBPeriph == APBPeriph_I2S0) || ((APBPeriph == APBPeriph_I2S1)) ||
        0x0080ecd8:    2802        .(      CMP      r0,#2
        0x0080ecda:    d011        ..      BEQ      0x80ed00 ; RCC_PeriFunctionConfig + 66
        0x0080ecdc:    2804        .(      CMP      r0,#4
        0x0080ecde:    d00f        ..      BEQ      0x80ed00 ; RCC_PeriFunctionConfig + 66
;;;392                (APBPeriph == APBPeriph_CODEC))
        0x0080ece0:    2801        .(      CMP      r0,#1
        0x0080ece2:    d00d        ..      BEQ      0x80ed00 ; RCC_PeriFunctionConfig + 66
        0x0080ece4:    2901        .)      CMP      r1,#1
        0x0080ece6:    ea4f0182    O...    LSL      r1,r2,#2
        0x0080ecea:    f1014180    ...A    ADD      r1,r1,#0x40000000
        0x0080ecee:    f0206040     .@`    BIC      r0,r0,#0xc000000
        0x0080ecf2:    f8d12210    ..."    LDR      r2,[r1,#0x210]
        0x0080ecf6:    d00d        ..      BEQ      0x80ed14 ; RCC_PeriFunctionConfig + 86
        0x0080ecf8:    4382        .C      BICS     r2,r2,r0
        0x0080ecfa:    f8c12210    ..."    STR      r2,[r1,#0x210]
        0x0080ecfe:    4770        pG      BX       lr
;;;393            {
;;;394                SYSBLKCTRL->u_220 |= APBPeriph;
        0x0080ed00:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x0080ed04:    4301        .C      ORRS     r1,r1,r0
;;;395                return;
        0x0080ed06:    e002        ..      B        0x80ed0e ; RCC_PeriFunctionConfig + 80
;;;396            }
;;;397        }
;;;398        else
;;;399        {
;;;400            if ((APBPeriph == APBPeriph_I2S0) || ((APBPeriph == APBPeriph_I2S1)) ||
;;;401                (APBPeriph == APBPeriph_CODEC))
;;;402            {
;;;403                SYSBLKCTRL->u_220 &= ~(APBPeriph);
        0x0080ed08:    f8d31220    .. .    LDR      r1,[r3,#0x220]
        0x0080ed0c:    4381        .C      BICS     r1,r1,r0
        0x0080ed0e:    f8c31220    .. .    STR      r1,[r3,#0x220]
        0x0080ed12:    4770        pG      BX       lr
;;;404                return;
;;;405            }
;;;406        }
;;;407    
;;;408        /* clear flag */
;;;409        APBPeriph &= (~(0x03 << 26));
;;;410    
;;;411        if (NewState == ENABLE)
;;;412        {
;;;413            //enable peripheral
;;;414            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) |= APBPeriph;
        0x0080ed14:    4302        .C      ORRS     r2,r2,r0
        0x0080ed16:    e7f0        ..      B        0x80ecfa ; RCC_PeriFunctionConfig + 60
    $d
        0x0080ed18:    60010000    ...`    DCD    1610678272
        0x0080ed1c:    20004000    .@.     DCD    536887296
        0x0080ed20:    40013000    .0.@    DCD    1073819648
        0x0080ed24:    40013400    .4.@    DCD    1073820672
        0x0080ed28:    40015000    .P.@    DCD    1073827840
        0x0080ed2c:    40015400    .T.@    DCD    1073828864
        0x0080ed30:    40012000    . .@    DCD    1073815552
        0x0080ed34:    40011000    ...@    DCD    1073811456
    $t
    .text
    ias_attr_write_cb
;;; .\..\include\SDK\src\ble\profile\server\ias.c
;;;96     {
        0x0080ed38:    b57c        |.      PUSH     {r2-r6,lr}
        0x0080ed3a:    460d        .F      MOV      r5,r1
        0x0080ed3c:    4601        .F      MOV      r1,r0
        0x0080ed3e:    e9dd0306    ....    LDRD     r0,r3,[sp,#0x18]
        0x0080ed42:    2400        .$      MOVS     r4,#0
;;; .\..\include\SDK\src\ble\profile\server\ias.c (96)
        0x0080ed44:    b123        #.      CBZ      r3,0x80ed50 ; ias_attr_write_cb + 24
        0x0080ed46:    2a02        .*      CMP      r2,#2
        0x0080ed48:    d00b        ..      BEQ      0x80ed62 ; ias_attr_write_cb + 42
        0x0080ed4a:    f240440a    @..D    MOV      r4,#0x40a
        0x0080ed4e:    e015        ..      B        0x80ed7c ; ias_attr_write_cb + 68
;;;97         T_APP_RESULT cause  = APP_RESULT_SUCCESS;
;;;98         T_IAS_CALLBACK_DATA callback_data;
;;;99         if (!p_value)
;;;100        {
;;;101            PROFILE_PRINT_ERROR2("ias_attr_write_cb: p_value %p length= 0x%x", p_value, length);
        0x0080ed50:    9000        ..      STR      r0,[sp,#0]
        0x0080ed52:    2202        ."      MOVS     r2,#2
        0x0080ed54:    491d        .I      LDR      r1,[pc,#116] ; [0x80edcc] = 0x8800098
        0x0080ed56:    481e        .H      LDR      r0,[pc,#120] ; [0x80edd0] = 0x21103300
        0x0080ed58:    f7f8de81    ....    BL       log_buffer ; 0x7a5e
;;;102            cause = APP_RESULT_INVALID_PDU;
        0x0080ed5c:    f2404004    @..@    MOV      r0,#0x404
        0x0080ed60:    bd7c        |.      POP      {r2-r6,pc}
;;;103            return cause;
;;;104        }
;;;105    
;;;106        switch (attrib_index)
;;;107        {
;;;108        default:
;;;109            cause = APP_RESULT_ATTR_NOT_FOUND;
;;;110            break;
;;;111    
;;;112        case GATT_SVC_PXP_IMMEDIATE_AlERT_VALUE_INDEX:
;;;113            if (length != sizeof(uint8_t))
        0x0080ed62:    2801        .(      CMP      r0,#1
        0x0080ed64:    d002        ..      BEQ      0x80ed6c ; ias_attr_write_cb + 52
;;;114            {
;;;115                cause = APP_RESULT_INVALID_VALUE_SIZE;
        0x0080ed66:    f240440d    @..D    MOV      r4,#0x40d
        0x0080ed6a:    e007        ..      B        0x80ed7c ; ias_attr_write_cb + 68
;;;116            }
;;;117            else
;;;118            {
;;;119                callback_data.conn_id = conn_id;
        0x0080ed6c:    f88d1004    ....    STRB     r1,[sp,#4]
;;;120                callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
        0x0080ed70:    2003        .       MOVS     r0,#3
        0x0080ed72:    f88d0005    ....    STRB     r0,[sp,#5]
;;;121                callback_data.msg_data.write_alert_level = p_value[0];
        0x0080ed76:    7818        .x      LDRB     r0,[r3,#0]
        0x0080ed78:    f88d0006    ....    STRB     r0,[sp,#6]
;;;122            }
;;;123            break;
;;;124        }
;;;125        if (pfn_ias_cb && (cause == APP_RESULT_SUCCESS))
        0x0080ed7c:    4815        .H      LDR      r0,[pc,#84] ; [0x80edd4] = 0x208008
        0x0080ed7e:    6802        .h      LDR      r2,[r0,#0]
        0x0080ed80:    b11a        ..      CBZ      r2,0x80ed8a ; ias_attr_write_cb + 82
        0x0080ed82:    b914        ..      CBNZ     r4,0x80ed8a ; ias_attr_write_cb + 82
;;;126        {
;;;127            pfn_ias_cb(service_id, (void *)&callback_data);
        0x0080ed84:    a901        ..      ADD      r1,sp,#4
        0x0080ed86:    4628        (F      MOV      r0,r5
        0x0080ed88:    4790        .G      BLX      r2
;;;128        }
;;;129    
;;;130        return cause;
        0x0080ed8a:    4620         F      MOV      r0,r4
;;;131    }
        0x0080ed8c:    bd7c        |.      POP      {r2-r6,pc}
    ias_add_service
;;;132    
;;;133    /*********************************************************************
;;;134     * SERVICE CALLBACKS
;;;135     */
;;;136    // IAS related Service Callbacks
;;;137    const T_FUN_GATT_SERVICE_CBS ias_cbs =
;;;138    {
;;;139        NULL,  // Read callback function pointer
;;;140        ias_attr_write_cb, // Write callback function pointer
;;;141        NULL  // CCCD update callback function pointer
;;;142    };
;;;143    
;;;144    /**
;;;145      * @brief Add immediate alert service to the BLE stack database.
;;;146      *
;;;147      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;148      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;149      * @retval 0xFF Operation failure.
;;;150      * @retval others Service id assigned by stack.
;;;151      *
;;;152      * <b>Example usage</b>
;;;153      * \code{.c}
;;;154        void profile_init()
;;;155        {
;;;156            server_init(1);
;;;157            ias_id = ias_add_service(app_handle_profile_message);
;;;158        }
;;;159      * \endcode
;;;160      */
;;;161    T_SERVER_ID ias_add_service(void *p_func)
;;;162    {
        0x0080ed8e:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080ed90:    4604        .F      MOV      r4,r0
;;;163        T_SERVER_ID service_id;
;;;164        if (false == server_add_service(&service_id,
        0x0080ed92:    4811        .H      LDR      r0,[pc,#68] ; [0x80edd8] = 0x8109bc
        0x0080ed94:    e9d01216    ....    LDRD     r1,r2,[r0,#0x58]
        0x0080ed98:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0080ed9c:    4601        .F      MOV      r1,r0
        0x0080ed9e:    6d43        Cm      LDR      r3,[r0,#0x54]
        0x0080eda0:    2254        T"      MOVS     r2,#0x54
        0x0080eda2:    a802        ..      ADD      r0,sp,#8
        0x0080eda4:    f440f463    @.c.    BL       server_add_service ; 0x4f66e
        0x0080eda8:    b950        P.      CBNZ     r0,0x80edc0 ; ias_add_service + 50
;;;165                                        (uint8_t *)ias_attr_tbl,
;;;166                                        ias_attr_tbl_size,
;;;167                                        ias_cbs))
;;;168        {
;;;169            PROFILE_PRINT_ERROR1("ias_add_service: service_id %d", service_id);
        0x0080edaa:    4908        .I      LDR      r1,[pc,#32] ; [0x80edcc] = 0x8800098
        0x0080edac:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080edb0:    2201        ."      MOVS     r2,#1
        0x0080edb2:    3130        01      ADDS     r1,r1,#0x30
        0x0080edb4:    4806        .H      LDR      r0,[pc,#24] ; [0x80edd0] = 0x21103300
        0x0080edb6:    f7f8de52    ..R.    BL       log_buffer ; 0x7a5e
;;;170            service_id = 0xff;
        0x0080edba:    20ff        .       MOVS     r0,#0xff
        0x0080edbc:    f88d0008    ....    STRB     r0,[sp,#8]
;;;171        }
;;;172    
;;;173        pfn_ias_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x0080edc0:    4804        .H      LDR      r0,[pc,#16] ; [0x80edd4] = 0x208008
;;;174        return service_id;
        0x0080edc2:    6004        .`      STR      r4,[r0,#0]
        0x0080edc4:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;175    }
        0x0080edc8:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080edca:    0000        ..      DCW    0
        0x0080edcc:    08800098    ....    DCD    142606488
        0x0080edd0:    21103300    .3.!    DCD    554709760
        0x0080edd4:    00208008    .. .    DCD    2129928
        0x0080edd8:    008109bc    ....    DCD    8456636
    $t
    .text
    lls_set_parameter
;;; .\..\include\SDK\src\ble\profile\server\lls.c
;;;102    {
        0x0080eddc:    b510        ..      PUSH     {r4,lr}
        0x0080edde:    2401        .$      MOVS     r4,#1
;;; .\..\include\SDK\src\ble\profile\server\lls.c (102)
        0x0080ede0:    b130        0.      CBZ      r0,0x80edf0 ; lls_set_parameter + 20
;;;103        bool ret = true;
;;;104    
;;;105        switch (param_type)
;;;106        {
;;;107        default:
;;;108            ret = false;
        0x0080ede2:    2400        .$      MOVS     r4,#0
        0x0080ede4:    4622        "F      MOV      r2,r4
        0x0080ede6:    4942        BI      LDR      r1,[pc,#264] ; [0x80eef0] = 0x88000ec
        0x0080ede8:    4842        BH      LDR      r0,[pc,#264] ; [0x80eef4] = 0x21103300
        0x0080edea:    f7f8de38    ..8.    BL       log_buffer ; 0x7a5e
;;;109            break;
        0x0080edee:    e002        ..      B        0x80edf6 ; lls_set_parameter + 26
;;;110        case LLS_PARAM_LINK_LOSS_ALERT_LEVEL:
;;;111            lls_alert_level = *(uint8_t *)p_value;
        0x0080edf0:    4941        AI      LDR      r1,[pc,#260] ; [0x80eef8] = 0x20800c
        0x0080edf2:    7810        .x      LDRB     r0,[r2,#0]
        0x0080edf4:    7008        .p      STRB     r0,[r1,#0]
;;;112            break;
;;;113        }
;;;114    
;;;115        if (!ret)
;;;116        {
;;;117            PROFILE_PRINT_ERROR0("lls_set_parameter: lls alert level parameter set failed");
;;;118        }
;;;119    
;;;120        return ret;
        0x0080edf6:    4620         F      MOV      r0,r4
;;;121    }
        0x0080edf8:    bd10        ..      POP      {r4,pc}
    lls_attr_read_cb
;;;122    
;;;123    
;;;124    /**
;;;125     * @brief read characteristic data from service.
;;;126     *
;;;127     * @param conn_id           connection id.
;;;128     * @param service_id        ServiceID to be read.
;;;129     * @param attrib_index      Attribute index of getting characteristic data.
;;;130     * @param offset            offset of characteritic to be read.
;;;131     * @param p_length          length of getting characteristic data.
;;;132     * @param pp_value          pointer to pointer of characteristic value to be read.
;;;133     * @return T_APP_RESULT
;;;134    */
;;;135    T_APP_RESULT lls_attr_read_cb(uint8_t conn_id, uint8_t service_id, uint16_t attrib_index,
;;;136                                  uint16_t offset, uint16_t *p_length, uint8_t **pp_value)
;;;137    {
        0x0080edfa:    e92d47fc    -..G    PUSH     {r2-r10,lr}
        0x0080edfe:    2500        .%      MOVS     r5,#0
        0x0080ee00:    e9dd690a    ...i    LDRD     r6,r9,[sp,#0x28]
        0x0080ee04:    460b        .F      MOV      r3,r1
        0x0080ee06:    8035        5.      STRH     r5,[r6,#0]
        0x0080ee08:    2a02        .*      CMP      r2,#2
        0x0080ee0a:    d009        ..      BEQ      0x80ee20 ; lls_attr_read_cb + 38
;;;138        T_APP_RESULT cause = APP_RESULT_SUCCESS;
;;;139        *p_length = 0;
;;;140        T_LLS_CALLBACK_DATA callback_data;
;;;141    
;;;142        switch (attrib_index)
;;;143        {
;;;144        default:
;;;145            PROFILE_PRINT_ERROR1("lls_attr_read_cb default:attrib_index %d", attrib_index);
        0x0080ee0c:    4938        8I      LDR      r1,[pc,#224] ; [0x80eef0] = 0x88000ec
        0x0080ee0e:    4613        .F      MOV      r3,r2
        0x0080ee10:    2201        ."      MOVS     r2,#1
        0x0080ee12:    313c        <1      ADDS     r1,r1,#0x3c
        0x0080ee14:    4837        7H      LDR      r0,[pc,#220] ; [0x80eef4] = 0x21103300
        0x0080ee16:    f7f8de22    ..".    BL       log_buffer ; 0x7a5e
;;;146            cause = APP_RESULT_ATTR_NOT_FOUND;
        0x0080ee1a:    f240450a    @..E    MOV      r5,#0x40a
;;;147            break;
        0x0080ee1e:    e01a        ..      B        0x80ee56 ; lls_attr_read_cb + 92
        0x0080ee20:    2702        .'      MOVS     r7,#2
;;;148    
;;;149        case GATT_SVC_PXP_LINK_LOSS_ALERT_LEVEL_INDEX:
;;;150            callback_data.conn_id = conn_id;
        0x0080ee22:    f88d0004    ....    STRB     r0,[sp,#4]
        0x0080ee26:    f8df80d0    ....    LDR      r8,[pc,#208] ; [0x80eef8] = 0x20800c
;;;151            callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0080ee2a:    f88d7005    ...p    STRB     r7,[sp,#5]
;;;152            callback_data.msg_data.read_value_index = LLS_READ_ALERT_LEVEL;
        0x0080ee2e:    2401        .$      MOVS     r4,#1
        0x0080ee30:    f88d4006    ...@    STRB     r4,[sp,#6]
;;;153            pfn_lls_cb(service_id, (void *)&callback_data);
        0x0080ee34:    f8d82004    ...     LDR      r2,[r8,#4]
        0x0080ee38:    a901        ..      ADD      r1,sp,#4
        0x0080ee3a:    4618        .F      MOV      r0,r3
        0x0080ee3c:    4790        .G      BLX      r2
;;;154            *pp_value = (uint8_t *)&lls_alert_level;
;;;155            *p_length = sizeof(lls_alert_level);
        0x0080ee3e:    f8c98000    ....    STR      r8,[r9,#0]
        0x0080ee42:    492b        +I      LDR      r1,[pc,#172] ; [0x80eef0] = 0x88000ec
        0x0080ee44:    482b        +H      LDR      r0,[pc,#172] ; [0x80eef4] = 0x21103300
        0x0080ee46:    8034        4.      STRH     r4,[r6,#0]
;;;156            PROFILE_PRINT_INFO2("lls_attr_read_cb: attrib_index %d, length %d", attrib_index, *p_length);
        0x0080ee48:    463b        ;F      MOV      r3,r7
        0x0080ee4a:    2202        ."      MOVS     r2,#2
        0x0080ee4c:    3168        h1      ADDS     r1,r1,#0x68
        0x0080ee4e:    1c80        ..      ADDS     r0,r0,#2
        0x0080ee50:    9400        ..      STR      r4,[sp,#0]
        0x0080ee52:    f7f8de04    ....    BL       log_buffer ; 0x7a5e
;;;157            break;
;;;158        }
;;;159    
;;;160        return (cause);
        0x0080ee56:    4628        (F      MOV      r0,r5
;;;161    }
        0x0080ee58:    e8bd87fc    ....    POP      {r2-r10,pc}
    lls_attr_write_cb
;;;162    
;;;163    /**
;;;164     * @brief write characteristic data from service.
;;;165     *
;;;166     * @param conn_id               connection id.
;;;167     * @param service_id            ServiceID to be written.
;;;168     * @param attrib_index          Attribute index of characteristic.
;;;169     * @param length                length of writing characteristic data.
;;;170     * @param p_value               pointer to characteristic data.
;;;171     * @param p_write_ind_post_proc function pointer called after lls_attr_write_cb.
;;;172     * @return T_APP_RESULT
;;;173    */
;;;174    T_APP_RESULT lls_attr_write_cb(uint8_t conn_id, uint8_t service_id, uint16_t attrib_index,
;;;175                                   T_WRITE_TYPE write_type,
;;;176                                   uint16_t length, uint8_t *p_value, P_FUN_WRITE_IND_POST_PROC *p_write_ind_post_proc)
;;;177    {
        0x0080ee5c:    b57c        |.      PUSH     {r2-r6,lr}
        0x0080ee5e:    460d        .F      MOV      r5,r1
        0x0080ee60:    4601        .F      MOV      r1,r0
        0x0080ee62:    e9dd0306    ....    LDRD     r0,r3,[sp,#0x18]
        0x0080ee66:    2400        .$      MOVS     r4,#0
;;; .\..\include\SDK\src\ble\profile\server\lls.c (177)
        0x0080ee68:    b123        #.      CBZ      r3,0x80ee74 ; lls_attr_write_cb + 24
        0x0080ee6a:    2a02        .*      CMP      r2,#2
        0x0080ee6c:    d00c        ..      BEQ      0x80ee88 ; lls_attr_write_cb + 44
        0x0080ee6e:    f240440a    @..D    MOV      r4,#0x40a
        0x0080ee72:    e016        ..      B        0x80eea2 ; lls_attr_write_cb + 70
;;;178        T_APP_RESULT  cause = APP_RESULT_SUCCESS;
;;;179        T_LLS_CALLBACK_DATA callback_data;
;;;180        if (!p_value)
;;;181        {
;;;182            PROFILE_PRINT_ERROR2("lls_attr_write_cb: p_value %p, length 0x%x", p_value, length);
        0x0080ee74:    491e        .I      LDR      r1,[pc,#120] ; [0x80eef0] = 0x88000ec
        0x0080ee76:    9000        ..      STR      r0,[sp,#0]
        0x0080ee78:    2202        ."      MOVS     r2,#2
        0x0080ee7a:    3198        .1      ADDS     r1,r1,#0x98
        0x0080ee7c:    481d        .H      LDR      r0,[pc,#116] ; [0x80eef4] = 0x21103300
        0x0080ee7e:    f7f8ddee    ....    BL       log_buffer ; 0x7a5e
;;;183            cause = APP_RESULT_INVALID_PDU;
        0x0080ee82:    f2404004    @..@    MOV      r0,#0x404
        0x0080ee86:    bd7c        |.      POP      {r2-r6,pc}
;;;184            return cause;
;;;185        }
;;;186    
;;;187        switch (attrib_index)
;;;188        {
;;;189        default:
;;;190            cause = APP_RESULT_ATTR_NOT_FOUND;
;;;191            break;
;;;192        case GATT_SVC_PXP_LINK_LOSS_ALERT_LEVEL_INDEX:
;;;193            if (length != sizeof(uint8_t))
        0x0080ee88:    2801        .(      CMP      r0,#1
        0x0080ee8a:    d002        ..      BEQ      0x80ee92 ; lls_attr_write_cb + 54
;;;194            {
;;;195                cause = APP_RESULT_INVALID_VALUE_SIZE;
        0x0080ee8c:    f240440d    @..D    MOV      r4,#0x40d
        0x0080ee90:    e007        ..      B        0x80eea2 ; lls_attr_write_cb + 70
;;;196            }
;;;197            else
;;;198            {
;;;199                callback_data.conn_id = conn_id;
        0x0080ee92:    f88d1004    ....    STRB     r1,[sp,#4]
;;;200                callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
        0x0080ee96:    2003        .       MOVS     r0,#3
        0x0080ee98:    f88d0005    ....    STRB     r0,[sp,#5]
;;;201                callback_data.msg_data.write_alert_level = p_value[0];
        0x0080ee9c:    7818        .x      LDRB     r0,[r3,#0]
        0x0080ee9e:    f88d0006    ....    STRB     r0,[sp,#6]
;;;202            }
;;;203            break;
;;;204    
;;;205        }
;;;206        if (pfn_lls_cb && (cause == APP_RESULT_SUCCESS))
        0x0080eea2:    4815        .H      LDR      r0,[pc,#84] ; [0x80eef8] = 0x20800c
        0x0080eea4:    6842        Bh      LDR      r2,[r0,#4]
        0x0080eea6:    b11a        ..      CBZ      r2,0x80eeb0 ; lls_attr_write_cb + 84
        0x0080eea8:    b914        ..      CBNZ     r4,0x80eeb0 ; lls_attr_write_cb + 84
;;;207        {
;;;208            pfn_lls_cb(service_id, (void *)&callback_data);
        0x0080eeaa:    a901        ..      ADD      r1,sp,#4
        0x0080eeac:    4628        (F      MOV      r0,r5
        0x0080eeae:    4790        .G      BLX      r2
;;;209        }
;;;210    
;;;211        return cause;
        0x0080eeb0:    4620         F      MOV      r0,r4
;;;212    
;;;213    }
        0x0080eeb2:    bd7c        |.      POP      {r2-r6,pc}
    lls_add_service
;;;214    
;;;215    
;;;216    // LLS related Service Callbacks
;;;217    const T_FUN_GATT_SERVICE_CBS lls_cbs =
;;;218    {
;;;219        lls_attr_read_cb,   // Read callback function pointer
;;;220        lls_attr_write_cb,  // Write callback function pointer
;;;221        NULL                // CCCD update callback function pointer
;;;222    };
;;;223    
;;;224    /**
;;;225      * @brief Add link loss service to the BLE stack database.
;;;226      *
;;;227      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;228      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;229      * @retval 0xFF Operation failure.
;;;230      * @retval others Service id assigned by stack.
;;;231      *
;;;232      * <b>Example usage</b>
;;;233      * \code{.c}
;;;234        void profile_init()
;;;235        {
;;;236            server_init(1);
;;;237            lls_id = lls_add_service(app_handle_profile_message);
;;;238        }
;;;239      * \endcode
;;;240      */
;;;241    T_SERVER_ID lls_add_service(void *p_func)
;;;242    {
        0x0080eeb4:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080eeb6:    4604        .F      MOV      r4,r0
;;;243        T_SERVER_ID service_id;
;;;244        if (false == server_add_service(&service_id,
        0x0080eeb8:    4810        .H      LDR      r0,[pc,#64] ; [0x80eefc] = 0x810a1c
        0x0080eeba:    e9d01216    ....    LDRD     r1,r2,[r0,#0x58]
        0x0080eebe:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0080eec2:    4601        .F      MOV      r1,r0
        0x0080eec4:    6d43        Cm      LDR      r3,[r0,#0x54]
        0x0080eec6:    2254        T"      MOVS     r2,#0x54
        0x0080eec8:    a802        ..      ADD      r0,sp,#8
        0x0080eeca:    f440f3d0    @...    BL       server_add_service ; 0x4f66e
        0x0080eece:    b950        P.      CBNZ     r0,0x80eee6 ; lls_add_service + 50
;;;245                                        (uint8_t *)lls_attr_tbl,
;;;246                                        lls_attr_tbl_size,
;;;247                                        lls_cbs))
;;;248        {
;;;249            PROFILE_PRINT_ERROR1("lls_add_service: service_id %d", service_id);
        0x0080eed0:    4907        .I      LDR      r1,[pc,#28] ; [0x80eef0] = 0x88000ec
        0x0080eed2:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080eed6:    2201        ."      MOVS     r2,#1
        0x0080eed8:    31c8        .1      ADDS     r1,r1,#0xc8
        0x0080eeda:    4806        .H      LDR      r0,[pc,#24] ; [0x80eef4] = 0x21103300
        0x0080eedc:    f7f8ddbf    ....    BL       log_buffer ; 0x7a5e
;;;250            service_id = 0xff;
        0x0080eee0:    20ff        .       MOVS     r0,#0xff
        0x0080eee2:    f88d0008    ....    STRB     r0,[sp,#8]
;;;251        }
;;;252    
;;;253        pfn_lls_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x0080eee6:    4804        .H      LDR      r0,[pc,#16] ; [0x80eef8] = 0x20800c
;;;254        return service_id;
        0x0080eee8:    6044        D`      STR      r4,[r0,#4]
        0x0080eeea:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;255    }
        0x0080eeee:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080eef0:    088000ec    ....    DCD    142606572
        0x0080eef4:    21103300    .3.!    DCD    554709760
        0x0080eef8:    0020800c    .. .    DCD    2129932
        0x0080eefc:    00810a1c    ....    DCD    8456732
    $t
    .text
    tps_set_parameter
;;; .\..\include\SDK\src\ble\profile\server\tps.c
;;;105    {
        0x0080ef00:    b510        ..      PUSH     {r4,lr}
        0x0080ef02:    2401        .$      MOVS     r4,#1
;;; .\..\include\SDK\src\ble\profile\server\tps.c (105)
        0x0080ef04:    b130        0.      CBZ      r0,0x80ef14 ; tps_set_parameter + 20
;;;106        bool ret = true;
;;;107    
;;;108        switch (param_type)
;;;109        {
;;;110        default:
;;;111            /* invalid param to set. */
;;;112            ret = false;
        0x0080ef06:    2400        .$      MOVS     r4,#0
        0x0080ef08:    4622        "F      MOV      r2,r4
        0x0080ef0a:    492c        ,I      LDR      r1,[pc,#176] ; [0x80efbc] = 0x88001d8
        0x0080ef0c:    482c        ,H      LDR      r0,[pc,#176] ; [0x80efc0] = 0x21103300
        0x0080ef0e:    f7f8dda6    ....    BL       log_buffer ; 0x7a5e
;;;113            break;
        0x0080ef12:    e002        ..      B        0x80ef1a ; tps_set_parameter + 26
;;;114    
;;;115        case TPS_PARAM_TX_POWER:
;;;116            tx_power_value = *(uint8_t *)p_value;
        0x0080ef14:    492b        +I      LDR      r1,[pc,#172] ; [0x80efc4] = 0x208014
        0x0080ef16:    7810        .x      LDRB     r0,[r2,#0]
        0x0080ef18:    7008        .p      STRB     r0,[r1,#0]
;;;117            break;
;;;118        }
;;;119    
;;;120        if (!ret)
;;;121        {
;;;122            PROFILE_PRINT_ERROR0("tps_set_parameter: TPS parameter set failed");
;;;123        }
;;;124    
;;;125        return ret;
        0x0080ef1a:    4620         F      MOV      r0,r4
;;;126    }
        0x0080ef1c:    bd10        ..      POP      {r4,pc}
    tps_attr_read_cb
;;;127    
;;;128    
;;;129    /**
;;;130     * @brief read characteristic data from service.
;;;131     *
;;;132     * @param[in] conn_id   Connection id.
;;;133     * @param[in] service_id          ServiceID to be read.
;;;134     * @param[in] attrib_index          Attribute index of getting characteristic data.
;;;135     * @param[in] offset                offset of characteritic to be read.
;;;136     * @param[in,out] length_ptr            length of getting characteristic data.
;;;137     * @param[in,out] pp_value            pointer to pointer of characteristic value to be read.
;;;138     * @return TProfileResult
;;;139    */
;;;140    T_APP_RESULT tps_attr_read_cb(uint8_t conn_id, uint8_t service_id, uint16_t attrib_index,
;;;141                                  uint16_t offset, uint16_t *length_ptr, uint8_t **pp_value)
;;;142    {
        0x0080ef1e:    e92d47fc    -..G    PUSH     {r2-r10,lr}
        0x0080ef22:    2500        .%      MOVS     r5,#0
        0x0080ef24:    e9dd490a    ...I    LDRD     r4,r9,[sp,#0x28]
        0x0080ef28:    4690        .F      MOV      r8,r2
        0x0080ef2a:    460b        .F      MOV      r3,r1
        0x0080ef2c:    8025        %.      STRH     r5,[r4,#0]
        0x0080ef2e:    2a02        .*      CMP      r2,#2
        0x0080ef30:    d009        ..      BEQ      0x80ef46 ; tps_attr_read_cb + 40
;;;143        T_APP_RESULT  cause  = APP_RESULT_SUCCESS;
;;;144        *length_ptr = 0;
;;;145        T_TPS_CALLBACK_DATA callback_data;
;;;146        switch (attrib_index)
;;;147        {
;;;148        default:
;;;149            PROFILE_PRINT_ERROR1("tps_attr_read_cb: attrib_index %d", attrib_index);
        0x0080ef32:    4922        "I      LDR      r1,[pc,#136] ; [0x80efbc] = 0x88001d8
        0x0080ef34:    4613        .F      MOV      r3,r2
        0x0080ef36:    2201        ."      MOVS     r2,#1
        0x0080ef38:    3130        01      ADDS     r1,r1,#0x30
        0x0080ef3a:    4821        !H      LDR      r0,[pc,#132] ; [0x80efc0] = 0x21103300
        0x0080ef3c:    f7f8dd8f    ....    BL       log_buffer ; 0x7a5e
;;;150            cause = APP_RESULT_ATTR_NOT_FOUND;
        0x0080ef40:    f240450a    @..E    MOV      r5,#0x40a
;;;151            break;
        0x0080ef44:    e00f        ..      B        0x80ef66 ; tps_attr_read_cb + 72
;;;152    
;;;153        case TPS_TX_POWER_VALUE_INDEX:
;;;154            callback_data.conn_id = conn_id;
        0x0080ef46:    f88d0004    ....    STRB     r0,[sp,#4]
;;;155            callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0080ef4a:    2002        .       MOVS     r0,#2
        0x0080ef4c:    4e1d        .N      LDR      r6,[pc,#116] ; [0x80efc4] = 0x208014
        0x0080ef4e:    f88d0005    ....    STRB     r0,[sp,#5]
;;;156            callback_data.msg_data.read_value_index = TPS_READ_TX_POWER_VALUE;
        0x0080ef52:    2701        .'      MOVS     r7,#1
        0x0080ef54:    f88d7006    ...p    STRB     r7,[sp,#6]
;;;157            pfn_tps_cb(service_id, (void *)&callback_data);
        0x0080ef58:    6872        rh      LDR      r2,[r6,#4]
        0x0080ef5a:    a901        ..      ADD      r1,sp,#4
        0x0080ef5c:    4618        .F      MOV      r0,r3
        0x0080ef5e:    4790        .G      BLX      r2
;;;158    
;;;159            *pp_value   = (uint8_t *)&tx_power_value;
;;;160            *length_ptr = sizeof(tx_power_value);
        0x0080ef60:    f8c96000    ...`    STR      r6,[r9,#0]
        0x0080ef64:    8027        '.      STRH     r7,[r4,#0]
;;;161            break;
;;;162        }
;;;163    
;;;164        PROFILE_PRINT_INFO2("tps_attr_read_cb: attrib_index %d, *length_ptr %d", attrib_index, *length_ptr);
        0x0080ef66:    8820         .      LDRH     r0,[r4,#0]
        0x0080ef68:    9000        ..      STR      r0,[sp,#0]
        0x0080ef6a:    4914        .I      LDR      r1,[pc,#80] ; [0x80efbc] = 0x88001d8
        0x0080ef6c:    4814        .H      LDR      r0,[pc,#80] ; [0x80efc0] = 0x21103300
        0x0080ef6e:    4643        CF      MOV      r3,r8
        0x0080ef70:    2202        ."      MOVS     r2,#2
        0x0080ef72:    3158        X1      ADDS     r1,r1,#0x58
        0x0080ef74:    1c80        ..      ADDS     r0,r0,#2
        0x0080ef76:    f7f8dd72    ..r.    BL       log_buffer ; 0x7a5e
;;;165    
;;;166        return (cause);
        0x0080ef7a:    4628        (F      MOV      r0,r5
;;;167    }
        0x0080ef7c:    e8bd87fc    ....    POP      {r2-r10,pc}
    tps_add_service
;;;168    
;;;169    
;;;170    // TPS related Service Callbacks
;;;171    const T_FUN_GATT_SERVICE_CBS tps_cbs =
;;;172    {
;;;173        tps_attr_read_cb,  // Read callback function pointer
;;;174        NULL,           // Write callback function pointer
;;;175        NULL            // CCCD update callback function pointer
;;;176    };
;;;177    
;;;178    /**
;;;179      * @brief Add tx power service to the BLE stack database.
;;;180      *
;;;181      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;182      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;183      * @retval 0xFF Operation failure.
;;;184      * @retval others Service id assigned by stack.
;;;185      *
;;;186      * <b>Example usage</b>
;;;187      * \code{.c}
;;;188         void profile_init()
;;;189         {
;;;190             server_init(1);
;;;191             tps_id = tps_add_service(app_handle_profile_message);
;;;192         }
;;;193      * \endcode
;;;194      */
;;;195    T_SERVER_ID tps_add_service(void *p_func)
;;;196    {
        0x0080ef80:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080ef82:    4604        .F      MOV      r4,r0
;;;197        T_SERVER_ID service_id;
;;;198        if (false == server_add_service(&service_id,
        0x0080ef84:    4810        .H      LDR      r0,[pc,#64] ; [0x80efc8] = 0x810a7c
        0x0080ef86:    e9d01216    ....    LDRD     r1,r2,[r0,#0x58]
        0x0080ef8a:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0080ef8e:    4601        .F      MOV      r1,r0
        0x0080ef90:    6d43        Cm      LDR      r3,[r0,#0x54]
        0x0080ef92:    2254        T"      MOVS     r2,#0x54
        0x0080ef94:    a802        ..      ADD      r0,sp,#8
        0x0080ef96:    f440f36a    @.j.    BL       server_add_service ; 0x4f66e
        0x0080ef9a:    b950        P.      CBNZ     r0,0x80efb2 ; tps_add_service + 50
;;;199                                        (uint8_t *)tps_attr_tbl,
;;;200                                        tps_attr_tbl_size,
;;;201                                        tps_cbs))
;;;202        {
;;;203            PROFILE_PRINT_ERROR1("tps_add_service: service_id %d", service_id);
        0x0080ef9c:    4907        .I      LDR      r1,[pc,#28] ; [0x80efbc] = 0x88001d8
        0x0080ef9e:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080efa2:    2201        ."      MOVS     r2,#1
        0x0080efa4:    3190        .1      ADDS     r1,r1,#0x90
        0x0080efa6:    4806        .H      LDR      r0,[pc,#24] ; [0x80efc0] = 0x21103300
        0x0080efa8:    f7f8dd59    ..Y.    BL       log_buffer ; 0x7a5e
;;;204            service_id = 0xff;
        0x0080efac:    20ff        .       MOVS     r0,#0xff
        0x0080efae:    f88d0008    ....    STRB     r0,[sp,#8]
;;;205        }
;;;206    
;;;207        pfn_tps_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x0080efb2:    4804        .H      LDR      r0,[pc,#16] ; [0x80efc4] = 0x208014
;;;208        return service_id;
        0x0080efb4:    6044        D`      STR      r4,[r0,#4]
        0x0080efb6:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;209    }
        0x0080efba:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080efbc:    088001d8    ....    DCD    142606808
        0x0080efc0:    21103300    .3.!    DCD    554709760
        0x0080efc4:    00208014    .. .    DCD    2129940
        0x0080efc8:    00810a7c    |...    DCD    8456828
    $t
    .text
    bas_set_parameter
;;; .\..\include\SDK\src\ble\profile\server\bas.c
;;;137    {
        0x0080efcc:    b510        ..      PUSH     {r4,lr}
        0x0080efce:    2401        .$      MOVS     r4,#1
        0x0080efd0:    2801        .(      CMP      r0,#1
;;; .\..\include\SDK\src\ble\profile\server\bas.c (137)
        0x0080efd2:    d006        ..      BEQ      0x80efe2 ; bas_set_parameter + 22
;;;138        bool ret = true;
;;;139    
;;;140        switch (param_type)
;;;141        {
;;;142        default:
;;;143            {
;;;144                ret = false;
        0x0080efd4:    2400        .$      MOVS     r4,#0
;;;145                PROFILE_PRINT_ERROR0("bas_set_parameter failed");
        0x0080efd6:    4622        "F      MOV      r2,r4
        0x0080efd8:    4953        SI      LDR      r1,[pc,#332] ; [0x80f128] = 0x880028c
        0x0080efda:    4854        TH      LDR      r0,[pc,#336] ; [0x80f12c] = 0x21103300
        0x0080efdc:    f7f8dd3f    ..?.    BL       log_buffer ; 0x7a5e
;;;146            }
;;;147            break;
        0x0080efe0:    e006        ..      B        0x80eff0 ; bas_set_parameter + 36
;;;148    
;;;149        case BAS_PARAM_BATTERY_LEVEL:
;;;150            {
;;;151                if (length != sizeof(uint8_t))
        0x0080efe2:    2901        .)      CMP      r1,#1
        0x0080efe4:    d001        ..      BEQ      0x80efea ; bas_set_parameter + 30
;;;152                {
;;;153                    ret = false;
        0x0080efe6:    2400        .$      MOVS     r4,#0
        0x0080efe8:    e002        ..      B        0x80eff0 ; bas_set_parameter + 36
;;;154                }
;;;155                else
;;;156                {
;;;157                    battery_level = p_value[0];
        0x0080efea:    4951        QI      LDR      r1,[pc,#324] ; [0x80f130] = 0x20801c
        0x0080efec:    7810        .x      LDRB     r0,[r2,#0]
        0x0080efee:    7008        .p      STRB     r0,[r1,#0]
;;;158                }
;;;159            }
;;;160            break;
;;;161        }
;;;162    
;;;163        return ret;
        0x0080eff0:    4620         F      MOV      r0,r4
;;;164    }
        0x0080eff2:    bd10        ..      POP      {r4,pc}
    bas_battery_level_value_notify
;;;165    
;;;166    /**
;;;167     * @brief       Send notify battery level notification data .
;;;168     *
;;;169     * @param[in]   conn_id  Connection id.
;;;170     * @param[in]   service_id  Service id.
;;;171     * @param[in]   battery_level  Battery level value.
;;;172     * @return Operation result.
;;;173     * @retval true Operation success.
;;;174     * @retval false Operation failure.
;;;175     *
;;;176     * <b>Example usage</b>
;;;177     * \code{.c}
;;;178        void test(void)
;;;179        {
;;;180            uint8_t battery_level = 90;
;;;181            bas_battery_level_value_notify(conn_id, bas_id, battery_level);
;;;182        }
;;;183     * \endcode
;;;184     */
;;;185    bool bas_battery_level_value_notify(uint8_t conn_id, uint8_t service_id, uint8_t battery_level)
;;;186    {
        0x0080eff4:    b507        ..      PUSH     {r0-r2,lr}
        0x0080eff6:    b082        ..      SUB      sp,sp,#8
;;;187        return server_send_data(conn_id, service_id, GATT_SVC_BAS_BATTERY_LEVEL_INDEX, &battery_level,
        0x0080eff8:    2300        .#      MOVS     r3,#0
        0x0080effa:    2201        ."      MOVS     r2,#1
        0x0080effc:    e9cd2300    ...#    STRD     r2,r3,[sp,#0]
        0x0080f000:    ab04        ..      ADD      r3,sp,#0x10
        0x0080f002:    2202        ."      MOVS     r2,#2
        0x0080f004:    f440f3ce    @...    BL       server_send_data ; 0x4f7a4
;;;188                                sizeof(battery_level), GATT_PDU_TYPE_ANY);
;;;189    }
        0x0080f008:    b005        ..      ADD      sp,sp,#0x14
        0x0080f00a:    bd00        ..      POP      {pc}
    bas_battery_level_value_read_confirm
;;;190    
;;;191    /**
;;;192     * @brief       Confirm for read battery level value request.
;;;193     *
;;;194     * @param[in]   conn_id  Callback when service attribute was read/write.
;;;195     * @param[in]   service_id  Callback when service attribute was read/write.
;;;196     * @param[in]   battery_level  Callback when service attribute was read/write.
;;;197     * @return Operation result.
;;;198     * @retval true Operation success.
;;;199     * @retval false Operation failure.
;;;200     *
;;;201     * <b>Example usage</b>
;;;202     * \code{.c}
;;;203        void test(void)
;;;204        {
;;;205            uint8_t battery_level = 90;
;;;206            bas_battery_level_value_read_confirm(conn_id, bas_id, battery_level);
;;;207        }
;;;208     * \endcode
;;;209     */
;;;210    bool bas_battery_level_value_read_confirm(uint8_t conn_id, uint8_t service_id,
;;;211                                              uint8_t battery_level)
;;;212    {
        0x0080f00c:    b507        ..      PUSH     {r0-r2,lr}
        0x0080f00e:    4b48        HK      LDR      r3,[pc,#288] ; [0x80f130] = 0x20801c
;;; .\..\include\SDK\src\ble\profile\server\bas.c (212)
        0x0080f010:    b082        ..      SUB      sp,sp,#8
        0x0080f012:    785a        Zx      LDRB     r2,[r3,#1]
        0x0080f014:    b14a        J.      CBZ      r2,0x80f02a ; bas_battery_level_value_read_confirm + 30
;;;213        if (bas_read_battery_level_pending == true)
;;;214        {
;;;215            bas_read_battery_level_pending = false;
        0x0080f016:    2200        ."      MOVS     r2,#0
        0x0080f018:    705a        Zp      STRB     r2,[r3,#1]
;;;216            return server_attr_read_confirm(conn_id, service_id, GATT_SVC_BAS_BATTERY_LEVEL_INDEX,
        0x0080f01a:    2301        .#      MOVS     r3,#1
        0x0080f01c:    e9cd3200    ...2    STRD     r3,r2,[sp,#0]
        0x0080f020:    ab04        ..      ADD      r3,sp,#0x10
        0x0080f022:    2202        ."      MOVS     r2,#2
        0x0080f024:    f440f335    @.5.    BL       server_attr_read_confirm ; 0x4f692
        0x0080f028:    e7ee        ..      B        0x80f008 ; bas_battery_level_value_notify + 20
;;;217                                            &battery_level, sizeof(battery_level), APP_RESULT_SUCCESS);
;;;218        }
;;;219        else
;;;220        {
;;;221            return false;
        0x0080f02a:    2000        .       MOVS     r0,#0
;;;222        }
;;;223    }
        0x0080f02c:    e7ec        ..      B        0x80f008 ; bas_battery_level_value_notify + 20
    bas_attr_read_cb
;;;224    
;;;225    /**
;;;226     * @brief read characteristic data from service.
;;;227     *
;;;228     * @param conn_id           Connection ID.
;;;229     * @param service_id        ServiceID to be read.
;;;230     * @param attrib_index      Attribute index of getting characteristic data.
;;;231     * @param offset            Offset of characteritic to be read.
;;;232     * @param p_length          Length of getting characteristic data.
;;;233     * @param pp_value          Pointer to pointer of characteristic value to be read.
;;;234     * @return T_APP_RESULT
;;;235    */
;;;236    T_APP_RESULT bas_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t attrib_index,
;;;237                                  uint16_t offset, uint16_t *p_length, uint8_t **pp_value)
;;;238    {
        0x0080f02e:    e92d43f8    -..C    PUSH     {r3-r9,lr}
        0x0080f032:    4605        .F      MOV      r5,r0
        0x0080f034:    e9dd6708    ...g    LDRD     r6,r7,[sp,#0x20]
        0x0080f038:    2000        .       MOVS     r0,#0
        0x0080f03a:    8030        0.      STRH     r0,[r6,#0]
        0x0080f03c:    4688        .F      MOV      r8,r1
        0x0080f03e:    9300        ..      STR      r3,[sp,#0]
        0x0080f040:    4939        9I      LDR      r1,[pc,#228] ; [0x80f128] = 0x880028c
        0x0080f042:    483a        :H      LDR      r0,[pc,#232] ; [0x80f12c] = 0x21103300
        0x0080f044:    4614        .F      MOV      r4,r2
;;;239        T_APP_RESULT cause = APP_RESULT_SUCCESS;
;;;240        *p_length = 0;
;;;241    
;;;242        PROFILE_PRINT_INFO2("bas_attr_read_cb attrib_index = %d offset %x", attrib_index, offset);
        0x0080f046:    4613        .F      MOV      r3,r2
        0x0080f048:    2202        ."      MOVS     r2,#2
        0x0080f04a:    311c        .1      ADDS     r1,r1,#0x1c
        0x0080f04c:    1c80        ..      ADDS     r0,r0,#2
        0x0080f04e:    f7f8dd06    ....    BL       log_buffer ; 0x7a5e
;;;243    
;;;244        switch (attrib_index)
        0x0080f052:    2c02        .,      CMP      r4,#2
        0x0080f054:    d00a        ..      BEQ      0x80f06c ; bas_attr_read_cb + 62
;;;245        {
;;;246        default:
;;;247            {
;;;248                PROFILE_PRINT_ERROR1("bas_attr_read_cb attrib_index = %d not found", attrib_index);
        0x0080f056:    4934        4I      LDR      r1,[pc,#208] ; [0x80f128] = 0x880028c
        0x0080f058:    4623        #F      MOV      r3,r4
        0x0080f05a:    2201        ."      MOVS     r2,#1
        0x0080f05c:    314c        L1      ADDS     r1,r1,#0x4c
        0x0080f05e:    4833        3H      LDR      r0,[pc,#204] ; [0x80f12c] = 0x21103300
        0x0080f060:    f7f8dcfd    ....    BL       log_buffer ; 0x7a5e
;;;249                cause  = APP_RESULT_ATTR_NOT_FOUND;
        0x0080f064:    f240400a    @..@    MOV      r0,#0x40a
        0x0080f068:    e8bd83f8    ....    POP      {r3-r9,pc}
;;;250            }
;;;251            break;
;;;252    
;;;253        case GATT_SVC_BAS_BATTERY_LEVEL_INDEX:
;;;254            {
;;;255                T_BAS_CALLBACK_DATA callback_data;
;;;256                callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0080f06c:    2002        .       MOVS     r0,#2
        0x0080f06e:    f88d0001    ....    STRB     r0,[sp,#1]
;;;257                callback_data.conn_id = conn_id;
        0x0080f072:    f88d5000    ...P    STRB     r5,[sp,#0]
        0x0080f076:    4d2e        .M      LDR      r5,[pc,#184] ; [0x80f130] = 0x20801c
;;;258                callback_data.msg_data.read_value_index = BAS_READ_BATTERY_LEVEL;
        0x0080f078:    2401        .$      MOVS     r4,#1
        0x0080f07a:    f88d4002    ...@    STRB     r4,[sp,#2]
;;;259                cause = pfn_bas_cb(service_id, (void *)&callback_data);
        0x0080f07e:    686a        jh      LDR      r2,[r5,#4]
        0x0080f080:    4669        iF      MOV      r1,sp
        0x0080f082:    4640        @F      MOV      r0,r8
        0x0080f084:    4790        .G      BLX      r2
;;;260                if (cause == APP_RESULT_PENDING)
        0x0080f086:    f5a06150    ..Pa    SUB      r1,r0,#0xd00
        0x0080f08a:    3901        .9      SUBS     r1,#1
        0x0080f08c:    d100        ..      BNE      0x80f090 ; bas_attr_read_cb + 98
;;;261                {
;;;262                    bas_read_battery_level_pending = true;
        0x0080f08e:    706c        lp      STRB     r4,[r5,#1]
;;;263                }
;;;264    
;;;265                *pp_value = &battery_level;
;;;266                *p_length = sizeof(battery_level);
        0x0080f090:    603d        =`      STR      r5,[r7,#0]
        0x0080f092:    8034        4.      STRH     r4,[r6,#0]
;;;267            }
;;;268            break;
;;;269        }
;;;270        return (cause);
;;;271    }
        0x0080f094:    e7e8        ..      B        0x80f068 ; bas_attr_read_cb + 58
    bas_cccd_update_cb
;;;272    
;;;273    /**
;;;274     * @brief update CCCD bits from stack.
;;;275     *
;;;276     * @param conn_id           Connection ID.
;;;277     * @param service_id        Service ID.
;;;278     * @param index             Attribute index of characteristic data.
;;;279     * @param ccc_bits          CCCD bits from stack.
;;;280     * @return None
;;;281    */
;;;282    void bas_cccd_update_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t index, uint16_t ccc_bits)
;;;283    {
        0x0080f096:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x0080f09a:    2601        .&      MOVS     r6,#1
        0x0080f09c:    f88d6005    ...`    STRB     r6,[sp,#5]
        0x0080f0a0:    4688        .F      MOV      r8,r1
        0x0080f0a2:    f88d0004    ....    STRB     r0,[sp,#4]
        0x0080f0a6:    461d        .F      MOV      r5,r3
        0x0080f0a8:    9300        ..      STR      r3,[sp,#0]
        0x0080f0aa:    491f        .I      LDR      r1,[pc,#124] ; [0x80f128] = 0x880028c
        0x0080f0ac:    481f        .H      LDR      r0,[pc,#124] ; [0x80f12c] = 0x21103300
        0x0080f0ae:    4617        .F      MOV      r7,r2
        0x0080f0b0:    4613        .F      MOV      r3,r2
;;;284        T_BAS_CALLBACK_DATA callback_data;
;;;285        callback_data.msg_type = SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION;
;;;286        callback_data.conn_id = conn_id;
;;;287        bool handle = true;
        0x0080f0b2:    4634        4F      MOV      r4,r6
;;;288        PROFILE_PRINT_INFO2("bas_cccd_update_cb index = %d ccc_bits %x", index, ccc_bits);
        0x0080f0b4:    2202        ."      MOVS     r2,#2
        0x0080f0b6:    317c        |1      ADDS     r1,r1,#0x7c
        0x0080f0b8:    1c80        ..      ADDS     r0,r0,#2
        0x0080f0ba:    f7f8dcd0    ....    BL       log_buffer ; 0x7a5e
;;;289    
;;;290        switch (index)
        0x0080f0be:    2f03        ./      CMP      r7,#3
        0x0080f0c0:    d00b        ..      BEQ      0x80f0da ; bas_cccd_update_cb + 68
;;;291        {
;;;292        case GATT_SVC_BAS_CHAR_CCCD_INDEX:
;;;293            {
;;;294                if (ccc_bits & GATT_CLIENT_CHAR_CONFIG_NOTIFY)
;;;295                {
;;;296                    callback_data.msg_data.notification_indification_index = BAS_NOTIFY_BATTERY_LEVEL_ENABLE;
;;;297                }
;;;298                else
;;;299                {
;;;300                    callback_data.msg_data.notification_indification_index = BAS_NOTIFY_BATTERY_LEVEL_DISABLE;
;;;301                }
;;;302                break;
;;;303            }
;;;304        default:
;;;305            {
;;;306                handle = false;
        0x0080f0c2:    2400        .$      MOVS     r4,#0
;;;307                break;
;;;308            }
;;;309    
;;;310        }
;;;311    
;;;312        if (pfn_bas_cb && (handle == true))
        0x0080f0c4:    481a        .H      LDR      r0,[pc,#104] ; [0x80f130] = 0x20801c
        0x0080f0c6:    6842        Bh      LDR      r2,[r0,#4]
        0x0080f0c8:    2a00        .*      CMP      r2,#0
        0x0080f0ca:    d004        ..      BEQ      0x80f0d6 ; bas_cccd_update_cb + 64
        0x0080f0cc:    2c00        .,      CMP      r4,#0
        0x0080f0ce:    d002        ..      BEQ      0x80f0d6 ; bas_cccd_update_cb + 64
;;;313        {
;;;314            pfn_bas_cb(service_id, (void *)&callback_data);
        0x0080f0d0:    a901        ..      ADD      r1,sp,#4
        0x0080f0d2:    4640        @F      MOV      r0,r8
        0x0080f0d4:    4790        .G      BLX      r2
;;;315        }
;;;316    
;;;317        return;
;;;318    }
        0x0080f0d6:    e8bd81fc    ....    POP      {r2-r8,pc}
        0x0080f0da:    07e8        ..      LSLS     r0,r5,#31
        0x0080f0dc:    d002        ..      BEQ      0x80f0e4 ; bas_cccd_update_cb + 78
        0x0080f0de:    f88d6006    ...`    STRB     r6,[sp,#6]
        0x0080f0e2:    e7ef        ..      B        0x80f0c4 ; bas_cccd_update_cb + 46
        0x0080f0e4:    2002        .       MOVS     r0,#2
        0x0080f0e6:    f88d0006    ....    STRB     r0,[sp,#6]
        0x0080f0ea:    e7eb        ..      B        0x80f0c4 ; bas_cccd_update_cb + 46
    bas_add_service
;;;319    
;;;320    /**
;;;321     * @brief BAS Service Callbacks.
;;;322    */
;;;323    const T_FUN_GATT_SERVICE_CBS bas_cbs =
;;;324    {
;;;325        bas_attr_read_cb,  // Read callback function pointer
;;;326        NULL, // Write callback function pointer
;;;327        bas_cccd_update_cb  // CCCD update callback function pointer
;;;328    };
;;;329    
;;;330    /**
;;;331      * @brief       Add battery service to the BLE stack database.
;;;332      *
;;;333      *
;;;334      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;335      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;336      * @retval 0xFF Operation failure.
;;;337      * @retval Others Service id assigned by stack.
;;;338      *
;;;339      * <b>Example usage</b>
;;;340      * \code{.c}
;;;341         void profile_init()
;;;342         {
;;;343             server_init(1);
;;;344             bas_id = bas_add_service(app_handle_profile_message);
;;;345         }
;;;346      * \endcode
;;;347      */
;;;348    T_SERVER_ID bas_add_service(void *p_func)
;;;349    {
        0x0080f0ec:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080f0ee:    4604        .F      MOV      r4,r0
;;;350        T_SERVER_ID service_id;
;;;351        if (false == server_add_service(&service_id,
        0x0080f0f0:    4810        .H      LDR      r0,[pc,#64] ; [0x80f134] = 0x810adc
        0x0080f0f2:    e9d0121d    ....    LDRD     r1,r2,[r0,#0x74]
        0x0080f0f6:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0080f0fa:    4601        .F      MOV      r1,r0
        0x0080f0fc:    6f03        .o      LDR      r3,[r0,#0x70]
        0x0080f0fe:    2270        p"      MOVS     r2,#0x70
        0x0080f100:    a802        ..      ADD      r0,sp,#8
        0x0080f102:    f440f2b4    @...    BL       server_add_service ; 0x4f66e
        0x0080f106:    b950        P.      CBNZ     r0,0x80f11e ; bas_add_service + 50
;;;352                                        (uint8_t *)bas_attr_tbl,
;;;353                                        bas_attr_tbl_size,
;;;354                                        bas_cbs))
;;;355        {
;;;356            PROFILE_PRINT_ERROR1("bas_add_service: service_id %d", service_id);
        0x0080f108:    4907        .I      LDR      r1,[pc,#28] ; [0x80f128] = 0x880028c
        0x0080f10a:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080f10e:    2201        ."      MOVS     r2,#1
        0x0080f110:    31ac        .1      ADDS     r1,r1,#0xac
        0x0080f112:    4806        .H      LDR      r0,[pc,#24] ; [0x80f12c] = 0x21103300
        0x0080f114:    f7f8dca3    ....    BL       log_buffer ; 0x7a5e
;;;357            service_id = 0xff;
        0x0080f118:    20ff        .       MOVS     r0,#0xff
        0x0080f11a:    f88d0008    ....    STRB     r0,[sp,#8]
;;;358        }
;;;359        pfn_bas_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x0080f11e:    4804        .H      LDR      r0,[pc,#16] ; [0x80f130] = 0x20801c
;;;360        return service_id;
        0x0080f120:    6044        D`      STR      r4,[r0,#4]
        0x0080f122:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;361    }
        0x0080f126:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080f128:    0880028c    ....    DCD    142606988
        0x0080f12c:    21103300    .3.!    DCD    554709760
        0x0080f130:    0020801c    .. .    DCD    2129948
        0x0080f134:    00810adc    ....    DCD    8456924
    $t
    .text
    kns_set_parameter
;;; ..\include\SDK\src\app\pxp\kns.c
;;;203    {
        0x0080f138:    b510        ..      PUSH     {r4,lr}
        0x0080f13a:    2401        .$      MOVS     r4,#1
;;; ..\include\SDK\src\app\pxp\kns.c (203)
        0x0080f13c:    b130        0.      CBZ      r0,0x80f14c ; kns_set_parameter + 20
;;;204        bool ret = true;
;;;205    
;;;206        switch (param_type)
;;;207        {
;;;208        default:
;;;209            {
;;;210                ret = false;
        0x0080f13e:    2400        .$      MOVS     r4,#0
;;;211                PROFILE_PRINT_ERROR0("bas_set_parameter failed");
        0x0080f140:    4622        "F      MOV      r2,r4
        0x0080f142:    4957        WI      LDR      r1,[pc,#348] ; [0x80f2a0] = 0x880035c
        0x0080f144:    4857        WH      LDR      r0,[pc,#348] ; [0x80f2a4] = 0x21103300
        0x0080f146:    f7f8dc8a    ....    BL       log_buffer ; 0x7a5e
;;;212            }
;;;213            break;
        0x0080f14a:    e006        ..      B        0x80f15a ; kns_set_parameter + 34
;;;214    
;;;215        case KNS_PARAM_VALUE:
;;;216            {
;;;217                if (length != sizeof(uint32_t))
        0x0080f14c:    2904        .)      CMP      r1,#4
        0x0080f14e:    d001        ..      BEQ      0x80f154 ; kns_set_parameter + 28
;;;218                {
;;;219                    ret = false;
        0x0080f150:    2400        .$      MOVS     r4,#0
        0x0080f152:    e002        ..      B        0x80f15a ; kns_set_parameter + 34
;;;220                }
;;;221                else
;;;222                {
;;;223                    gParaValue = *p_value;
        0x0080f154:    4954        TI      LDR      r1,[pc,#336] ; [0x80f2a8] = 0x207e5c
        0x0080f156:    6810        .h      LDR      r0,[r2,#0]
        0x0080f158:    6008        .`      STR      r0,[r1,#0]
;;;224                }
;;;225            }
;;;226            break;
;;;227        }
;;;228    
;;;229        return ret;
        0x0080f15a:    4620         F      MOV      r0,r4
;;;230    }
        0x0080f15c:    bd10        ..      POP      {r4,pc}
    kns_attr_read_cb
;;;231    /**
;;;232     * @brief read characteristic data from stack.
;;;233     *
;;;234     * @param ServiceId          ServiceId generated when register to upper stack.
;;;235     * @param attrib_index          Attribute index of getting characteristic data.
;;;236     * @param offset                Used for Blob Read.
;;;237     * @param length_ptr            length of getting characteristic data.
;;;238     * @param ppValue            pointer of getting characteristic data.
;;;239     * @return TProfileResult   profile procedure results.
;;;240    */
;;;241    T_APP_RESULT kns_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t attrib_index,
;;;242                                  uint16_t offset, uint16_t *p_length, uint8_t **pp_value)
;;;243    {
        0x0080f15e:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x0080f162:    2500        .%      MOVS     r5,#0
        0x0080f164:    e9dd4708    ...G    LDRD     r4,r7,[sp,#0x20]
        0x0080f168:    4616        .F      MOV      r6,r2
        0x0080f16a:    460b        .F      MOV      r3,r1
        0x0080f16c:    8025        %.      STRH     r5,[r4,#0]
        0x0080f16e:    2a02        .*      CMP      r2,#2
        0x0080f170:    d009        ..      BEQ      0x80f186 ; kns_attr_read_cb + 40
;;;244        T_APP_RESULT  cause  = APP_RESULT_SUCCESS;
;;;245        *p_length = 0;
;;;246    
;;;247        switch (attrib_index)
;;;248        {
;;;249        default:
;;;250            /* invalid attribute index. */
;;;251            PROFILE_PRINT_ERROR1("kns_attr_read_cb attrib_index = %d not found", attrib_index);
        0x0080f172:    494b        KI      LDR      r1,[pc,#300] ; [0x80f2a0] = 0x880035c
        0x0080f174:    4613        .F      MOV      r3,r2
        0x0080f176:    2201        ."      MOVS     r2,#1
        0x0080f178:    311c        .1      ADDS     r1,r1,#0x1c
        0x0080f17a:    484a        JH      LDR      r0,[pc,#296] ; [0x80f2a4] = 0x21103300
        0x0080f17c:    f7f8dc6f    ..o.    BL       log_buffer ; 0x7a5e
;;;252            cause  = APP_RESULT_ATTR_NOT_FOUND;
        0x0080f180:    f240450a    @..E    MOV      r5,#0x40a
;;;253            break;
        0x0080f184:    e00e        ..      B        0x80f1a4 ; kns_attr_read_cb + 70
;;;254        case KNS_PARAM_VALUE_INDEX:
;;;255            {
;;;256                T_KNS_CALLBACK_DATA callback_data;
;;;257    
;;;258                callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0080f186:    2002        .       MOVS     r0,#2
        0x0080f188:    f88d0000    ....    STRB     r0,[sp,#0]
;;;259                //callback_data.conn_id = conn_id;
;;;260                callback_data.msg_data.read_index = KNS_READ_PARA;
        0x0080f18c:    f88d0004    ....    STRB     r0,[sp,#4]
;;;261                if (pfn_kns_cb)
        0x0080f190:    4846        FH      LDR      r0,[pc,#280] ; [0x80f2ac] = 0x208024
        0x0080f192:    6802        .h      LDR      r2,[r0,#0]
        0x0080f194:    b112        ..      CBZ      r2,0x80f19c ; kns_attr_read_cb + 62
;;;262                {
;;;263                    pfn_kns_cb(service_id, (void *)&callback_data);
        0x0080f196:    4669        iF      MOV      r1,sp
        0x0080f198:    4618        .F      MOV      r0,r3
        0x0080f19a:    4790        .G      BLX      r2
;;;264                }
;;;265    
;;;266                *pp_value = (uint8_t *)&gParaValue;
        0x0080f19c:    4842        BH      LDR      r0,[pc,#264] ; [0x80f2a8] = 0x207e5c
;;;267                *p_length = sizeof(gParaValue);
        0x0080f19e:    6038        8`      STR      r0,[r7,#0]
        0x0080f1a0:    2004        .       MOVS     r0,#4
        0x0080f1a2:    8020         .      STRH     r0,[r4,#0]
;;;268            }
;;;269            break;
;;;270        }
;;;271    
;;;272        PROFILE_PRINT_INFO2("<-- gatt get PxpExtended attribute value: AttribIndex--%d, length--%d",
        0x0080f1a4:    8820         .      LDRH     r0,[r4,#0]
        0x0080f1a6:    9000        ..      STR      r0,[sp,#0]
        0x0080f1a8:    493d        =I      LDR      r1,[pc,#244] ; [0x80f2a0] = 0x880035c
        0x0080f1aa:    483e        >H      LDR      r0,[pc,#248] ; [0x80f2a4] = 0x21103300
        0x0080f1ac:    4633        3F      MOV      r3,r6
        0x0080f1ae:    2202        ."      MOVS     r2,#2
        0x0080f1b0:    314c        L1      ADDS     r1,r1,#0x4c
        0x0080f1b2:    1c80        ..      ADDS     r0,r0,#2
        0x0080f1b4:    f7f8dc53    ..S.    BL       log_buffer ; 0x7a5e
;;;273                            attrib_index,
;;;274                            *p_length);
;;;275        return (cause);
        0x0080f1b8:    4628        (F      MOV      r0,r5
;;;276    }
        0x0080f1ba:    e8bd81fc    ....    POP      {r2-r8,pc}
    kns_attr_write_cb
;;;277    
;;;278    /**
;;;279     * @brief write characteristic data from stack.
;;;280     *
;;;281     * @param ServiceId          ServiceId generated when register to upper stack.
;;;282     * @param iAttribIndex          Attribute index of getting characteristic data.
;;;283     * @param wLength                length of data to be written.
;;;284     * @param pValue            pointer of data to be written.
;;;285     * @return TProfileResult   profile procedure results.
;;;286    */
;;;287    
;;;288    static T_APP_RESULT kns_attr_write_cb(uint8_t conn_id, T_SERVER_ID service_id,
;;;289                                          uint16_t attr_index, T_WRITE_TYPE write_type, uint16_t length,
;;;290                                          uint8_t *p_value, P_FUN_WRITE_IND_POST_PROC *p_write_ind_post_proc)
;;;291    {
        0x0080f1be:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080f1c0:    460d        .F      MOV      r5,r1
        0x0080f1c2:    e9dd0306    ....    LDRD     r0,r3,[sp,#0x18]
        0x0080f1c6:    2400        .$      MOVS     r4,#0
        0x0080f1c8:    b123        #.      CBZ      r3,0x80f1d4 ; kns_attr_write_cb + 22
        0x0080f1ca:    2a02        .*      CMP      r2,#2
        0x0080f1cc:    d00c        ..      BEQ      0x80f1e8 ; kns_attr_write_cb + 42
        0x0080f1ce:    f240440a    @..D    MOV      r4,#0x40a
        0x0080f1d2:    e013        ..      B        0x80f1fc ; kns_attr_write_cb + 62
;;;292        T_APP_RESULT  cause = APP_RESULT_SUCCESS;
;;;293        T_KNS_CALLBACK_DATA callback_data;
;;;294        if (!p_value)
;;;295        {
;;;296            PROFILE_PRINT_ERROR2("kns_attr_write_cb: p_value %p, length 0x%x", p_value, length);
        0x0080f1d4:    4932        2I      LDR      r1,[pc,#200] ; [0x80f2a0] = 0x880035c
        0x0080f1d6:    9000        ..      STR      r0,[sp,#0]
        0x0080f1d8:    2202        ."      MOVS     r2,#2
        0x0080f1da:    3198        .1      ADDS     r1,r1,#0x98
        0x0080f1dc:    4831        1H      LDR      r0,[pc,#196] ; [0x80f2a4] = 0x21103300
        0x0080f1de:    f7f8dc3e    ..>.    BL       log_buffer ; 0x7a5e
;;;297            cause = APP_RESULT_INVALID_PDU;
        0x0080f1e2:    f2404004    @..@    MOV      r0,#0x404
        0x0080f1e6:    bd3e        >.      POP      {r1-r5,pc}
;;;298            return cause;
;;;299        }
;;;300    
;;;301        switch (attr_index)
;;;302        {
;;;303        default:
;;;304            cause = APP_RESULT_ATTR_NOT_FOUND;
;;;305            break;
;;;306        case KNS_PARAM_VALUE_INDEX:
;;;307            if (length != sizeof(uint32_t))
        0x0080f1e8:    2804        .(      CMP      r0,#4
        0x0080f1ea:    d002        ..      BEQ      0x80f1f2 ; kns_attr_write_cb + 52
;;;308            {
;;;309                cause = APP_RESULT_INVALID_VALUE_SIZE;
        0x0080f1ec:    f240440d    @..D    MOV      r4,#0x40d
        0x0080f1f0:    e004        ..      B        0x80f1fc ; kns_attr_write_cb + 62
;;;310            }
;;;311            else
;;;312            {
;;;313                //callback_data.conn_id = conn_id;
;;;314                callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
        0x0080f1f2:    2003        .       MOVS     r0,#3
        0x0080f1f4:    f88d0004    ....    STRB     r0,[sp,#4]
;;;315                callback_data.msg_data.write_value = *(uint32_t *)p_value;
        0x0080f1f8:    6818        .h      LDR      r0,[r3,#0]
        0x0080f1fa:    9002        ..      STR      r0,[sp,#8]
;;;316            }
;;;317            break;
;;;318    
;;;319        }
;;;320        if (pfn_kns_cb && (cause == APP_RESULT_SUCCESS))
        0x0080f1fc:    482b        +H      LDR      r0,[pc,#172] ; [0x80f2ac] = 0x208024
        0x0080f1fe:    6802        .h      LDR      r2,[r0,#0]
        0x0080f200:    b11a        ..      CBZ      r2,0x80f20a ; kns_attr_write_cb + 76
        0x0080f202:    b914        ..      CBNZ     r4,0x80f20a ; kns_attr_write_cb + 76
;;;321        {
;;;322            pfn_kns_cb(service_id, (void *)&callback_data);
        0x0080f204:    a901        ..      ADD      r1,sp,#4
        0x0080f206:    4628        (F      MOV      r0,r5
        0x0080f208:    4790        .G      BLX      r2
;;;323        }
;;;324        return cause;
        0x0080f20a:    4620         F      MOV      r0,r4
;;;325    
;;;326    }
        0x0080f20c:    bd3e        >.      POP      {r1-r5,pc}
    kns_cccd_update_cb
;;;327    /**
;;;328     * @brief update CCCD bits from stack.
;;;329     *
;;;330     * @param ServiceId          ServiceId generated when register to upper stack.
;;;331     * @param Index          Attribute index of getting characteristic data.
;;;332     * @param wCCCBits                CCCD bits to be updated.
;;;333     * @return none.
;;;334    */
;;;335    
;;;336    void kns_cccd_update_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t index, uint16_t ccc_bits)
;;;337    {
        0x0080f20e:    e92d43fe    -..C    PUSH     {r1-r9,lr}
        0x0080f212:    4688        .F      MOV      r8,r1
        0x0080f214:    461d        .F      MOV      r5,r3
        0x0080f216:    2601        .&      MOVS     r6,#1
        0x0080f218:    9300        ..      STR      r3,[sp,#0]
        0x0080f21a:    4921        !I      LDR      r1,[pc,#132] ; [0x80f2a0] = 0x880035c
        0x0080f21c:    4821        !H      LDR      r0,[pc,#132] ; [0x80f2a4] = 0x21103300
        0x0080f21e:    4617        .F      MOV      r7,r2
        0x0080f220:    4613        .F      MOV      r3,r2
;;;338        T_KNS_CALLBACK_DATA callback_data;
;;;339        callback_data.msg_type = SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION;
        0x0080f222:    f88d6004    ...`    STRB     r6,[sp,#4]
;;;340        //callback_data.conn_id = conn_id;
;;;341        bool handle = true;
        0x0080f226:    4634        4F      MOV      r4,r6
;;;342        PROFILE_PRINT_INFO2("kns_cccd_update_cb index = %d ccc_bits %x", index, ccc_bits);
        0x0080f228:    2202        ."      MOVS     r2,#2
        0x0080f22a:    31c8        .1      ADDS     r1,r1,#0xc8
        0x0080f22c:    1c80        ..      ADDS     r0,r0,#2
        0x0080f22e:    f7f8dc16    ....    BL       log_buffer ; 0x7a5e
;;;343    
;;;344        switch (index)
        0x0080f232:    2f05        ./      CMP      r7,#5
        0x0080f234:    d00b        ..      BEQ      0x80f24e ; kns_cccd_update_cb + 64
;;;345        {
;;;346        case KNS_KEY_VALUE_CCCD_INDEX:
;;;347            {
;;;348                if (ccc_bits & GATT_CLIENT_CHAR_CONFIG_NOTIFY)
;;;349                {
;;;350                    callback_data.msg_data.notification_indification_index = KNS_NOTIFY_ENABLE;
;;;351                }
;;;352                else
;;;353                {
;;;354                    callback_data.msg_data.notification_indification_index = KNS_NOTIFY_DISABLE;
;;;355                }
;;;356                break;
;;;357            }
;;;358        default:
;;;359            {
;;;360                handle = false;
        0x0080f236:    2400        .$      MOVS     r4,#0
;;;361                break;
;;;362            }
;;;363    
;;;364        }
;;;365    
;;;366        if (pfn_kns_cb && (handle == true))
        0x0080f238:    481c        .H      LDR      r0,[pc,#112] ; [0x80f2ac] = 0x208024
        0x0080f23a:    6802        .h      LDR      r2,[r0,#0]
        0x0080f23c:    2a00        .*      CMP      r2,#0
        0x0080f23e:    d004        ..      BEQ      0x80f24a ; kns_cccd_update_cb + 60
        0x0080f240:    2c00        .,      CMP      r4,#0
        0x0080f242:    d002        ..      BEQ      0x80f24a ; kns_cccd_update_cb + 60
;;;367        {
;;;368            pfn_kns_cb(service_id, (void *)&callback_data);
        0x0080f244:    a901        ..      ADD      r1,sp,#4
        0x0080f246:    4640        @F      MOV      r0,r8
        0x0080f248:    4790        .G      BLX      r2
;;;369        }
;;;370    
;;;371        return;
;;;372    }
        0x0080f24a:    e8bd83fe    ....    POP      {r1-r9,pc}
        0x0080f24e:    07e8        ..      LSLS     r0,r5,#31
        0x0080f250:    d002        ..      BEQ      0x80f258 ; kns_cccd_update_cb + 74
        0x0080f252:    f88d6008    ...`    STRB     r6,[sp,#8]
        0x0080f256:    e7ef        ..      B        0x80f238 ; kns_cccd_update_cb + 42
        0x0080f258:    2000        .       MOVS     r0,#0
        0x0080f25a:    f88d0008    ....    STRB     r0,[sp,#8]
        0x0080f25e:    e7eb        ..      B        0x80f238 ; kns_cccd_update_cb + 42
    kns_add_service
;;;373    
;;;374    /**
;;;375     * @brief KNS Service Callbacks.
;;;376    */
;;;377    const T_FUN_GATT_SERVICE_CBS kns_cbs =
;;;378    {
;;;379        kns_attr_read_cb,  // Read callback function pointer
;;;380        kns_attr_write_cb, // Write callback function pointer
;;;381        kns_cccd_update_cb  // CCCD update callback function pointer
;;;382    };
;;;383    
;;;384    /**
;;;385     * @brief Add PXP extended service to stack/profile.
;;;386     *
;;;387     * @param pFunc          pointer of function to send data to application from PXP extended service.
;;;388     * @return ServiceId.   the service ID auto generated by stack when register this service to stack
;;;389    */
;;;390    uint8_t kns_add_service(void *pFunc)
;;;391    {
        0x0080f260:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080f262:    4604        .F      MOV      r4,r0
;;;392        T_SERVER_ID service_id;
;;;393        if (false == server_add_service(&service_id,
        0x0080f264:    4812        .H      LDR      r0,[pc,#72] ; [0x80f2b0] = 0x810be8
        0x0080f266:    e9d0120b    ....    LDRD     r1,r2,[r0,#0x2c]
        0x0080f26a:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0080f26e:    f1a00180    ....    SUB      r1,r0,#0x80
        0x0080f272:    6a83        .j      LDR      r3,[r0,#0x28]
        0x0080f274:    22a8        ."      MOVS     r2,#0xa8
        0x0080f276:    a802        ..      ADD      r0,sp,#8
        0x0080f278:    f440f1f9    @...    BL       server_add_service ; 0x4f66e
        0x0080f27c:    b950        P.      CBNZ     r0,0x80f294 ; kns_add_service + 52
;;;394                                        (uint8_t *)kns_attr_tbl,
;;;395                                        kns_attr_tbl_size,
;;;396                                        kns_cbs))
;;;397        {
;;;398            PROFILE_PRINT_ERROR1("kns_add_service: service_id %d", service_id);
        0x0080f27e:    4908        .I      LDR      r1,[pc,#32] ; [0x80f2a0] = 0x880035c
        0x0080f280:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080f284:    2201        ."      MOVS     r2,#1
        0x0080f286:    31f8        .1      ADDS     r1,r1,#0xf8
        0x0080f288:    4806        .H      LDR      r0,[pc,#24] ; [0x80f2a4] = 0x21103300
        0x0080f28a:    f7f8dbe8    ....    BL       log_buffer ; 0x7a5e
;;;399            service_id = 0xff;
        0x0080f28e:    20ff        .       MOVS     r0,#0xff
        0x0080f290:    f88d0008    ....    STRB     r0,[sp,#8]
;;;400        }
;;;401    
;;;402        pfn_kns_cb = (P_FUN_SERVER_GENERAL_CB)pFunc;
        0x0080f294:    4805        .H      LDR      r0,[pc,#20] ; [0x80f2ac] = 0x208024
;;;403        return service_id;
        0x0080f296:    6004        .`      STR      r4,[r0,#0]
        0x0080f298:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;404    }
        0x0080f29c:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080f29e:    0000        ..      DCW    0
        0x0080f2a0:    0880035c    \...    DCD    142607196
        0x0080f2a4:    21103300    .3.!    DCD    554709760
        0x0080f2a8:    00207e5c    \~ .    DCD    2129500
        0x0080f2ac:    00208024    $. .    DCD    2129956
        0x0080f2b0:    00810be8    ....    DCD    8457192
    $t
    .text
    dis_set_parameter
;;; .\..\include\SDK\src\ble\profile\server\dis.c
;;;422    {
        0x0080f2b4:    b570        p.      PUSH     {r4-r6,lr}
        0x0080f2b6:    4613        .F      MOV      r3,r2
;;;423        bool ret = true;
        0x0080f2b8:    2401        .$      MOVS     r4,#1
        0x0080f2ba:    4a9a        .J      LDR      r2,[pc,#616] ; [0x80f524] = 0x208028
;;;424    
;;;425        switch (param_type)
        0x0080f2bc:    2809        .(      CMP      r0,#9
        0x0080f2be:    d206        ..      BCS      0x80f2ce ; dis_set_parameter + 26
        0x0080f2c0:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x0080f2c4:    2a21150c    ..!*    DCD    706811148
        0x0080f2c8:    4c453c33    3<EL    DCD    1279605811
        0x0080f2cc:    0056        V.      DCW    86
    $t
;;;426        {
;;;427        default:
;;;428            ret = false;
        0x0080f2ce:    2400        .$      MOVS     r4,#0
        0x0080f2d0:    4622        "F      MOV      r2,r4
        0x0080f2d2:    4995        .I      LDR      r1,[pc,#596] ; [0x80f528] = 0x8800478
        0x0080f2d4:    4895        .H      LDR      r0,[pc,#596] ; [0x80f52c] = 0x21103300
        0x0080f2d6:    f7f8dbc2    ....    BL       log_buffer ; 0x7a5e
;;;429            break;
        0x0080f2da:    e012        ..      B        0x80f302 ; dis_set_parameter + 78
;;;430    
;;;431    #if DIS_CHAR_MANUFACTURER_NAME_SUPPORT
;;;432        case DIS_PARAM_MANUFACTURER_NAME:
;;;433            if (length > DIS_CHAR_MANUFACTURER_NAME_STR_MAX_LENGTH)
        0x0080f2dc:    2914        .)      CMP      r1,#0x14
        0x0080f2de:    d900        ..      BLS      0x80f2e2 ; dis_set_parameter + 46
;;;434            {
;;;435                length = DIS_CHAR_MANUFACTURER_NAME_STR_MAX_LENGTH;
        0x0080f2e0:    2114        .!      MOVS     r1,#0x14
;;;436            }
;;;437            dis_manufacturer_name_len = length;
        0x0080f2e2:    7011        .p      STRB     r1,[r2,#0]
;;;438            memcpy(dis_manufacturer_name, p_value, length);
        0x0080f2e4:    488f        .H      LDR      r0,[pc,#572] ; [0x80f524] = 0x208028
        0x0080f2e6:    460a        .F      MOV      r2,r1
        0x0080f2e8:    4619        .F      MOV      r1,r3
        0x0080f2ea:    300c        .0      ADDS     r0,r0,#0xc
;;;439            break;
        0x0080f2ec:    e007        ..      B        0x80f2fe ; dis_set_parameter + 74
;;;440    #endif
;;;441    
;;;442    #if DIS_CHAR_MODEL_NUMBER_SUPPORT
;;;443        case DIS_PARAM_MODEL_NUMBER:
;;;444            if (length > DIS_CHAR_MODEL_NUMBER_STR_MAX_LENGTH)
        0x0080f2ee:    2914        .)      CMP      r1,#0x14
        0x0080f2f0:    d900        ..      BLS      0x80f2f4 ; dis_set_parameter + 64
;;;445            {
;;;446                length = DIS_CHAR_MODEL_NUMBER_STR_MAX_LENGTH;
        0x0080f2f2:    2114        .!      MOVS     r1,#0x14
;;;447            }
;;;448            dis_model_number_len = length;
        0x0080f2f4:    7051        Qp      STRB     r1,[r2,#1]
;;;449            memcpy(dis_model_number, p_value, length);
        0x0080f2f6:    488b        .H      LDR      r0,[pc,#556] ; [0x80f524] = 0x208028
        0x0080f2f8:    460a        .F      MOV      r2,r1
        0x0080f2fa:    4619        .F      MOV      r1,r3
        0x0080f2fc:    3020         0      ADDS     r0,r0,#0x20
        0x0080f2fe:    f44af5cc    J...    BL       __aeabi_memcpy ; 0x59e9a
        0x0080f302:    4620         F      MOV      r0,r4
        0x0080f304:    bd70        p.      POP      {r4-r6,pc}
;;;450            break;
;;;451    #endif
;;;452    
;;;453    #if DIS_CHAR_SERIAL_NUMBER_SUPPORT
;;;454        case DIS_PARAM_SERIAL_NUMBER:
;;;455            if (length > DIS_CHAR_SERIAL_NUMBER_STR_MAX_LENGTH)
        0x0080f306:    2914        .)      CMP      r1,#0x14
        0x0080f308:    d900        ..      BLS      0x80f30c ; dis_set_parameter + 88
;;;456            {
;;;457                length = DIS_CHAR_SERIAL_NUMBER_STR_MAX_LENGTH;
        0x0080f30a:    2114        .!      MOVS     r1,#0x14
;;;458            }
;;;459            dis_serial_number_len = length;
        0x0080f30c:    7091        .p      STRB     r1,[r2,#2]
;;;460            memcpy(dis_serial_number, p_value, length);
        0x0080f30e:    4885        .H      LDR      r0,[pc,#532] ; [0x80f524] = 0x208028
        0x0080f310:    460a        .F      MOV      r2,r1
        0x0080f312:    4619        .F      MOV      r1,r3
        0x0080f314:    3034        40      ADDS     r0,r0,#0x34
;;;461    
;;;462            break;
        0x0080f316:    e7f2        ..      B        0x80f2fe ; dis_set_parameter + 74
;;;463    #endif
;;;464    
;;;465    #if DIS_CHAR_HARDWARE_REVISION_SUPPORT
;;;466        case DIS_PARAM_HARDWARE_REVISION:
;;;467            if (length > DIS_CHAR_HARDWARE_REVISION_STR_MAX_LENGTH)
        0x0080f318:    2914        .)      CMP      r1,#0x14
        0x0080f31a:    d900        ..      BLS      0x80f31e ; dis_set_parameter + 106
;;;468            {
;;;469                length = DIS_CHAR_HARDWARE_REVISION_STR_MAX_LENGTH;
        0x0080f31c:    2114        .!      MOVS     r1,#0x14
;;;470            }
;;;471            dis_hardware_rev_len = length;
        0x0080f31e:    70d1        .p      STRB     r1,[r2,#3]
;;;472            memcpy(dis_hardware_rev, p_value, length);
        0x0080f320:    4880        .H      LDR      r0,[pc,#512] ; [0x80f524] = 0x208028
        0x0080f322:    460a        .F      MOV      r2,r1
        0x0080f324:    4619        .F      MOV      r1,r3
        0x0080f326:    3048        H0      ADDS     r0,r0,#0x48
;;;473            break;
        0x0080f328:    e7e9        ..      B        0x80f2fe ; dis_set_parameter + 74
;;;474    #endif
;;;475    
;;;476    #if DIS_CHAR_FIRMWARE_REVISION_SUPPORT
;;;477        case DIS_PARAM_FIRMWARE_REVISION:
;;;478            if (length > DIS_CHAR_FIRMWARE_REVISION_STR_MAX_LENGTH)
        0x0080f32a:    2914        .)      CMP      r1,#0x14
        0x0080f32c:    d900        ..      BLS      0x80f330 ; dis_set_parameter + 124
;;;479            {
;;;480                length = DIS_CHAR_FIRMWARE_REVISION_STR_MAX_LENGTH;
        0x0080f32e:    2114        .!      MOVS     r1,#0x14
;;;481            }
;;;482            dis_firmware_rev_len = length;
        0x0080f330:    7111        .q      STRB     r1,[r2,#4]
;;;483            memcpy(dis_firmware_rev, p_value, length);
        0x0080f332:    487c        |H      LDR      r0,[pc,#496] ; [0x80f524] = 0x208028
        0x0080f334:    460a        .F      MOV      r2,r1
        0x0080f336:    4619        .F      MOV      r1,r3
        0x0080f338:    305c        \0      ADDS     r0,r0,#0x5c
;;;484            break;
        0x0080f33a:    e7e0        ..      B        0x80f2fe ; dis_set_parameter + 74
;;;485    #endif
;;;486    
;;;487    #if DIS_CHAR_SOFTWARE_REVISION_SUPPORT
;;;488        case DIS_PARAM_SOFTWARE_REVISION:
;;;489            if (length > DIS_CHAR_SOFTWARE_REVISION_STR_MAX_LENGTH)
        0x0080f33c:    2914        .)      CMP      r1,#0x14
        0x0080f33e:    d900        ..      BLS      0x80f342 ; dis_set_parameter + 142
;;;490            {
;;;491                length = DIS_CHAR_SOFTWARE_REVISION_STR_MAX_LENGTH;
        0x0080f340:    2114        .!      MOVS     r1,#0x14
;;;492            }
;;;493            dis_software_rev_len = length;
        0x0080f342:    7151        Qq      STRB     r1,[r2,#5]
;;;494            memcpy(dis_software_rev, p_value, length);
        0x0080f344:    4877        wH      LDR      r0,[pc,#476] ; [0x80f524] = 0x208028
        0x0080f346:    460a        .F      MOV      r2,r1
        0x0080f348:    4619        .F      MOV      r1,r3
        0x0080f34a:    3070        p0      ADDS     r0,r0,#0x70
;;;495            break;
        0x0080f34c:    e7d7        ..      B        0x80f2fe ; dis_set_parameter + 74
;;;496    #endif
;;;497    
;;;498    #if DIS_CHAR_SYSTEM_ID_SUPPORT
;;;499        case DIS_PARAM_SYSTEM_ID:
;;;500            if (length > DIS_SYSTEM_ID_LENGTH)
        0x0080f34e:    2908        .)      CMP      r1,#8
        0x0080f350:    d900        ..      BLS      0x80f354 ; dis_set_parameter + 160
;;;501            {
;;;502                length = DIS_SYSTEM_ID_LENGTH;
        0x0080f352:    2108        .!      MOVS     r1,#8
;;;503            }
;;;504            memcpy(dis_system_id, p_value, length);
        0x0080f354:    460a        .F      MOV      r2,r1
        0x0080f356:    4619        .F      MOV      r1,r3
        0x0080f358:    4875        uH      LDR      r0,[pc,#468] ; [0x80f530] = 0x207e68
;;;505            break;
        0x0080f35a:    e7d0        ..      B        0x80f2fe ; dis_set_parameter + 74
;;;506    #endif
;;;507    
;;;508    #if DIS_CHAR_IEEE_CERTIF_DATA_LIST_SUPPORT
;;;509        case DIS_PARAM_IEEE_DATA_LIST:
;;;510            if (length > DIS_CHAR_IEEE_CERTIF_DATA_LIST_MAX_LENGTH)
        0x0080f35c:    291e        .)      CMP      r1,#0x1e
        0x0080f35e:    d900        ..      BLS      0x80f362 ; dis_set_parameter + 174
;;;511            {
;;;512                length = DIS_CHAR_IEEE_CERTIF_DATA_LIST_MAX_LENGTH;
        0x0080f360:    211e        .!      MOVS     r1,#0x1e
;;;513            }
;;;514            dis_ieee_data_list_len = length;
        0x0080f362:    4873        sH      LDR      r0,[pc,#460] ; [0x80f530] = 0x207e68
        0x0080f364:    460a        .F      MOV      r2,r1
        0x0080f366:    3808        .8      SUBS     r0,r0,#8
        0x0080f368:    7001        .p      STRB     r1,[r0,#0]
;;;515            memcpy(dis_ieee_data_list, p_value, length);
        0x0080f36a:    4619        .F      MOV      r1,r3
        0x0080f36c:    3010        .0      ADDS     r0,r0,#0x10
;;;516            break;
        0x0080f36e:    e7c6        ..      B        0x80f2fe ; dis_set_parameter + 74
;;;517    #endif
;;;518    
;;;519    #if DIS_CHAR_PNP_ID_SUPPORT
;;;520        case DIS_PARAM_PNP_ID:
;;;521            if (length > DIS_PNP_ID_LENGTH)
        0x0080f370:    2907        .)      CMP      r1,#7
        0x0080f372:    d900        ..      BLS      0x80f376 ; dis_set_parameter + 194
;;;522            {
;;;523                length = DIS_PNP_ID_LENGTH;
        0x0080f374:    2107        .!      MOVS     r1,#7
;;;524            }
;;;525            memcpy(dis_pnp_id, p_value, length);
        0x0080f376:    486e        nH      LDR      r0,[pc,#440] ; [0x80f530] = 0x207e68
        0x0080f378:    460a        .F      MOV      r2,r1
        0x0080f37a:    4619        .F      MOV      r1,r3
        0x0080f37c:    1fc0        ..      SUBS     r0,r0,#7
;;;526            break;
        0x0080f37e:    e7be        ..      B        0x80f2fe ; dis_set_parameter + 74
    dis_attr_read_cb
;;;527    #endif
;;;528        }
;;;529    
;;;530        if (!ret)
;;;531        {
;;;532            PROFILE_PRINT_ERROR0("DIS parameter set failed");
;;;533        }
;;;534    
;;;535        return ret;
;;;536    }
;;;537    
;;;538    /**
;;;539     * @brief Read characteristic data from service.
;;;540     *
;;;541     * @param[in]   conn_id  Connection id.
;;;542     * @param[in] service_id            ServiceID to be read.
;;;543     * @param[in] attrib_index          Attribute index of getting characteristic data.
;;;544     * @param[in] offset                offset of characteritic to be read.
;;;545     * @param[in,out] length_ptr            length of getting characteristic data.
;;;546     * @param[in,out] pp_value              pointer to pointer of characteristic value to be read.
;;;547     * @return T_APP_RESULT
;;;548    */
;;;549    T_APP_RESULT dis_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t attrib_index,
;;;550                                  uint16_t offset, uint16_t *length_ptr, uint8_t **pp_value)
;;;551    {
        0x0080f380:    e92d47fc    -..G    PUSH     {r2-r10,lr}
        0x0080f384:    4692        .F      MOV      r10,r2
        0x0080f386:    e9dd450a    ...E    LDRD     r4,r5,[sp,#0x28]
        0x0080f38a:    460a        .F      MOV      r2,r1
;;;552        T_DIS_CALLBACK_DATA callback_data;
;;;553        T_APP_RESULT  cause  = APP_RESULT_SUCCESS;
        0x0080f38c:    2600        .&      MOVS     r6,#0
;;;554        *length_ptr = 0;
        0x0080f38e:    8026        &.      STRH     r6,[r4,#0]
;;;555        callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0080f390:    2102        .!      MOVS     r1,#2
        0x0080f392:    f88d1004    ....    STRB     r1,[sp,#4]
;;;556        callback_data.conn_id = conn_id;
        0x0080f396:    f88d0005    ....    STRB     r0,[sp,#5]
;;;557    
;;;558        switch (attrib_index)
        0x0080f39a:    f1aa0002    ....    SUB      r0,r10,#2
        0x0080f39e:    2708        .'      MOVS     r7,#8
        0x0080f3a0:    f8df8180    ....    LDR      r8,[pc,#384] ; [0x80f524] = 0x208028
        0x0080f3a4:    f04f0907    O...    MOV      r9,#7
        0x0080f3a8:    2811        .(      CMP      r0,#0x11
        0x0080f3aa:    d20a        ..      BCS      0x80f3c2 ; dis_attr_read_cb + 66
        0x0080f3ac:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x0080f3b0:    098c091e    ....    DCD    160172318
        0x0080f3b4:    0949092c    ,.I.    DCD    155781420
        0x0080f3b8:    0957093b    ;.W.    DCD    156698939
        0x0080f3bc:    09650913    ..e.    DCD    157616403
        0x0080f3c0:    0072        r.      DCW    114
    $t
;;;559        {
;;;560        default:
;;;561            PROFILE_PRINT_ERROR1("dis_attr_read_cb: attrib_index %d", attrib_index);
        0x0080f3c2:    4959        YI      LDR      r1,[pc,#356] ; [0x80f528] = 0x8800478
        0x0080f3c4:    4653        SF      MOV      r3,r10
        0x0080f3c6:    2201        ."      MOVS     r2,#1
        0x0080f3c8:    311c        .1      ADDS     r1,r1,#0x1c
        0x0080f3ca:    4858        XH      LDR      r0,[pc,#352] ; [0x80f52c] = 0x21103300
        0x0080f3cc:    f7f8db47    ..G.    BL       log_buffer ; 0x7a5e
;;;562            cause = APP_RESULT_ATTR_NOT_FOUND;
        0x0080f3d0:    f240460a    @..F    MOV      r6,#0x40a
;;;563            break;
        0x0080f3d4:    e06b        k.      B        0x80f4ae ; dis_attr_read_cb + 302
;;;564    
;;;565    #if DIS_CHAR_SYSTEM_ID_SUPPORT
;;;566        case GATT_SVC_DIS_SYSTEM_ID_INDEX:
;;;567            callback_data.msg_data.read_value_index = DIS_READ_SYSTEM_ID_INDEX;
        0x0080f3d6:    f88d9006    ....    STRB     r9,[sp,#6]
;;;568            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080f3da:    4610        .F      MOV      r0,r2
        0x0080f3dc:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080f3e0:    a901        ..      ADD      r1,sp,#4
        0x0080f3e2:    4790        .G      BLX      r2
;;;569            *pp_value    = (uint8_t *)&dis_system_id;
        0x0080f3e4:    4852        RH      LDR      r0,[pc,#328] ; [0x80f530] = 0x207e68
;;;570            *length_ptr = sizeof(dis_system_id);
        0x0080f3e6:    6028        (`      STR      r0,[r5,#0]
        0x0080f3e8:    8027        '.      STRH     r7,[r4,#0]
;;;571            break;
        0x0080f3ea:    e060        `.      B        0x80f4ae ; dis_attr_read_cb + 302
;;;572    #endif
;;;573    
;;;574    #if DIS_CHAR_MANUFACTURER_NAME_SUPPORT
;;;575        case GATT_SVC_DIS_MANU_NAME_INDEX:
;;;576            callback_data.msg_data.read_value_index = DIS_READ_MANU_NAME_INDEX;
        0x0080f3ec:    2001        .       MOVS     r0,#1
        0x0080f3ee:    f88d0006    ....    STRB     r0,[sp,#6]
;;;577            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080f3f2:    4610        .F      MOV      r0,r2
        0x0080f3f4:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080f3f8:    a901        ..      ADD      r1,sp,#4
        0x0080f3fa:    4790        .G      BLX      r2
;;;578            *pp_value    = (uint8_t *)&dis_manufacturer_name;
        0x0080f3fc:    4849        IH      LDR      r0,[pc,#292] ; [0x80f524] = 0x208028
        0x0080f3fe:    300c        .0      ADDS     r0,r0,#0xc
;;;579            *length_ptr = dis_manufacturer_name_len;
        0x0080f400:    6028        (`      STR      r0,[r5,#0]
        0x0080f402:    f8980000    ....    LDRB     r0,[r8,#0]
;;;580            break;
        0x0080f406:    e00c        ..      B        0x80f422 ; dis_attr_read_cb + 162
;;;581    #endif
;;;582    
;;;583    #if DIS_CHAR_SERIAL_NUMBER_SUPPORT
;;;584        case GATT_SVC_DIS_SERIAL_NUM_INDEX:
;;;585            callback_data.msg_data.read_value_index = DIS_READ_SERIAL_NUM_INDEX;
        0x0080f408:    2003        .       MOVS     r0,#3
        0x0080f40a:    f88d0006    ....    STRB     r0,[sp,#6]
;;;586            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080f40e:    4610        .F      MOV      r0,r2
        0x0080f410:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080f414:    a901        ..      ADD      r1,sp,#4
        0x0080f416:    4790        .G      BLX      r2
;;;587            *pp_value    = (uint8_t *)&dis_serial_number;
        0x0080f418:    4842        BH      LDR      r0,[pc,#264] ; [0x80f524] = 0x208028
        0x0080f41a:    3034        40      ADDS     r0,r0,#0x34
;;;588            *length_ptr = dis_serial_number_len;
        0x0080f41c:    6028        (`      STR      r0,[r5,#0]
        0x0080f41e:    f8980002    ....    LDRB     r0,[r8,#2]
        0x0080f422:    8020         .      STRH     r0,[r4,#0]
        0x0080f424:    e043        C.      B        0x80f4ae ; dis_attr_read_cb + 302
;;;589            break;
;;;590    #endif
;;;591    
;;;592    #if DIS_CHAR_FIRMWARE_REVISION_SUPPORT
;;;593        case GATT_SVC_DIS_FIRMWARE_REV_INDEX:
;;;594            callback_data.msg_data.read_value_index = DIS_READ_FIRMWARE_REV_INDEX;
        0x0080f426:    2005        .       MOVS     r0,#5
        0x0080f428:    f88d0006    ....    STRB     r0,[sp,#6]
;;;595            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080f42c:    4610        .F      MOV      r0,r2
        0x0080f42e:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080f432:    a901        ..      ADD      r1,sp,#4
        0x0080f434:    4790        .G      BLX      r2
;;;596            *pp_value    = (uint8_t *)&dis_firmware_rev;
        0x0080f436:    483b        ;H      LDR      r0,[pc,#236] ; [0x80f524] = 0x208028
        0x0080f438:    305c        \0      ADDS     r0,r0,#0x5c
;;;597            *length_ptr = dis_firmware_rev_len;
        0x0080f43a:    6028        (`      STR      r0,[r5,#0]
        0x0080f43c:    f8980004    ....    LDRB     r0,[r8,#4]
;;;598            break;
        0x0080f440:    e7ef        ..      B        0x80f422 ; dis_attr_read_cb + 162
;;;599    #endif
;;;600    
;;;601    #if DIS_CHAR_HARDWARE_REVISION_SUPPORT
;;;602        case GATT_SVC_DIS_HARDWARE_REV_INDEX:
;;;603            callback_data.msg_data.read_value_index = DIS_READ_HARDWARE_REV_INDEX;
        0x0080f442:    2004        .       MOVS     r0,#4
        0x0080f444:    f88d0006    ....    STRB     r0,[sp,#6]
;;;604            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080f448:    4610        .F      MOV      r0,r2
        0x0080f44a:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080f44e:    a901        ..      ADD      r1,sp,#4
        0x0080f450:    4790        .G      BLX      r2
;;;605            *pp_value    = (uint8_t *)&dis_hardware_rev;
        0x0080f452:    4834        4H      LDR      r0,[pc,#208] ; [0x80f524] = 0x208028
        0x0080f454:    3048        H0      ADDS     r0,r0,#0x48
;;;606            *length_ptr = dis_hardware_rev_len;
        0x0080f456:    6028        (`      STR      r0,[r5,#0]
        0x0080f458:    f8980003    ....    LDRB     r0,[r8,#3]
;;;607            break;
        0x0080f45c:    e7e1        ..      B        0x80f422 ; dis_attr_read_cb + 162
;;;608    #endif
;;;609    
;;;610    #if DIS_CHAR_SOFTWARE_REVISION_SUPPORT
;;;611        case GATT_SVC_DIS_SOFTWARE_REV_INDEX:
;;;612            callback_data.msg_data.read_value_index = DIS_READ_SOFTWARE_REV_INDEX;
        0x0080f45e:    2006        .       MOVS     r0,#6
        0x0080f460:    f88d0006    ....    STRB     r0,[sp,#6]
;;;613            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080f464:    4610        .F      MOV      r0,r2
        0x0080f466:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080f46a:    a901        ..      ADD      r1,sp,#4
        0x0080f46c:    4790        .G      BLX      r2
;;;614            *pp_value    = (uint8_t *)&dis_software_rev;
        0x0080f46e:    482d        -H      LDR      r0,[pc,#180] ; [0x80f524] = 0x208028
        0x0080f470:    3070        p0      ADDS     r0,r0,#0x70
;;;615            *length_ptr = dis_software_rev_len;
        0x0080f472:    6028        (`      STR      r0,[r5,#0]
        0x0080f474:    f8980005    ....    LDRB     r0,[r8,#5]
;;;616            break;
        0x0080f478:    e7d3        ..      B        0x80f422 ; dis_attr_read_cb + 162
;;;617    #endif
;;;618    
;;;619    #if DIS_CHAR_IEEE_CERTIF_DATA_LIST_SUPPORT
;;;620        case GATT_SVC_DIS_IEEE_CERT_STR_INDEX:
;;;621            callback_data.msg_data.read_value_index = DIS_READ_IEEE_CERT_STR_INDEX;
        0x0080f47a:    f88d7006    ...p    STRB     r7,[sp,#6]
;;;622            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080f47e:    4610        .F      MOV      r0,r2
        0x0080f480:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080f484:    a901        ..      ADD      r1,sp,#4
        0x0080f486:    4790        .G      BLX      r2
;;;623            *pp_value    = (uint8_t *)&dis_ieee_data_list;
        0x0080f488:    4829        )H      LDR      r0,[pc,#164] ; [0x80f530] = 0x207e68
        0x0080f48a:    3008        .0      ADDS     r0,r0,#8
;;;624            *length_ptr = dis_ieee_data_list_len;
        0x0080f48c:    6028        (`      STR      r0,[r5,#0]
        0x0080f48e:    3810        .8      SUBS     r0,r0,#0x10
        0x0080f490:    7800        .x      LDRB     r0,[r0,#0]
;;;625            break;
        0x0080f492:    e7c6        ..      B        0x80f422 ; dis_attr_read_cb + 162
;;;626    #endif
;;;627    
;;;628    #if DIS_CHAR_PNP_ID_SUPPORT
;;;629        case GATT_SVC_DIS_PNP_ID_INDEX:
;;;630            callback_data.msg_data.read_value_index = DIS_READ_PNP_ID_INDEX;
        0x0080f494:    2009        .       MOVS     r0,#9
        0x0080f496:    f88d0006    ....    STRB     r0,[sp,#6]
;;;631            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080f49a:    4610        .F      MOV      r0,r2
        0x0080f49c:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080f4a0:    a901        ..      ADD      r1,sp,#4
        0x0080f4a2:    4790        .G      BLX      r2
;;;632            *pp_value    = (uint8_t *)&dis_pnp_id;
        0x0080f4a4:    4822        "H      LDR      r0,[pc,#136] ; [0x80f530] = 0x207e68
        0x0080f4a6:    1fc0        ..      SUBS     r0,r0,#7
;;;633            *length_ptr = sizeof(dis_pnp_id);
        0x0080f4a8:    6028        (`      STR      r0,[r5,#0]
        0x0080f4aa:    f8a49000    ....    STRH     r9,[r4,#0]
        0x0080f4ae:    8820         .      LDRH     r0,[r4,#0]
        0x0080f4b0:    9000        ..      STR      r0,[sp,#0]
        0x0080f4b2:    491d        .I      LDR      r1,[pc,#116] ; [0x80f528] = 0x8800478
        0x0080f4b4:    481d        .H      LDR      r0,[pc,#116] ; [0x80f52c] = 0x21103300
        0x0080f4b6:    4653        SF      MOV      r3,r10
        0x0080f4b8:    2202        ."      MOVS     r2,#2
        0x0080f4ba:    3144        D1      ADDS     r1,r1,#0x44
        0x0080f4bc:    1c80        ..      ADDS     r0,r0,#2
        0x0080f4be:    f7f8dace    ....    BL       log_buffer ; 0x7a5e
        0x0080f4c2:    4630        0F      MOV      r0,r6
        0x0080f4c4:    e8bd87fc    ....    POP      {r2-r10,pc}
;;;634            break;
;;;635    #endif
;;;636    
;;;637    #if DIS_CHAR_MODEL_NUMBER_SUPPORT
;;;638        case GATT_SVC_DIS_MODEL_NUM_INDEX:
;;;639            callback_data.msg_data.read_value_index = DIS_READ_MODEL_NUM_INDEX;
        0x0080f4c8:    f88d1006    ....    STRB     r1,[sp,#6]
;;;640            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080f4cc:    4610        .F      MOV      r0,r2
        0x0080f4ce:    f8d82008    ...     LDR      r2,[r8,#8]
        0x0080f4d2:    a901        ..      ADD      r1,sp,#4
        0x0080f4d4:    4790        .G      BLX      r2
;;;641            *pp_value    = (uint8_t *)&dis_model_number;
        0x0080f4d6:    4813        .H      LDR      r0,[pc,#76] ; [0x80f524] = 0x208028
        0x0080f4d8:    3020         0      ADDS     r0,r0,#0x20
;;;642            *length_ptr = dis_model_number_len;
        0x0080f4da:    6028        (`      STR      r0,[r5,#0]
        0x0080f4dc:    f8980001    ....    LDRB     r0,[r8,#1]
;;;643            break;
        0x0080f4e0:    e79f        ..      B        0x80f422 ; dis_attr_read_cb + 162
    dis_add_service
;;;644    #endif
;;;645    
;;;646        }
;;;647    
;;;648        PROFILE_PRINT_INFO2("dis_attr_read_cb: attrib_index %d, *length_ptr %d",
;;;649                            attrib_index,
;;;650                            *length_ptr);
;;;651        return (cause);
;;;652    }
;;;653    
;;;654    const T_FUN_GATT_SERVICE_CBS dis_cbs =
;;;655    {
;;;656        dis_attr_read_cb,  // Read callback function pointer
;;;657        NULL, // Write callback function pointer
;;;658        NULL  // Authorization callback function pointer
;;;659    };
;;;660    
;;;661    /**
;;;662      * @brief Add device information service to the BLE stack database.
;;;663      *
;;;664      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;665      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;666      * @retval 0xFF Operation failure.
;;;667      * @retval others Service id assigned by stack.
;;;668      *
;;;669      * <b>Example usage</b>
;;;670      * \code{.c}
;;;671        void profile_init()
;;;672        {
;;;673            server_init(1);
;;;674            dis_id = dis_add_service(app_handle_profile_message);
;;;675        }
;;;676      * \endcode
;;;677      */
;;;678    T_SERVER_ID dis_add_service(void *p_func)
;;;679    {
        0x0080f4e2:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080f4e4:    4604        .F      MOV      r4,r0
;;;680        T_SERVER_ID service_id;
;;;681        if (false == server_add_service(&service_id,
        0x0080f4e6:    4813        .H      LDR      r0,[pc,#76] ; [0x80f534] = 0x810e1c
        0x0080f4e8:    e9d01206    ....    LDRD     r1,r2,[r0,#0x18]
        0x0080f4ec:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x0080f4f0:    f5a07100    ...q    SUB      r1,r0,#0x200
        0x0080f4f4:    6943        Ci      LDR      r3,[r0,#0x14]
        0x0080f4f6:    f44f7205    O..r    MOV      r2,#0x214
        0x0080f4fa:    a802        ..      ADD      r0,sp,#8
        0x0080f4fc:    f440f0b7    @...    BL       server_add_service ; 0x4f66e
        0x0080f500:    b950        P.      CBNZ     r0,0x80f518 ; dis_add_service + 54
;;;682                                        (uint8_t *)dis_attr_tbl,
;;;683                                        dis_attr_tbl_size,
;;;684                                        dis_cbs))
;;;685        {
;;;686            PROFILE_PRINT_ERROR1("dis_add_service: service_id %d", service_id);
        0x0080f502:    4909        .I      LDR      r1,[pc,#36] ; [0x80f528] = 0x8800478
        0x0080f504:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080f508:    2201        ."      MOVS     r2,#1
        0x0080f50a:    317c        |1      ADDS     r1,r1,#0x7c
        0x0080f50c:    4807        .H      LDR      r0,[pc,#28] ; [0x80f52c] = 0x21103300
        0x0080f50e:    f7f8daa6    ....    BL       log_buffer ; 0x7a5e
;;;687            service_id = 0xff;
        0x0080f512:    20ff        .       MOVS     r0,#0xff
        0x0080f514:    f88d0008    ....    STRB     r0,[sp,#8]
;;;688        }
;;;689        pfn_dis_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x0080f518:    4802        .H      LDR      r0,[pc,#8] ; [0x80f524] = 0x208028
;;;690        return service_id;
        0x0080f51a:    6084        .`      STR      r4,[r0,#8]
        0x0080f51c:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;691    }
        0x0080f520:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080f522:    0000        ..      DCW    0
        0x0080f524:    00208028    (. .    DCD    2129960
        0x0080f528:    08800478    x...    DCD    142607480
        0x0080f52c:    21103300    .3.!    DCD    554709760
        0x0080f530:    00207e68    h~ .    DCD    2129512
        0x0080f534:    00810e1c    ....    DCD    8457756
    $t
    .text
    app_send_msg_to_apptask
;;; ..\include\SDK\src\app\pxp\app_task.c
;;;75     {
        0x0080f538:    b57c        |.      PUSH     {r2-r6,lr}
;;;76         uint8_t event = EVENT_IO_TO_APP;
        0x0080f53a:    2202        ."      MOVS     r2,#2
        0x0080f53c:    f88d2004    ...     STRB     r2,[sp,#4]
;;;77     
;;;78         if (os_msg_send(io_queue_handle, p_msg, 0) == false)
        0x0080f540:    224e        N"      MOVS     r2,#0x4e
        0x0080f542:    4c38        8L      LDR      r4,[pc,#224] ; [0x80f624] = 0x2080ac
        0x0080f544:    9200        ..      STR      r2,[sp,#0]
        0x0080f546:    4601        .F      MOV      r1,r0
        0x0080f548:    4b35        5K      LDR      r3,[pc,#212] ; [0x80f620] = 0x810e3c
        0x0080f54a:    2200        ."      MOVS     r2,#0
        0x0080f54c:    68a0        .h      LDR      r0,[r4,#8]
        0x0080f54e:    f416f549    ..I.    BL       os_msg_send_intern ; 0x25fe4
        0x0080f552:    4d35        5M      LDR      r5,[pc,#212] ; [0x80f628] = 0x21103000
        0x0080f554:    b150        P.      CBZ      r0,0x80f56c ; app_send_msg_to_apptask + 52
        0x0080f556:    2053        S       MOVS     r0,#0x53
        0x0080f558:    9000        ..      STR      r0,[sp,#0]
        0x0080f55a:    4b31        1K      LDR      r3,[pc,#196] ; [0x80f620] = 0x810e3c
        0x0080f55c:    2200        ."      MOVS     r2,#0
        0x0080f55e:    a901        ..      ADD      r1,sp,#4
        0x0080f560:    6860        `h      LDR      r0,[r4,#4]
        0x0080f562:    f416f53f    ..?.    BL       os_msg_send_intern ; 0x25fe4
        0x0080f566:    b120         .      CBZ      r0,0x80f572 ; app_send_msg_to_apptask + 58
        0x0080f568:    2001        .       MOVS     r0,#1
        0x0080f56a:    bd7c        |.      POP      {r2-r6,pc}
;;;79         {
;;;80             APP_PRINT_ERROR0("send_io_msg_to_app fail");
        0x0080f56c:    2200        ."      MOVS     r2,#0
        0x0080f56e:    492f        /I      LDR      r1,[pc,#188] ; [0x80f62c] = 0x8800518
;;;81             return false;
        0x0080f570:    e002        ..      B        0x80f578 ; app_send_msg_to_apptask + 64
;;;82         }
;;;83         if (os_msg_send(evt_queue_handle, &event, 0) == false)
;;;84         {
;;;85             APP_PRINT_ERROR0("send_evt_msg_to_app fail");
        0x0080f572:    492e        .I      LDR      r1,[pc,#184] ; [0x80f62c] = 0x8800518
        0x0080f574:    2200        ."      MOVS     r2,#0
        0x0080f576:    311c        .1      ADDS     r1,r1,#0x1c
        0x0080f578:    4628        (F      MOV      r0,r5
        0x0080f57a:    f7f8da70    ..p.    BL       log_buffer ; 0x7a5e
;;;86             return false;
        0x0080f57e:    2000        .       MOVS     r0,#0
;;;87         }
;;;88         return true;
;;;89     }
        0x0080f580:    bd7c        |.      POP      {r2-r6,pc}
    app_main_task
;;;90     /**
;;;91      * @brief  Initialize App task
;;;92      * @return void
;;;93      */
;;;94     void app_task_init()
;;;95     {
;;;96         os_task_create(&app_task_handle, "app", app_main_task, 0, APP_TASK_STACK_SIZE,
;;;97                        APP_TASK_PRIORITY);
;;;98     }
;;;99     
;;;100    /**
;;;101     * @brief        App task to handle events & messages
;;;102     * @param[in]    p_params    Parameters sending to the task
;;;103     * @return       void
;;;104     */
;;;105    void driver_init(void);
;;;106    void app_main_task(void *p_param)
;;;107    {
        0x0080f582:    b51f        ..      PUSH     {r0-r4,lr}
;;;108        uint8_t event;
;;;109    
;;;110        os_msg_queue_create(&io_queue_handle, MAX_NUMBER_OF_IO_MESSAGE, sizeof(T_IO_MSG));
        0x0080f584:    206e        n       MOVS     r0,#0x6e
        0x0080f586:    9000        ..      STR      r0,[sp,#0]
        0x0080f588:    4b25        %K      LDR      r3,[pc,#148] ; [0x80f620] = 0x810e3c
        0x0080f58a:    4826        &H      LDR      r0,[pc,#152] ; [0x80f624] = 0x2080ac
        0x0080f58c:    3318        .3      ADDS     r3,r3,#0x18
        0x0080f58e:    2208        ."      MOVS     r2,#8
        0x0080f590:    2120         !      MOVS     r1,#0x20
        0x0080f592:    3008        .0      ADDS     r0,r0,#8
        0x0080f594:    f416f4ae    ....    BL       os_msg_queue_create_intern ; 0x25ef4
;;;111        os_msg_queue_create(&evt_queue_handle, MAX_NUMBER_OF_EVENT_MESSAGE, sizeof(uint8_t));
        0x0080f598:    206f        o       MOVS     r0,#0x6f
        0x0080f59a:    9000        ..      STR      r0,[sp,#0]
        0x0080f59c:    4b20         K      LDR      r3,[pc,#128] ; [0x80f620] = 0x810e3c
        0x0080f59e:    4821        !H      LDR      r0,[pc,#132] ; [0x80f624] = 0x2080ac
        0x0080f5a0:    3318        .3      ADDS     r3,r3,#0x18
        0x0080f5a2:    2201        ."      MOVS     r2,#1
        0x0080f5a4:    2140        @!      MOVS     r1,#0x40
        0x0080f5a6:    1d00        ..      ADDS     r0,r0,#4
        0x0080f5a8:    f416f4a4    ....    BL       os_msg_queue_create_intern ; 0x25ef4
;;;112    
;;;113        gap_start_bt_stack(evt_queue_handle, io_queue_handle, MAX_NUMBER_OF_GAP_MESSAGE);
        0x0080f5ac:    4c1d        .L      LDR      r4,[pc,#116] ; [0x80f624] = 0x2080ac
        0x0080f5ae:    2220         "      MOVS     r2,#0x20
        0x0080f5b0:    e9d40101    ....    LDRD     r0,r1,[r4,#4]
        0x0080f5b4:    f43cf459    <.Y.    BL       gap_start_bt_stack ; 0x4be6a
;;;114    
;;;115    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;116        extern void reset_watch_dog_timer_enable(void);
;;;117        reset_watch_dog_timer_enable();
;;;118    #endif
;;;119    
;;;120        //data_uart_init(evt_queue_handle, io_queue_handle);
;;;121        //user_cmd_init(&user_cmd_if, "scatternet");
;;;122        driver_init();
        0x0080f5b8:    f000f86d    ..m.    BL       driver_init ; 0x80f696
;;;123        while (true)
;;;124        {
;;;125            if (os_msg_recv(evt_queue_handle, &event, 0xFFFFFFFF) == true)
        0x0080f5bc:    257d        }%      MOVS     r5,#0x7d
        0x0080f5be:    f04f37ff    O..7    MOV      r7,#0xffffffff
        0x0080f5c2:    2682        .&      MOVS     r6,#0x82
        0x0080f5c4:    4b16        .K      LDR      r3,[pc,#88] ; [0x80f620] = 0x810e3c
        0x0080f5c6:    9500        ..      STR      r5,[sp,#0]
        0x0080f5c8:    3318        .3      ADDS     r3,r3,#0x18
        0x0080f5ca:    463a        :F      MOV      r2,r7
        0x0080f5cc:    a903        ..      ADD      r1,sp,#0xc
        0x0080f5ce:    6860        `h      LDR      r0,[r4,#4]
        0x0080f5d0:    f416f538    ..8.    BL       os_msg_recv_intern ; 0x26044
        0x0080f5d4:    2800        .(      CMP      r0,#0
        0x0080f5d6:    d0f5        ..      BEQ      0x80f5c4 ; app_main_task + 66
;;;126            {
;;;127                if (event == EVENT_IO_TO_APP)
        0x0080f5d8:    f89d000c    ....    LDRB     r0,[sp,#0xc]
        0x0080f5dc:    2802        .(      CMP      r0,#2
        0x0080f5de:    d002        ..      BEQ      0x80f5e6 ; app_main_task + 100
        0x0080f5e0:    f43cf4b0    <...    BL       gap_handle_msg ; 0x4bf44
        0x0080f5e4:    e7ee        ..      B        0x80f5c4 ; app_main_task + 66
;;;128                {
;;;129                    T_IO_MSG io_msg;
;;;130                    if (os_msg_recv(io_queue_handle, &io_msg, 0) == true)
        0x0080f5e6:    4b0e        .K      LDR      r3,[pc,#56] ; [0x80f620] = 0x810e3c
        0x0080f5e8:    9600        ..      STR      r6,[sp,#0]
        0x0080f5ea:    3318        .3      ADDS     r3,r3,#0x18
        0x0080f5ec:    2200        ."      MOVS     r2,#0
        0x0080f5ee:    a901        ..      ADD      r1,sp,#4
        0x0080f5f0:    68a0        .h      LDR      r0,[r4,#8]
        0x0080f5f2:    f416f527    ..'.    BL       os_msg_recv_intern ; 0x26044
        0x0080f5f6:    2800        .(      CMP      r0,#0
        0x0080f5f8:    d0e4        ..      BEQ      0x80f5c4 ; app_main_task + 66
        0x0080f5fa:    e9dd0101    ....    LDRD     r0,r1,[sp,#4]
;;;131                    {
;;;132                        app_handle_io_msg(io_msg);
        0x0080f5fe:    f000fe41    ..A.    BL       app_handle_io_msg ; 0x810284
        0x0080f602:    e7df        ..      B        0x80f5c4 ; app_main_task + 66
    app_task_init
;;; ..\include\SDK\src\app\pxp\app_task.c (95)
        0x0080f604:    b51c        ..      PUSH     {r2-r4,lr}
;;;96         os_task_create(&app_task_handle, "app", app_main_task, 0, APP_TASK_STACK_SIZE,
        0x0080f606:    2101        .!      MOVS     r1,#1
        0x0080f608:    f44f60c0    O..`    MOV      r0,#0x600
        0x0080f60c:    2300        .#      MOVS     r3,#0
        0x0080f60e:    f2af028d    ....    ADR      r2,{pc}-0x8b ; 0x80f583
        0x0080f612:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0080f616:    a106        ..      ADR      r1,{pc}+0x1a ; 0x80f630
        0x0080f618:    4802        .H      LDR      r0,[pc,#8] ; [0x80f624] = 0x2080ac
        0x0080f61a:    f417f1d9    ....    BL       os_task_create ; 0x269d0
;;;97                        APP_TASK_PRIORITY);
;;;98     }
        0x0080f61e:    bd1c        ..      POP      {r2-r4,pc}
    $d
        0x0080f620:    00810e3c    <...    DCD    8457788
        0x0080f624:    002080ac    .. .    DCD    2130092
        0x0080f628:    21103000    .0.!    DCD    554708992
        0x0080f62c:    08800518    ....    DCD    142607640
        0x0080f630:    00707061    app.    DCD    7368801
    $t
    .text
    PINMUX_Configuration
;;; ..\include\SDK\src\app\pxp\iohandle.c
;;;32     {
        0x0080f634:    b510        ..      PUSH     {r4,lr}
;;;33         Pinmux_Config(LED, DWGPIO);
        0x0080f636:    215a        Z!      MOVS     r1,#0x5a
        0x0080f638:    2001        .       MOVS     r0,#1
        0x0080f63a:    f401f69b    ....    BL       Pinmux_Config ; 0x11374
;;;34         Pinmux_Config(BEEP, DWGPIO);
        0x0080f63e:    215a        Z!      MOVS     r1,#0x5a
        0x0080f640:    2002        .       MOVS     r0,#2
        0x0080f642:    f401f697    ....    BL       Pinmux_Config ; 0x11374
;;;35         Pinmux_Config(KEY, DWGPIO);
        0x0080f646:    215a        Z!      MOVS     r1,#0x5a
        0x0080f648:    e8bd4010    ...@    POP      {r4,lr}
        0x0080f64c:    2014        .       MOVS     r0,#0x14
        0x0080f64e:    f401b691    ....    B        Pinmux_Config ; 0x11374
    PAD_Configuration
;;;36     
;;;37         return;
;;;38     }
;;;39     /**
;;;40      * @brief    pad configuration
;;;41      * @return   void
;;;42      */
;;;43     void PAD_Configuration(void)
;;;44     {
        0x0080f652:    b57c        |.      PUSH     {r2-r6,lr}
;;;45         /* Keypad pad config */
;;;46         Pad_Config(LED, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0080f654:    2501        .%      MOVS     r5,#1
        0x0080f656:    2400        .$      MOVS     r4,#0
        0x0080f658:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0080f65c:    4623        #F      MOV      r3,r4
        0x0080f65e:    462a        *F      MOV      r2,r5
        0x0080f660:    4629        )F      MOV      r1,r5
        0x0080f662:    4628        (F      MOV      r0,r5
        0x0080f664:    f401f6ba    ....    BL       Pad_Config ; 0x113dc
;;;47         Pad_Config(BEEP, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0080f668:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0080f66c:    2201        ."      MOVS     r2,#1
        0x0080f66e:    2300        .#      MOVS     r3,#0
        0x0080f670:    4611        .F      MOV      r1,r2
        0x0080f672:    2002        .       MOVS     r0,#2
        0x0080f674:    f401f6b2    ....    BL       Pad_Config ; 0x113dc
;;;48         Pad_Config(KEY, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0080f678:    2301        .#      MOVS     r3,#1
        0x0080f67a:    9400        ..      STR      r4,[sp,#0]
        0x0080f67c:    461a        .F      MOV      r2,r3
        0x0080f67e:    4619        .F      MOV      r1,r3
        0x0080f680:    2014        .       MOVS     r0,#0x14
        0x0080f682:    9401        ..      STR      r4,[sp,#4]
        0x0080f684:    f401f6aa    ....    BL       Pad_Config ; 0x113dc
;;;49         return;
;;;50     }
        0x0080f688:    bd7c        |.      POP      {r2-r6,pc}
    RCC_Configuration
;;;51     /**
;;;52      * @brief    rcc configuration
;;;53      * @return   void
;;;54      */
;;;55     void RCC_Configuration(void)
;;;56     {
;;;57         RCC_PeriphClockCmd(APBPeriph_GPIO, APBPeriph_GPIO_CLOCK, ENABLE);
        0x0080f68a:    2201        ."      MOVS     r2,#1
        0x0080f68c:    f04f5104    O..Q    MOV      r1,#0x21000000
        0x0080f690:    48f7        .H      LDR      r0,[pc,#988] ; [0x80fa70] = 0xc000100
        0x0080f692:    f7ffb9a5    ....    B        RCC_PeriphClockCmd ; 0x80e9e0
    driver_init
;;;58         return;
;;;59     }
;;;60     
;;;61     /**
;;;62      * @brief    Contains the initialization of peripherals
;;;63      * @note     Both new architecture driver and legacy driver initialization method can be used
;;;64      * @return   void
;;;65      */
;;;66     void driver_init(void)
;;;67     {
        0x0080f696:    b530        0.      PUSH     {r4,r5,lr}
        0x0080f698:    b087        ..      SUB      sp,sp,#0x1c
;;;68         GPIO_InitTypeDef Gpio_Struct;
;;;69         GPIO_StructInit(&Gpio_Struct);
        0x0080f69a:    4668        hF      MOV      r0,sp
        0x0080f69c:    f7fff943    ..C.    BL       GPIO_StructInit ; 0x80e926
;;;70         Gpio_Struct.GPIO_Pin = GPIO_GetPin(LED) | GPIO_GetPin(BEEP);
        0x0080f6a0:    2001        .       MOVS     r0,#1
        0x0080f6a2:    f7fff962    ..b.    BL       GPIO_GetPin ; 0x80e96a
        0x0080f6a6:    4604        .F      MOV      r4,r0
        0x0080f6a8:    2002        .       MOVS     r0,#2
        0x0080f6aa:    f7fff95e    ..^.    BL       GPIO_GetPin ; 0x80e96a
        0x0080f6ae:    4304        .C      ORRS     r4,r4,r0
;;;71         Gpio_Struct.GPIO_Mode = GPIO_Mode_OUT;
        0x0080f6b0:    9400        ..      STR      r4,[sp,#0]
        0x0080f6b2:    2401        .$      MOVS     r4,#1
        0x0080f6b4:    f88d4004    ...@    STRB     r4,[sp,#4]
;;;72         GPIO_Init(&Gpio_Struct);
        0x0080f6b8:    4668        hF      MOV      r0,sp
        0x0080f6ba:    f7fff8d5    ....    BL       GPIO_Init ; 0x80e868
;;;73         GPIO_ResetBits(GPIO_GetPin(LED) | GPIO_GetPin(BEEP));
        0x0080f6be:    2001        .       MOVS     r0,#1
        0x0080f6c0:    f7fff953    ..S.    BL       GPIO_GetPin ; 0x80e96a
        0x0080f6c4:    4605        .F      MOV      r5,r0
        0x0080f6c6:    2002        .       MOVS     r0,#2
        0x0080f6c8:    f7fff94f    ..O.    BL       GPIO_GetPin ; 0x80e96a
        0x0080f6cc:    4328        (C      ORRS     r0,r0,r5
        0x0080f6ce:    f000fa1b    ....    BL       GPIO_ResetBits ; 0x80fb08
;;;74     
;;;75         Gpio_Struct.GPIO_Pin = GPIO_GetPin(KEY);
        0x0080f6d2:    2014        .       MOVS     r0,#0x14
        0x0080f6d4:    f7fff949    ..I.    BL       GPIO_GetPin ; 0x80e96a
;;;76         Gpio_Struct.GPIO_Mode = GPIO_Mode_IN;
        0x0080f6d8:    9000        ..      STR      r0,[sp,#0]
        0x0080f6da:    2000        .       MOVS     r0,#0
        0x0080f6dc:    f88d0004    ....    STRB     r0,[sp,#4]
;;;77         Gpio_Struct.GPIO_ITCmd = ENABLE;
        0x0080f6e0:    f88d4005    ...@    STRB     r4,[sp,#5]
;;;78         Gpio_Struct.GPIO_ITTrigger = GPIO_INT_Trigger_EDGE;
        0x0080f6e4:    f88d4006    ...@    STRB     r4,[sp,#6]
;;;79         Gpio_Struct.GPIO_ITPolarity = GPIO_INT_POLARITY_ACTIVE_LOW;
        0x0080f6e8:    f88d0007    ....    STRB     r0,[sp,#7]
        0x0080f6ec:    2014        .       MOVS     r0,#0x14
        0x0080f6ee:    9003        ..      STR      r0,[sp,#0xc]
;;;80         Gpio_Struct.GPIO_ITDebounce = GPIO_INT_DEBOUNCE_ENABLE;
        0x0080f6f0:    f88d4008    ...@    STRB     r4,[sp,#8]
;;;81         Gpio_Struct.GPIO_DebounceTime = 20;
;;;82         GPIO_Init(&Gpio_Struct);
        0x0080f6f4:    4668        hF      MOV      r0,sp
        0x0080f6f6:    f7fff8b7    ....    BL       GPIO_Init ; 0x80e868
;;;83     
;;;84         keystatus = GPIO_ReadInputDataBit(GPIO_GetPin(KEY));
        0x0080f6fa:    2014        .       MOVS     r0,#0x14
        0x0080f6fc:    f7fff935    ..5.    BL       GPIO_GetPin ; 0x80e96a
        0x0080f700:    f000f9ed    ....    BL       GPIO_ReadInputDataBit ; 0x80fade
        0x0080f704:    49db        .I      LDR      r1,[pc,#876] ; [0x80fa74] = 0x2080b8
        0x0080f706:    7088        .p      STRB     r0,[r1,#2]
;;;85         GPIO_MaskINTConfig(GPIO_GetPin(KEY), DISABLE);
        0x0080f708:    2014        .       MOVS     r0,#0x14
        0x0080f70a:    f7fff92e    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f70e:    2100        .!      MOVS     r1,#0
        0x0080f710:    f7fff922    ..".    BL       GPIO_MaskINTConfig ; 0x80e958
;;;86         GPIO_INTConfig(GPIO_GetPin(KEY), ENABLE);
        0x0080f714:    2014        .       MOVS     r0,#0x14
        0x0080f716:    f7fff928    ..(.    BL       GPIO_GetPin ; 0x80e96a
        0x0080f71a:    2101        .!      MOVS     r1,#1
        0x0080f71c:    f7fff910    ....    BL       GPIO_INTConfig ; 0x80e940
;;;87     
;;;88         NVIC_InitTypeDef NVIC_InitStruct;
;;;89         //NVIC_InitStruct.NVIC_IRQChannel = GPIO5_IRQn;
;;;90         NVIC_InitStruct.NVIC_IRQChannel = KEY_IRQ;//P2_4
        0x0080f720:    201e        .       MOVS     r0,#0x1e
        0x0080f722:    f88d0010    ....    STRB     r0,[sp,#0x10]
;;;91         NVIC_InitStruct.NVIC_IRQChannelPriority = 3;
        0x0080f726:    2003        .       MOVS     r0,#3
;;;92         NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
        0x0080f728:    9005        ..      STR      r0,[sp,#0x14]
        0x0080f72a:    f88d4018    ...@    STRB     r4,[sp,#0x18]
;;;93         NVIC_Init(&NVIC_InitStruct);
        0x0080f72e:    a804        ..      ADD      r0,sp,#0x10
        0x0080f730:    f401f5c6    ....    BL       NVIC_Init ; 0x112c0
;;;94     }
        0x0080f734:    b007        ..      ADD      sp,sp,#0x1c
        0x0080f736:    bd30        0.      POP      {r4,r5,pc}
    GPIO20_Handler
;;;95     
;;;96     typedef enum _KeyStatus
;;;97     {
;;;98         keyIdle = 0,
;;;99         keyShortPress,
;;;100        keyLongPress,
;;;101    } KeyStatus;
;;;102    KeyStatus gKeyStatus = keyIdle;
;;;103    
;;;104    
;;;105    //void GPIO_Group0_Handler(void)
;;;106    //{
;;;107    //     APP_PRINT_ERROR0("Enter GPIO_Group0_Handler!");
;;;108    //}
;;;109    /**
;;;110    * @brief    KEY_INT_Handle for key interrupt/GPIO20/P2_4
;;;111     * @note     Send short press event when read correct gpio bit port
;;;112     * @return   void
;;;113     */
;;;114    //void GPIO5_Handler(void)
;;;115    void KEY_INT_Handle(void)//P2_4
;;;116    {
        0x0080f738:    b57c        |.      PUSH     {r2-r6,lr}
;;;117    
;;;118        T_IO_MSG bee_io_msg;
;;;119        APP_PRINT_ERROR0("Enter GPIO5_Handler!");
        0x0080f73a:    2200        ."      MOVS     r2,#0
        0x0080f73c:    49ce        .I      LDR      r1,[pc,#824] ; [0x80fa78] = 0x8800550
        0x0080f73e:    48cf        .H      LDR      r0,[pc,#828] ; [0x80fa7c] = 0x21103000
        0x0080f740:    f7f8d98d    ....    BL       log_buffer ; 0x7a5e
;;;120        GPIO_MaskINTConfig(GPIO_GetPin(KEY), ENABLE);
        0x0080f744:    2014        .       MOVS     r0,#0x14
        0x0080f746:    f7fff910    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f74a:    2101        .!      MOVS     r1,#1
        0x0080f74c:    f7fff904    ....    BL       GPIO_MaskINTConfig ; 0x80e958
        0x0080f750:    2014        .       MOVS     r0,#0x14
        0x0080f752:    f7fff90a    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f756:    f000f9c2    ....    BL       GPIO_ReadInputDataBit ; 0x80fade
        0x0080f75a:    4cc6        .L      LDR      r4,[pc,#792] ; [0x80fa74] = 0x2080b8
        0x0080f75c:    4dc8        .M      LDR      r5,[pc,#800] ; [0x80fa80] = 0x40001000
        0x0080f75e:    2601        .&      MOVS     r6,#1
;;;121        keystatus = GPIO_ReadInputDataBit(GPIO_GetPin(KEY));
        0x0080f760:    70a0        .p      STRB     r0,[r4,#2]
;;;122    
;;;123        if (keystatus == 0)
        0x0080f762:    b148        H.      CBZ      r0,0x80f778 ; GPIO20_Handler + 64
        0x0080f764:    2014        .       MOVS     r0,#0x14
        0x0080f766:    f7fff900    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f76a:    6be9        .k      LDR      r1,[r5,#0x3c]
        0x0080f76c:    4381        .C      BICS     r1,r1,r0
        0x0080f76e:    63e9        .c      STR      r1,[r5,#0x3c]
        0x0080f770:    7860        `x      LDRB     r0,[r4,#1]
        0x0080f772:    2801        .(      CMP      r0,#1
        0x0080f774:    d00c        ..      BEQ      0x80f790 ; GPIO20_Handler + 88
        0x0080f776:    e017        ..      B        0x80f7a8 ; GPIO20_Handler + 112
;;;124        {
;;;125            gKeyStatus = keyShortPress;
        0x0080f778:    7066        fp      STRB     r6,[r4,#1]
;;;126            GPIO->INTPOLARITY |= GPIO_GetPin(KEY);
        0x0080f77a:    2014        .       MOVS     r0,#0x14
        0x0080f77c:    f7fff8f5    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f780:    6be9        .k      LDR      r1,[r5,#0x3c]
        0x0080f782:    4308        .C      ORRS     r0,r0,r1
        0x0080f784:    63e8        .c      STR      r0,[r5,#0x3c]
;;;127            os_timer_start(&xTimerLongPress);
        0x0080f786:    48bb        .H      LDR      r0,[pc,#748] ; [0x80fa74] = 0x2080b8
        0x0080f788:    3014        .0      ADDS     r0,r0,#0x14
        0x0080f78a:    f417f247    ..G.    BL       os_timer_start ; 0x26c1c
        0x0080f78e:    e00d        ..      B        0x80f7ac ; GPIO20_Handler + 116
;;;128        }
;;;129        else
;;;130        {
;;;131            GPIO->INTPOLARITY &= ~GPIO_GetPin(KEY);
;;;132            if (gKeyStatus == keyShortPress)
;;;133            {
;;;134                os_timer_stop(&xTimerLongPress);
        0x0080f790:    48b8        .H      LDR      r0,[pc,#736] ; [0x80fa74] = 0x2080b8
        0x0080f792:    3014        .0      ADDS     r0,r0,#0x14
        0x0080f794:    f417f266    ..f.    BL       os_timer_stop ; 0x26c64
;;;135                bee_io_msg.type = IO_MSG_TYPE_GPIO;
        0x0080f798:    200b        .       MOVS     r0,#0xb
        0x0080f79a:    f8ad0000    ....    STRH     r0,[sp,#0]
;;;136                bee_io_msg.subtype = MSG_SHORT_PRESS;
        0x0080f79e:    f8ad6002    ...`    STRH     r6,[sp,#2]
;;;137                app_send_msg_to_apptask(&bee_io_msg);
        0x0080f7a2:    4668        hF      MOV      r0,sp
        0x0080f7a4:    f7fffec8    ....    BL       app_send_msg_to_apptask ; 0x80f538
;;;138            }
;;;139            gKeyStatus = keyIdle;
        0x0080f7a8:    2000        .       MOVS     r0,#0
        0x0080f7aa:    7060        `p      STRB     r0,[r4,#1]
;;;140        }
;;;141        GPIO_ClearINTPendingBit(GPIO_GetPin(KEY));
        0x0080f7ac:    2014        .       MOVS     r0,#0x14
        0x0080f7ae:    f7fff8dc    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f7b2:    f7fff8ce    ....    BL       GPIO_ClearINTPendingBit ; 0x80e952
;;;142        GPIO_MaskINTConfig(GPIO_GetPin(KEY), DISABLE);
        0x0080f7b6:    2014        .       MOVS     r0,#0x14
        0x0080f7b8:    f7fff8d7    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f7bc:    2100        .!      MOVS     r1,#0
        0x0080f7be:    f7fff8cb    ....    BL       GPIO_MaskINTConfig ; 0x80e958
;;;143    }
        0x0080f7c2:    bd7c        |.      POP      {r2-r6,pc}
    StopPxpIO
;;;144    
;;;145    /**
;;;146     * @brief    Pxp_HandleButtonEvent for key io event
;;;147     * @note     Event for Gpio interrupt and long press timer.
;;;148     * @param[in] io_msg
;;;149     * @return   void
;;;150     */
;;;151    void Pxp_HandleButtonEvent(T_IO_MSG io_msg)
;;;152    {
;;;153        uint8_t value_to_send;
;;;154        uint8_t keytype = io_msg.subtype ;
;;;155        if (keytype == MSG_SHORT_PRESS)
;;;156        {
;;;157            APP_PRINT_ERROR0("MSG_SHORT_PRESS");
;;;158            switch (gPxpState)
;;;159            {
;;;160            case PxpStateIdle:
;;;161                if (gIoState == IoStateIdle)
;;;162                {
;;;163                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK,
;;;164                               1); /*low period 0.9s, high period 0.1s,  led blink,  1times(cnt)*/
;;;165                }
;;;166                break;
;;;167            case PxpStateAdv:
;;;168                if (gIoState == IoStateLlsAlert)
;;;169                {
;;;170                    gActCnt = 0;
;;;171                    allowedPxpEnterDlps = true;
;;;172                    os_timer_stop(&xTimerPxpIO);
;;;173                    gIoState = IoStateIdle;
;;;174                }
;;;175                break;
;;;176            case PxpStateLink:
;;;177                if (gIoState == IoStateImmAlert)
;;;178                {
;;;179                    gActCnt = 0;
;;;180                    allowedPxpEnterDlps = true;
;;;181                    os_timer_stop(&xTimerPxpIO);
;;;182                    gIoState = IoStateIdle;
;;;183                }
;;;184                else if (gIoState == IoStateIdle)
;;;185                {
;;;186                    value_to_send = 1;
;;;187                    server_send_data(0, kns_srv_id, KNS_KEY_VALUE_INDEX, \
;;;188                                     &value_to_send, sizeof(uint8_t), GATT_PDU_TYPE_NOTIFICATION);
;;;189                }
;;;190                else
;;;191                {
;;;192                    APP_PRINT_ERROR0("ERROR IO STATUS");//error status
;;;193                }
;;;194                break;
;;;195            default:
;;;196                break;
;;;197            }
;;;198        }
;;;199        else if (keytype == MSG_LONG_PRESS)
;;;200        {
;;;201            APP_PRINT_ERROR0("MSG_LONG_PRESS");
;;;202            switch (gPxpState)
;;;203            {
;;;204            case PxpStateIdle:
;;;205                if (gPowerFlg == false)
;;;206                {
;;;207                    gPowerFlg = true;
;;;208                    le_adv_start();
;;;209                }
;;;210                else
;;;211                {
;;;212                    APP_PRINT_ERROR0("ERROR POWER STATUS");//error status
;;;213                }
;;;214                break;
;;;215            case PxpStateAdv:
;;;216                if (gPowerFlg == true)
;;;217                {
;;;218                    gPowerFlg = false;
;;;219                    if (gIoState != IoStateIdle)
;;;220                    {
;;;221                        gIoState = IoStateIdle;
;;;222                        StopPxpIO();
;;;223                    }
;;;224                    le_adv_stop();
;;;225                }
;;;226                else
;;;227                {
;;;228                    APP_PRINT_ERROR0("ERROR POWER STATUS");//error status
;;;229                }
;;;230                break;
;;;231            case PxpStateLink:
;;;232                if (gPowerFlg == true)
;;;233                {
;;;234                    gPowerFlg = false;
;;;235                    if (gIoState != IoStateIdle)
;;;236                    {
;;;237                        gIoState = IoStateIdle;
;;;238                        StopPxpIO();
;;;239                    }
;;;240                    le_disconnect(0);
;;;241                }
;;;242                else
;;;243                {
;;;244                    APP_PRINT_ERROR0("ERROR POWER STATUS");//error status
;;;245                }
;;;246                break;
;;;247            default:
;;;248                break;
;;;249            }
;;;250        }
;;;251        else
;;;252        {
;;;253            //nothing to do
;;;254        }
;;;255    }
;;;256    
;;;257    /**
;;;258     * @brief    StartPxpIO for led blink and beep
;;;259     * @note     Set parameter and start swtimer xTimerPxpIO
;;;260     * @param[in] lowPeroid
;;;261     * @param[in] HighPeroid
;;;262     * @param[in] mode
;;;263     * @param[in] cnt
;;;264     * @return   void
;;;265     */
;;;266    void StartPxpIO(uint32_t lowPeroid, uint32_t HighPeroid, uint8_t mode, uint32_t cnt)
;;;267    {
;;;268        xPeriodLow = lowPeroid;
;;;269        xPeriodHigh = HighPeroid;
;;;270        gIoMode = mode;
;;;271        gActCnt = cnt;
;;;272        if (gIoMode)
;;;273        {
;;;274            if (gIoMode & 0x1)
;;;275            {
;;;276                GPIO_SetBits(GPIO_GetPin(LED));
;;;277            }
;;;278            if (gIoMode & 0x2)
;;;279            {
;;;280                GPIO_SetBits(GPIO_GetPin(BEEP));
;;;281            }
;;;282            allowedPxpEnterDlps = false;
;;;283            os_timer_restart(&xTimerPxpIO, HighPeroid);
;;;284        }
;;;285    }
;;;286    /**
;;;287     * @brief    StopPxpIO
;;;288     * @note     Stop pxp io action
;;;289     * @return   void
;;;290     */
;;;291    void StopPxpIO()
;;;292    {
;;;293        allowedPxpEnterDlps = true;
        0x0080f7c4:    49af        .I      LDR      r1,[pc,#700] ; [0x80fa84] = 0x207e8e
;;; ..\include\SDK\src\app\pxp\iohandle.c (292)
        0x0080f7c6:    b510        ..      PUSH     {r4,lr}
;;;293        allowedPxpEnterDlps = true;
        0x0080f7c8:    2001        .       MOVS     r0,#1
        0x0080f7ca:    7008        .p      STRB     r0,[r1,#0]
;;;294        gActCnt = 0;
        0x0080f7cc:    49a9        .I      LDR      r1,[pc,#676] ; [0x80fa74] = 0x2080b8
        0x0080f7ce:    2000        .       MOVS     r0,#0
;;;295        GPIO_ResetBits(GPIO_GetPin(LED));
        0x0080f7d0:    60c8        .`      STR      r0,[r1,#0xc]
        0x0080f7d2:    2001        .       MOVS     r0,#1
        0x0080f7d4:    f7fff8c9    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f7d8:    f000f996    ....    BL       GPIO_ResetBits ; 0x80fb08
;;;296        GPIO_ResetBits(GPIO_GetPin(BEEP));
        0x0080f7dc:    2002        .       MOVS     r0,#2
        0x0080f7de:    f7fff8c4    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f7e2:    f000f991    ....    BL       GPIO_ResetBits ; 0x80fb08
;;;297        os_timer_stop(&xTimerPxpIO);
        0x0080f7e6:    48a3        .H      LDR      r0,[pc,#652] ; [0x80fa74] = 0x2080b8
        0x0080f7e8:    e8bd4010    ...@    POP      {r4,lr}
        0x0080f7ec:    3010        .0      ADDS     r0,r0,#0x10
        0x0080f7ee:    f417b239    ..9.    B        os_timer_stop ; 0x26c64
    StartPxpIO
        0x0080f7f2:    b570        p.      PUSH     {r4-r6,lr}
        0x0080f7f4:    4c9f        .L      LDR      r4,[pc,#636] ; [0x80fa74] = 0x2080b8
;;; ..\include\SDK\src\app\pxp\iohandle.c (267)
        0x0080f7f6:    460d        .F      MOV      r5,r1
        0x0080f7f8:    2a00        .*      CMP      r2,#0
        0x0080f7fa:    e9c40101    ....    STRD     r0,r1,[r4,#4]
        0x0080f7fe:    7022        "p      STRB     r2,[r4,#0]
        0x0080f800:    60e3        .`      STR      r3,[r4,#0xc]
        0x0080f802:    d018        ..      BEQ      0x80f836 ; StartPxpIO + 68
;;;268        xPeriodLow = lowPeroid;
;;;269        xPeriodHigh = HighPeroid;
;;;270        gIoMode = mode;
;;;271        gActCnt = cnt;
;;;272        if (gIoMode)
;;;273        {
;;;274            if (gIoMode & 0x1)
        0x0080f804:    07d0        ..      LSLS     r0,r2,#31
        0x0080f806:    d004        ..      BEQ      0x80f812 ; StartPxpIO + 32
;;;275            {
;;;276                GPIO_SetBits(GPIO_GetPin(LED));
        0x0080f808:    2001        .       MOVS     r0,#1
        0x0080f80a:    f7fff8ae    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f80e:    f000f976    ..v.    BL       GPIO_SetBits ; 0x80fafe
;;;277            }
;;;278            if (gIoMode & 0x2)
        0x0080f812:    7820         x      LDRB     r0,[r4,#0]
        0x0080f814:    0780        ..      LSLS     r0,r0,#30
        0x0080f816:    d504        ..      BPL      0x80f822 ; StartPxpIO + 48
;;;279            {
;;;280                GPIO_SetBits(GPIO_GetPin(BEEP));
        0x0080f818:    2002        .       MOVS     r0,#2
        0x0080f81a:    f7fff8a6    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f81e:    f000f96e    ..n.    BL       GPIO_SetBits ; 0x80fafe
;;;281            }
;;;282            allowedPxpEnterDlps = false;
        0x0080f822:    4998        .I      LDR      r1,[pc,#608] ; [0x80fa84] = 0x207e8e
        0x0080f824:    2000        .       MOVS     r0,#0
        0x0080f826:    7008        .p      STRB     r0,[r1,#0]
;;;283            os_timer_restart(&xTimerPxpIO, HighPeroid);
        0x0080f828:    4629        )F      MOV      r1,r5
        0x0080f82a:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0080f82e:    4891        .H      LDR      r0,[pc,#580] ; [0x80fa74] = 0x2080b8
        0x0080f830:    3010        .0      ADDS     r0,r0,#0x10
        0x0080f832:    f417b204    ....    B        os_timer_restart ; 0x26c3e
;;;284        }
;;;285    }
        0x0080f836:    bd70        p.      POP      {r4-r6,pc}
    Pxp_HandleButtonEvent
;;; ..\include\SDK\src\app\pxp\iohandle.c (152)
        0x0080f838:    e92d43fe    -..C    PUSH     {r1-r9,lr}
;;;153        uint8_t value_to_send;
;;;154        uint8_t keytype = io_msg.subtype ;
        0x0080f83c:    f3c04007    ...@    UBFX     r0,r0,#16,#8
        0x0080f840:    2601        .&      MOVS     r6,#1
        0x0080f842:    4f91        .O      LDR      r7,[pc,#580] ; [0x80fa88] = 0x2080d0
        0x0080f844:    4b8d        .K      LDR      r3,[pc,#564] ; [0x80fa7c] = 0x21103000
        0x0080f846:    2500        .%      MOVS     r5,#0
        0x0080f848:    4c90        .L      LDR      r4,[pc,#576] ; [0x80fa8c] = 0x2080d1
;;;155        if (keytype == MSG_SHORT_PRESS)
        0x0080f84a:    2801        .(      CMP      r0,#1
        0x0080f84c:    d01d        ..      BEQ      0x80f88a ; Pxp_HandleButtonEvent + 82
        0x0080f84e:    2803        .(      CMP      r0,#3
        0x0080f850:    d119        ..      BNE      0x80f886 ; Pxp_HandleButtonEvent + 78
        0x0080f852:    4989        .I      LDR      r1,[pc,#548] ; [0x80fa78] = 0x8800550
        0x0080f854:    2200        ."      MOVS     r2,#0
        0x0080f856:    3140        @1      ADDS     r1,r1,#0x40
        0x0080f858:    4698        .F      MOV      r8,r3
        0x0080f85a:    4618        .F      MOV      r0,r3
        0x0080f85c:    f7f8d8ff    ....    BL       log_buffer ; 0x7a5e
        0x0080f860:    7838        8x      LDRB     r0,[r7,#0]
        0x0080f862:    498b        .I      LDR      r1,[pc,#556] ; [0x80fa90] = 0x2080d2
        0x0080f864:    b398        ..      CBZ      r0,0x80f8ce ; Pxp_HandleButtonEvent + 150
        0x0080f866:    2801        .(      CMP      r0,#1
        0x0080f868:    d053        S.      BEQ      0x80f912 ; Pxp_HandleButtonEvent + 218
        0x0080f86a:    2802        .(      CMP      r0,#2
        0x0080f86c:    d10b        ..      BNE      0x80f886 ; Pxp_HandleButtonEvent + 78
        0x0080f86e:    7808        .x      LDRB     r0,[r1,#0]
        0x0080f870:    2800        .(      CMP      r0,#0
        0x0080f872:    d05d        ].      BEQ      0x80f930 ; Pxp_HandleButtonEvent + 248
        0x0080f874:    700d        .p      STRB     r5,[r1,#0]
        0x0080f876:    7820         x      LDRB     r0,[r4,#0]
        0x0080f878:    b110        ..      CBZ      r0,0x80f880 ; Pxp_HandleButtonEvent + 72
        0x0080f87a:    7025        %p      STRB     r5,[r4,#0]
        0x0080f87c:    f7ffffa2    ....    BL       StopPxpIO ; 0x80f7c4
        0x0080f880:    2000        .       MOVS     r0,#0
        0x0080f882:    f43ef1cf    >...    BL       le_disconnect ; 0x4dc24
        0x0080f886:    e8bd83fe    ....    POP      {r1-r9,pc}
;;;156        {
;;;157            APP_PRINT_ERROR0("MSG_SHORT_PRESS");
        0x0080f88a:    497b        {I      LDR      r1,[pc,#492] ; [0x80fa78] = 0x8800550
        0x0080f88c:    2200        ."      MOVS     r2,#0
        0x0080f88e:    3118        .1      ADDS     r1,r1,#0x18
        0x0080f890:    4698        .F      MOV      r8,r3
        0x0080f892:    4618        .F      MOV      r0,r3
        0x0080f894:    f7f8d8e3    ....    BL       log_buffer ; 0x7a5e
;;;158            switch (gPxpState)
        0x0080f898:    7838        8x      LDRB     r0,[r7,#0]
        0x0080f89a:    b168        h.      CBZ      r0,0x80f8b8 ; Pxp_HandleButtonEvent + 128
        0x0080f89c:    4975        uI      LDR      r1,[pc,#468] ; [0x80fa74] = 0x2080b8
        0x0080f89e:    4a79        yJ      LDR      r2,[pc,#484] ; [0x80fa84] = 0x207e8e
        0x0080f8a0:    2801        .(      CMP      r0,#1
        0x0080f8a2:    d015        ..      BEQ      0x80f8d0 ; Pxp_HandleButtonEvent + 152
        0x0080f8a4:    2802        .(      CMP      r0,#2
        0x0080f8a6:    d1ee        ..      BNE      0x80f886 ; Pxp_HandleButtonEvent + 78
        0x0080f8a8:    7820         x      LDRB     r0,[r4,#0]
        0x0080f8aa:    2802        .(      CMP      r0,#2
        0x0080f8ac:    d013        ..      BEQ      0x80f8d6 ; Pxp_HandleButtonEvent + 158
        0x0080f8ae:    b1d0        ..      CBZ      r0,0x80f8e6 ; Pxp_HandleButtonEvent + 174
        0x0080f8b0:    4971        qI      LDR      r1,[pc,#452] ; [0x80fa78] = 0x8800550
        0x0080f8b2:    2200        ."      MOVS     r2,#0
        0x0080f8b4:    312c        ,1      ADDS     r1,r1,#0x2c
        0x0080f8b6:    e03e        >.      B        0x80f936 ; Pxp_HandleButtonEvent + 254
;;;159            {
;;;160            case PxpStateIdle:
;;;161                if (gIoState == IoStateIdle)
        0x0080f8b8:    7820         x      LDRB     r0,[r4,#0]
        0x0080f8ba:    2800        .(      CMP      r0,#0
        0x0080f8bc:    d1e3        ..      BNE      0x80f886 ; Pxp_HandleButtonEvent + 78
;;;162                {
;;;163                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK,
        0x0080f8be:    2301        .#      MOVS     r3,#1
        0x0080f8c0:    461a        .F      MOV      r2,r3
        0x0080f8c2:    2164        d!      MOVS     r1,#0x64
        0x0080f8c4:    f44f7061    O.ap    MOV      r0,#0x384
        0x0080f8c8:    f7ffff93    ....    BL       StartPxpIO ; 0x80f7f2
        0x0080f8cc:    e7db        ..      B        0x80f886 ; Pxp_HandleButtonEvent + 78
        0x0080f8ce:    e016        ..      B        0x80f8fe ; Pxp_HandleButtonEvent + 198
;;;164                               1); /*low period 0.9s, high period 0.1s,  led blink,  1times(cnt)*/
;;;165                }
;;;166                break;
;;;167            case PxpStateAdv:
;;;168                if (gIoState == IoStateLlsAlert)
        0x0080f8d0:    7820         x      LDRB     r0,[r4,#0]
        0x0080f8d2:    2803        .(      CMP      r0,#3
        0x0080f8d4:    d1d7        ..      BNE      0x80f886 ; Pxp_HandleButtonEvent + 78
        0x0080f8d6:    4867        gH      LDR      r0,[pc,#412] ; [0x80fa74] = 0x2080b8
;;;169                {
;;;170                    gActCnt = 0;
;;;171                    allowedPxpEnterDlps = true;
;;;172                    os_timer_stop(&xTimerPxpIO);
;;;173                    gIoState = IoStateIdle;
;;;174                }
;;;175                break;
;;;176            case PxpStateLink:
;;;177                if (gIoState == IoStateImmAlert)
;;;178                {
;;;179                    gActCnt = 0;
;;;180                    allowedPxpEnterDlps = true;
        0x0080f8d8:    60cd        .`      STR      r5,[r1,#0xc]
        0x0080f8da:    7016        .p      STRB     r6,[r2,#0]
;;;181                    os_timer_stop(&xTimerPxpIO);
        0x0080f8dc:    3010        .0      ADDS     r0,r0,#0x10
        0x0080f8de:    f417f1c1    ....    BL       os_timer_stop ; 0x26c64
;;;182                    gIoState = IoStateIdle;
        0x0080f8e2:    7025        %p      STRB     r5,[r4,#0]
        0x0080f8e4:    e7cf        ..      B        0x80f886 ; Pxp_HandleButtonEvent + 78
        0x0080f8e6:    486b        kH      LDR      r0,[pc,#428] ; [0x80fa94] = 0x2080d8
;;;183                }
;;;184                else if (gIoState == IoStateIdle)
;;;185                {
;;;186                    value_to_send = 1;
        0x0080f8e8:    f88d6008    ...`    STRB     r6,[sp,#8]
;;;187                    server_send_data(0, kns_srv_id, KNS_KEY_VALUE_INDEX, \
        0x0080f8ec:    9600        ..      STR      r6,[sp,#0]
        0x0080f8ee:    9601        ..      STR      r6,[sp,#4]
        0x0080f8f0:    7801        .x      LDRB     r1,[r0,#0]
        0x0080f8f2:    ab02        ..      ADD      r3,sp,#8
        0x0080f8f4:    2204        ."      MOVS     r2,#4
        0x0080f8f6:    2000        .       MOVS     r0,#0
        0x0080f8f8:    f43ff754    ?.T.    BL       server_send_data ; 0x4f7a4
        0x0080f8fc:    e7c3        ..      B        0x80f886 ; Pxp_HandleButtonEvent + 78
;;;188                                     &value_to_send, sizeof(uint8_t), GATT_PDU_TYPE_NOTIFICATION);
;;;189                }
;;;190                else
;;;191                {
;;;192                    APP_PRINT_ERROR0("ERROR IO STATUS");//error status
;;;193                }
;;;194                break;
;;;195            default:
;;;196                break;
;;;197            }
;;;198        }
;;;199        else if (keytype == MSG_LONG_PRESS)
;;;200        {
;;;201            APP_PRINT_ERROR0("MSG_LONG_PRESS");
;;;202            switch (gPxpState)
;;;203            {
;;;204            case PxpStateIdle:
;;;205                if (gPowerFlg == false)
        0x0080f8fe:    7808        .x      LDRB     r0,[r1,#0]
        0x0080f900:    b118        ..      CBZ      r0,0x80f90a ; Pxp_HandleButtonEvent + 210
        0x0080f902:    495d        ]I      LDR      r1,[pc,#372] ; [0x80fa78] = 0x8800550
        0x0080f904:    2200        ."      MOVS     r2,#0
        0x0080f906:    3154        T1      ADDS     r1,r1,#0x54
        0x0080f908:    e015        ..      B        0x80f936 ; Pxp_HandleButtonEvent + 254
;;;206                {
;;;207                    gPowerFlg = true;
        0x0080f90a:    700e        .p      STRB     r6,[r1,#0]
;;;208                    le_adv_start();
        0x0080f90c:    f442f3db    B...    BL       le_adv_start ; 0x520c6
        0x0080f910:    e7b9        ..      B        0x80f886 ; Pxp_HandleButtonEvent + 78
;;;209                }
;;;210                else
;;;211                {
;;;212                    APP_PRINT_ERROR0("ERROR POWER STATUS");//error status
;;;213                }
;;;214                break;
;;;215            case PxpStateAdv:
;;;216                if (gPowerFlg == true)
        0x0080f912:    7808        .x      LDRB     r0,[r1,#0]
        0x0080f914:    b140        @.      CBZ      r0,0x80f928 ; Pxp_HandleButtonEvent + 240
;;;217                {
;;;218                    gPowerFlg = false;
        0x0080f916:    700d        .p      STRB     r5,[r1,#0]
;;;219                    if (gIoState != IoStateIdle)
        0x0080f918:    7820         x      LDRB     r0,[r4,#0]
        0x0080f91a:    b110        ..      CBZ      r0,0x80f922 ; Pxp_HandleButtonEvent + 234
;;;220                    {
;;;221                        gIoState = IoStateIdle;
        0x0080f91c:    7025        %p      STRB     r5,[r4,#0]
;;;222                        StopPxpIO();
        0x0080f91e:    f7ffff51    ..Q.    BL       StopPxpIO ; 0x80f7c4
;;;223                    }
;;;224                    le_adv_stop();
        0x0080f922:    f442f432    B.2.    BL       le_adv_stop ; 0x5218a
        0x0080f926:    e7ae        ..      B        0x80f886 ; Pxp_HandleButtonEvent + 78
;;;225                }
;;;226                else
;;;227                {
;;;228                    APP_PRINT_ERROR0("ERROR POWER STATUS");//error status
        0x0080f928:    4953        SI      LDR      r1,[pc,#332] ; [0x80fa78] = 0x8800550
        0x0080f92a:    2200        ."      MOVS     r2,#0
        0x0080f92c:    316c        l1      ADDS     r1,r1,#0x6c
        0x0080f92e:    e002        ..      B        0x80f936 ; Pxp_HandleButtonEvent + 254
;;;229                }
;;;230                break;
;;;231            case PxpStateLink:
;;;232                if (gPowerFlg == true)
;;;233                {
;;;234                    gPowerFlg = false;
;;;235                    if (gIoState != IoStateIdle)
;;;236                    {
;;;237                        gIoState = IoStateIdle;
;;;238                        StopPxpIO();
;;;239                    }
;;;240                    le_disconnect(0);
;;;241                }
;;;242                else
;;;243                {
;;;244                    APP_PRINT_ERROR0("ERROR POWER STATUS");//error status
        0x0080f930:    4951        QI      LDR      r1,[pc,#324] ; [0x80fa78] = 0x8800550
        0x0080f932:    2200        ."      MOVS     r2,#0
        0x0080f934:    3184        .1      ADDS     r1,r1,#0x84
        0x0080f936:    4640        @F      MOV      r0,r8
        0x0080f938:    f7f8d891    ....    BL       log_buffer ; 0x7a5e
;;;245                }
;;;246                break;
;;;247            default:
;;;248                break;
;;;249            }
;;;250        }
;;;251        else
;;;252        {
;;;253            //nothing to do
;;;254        }
;;;255    }
        0x0080f93c:    e7a3        ..      B        0x80f886 ; Pxp_HandleButtonEvent + 78
    vTimerPxpIOCallback
;;;256    
;;;257    /**
;;;258     * @brief    StartPxpIO for led blink and beep
;;;259     * @note     Set parameter and start swtimer xTimerPxpIO
;;;260     * @param[in] lowPeroid
;;;261     * @param[in] HighPeroid
;;;262     * @param[in] mode
;;;263     * @param[in] cnt
;;;264     * @return   void
;;;265     */
;;;266    void StartPxpIO(uint32_t lowPeroid, uint32_t HighPeroid, uint8_t mode, uint32_t cnt)
;;;267    {
;;;268        xPeriodLow = lowPeroid;
;;;269        xPeriodHigh = HighPeroid;
;;;270        gIoMode = mode;
;;;271        gActCnt = cnt;
;;;272        if (gIoMode)
;;;273        {
;;;274            if (gIoMode & 0x1)
;;;275            {
;;;276                GPIO_SetBits(GPIO_GetPin(LED));
;;;277            }
;;;278            if (gIoMode & 0x2)
;;;279            {
;;;280                GPIO_SetBits(GPIO_GetPin(BEEP));
;;;281            }
;;;282            allowedPxpEnterDlps = false;
;;;283            os_timer_restart(&xTimerPxpIO, HighPeroid);
;;;284        }
;;;285    }
;;;286    /**
;;;287     * @brief    StopPxpIO
;;;288     * @note     Stop pxp io action
;;;289     * @return   void
;;;290     */
;;;291    void StopPxpIO()
;;;292    {
;;;293        allowedPxpEnterDlps = true;
;;;294        gActCnt = 0;
;;;295        GPIO_ResetBits(GPIO_GetPin(LED));
;;;296        GPIO_ResetBits(GPIO_GetPin(BEEP));
;;;297        os_timer_stop(&xTimerPxpIO);
;;;298    }
;;;299    
;;;300    /**
;;;301     * @brief    vTimerPxpIOCallback
;;;302     * @note     BEEP & LED act here
;;;303     * @param[in] pxTimer
;;;304     * @return   void
;;;305     */
;;;306    void vTimerPxpIOCallback(TimerHandle_t pxTimer)
;;;307    {
        0x0080f93e:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0080f942:    4c4c        LL      LDR      r4,[pc,#304] ; [0x80fa74] = 0x2080b8
        0x0080f944:    7820         x      LDRB     r0,[r4,#0]
        0x0080f946:    07c1        ..      LSLS     r1,r0,#31
        0x0080f948:    d001        ..      BEQ      0x80f94e ; vTimerPxpIOCallback + 16
;;;308        uint8_t  status_value;
;;;309        uint32_t xNewPeriod;
;;;310        if (gIoMode & 0x1)
;;;311        {
;;;312            status_value = GPIO_ReadOutputDataBit(GPIO_GetPin(LED));
        0x0080f94a:    2001        .       MOVS     r0,#1
        0x0080f94c:    e002        ..      B        0x80f954 ; vTimerPxpIOCallback + 22
;;;313        }
;;;314        else if (gIoMode & 0x2)
        0x0080f94e:    0780        ..      LSLS     r0,r0,#30
        0x0080f950:    d51a        ..      BPL      0x80f988 ; vTimerPxpIOCallback + 74
;;;315        {
;;;316            status_value = GPIO_ReadOutputDataBit(GPIO_GetPin(BEEP));
        0x0080f952:    2002        .       MOVS     r0,#2
        0x0080f954:    f7fff809    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f958:    f000f8c9    ....    BL       GPIO_ReadOutputDataBit ; 0x80faee
        0x0080f95c:    4d49        IM      LDR      r5,[pc,#292] ; [0x80fa84] = 0x207e8e
;;;317        }
;;;318        else
;;;319        {
;;;320            APP_PRINT_ERROR0("ERROR IO MODE");
;;;321            return;
;;;322        }
;;;323    
;;;324        if (status_value & 0x1)
        0x0080f95e:    07c0        ..      LSLS     r0,r0,#31
        0x0080f960:    f04f0600    O...    MOV      r6,#0
        0x0080f964:    d018        ..      BEQ      0x80f998 ; vTimerPxpIOCallback + 90
;;;325        {
;;;326            xNewPeriod = xPeriodLow;
;;;327            GPIO_ResetBits(GPIO_GetPin(LED));
        0x0080f966:    2001        .       MOVS     r0,#1
        0x0080f968:    6867        gh      LDR      r7,[r4,#4]
        0x0080f96a:    f7fefffe    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f96e:    f000f8cb    ....    BL       GPIO_ResetBits ; 0x80fb08
;;;328            GPIO_ResetBits(GPIO_GetPin(BEEP));
        0x0080f972:    2002        .       MOVS     r0,#2
        0x0080f974:    f7fefff9    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f978:    f000f8c6    ....    BL       GPIO_ResetBits ; 0x80fb08
;;;329            allowedPxpEnterDlps = true;
        0x0080f97c:    2001        .       MOVS     r0,#1
        0x0080f97e:    7028        (p      STRB     r0,[r5,#0]
;;;330            gActCnt--;
        0x0080f980:    68e0        .h      LDR      r0,[r4,#0xc]
        0x0080f982:    1e40        @.      SUBS     r0,r0,#1
        0x0080f984:    60e0        .`      STR      r0,[r4,#0xc]
        0x0080f986:    e01a        ..      B        0x80f9be ; vTimerPxpIOCallback + 128
        0x0080f988:    e8bd41f0    ...A    POP      {r4-r8,lr}
        0x0080f98c:    493a        :I      LDR      r1,[pc,#232] ; [0x80fa78] = 0x8800550
        0x0080f98e:    2200        ."      MOVS     r2,#0
        0x0080f990:    319c        .1      ADDS     r1,r1,#0x9c
        0x0080f992:    483a        :H      LDR      r0,[pc,#232] ; [0x80fa7c] = 0x21103000
        0x0080f994:    f7f89863    ..c.    B        log_buffer ; 0x7a5e
;;;331        }
;;;332        else
;;;333        {
;;;334            xNewPeriod = xPeriodHigh;
;;;335            if (gIoMode & 0x1)
        0x0080f998:    7820         x      LDRB     r0,[r4,#0]
        0x0080f99a:    68a7        .h      LDR      r7,[r4,#8]
        0x0080f99c:    07c0        ..      LSLS     r0,r0,#31
        0x0080f99e:    d005        ..      BEQ      0x80f9ac ; vTimerPxpIOCallback + 110
;;;336            {
;;;337                GPIO_SetBits(GPIO_GetPin(LED));
        0x0080f9a0:    2001        .       MOVS     r0,#1
        0x0080f9a2:    f7feffe2    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f9a6:    f000f8aa    ....    BL       GPIO_SetBits ; 0x80fafe
;;;338                allowedPxpEnterDlps = false;
        0x0080f9aa:    702e        .p      STRB     r6,[r5,#0]
;;;339            }
;;;340            if (gIoMode & 0x2)
        0x0080f9ac:    7820         x      LDRB     r0,[r4,#0]
        0x0080f9ae:    0780        ..      LSLS     r0,r0,#30
        0x0080f9b0:    d505        ..      BPL      0x80f9be ; vTimerPxpIOCallback + 128
;;;341            {
;;;342                GPIO_SetBits(GPIO_GetPin(BEEP));
        0x0080f9b2:    2002        .       MOVS     r0,#2
        0x0080f9b4:    f7feffd9    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f9b8:    f000f8a1    ....    BL       GPIO_SetBits ; 0x80fafe
;;;343                allowedPxpEnterDlps = false;
        0x0080f9bc:    702e        .p      STRB     r6,[r5,#0]
;;;344            }
;;;345        }
;;;346        if (gActCnt)
        0x0080f9be:    68e0        .h      LDR      r0,[r4,#0xc]
        0x0080f9c0:    b168        h.      CBZ      r0,0x80f9de ; vTimerPxpIOCallback + 160
;;;347        {
;;;348            APP_PRINT_INFO0("xTimerPxpIO os_timer_restart.");
        0x0080f9c2:    492d        -I      LDR      r1,[pc,#180] ; [0x80fa78] = 0x8800550
        0x0080f9c4:    482d        -H      LDR      r0,[pc,#180] ; [0x80fa7c] = 0x21103000
        0x0080f9c6:    2200        ."      MOVS     r2,#0
        0x0080f9c8:    31b0        .1      ADDS     r1,r1,#0xb0
        0x0080f9ca:    1c80        ..      ADDS     r0,r0,#2
        0x0080f9cc:    f7f8d847    ..G.    BL       log_buffer ; 0x7a5e
;;;349            os_timer_restart(&xTimerPxpIO, xNewPeriod);
        0x0080f9d0:    4639        9F      MOV      r1,r7
        0x0080f9d2:    e8bd41f0    ...A    POP      {r4-r8,lr}
        0x0080f9d6:    4827        'H      LDR      r0,[pc,#156] ; [0x80fa74] = 0x2080b8
        0x0080f9d8:    3010        .0      ADDS     r0,r0,#0x10
        0x0080f9da:    f417b130    ..0.    B        os_timer_restart ; 0x26c3e
;;;350        }
;;;351        else
;;;352        {
;;;353            gIoState = IoStateIdle;
        0x0080f9de:    482b        +H      LDR      r0,[pc,#172] ; [0x80fa8c] = 0x2080d1
        0x0080f9e0:    7006        .p      STRB     r6,[r0,#0]
;;;354        }
;;;355    }
        0x0080f9e2:    e8bd81f0    ....    POP      {r4-r8,pc}
    vTimerLongPressCallback
;;;356    
;;;357    /**
;;;358     * @brief    vTimerLongPressCallback
;;;359     * @note     if key still pressed , send long press message
;;;360     * @param[in] pxTimer
;;;361     * @return   void
;;;362     */
;;;363    void vTimerLongPressCallback(TimerHandle_t pxTimer)
;;;364    {
        0x0080f9e6:    b51c        ..      PUSH     {r2-r4,lr}
;;;365        T_IO_MSG bee_io_msg;
;;;366    
;;;367        gKeyStatus = keyLongPress;
        0x0080f9e8:    4c22        "L      LDR      r4,[pc,#136] ; [0x80fa74] = 0x2080b8
        0x0080f9ea:    2002        .       MOVS     r0,#2
        0x0080f9ec:    7060        `p      STRB     r0,[r4,#1]
;;;368    
;;;369        keystatus = GPIO_ReadInputDataBit(GPIO_GetPin(KEY));
        0x0080f9ee:    2014        .       MOVS     r0,#0x14
        0x0080f9f0:    f7feffbb    ....    BL       GPIO_GetPin ; 0x80e96a
        0x0080f9f4:    f000f873    ..s.    BL       GPIO_ReadInputDataBit ; 0x80fade
        0x0080f9f8:    70a0        .p      STRB     r0,[r4,#2]
;;;370        if (keystatus == 0)
        0x0080f9fa:    2800        .(      CMP      r0,#0
        0x0080f9fc:    d108        ..      BNE      0x80fa10 ; vTimerLongPressCallback + 42
;;;371        {
;;;372            bee_io_msg.type = IO_MSG_TYPE_GPIO;
        0x0080f9fe:    200b        .       MOVS     r0,#0xb
        0x0080fa00:    f8ad0000    ....    STRH     r0,[sp,#0]
;;;373            bee_io_msg.subtype = MSG_LONG_PRESS;
        0x0080fa04:    2003        .       MOVS     r0,#3
        0x0080fa06:    f8ad0002    ....    STRH     r0,[sp,#2]
;;;374            app_send_msg_to_apptask(&bee_io_msg);
        0x0080fa0a:    4668        hF      MOV      r0,sp
        0x0080fa0c:    f7fffd94    ....    BL       app_send_msg_to_apptask ; 0x80f538
;;;375        }
;;;376    }
        0x0080fa10:    bd1c        ..      POP      {r2-r4,pc}
    swTimerInit
;;;377    /**
;;;378     * @brief    swTimerInit
;;;379     * @note     creat sw timer
;;;380     * @return   void
;;;381     */
;;;382    void swTimerInit()
;;;383    {
        0x0080fa12:    b57c        |.      PUSH     {r2-r6,lr}
;;;384        bool retval ;
;;;385        /* xTimersRmcPairBtn is used to start bt pair process after timeout */
;;;386    
;;;387        retval = os_timer_create(&xTimerPxpIO, "xTimerPxpIO",  1, \
        0x0080fa14:    f2af00d9    ....    ADR      r0,{pc}-0xd5 ; 0x80f93f
        0x0080fa18:    2500        .%      MOVS     r5,#0
        0x0080fa1a:    e9cd5000    ...P    STRD     r5,r0,[sp,#0]
        0x0080fa1e:    4815        .H      LDR      r0,[pc,#84] ; [0x80fa74] = 0x2080b8
        0x0080fa20:    2364        d#      MOVS     r3,#0x64
        0x0080fa22:    2201        ."      MOVS     r2,#1
        0x0080fa24:    a11c        ..      ADR      r1,{pc}+0x74 ; 0x80fa98
        0x0080fa26:    3010        .0      ADDS     r0,r0,#0x10
        0x0080fa28:    f417f0d5    ....    BL       os_timer_create ; 0x26bd6
        0x0080fa2c:    4c1d        .L      LDR      r4,[pc,#116] ; [0x80faa4] = 0x21103002
        0x0080fa2e:    0003        ..      MOVS     r3,r0
;;;388                                 100/*0.1s*/, false, vTimerPxpIOCallback);
;;;389        if (!retval)
        0x0080fa30:    d105        ..      BNE      0x80fa3e ; swTimerInit + 44
;;;390        {
;;;391            APP_PRINT_INFO1("xTimerAlert retval is %d", retval);
        0x0080fa32:    4911        .I      LDR      r1,[pc,#68] ; [0x80fa78] = 0x8800550
        0x0080fa34:    2201        ."      MOVS     r2,#1
        0x0080fa36:    31d4        .1      ADDS     r1,r1,#0xd4
        0x0080fa38:    4620         F      MOV      r0,r4
        0x0080fa3a:    f7f8d810    ....    BL       log_buffer ; 0x7a5e
;;;392        }
;;;393        retval = os_timer_create(&xTimerLongPress, "xTimerLongPress",  1, \
        0x0080fa3e:    f2af0059    ..Y.    ADR      r0,{pc}-0x57 ; 0x80f9e7
        0x0080fa42:    e9cd5000    ...P    STRD     r5,r0,[sp,#0]
        0x0080fa46:    480b        .H      LDR      r0,[pc,#44] ; [0x80fa74] = 0x2080b8
        0x0080fa48:    f44f637a    O.zc    MOV      r3,#0xfa0
        0x0080fa4c:    2201        ."      MOVS     r2,#1
        0x0080fa4e:    a116        ..      ADR      r1,{pc}+0x5a ; 0x80faa8
        0x0080fa50:    3014        .0      ADDS     r0,r0,#0x14
        0x0080fa52:    f417f0c0    ....    BL       os_timer_create ; 0x26bd6
        0x0080fa56:    0003        ..      MOVS     r3,r0
;;;394                                 4000/*4s*/, false, vTimerLongPressCallback);
;;;395        if (!retval)
        0x0080fa58:    d108        ..      BNE      0x80fa6c ; swTimerInit + 90
;;;396        {
;;;397            APP_PRINT_INFO1("xTimerLongPress retval is %d", retval);
        0x0080fa5a:    b002        ..      ADD      sp,sp,#8
        0x0080fa5c:    4620         F      MOV      r0,r4
        0x0080fa5e:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0080fa62:    4905        .I      LDR      r1,[pc,#20] ; [0x80fa78] = 0x8800550
        0x0080fa64:    2201        ."      MOVS     r2,#1
        0x0080fa66:    31f0        .1      ADDS     r1,r1,#0xf0
        0x0080fa68:    f7f79ff9    ....    B        log_buffer ; 0x7a5e
;;;398        }
;;;399    }
        0x0080fa6c:    bd7c        |.      POP      {r2-r6,pc}
    $d
        0x0080fa6e:    0000        ..      DCW    0
        0x0080fa70:    0c000100    ....    DCD    201326848
        0x0080fa74:    002080b8    .. .    DCD    2130104
        0x0080fa78:    08800550    P...    DCD    142607696
        0x0080fa7c:    21103000    .0.!    DCD    554708992
        0x0080fa80:    40001000    ...@    DCD    1073745920
        0x0080fa84:    00207e8e    .~ .    DCD    2129550
        0x0080fa88:    002080d0    .. .    DCD    2130128
        0x0080fa8c:    002080d1    .. .    DCD    2130129
        0x0080fa90:    002080d2    .. .    DCD    2130130
        0x0080fa94:    002080d8    .. .    DCD    2130136
        0x0080fa98:    6d695478    xTim    DCD    1835619448
        0x0080fa9c:    78507265    erPx    DCD    2018538085
        0x0080faa0:    004f4970    pIO.    DCD    5196144
        0x0080faa4:    21103002    .0.!    DCD    554708994
        0x0080faa8:    6d695478    xTim    DCD    1835619448
        0x0080faac:    6f4c7265    erLo    DCD    1867280997
        0x0080fab0:    7250676e    ngPr    DCD    1917871982
        0x0080fab4:    00737365    ess.    DCD    7566181
    $t
    ChangeConnectionParameter
;;;400    /**
;;;401     * @brief change peripheral interval and latency function
;;;402     * @param interval - connection interval;
;;;403     * @param latency - peripheral connection latency;
;;;404     * @param timeout - supervision time out;
;;;405     * @return none
;;;406     */
;;;407    void ChangeConnectionParameter(uint16_t interval, uint16_t latency, uint16_t timeout)
;;;408    {
        0x0080fab8:    b50e        ..      PUSH     {r1-r3,lr}
        0x0080faba:    460b        .F      MOV      r3,r1
;;;409        le_update_conn_param(0, interval, interval, latency, timeout / 10, interval * 2 - 2,
        0x0080fabc:    210a        .!      MOVS     r1,#0xa
        0x0080fabe:    fbb2f2f1    ....    UDIV     r2,r2,r1
        0x0080fac2:    f06f0101    o...    MVN      r1,#1
        0x0080fac6:    eb010140    ..@.    ADD      r1,r1,r0,LSL #1
        0x0080faca:    b289        ..      UXTH     r1,r1
        0x0080facc:    e9cd2100    ...!    STRD     r2,r1,[sp,#0]
        0x0080fad0:    4602        .F      MOV      r2,r0
        0x0080fad2:    9102        ..      STR      r1,[sp,#8]
        0x0080fad4:    4611        .F      MOV      r1,r2
        0x0080fad6:    2000        .       MOVS     r0,#0
        0x0080fad8:    f43ef0d7    >...    BL       le_update_conn_param ; 0x4dc8a
;;;410                             interval * 2 - 2);
;;;411    }
        0x0080fadc:    bd0e        ..      POP      {r1-r3,pc}
    GPIO_ReadInputDataBit
        0x0080fade:    4a0d        .J      LDR      r2,[pc,#52] ; [0x80fb14] = 0x40001000
;;; ..\include\SDK\inc\peripheral\rtl876x_gpio.h
;;;385    {
        0x0080fae0:    4601        .F      MOV      r1,r0
        0x0080fae2:    2000        .       MOVS     r0,#0
        0x0080fae4:    6d12        .m      LDR      r2,[r2,#0x50]
        0x0080fae6:    420a        .B      TST      r2,r1
        0x0080fae8:    d000        ..      BEQ      0x80faec ; GPIO_ReadInputDataBit + 14
;;;386        uint8_t bitstatus = RESET;
;;;387    
;;;388        /* Check the parameters */
;;;389        assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;390    
;;;391        if (GPIO->DATAIN & GPIO_Pin)
;;;392        {
;;;393            bitstatus = (uint8_t)SET;
        0x0080faea:    2001        .       MOVS     r0,#1
;;;394        }
;;;395    
;;;396        return bitstatus;
;;;397    }
        0x0080faec:    4770        pG      BX       lr
    GPIO_ReadOutputDataBit
        0x0080faee:    4a09        .J      LDR      r2,[pc,#36] ; [0x80fb14] = 0x40001000
;;;398    
;;;399    /**
;;;400      * @brief  Reads value of all  GPIO input data port.
;;;401      * @param  None
;;;402      * @retval GPIO input data port value.
;;;403      */
;;;404    __STATIC_INLINE uint32_t GPIO_ReadInputData(void)
;;;405    {
;;;406        return GPIO->DATAIN;
;;;407    }
;;;408    
;;;409    /**
;;;410      * @brief  Reads the specified output port pin.
;;;411      * @param  GPIO_Pin:  specifies the port bit to read.
;;;412      *   This parameter can be GPIO_Pin_x where x can be (0..31).
;;;413      * @retval The output port pin value.
;;;414      */
;;;415    __STATIC_INLINE uint8_t GPIO_ReadOutputDataBit(uint32_t GPIO_Pin)
;;;416    {
        0x0080faf0:    4601        .F      MOV      r1,r0
        0x0080faf2:    2000        .       MOVS     r0,#0
        0x0080faf4:    6812        .h      LDR      r2,[r2,#0]
        0x0080faf6:    420a        .B      TST      r2,r1
        0x0080faf8:    d000        ..      BEQ      0x80fafc ; GPIO_ReadOutputDataBit + 14
;;;417        uint8_t bitstatus = RESET;
;;;418    
;;;419        /* Check the parameters */
;;;420        assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;421    
;;;422        if (GPIO->DATAOUT & GPIO_Pin)
;;;423        {
;;;424            bitstatus = (uint8_t)SET;
        0x0080fafa:    2001        .       MOVS     r0,#1
;;;425        }
;;;426    
;;;427        return bitstatus;
;;;428    }
        0x0080fafc:    4770        pG      BX       lr
    GPIO_SetBits
;;;429    
;;;430    /**
;;;431      * @brief  Reads value of all  GPIO output data port.
;;;432      * @param  None
;;;433      * @retval GPIO output data port value.
;;;434      */
;;;435    __STATIC_INLINE uint32_t GPIO_ReadOutputData(void)
;;;436    {
;;;437        return ((uint32_t)GPIO->DATAOUT);
;;;438    }
;;;439    
;;;440    /**
;;;441      * @brief  Sets the selected data port bits.
;;;442      * @param  GPIO_Pin: specifies the port bits to be written.
;;;443      *   This parameter can be GPIO_Pin_x where x can be (0..31) or GPIO_Pin_All.
;;;444      * @retval None
;;;445      */
;;;446    __STATIC_INLINE void GPIO_SetBits(uint32_t GPIO_Pin)
;;;447    {
;;;448        /* Check the parameters */
;;;449        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;450    
;;;451        GPIO->DATAOUT |= GPIO_Pin;
        0x0080fafe:    4905        .I      LDR      r1,[pc,#20] ; [0x80fb14] = 0x40001000
        0x0080fb00:    680a        .h      LDR      r2,[r1,#0]
        0x0080fb02:    4302        .C      ORRS     r2,r2,r0
        0x0080fb04:    600a        .`      STR      r2,[r1,#0]
;;;452    }
        0x0080fb06:    4770        pG      BX       lr
    GPIO_ResetBits
;;;453    
;;;454    /**
;;;455      * @brief  Resets the selected data port bits.
;;;456      * @param  GPIO_Pin: specifies the port bits to be written.
;;;457      *   This parameter can be GPIO_Pin_0 to GPIO_Pin_31 or GPIO_Pin_All.
;;;458      * @retval None
;;;459      */
;;;460    __STATIC_INLINE void GPIO_ResetBits(uint32_t GPIO_Pin)
;;;461    {
;;;462        /* Check the parameters */
;;;463        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;464    
;;;465        GPIO->DATAOUT &= ~(GPIO_Pin);
        0x0080fb08:    4902        .I      LDR      r1,[pc,#8] ; [0x80fb14] = 0x40001000
        0x0080fb0a:    680a        .h      LDR      r2,[r1,#0]
        0x0080fb0c:    4382        .C      BICS     r2,r2,r0
        0x0080fb0e:    600a        .`      STR      r2,[r1,#0]
;;;466    }
        0x0080fb10:    4770        pG      BX       lr
    $d
        0x0080fb12:    0000        ..      DCW    0
        0x0080fb14:    40001000    ...@    DCD    1073745920
    $t
    .text
    app_le_gap_init
;;; ..\include\SDK\src\app\pxp\main.c
;;;145    {
        0x0080fb18:    b500        ..      PUSH     {lr}
        0x0080fb1a:    b09d        ..      SUB      sp,sp,#0x74
;;;146        /* Device name and device appearance */
;;;147        uint8_t  device_name[GAP_DEVICE_NAME_LEN] = "REAL_PXP";
        0x0080fb1c:    2228        ("      MOVS     r2,#0x28
        0x0080fb1e:    49b9        .I      LDR      r1,[pc,#740] ; [0x80fe04] = 0x810e64
        0x0080fb20:    4668        hF      MOV      r0,sp
        0x0080fb22:    f44af241    J.A.    BL       __aeabi_memcpy4 ; 0x59fa8
;;;148        uint16_t appearance = GAP_GATT_APPEARANCE_GENERIC_KEYRING;
        0x0080fb26:    f44f7010    O..p    MOV      r0,#0x240
        0x0080fb2a:    f8ad006c    ..l.    STRH     r0,[sp,#0x6c]
;;;149        uint8_t  slave_init_mtu_req = false;
        0x0080fb2e:    2000        .       MOVS     r0,#0
        0x0080fb30:    2107        .!      MOVS     r1,#7
        0x0080fb32:    f88d1034    ..4.    STRB     r1,[sp,#0x34]
        0x0080fb36:    f44f71a0    O..q    MOV      r1,#0x140
        0x0080fb3a:    f88d0044    ..D.    STRB     r0,[sp,#0x44]
        0x0080fb3e:    f8ad1048    ..H.    STRH     r1,[sp,#0x48]
        0x0080fb42:    f8ad1030    ..0.    STRH     r1,[sp,#0x30]
        0x0080fb46:    2101        .!      MOVS     r1,#1
        0x0080fb48:    f88d0040    ..@.    STRB     r0,[sp,#0x40]
        0x0080fb4c:    f88d003c    ..<.    STRB     r0,[sp,#0x3c]
        0x0080fb50:    900b        ..      STR      r0,[sp,#0x2c]
;;;150    
;;;151        /* Advertising parameters */
;;;152        uint8_t  adv_evt_type = GAP_ADTYPE_ADV_IND;
;;;153        uint8_t  adv_direct_type = GAP_REMOTE_ADDR_LE_PUBLIC;
;;;154        uint8_t  adv_direct_addr[GAP_BD_ADDR_LEN] = {0};
        0x0080fb52:    900a        ..      STR      r0,[sp,#0x28]
;;;155        uint8_t  adv_chann_map = GAP_ADVCHAN_ALL;
;;;156        uint8_t  adv_filter_policy = GAP_ADV_FILTER_ANY;
        0x0080fb54:    f88d0038    ..8.    STRB     r0,[sp,#0x38]
        0x0080fb58:    2203        ."      MOVS     r2,#3
;;;157        uint16_t adv_int_min = DEFAULT_ADVERTISING_INTERVAL_MIN;
;;;158        uint16_t adv_int_max = DEFAULT_ADVERTISING_INTERVAL_MIN;
;;;159    
;;;160        /* GAP Bond Manager parameters */
;;;161        uint8_t  auth_pair_mode = GAP_PAIRING_MODE_PAIRABLE;
        0x0080fb5a:    f88d104c    ..L.    STRB     r1,[sp,#0x4c]
;;;162        uint16_t auth_flags = GAP_AUTHEN_BIT_BONDING_FLAG;
        0x0080fb5e:    f8ad1050    ..P.    STRH     r1,[sp,#0x50]
;;;163        uint8_t  auth_io_cap = GAP_IO_CAP_NO_INPUT_NO_OUTPUT;
        0x0080fb62:    f88d2054    ..T     STRB     r2,[sp,#0x54]
;;;164        uint8_t  auth_oob = false;
        0x0080fb66:    f88d0058    ..X.    STRB     r0,[sp,#0x58]
;;;165        uint8_t  auth_use_fix_passkey = false;
        0x0080fb6a:    f88d005c    ..\.    STRB     r0,[sp,#0x5c]
;;;166        uint32_t auth_fix_passkey = 0;
;;;167    
;;;168        uint8_t  auth_sec_req_enable = false;
        0x0080fb6e:    9018        ..      STR      r0,[sp,#0x60]
        0x0080fb70:    f88d0064    ..d.    STRB     r0,[sp,#0x64]
;;;169    
;;;170        uint16_t auth_sec_req_flags = GAP_AUTHEN_BIT_BONDING_FLAG;
        0x0080fb74:    f8ad1068    ..h.    STRH     r1,[sp,#0x68]
;;;171    
;;;172        /* Set device name and device appearance */
;;;173        le_set_gap_param(GAP_PARAM_DEVICE_NAME, GAP_DEVICE_NAME_LEN, device_name);
        0x0080fb78:    466a        jF      MOV      r2,sp
        0x0080fb7a:    2128        (!      MOVS     r1,#0x28
        0x0080fb7c:    f2402022    @."     MOV      r0,#0x222
        0x0080fb80:    f43df062    =.b.    BL       le_set_gap_param ; 0x4cc48
;;;174        le_set_gap_param(GAP_PARAM_APPEARANCE, sizeof(appearance), &appearance);
        0x0080fb84:    aa1b        ..      ADD      r2,sp,#0x6c
        0x0080fb86:    2102        .!      MOVS     r1,#2
        0x0080fb88:    f2402021    @.!     MOV      r0,#0x221
        0x0080fb8c:    f43df05c    =.\.    BL       le_set_gap_param ; 0x4cc48
;;;175        le_set_gap_param(GAP_PARAM_SLAVE_INIT_GATT_MTU_REQ, sizeof(slave_init_mtu_req),
        0x0080fb90:    aa0f        ..      ADD      r2,sp,#0x3c
        0x0080fb92:    2101        .!      MOVS     r1,#1
        0x0080fb94:    f2402023    @.#     MOV      r0,#0x223
        0x0080fb98:    f43df056    =.V.    BL       le_set_gap_param ; 0x4cc48
;;;176                         &slave_init_mtu_req);
;;;177    
;;;178        /* Set advertising parameters */
;;;179        le_adv_set_param(GAP_PARAM_ADV_EVENT_TYPE, sizeof(adv_evt_type), &adv_evt_type);
        0x0080fb9c:    aa10        ..      ADD      r2,sp,#0x40
        0x0080fb9e:    2101        .!      MOVS     r1,#1
        0x0080fba0:    f2402063    @.c     MOV      r0,#0x263
        0x0080fba4:    f442f174    B.t.    BL       le_adv_set_param ; 0x51e90
;;;180        le_adv_set_param(GAP_PARAM_ADV_DIRECT_ADDR_TYPE, sizeof(adv_direct_type), &adv_direct_type);
        0x0080fba8:    aa11        ..      ADD      r2,sp,#0x44
        0x0080fbaa:    2101        .!      MOVS     r1,#1
        0x0080fbac:    f44f7019    O..p    MOV      r0,#0x264
        0x0080fbb0:    f442f16e    B.n.    BL       le_adv_set_param ; 0x51e90
;;;181        le_adv_set_param(GAP_PARAM_ADV_DIRECT_ADDR, sizeof(adv_direct_addr), adv_direct_addr);
        0x0080fbb4:    aa0a        ..      ADD      r2,sp,#0x28
        0x0080fbb6:    2106        .!      MOVS     r1,#6
        0x0080fbb8:    f2402065    @.e     MOV      r0,#0x265
        0x0080fbbc:    f442f168    B.h.    BL       le_adv_set_param ; 0x51e90
;;;182        le_adv_set_param(GAP_PARAM_ADV_CHANNEL_MAP, sizeof(adv_chann_map), &adv_chann_map);
        0x0080fbc0:    aa0d        ..      ADD      r2,sp,#0x34
        0x0080fbc2:    2101        .!      MOVS     r1,#1
        0x0080fbc4:    f2402066    @.f     MOV      r0,#0x266
        0x0080fbc8:    f442f162    B.b.    BL       le_adv_set_param ; 0x51e90
;;;183        le_adv_set_param(GAP_PARAM_ADV_FILTER_POLICY, sizeof(adv_filter_policy), &adv_filter_policy);
        0x0080fbcc:    aa0e        ..      ADD      r2,sp,#0x38
        0x0080fbce:    2101        .!      MOVS     r1,#1
        0x0080fbd0:    f2402067    @.g     MOV      r0,#0x267
        0x0080fbd4:    f442f15c    B.\.    BL       le_adv_set_param ; 0x51e90
;;;184        le_adv_set_param(GAP_PARAM_ADV_INTERVAL_MIN, sizeof(adv_int_min), &adv_int_min);
        0x0080fbd8:    aa12        ..      ADD      r2,sp,#0x48
        0x0080fbda:    2102        .!      MOVS     r1,#2
        0x0080fbdc:    f44f701a    O..p    MOV      r0,#0x268
        0x0080fbe0:    f442f156    B.V.    BL       le_adv_set_param ; 0x51e90
;;;185        le_adv_set_param(GAP_PARAM_ADV_INTERVAL_MAX, sizeof(adv_int_max), &adv_int_max);
        0x0080fbe4:    aa0c        ..      ADD      r2,sp,#0x30
        0x0080fbe6:    2102        .!      MOVS     r1,#2
        0x0080fbe8:    f2402069    @.i     MOV      r0,#0x269
        0x0080fbec:    f442f150    B.P.    BL       le_adv_set_param ; 0x51e90
;;;186        le_adv_set_param(GAP_PARAM_ADV_DATA, sizeof(adv_data), (void *)adv_data);
        0x0080fbf0:    4a85        .J      LDR      r2,[pc,#532] ; [0x80fe08] = 0x207e9d
        0x0080fbf2:    2115        .!      MOVS     r1,#0x15
        0x0080fbf4:    f2402061    @.a     MOV      r0,#0x261
        0x0080fbf8:    f442f14a    B.J.    BL       le_adv_set_param ; 0x51e90
;;;187        le_adv_set_param(GAP_PARAM_SCAN_RSP_DATA, sizeof(scan_rsp_data), (void *)scan_rsp_data);
        0x0080fbfc:    4a82        .J      LDR      r2,[pc,#520] ; [0x80fe08] = 0x207e9d
        0x0080fbfe:    210e        .!      MOVS     r1,#0xe
        0x0080fc00:    3a0e        .:      SUBS     r2,r2,#0xe
        0x0080fc02:    f2402062    @.b     MOV      r0,#0x262
        0x0080fc06:    f442f143    B.C.    BL       le_adv_set_param ; 0x51e90
;;;188    
;;;189        /* Setup the GAP Bond Manager */
;;;190        gap_set_param(GAP_PARAM_BOND_PAIRING_MODE, sizeof(auth_pair_mode), &auth_pair_mode);
        0x0080fc0a:    aa13        ..      ADD      r2,sp,#0x4c
        0x0080fc0c:    2101        .!      MOVS     r1,#1
        0x0080fc0e:    f2402002    @..     MOV      r0,#0x202
        0x0080fc12:    f43cf1ca    <...    BL       gap_set_param ; 0x4bfaa
;;;191        gap_set_param(GAP_PARAM_BOND_AUTHEN_REQUIREMENTS_FLAGS, sizeof(auth_flags), &auth_flags);
        0x0080fc16:    aa14        ..      ADD      r2,sp,#0x50
        0x0080fc18:    2102        .!      MOVS     r1,#2
        0x0080fc1a:    f2402003    @..     MOV      r0,#0x203
        0x0080fc1e:    f43cf1c4    <...    BL       gap_set_param ; 0x4bfaa
;;;192        gap_set_param(GAP_PARAM_BOND_IO_CAPABILITIES, sizeof(auth_io_cap), &auth_io_cap);
        0x0080fc22:    aa15        ..      ADD      r2,sp,#0x54
        0x0080fc24:    2101        .!      MOVS     r1,#1
        0x0080fc26:    f44f7001    O..p    MOV      r0,#0x204
        0x0080fc2a:    f43cf1be    <...    BL       gap_set_param ; 0x4bfaa
;;;193        gap_set_param(GAP_PARAM_BOND_OOB_ENABLED, sizeof(auth_oob), &auth_oob);
        0x0080fc2e:    aa16        ..      ADD      r2,sp,#0x58
        0x0080fc30:    2101        .!      MOVS     r1,#1
        0x0080fc32:    f2402005    @..     MOV      r0,#0x205
        0x0080fc36:    f43cf1b8    <...    BL       gap_set_param ; 0x4bfaa
;;;194        le_bond_set_param(GAP_PARAM_BOND_FIXED_PASSKEY, sizeof(auth_fix_passkey), &auth_fix_passkey);
        0x0080fc3a:    aa18        ..      ADD      r2,sp,#0x60
        0x0080fc3c:    2104        .!      MOVS     r1,#4
        0x0080fc3e:    f2402011    @..     MOV      r0,#0x211
        0x0080fc42:    f43cf2d4    <...    BL       le_bond_set_param ; 0x4c1ee
;;;195        le_bond_set_param(GAP_PARAM_BOND_FIXED_PASSKEY_ENABLE, sizeof(auth_use_fix_passkey),
        0x0080fc46:    aa17        ..      ADD      r2,sp,#0x5c
        0x0080fc48:    2101        .!      MOVS     r1,#1
        0x0080fc4a:    f2402012    @..     MOV      r0,#0x212
        0x0080fc4e:    f43cf2ce    <...    BL       le_bond_set_param ; 0x4c1ee
;;;196                          &auth_use_fix_passkey);
;;;197        le_bond_set_param(GAP_PARAM_BOND_SEC_REQ_ENABLE, sizeof(auth_sec_req_enable), &auth_sec_req_enable);
        0x0080fc52:    aa19        ..      ADD      r2,sp,#0x64
        0x0080fc54:    2101        .!      MOVS     r1,#1
        0x0080fc56:    f2402013    @..     MOV      r0,#0x213
        0x0080fc5a:    f43cf2c8    <...    BL       le_bond_set_param ; 0x4c1ee
;;;198        le_bond_set_param(GAP_PARAM_BOND_SEC_REQ_REQUIREMENT, sizeof(auth_sec_req_flags),
        0x0080fc5e:    aa1a        ..      ADD      r2,sp,#0x68
        0x0080fc60:    2102        .!      MOVS     r1,#2
        0x0080fc62:    f44f7005    O..p    MOV      r0,#0x214
        0x0080fc66:    f43cf2c2    <...    BL       le_bond_set_param ; 0x4c1ee
;;;199                          &auth_sec_req_flags);
;;;200    
;;;201        /* register gap message callback */
;;;202        le_register_app_cb(app_gap_callback);
        0x0080fc6a:    4868        hH      LDR      r0,[pc,#416] ; [0x80fe0c] = 0x8102b7
        0x0080fc6c:    f43cf7e9    <...    BL       le_register_app_cb ; 0x4cc42
;;;203    }
        0x0080fc70:    b01d        ..      ADD      sp,sp,#0x74
        0x0080fc72:    bd00        ..      POP      {pc}
    app_le_profile_init
;;;204    
;;;205    /**
;;;206     * @brief  Add GATT services, clients and register callbacks
;;;207     * @return void
;;;208     */
;;;209    void app_le_profile_init(void)
;;;210    {
        0x0080fc74:    b510        ..      PUSH     {r4,lr}
;;;211        server_init(6);
        0x0080fc76:    2006        .       MOVS     r0,#6
        0x0080fc78:    f43ff444    ?.D.    BL       server_init ; 0x4f504
;;;212        //simp_srv_id = simp_ble_service_add_service(app_profile_callback);
;;;213        ias_srv_id  = ias_add_service(app_profile_callback);
        0x0080fc7c:    4864        dH      LDR      r0,[pc,#400] ; [0x80fe10] = 0x810305
        0x0080fc7e:    f7fff886    ....    BL       ias_add_service ; 0x80ed8e
        0x0080fc82:    4964        dI      LDR      r1,[pc,#400] ; [0x80fe14] = 0x2080d5
        0x0080fc84:    7008        .p      STRB     r0,[r1,#0]
;;;214        lls_srv_id  = lls_add_service(app_profile_callback);
        0x0080fc86:    4862        bH      LDR      r0,[pc,#392] ; [0x80fe10] = 0x810305
        0x0080fc88:    f7fff914    ....    BL       lls_add_service ; 0x80eeb4
        0x0080fc8c:    4962        bI      LDR      r1,[pc,#392] ; [0x80fe18] = 0x2080d6
        0x0080fc8e:    7008        .p      STRB     r0,[r1,#0]
;;;215        tps_srv_id  = tps_add_service(app_profile_callback);
        0x0080fc90:    485f        _H      LDR      r0,[pc,#380] ; [0x80fe10] = 0x810305
        0x0080fc92:    f7fff975    ..u.    BL       tps_add_service ; 0x80ef80
        0x0080fc96:    4961        aI      LDR      r1,[pc,#388] ; [0x80fe1c] = 0x2080d7
        0x0080fc98:    7008        .p      STRB     r0,[r1,#0]
;;;216        kns_srv_id  = kns_add_service(app_profile_callback);
        0x0080fc9a:    485d        ]H      LDR      r0,[pc,#372] ; [0x80fe10] = 0x810305
        0x0080fc9c:    f7fffae0    ....    BL       kns_add_service ; 0x80f260
        0x0080fca0:    495f        _I      LDR      r1,[pc,#380] ; [0x80fe20] = 0x2080d8
        0x0080fca2:    7008        .p      STRB     r0,[r1,#0]
;;;217        bas_srv_id  = bas_add_service(app_profile_callback);
        0x0080fca4:    485a        ZH      LDR      r0,[pc,#360] ; [0x80fe10] = 0x810305
        0x0080fca6:    f7fffa21    ..!.    BL       bas_add_service ; 0x80f0ec
        0x0080fcaa:    495e        ^I      LDR      r1,[pc,#376] ; [0x80fe24] = 0x2080d9
        0x0080fcac:    7008        .p      STRB     r0,[r1,#0]
;;;218        dis_srv_id  = dis_add_service(app_profile_callback);
        0x0080fcae:    4858        XH      LDR      r0,[pc,#352] ; [0x80fe10] = 0x810305
        0x0080fcb0:    f7fffc17    ....    BL       dis_add_service ; 0x80f4e2
        0x0080fcb4:    495c        \I      LDR      r1,[pc,#368] ; [0x80fe28] = 0x2080da
        0x0080fcb6:    7008        .p      STRB     r0,[r1,#0]
;;;219        server_register_app_cb(app_profile_callback);
        0x0080fcb8:    e8bd4010    ...@    POP      {r4,lr}
        0x0080fcbc:    4854        TH      LDR      r0,[pc,#336] ; [0x80fe10] = 0x810305
        0x0080fcbe:    f43fb43a    ?.:.    B        server_register_app_cb ; 0x4f536
    board_init
;;;220    
;;;221    }
;;;222    
;;;223    
;;;224    /**
;;;225     * @brief    Contains the initialization of pinmux settings and pad settings
;;;226     * @note     All the pinmux settings and pad settings shall be initiated in this function,
;;;227     *           but if legacy driver is used, the initialization of pinmux setting and pad setting
;;;228     *           should be peformed with the IO initializing.
;;;229     * @return   void
;;;230     */
;;;231    void board_init(void)
;;;232    {
        0x0080fcc2:    b510        ..      PUSH     {r4,lr}
;;;233        RCC_Configuration();
        0x0080fcc4:    f7fffce1    ....    BL       RCC_Configuration ; 0x80f68a
;;;234        PINMUX_Configuration();
        0x0080fcc8:    f7fffcb4    ....    BL       PINMUX_Configuration ; 0x80f634
;;;235        PAD_Configuration();
        0x0080fccc:    e8bd4010    ...@    POP      {r4,lr}
        0x0080fcd0:    f7ffbcbf    ....    B.W      PAD_Configuration ; 0x80f652
    System_Handler
;;;236    }
;;;237    /**
;;;238     * @brief    System_Handler
;;;239     * @note     system handle to judge which pin is wake source
;;;240     * @return   void
;;;241     */
;;;242    void System_Handler(void)
;;;243    {
        0x0080fcd4:    b570        p.      PUSH     {r4-r6,lr}
;;;244        uint8_t tmpVal;
;;;245    
;;;246        APP_PRINT_INFO0("System_Handler");
        0x0080fcd6:    2200        ."      MOVS     r2,#0
        0x0080fcd8:    4954        TI      LDR      r1,[pc,#336] ; [0x80fe2c] = 0x8800660
        0x0080fcda:    4855        UH      LDR      r0,[pc,#340] ; [0x80fe30] = 0x21103002
        0x0080fcdc:    f7f7debf    ....    BL       log_buffer ; 0x7a5e
;;; ..\include\SDK\inc\platform\cmsis\core_cm4.h
;;;1659       NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
        0x0080fce0:    f04f25e0    O..%    MOV      r5,#0xe000e000
        0x0080fce4:    2401        .$      MOVS     r4,#1
        0x0080fce6:    f8c54180    ...A    STR      r4,[r5,#0x180]
        0x0080fcea:    f50575c0    ...u    ADD      r5,r5,#0x180
;;; ..\include\SDK\src\app\pxp\main.c
;;;249        KEY_INT_Handle();//P2_4  edge triggle , can't interrupt after dlps
        0x0080fcee:    f7fffd23    ..#.    BL       GPIO20_Handler ; 0x80f738
;;;250    
;;;251        // need clear debounce bit here.
;;;252        tmpVal = btaon_fast_read_safe(0x2b);
        0x0080fcf2:    202b        +       MOVS     r0,#0x2b
        0x0080fcf4:    f42ff086    /...    BL       btaon_fast_read_safe ; 0x3ee04
;;;253        btaon_fast_write_safe(0x2b, (tmpVal | BIT7));
        0x0080fcf8:    f0400180    @...    ORR      r1,r0,#0x80
        0x0080fcfc:    202b        +       MOVS     r0,#0x2b
        0x0080fcfe:    f42ff0a2    /...    BL       btaon_fast_write_safe ; 0x3ee46
;;; ..\include\SDK\inc\platform\cmsis\core_cm4.h
;;;1700       NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) &
        0x0080fd02:    f8c54100    ...A    STR      r4,[r5,#0x100]
;;; ..\include\SDK\src\app\pxp\main.c
;;;265    }
        0x0080fd06:    bd70        p.      POP      {r4-r6,pc}
    PxpEnterDlpsSet
;;;266    /**
;;;267     * @brief    PxpEnterDlpsSet
;;;268     * @note     enter dlps to set pad&wake up pin
;;;269     * @return   void
;;;270     */
;;;271    void PxpEnterDlpsSet(void)
;;;272    {
        0x0080fd08:    b57c        |.      PUSH     {r2-r6,lr}
;;;273        Pad_Config(KEY, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0080fd0a:    2400        .$      MOVS     r4,#0
        0x0080fd0c:    2301        .#      MOVS     r3,#1
        0x0080fd0e:    9400        ..      STR      r4,[sp,#0]
        0x0080fd10:    461a        .F      MOV      r2,r3
        0x0080fd12:    4621        !F      MOV      r1,r4
        0x0080fd14:    2014        .       MOVS     r0,#0x14
        0x0080fd16:    9401        ..      STR      r4,[sp,#4]
        0x0080fd18:    f401f360    ..`.    BL       Pad_Config ; 0x113dc
;;;274        Pad_Config(LED, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0080fd1c:    2501        .%      MOVS     r5,#1
        0x0080fd1e:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0080fd22:    2300        .#      MOVS     r3,#0
        0x0080fd24:    462a        *F      MOV      r2,r5
        0x0080fd26:    4619        .F      MOV      r1,r3
        0x0080fd28:    4628        (F      MOV      r0,r5
        0x0080fd2a:    f401f357    ..W.    BL       Pad_Config ; 0x113dc
;;;275        Pad_Config(BEEP, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0080fd2e:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0080fd32:    2300        .#      MOVS     r3,#0
        0x0080fd34:    2201        ."      MOVS     r2,#1
        0x0080fd36:    4619        .F      MOV      r1,r3
        0x0080fd38:    2002        .       MOVS     r0,#2
        0x0080fd3a:    f401f34f    ..O.    BL       Pad_Config ; 0x113dc
;;;276        System_WakeUpDebounceTime(0x8);
        0x0080fd3e:    2008        .       MOVS     r0,#8
        0x0080fd40:    f401f393    ....    BL       System_WakeUpDebounceTime ; 0x1146a
;;;277        if (keystatus)
        0x0080fd44:    483b        ;H      LDR      r0,[pc,#236] ; [0x80fe34] = 0x2080ba
        0x0080fd46:    f04f0201    O...    MOV      r2,#1
        0x0080fd4a:    7800        .x      LDRB     r0,[r0,#0]
        0x0080fd4c:    b108        ..      CBZ      r0,0x80fd52 ; PxpEnterDlpsSet + 74
;;;278        {
;;;279            System_WakeUpPinEnable(KEY, PAD_WAKEUP_POL_LOW, PAD_WK_DEBOUNCE_ENABLE);
        0x0080fd4e:    2101        .!      MOVS     r1,#1
        0x0080fd50:    e000        ..      B        0x80fd54 ; PxpEnterDlpsSet + 76
;;;280        }
;;;281        else
;;;282        {
;;;283            System_WakeUpPinEnable(KEY, PAD_WAKEUP_POL_HIGH, PAD_WK_DEBOUNCE_ENABLE);
        0x0080fd52:    2100        .!      MOVS     r1,#0
        0x0080fd54:    b002        ..      ADD      sp,sp,#8
        0x0080fd56:    2014        .       MOVS     r0,#0x14
        0x0080fd58:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0080fd5c:    f401b3cf    ....    B        System_WakeUpPinEnable ; 0x114fe
    PxpExitDlpsInit
;;;284        }
;;;285    }
;;;286    /**
;;;287     * @brief    PxpExitDlpsInit
;;;288     * @note     Exit dlps to configure pad
;;;289     * @return   void
;;;290     */
;;;291    void PxpExitDlpsInit(void)
;;;292    {
        0x0080fd60:    b57c        |.      PUSH     {r2-r6,lr}
;;;293        Pad_Config(LED, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0080fd62:    2501        .%      MOVS     r5,#1
        0x0080fd64:    2400        .$      MOVS     r4,#0
        0x0080fd66:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0080fd6a:    4623        #F      MOV      r3,r4
        0x0080fd6c:    462a        *F      MOV      r2,r5
        0x0080fd6e:    4629        )F      MOV      r1,r5
        0x0080fd70:    4628        (F      MOV      r0,r5
        0x0080fd72:    f401f333    ..3.    BL       Pad_Config ; 0x113dc
;;;294        Pad_Config(BEEP, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_ENABLE, PAD_OUT_LOW);
        0x0080fd76:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x0080fd7a:    2201        ."      MOVS     r2,#1
        0x0080fd7c:    2300        .#      MOVS     r3,#0
        0x0080fd7e:    4611        .F      MOV      r1,r2
        0x0080fd80:    2002        .       MOVS     r0,#2
        0x0080fd82:    f401f32b    ..+.    BL       Pad_Config ; 0x113dc
;;;295        Pad_Config(KEY, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0080fd86:    2301        .#      MOVS     r3,#1
        0x0080fd88:    9400        ..      STR      r4,[sp,#0]
        0x0080fd8a:    461a        .F      MOV      r2,r3
        0x0080fd8c:    4619        .F      MOV      r1,r3
        0x0080fd8e:    2014        .       MOVS     r0,#0x14
        0x0080fd90:    9401        ..      STR      r4,[sp,#4]
        0x0080fd92:    f401f323    ..#.    BL       Pad_Config ; 0x113dc
;;;296    }
        0x0080fd96:    bd7c        |.      POP      {r2-r6,pc}
    DLPS_PxpCheck
;;;297    /**
;;;298     * @brief    DLPS_PxpCheck
;;;299     * @note     check app enter dlps flg.
;;;300     * @return   bool
;;;301     */
;;;302    bool DLPS_PxpCheck(void)
;;;303    {
;;;304        return allowedPxpEnterDlps;
        0x0080fd98:    481b        .H      LDR      r0,[pc,#108] ; [0x80fe08] = 0x207e9d
        0x0080fd9a:    380f        .8      SUBS     r0,r0,#0xf
        0x0080fd9c:    7800        .x      LDRB     r0,[r0,#0]
;;;305    }
        0x0080fd9e:    4770        pG      BX       lr
    pwr_mgr_init
;;;306    
;;;307    /**
;;;308     * @brief    Contains the power mode settings
;;;309     * @return   void
;;;310     */
;;;311    void pwr_mgr_init(void)
;;;312    {
        0x0080fda0:    b510        ..      PUSH     {r4,lr}
;;;313    #if DLPS_EN
;;;314        if (false == dlps_check_cb_reg(DLPS_PxpCheck))
        0x0080fda2:    f2af000b    ....    ADR      r0,{pc}-9 ; 0x80fd99
        0x0080fda6:    f7f8dc2a    ..*.    BL       dlps_check_cb_reg ; 0x85fe
        0x0080fdaa:    b920         .      CBNZ     r0,0x80fdb6 ; pwr_mgr_init + 22
;;;315        {
;;;316            DBG_DIRECT("Error: dlps_check_cb_reg(DLPS_RcuCheck) failed!\n");
        0x0080fdac:    a122        ".      ADR      r1,{pc}+0x8c ; 0x80fe38
        0x0080fdae:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0080fdb2:    f7f7ddfd    ....    BL       log_direct ; 0x79b0
;;;317        }
;;;318        DLPS_IORegUserDlpsEnterCb(PxpEnterDlpsSet);
        0x0080fdb6:    f2af00af    ....    ADR      r0,{pc}-0xad ; 0x80fd09
;;; ..\include\SDK\inc\peripheral\rtl876x_io_dlps.h
;;;88         User_IO_EnterDlpsCB = func;
        0x0080fdba:    492c        ,I      LDR      r1,[pc,#176] ; [0x80fe6c] = 0x207f34
;;; ..\include\SDK\src\app\pxp\main.c
;;;319        DLPS_IORegUserDlpsExitCb(PxpExitDlpsInit);
        0x0080fdbc:    6008        .`      STR      r0,[r1,#0]
        0x0080fdbe:    f2af005f    .._.    ADR      r0,{pc}-0x5d ; 0x80fd61
;;; ..\include\SDK\inc\peripheral\rtl876x_io_dlps.h
;;;72         User_IO_ExitDlpsCB = func;
        0x0080fdc2:    492b        +I      LDR      r1,[pc,#172] ; [0x80fe70] = 0x207f30
;;; ..\include\SDK\src\app\pxp\main.c
;;;320        DLPS_IORegister();
        0x0080fdc4:    6008        .`      STR      r0,[r1,#0]
        0x0080fdc6:    f7fefd33    ..3.    BL       DLPS_IORegister ; 0x80e830
;;;321        lps_mode_set(LPM_DLPS_MODE);
        0x0080fdca:    e8bd4010    ...@    POP      {r4,lr}
        0x0080fdce:    2002        .       MOVS     r0,#2
        0x0080fdd0:    f7f89d45    ..E.    B        lps_mode_set ; 0x885e
    task_init
;;;322    #endif
;;;323    }
;;;324    
;;;325    /**
;;;326     * @brief    Contains the initialization of all tasks
;;;327     * @note     There is only one task in BLE Scatternet APP, thus only one APP task is init here
;;;328     * @return   void
;;;329     */
;;;330    void task_init(void)
;;;331    {
;;;332        app_task_init();
        0x0080fdd4:    f7ffbc16    ....    B.W      app_task_init ; 0x80f604
    main
;;;333    }
;;;334    
;;;335    /**
;;;336     * @brief    Entry of APP code
;;;337     * @return   int (To avoid compile warning)
;;;338     */
;;;339    int main(void)
;;;340    {
        0x0080fdd8:    b510        ..      PUSH     {r4,lr}
;;;341        board_init();
        0x0080fdda:    f7ffff72    ..r.    BL       board_init ; 0x80fcc2
;;;342    
;;;343        le_gap_init(APP_MAX_LINKS);
        0x0080fdde:    2001        .       MOVS     r0,#1
        0x0080fde0:    f43cf6ec    <...    BL       le_gap_init ; 0x4cbbc
;;;344        gap_lib_init();
        0x0080fde4:    f000fc6a    ..j.    BL       gap_lib_init ; 0x8106bc
;;;345        app_le_gap_init();
        0x0080fde8:    f7fffe96    ....    BL       app_le_gap_init ; 0x80fb18
;;;346        app_le_profile_init();
        0x0080fdec:    f7ffff42    ..B.    BL       app_le_profile_init ; 0x80fc74
;;;347        pwr_mgr_init();
        0x0080fdf0:    f7ffffd6    ....    BL       pwr_mgr_init ; 0x80fda0
;;;348        swTimerInit();
        0x0080fdf4:    f7fffe0d    ....    BL       swTimerInit ; 0x80fa12
        0x0080fdf8:    f7fffc04    ....    BL       app_task_init ; 0x80f604
;;;349        task_init();
;;;350        os_sched_start();
        0x0080fdfc:    f416f4e1    ....    BL       os_sched_start ; 0x267c2
;;;351    
;;;352        return 0;
        0x0080fe00:    2000        .       MOVS     r0,#0
;;;353    }
        0x0080fe02:    bd10        ..      POP      {r4,pc}
    $d
        0x0080fe04:    00810e64    d...    DCD    8457828
        0x0080fe08:    00207e9d    .~ .    DCD    2129565
        0x0080fe0c:    008102b7    ....    DCD    8454839
        0x0080fe10:    00810305    ....    DCD    8454917
        0x0080fe14:    002080d5    .. .    DCD    2130133
        0x0080fe18:    002080d6    .. .    DCD    2130134
        0x0080fe1c:    002080d7    .. .    DCD    2130135
        0x0080fe20:    002080d8    .. .    DCD    2130136
        0x0080fe24:    002080d9    .. .    DCD    2130137
        0x0080fe28:    002080da    .. .    DCD    2130138
        0x0080fe2c:    08800660    `...    DCD    142607968
        0x0080fe30:    21103002    .0.!    DCD    554708994
        0x0080fe34:    002080ba    .. .    DCD    2130106
        0x0080fe38:    6f727245    Erro    DCD    1869771333
        0x0080fe3c:    64203a72    r: d    DCD    1679833714
        0x0080fe40:    5f73706c    lps_    DCD    1601400940
        0x0080fe44:    63656863    chec    DCD    1667590243
        0x0080fe48:    62635f6b    k_cb    DCD    1650679659
        0x0080fe4c:    6765725f    _reg    DCD    1734701663
        0x0080fe50:    504c4428    (DLP    DCD    1347175464
        0x0080fe54:    63525f53    S_Rc    DCD    1666342739
        0x0080fe58:    65684375    uChe    DCD    1701331829
        0x0080fe5c:    20296b63    ck)     DCD    539585379
        0x0080fe60:    6c696166    fail    DCD    1818845542
        0x0080fe64:    0a216465    ed!.    DCD    169960549
        0x0080fe68:    00000000    ....    DCD    0
        0x0080fe6c:    00207f34    4. .    DCD    2129716
        0x0080fe70:    00207f30    0. .    DCD    2129712
    $t
    .text
    app_handle_authen_state_evt
;;; ..\include\SDK\src\app\pxp\pxp_app.c
;;;241    {
        0x0080fe74:    b5f8        ..      PUSH     {r3-r7,lr}
        0x0080fe76:    4efa        .N      LDR      r6,[pc,#1000] ; [0x810260] = 0x21103002
;;; ..\include\SDK\src\app\pxp\pxp_app.c (241)
        0x0080fe78:    4615        .F      MOV      r5,r2
        0x0080fe7a:    460c        .F      MOV      r4,r1
;;;242        APP_PRINT_INFO2("app_handle_authen_state_evt:conn_id %d, cause 0x%x", conn_id, cause);
        0x0080fe7c:    4603        .F      MOV      r3,r0
        0x0080fe7e:    9200        ..      STR      r2,[sp,#0]
        0x0080fe80:    2202        ."      MOVS     r2,#2
        0x0080fe82:    49f6        .I      LDR      r1,[pc,#984] ; [0x81025c] = 0x8800880
        0x0080fe84:    4630        0F      MOV      r0,r6
        0x0080fe86:    f7f7ddea    ....    BL       log_buffer ; 0x7a5e
;;;243    
;;;244        switch (new_state)
        0x0080fe8a:    b154        T.      CBZ      r4,0x80fea2 ; app_handle_authen_state_evt + 46
        0x0080fe8c:    2c01        .,      CMP      r4,#1
        0x0080fe8e:    d00c        ..      BEQ      0x80feaa ; app_handle_authen_state_evt + 54
        0x0080fe90:    2201        ."      MOVS     r2,#1
        0x0080fe92:    b001        ..      ADD      sp,sp,#4
        0x0080fe94:    4623        #F      MOV      r3,r4
        0x0080fe96:    1eb0        ..      SUBS     r0,r6,#2
        0x0080fe98:    e8bd40f0    ...@    POP      {r4-r7,lr}
        0x0080fe9c:    49f1        .I      LDR      r1,[pc,#964] ; [0x810264] = 0x8800984
        0x0080fe9e:    f7f79dde    ....    B        log_buffer ; 0x7a5e
;;;245        {
;;;246        case GAP_AUTHEN_STATE_STARTED:
;;;247            {
;;;248                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
        0x0080fea2:    49ee        .I      LDR      r1,[pc,#952] ; [0x81025c] = 0x8800880
        0x0080fea4:    2200        ."      MOVS     r2,#0
        0x0080fea6:    3138        81      ADDS     r1,r1,#0x38
;;;249            }
;;;250            break;
        0x0080fea8:    e003        ..      B        0x80feb2 ; app_handle_authen_state_evt + 62
;;;251    
;;;252        case GAP_AUTHEN_STATE_COMPLETE:
;;;253            {
;;;254                if (cause == GAP_SUCCESS)
        0x0080feaa:    b13d        =.      CBZ      r5,0x80febc ; app_handle_authen_state_evt + 72
        0x0080feac:    49ed        .I      LDR      r1,[pc,#948] ; [0x810264] = 0x8800984
        0x0080feae:    2200        ."      MOVS     r2,#0
        0x0080feb0:    3948        H9      SUBS     r1,r1,#0x48
        0x0080feb2:    4630        0F      MOV      r0,r6
        0x0080feb4:    e8bd40f8    ...@    POP      {r3-r7,lr}
        0x0080feb8:    f7f79dd1    ....    B        log_buffer ; 0x7a5e
;;;255                {
;;;256                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, 1);
        0x0080febc:    2301        .#      MOVS     r3,#1
        0x0080febe:    2203        ."      MOVS     r2,#3
        0x0080fec0:    2164        d!      MOVS     r1,#0x64
        0x0080fec2:    f44f7061    O.ap    MOV      r0,#0x384
        0x0080fec6:    f7fffc94    ....    BL       StartPxpIO ; 0x80f7f2
;;;257    
;;;258                    ChangeConnectionParameter(400, 0, 2000); //interval = 400*1.25ms
        0x0080feca:    f44f62fa    O..b    MOV      r2,#0x7d0
        0x0080fece:    2100        .!      MOVS     r1,#0
        0x0080fed0:    f44f70c8    O..p    MOV      r0,#0x190
        0x0080fed4:    f7fffdf0    ....    BL       ChangeConnectionParameter ; 0x80fab8
;;;259                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
        0x0080fed8:    49e0        .I      LDR      r1,[pc,#896] ; [0x81025c] = 0x8800880
        0x0080feda:    2200        ."      MOVS     r2,#0
        0x0080fedc:    3174        t1      ADDS     r1,r1,#0x74
        0x0080fede:    e7e8        ..      B        0x80feb2 ; app_handle_authen_state_evt + 62
    app_handle_conn_param_update_evt
;;;260    
;;;261                }
;;;262                else
;;;263                {
;;;264                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;265                }
;;;266            }
;;;267            break;
;;;268    
;;;269        default:
;;;270            {
;;;271                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;272            }
;;;273            break;
;;;274        }
;;;275    }
;;;276    
;;;277    /**
;;;278     * @brief    Handle msg GAP_MSG_LE_CONN_MTU_INFO
;;;279     * @note     This msg is used to inform APP that exchange mtu procedure is completed.
;;;280     * @param[in] conn_id Connection ID
;;;281     * @param[in] mtu_size  New mtu size
;;;282     * @return   void
;;;283     */
;;;284    void app_handle_conn_mtu_info_evt(uint8_t conn_id, uint16_t mtu_size)
;;;285    {
;;;286        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
;;;287    }
;;;288    
;;;289    
;;;290    /**
;;;291     * @brief    Handle msg GAP_MSG_LE_CONN_PARAM_UPDATE
;;;292     * @note     All the connection parameter update change  events are pre-handled in this function.
;;;293     * @param[in] conn_id Connection ID
;;;294     * @param[in] status  New update state
;;;295     * @param[in] cause Use this cause when status is GAP_CONN_PARAM_UPDATE_STATUS_FAIL
;;;296     * @return   void
;;;297     */
;;;298    void app_handle_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;299    {
        0x0080fee0:    b530        0.      PUSH     {r4,r5,lr}
        0x0080fee2:    4cdf        .L      LDR      r4,[pc,#892] ; [0x810260] = 0x21103002
;;; ..\include\SDK\src\app\pxp\pxp_app.c (299)
        0x0080fee4:    b085        ..      SUB      sp,sp,#0x14
        0x0080fee6:    4605        .F      MOV      r5,r0
        0x0080fee8:    b159        Y.      CBZ      r1,0x80ff02 ; app_handle_conn_param_update_evt + 34
;;;300        switch (status)
        0x0080feea:    2901        .)      CMP      r1,#1
        0x0080feec:    d02b        +.      BEQ      0x80ff46 ; app_handle_conn_param_update_evt + 102
        0x0080feee:    2902        .)      CMP      r1,#2
        0x0080fef0:    d127        '.      BNE      0x80ff42 ; app_handle_conn_param_update_evt + 98
        0x0080fef2:    b005        ..      ADD      sp,sp,#0x14
        0x0080fef4:    4620         F      MOV      r0,r4
        0x0080fef6:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x0080fefa:    2200        ."      MOVS     r2,#0
        0x0080fefc:    49da        .I      LDR      r1,[pc,#872] ; [0x810268] = 0x8800ab4
        0x0080fefe:    f7f79dae    ....    B        log_buffer ; 0x7a5e
;;;301        {
;;;302        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;303            {
;;;304                uint16_t conn_interval;
;;;305                uint16_t conn_slave_latency;
;;;306                uint16_t conn_supervision_timeout;
;;;307    
;;;308                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
        0x0080ff02:    4602        .F      MOV      r2,r0
        0x0080ff04:    a904        ..      ADD      r1,sp,#0x10
        0x0080ff06:    f2402072    @.r     MOV      r0,#0x272
        0x0080ff0a:    f43df5b8    =...    BL       le_get_conn_param ; 0x4da7e
;;;309                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
        0x0080ff0e:    462a        *F      MOV      r2,r5
        0x0080ff10:    a903        ..      ADD      r1,sp,#0xc
        0x0080ff12:    f2402073    @.s     MOV      r0,#0x273
        0x0080ff16:    f43df5b2    =...    BL       le_get_conn_param ; 0x4da7e
;;;310                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
        0x0080ff1a:    462a        *F      MOV      r2,r5
        0x0080ff1c:    a902        ..      ADD      r1,sp,#8
        0x0080ff1e:    f44f701d    O..p    MOV      r0,#0x274
        0x0080ff22:    f43df5ac    =...    BL       le_get_conn_param ; 0x4da7e
;;;311                APP_PRINT_INFO3("app_handle_conn_param_update_evt update success:conn_interval 0x%x, conn_slave_latency 0x%x, conn_supervision_timeout 0x%x",
        0x0080ff26:    f8bd1008    ....    LDRH     r1,[sp,#8]
        0x0080ff2a:    f8bd000c    ....    LDRH     r0,[sp,#0xc]
        0x0080ff2e:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0080ff32:    49cc        .I      LDR      r1,[pc,#816] ; [0x810264] = 0x8800984
        0x0080ff34:    f8bd3010    ...0    LDRH     r3,[sp,#0x10]
        0x0080ff38:    2203        ."      MOVS     r2,#3
        0x0080ff3a:    3170        p1      ADDS     r1,r1,#0x70
        0x0080ff3c:    4620         F      MOV      r0,r4
        0x0080ff3e:    f7f7dd8e    ....    BL       log_buffer ; 0x7a5e
        0x0080ff42:    b005        ..      ADD      sp,sp,#0x14
        0x0080ff44:    bd30        0.      POP      {r4,r5,pc}
;;;312                                conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;313            }
;;;314            break;
;;;315    
;;;316        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;317            {
;;;318                APP_PRINT_ERROR1("app_handle_conn_param_update_evt update failed: cause 0x%x", cause);
        0x0080ff46:    b005        ..      ADD      sp,sp,#0x14
        0x0080ff48:    49c7        .I      LDR      r1,[pc,#796] ; [0x810268] = 0x8800ab4
        0x0080ff4a:    4613        .F      MOV      r3,r2
        0x0080ff4c:    48c4        .H      LDR      r0,[pc,#784] ; [0x810260] = 0x21103002
        0x0080ff4e:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x0080ff52:    2201        ."      MOVS     r2,#1
        0x0080ff54:    3940        @9      SUBS     r1,r1,#0x40
        0x0080ff56:    1e80        ..      SUBS     r0,r0,#2
        0x0080ff58:    f7f79d81    ....    B        log_buffer ; 0x7a5e
    app_handle_conn_mtu_info_evt
        0x0080ff5c:    b508        ..      PUSH     {r3,lr}
        0x0080ff5e:    4603        .F      MOV      r3,r0
        0x0080ff60:    9100        ..      STR      r1,[sp,#0]
        0x0080ff62:    49c0        .I      LDR      r1,[pc,#768] ; [0x810264] = 0x8800984
        0x0080ff64:    2202        ."      MOVS     r2,#2
        0x0080ff66:    3134        41      ADDS     r1,r1,#0x34
        0x0080ff68:    48bd        .H      LDR      r0,[pc,#756] ; [0x810260] = 0x21103002
        0x0080ff6a:    f7f7dd78    ..x.    BL       log_buffer ; 0x7a5e
        0x0080ff6e:    bd08        ..      POP      {r3,pc}
    app_handle_conn_state_evt
;;; ..\include\SDK\src\app\pxp\pxp_app.c (170)
        0x0080ff70:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0080ff74:    4dbd        .M      LDR      r5,[pc,#756] ; [0x81026c] = 0x2080d0
;;; ..\include\SDK\src\app\pxp\pxp_app.c (170)
        0x0080ff76:    4680        .F      MOV      r8,r0
        0x0080ff78:    b08a        ..      SUB      sp,sp,#0x28
        0x0080ff7a:    4616        .F      MOV      r6,r2
        0x0080ff7c:    460c        .F      MOV      r4,r1
;;;171        APP_PRINT_INFO4("app_handle_conn_state_evt: conn_id %d old_state %d new_state %d, disc_cause 0x%x",
        0x0080ff7e:    7928        (y      LDRB     r0,[r5,#4]
        0x0080ff80:    4fb7        .O      LDR      r7,[pc,#732] ; [0x810260] = 0x21103002
        0x0080ff82:    e88d0051    ..Q.    STM      sp,{r0,r4,r6}
        0x0080ff86:    4643        CF      MOV      r3,r8
        0x0080ff88:    2204        ."      MOVS     r2,#4
        0x0080ff8a:    49b9        .I      LDR      r1,[pc,#740] ; [0x810270] = 0x8800748
        0x0080ff8c:    4638        8F      MOV      r0,r7
        0x0080ff8e:    f7f7dd66    ..f.    BL       log_buffer ; 0x7a5e
;;;172                        conn_id, gap_conn_state, new_state, disc_cause);
;;;173        switch (new_state)
        0x0080ff92:    b114        ..      CBZ      r4,0x80ff9a ; app_handle_conn_state_evt + 42
        0x0080ff94:    2c02        .,      CMP      r4,#2
        0x0080ff96:    d163        c.      BNE      0x810060 ; app_handle_conn_state_evt + 240
        0x0080ff98:    e034        4.      B        0x810004 ; app_handle_conn_state_evt + 148
        0x0080ff9a:    4fb1        .O      LDR      r7,[pc,#708] ; [0x810260] = 0x21103002
;;;174        {
;;;175        case GAP_CONN_STATE_DISCONNECTED:
;;;176            {
;;;177                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
        0x0080ff9c:    f5a67080    ...p    SUB      r0,r6,#0x100
        0x0080ffa0:    1ebf        ..      SUBS     r7,r7,#2
        0x0080ffa2:    3813        .8      SUBS     r0,r0,#0x13
        0x0080ffa4:    d009        ..      BEQ      0x80ffba ; app_handle_conn_state_evt + 74
;;;178                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
        0x0080ffa6:    f5b67f8b    ....    CMP      r6,#0x116
        0x0080ffaa:    d006        ..      BEQ      0x80ffba ; app_handle_conn_state_evt + 74
;;;179                {
;;;180                    APP_PRINT_ERROR1("app_handle_conn_state_evt: connection lost cause 0x%x", disc_cause);
        0x0080ffac:    49b0        .I      LDR      r1,[pc,#704] ; [0x810270] = 0x8800748
        0x0080ffae:    4633        3F      MOV      r3,r6
        0x0080ffb0:    2201        ."      MOVS     r2,#1
        0x0080ffb2:    3154        T1      ADDS     r1,r1,#0x54
        0x0080ffb4:    4638        8F      MOV      r0,r7
        0x0080ffb6:    f7f7dd52    ..R.    BL       log_buffer ; 0x7a5e
;;;181                }
;;;182                gPxpState = PxpStateIdle;
        0x0080ffba:    2000        .       MOVS     r0,#0
        0x0080ffbc:    7028        (p      STRB     r0,[r5,#0]
;;;183                if (gPowerFlg == true)
        0x0080ffbe:    78a8        .x      LDRB     r0,[r5,#2]
        0x0080ffc0:    b1f8        ..      CBZ      r0,0x810002 ; app_handle_conn_state_evt + 146
;;;184                {
;;;185                    le_adv_start();
        0x0080ffc2:    f442f080    B...    BL       le_adv_start ; 0x520c6
;;;186                    APP_PRINT_ERROR1("g_pxp_linkloss_alert_level is %d", g_pxp_linkloss_alert_level);
        0x0080ffc6:    4eab        .N      LDR      r6,[pc,#684] ; [0x810274] = 0x207eb4
        0x0080ffc8:    49a9        .I      LDR      r1,[pc,#676] ; [0x810270] = 0x8800748
        0x0080ffca:    2201        ."      MOVS     r2,#1
        0x0080ffcc:    7833        3x      LDRB     r3,[r6,#0]
        0x0080ffce:    3190        .1      ADDS     r1,r1,#0x90
        0x0080ffd0:    4638        8F      MOV      r0,r7
        0x0080ffd2:    f7f7dd44    ..D.    BL       log_buffer ; 0x7a5e
;;;187                    gIoState = IoStateLlsAlert;
        0x0080ffd6:    2003        .       MOVS     r0,#3
        0x0080ffd8:    7068        hp      STRB     r0,[r5,#1]
;;;188                    if (g_pxp_linkloss_alert_level == 1)
        0x0080ffda:    7830        0x      LDRB     r0,[r6,#0]
        0x0080ffdc:    f44f7761    O.aw    MOV      r7,#0x384
        0x0080ffe0:    2801        .(      CMP      r0,#1
        0x0080ffe2:    d105        ..      BNE      0x80fff0 ; app_handle_conn_state_evt + 128
;;;189                    {
;;;190                        StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK, LL_ASSERT_TIME);
        0x0080ffe4:    2201        ."      MOVS     r2,#1
        0x0080ffe6:    2164        d!      MOVS     r1,#0x64
        0x0080ffe8:    4638        8F      MOV      r0,r7
        0x0080ffea:    6873        sh      LDR      r3,[r6,#4]
        0x0080ffec:    f7fffc01    ....    BL       StartPxpIO ; 0x80f7f2
;;;191                    }
;;;192                    if (g_pxp_linkloss_alert_level == 2)
        0x0080fff0:    7830        0x      LDRB     r0,[r6,#0]
        0x0080fff2:    2802        .(      CMP      r0,#2
        0x0080fff4:    d134        4.      BNE      0x810060 ; app_handle_conn_state_evt + 240
;;;193                    {
;;;194                        StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, LL_ASSERT_TIME);
        0x0080fff6:    2203        ."      MOVS     r2,#3
        0x0080fff8:    2164        d!      MOVS     r1,#0x64
        0x0080fffa:    4638        8F      MOV      r0,r7
        0x0080fffc:    6873        sh      LDR      r3,[r6,#4]
        0x0080fffe:    f7fffbf8    ....    BL       StartPxpIO ; 0x80f7f2
        0x00810002:    e02d        -.      B        0x810060 ; app_handle_conn_state_evt + 240
;;;195                    }
;;;196                    else
;;;197                    {
;;;198                        //nothing to do
;;;199                    }
;;;200                }
;;;201            }
;;;202            break;
;;;203    
;;;204        case GAP_CONN_STATE_CONNECTED:
;;;205            {
;;;206                uint16_t conn_interval;
;;;207                uint16_t conn_latency;
;;;208                uint16_t conn_supervision_timeout;
;;;209                uint8_t  remote_bd[6];
;;;210                T_GAP_REMOTE_ADDR_TYPE remote_bd_type;
;;;211    
;;;212                gPxpState = PxpStateLink;
        0x00810004:    2002        .       MOVS     r0,#2
        0x00810006:    7028        (p      STRB     r0,[r5,#0]
;;;213    
;;;214                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
        0x00810008:    4642        BF      MOV      r2,r8
        0x0081000a:    a906        ..      ADD      r1,sp,#0x18
        0x0081000c:    f2402072    @.r     MOV      r0,#0x272
        0x00810010:    f43df535    =.5.    BL       le_get_conn_param ; 0x4da7e
;;;215                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_latency, conn_id);
        0x00810014:    4642        BF      MOV      r2,r8
        0x00810016:    a908        ..      ADD      r1,sp,#0x20
        0x00810018:    f2402073    @.s     MOV      r0,#0x273
        0x0081001c:    f43df52f    =./.    BL       le_get_conn_param ; 0x4da7e
;;;216                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
        0x00810020:    4642        BF      MOV      r2,r8
        0x00810022:    a909        ..      ADD      r1,sp,#0x24
        0x00810024:    f44f701d    O..p    MOV      r0,#0x274
        0x00810028:    f43df529    =.).    BL       le_get_conn_param ; 0x4da7e
;;;217                le_get_conn_addr(conn_id, remote_bd, &remote_bd_type);
        0x0081002c:    aa07        ..      ADD      r2,sp,#0x1c
        0x0081002e:    a904        ..      ADD      r1,sp,#0x10
        0x00810030:    4640        @F      MOV      r0,r8
        0x00810032:    f43df5dc    =...    BL       le_get_conn_addr ; 0x4dbee
;;;218                APP_PRINT_INFO5("GAP_CONN_STATE_CONNECTED:remote_bd %s, remote_addr_type %d, conn_interval 0x%x, conn_latency 0x%x, conn_supervision_timeout 0x%x",
        0x00810036:    a904        ..      ADD      r1,sp,#0x10
        0x00810038:    488f        .H      LDR      r0,[pc,#572] ; [0x810278] = 0x21300000
        0x0081003a:    f7f7decd    ....    BL       trace_bdaddr ; 0x7dd8
        0x0081003e:    4603        .F      MOV      r3,r0
        0x00810040:    f89d001c    ....    LDRB     r0,[sp,#0x1c]
        0x00810044:    f8bd6024    ..$`    LDRH     r6,[sp,#0x24]
        0x00810048:    f8bd2020    ..      LDRH     r2,[sp,#0x20]
        0x0081004c:    f8bd1018    ....    LDRH     r1,[sp,#0x18]
        0x00810050:    e88d0047    ..G.    STM      sp,{r0-r2,r6}
        0x00810054:    4981        .I      LDR      r1,[pc,#516] ; [0x81025c] = 0x8800880
        0x00810056:    2205        ."      MOVS     r2,#5
        0x00810058:    3984        .9      SUBS     r1,r1,#0x84
        0x0081005a:    4638        8F      MOV      r0,r7
        0x0081005c:    f7f7dcff    ....    BL       log_buffer ; 0x7a5e
;;;219                                TRACE_BDADDR(remote_bd), remote_bd_type,
;;;220                                conn_interval, conn_latency, conn_supervision_timeout);
;;;221            }
;;;222            break;
;;;223    
;;;224        default:
;;;225            break;
;;;226        }
;;;227        gap_conn_state = new_state;
        0x00810060:    712c        ,q      STRB     r4,[r5,#4]
;;;228    }
        0x00810062:    b00a        ..      ADD      sp,sp,#0x28
        0x00810064:    e8bd81f0    ....    POP      {r4-r8,pc}
    app_handle_dev_state_evt
        0x00810068:    e92d47fc    -..G    PUSH     {r2-r10,lr}
        0x0081006c:    b2c4        ..      UXTB     r4,r0
;;; ..\include\SDK\src\app\pxp\pxp_app.c (119)
        0x0081006e:    f3c40581    ....    UBFX     r5,r4,#2,#2
        0x00810072:    e9cd5100    ...Q    STRD     r5,r1,[sp,#0]
        0x00810076:    497e        ~I      LDR      r1,[pc,#504] ; [0x810270] = 0x8800748
        0x00810078:    f8dfa1e4    ....    LDR      r10,[pc,#484] ; [0x810260] = 0x21103002
        0x0081007c:    f0040701    ....    AND      r7,r4,#1
        0x00810080:    463b        ;F      MOV      r3,r7
        0x00810082:    2203        ."      MOVS     r2,#3
        0x00810084:    39b4        .9      SUBS     r1,r1,#0xb4
        0x00810086:    4650        PF      MOV      r0,r10
        0x00810088:    f7f7dce9    ....    BL       log_buffer ; 0x7a5e
;;;120                        new_state.gap_init_state, new_state.gap_adv_state, cause);
;;;121        if (gap_dev_state.gap_init_state != new_state.gap_init_state)
        0x0081008c:    f8df91dc    ....    LDR      r9,[pc,#476] ; [0x81026c] = 0x2080d0
        0x00810090:    4e76        vN      LDR      r6,[pc,#472] ; [0x81026c] = 0x2080d0
        0x00810092:    f1090903    ....    ADD      r9,r9,#3
        0x00810096:    f04f0800    O...    MOV      r8,#0
        0x0081009a:    f8990000    ....    LDRB     r0,[r9,#0]
        0x0081009e:    f0000001    ....    AND      r0,r0,#1
        0x008100a2:    42b8        .B      CMP      r0,r7
        0x008100a4:    d009        ..      BEQ      0x8100ba ; app_handle_dev_state_evt + 82
;;;122        {
;;;123            if (new_state.gap_init_state == GAP_INIT_STATE_STACK_READY)
        0x008100a6:    07e0        ..      LSLS     r0,r4,#31
        0x008100a8:    d007        ..      BEQ      0x8100ba ; app_handle_dev_state_evt + 82
;;;124            {
;;;125                APP_PRINT_INFO0("GAP stack ready");
        0x008100aa:    4971        qI      LDR      r1,[pc,#452] ; [0x810270] = 0x8800748
        0x008100ac:    2200        ."      MOVS     r2,#0
        0x008100ae:    396c        l9      SUBS     r1,r1,#0x6c
        0x008100b0:    4650        PF      MOV      r0,r10
        0x008100b2:    f7f7dcd4    ....    BL       log_buffer ; 0x7a5e
;;;126                gPowerFlg = false;
        0x008100b6:    f8868002    ....    STRB     r8,[r6,#2]
;;;127            }
;;;128        }
;;;129    
;;;130        if (gap_dev_state.gap_adv_state != new_state.gap_adv_state)
        0x008100ba:    f8990000    ....    LDRB     r0,[r9,#0]
        0x008100be:    f3c00081    ....    UBFX     r0,r0,#2,#2
        0x008100c2:    42a8        .B      CMP      r0,r5
        0x008100c4:    d027        '.      BEQ      0x810116 ; app_handle_dev_state_evt + 174
;;;131        {
;;;132            if (new_state.gap_adv_state == GAP_ADV_STATE_IDLE)
        0x008100c6:    f0140f0c    ....    TST      r4,#0xc
        0x008100ca:    d002        ..      BEQ      0x8100d2 ; app_handle_dev_state_evt + 106
        0x008100cc:    2d02        .-      CMP      r5,#2
        0x008100ce:    d00f        ..      BEQ      0x8100f0 ; app_handle_dev_state_evt + 136
        0x008100d0:    e021        !.      B        0x810116 ; app_handle_dev_state_evt + 174
;;;133            {
;;;134                if (new_state.gap_adv_sub_state == GAP_ADV_TO_IDLE_CAUSE_CONN)
        0x008100d2:    07a0        ..      LSLS     r0,r4,#30
        0x008100d4:    d503        ..      BPL      0x8100de ; app_handle_dev_state_evt + 118
;;;135                {
;;;136                    APP_PRINT_INFO0("GAP adv stoped: because connection created");
        0x008100d6:    4966        fI      LDR      r1,[pc,#408] ; [0x810270] = 0x8800748
        0x008100d8:    2200        ."      MOVS     r2,#0
        0x008100da:    3958        X9      SUBS     r1,r1,#0x58
        0x008100dc:    e004        ..      B        0x8100e8 ; app_handle_dev_state_evt + 128
        0x008100de:    4964        dI      LDR      r1,[pc,#400] ; [0x810270] = 0x8800748
        0x008100e0:    2200        ."      MOVS     r2,#0
;;;137                }
;;;138                else
;;;139                {
;;;140                    gPxpState = PxpStateIdle;
        0x008100e2:    f8868000    ....    STRB     r8,[r6,#0]
;;;141                    APP_PRINT_INFO0("GAP adv stoped");
        0x008100e6:    3928        (9      SUBS     r1,r1,#0x28
        0x008100e8:    4650        PF      MOV      r0,r10
        0x008100ea:    f7f7dcb8    ....    BL       log_buffer ; 0x7a5e
        0x008100ee:    e012        ..      B        0x810116 ; app_handle_dev_state_evt + 174
;;;142                }
;;;143            }
;;;144            else if (new_state.gap_adv_state == GAP_ADV_STATE_ADVERTISING)
;;;145            {
;;;146                APP_PRINT_INFO0("GAP adv start");
        0x008100f0:    495f        _I      LDR      r1,[pc,#380] ; [0x810270] = 0x8800748
        0x008100f2:    2200        ."      MOVS     r2,#0
        0x008100f4:    3914        .9      SUBS     r1,r1,#0x14
        0x008100f6:    4650        PF      MOV      r0,r10
        0x008100f8:    f7f7dcb1    ....    BL       log_buffer ; 0x7a5e
;;;147                gPxpState = PxpStateAdv;
        0x008100fc:    2501        .%      MOVS     r5,#1
        0x008100fe:    7035        5p      STRB     r5,[r6,#0]
;;;148                if (gIoState != IoStateLlsAlert)
        0x00810100:    7870        px      LDRB     r0,[r6,#1]
        0x00810102:    2803        .(      CMP      r0,#3
        0x00810104:    d007        ..      BEQ      0x810116 ; app_handle_dev_state_evt + 174
;;;149                {
;;;150                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK,
        0x00810106:    230a        .#      MOVS     r3,#0xa
        0x00810108:    2201        ."      MOVS     r2,#1
        0x0081010a:    2164        d!      MOVS     r1,#0x64
        0x0081010c:    f44f7061    O.ap    MOV      r0,#0x384
        0x00810110:    f7fffb6f    ..o.    BL       StartPxpIO ; 0x80f7f2
;;;151                               10); /*low period 0.9s, high period 0.1s,  led blink,  10times(cnt)*/
;;;152                    gIoState = IoStateAdvBlink;
        0x00810114:    7075        up      STRB     r5,[r6,#1]
;;;153                }
;;;154            }
;;;155        }
;;;156    
;;;157        gap_dev_state = new_state;
        0x00810116:    70f4        .p      STRB     r4,[r6,#3]
;;;158    }
        0x00810118:    e8bd87fc    ....    POP      {r2-r10,pc}
    app_handle_gap_msg
;;;159    
;;;160    /**
;;;161     * @brief    Handle msg GAP_MSG_LE_CONN_STATE_CHANGE
;;;162     * @note     All the gap conn state events are pre-handled in this function.
;;;163     *           Then the event handling function shall be called according to the new_state
;;;164     * @param[in] conn_id Connection ID
;;;165     * @param[in] new_state  New gap connection state
;;;166     * @param[in] disc_cause Use this cause when new_state is GAP_CONN_STATE_DISCONNECTED
;;;167     * @return   void
;;;168     */
;;;169    void app_handle_conn_state_evt(uint8_t conn_id, T_GAP_CONN_STATE new_state, uint16_t disc_cause)
;;;170    {
;;;171        APP_PRINT_INFO4("app_handle_conn_state_evt: conn_id %d old_state %d new_state %d, disc_cause 0x%x",
;;;172                        conn_id, gap_conn_state, new_state, disc_cause);
;;;173        switch (new_state)
;;;174        {
;;;175        case GAP_CONN_STATE_DISCONNECTED:
;;;176            {
;;;177                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
;;;178                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
;;;179                {
;;;180                    APP_PRINT_ERROR1("app_handle_conn_state_evt: connection lost cause 0x%x", disc_cause);
;;;181                }
;;;182                gPxpState = PxpStateIdle;
;;;183                if (gPowerFlg == true)
;;;184                {
;;;185                    le_adv_start();
;;;186                    APP_PRINT_ERROR1("g_pxp_linkloss_alert_level is %d", g_pxp_linkloss_alert_level);
;;;187                    gIoState = IoStateLlsAlert;
;;;188                    if (g_pxp_linkloss_alert_level == 1)
;;;189                    {
;;;190                        StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK, LL_ASSERT_TIME);
;;;191                    }
;;;192                    if (g_pxp_linkloss_alert_level == 2)
;;;193                    {
;;;194                        StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, LL_ASSERT_TIME);
;;;195                    }
;;;196                    else
;;;197                    {
;;;198                        //nothing to do
;;;199                    }
;;;200                }
;;;201            }
;;;202            break;
;;;203    
;;;204        case GAP_CONN_STATE_CONNECTED:
;;;205            {
;;;206                uint16_t conn_interval;
;;;207                uint16_t conn_latency;
;;;208                uint16_t conn_supervision_timeout;
;;;209                uint8_t  remote_bd[6];
;;;210                T_GAP_REMOTE_ADDR_TYPE remote_bd_type;
;;;211    
;;;212                gPxpState = PxpStateLink;
;;;213    
;;;214                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;215                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_latency, conn_id);
;;;216                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;217                le_get_conn_addr(conn_id, remote_bd, &remote_bd_type);
;;;218                APP_PRINT_INFO5("GAP_CONN_STATE_CONNECTED:remote_bd %s, remote_addr_type %d, conn_interval 0x%x, conn_latency 0x%x, conn_supervision_timeout 0x%x",
;;;219                                TRACE_BDADDR(remote_bd), remote_bd_type,
;;;220                                conn_interval, conn_latency, conn_supervision_timeout);
;;;221            }
;;;222            break;
;;;223    
;;;224        default:
;;;225            break;
;;;226        }
;;;227        gap_conn_state = new_state;
;;;228    }
;;;229    
;;;230    
;;;231    /**
;;;232     * @brief    Handle msg GAP_MSG_LE_AUTHEN_STATE_CHANGE
;;;233     * @note     All the gap authentication state events are pre-handled in this function.
;;;234     *           Then the event handling function shall be called according to the new_state
;;;235     * @param[in] conn_id Connection ID
;;;236     * @param[in] new_state  New authentication state
;;;237     * @param[in] cause Use this cause when new_state is GAP_AUTHEN_STATE_COMPLETE
;;;238     * @return   void
;;;239     */
;;;240    void app_handle_authen_state_evt(uint8_t conn_id, uint8_t new_state, uint16_t cause)
;;;241    {
;;;242        APP_PRINT_INFO2("app_handle_authen_state_evt:conn_id %d, cause 0x%x", conn_id, cause);
;;;243    
;;;244        switch (new_state)
;;;245        {
;;;246        case GAP_AUTHEN_STATE_STARTED:
;;;247            {
;;;248                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
;;;249            }
;;;250            break;
;;;251    
;;;252        case GAP_AUTHEN_STATE_COMPLETE:
;;;253            {
;;;254                if (cause == GAP_SUCCESS)
;;;255                {
;;;256                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, 1);
;;;257    
;;;258                    ChangeConnectionParameter(400, 0, 2000); //interval = 400*1.25ms
;;;259                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
;;;260    
;;;261                }
;;;262                else
;;;263                {
;;;264                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;265                }
;;;266            }
;;;267            break;
;;;268    
;;;269        default:
;;;270            {
;;;271                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;272            }
;;;273            break;
;;;274        }
;;;275    }
;;;276    
;;;277    /**
;;;278     * @brief    Handle msg GAP_MSG_LE_CONN_MTU_INFO
;;;279     * @note     This msg is used to inform APP that exchange mtu procedure is completed.
;;;280     * @param[in] conn_id Connection ID
;;;281     * @param[in] mtu_size  New mtu size
;;;282     * @return   void
;;;283     */
;;;284    void app_handle_conn_mtu_info_evt(uint8_t conn_id, uint16_t mtu_size)
;;;285    {
;;;286        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
;;;287    }
;;;288    
;;;289    
;;;290    /**
;;;291     * @brief    Handle msg GAP_MSG_LE_CONN_PARAM_UPDATE
;;;292     * @note     All the connection parameter update change  events are pre-handled in this function.
;;;293     * @param[in] conn_id Connection ID
;;;294     * @param[in] status  New update state
;;;295     * @param[in] cause Use this cause when status is GAP_CONN_PARAM_UPDATE_STATUS_FAIL
;;;296     * @return   void
;;;297     */
;;;298    void app_handle_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;299    {
;;;300        switch (status)
;;;301        {
;;;302        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;303            {
;;;304                uint16_t conn_interval;
;;;305                uint16_t conn_slave_latency;
;;;306                uint16_t conn_supervision_timeout;
;;;307    
;;;308                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;309                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
;;;310                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;311                APP_PRINT_INFO3("app_handle_conn_param_update_evt update success:conn_interval 0x%x, conn_slave_latency 0x%x, conn_supervision_timeout 0x%x",
;;;312                                conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;313            }
;;;314            break;
;;;315    
;;;316        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;317            {
;;;318                APP_PRINT_ERROR1("app_handle_conn_param_update_evt update failed: cause 0x%x", cause);
;;;319            }
;;;320            break;
;;;321    
;;;322        case GAP_CONN_PARAM_UPDATE_STATUS_PENDING:
;;;323            {
;;;324                APP_PRINT_INFO0("app_handle_conn_param_update_evt update pending.");
;;;325            }
;;;326            break;
;;;327    
;;;328        default:
;;;329            break;
;;;330        }
;;;331    }
;;;332    
;;;333    
;;;334    /**
;;;335     * @brief    All the BT GAP MSG are pre-handled in this function.
;;;336     * @note     Then the event handling function shall be called according to the
;;;337     *           subtype of T_IO_MSG
;;;338     * @param[in] p_gap_msg Pointer to GAP msg
;;;339     * @return   void
;;;340     */
;;;341    void app_handle_gap_msg(T_IO_MSG *p_gap_msg)
;;;342    {
        0x0081011c:    b57f        ..      PUSH     {r0-r6,lr}
        0x0081011e:    4605        .F      MOV      r5,r0
;;;343        T_LE_GAP_MSG gap_msg;
;;;344        uint8_t conn_id;
;;;345        memcpy(&gap_msg, &p_gap_msg->u.param, sizeof(p_gap_msg->u.param));
;;;346    
;;;347        APP_PRINT_TRACE1("app_handle_gap_msg: subtype %d", p_gap_msg->subtype);
        0x00810120:    8843        C.      LDRH     r3,[r0,#2]
        0x00810122:    6844        Dh      LDR      r4,[r0,#4]
        0x00810124:    4950        PI      LDR      r1,[pc,#320] ; [0x810268] = 0x8800ab4
        0x00810126:    484e        NH      LDR      r0,[pc,#312] ; [0x810260] = 0x21103002
        0x00810128:    2201        ."      MOVS     r2,#1
        0x0081012a:    3134        41      ADDS     r1,r1,#0x34
        0x0081012c:    1c40        @.      ADDS     r0,r0,#1
        0x0081012e:    f7f7dc96    ....    BL       log_buffer ; 0x7a5e
;;;348        switch (p_gap_msg->subtype)
        0x00810132:    886b        k.      LDRH     r3,[r5,#2]
        0x00810134:    2000        .       MOVS     r0,#0
        0x00810136:    4d4a        JM      LDR      r5,[pc,#296] ; [0x810260] = 0x21103002
        0x00810138:    2b0b        .+      CMP      r3,#0xb
        0x0081013a:    d27c        |.      BCS      0x810236 ; app_handle_gap_msg + 282
        0x0081013c:    e8dff003    ....    TBB      [pc,r3]
    $d
        0x00810140:    1a0c0683    ....    DCD    436995715
        0x00810144:    5b372214    ."7[    DCD    1530339860
        0x00810148:    002a496c    lI*.    DCD    2771308
    $t
;;;349        {
;;;350        case GAP_MSG_LE_DEV_STATE_CHANGE:
;;;351            {
;;;352                app_handle_dev_state_evt(gap_msg.msg_data.gap_dev_state_change.new_state,
        0x0081014c:    b004        ..      ADD      sp,sp,#0x10
        0x0081014e:    4620         F      MOV      r0,r4
        0x00810150:    0c21        !.      LSRS     r1,r4,#16
        0x00810152:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00810156:    e787        ..      B        app_handle_dev_state_evt ; 0x810068
        0x00810158:    b004        ..      ADD      sp,sp,#0x10
        0x0081015a:    0c22        ".      LSRS     r2,r4,#16
        0x0081015c:    f3c42107    ...!    UBFX     r1,r4,#8,#8
        0x00810160:    b2e0        ..      UXTB     r0,r4
;;;353                                         gap_msg.msg_data.gap_dev_state_change.cause);
;;;354            }
;;;355            break;
;;;356    
;;;357        case GAP_MSG_LE_CONN_STATE_CHANGE:
;;;358            {
;;;359                app_handle_conn_state_evt(gap_msg.msg_data.gap_conn_state_change.conn_id,
        0x00810162:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00810166:    e703        ..      B        app_handle_conn_state_evt ; 0x80ff70
        0x00810168:    b004        ..      ADD      sp,sp,#0x10
        0x0081016a:    0c21        !.      LSRS     r1,r4,#16
        0x0081016c:    b2e0        ..      UXTB     r0,r4
;;;360                                          (T_GAP_CONN_STATE)gap_msg.msg_data.gap_conn_state_change.new_state,
;;;361                                          gap_msg.msg_data.gap_conn_state_change.disc_cause);
;;;362            }
;;;363            break;
;;;364    
;;;365        case GAP_MSG_LE_CONN_MTU_INFO:
;;;366            {
;;;367                app_handle_conn_mtu_info_evt(gap_msg.msg_data.gap_conn_mtu_info.conn_id,
        0x0081016e:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00810172:    e6f3        ..      B        app_handle_conn_mtu_info_evt ; 0x80ff5c
        0x00810174:    b004        ..      ADD      sp,sp,#0x10
        0x00810176:    0c22        ".      LSRS     r2,r4,#16
        0x00810178:    f3c42107    ...!    UBFX     r1,r4,#8,#8
        0x0081017c:    b2e0        ..      UXTB     r0,r4
;;;368                                             gap_msg.msg_data.gap_conn_mtu_info.mtu_size);
;;;369            }
;;;370            break;
;;;371    
;;;372        case GAP_MSG_LE_CONN_PARAM_UPDATE:
;;;373            {
;;;374                app_handle_conn_param_update_evt(gap_msg.msg_data.gap_conn_param_update.conn_id,
        0x0081017e:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00810182:    e6ad        ..      B        app_handle_conn_param_update_evt ; 0x80fee0
        0x00810184:    b004        ..      ADD      sp,sp,#0x10
        0x00810186:    0c22        ".      LSRS     r2,r4,#16
        0x00810188:    f3c42107    ...!    UBFX     r1,r4,#8,#8
        0x0081018c:    b2e0        ..      UXTB     r0,r4
;;;375                                                 gap_msg.msg_data.gap_conn_param_update.status,
;;;376                                                 gap_msg.msg_data.gap_conn_param_update.cause);
;;;377            }
;;;378            break;
;;;379    
;;;380        case GAP_MSG_LE_AUTHEN_STATE_CHANGE:
;;;381            {
;;;382                app_handle_authen_state_evt(gap_msg.msg_data.gap_authen_state.conn_id,
        0x0081018e:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00810192:    e66f        o.      B        app_handle_authen_state_evt ; 0x80fe74
        0x00810194:    b2e0        ..      UXTB     r0,r4
;;;383                                            gap_msg.msg_data.gap_authen_state.new_state,
;;;384                                            gap_msg.msg_data.gap_authen_state.status);
;;;385            }
;;;386            break;
;;;387    
;;;388        case GAP_MSG_LE_BOND_JUST_WORK:
;;;389            {
;;;390                conn_id = gap_msg.msg_data.gap_bond_just_work_conf.conn_id;
;;;391                le_bond_just_work_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x00810196:    2101        .!      MOVS     r1,#1
        0x00810198:    f000faed    ....    BL       le_bond_just_work_confirm ; 0x810776
;;;392                APP_PRINT_INFO0("GAP_MSG_LE_BOND_JUST_WORK");
        0x0081019c:    b004        ..      ADD      sp,sp,#0x10
        0x0081019e:    4628        (F      MOV      r0,r5
        0x008101a0:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x008101a4:    4930        0I      LDR      r1,[pc,#192] ; [0x810268] = 0x8800ab4
        0x008101a6:    2200        ."      MOVS     r2,#0
        0x008101a8:    3154        T1      ADDS     r1,r1,#0x54
        0x008101aa:    f7f79c58    ..X.    B        log_buffer ; 0x7a5e
;;;393            }
;;;394            break;
;;;395    
;;;396        case GAP_MSG_LE_BOND_PASSKEY_DISPLAY:
;;;397            {
;;;398                uint32_t display_value = 0;
        0x008101ae:    b2e4        ..      UXTB     r4,r4
;;;399                conn_id = gap_msg.msg_data.gap_bond_passkey_display.conn_id;
;;;400                le_bond_get_display_key(conn_id, &display_value);
        0x008101b0:    9000        ..      STR      r0,[sp,#0]
        0x008101b2:    4669        iF      MOV      r1,sp
        0x008101b4:    4620         F      MOV      r0,r4
        0x008101b6:    f43cf118    <...    BL       le_bond_get_display_key ; 0x4c3ea
;;;401                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_DISPLAY:passkey %d", display_value);
        0x008101ba:    492b        +I      LDR      r1,[pc,#172] ; [0x810268] = 0x8800ab4
        0x008101bc:    2201        ."      MOVS     r2,#1
        0x008101be:    3174        t1      ADDS     r1,r1,#0x74
        0x008101c0:    4628        (F      MOV      r0,r5
        0x008101c2:    9b00        ..      LDR      r3,[sp,#0]
        0x008101c4:    f7f7dc4b    ..K.    BL       log_buffer ; 0x7a5e
;;;402                le_bond_passkey_display_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x008101c8:    2101        .!      MOVS     r1,#1
        0x008101ca:    4620         F      MOV      r0,r4
        0x008101cc:    f43cf152    <.R.    BL       le_bond_passkey_display_confirm ; 0x4c474
        0x008101d0:    bd7f        ..      POP      {r0-r6,pc}
;;;403            }
;;;404            break;
;;;405    
;;;406        case GAP_MSG_LE_BOND_USER_CONFIRMATION:
;;;407            {
;;;408                uint32_t display_value = 0;
        0x008101d2:    b2e4        ..      UXTB     r4,r4
;;;409                conn_id = gap_msg.msg_data.gap_bond_user_conf.conn_id;
;;;410                le_bond_get_display_key(conn_id, &display_value);
        0x008101d4:    9000        ..      STR      r0,[sp,#0]
        0x008101d6:    4669        iF      MOV      r1,sp
        0x008101d8:    4620         F      MOV      r0,r4
        0x008101da:    f43cf106    <...    BL       le_bond_get_display_key ; 0x4c3ea
;;;411                APP_PRINT_INFO1("GAP_MSG_LE_BOND_USER_CONFIRMATION: passkey %d", display_value);
        0x008101de:    4922        "I      LDR      r1,[pc,#136] ; [0x810268] = 0x8800ab4
        0x008101e0:    2201        ."      MOVS     r2,#1
        0x008101e2:    31a4        .1      ADDS     r1,r1,#0xa4
        0x008101e4:    4628        (F      MOV      r0,r5
        0x008101e6:    9b00        ..      LDR      r3,[sp,#0]
        0x008101e8:    f7f7dc39    ..9.    BL       log_buffer ; 0x7a5e
;;;412                le_bond_user_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x008101ec:    2101        .!      MOVS     r1,#1
        0x008101ee:    4620         F      MOV      r0,r4
        0x008101f0:    f43cf110    <...    BL       le_bond_user_confirm ; 0x4c414
        0x008101f4:    bd7f        ..      POP      {r0-r6,pc}
        0x008101f6:    491c        .I      LDR      r1,[pc,#112] ; [0x810268] = 0x8800ab4
;;;413            }
;;;414            break;
;;;415    
;;;416        case GAP_MSG_LE_BOND_PASSKEY_INPUT:
;;;417            {
;;;418                uint32_t passkey = 888888;
        0x008101f8:    b2e4        ..      UXTB     r4,r4
        0x008101fa:    4e20         N      LDR      r6,[pc,#128] ; [0x81027c] = 0xd9038
;;;419                conn_id = gap_msg.msg_data.gap_bond_passkey_input.conn_id;
;;;420                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d", conn_id);
        0x008101fc:    4623        #F      MOV      r3,r4
        0x008101fe:    2201        ."      MOVS     r2,#1
        0x00810200:    31d8        .1      ADDS     r1,r1,#0xd8
        0x00810202:    4628        (F      MOV      r0,r5
        0x00810204:    f7f7dc2b    ..+.    BL       log_buffer ; 0x7a5e
;;;421                le_bond_passkey_input_confirm(conn_id, passkey, GAP_CFM_CAUSE_ACCEPT);
        0x00810208:    b004        ..      ADD      sp,sp,#0x10
        0x0081020a:    4631        1F      MOV      r1,r6
        0x0081020c:    4620         F      MOV      r0,r4
        0x0081020e:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00810212:    2201        ."      MOVS     r2,#1
        0x00810214:    f43cb0b5    <...    B        le_bond_passkey_input_confirm ; 0x4c382
;;;422            }
;;;423            break;
;;;424    
;;;425        case GAP_MSG_LE_BOND_OOB_INPUT:
;;;426            {
;;;427                uint8_t oob_data[GAP_OOB_LEN] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        0x00810218:    9000        ..      STR      r0,[sp,#0]
        0x0081021a:    9001        ..      STR      r0,[sp,#4]
        0x0081021c:    9002        ..      STR      r0,[sp,#8]
        0x0081021e:    9003        ..      STR      r0,[sp,#0xc]
        0x00810220:    b2e4        ..      UXTB     r4,r4
;;;428                conn_id = gap_msg.msg_data.gap_bond_oob_input.conn_id;
;;;429                APP_PRINT_INFO0("GAP_MSG_LE_BOND_OOB_INPUT");
        0x00810222:    2200        ."      MOVS     r2,#0
        0x00810224:    4916        .I      LDR      r1,[pc,#88] ; [0x810280] = 0x8800bbc
        0x00810226:    4628        (F      MOV      r0,r5
        0x00810228:    f7f7dc19    ....    BL       log_buffer ; 0x7a5e
;;;430                le_bond_set_param(GAP_PARAM_BOND_OOB_DATA, GAP_OOB_LEN, oob_data);
        0x0081022c:    466a        jF      MOV      r2,sp
        0x0081022e:    2110        .!      MOVS     r1,#0x10
        0x00810230:    f44f7004    O..p    MOV      r0,#0x210
        0x00810234:    e000        ..      B        0x810238 ; app_handle_gap_msg + 284
        0x00810236:    e006        ..      B        0x810246 ; app_handle_gap_msg + 298
        0x00810238:    f43bf7d9    ;...    BL       le_bond_set_param ; 0x4c1ee
;;;431                le_bond_oob_input_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x0081023c:    2101        .!      MOVS     r1,#1
        0x0081023e:    4620         F      MOV      r0,r4
        0x00810240:    f43cf0b9    <...    BL       le_bond_oob_input_confirm ; 0x4c3b6
        0x00810244:    bd7f        ..      POP      {r0-r6,pc}
;;;432            }
;;;433            break;
;;;434    
;;;435        default:
;;;436            APP_PRINT_ERROR1("app_handle_gap_msg: unknown subtype %d", p_gap_msg->subtype);
        0x00810246:    b004        ..      ADD      sp,sp,#0x10
        0x00810248:    490d        .I      LDR      r1,[pc,#52] ; [0x810280] = 0x8800bbc
        0x0081024a:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0081024e:    4804        .H      LDR      r0,[pc,#16] ; [0x810260] = 0x21103002
        0x00810250:    2201        ."      MOVS     r2,#1
        0x00810252:    3120         1      ADDS     r1,r1,#0x20
        0x00810254:    1e80        ..      SUBS     r0,r0,#2
        0x00810256:    f7f79c02    ....    B        log_buffer ; 0x7a5e
    $d
        0x0081025a:    0000        ..      DCW    0
        0x0081025c:    08800880    ....    DCD    142608512
        0x00810260:    21103002    .0.!    DCD    554708994
        0x00810264:    08800984    ....    DCD    142608772
        0x00810268:    08800ab4    ....    DCD    142609076
        0x0081026c:    002080d0    .. .    DCD    2130128
        0x00810270:    08800748    H...    DCD    142608200
        0x00810274:    00207eb4    .~ .    DCD    2129588
        0x00810278:    21300000    ..0!    DCD    556793856
        0x0081027c:    000d9038    8...    DCD    888888
        0x00810280:    08800bbc    ....    DCD    142609340
    $t
    app_handle_io_msg
        0x00810284:    b513        ..      PUSH     {r0,r1,r4,lr}
        0x00810286:    f8bd0000    ....    LDRH     r0,[sp,#0]
;;; ..\include\SDK\src\app\pxp\pxp_app.c (84)
        0x0081028a:    b158        X.      CBZ      r0,0x8102a4 ; app_handle_io_msg + 32
;;;85         uint16_t msg_type = io_msg.type;
;;;86     
;;;87         switch (msg_type)
        0x0081028c:    280b        .(      CMP      r0,#0xb
        0x0081028e:    d00d        ..      BEQ      0x8102ac ; app_handle_io_msg + 40
        0x00810290:    2819        .(      CMP      r0,#0x19
        0x00810292:    d106        ..      BNE      0x8102a2 ; app_handle_io_msg + 30
;;;88         {
;;;89         case IO_MSG_TYPE_BT_STATUS:
;;;90             {
;;;91                 app_handle_gap_msg(&io_msg);
;;;92             }
;;;93             break;
;;;94         case IO_MSG_TYPE_GPIO:
;;;95             Pxp_HandleButtonEvent(io_msg);
;;;96             break;
;;;97         case IO_MSG_TYPE_RESET_WDG_TIMER:
;;;98             {
;;;99                 APP_PRINT_INFO0("[WDG] Watch Dog Rset Timer");
        0x00810294:    2200        ."      MOVS     r2,#0
        0x00810296:    49bd        .I      LDR      r1,[pc,#756] ; [0x81058c] = 0x8800674
        0x00810298:    48bd        .H      LDR      r0,[pc,#756] ; [0x810590] = 0x21103002
        0x0081029a:    f7f7dbe0    ....    BL       log_buffer ; 0x7a5e
;;;100                WDG_Restart();
        0x0081029e:    f401f359    ..Y.    BL       WDG_Restart ; 0x11954
;;;101            }
;;;102            break;
;;;103        default:
;;;104            break;
;;;105        }
;;;106    }
        0x008102a2:    bd1c        ..      POP      {r2-r4,pc}
        0x008102a4:    4668        hF      MOV      r0,sp
        0x008102a6:    f7ffff39    ..9.    BL       app_handle_gap_msg ; 0x81011c
        0x008102aa:    bd1c        ..      POP      {r2-r4,pc}
        0x008102ac:    e9dd0100    ....    LDRD     r0,r1,[sp,#0]
        0x008102b0:    f7fffac2    ....    BL       Pxp_HandleButtonEvent ; 0x80f838
        0x008102b4:    bd1c        ..      POP      {r2-r4,pc}
    app_gap_callback
;;;107    
;;;108    
;;;109    /**
;;;110     * @brief    Handle msg GAP_MSG_LE_DEV_STATE_CHANGE
;;;111     * @note     All the gap device state events are pre-handled in this function.
;;;112     *           Then the event handling function shall be called according to the new_state
;;;113     * @param[in] new_state  New gap device state
;;;114     * @param[in] cause GAP device state change cause
;;;115     * @return   void
;;;116     */
;;;117    void app_handle_dev_state_evt(T_GAP_DEV_STATE new_state, uint16_t cause)
;;;118    {
;;;119        APP_PRINT_INFO3("app_handle_dev_state_evt: init state %d, adv state %d, cause 0x%x",
;;;120                        new_state.gap_init_state, new_state.gap_adv_state, cause);
;;;121        if (gap_dev_state.gap_init_state != new_state.gap_init_state)
;;;122        {
;;;123            if (new_state.gap_init_state == GAP_INIT_STATE_STACK_READY)
;;;124            {
;;;125                APP_PRINT_INFO0("GAP stack ready");
;;;126                gPowerFlg = false;
;;;127            }
;;;128        }
;;;129    
;;;130        if (gap_dev_state.gap_adv_state != new_state.gap_adv_state)
;;;131        {
;;;132            if (new_state.gap_adv_state == GAP_ADV_STATE_IDLE)
;;;133            {
;;;134                if (new_state.gap_adv_sub_state == GAP_ADV_TO_IDLE_CAUSE_CONN)
;;;135                {
;;;136                    APP_PRINT_INFO0("GAP adv stoped: because connection created");
;;;137                }
;;;138                else
;;;139                {
;;;140                    gPxpState = PxpStateIdle;
;;;141                    APP_PRINT_INFO0("GAP adv stoped");
;;;142                }
;;;143            }
;;;144            else if (new_state.gap_adv_state == GAP_ADV_STATE_ADVERTISING)
;;;145            {
;;;146                APP_PRINT_INFO0("GAP adv start");
;;;147                gPxpState = PxpStateAdv;
;;;148                if (gIoState != IoStateLlsAlert)
;;;149                {
;;;150                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK,
;;;151                               10); /*low period 0.9s, high period 0.1s,  led blink,  10times(cnt)*/
;;;152                    gIoState = IoStateAdvBlink;
;;;153                }
;;;154            }
;;;155        }
;;;156    
;;;157        gap_dev_state = new_state;
;;;158    }
;;;159    
;;;160    /**
;;;161     * @brief    Handle msg GAP_MSG_LE_CONN_STATE_CHANGE
;;;162     * @note     All the gap conn state events are pre-handled in this function.
;;;163     *           Then the event handling function shall be called according to the new_state
;;;164     * @param[in] conn_id Connection ID
;;;165     * @param[in] new_state  New gap connection state
;;;166     * @param[in] disc_cause Use this cause when new_state is GAP_CONN_STATE_DISCONNECTED
;;;167     * @return   void
;;;168     */
;;;169    void app_handle_conn_state_evt(uint8_t conn_id, T_GAP_CONN_STATE new_state, uint16_t disc_cause)
;;;170    {
;;;171        APP_PRINT_INFO4("app_handle_conn_state_evt: conn_id %d old_state %d new_state %d, disc_cause 0x%x",
;;;172                        conn_id, gap_conn_state, new_state, disc_cause);
;;;173        switch (new_state)
;;;174        {
;;;175        case GAP_CONN_STATE_DISCONNECTED:
;;;176            {
;;;177                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
;;;178                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
;;;179                {
;;;180                    APP_PRINT_ERROR1("app_handle_conn_state_evt: connection lost cause 0x%x", disc_cause);
;;;181                }
;;;182                gPxpState = PxpStateIdle;
;;;183                if (gPowerFlg == true)
;;;184                {
;;;185                    le_adv_start();
;;;186                    APP_PRINT_ERROR1("g_pxp_linkloss_alert_level is %d", g_pxp_linkloss_alert_level);
;;;187                    gIoState = IoStateLlsAlert;
;;;188                    if (g_pxp_linkloss_alert_level == 1)
;;;189                    {
;;;190                        StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK, LL_ASSERT_TIME);
;;;191                    }
;;;192                    if (g_pxp_linkloss_alert_level == 2)
;;;193                    {
;;;194                        StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, LL_ASSERT_TIME);
;;;195                    }
;;;196                    else
;;;197                    {
;;;198                        //nothing to do
;;;199                    }
;;;200                }
;;;201            }
;;;202            break;
;;;203    
;;;204        case GAP_CONN_STATE_CONNECTED:
;;;205            {
;;;206                uint16_t conn_interval;
;;;207                uint16_t conn_latency;
;;;208                uint16_t conn_supervision_timeout;
;;;209                uint8_t  remote_bd[6];
;;;210                T_GAP_REMOTE_ADDR_TYPE remote_bd_type;
;;;211    
;;;212                gPxpState = PxpStateLink;
;;;213    
;;;214                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;215                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_latency, conn_id);
;;;216                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;217                le_get_conn_addr(conn_id, remote_bd, &remote_bd_type);
;;;218                APP_PRINT_INFO5("GAP_CONN_STATE_CONNECTED:remote_bd %s, remote_addr_type %d, conn_interval 0x%x, conn_latency 0x%x, conn_supervision_timeout 0x%x",
;;;219                                TRACE_BDADDR(remote_bd), remote_bd_type,
;;;220                                conn_interval, conn_latency, conn_supervision_timeout);
;;;221            }
;;;222            break;
;;;223    
;;;224        default:
;;;225            break;
;;;226        }
;;;227        gap_conn_state = new_state;
;;;228    }
;;;229    
;;;230    
;;;231    /**
;;;232     * @brief    Handle msg GAP_MSG_LE_AUTHEN_STATE_CHANGE
;;;233     * @note     All the gap authentication state events are pre-handled in this function.
;;;234     *           Then the event handling function shall be called according to the new_state
;;;235     * @param[in] conn_id Connection ID
;;;236     * @param[in] new_state  New authentication state
;;;237     * @param[in] cause Use this cause when new_state is GAP_AUTHEN_STATE_COMPLETE
;;;238     * @return   void
;;;239     */
;;;240    void app_handle_authen_state_evt(uint8_t conn_id, uint8_t new_state, uint16_t cause)
;;;241    {
;;;242        APP_PRINT_INFO2("app_handle_authen_state_evt:conn_id %d, cause 0x%x", conn_id, cause);
;;;243    
;;;244        switch (new_state)
;;;245        {
;;;246        case GAP_AUTHEN_STATE_STARTED:
;;;247            {
;;;248                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
;;;249            }
;;;250            break;
;;;251    
;;;252        case GAP_AUTHEN_STATE_COMPLETE:
;;;253            {
;;;254                if (cause == GAP_SUCCESS)
;;;255                {
;;;256                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, 1);
;;;257    
;;;258                    ChangeConnectionParameter(400, 0, 2000); //interval = 400*1.25ms
;;;259                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
;;;260    
;;;261                }
;;;262                else
;;;263                {
;;;264                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;265                }
;;;266            }
;;;267            break;
;;;268    
;;;269        default:
;;;270            {
;;;271                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;272            }
;;;273            break;
;;;274        }
;;;275    }
;;;276    
;;;277    /**
;;;278     * @brief    Handle msg GAP_MSG_LE_CONN_MTU_INFO
;;;279     * @note     This msg is used to inform APP that exchange mtu procedure is completed.
;;;280     * @param[in] conn_id Connection ID
;;;281     * @param[in] mtu_size  New mtu size
;;;282     * @return   void
;;;283     */
;;;284    void app_handle_conn_mtu_info_evt(uint8_t conn_id, uint16_t mtu_size)
;;;285    {
;;;286        APP_PRINT_INFO2("app_handle_conn_mtu_info_evt: conn_id %d, mtu_size %d", conn_id, mtu_size);
;;;287    }
;;;288    
;;;289    
;;;290    /**
;;;291     * @brief    Handle msg GAP_MSG_LE_CONN_PARAM_UPDATE
;;;292     * @note     All the connection parameter update change  events are pre-handled in this function.
;;;293     * @param[in] conn_id Connection ID
;;;294     * @param[in] status  New update state
;;;295     * @param[in] cause Use this cause when status is GAP_CONN_PARAM_UPDATE_STATUS_FAIL
;;;296     * @return   void
;;;297     */
;;;298    void app_handle_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;299    {
;;;300        switch (status)
;;;301        {
;;;302        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;303            {
;;;304                uint16_t conn_interval;
;;;305                uint16_t conn_slave_latency;
;;;306                uint16_t conn_supervision_timeout;
;;;307    
;;;308                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;309                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
;;;310                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;311                APP_PRINT_INFO3("app_handle_conn_param_update_evt update success:conn_interval 0x%x, conn_slave_latency 0x%x, conn_supervision_timeout 0x%x",
;;;312                                conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;313            }
;;;314            break;
;;;315    
;;;316        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;317            {
;;;318                APP_PRINT_ERROR1("app_handle_conn_param_update_evt update failed: cause 0x%x", cause);
;;;319            }
;;;320            break;
;;;321    
;;;322        case GAP_CONN_PARAM_UPDATE_STATUS_PENDING:
;;;323            {
;;;324                APP_PRINT_INFO0("app_handle_conn_param_update_evt update pending.");
;;;325            }
;;;326            break;
;;;327    
;;;328        default:
;;;329            break;
;;;330        }
;;;331    }
;;;332    
;;;333    
;;;334    /**
;;;335     * @brief    All the BT GAP MSG are pre-handled in this function.
;;;336     * @note     Then the event handling function shall be called according to the
;;;337     *           subtype of T_IO_MSG
;;;338     * @param[in] p_gap_msg Pointer to GAP msg
;;;339     * @return   void
;;;340     */
;;;341    void app_handle_gap_msg(T_IO_MSG *p_gap_msg)
;;;342    {
;;;343        T_LE_GAP_MSG gap_msg;
;;;344        uint8_t conn_id;
;;;345        memcpy(&gap_msg, &p_gap_msg->u.param, sizeof(p_gap_msg->u.param));
;;;346    
;;;347        APP_PRINT_TRACE1("app_handle_gap_msg: subtype %d", p_gap_msg->subtype);
;;;348        switch (p_gap_msg->subtype)
;;;349        {
;;;350        case GAP_MSG_LE_DEV_STATE_CHANGE:
;;;351            {
;;;352                app_handle_dev_state_evt(gap_msg.msg_data.gap_dev_state_change.new_state,
;;;353                                         gap_msg.msg_data.gap_dev_state_change.cause);
;;;354            }
;;;355            break;
;;;356    
;;;357        case GAP_MSG_LE_CONN_STATE_CHANGE:
;;;358            {
;;;359                app_handle_conn_state_evt(gap_msg.msg_data.gap_conn_state_change.conn_id,
;;;360                                          (T_GAP_CONN_STATE)gap_msg.msg_data.gap_conn_state_change.new_state,
;;;361                                          gap_msg.msg_data.gap_conn_state_change.disc_cause);
;;;362            }
;;;363            break;
;;;364    
;;;365        case GAP_MSG_LE_CONN_MTU_INFO:
;;;366            {
;;;367                app_handle_conn_mtu_info_evt(gap_msg.msg_data.gap_conn_mtu_info.conn_id,
;;;368                                             gap_msg.msg_data.gap_conn_mtu_info.mtu_size);
;;;369            }
;;;370            break;
;;;371    
;;;372        case GAP_MSG_LE_CONN_PARAM_UPDATE:
;;;373            {
;;;374                app_handle_conn_param_update_evt(gap_msg.msg_data.gap_conn_param_update.conn_id,
;;;375                                                 gap_msg.msg_data.gap_conn_param_update.status,
;;;376                                                 gap_msg.msg_data.gap_conn_param_update.cause);
;;;377            }
;;;378            break;
;;;379    
;;;380        case GAP_MSG_LE_AUTHEN_STATE_CHANGE:
;;;381            {
;;;382                app_handle_authen_state_evt(gap_msg.msg_data.gap_authen_state.conn_id,
;;;383                                            gap_msg.msg_data.gap_authen_state.new_state,
;;;384                                            gap_msg.msg_data.gap_authen_state.status);
;;;385            }
;;;386            break;
;;;387    
;;;388        case GAP_MSG_LE_BOND_JUST_WORK:
;;;389            {
;;;390                conn_id = gap_msg.msg_data.gap_bond_just_work_conf.conn_id;
;;;391                le_bond_just_work_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;392                APP_PRINT_INFO0("GAP_MSG_LE_BOND_JUST_WORK");
;;;393            }
;;;394            break;
;;;395    
;;;396        case GAP_MSG_LE_BOND_PASSKEY_DISPLAY:
;;;397            {
;;;398                uint32_t display_value = 0;
;;;399                conn_id = gap_msg.msg_data.gap_bond_passkey_display.conn_id;
;;;400                le_bond_get_display_key(conn_id, &display_value);
;;;401                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_DISPLAY:passkey %d", display_value);
;;;402                le_bond_passkey_display_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;403            }
;;;404            break;
;;;405    
;;;406        case GAP_MSG_LE_BOND_USER_CONFIRMATION:
;;;407            {
;;;408                uint32_t display_value = 0;
;;;409                conn_id = gap_msg.msg_data.gap_bond_user_conf.conn_id;
;;;410                le_bond_get_display_key(conn_id, &display_value);
;;;411                APP_PRINT_INFO1("GAP_MSG_LE_BOND_USER_CONFIRMATION: passkey %d", display_value);
;;;412                le_bond_user_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;413            }
;;;414            break;
;;;415    
;;;416        case GAP_MSG_LE_BOND_PASSKEY_INPUT:
;;;417            {
;;;418                uint32_t passkey = 888888;
;;;419                conn_id = gap_msg.msg_data.gap_bond_passkey_input.conn_id;
;;;420                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d", conn_id);
;;;421                le_bond_passkey_input_confirm(conn_id, passkey, GAP_CFM_CAUSE_ACCEPT);
;;;422            }
;;;423            break;
;;;424    
;;;425        case GAP_MSG_LE_BOND_OOB_INPUT:
;;;426            {
;;;427                uint8_t oob_data[GAP_OOB_LEN] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
;;;428                conn_id = gap_msg.msg_data.gap_bond_oob_input.conn_id;
;;;429                APP_PRINT_INFO0("GAP_MSG_LE_BOND_OOB_INPUT");
;;;430                le_bond_set_param(GAP_PARAM_BOND_OOB_DATA, GAP_OOB_LEN, oob_data);
;;;431                le_bond_oob_input_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;432            }
;;;433            break;
;;;434    
;;;435        default:
;;;436            APP_PRINT_ERROR1("app_handle_gap_msg: unknown subtype %d", p_gap_msg->subtype);
;;;437            break;
;;;438        }
;;;439    }
;;;440    /** @} */ /* End of group PERIPH_GAP_MSG */
;;;441    
;;;442    
;;;443    
;;;444    /** @defgroup  PXP_SMART_GAP_CALLBACK GAP Callback Event Handler
;;;445        * @brief Handle GAP callback event
;;;446        * @{
;;;447        */
;;;448    /**
;;;449      * @brief Callback for gap le to notify app
;;;450      * @param[in] cb_type callback msy type @ref GAP_LE_MSG_Types.
;;;451      * @param[in] p_cb_data point to callback data @ref T_LE_CB_DATA.
;;;452      * @retval result @ref T_APP_RESULT
;;;453      */
;;;454    T_APP_RESULT app_gap_callback(uint8_t cb_type, void *p_cb_data)
;;;455    {
        0x008102b6:    b57c        |.      PUSH     {r2-r6,lr}
        0x008102b8:    2400        .$      MOVS     r4,#0
        0x008102ba:    4db5        .M      LDR      r5,[pc,#724] ; [0x810590] = 0x21103002
        0x008102bc:    2801        .(      CMP      r0,#1
        0x008102be:    d016        ..      BEQ      0x8102ee ; app_gap_callback + 56
;;;456        T_APP_RESULT result = APP_RESULT_SUCCESS;
;;;457        T_LE_CB_DATA *p_data = (T_LE_CB_DATA *)p_cb_data;
;;;458    
;;;459        switch (cb_type)
        0x008102c0:    2814        .(      CMP      r0,#0x14
        0x008102c2:    d007        ..      BEQ      0x8102d4 ; app_gap_callback + 30
        0x008102c4:    4603        .F      MOV      r3,r0
        0x008102c6:    2201        ."      MOVS     r2,#1
        0x008102c8:    49b2        .I      LDR      r1,[pc,#712] ; [0x810594] = 0x8800c98
        0x008102ca:    1ea8        ..      SUBS     r0,r5,#2
        0x008102cc:    f7f7dbc7    ....    BL       log_buffer ; 0x7a5e
        0x008102d0:    4620         F      MOV      r0,r4
        0x008102d2:    bd7c        |.      POP      {r2-r6,pc}
;;;460        {
;;;461        case GAP_MSG_LE_DATA_LEN_CHANGE_INFO:
;;;462            APP_PRINT_INFO3("GAP_MSG_LE_DATA_LEN_CHANGE_INFO: conn_id %d, tx octets 0x%x, max_tx_time 0x%x",
        0x008102d4:    6808        .h      LDR      r0,[r1,#0]
        0x008102d6:    8882        ..      LDRH     r2,[r0,#4]
        0x008102d8:    8841        A.      LDRH     r1,[r0,#2]
        0x008102da:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
        0x008102de:    49ad        .I      LDR      r1,[pc,#692] ; [0x810594] = 0x8800c98
        0x008102e0:    7803        .x      LDRB     r3,[r0,#0]
        0x008102e2:    2203        ."      MOVS     r2,#3
        0x008102e4:    3990        .9      SUBS     r1,r1,#0x90
        0x008102e6:    4628        (F      MOV      r0,r5
        0x008102e8:    f7f7dbb9    ....    BL       log_buffer ; 0x7a5e
;;;463                            p_data->p_le_data_len_change_info->conn_id,
;;;464                            p_data->p_le_data_len_change_info->max_tx_octets,
;;;465                            p_data->p_le_data_len_change_info->max_tx_time);
;;;466            break;
        0x008102ec:    e7f0        ..      B        0x8102d0 ; app_gap_callback + 26
;;;467    
;;;468        case GAP_MSG_LE_MODIFY_WHITE_LIST:
;;;469            APP_PRINT_INFO2("GAP_MSG_LE_MODIFY_WHITE_LIST: operation %d, cause 0x%x",
        0x008102ee:    6808        .h      LDR      r0,[r1,#0]
        0x008102f0:    2202        ."      MOVS     r2,#2
        0x008102f2:    8841        A.      LDRH     r1,[r0,#2]
        0x008102f4:    9100        ..      STR      r1,[sp,#0]
        0x008102f6:    49a7        .I      LDR      r1,[pc,#668] ; [0x810594] = 0x8800c98
        0x008102f8:    7803        .x      LDRB     r3,[r0,#0]
        0x008102fa:    393c        <9      SUBS     r1,r1,#0x3c
        0x008102fc:    4628        (F      MOV      r0,r5
        0x008102fe:    f7f7dbae    ....    BL       log_buffer ; 0x7a5e
;;;470                            p_data->p_le_modify_white_list_rsp->operation,
;;;471                            p_data->p_le_modify_white_list_rsp->cause);
;;;472            break;
        0x00810302:    e7e5        ..      B        0x8102d0 ; app_gap_callback + 26
    app_profile_callback
;;;473    
;;;474        default:
;;;475            APP_PRINT_ERROR1("app_gap_callback: unhandled cb_type 0x%x", cb_type);
;;;476            break;
;;;477        }
;;;478        return result;
;;;479    }
;;;480    /** @} */ /* End of group PXP_GAP_CALLBACK */
;;;481    
;;;482    
;;;483    /** @defgroup  PXP_SEVER_CALLBACK Profile Server Callback Event Handler
;;;484        * @brief Handle profile server callback event
;;;485        * @{
;;;486        */
;;;487    /**
;;;488     * @brief    All the BT Profile service callback events are handled in this function
;;;489     * @note     Then the event handling function shall be called according to the
;;;490     *           service_id.
;;;491     * @param[in] service_id  Profile service ID
;;;492     * @param[in] p_data      Pointer to callback data
;;;493     * @return   Indicates the function call is successful or not
;;;494     * @retval   result @ref T_APP_RESULT
;;;495     */
;;;496    
;;;497    T_APP_RESULT app_profile_callback(T_SERVER_ID service_id, void *p_data)
;;;498    {
        0x00810304:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x00810308:    f8df8284    ....    LDR      r8,[pc,#644] ; [0x810590] = 0x21103002
        0x0081030c:    2500        .%      MOVS     r5,#0
        0x0081030e:    4fa0        .O      LDR      r7,[pc,#640] ; [0x810590] = 0x21103002
;;; ..\include\SDK\src\app\pxp\pxp_app.c (498)
        0x00810310:    b086        ..      SUB      sp,sp,#0x18
        0x00810312:    f1a80802    ....    SUB      r8,r8,#2
        0x00810316:    28ff        .(      CMP      r0,#0xff
        0x00810318:    d00e        ..      BEQ      0x810338 ; app_profile_callback + 52
        0x0081031a:    4e9f        .N      LDR      r6,[pc,#636] ; [0x810598] = 0x2080d0
        0x0081031c:    4c9f        .L      LDR      r4,[pc,#636] ; [0x81059c] = 0x207eb4
        0x0081031e:    7972        ry      LDRB     r2,[r6,#5]
        0x00810320:    4290        .B      CMP      r0,r2
        0x00810322:    d149        I.      BNE      0x8103b8 ; app_profile_callback + 180
        0x00810324:    460f        .F      MOV      r7,r1
        0x00810326:    2200        ."      MOVS     r2,#0
        0x00810328:    499d        .I      LDR      r1,[pc,#628] ; [0x8105a0] = 0x8800db0
        0x0081032a:    4640        @F      MOV      r0,r8
        0x0081032c:    f7f7db97    ....    BL       log_buffer ; 0x7a5e
        0x00810330:    7878        xx      LDRB     r0,[r7,#1]
        0x00810332:    2803        .(      CMP      r0,#3
        0x00810334:    d026        &.      BEQ      0x810384 ; app_profile_callback + 128
        0x00810336:    e0eb        ..      B        0x810510 ; app_profile_callback + 524
        0x00810338:    7808        .x      LDRB     r0,[r1,#0]
;;;499        T_APP_RESULT app_result = APP_RESULT_SUCCESS;
;;;500        if (service_id == SERVICE_PROFILE_GENERAL_ID)
;;;501        {
;;;502            T_SERVER_APP_CB_DATA *p_param = (T_SERVER_APP_CB_DATA *)p_data;
        0x0081033a:    460c        .F      MOV      r4,r1
;;;503            switch (p_param->eventId)
        0x0081033c:    b110        ..      CBZ      r0,0x810344 ; app_profile_callback + 64
        0x0081033e:    2801        .(      CMP      r0,#1
        0x00810340:    d1f9        ..      BNE      0x810336 ; app_profile_callback + 50
        0x00810342:    e007        ..      B        0x810354 ; app_profile_callback + 80
;;;504            {
;;;505            case PROFILE_EVT_SRV_REG_COMPLETE:// srv register result event.
;;;506                APP_PRINT_INFO1("PROFILE_EVT_SRV_REG_COMPLETE: result %d",
        0x00810344:    788b        .x      LDRB     r3,[r1,#2]
        0x00810346:    4993        .I      LDR      r1,[pc,#588] ; [0x810594] = 0x8800c98
        0x00810348:    2201        ."      MOVS     r2,#1
        0x0081034a:    312c        ,1      ADDS     r1,r1,#0x2c
        0x0081034c:    4638        8F      MOV      r0,r7
        0x0081034e:    f7f7db86    ....    BL       log_buffer ; 0x7a5e
;;;507                                p_param->event_data.service_reg_result);
;;;508                break;
        0x00810352:    e0dd        ..      B        0x810510 ; app_profile_callback + 524
;;;509    
;;;510            case PROFILE_EVT_SEND_DATA_COMPLETE:
;;;511                APP_PRINT_INFO5("PROFILE_EVT_SEND_DATA_COMPLETE: conn_id %d, cause 0x%x, service_id %d, attrib_idx 0x%x, credits %d",
        0x00810354:    8920         .      LDRH     r0,[r4,#8]
        0x00810356:    8863        c.      LDRH     r3,[r4,#2]
        0x00810358:    88e2        ..      LDRH     r2,[r4,#6]
        0x0081035a:    7961        ay      LDRB     r1,[r4,#5]
        0x0081035c:    e88d000f    ....    STM      sp,{r0-r3}
        0x00810360:    498c        .I      LDR      r1,[pc,#560] ; [0x810594] = 0x8800c98
        0x00810362:    7923        #y      LDRB     r3,[r4,#4]
        0x00810364:    2205        ."      MOVS     r2,#5
        0x00810366:    3158        X1      ADDS     r1,r1,#0x58
        0x00810368:    4638        8F      MOV      r0,r7
        0x0081036a:    f7f7db78    ..x.    BL       log_buffer ; 0x7a5e
;;;512                                p_param->event_data.send_data_result.conn_id,
;;;513                                p_param->event_data.send_data_result.cause,
;;;514                                p_param->event_data.send_data_result.service_id,
;;;515                                p_param->event_data.send_data_result.attrib_idx,
;;;516                                p_param->event_data.send_data_result.credits);
;;;517                if (p_param->event_data.send_data_result.cause == GAP_SUCCESS)
        0x0081036e:    8920         .      LDRH     r0,[r4,#8]
        0x00810370:    f04f0200    O...    MOV      r2,#0
        0x00810374:    b118        ..      CBZ      r0,0x81037e ; app_profile_callback + 122
        0x00810376:    498a        .I      LDR      r1,[pc,#552] ; [0x8105a0] = 0x8800db0
        0x00810378:    4640        @F      MOV      r0,r8
        0x0081037a:    392c        ,9      SUBS     r1,r1,#0x2c
        0x0081037c:    e088        ..      B        0x810490 ; app_profile_callback + 396
;;;518                {
;;;519                    APP_PRINT_INFO0("PROFILE_EVT_SEND_DATA_COMPLETE success");
        0x0081037e:    4988        .I      LDR      r1,[pc,#544] ; [0x8105a0] = 0x8800db0
        0x00810380:    3958        X9      SUBS     r1,r1,#0x58
        0x00810382:    e084        ..      B        0x81048e ; app_profile_callback + 394
;;;520                }
;;;521                else
;;;522                {
;;;523                    APP_PRINT_ERROR0("PROFILE_EVT_SEND_DATA_COMPLETE failed");
;;;524                }
;;;525                break;
;;;526    
;;;527            default:
;;;528                break;
;;;529            }
;;;530        }
;;;531        else if (service_id == ias_srv_id)
;;;532        {
;;;533            T_IAS_CALLBACK_DATA *p_ias_cb_data = (T_IAS_CALLBACK_DATA *)p_data;
;;;534            APP_PRINT_ERROR0("IAS CallBack.");
;;;535            if (p_ias_cb_data->msg_type == SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE)
;;;536            {
;;;537                g_pxp_immediate_alert_level = p_ias_cb_data->msg_data.write_alert_level;
        0x00810384:    78b8        .x      LDRB     r0,[r7,#2]
        0x00810386:    2102        .!      MOVS     r1,#2
        0x00810388:    72f0        .r      STRB     r0,[r6,#0xb]
        0x0081038a:    f44f7761    O.aw    MOV      r7,#0x384
;;;538                if (g_pxp_immediate_alert_level == 1)
        0x0081038e:    2801        .(      CMP      r0,#1
        0x00810390:    d004        ..      BEQ      0x81039c ; app_profile_callback + 152
        0x00810392:    2802        .(      CMP      r0,#2
        0x00810394:    d008        ..      BEQ      0x8103a8 ; app_profile_callback + 164
        0x00810396:    f7fffa15    ....    BL       StopPxpIO ; 0x80f7c4
        0x0081039a:    e0b9        ..      B        0x810510 ; app_profile_callback + 524
;;;539                {
;;;540                    gIoState = IoStateImmAlert;
        0x0081039c:    7071        qp      STRB     r1,[r6,#1]
;;;541                    StopPxpIO();
        0x0081039e:    f7fffa11    ....    BL       StopPxpIO ; 0x80f7c4
;;;542                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK, gTimeParaValue);
        0x008103a2:    2201        ."      MOVS     r2,#1
        0x008103a4:    6863        ch      LDR      r3,[r4,#4]
        0x008103a6:    e002        ..      B        0x8103ae ; app_profile_callback + 170
        0x008103a8:    7071        qp      STRB     r1,[r6,#1]
        0x008103aa:    6863        ch      LDR      r3,[r4,#4]
        0x008103ac:    2203        ."      MOVS     r2,#3
        0x008103ae:    2164        d!      MOVS     r1,#0x64
        0x008103b0:    4638        8F      MOV      r0,r7
        0x008103b2:    f7fffa1e    ....    BL       StartPxpIO ; 0x80f7f2
        0x008103b6:    e0ab        ..      B        0x810510 ; app_profile_callback + 524
;;;543                }
;;;544                else if (g_pxp_immediate_alert_level == 2)
;;;545                {
;;;546                    gIoState = IoStateImmAlert;
;;;547                    StartPxpIO(ALERT_LOW_PERIOD, ALERT_HIGH_PERIOD, LED_BLINK | BEEP_ALERT, gTimeParaValue);
;;;548                }
;;;549                else
;;;550                {
;;;551                    StopPxpIO();
;;;552                }
;;;553            }
;;;554        }
;;;555        else if (service_id == lls_srv_id)
        0x008103b8:    79b2        .y      LDRB     r2,[r6,#6]
        0x008103ba:    4290        .B      CMP      r0,r2
        0x008103bc:    d10d        ..      BNE      0x8103da ; app_profile_callback + 214
;;;556        {
;;;557            T_LLS_CALLBACK_DATA *p_lls_cb_data = (T_LLS_CALLBACK_DATA *)p_data;
;;;558            switch (p_lls_cb_data->msg_type)
        0x008103be:    7848        Hx      LDRB     r0,[r1,#1]
        0x008103c0:    2802        .(      CMP      r0,#2
        0x008103c2:    d004        ..      BEQ      0x8103ce ; app_profile_callback + 202
        0x008103c4:    2803        .(      CMP      r0,#3
        0x008103c6:    d101        ..      BNE      0x8103cc ; app_profile_callback + 200
;;;559            {
;;;560            case SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE:
;;;561                g_pxp_linkloss_alert_level = p_lls_cb_data->msg_data.write_alert_level;
        0x008103c8:    7888        .x      LDRB     r0,[r1,#2]
        0x008103ca:    7020         p      STRB     r0,[r4,#0]
;;;562                break;
        0x008103cc:    e0a0        ..      B        0x810510 ; app_profile_callback + 524
;;;563            case SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE:
;;;564                lls_set_parameter(LLS_PARAM_LINK_LOSS_ALERT_LEVEL, 1, &g_pxp_linkloss_alert_level);
        0x008103ce:    4a73        sJ      LDR      r2,[pc,#460] ; [0x81059c] = 0x207eb4
        0x008103d0:    2101        .!      MOVS     r1,#1
        0x008103d2:    2000        .       MOVS     r0,#0
        0x008103d4:    f7fefd02    ....    BL       lls_set_parameter ; 0x80eddc
;;;565                break;
        0x008103d8:    e09a        ..      B        0x810510 ; app_profile_callback + 524
;;;566            default:
;;;567                break;
;;;568            }
;;;569        }
;;;570        else if (service_id == tps_srv_id)
        0x008103da:    79f3        .y      LDRB     r3,[r6,#7]
        0x008103dc:    2200        ."      MOVS     r2,#0
        0x008103de:    4298        .B      CMP      r0,r3
        0x008103e0:    d10d        ..      BNE      0x8103fe ; app_profile_callback + 250
;;;571        {
;;;572            T_TPS_CALLBACK_DATA *p_tps_cb_data = (T_TPS_CALLBACK_DATA *)p_data;
;;;573            if (p_tps_cb_data->msg_type == SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE)
        0x008103e2:    7848        Hx      LDRB     r0,[r1,#1]
        0x008103e4:    2802        .(      CMP      r0,#2
        0x008103e6:    d109        ..      BNE      0x8103fc ; app_profile_callback + 248
;;;574            {
;;;575                if (p_tps_cb_data->msg_data.read_value_index == TPS_READ_TX_POWER_VALUE)
        0x008103e8:    7888        .x      LDRB     r0,[r1,#2]
        0x008103ea:    2801        .(      CMP      r0,#1
        0x008103ec:    d106        ..      BNE      0x8103fc ; app_profile_callback + 248
;;;576                {
;;;577                    uint8_t tps_value = 0;
        0x008103ee:    f88d2000    ...     STRB     r2,[sp,#0]
;;;578                    tps_set_parameter(TPS_PARAM_TX_POWER, 1, &tps_value);
        0x008103f2:    466a        jF      MOV      r2,sp
        0x008103f4:    2101        .!      MOVS     r1,#1
        0x008103f6:    2000        .       MOVS     r0,#0
        0x008103f8:    f7fefd82    ....    BL       tps_set_parameter ; 0x80ef00
;;;579                }
        0x008103fc:    e088        ..      B        0x810510 ; app_profile_callback + 524
;;;580            }
;;;581        }
;;;582    
;;;583        else  if (service_id == kns_srv_id)
        0x008103fe:    7a33        3z      LDRB     r3,[r6,#8]
        0x00810400:    4298        .B      CMP      r0,r3
        0x00810402:    d12e        ..      BNE      0x810462 ; app_profile_callback + 350
        0x00810404:    7808        .x      LDRB     r0,[r1,#0]
;;;584        {
;;;585            T_KNS_CALLBACK_DATA *p_kns_cb_data = (T_KNS_CALLBACK_DATA *)p_data;
        0x00810406:    460e        .F      MOV      r6,r1
;;;586            switch (p_kns_cb_data->msg_type)
        0x00810408:    2801        .(      CMP      r0,#1
        0x0081040a:    d004        ..      BEQ      0x810416 ; app_profile_callback + 274
        0x0081040c:    2802        .(      CMP      r0,#2
        0x0081040e:    d00e        ..      BEQ      0x81042e ; app_profile_callback + 298
        0x00810410:    2803        .(      CMP      r0,#3
        0x00810412:    d17d        }.      BNE      0x810510 ; app_profile_callback + 524
        0x00810414:    e01b        ..      B        0x81044e ; app_profile_callback + 330
;;;587            {
;;;588            case SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION:
;;;589                {
;;;590                    switch (p_kns_cb_data->msg_data.notification_indification_index)
        0x00810416:    7908        .y      LDRB     r0,[r1,#4]
        0x00810418:    b128        (.      CBZ      r0,0x810426 ; app_profile_callback + 290
        0x0081041a:    2801        .(      CMP      r0,#1
        0x0081041c:    d178        x.      BNE      0x810510 ; app_profile_callback + 524
;;;591                    {
;;;592                    case KNS_NOTIFY_ENABLE:
;;;593                        {
;;;594                            APP_PRINT_INFO0("KNS_NOTIFY_ENABLE");
        0x0081041e:    4960        `I      LDR      r1,[pc,#384] ; [0x8105a0] = 0x8800db0
        0x00810420:    2200        ."      MOVS     r2,#0
        0x00810422:    3114        .1      ADDS     r1,r1,#0x14
;;;595                        }
;;;596                        break;
        0x00810424:    e033        3.      B        0x81048e ; app_profile_callback + 394
;;;597    
;;;598                    case KNS_NOTIFY_DISABLE:
;;;599                        {
;;;600                            APP_PRINT_INFO0("KNS_NOTIFY_DISABLE");
        0x00810426:    495e        ^I      LDR      r1,[pc,#376] ; [0x8105a0] = 0x8800db0
        0x00810428:    2200        ."      MOVS     r2,#0
        0x0081042a:    312c        ,1      ADDS     r1,r1,#0x2c
;;;601                        }
;;;602                        break;
        0x0081042c:    e02f        /.      B        0x81048e ; app_profile_callback + 394
;;;603                    default:
;;;604                        break;
;;;605                    }
;;;606                }
;;;607                break;
;;;608    
;;;609            case SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE:
;;;610                {
;;;611                    if (p_kns_cb_data->msg_data.read_index == KNS_READ_PARA)
        0x0081042e:    7908        .y      LDRB     r0,[r1,#4]
        0x00810430:    2802        .(      CMP      r0,#2
        0x00810432:    d16d        m.      BNE      0x810510 ; app_profile_callback + 524
;;;612                    {
;;;613                        APP_PRINT_INFO0("KNS_READ_PARA");
        0x00810434:    495a        ZI      LDR      r1,[pc,#360] ; [0x8105a0] = 0x8800db0
        0x00810436:    2200        ."      MOVS     r2,#0
        0x00810438:    3144        D1      ADDS     r1,r1,#0x44
        0x0081043a:    4638        8F      MOV      r0,r7
        0x0081043c:    f7f7db0f    ....    BL       log_buffer ; 0x7a5e
;;;614                        kns_set_parameter(KNS_PARAM_VALUE, 4, &gTimeParaValue);
        0x00810440:    4a56        VJ      LDR      r2,[pc,#344] ; [0x81059c] = 0x207eb4
        0x00810442:    2104        .!      MOVS     r1,#4
        0x00810444:    1d12        ..      ADDS     r2,r2,#4
        0x00810446:    2000        .       MOVS     r0,#0
        0x00810448:    f7fefe76    ..v.    BL       kns_set_parameter ; 0x80f138
        0x0081044c:    e060        `.      B        0x810510 ; app_profile_callback + 524
;;;615                    }
;;;616                }
;;;617                break;
;;;618            case SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE:
;;;619                {
;;;620                    APP_PRINT_INFO1("KNS_WRITE_PARA %x", p_kns_cb_data->msg_data.write_value);
        0x0081044e:    4954        TI      LDR      r1,[pc,#336] ; [0x8105a0] = 0x8800db0
        0x00810450:    2201        ."      MOVS     r2,#1
        0x00810452:    3158        X1      ADDS     r1,r1,#0x58
        0x00810454:    4638        8F      MOV      r0,r7
        0x00810456:    6873        sh      LDR      r3,[r6,#4]
        0x00810458:    f7f7db01    ....    BL       log_buffer ; 0x7a5e
;;;621                    gTimeParaValue = p_kns_cb_data->msg_data.write_value;
        0x0081045c:    6870        ph      LDR      r0,[r6,#4]
;;;622                }
;;;623                break;
        0x0081045e:    6060        ``      STR      r0,[r4,#4]
        0x00810460:    e056        V.      B        0x810510 ; app_profile_callback + 524
;;;624    
;;;625            default:
;;;626                break;
;;;627            }
;;;628        }
;;;629        else if (service_id == bas_srv_id)
        0x00810462:    7a73        sz      LDRB     r3,[r6,#9]
        0x00810464:    4298        .B      CMP      r0,r3
        0x00810466:    d128        (.      BNE      0x8104ba ; app_profile_callback + 438
;;;630        {
;;;631            T_BAS_CALLBACK_DATA *p_bas_cb_data = (T_BAS_CALLBACK_DATA *)p_data;
;;;632            switch (p_bas_cb_data->msg_type)
        0x00810468:    7848        Hx      LDRB     r0,[r1,#1]
        0x0081046a:    2801        .(      CMP      r0,#1
        0x0081046c:    d002        ..      BEQ      0x810474 ; app_profile_callback + 368
        0x0081046e:    2802        .(      CMP      r0,#2
        0x00810470:    d14e        N.      BNE      0x810510 ; app_profile_callback + 524
        0x00810472:    e010        ..      B        0x810496 ; app_profile_callback + 402
;;;633            {
;;;634            case SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION:
;;;635                {
;;;636                    switch (p_bas_cb_data->msg_data.notification_indification_index)
        0x00810474:    7888        .x      LDRB     r0,[r1,#2]
        0x00810476:    2801        .(      CMP      r0,#1
        0x00810478:    d002        ..      BEQ      0x810480 ; app_profile_callback + 380
        0x0081047a:    2802        .(      CMP      r0,#2
        0x0081047c:    d148        H.      BNE      0x810510 ; app_profile_callback + 524
        0x0081047e:    e003        ..      B        0x810488 ; app_profile_callback + 388
;;;637                    {
;;;638                    case BAS_NOTIFY_BATTERY_LEVEL_ENABLE:
;;;639                        {
;;;640                            APP_PRINT_INFO0("BAS_NOTIFY_BATTERY_LEVEL_ENABLE");
        0x00810480:    4947        GI      LDR      r1,[pc,#284] ; [0x8105a0] = 0x8800db0
        0x00810482:    2200        ."      MOVS     r2,#0
        0x00810484:    3170        p1      ADDS     r1,r1,#0x70
        0x00810486:    e002        ..      B        0x81048e ; app_profile_callback + 394
        0x00810488:    4945        EI      LDR      r1,[pc,#276] ; [0x8105a0] = 0x8800db0
        0x0081048a:    2200        ."      MOVS     r2,#0
        0x0081048c:    3194        .1      ADDS     r1,r1,#0x94
        0x0081048e:    4638        8F      MOV      r0,r7
        0x00810490:    f7f7dae5    ....    BL       log_buffer ; 0x7a5e
        0x00810494:    e03c        <.      B        0x810510 ; app_profile_callback + 524
;;;641                        }
;;;642                        break;
;;;643    
;;;644                    case BAS_NOTIFY_BATTERY_LEVEL_DISABLE:
;;;645                        {
;;;646                            APP_PRINT_INFO0("BAS_NOTIFY_BATTERY_LEVEL_DISABLE");
;;;647                        }
;;;648                        break;
;;;649                    default:
;;;650                        break;
;;;651                    }
;;;652                }
;;;653                break;
;;;654    
;;;655            case SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE:
;;;656                {
;;;657                    if (p_bas_cb_data->msg_data.read_value_index == BAS_READ_BATTERY_LEVEL)
        0x00810496:    7888        .x      LDRB     r0,[r1,#2]
        0x00810498:    2801        .(      CMP      r0,#1
        0x0081049a:    d139        9.      BNE      0x810510 ; app_profile_callback + 524
        0x0081049c:    4940        @I      LDR      r1,[pc,#256] ; [0x8105a0] = 0x8800db0
;;;658                    {
;;;659                        uint8_t battery_level = 90;
        0x0081049e:    235a        Z#      MOVS     r3,#0x5a
        0x008104a0:    f88d3000    ...0    STRB     r3,[sp,#0]
;;;660                        APP_PRINT_INFO1("BAS_READ_BATTERY_LEVEL: battery_level %d", battery_level);
        0x008104a4:    2201        ."      MOVS     r2,#1
        0x008104a6:    31b8        .1      ADDS     r1,r1,#0xb8
        0x008104a8:    4638        8F      MOV      r0,r7
        0x008104aa:    f7f7dad8    ....    BL       log_buffer ; 0x7a5e
;;;661                        bas_set_parameter(BAS_PARAM_BATTERY_LEVEL, 1, &battery_level);
        0x008104ae:    2101        .!      MOVS     r1,#1
        0x008104b0:    466a        jF      MOV      r2,sp
        0x008104b2:    4608        .F      MOV      r0,r1
        0x008104b4:    f7fefd8a    ....    BL       bas_set_parameter ; 0x80efcc
;;;662                    }
        0x008104b8:    e02a        *.      B        0x810510 ; app_profile_callback + 524
;;;663                }
;;;664                break;
;;;665            default:
;;;666                break;
;;;667            }
;;;668        }
;;;669        else if (service_id == dis_srv_id)
        0x008104ba:    7ab3        .z      LDRB     r3,[r6,#0xa]
        0x008104bc:    4298        .B      CMP      r0,r3
        0x008104be:    d127        '.      BNE      0x810510 ; app_profile_callback + 524
;;;670        {
;;;671            T_DIS_CALLBACK_DATA *p_dis_cb_data = (T_DIS_CALLBACK_DATA *)p_data;
;;;672            switch (p_dis_cb_data->msg_type)
        0x008104c0:    7808        .x      LDRB     r0,[r1,#0]
        0x008104c2:    2802        .(      CMP      r0,#2
        0x008104c4:    d124        $.      BNE      0x810510 ; app_profile_callback + 524
;;;673            {
;;;674            case SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE:
;;;675                {
;;;676                    if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_MANU_NAME_INDEX)
        0x008104c6:    7889        .x      LDRB     r1,[r1,#2]
        0x008104c8:    2901        .)      CMP      r1,#1
        0x008104ca:    d010        ..      BEQ      0x8104ee ; app_profile_callback + 490
;;;677                    {
;;;678                        const uint8_t DISManufacturerName[] = "Realtek BT";
;;;679                        dis_set_parameter(DIS_PARAM_MANUFACTURER_NAME,
;;;680                                          sizeof(DISManufacturerName),
;;;681                                          (void *)DISManufacturerName);
;;;682    
;;;683                    }
;;;684                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_MODEL_NUM_INDEX)
        0x008104cc:    2902        .)      CMP      r1,#2
        0x008104ce:    d016        ..      BEQ      0x8104fe ; app_profile_callback + 506
;;;685                    {
;;;686                        const uint8_t DISModelNumber[] = "Model Nbr 0.9";
;;;687                        dis_set_parameter(DIS_PARAM_MODEL_NUMBER,
;;;688                                          sizeof(DISModelNumber),
;;;689                                          (void *)DISModelNumber);
;;;690                    }
;;;691                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_SERIAL_NUM_INDEX)
        0x008104d0:    2903        .)      CMP      r1,#3
        0x008104d2:    d020         .      BEQ      0x810516 ; app_profile_callback + 530
        0x008104d4:    2904        .)      CMP      r1,#4
        0x008104d6:    d026        &.      BEQ      0x810526 ; app_profile_callback + 546
        0x008104d8:    2905        .)      CMP      r1,#5
        0x008104da:    d02d        -.      BEQ      0x810538 ; app_profile_callback + 564
        0x008104dc:    2906        .)      CMP      r1,#6
        0x008104de:    d034        4.      BEQ      0x81054a ; app_profile_callback + 582
        0x008104e0:    2907        .)      CMP      r1,#7
        0x008104e2:    d03b        ;.      BEQ      0x81055c ; app_profile_callback + 600
        0x008104e4:    2908        .)      CMP      r1,#8
        0x008104e6:    d042        B.      BEQ      0x81056e ; app_profile_callback + 618
        0x008104e8:    2909        .)      CMP      r1,#9
        0x008104ea:    d049        I.      BEQ      0x810580 ; app_profile_callback + 636
        0x008104ec:    e010        ..      B        0x810510 ; app_profile_callback + 524
        0x008104ee:    a02d        -.      ADR      r0,{pc}+0xb6 ; 0x8105a4
        0x008104f0:    c807        ..      LDM      r0,{r0-r2}
        0x008104f2:    e88d0007    ....    STM      sp,{r0-r2}
        0x008104f6:    210b        .!      MOVS     r1,#0xb
        0x008104f8:    466a        jF      MOV      r2,sp
        0x008104fa:    2000        .       MOVS     r0,#0
        0x008104fc:    e006        ..      B        0x81050c ; app_profile_callback + 520
        0x008104fe:    a02c        ,.      ADR      r0,{pc}+0xb2 ; 0x8105b0
        0x00810500:    c80f        ..      LDM      r0,{r0-r3}
        0x00810502:    e88d000f    ....    STM      sp,{r0-r3}
        0x00810506:    466a        jF      MOV      r2,sp
        0x00810508:    210e        .!      MOVS     r1,#0xe
        0x0081050a:    2001        .       MOVS     r0,#1
        0x0081050c:    f7fefed2    ....    BL       dis_set_parameter ; 0x80f2b4
        0x00810510:    4628        (F      MOV      r0,r5
        0x00810512:    b006        ..      ADD      sp,sp,#0x18
        0x00810514:    e5a6        ..      B        0x810064 ; app_handle_conn_state_evt + 244
;;;692                    {
;;;693                        const uint8_t DISSerialNumber[] = "RTKBeeSerialNum";
        0x00810516:    a02a        *.      ADR      r0,{pc}+0xaa ; 0x8105c0
        0x00810518:    c80f        ..      LDM      r0,{r0-r3}
        0x0081051a:    e88d000f    ....    STM      sp,{r0-r3}
;;;694                        dis_set_parameter(DIS_PARAM_SERIAL_NUMBER,
        0x0081051e:    2110        .!      MOVS     r1,#0x10
        0x00810520:    466a        jF      MOV      r2,sp
        0x00810522:    2002        .       MOVS     r0,#2
;;;695                                          sizeof(DISSerialNumber),
;;;696                                          (void *)DISSerialNumber);
;;;697    
;;;698                    }
        0x00810524:    e7f2        ..      B        0x81050c ; app_profile_callback + 520
;;;699                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_HARDWARE_REV_INDEX)
;;;700                    {
;;;701                        const uint8_t DISHardwareRev[] = "RTKBeeHardwareRev";
        0x00810526:    2214        ."      MOVS     r2,#0x14
        0x00810528:    a129        ).      ADR      r1,{pc}+0xa8 ; 0x8105d0
        0x0081052a:    4668        hF      MOV      r0,sp
        0x0081052c:    f449f53c    I.<.    BL       __aeabi_memcpy4 ; 0x59fa8
;;;702                        dis_set_parameter(DIS_PARAM_HARDWARE_REVISION,
        0x00810530:    2112        .!      MOVS     r1,#0x12
        0x00810532:    466a        jF      MOV      r2,sp
        0x00810534:    2003        .       MOVS     r0,#3
;;;703                                          sizeof(DISHardwareRev),
;;;704                                          (void *)DISHardwareRev);
;;;705                    }
        0x00810536:    e7e9        ..      B        0x81050c ; app_profile_callback + 520
;;;706                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_FIRMWARE_REV_INDEX)
;;;707                    {
;;;708                        const uint8_t DISFirmwareRev[] = "RTKBeeFirmwareRev";
        0x00810538:    2214        ."      MOVS     r2,#0x14
        0x0081053a:    a12a        *.      ADR      r1,{pc}+0xaa ; 0x8105e4
        0x0081053c:    4668        hF      MOV      r0,sp
        0x0081053e:    f449f533    I.3.    BL       __aeabi_memcpy4 ; 0x59fa8
;;;709                        dis_set_parameter(DIS_PARAM_FIRMWARE_REVISION,
        0x00810542:    2112        .!      MOVS     r1,#0x12
        0x00810544:    466a        jF      MOV      r2,sp
        0x00810546:    2004        .       MOVS     r0,#4
;;;710                                          sizeof(DISFirmwareRev),
;;;711                                          (void *)DISFirmwareRev);
;;;712                    }
        0x00810548:    e7e0        ..      B        0x81050c ; app_profile_callback + 520
;;;713                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_SOFTWARE_REV_INDEX)
;;;714                    {
;;;715                        const uint8_t DISSoftwareRev[] = "RTKBeeSoftwareRev";
        0x0081054a:    2214        ."      MOVS     r2,#0x14
        0x0081054c:    a12a        *.      ADR      r1,{pc}+0xac ; 0x8105f8
        0x0081054e:    4668        hF      MOV      r0,sp
        0x00810550:    f449f52a    I.*.    BL       __aeabi_memcpy4 ; 0x59fa8
;;;716                        dis_set_parameter(DIS_PARAM_SOFTWARE_REVISION,
        0x00810554:    2112        .!      MOVS     r1,#0x12
        0x00810556:    466a        jF      MOV      r2,sp
        0x00810558:    2005        .       MOVS     r0,#5
;;;717                                          sizeof(DISSoftwareRev),
;;;718                                          (void *)DISSoftwareRev);
;;;719                    }
        0x0081055a:    e7d7        ..      B        0x81050c ; app_profile_callback + 520
;;;720                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_SYSTEM_ID_INDEX)
;;;721                    {
;;;722                        const uint8_t DISSystemID[DIS_SYSTEM_ID_LENGTH] = {0, 1, 2, 0, 0, 3, 4, 5};
        0x0081055c:    a02b        +.      ADR      r0,{pc}+0xb0 ; 0x81060c
        0x0081055e:    466a        jF      MOV      r2,sp
        0x00810560:    e9d01000    ....    LDRD     r1,r0,[r0,#0]
;;;723                        dis_set_parameter(DIS_PARAM_SYSTEM_ID,
        0x00810564:    e9cd1000    ....    STRD     r1,r0,[sp,#0]
        0x00810568:    2108        .!      MOVS     r1,#8
        0x0081056a:    2006        .       MOVS     r0,#6
;;;724                                          sizeof(DISSystemID),
;;;725                                          (void *)DISSystemID);
;;;726    
;;;727                    }
        0x0081056c:    e7ce        ..      B        0x81050c ; app_profile_callback + 520
;;;728                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_IEEE_CERT_STR_INDEX)
;;;729                    {
;;;730                        const uint8_t DISIEEEDataList[] = "RTKBeeIEEEDatalist";
        0x0081056e:    2214        ."      MOVS     r2,#0x14
        0x00810570:    a128        (.      ADR      r1,{pc}+0xa4 ; 0x810614
        0x00810572:    4668        hF      MOV      r0,sp
        0x00810574:    f449f518    I...    BL       __aeabi_memcpy4 ; 0x59fa8
;;;731                        dis_set_parameter(DIS_PARAM_IEEE_DATA_LIST,
        0x00810578:    2113        .!      MOVS     r1,#0x13
        0x0081057a:    466a        jF      MOV      r2,sp
        0x0081057c:    2007        .       MOVS     r0,#7
;;;732                                          sizeof(DISIEEEDataList),
;;;733                                          (void *)DISIEEEDataList);
;;;734                    }
        0x0081057e:    e7c5        ..      B        0x81050c ; app_profile_callback + 520
;;;735                    else if (p_dis_cb_data->msg_data.read_value_index == DIS_READ_PNP_ID_INDEX)
;;;736                    {
;;;737                        uint8_t DISPnpID[DIS_PNP_ID_LENGTH] = {0};
        0x00810580:    9200        ..      STR      r2,[sp,#0]
;;;738                        dis_set_parameter(DIS_PARAM_PNP_ID,
        0x00810582:    9201        ..      STR      r2,[sp,#4]
        0x00810584:    2107        .!      MOVS     r1,#7
        0x00810586:    466a        jF      MOV      r2,sp
        0x00810588:    2008        .       MOVS     r0,#8
;;;739                                          sizeof(DISPnpID),
;;;740                                          DISPnpID);
;;;741                    }
        0x0081058a:    e7bf        ..      B        0x81050c ; app_profile_callback + 520
    $d
        0x0081058c:    08800674    t...    DCD    142607988
        0x00810590:    21103002    .0.!    DCD    554708994
        0x00810594:    08800c98    ....    DCD    142609560
        0x00810598:    002080d0    .. .    DCD    2130128
        0x0081059c:    00207eb4    .~ .    DCD    2129588
        0x008105a0:    08800db0    ....    DCD    142609840
        0x008105a4:    6c616552    Real    DCD    1818322258
        0x008105a8:    206b6574    tek     DCD    543909236
        0x008105ac:    00005442    BT..    DCD    21570
        0x008105b0:    65646f4d    Mode    DCD    1701080909
        0x008105b4:    624e206c    l Nb    DCD    1649287276
        0x008105b8:    2e302072    r 0.    DCD    774905970
        0x008105bc:    00000039    9...    DCD    57
        0x008105c0:    424b5452    RTKB    DCD    1112233042
        0x008105c4:    65536565    eeSe    DCD    1699964261
        0x008105c8:    6c616972    rial    DCD    1818323314
        0x008105cc:    006d754e    Num.    DCD    7173454
        0x008105d0:    424b5452    RTKB    DCD    1112233042
        0x008105d4:    61486565    eeHa    DCD    1632134501
        0x008105d8:    61776472    rdwa    DCD    1635214450
        0x008105dc:    65526572    reRe    DCD    1699898738
        0x008105e0:    00000076    v...    DCD    118
        0x008105e4:    424b5452    RTKB    DCD    1112233042
        0x008105e8:    69466565    eeFi    DCD    1766221157
        0x008105ec:    61776d72    rmwa    DCD    1635216754
        0x008105f0:    65526572    reRe    DCD    1699898738
        0x008105f4:    00000076    v...    DCD    118
        0x008105f8:    424b5452    RTKB    DCD    1112233042
        0x008105fc:    6f536565    eeSo    DCD    1867736421
        0x00810600:    61777466    ftwa    DCD    1635218534
        0x00810604:    65526572    reRe    DCD    1699898738
        0x00810608:    00000076    v...    DCD    118
        0x0081060c:    00020100    ....    DCD    131328
        0x00810610:    05040300    ....    DCD    84148992
        0x00810614:    424b5452    RTKB    DCD    1112233042
        0x00810618:    45496565    eeIE    DCD    1162437989
        0x0081061c:    61444545    EEDa    DCD    1631864133
        0x00810620:    696c6174    tali    DCD    1768710516
        0x00810624:    00007473    st..    DCD    29811
    $t
    .text
    load_overlay
;;; .\..\include\SDK\src\mcu\rtl876x\overlay_mgr.c
;;;116    {
        0x00810628:    b510        ..      PUSH     {r4,lr}
        0x0081062a:    2803        .(      CMP      r0,#3
;;; .\..\include\SDK\src\mcu\rtl876x\overlay_mgr.c (116)
        0x0081062c:    d301        ..      BCC      0x810632 ; load_overlay + 10
;;;117        const T_OVERLAY_SECTION *selected_scenario;
;;;118    
;;;119        if (scenario_idx >= OVERLAY_SCENARIO_NUM)
;;;120        {
;;;121            return false;
        0x0081062e:    2000        .       MOVS     r0,#0
        0x00810630:    bd10        ..      POP      {r4,pc}
;;;122        }
;;;123    
;;;124        selected_scenario = &overlay_sections[scenario_idx];
        0x00810632:    491a        .I      LDR      r1,[pc,#104] ; [0x81069c] = 0x207ebc
        0x00810634:    eb0000c0    ....    ADD      r0,r0,r0,LSL #3
        0x00810638:    eb010480    ....    ADD      r4,r1,r0,LSL #2
;;;125    
;;;126        if (memcmp(selected_scenario->signature, scenario_name, 8) == 0)
        0x0081063c:    2208        ."      MOVS     r2,#8
        0x0081063e:    4918        .I      LDR      r1,[pc,#96] ; [0x8106a0] = 0x2080dc
        0x00810640:    6820         h      LDR      r0,[r4,#0]
        0x00810642:    f449f3df    I...    BL       memcmp ; 0x59e04
        0x00810646:    b198        ..      CBZ      r0,0x810670 ; load_overlay + 72
;;;127        {
;;;128            return true;
;;;129        }
;;;130    
;;;131        /* load code */
;;;132        memcpy(selected_scenario->image_ro_base, selected_scenario->load_ro_base,
        0x00810648:    69a2        .i      LDR      r2,[r4,#0x18]
        0x0081064a:    6861        ah      LDR      r1,[r4,#4]
        0x0081064c:    68e0        .h      LDR      r0,[r4,#0xc]
        0x0081064e:    f449f424    I.$.    BL       __aeabi_memcpy ; 0x59e9a
;;;133               selected_scenario->ro_length);
;;;134        /* load rw data */
;;;135        memcpy(selected_scenario->image_rw_base, selected_scenario->load_rw_base,
        0x00810652:    69e2        .i      LDR      r2,[r4,#0x1c]
        0x00810654:    68a1        .h      LDR      r1,[r4,#8]
        0x00810656:    6920         i      LDR      r0,[r4,#0x10]
        0x00810658:    f449f41f    I...    BL       __aeabi_memcpy ; 0x59e9a
;;;136               selected_scenario->rw_length);
;;;137        /* clear zi data */
;;;138        memset(selected_scenario->image_zi_base, 0x0, selected_scenario->zi_length);
        0x0081065c:    6a21        !j      LDR      r1,[r4,#0x20]
        0x0081065e:    6960        `i      LDR      r0,[r4,#0x14]
        0x00810660:    f449f4dc    I...    BL       __aeabi_memclr ; 0x5a01c
;;;139    
;;;140        memcpy(scenario_name, selected_scenario->signature, 8);
        0x00810664:    6820         h      LDR      r0,[r4,#0]
        0x00810666:    490e        .I      LDR      r1,[pc,#56] ; [0x8106a0] = 0x2080dc
        0x00810668:    6802        .h      LDR      r2,[r0,#0]
        0x0081066a:    600a        .`      STR      r2,[r1,#0]
        0x0081066c:    6840        @h      LDR      r0,[r0,#4]
        0x0081066e:    6048        H`      STR      r0,[r1,#4]
        0x00810670:    2001        .       MOVS     r0,#1
;;;141    
;;;142        return true;
;;;143    }
        0x00810672:    bd10        ..      POP      {r4,pc}
    get_current_scenario_index
;;;144    
;;;145    T_OVERLAY_SCENARIO_IDX get_current_scenario_index(void)
;;;146    {
        0x00810674:    b570        p.      PUSH     {r4-r6,lr}
        0x00810676:    4d09        .M      LDR      r5,[pc,#36] ; [0x81069c] = 0x207ebc
;;;147        const T_OVERLAY_SECTION *selected_scenario;
;;;148    
;;;149        for (int i = 0; i < (int)OVERLAY_SCENARIO_NUM; ++i)
        0x00810678:    2400        .$      MOVS     r4,#0
        0x0081067a:    eb0400c4    ....    ADD      r0,r4,r4,LSL #3
        0x0081067e:    2208        ."      MOVS     r2,#8
        0x00810680:    f8550020    U. .    LDR      r0,[r5,r0,LSL #2]
        0x00810684:    4906        .I      LDR      r1,[pc,#24] ; [0x8106a0] = 0x2080dc
        0x00810686:    f449f3bd    I...    BL       memcmp ; 0x59e04
        0x0081068a:    b120         .      CBZ      r0,0x810696 ; get_current_scenario_index + 34
        0x0081068c:    1c64        d.      ADDS     r4,r4,#1
        0x0081068e:    2c03        .,      CMP      r4,#3
        0x00810690:    dbf3        ..      BLT      0x81067a ; get_current_scenario_index + 6
        0x00810692:    2003        .       MOVS     r0,#3
        0x00810694:    bd70        p.      POP      {r4-r6,pc}
;;;150        {
;;;151            selected_scenario = &overlay_sections[i];
;;;152            if (memcmp(selected_scenario->signature, scenario_name, 8) == 0)
;;;153            {
;;;154                return (T_OVERLAY_SCENARIO_IDX)i;
        0x00810696:    b2e0        ..      UXTB     r0,r4
;;;155            }
;;;156        }
;;;157    
;;;158        return OVERLAY_SCENARIO_NUM; //not found valid scenario
;;;159    }
        0x00810698:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x0081069a:    0000        ..      DCW    0
        0x0081069c:    00207ebc    .~ .    DCD    2129596
        0x008106a0:    002080dc    .. .    DCD    2130140
    $t
    .text
    gap_lib_handle_btif_msg
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (31)
        0x008106a4:    b510        ..      PUSH     {r4,lr}
        0x008106a6:    2201        ."      MOVS     r2,#1
        0x008106a8:    700a        .p      STRB     r2,[r1,#0]
        0x008106aa:    8841        A.      LDRH     r1,[r0,#2]
        0x008106ac:    2400        .$      MOVS     r4,#0
        0x008106ae:    290e        .)      CMP      r1,#0xe
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (31)
        0x008106b0:    d102        ..      BNE      0x8106b8 ; gap_lib_handle_btif_msg + 20
        0x008106b2:    1d00        ..      ADDS     r0,r0,#4
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (39)
        0x008106b4:    f000f8c1    ....    BL       le_handle_vendor_cmd_rsp ; 0x81083a
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (112)
        0x008106b8:    4620         F      MOV      r0,r4
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (113)
        0x008106ba:    bd10        ..      POP      {r4,pc}
    gap_lib_init
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (116)
        0x008106bc:    b570        p.      PUSH     {r4-r6,lr}
        0x008106be:    b088        ..      SUB      sp,sp,#0x20
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (117)
        0x008106c0:    2400        .$      MOVS     r4,#0
        0x008106c2:    9405        ..      STR      r4,[sp,#0x14]
        0x008106c4:    2501        .%      MOVS     r5,#1
        0x008106c6:    9406        ..      STR      r4,[sp,#0x18]
        0x008106c8:    e9cd5400    ...T    STRD     r5,r4,[sp,#0]
        0x008106cc:    4e0e        .N      LDR      r6,[pc,#56] ; [0x810708] = 0x21103500
        0x008106ce:    2308        .#      MOVS     r3,#8
        0x008106d0:    9403        ..      STR      r4,[sp,#0xc]
        0x008106d2:    9404        ..      STR      r4,[sp,#0x10]
        0x008106d4:    461a        .F      MOV      r2,r3
        0x008106d6:    490b        .I      LDR      r1,[pc,#44] ; [0x810704] = 0x8800e94
        0x008106d8:    4630        0F      MOV      r0,r6
        0x008106da:    9402        ..      STR      r4,[sp,#8]
        0x008106dc:    f7f7d9bf    ....    BL       log_buffer ; 0x7a5e
        0x008106e0:    4908        .I      LDR      r1,[pc,#32] ; [0x810704] = 0x8800e94
        0x008106e2:    e9cd4500    ...E    STRD     r4,r5,[sp,#0]
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (121)
        0x008106e6:    2300        .#      MOVS     r3,#0
        0x008106e8:    2204        ."      MOVS     r2,#4
        0x008106ea:    31ec        .1      ADDS     r1,r1,#0xec
        0x008106ec:    4630        0F      MOV      r0,r6
        0x008106ee:    9502        ..      STR      r5,[sp,#8]
        0x008106f0:    f7f7d9b5    ....    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (123)
        0x008106f4:    f2af0053    ..S.    ADR      r0,{pc}-0x4f ; 0x8106a5
        0x008106f8:    b008        ..      ADD      sp,sp,#0x20
        0x008106fa:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x008106fe:    f43bb387    ;...    B        gap_register_extend_cb ; 0x4be10
    $d
        0x00810702:    0000        ..      DCW    0
        0x00810704:    08800e94    ....    DCD    142610068
        0x00810708:    21103500    .5.!    DCD    554710272
    $t
    .text
    le_check_privacy_bond
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (163)
        0x0081070c:    b530        0.      PUSH     {r4,r5,lr}
        0x0081070e:    b08b        ..      SUB      sp,sp,#0x2c
        0x00810710:    f04f0100    O...    MOV      r1,#0
        0x00810714:    4d33        3M      LDR      r5,[pc,#204] ; [0x8107e4] = 0x21103502
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (163)
        0x00810716:    0004        ..      MOVS     r4,r0
        0x00810718:    9106        ..      STR      r1,[sp,#0x18]
        0x0081071a:    9107        ..      STR      r1,[sp,#0x1c]
        0x0081071c:    9108        ..      STR      r1,[sp,#0x20]
        0x0081071e:    9109        ..      STR      r1,[sp,#0x24]
        0x00810720:    d002        ..      BEQ      0x810728 ; le_check_privacy_bond + 28
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (166)
        0x00810722:    7820         x      LDRB     r0,[r4,#0]
        0x00810724:    2801        .(      CMP      r0,#1
        0x00810726:    d008        ..      BEQ      0x81073a ; le_check_privacy_bond + 46
        0x00810728:    2301        .#      MOVS     r3,#1
        0x0081072a:    2201        ."      MOVS     r2,#1
        0x0081072c:    492e        .I      LDR      r1,[pc,#184] ; [0x8107e8] = 0x880102c
        0x0081072e:    4628        (F      MOV      r0,r5
        0x00810730:    f7f7d995    ....    BL       log_buffer ; 0x7a5e
        0x00810734:    2000        .       MOVS     r0,#0
        0x00810736:    b00b        ..      ADD      sp,sp,#0x2c
        0x00810738:    bd30        0.      POP      {r4,r5,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (168)
        0x0081073a:    78a0        .x      LDRB     r0,[r4,#2]
        0x0081073c:    0700        ..      LSLS     r0,r0,#28
        0x0081073e:    d518        ..      BPL      0x810772 ; le_check_privacy_bond + 102
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (171)
        0x00810740:    466a        jF      MOV      r2,sp
        0x00810742:    2114        .!      MOVS     r1,#0x14
        0x00810744:    4620         F      MOV      r0,r4
        0x00810746:    f43ff60d    ?...    BL       le_get_key ; 0x50364
        0x0081074a:    b180        ..      CBZ      r0,0x81076e ; le_check_privacy_bond + 98
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (173)
        0x0081074c:    2210        ."      MOVS     r2,#0x10
        0x0081074e:    a906        ..      ADD      r1,sp,#0x18
        0x00810750:    4668        hF      MOV      r0,sp
        0x00810752:    f449f357    I.W.    BL       memcmp ; 0x59e04
        0x00810756:    b140        @.      CBZ      r0,0x81076a ; le_check_privacy_bond + 94
        0x00810758:    4923        #I      LDR      r1,[pc,#140] ; [0x8107e8] = 0x880102c
        0x0081075a:    7863        cx      LDRB     r3,[r4,#1]
        0x0081075c:    2201        ."      MOVS     r2,#1
        0x0081075e:    3930        09      SUBS     r1,r1,#0x30
        0x00810760:    4628        (F      MOV      r0,r5
        0x00810762:    f7f7d97c    ..|.    BL       log_buffer ; 0x7a5e
        0x00810766:    2001        .       MOVS     r0,#1
        0x00810768:    e7e5        ..      B        0x810736 ; le_check_privacy_bond + 42
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (175)
        0x0081076a:    2305        .#      MOVS     r3,#5
        0x0081076c:    e7dd        ..      B        0x81072a ; le_check_privacy_bond + 30
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (185)
        0x0081076e:    2304        .#      MOVS     r3,#4
        0x00810770:    e7db        ..      B        0x81072a ; le_check_privacy_bond + 30
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (190)
        0x00810772:    2302        .#      MOVS     r3,#2
        0x00810774:    e7d9        ..      B        0x81072a ; le_check_privacy_bond + 30
    le_bond_just_work_confirm
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (202)
        0x00810776:    460a        .F      MOV      r2,r1
        0x00810778:    eb000140    ..@.    ADD      r1,r0,r0,LSL #1
        0x0081077c:    481b        .H      LDR      r0,[pc,#108] ; [0x8107ec] = 0x202e64
        0x0081077e:    b510        ..      PUSH     {r4,lr}
        0x00810780:    6800        .h      LDR      r0,[r0,#0]
        0x00810782:    eb001001    ....    ADD      r0,r0,r1,LSL #4
        0x00810786:    7801        .x      LDRB     r1,[r0,#0]
        0x00810788:    b129        ).      CBZ      r1,0x810796 ; le_bond_just_work_confirm + 32
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (205)
        0x0081078a:    7981        .y      LDRB     r1,[r0,#6]
        0x0081078c:    1dc0        ..      ADDS     r0,r0,#7
        0x0081078e:    f410f764    ..d.    BL       btif_just_work_req_cfm ; 0x2165a
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (207)
        0x00810792:    2000        .       MOVS     r0,#0
        0x00810794:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (211)
        0x00810796:    2004        .       MOVS     r0,#4
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (213)
        0x00810798:    bd10        ..      POP      {r4,pc}
    le_bond_get_sec_level
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (226)
        0x0081079a:    b510        ..      PUSH     {r4,lr}
        0x0081079c:    b08a        ..      SUB      sp,sp,#0x28
        0x0081079e:    460c        .F      MOV      r4,r1
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (229)
        0x008107a0:    2100        .!      MOVS     r1,#0
        0x008107a2:    7021        !p      STRB     r1,[r4,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (230)
        0x008107a4:    aa09        ..      ADD      r2,sp,#0x24
        0x008107a6:    a907        ..      ADD      r1,sp,#0x1c
        0x008107a8:    f43df221    =.!.    BL       le_get_conn_addr ; 0x4dbee
        0x008107ac:    b1c0        ..      CBZ      r0,0x8107e0 ; le_bond_get_sec_level + 70
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (233)
        0x008107ae:    f89d1024    ..$.    LDRB     r1,[sp,#0x24]
        0x008107b2:    a807        ..      ADD      r0,sp,#0x1c
        0x008107b4:    f43ff4eb    ?...    BL       le_find_key_entry ; 0x5018e
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (234)
        0x008107b8:    b190        ..      CBZ      r0,0x8107e0 ; le_bond_get_sec_level + 70
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (237)
        0x008107ba:    466a        jF      MOV      r2,sp
        0x008107bc:    2111        .!      MOVS     r1,#0x11
        0x008107be:    f43ff5d1    ?...    BL       le_get_key ; 0x50364
        0x008107c2:    b168        h.      CBZ      r0,0x8107e0 ; le_bond_get_sec_level + 70
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (239)
        0x008107c4:    4908        .I      LDR      r1,[pc,#32] ; [0x8107e8] = 0x880102c
        0x008107c6:    f89d301b    ...0    LDRB     r3,[sp,#0x1b]
        0x008107ca:    2201        ."      MOVS     r2,#1
        0x008107cc:    3138        81      ADDS     r1,r1,#0x38
        0x008107ce:    4805        .H      LDR      r0,[pc,#20] ; [0x8107e4] = 0x21103502
        0x008107d0:    f7f7d945    ..E.    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (240)
        0x008107d4:    f89d001b    ....    LDRB     r0,[sp,#0x1b]
        0x008107d8:    7020         p      STRB     r0,[r4,#0]
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (241)
        0x008107da:    2000        .       MOVS     r0,#0
        0x008107dc:    b00a        ..      ADD      sp,sp,#0x28
        0x008107de:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (245)
        0x008107e0:    2003        .       MOVS     r0,#3
;;; ..\..\..\src\app\gap_lib\common\gap_lib_patch.c (246)
        0x008107e2:    e7fb        ..      B        0x8107dc ; le_bond_get_sec_level + 66
    $d
        0x008107e4:    21103502    .5.!    DCD    554710274
        0x008107e8:    0880102c    ,...    DCD    142610476
        0x008107ec:    00202e64    d. .    DCD    2109028
    $t
    .text
    gap_set_lps_bootup_active_time
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (43)
        0x008107f0:    b508        ..      PUSH     {r3,lr}
        0x008107f2:    1ec1        ..      SUBS     r1,r0,#3
        0x008107f4:    f24072fe    @..r    MOV      r2,#0x7fe
        0x008107f8:    4291        .B      CMP      r1,r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (43)
        0x008107fa:    d301        ..      BCC      0x810800 ; gap_set_lps_bootup_active_time + 16
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (48)
        0x008107fc:    2000        .       MOVS     r0,#0
        0x008107fe:    bd08        ..      POP      {r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (50)
        0x00810800:    2105        .!      MOVS     r1,#5
        0x00810802:    f88d1000    ....    STRB     r1,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (51)
        0x00810806:    f88d0001    ....    STRB     r0,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (52)
        0x0081080a:    0a00        ..      LSRS     r0,r0,#8
        0x0081080c:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (54)
        0x00810810:    466a        jF      MOV      r2,sp
        0x00810812:    2103        .!      MOVS     r1,#3
        0x00810814:    f64f406e    O.n@    MOV      r0,#0xfc6e
        0x00810818:    f410f668    ..h.    BL       btif_vendor_cmd_req ; 0x214ec
        0x0081081c:    2800        .(      CMP      r0,#0
        0x0081081e:    d0ee        ..      BEQ      0x8107fe ; gap_set_lps_bootup_active_time + 14
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (56)
        0x00810820:    2001        .       MOVS     r0,#1
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (59)
        0x00810822:    bd08        ..      POP      {r3,pc}
    lps_get_wakeup_time
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (62)
        0x00810824:    b530        0.      PUSH     {r4,r5,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (63)
        0x00810826:    4b20         K      LDR      r3,[pc,#128] ; [0x8108a8] = 0x201b1c
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (64)
        0x00810828:    681d        .h      LDR      r5,[r3,#0]
        0x0081082a:    1d1b        ..      ADDS     r3,r3,#4
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (65)
        0x0081082c:    681c        .h      LDR      r4,[r3,#0]
        0x0081082e:    1d1b        ..      ADDS     r3,r3,#4
        0x00810830:    681b        .h      LDR      r3,[r3,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (67)
        0x00810832:    6005        .`      STR      r5,[r0,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (68)
        0x00810834:    600c        .`      STR      r4,[r1,#0]
        0x00810836:    6013        .`      STR      r3,[r2,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (69)
        0x00810838:    bd30        0.      POP      {r4,r5,pc}
    le_handle_vendor_cmd_rsp
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (169)
        0x0081083a:    b508        ..      PUSH     {r3,lr}
        0x0081083c:    8801        ..      LDRH     r1,[r0,#0]
        0x0081083e:    f5a1427c    ..|B    SUB      r2,r1,#0xfc00
        0x00810842:    3a6e        n:      SUBS     r2,r2,#0x6e
        0x00810844:    d109        ..      BNE      0x81085a ; le_handle_vendor_cmd_rsp + 32
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (250)
        0x00810846:    8840        @.      LDRH     r0,[r0,#2]
        0x00810848:    f8ad0000    ....    STRH     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (251)
        0x0081084c:    4817        .H      LDR      r0,[pc,#92] ; [0x8108ac] = 0x202e48
        0x0081084e:    6802        .h      LDR      r2,[r0,#0]
        0x00810850:    2a00        .*      CMP      r2,#0
        0x00810852:    d002        ..      BEQ      0x81085a ; le_handle_vendor_cmd_rsp + 32
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (253)
        0x00810854:    4669        iF      MOV      r1,sp
        0x00810856:    20a6        .       MOVS     r0,#0xa6
        0x00810858:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (258)
        0x0081085a:    bd08        ..      POP      {r3,pc}
    le_vendor_modify_bt_le_fw_policy
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (262)
        0x0081085c:    b50e        ..      PUSH     {r1-r3,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (265)
        0x0081085e:    2210        ."      MOVS     r2,#0x10
        0x00810860:    f88d2000    ...     STRB     r2,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (266)
        0x00810864:    f88d0001    ....    STRB     r0,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (267)
        0x00810868:    0a02        ..      LSRS     r2,r0,#8
        0x0081086a:    f88d2002    ...     STRB     r2,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (268)
        0x0081086e:    0c02        ..      LSRS     r2,r0,#16
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (269)
        0x00810870:    0e00        ..      LSRS     r0,r0,#24
        0x00810872:    f88d0004    ....    STRB     r0,[sp,#4]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (270)
        0x00810876:    f88d1005    ....    STRB     r1,[sp,#5]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (271)
        0x0081087a:    0a08        ..      LSRS     r0,r1,#8
        0x0081087c:    f88d0006    ....    STRB     r0,[sp,#6]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (272)
        0x00810880:    0c08        ..      LSRS     r0,r1,#16
        0x00810882:    f88d0007    ....    STRB     r0,[sp,#7]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (273)
        0x00810886:    0e08        ..      LSRS     r0,r1,#24
        0x00810888:    f88d2003    ...     STRB     r2,[sp,#3]
        0x0081088c:    f88d0008    ....    STRB     r0,[sp,#8]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (275)
        0x00810890:    466a        jF      MOV      r2,sp
        0x00810892:    2109        .!      MOVS     r1,#9
        0x00810894:    f64f5080    O..P    MOV      r0,#0xfd80
        0x00810898:    f410f628    ..(.    BL       btif_vendor_cmd_req ; 0x214ec
        0x0081089c:    b108        ..      CBZ      r0,0x8108a2 ; le_vendor_modify_bt_le_fw_policy + 70
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (277)
        0x0081089e:    2000        .       MOVS     r0,#0
        0x008108a0:    bd0e        ..      POP      {r1-r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (279)
        0x008108a2:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (286)
        0x008108a4:    bd0e        ..      POP      {r1-r3,pc}
    $d
        0x008108a6:    0000        ..      DCW    0
        0x008108a8:    00201b1c    .. .    DCD    2104092
        0x008108ac:    00202e48    H. .    DCD    2109000
    $t
    x$fpl$fpinit
    $v0
    _fp_init
        0x008108b0:    f04f7040    O.@p    MOV      r0,#0x3000000
        0x008108b4:    eee10a10    ....    VMSR     FPSCR,r0
    __fplib_config_fpu_vfp
    __fplib_config_pureend_doubles
        0x008108b8:    4770        pG      BX       lr
        0x008108ba:    0000        ..      MOVS     r0,r0
    $d.realdata
    .constdata
    app_cb_table
        0x008108bc:    0e85d101    ....    DCD    243650817
        0x008108c0:    00000001    ....    DCD    1
        0x008108c4:    0080e6f3    ....    DCD    8447731
    .constdata
        0x008108c8:    00810fc8    ....    DCD    8458184
        0x008108cc:    00811074    t...    DCD    8458356
        0x008108d0:    00810fbc    ....    DCD    8458172
        0x008108d4:    0081107c    |...    DCD    8458364
        0x008108d8:    00811020     ...    DCD    8458272
        0x008108dc:    00811094    ....    DCD    8458388
        0x008108e0:    00811088    ....    DCD    8458376
        0x008108e4:    00811010    ....    DCD    8458256
        0x008108e8:    00811010    ....    DCD    8458256
        0x008108ec:    00811010    ....    DCD    8458256
        0x008108f0:    00811010    ....    DCD    8458256
        0x008108f4:    00810fb0    ....    DCD    8458160
        0x008108f8:    00811068    h...    DCD    8458344
        0x008108fc:    00811010    ....    DCD    8458256
        0x00810900:    00810fd8    ....    DCD    8458200
        0x00810904:    00811038    8...    DCD    8458296
        0x00810908:    0081104c    L...    DCD    8458316
        0x0081090c:    00810fb8    ....    DCD    8458168
        0x00810910:    00810fa0    ....    DCD    8458144
        0x00810914:    00810f20     ...    DCD    8458016
        0x00810918:    00810ef4    ....    DCD    8457972
        0x0081091c:    00811054    T...    DCD    8458324
        0x00810920:    00811008    ....    DCD    8458248
        0x00810924:    00810ff4    ....    DCD    8458228
        0x00810928:    00810f8c    ....    DCD    8458124
        0x0081092c:    00810f4c    L...    DCD    8458060
        0x00810930:    00810f6c    l...    DCD    8458092
        0x00810934:    00810ed0    ....    DCD    8457936
        0x00810938:    00810e9c    ....    DCD    8457884
        0x0081093c:    00810fac    ....    DCD    8458156
        0x00810940:    00810e94    ....    DCD    8457876
        0x00810944:    00810ec8    ....    DCD    8457928
        0x00810948:    00810e8c    ....    DCD    8457868
        0x0081094c:    00810ec0    ....    DCD    8457920
        0x00810950:    00810fa8    ....    DCD    8458152
        0x00810954:    00811040    @...    DCD    8458304
        0x00810958:    00810ea4    ....    DCD    8457892
        0x0081095c:    00810ed8    ....    DCD    8457944
        0x00810960:    00810f04    ....    DCD    8457988
        0x00810964:    00810f28    (...    DCD    8458024
        0x00810968:    00810f54    T...    DCD    8458068
        0x0081096c:    00810f74    t...    DCD    8458100
        0x00810970:    00810f38    8...    DCD    8458040
        0x00810974:    00810f14    ....    DCD    8458004
        0x00810978:    00810fd4    ....    DCD    8458196
        0x0081097c:    00810ee8    ....    DCD    8457960
        0x00810980:    00810eb4    ....    DCD    8457908
        0x00810984:    00810efc    ....    DCD    8457980
        0x00810988:    00810f44    D...    DCD    8458052
        0x0081098c:    00810f64    d...    DCD    8458084
        0x00810990:    00810f84    ....    DCD    8458116
        0x00810994:    00810f98    ....    DCD    8458136
        0x00810998:    0081102c    ,...    DCD    8458284
        0x0081099c:    00811018    ....    DCD    8458264
        0x008109a0:    00811060    `...    DCD    8458336
        0x008109a4:    00810fe0    ....    DCD    8458208
        0x008109a8:    00810fc0    ....    DCD    8458176
        0x008109ac:    008110a0    ....    DCD    8458400
        0x008109b0:    00810ffc    ....    DCD    8458236
        0x008109b4:    00810fe8    ....    DCD    8458216
        0x008109b8:    00810fb4    ....    DCD    8458164
    .constdata
    ias_attr_tbl
        0x008109bc:    28000802    ...(    DCD    671090690
        0x008109c0:    00001802    ....    DCD    6146
        0x008109c4:    00000000    ....    DCD    0
        0x008109c8:    00000000    ....    DCD    0
        0x008109cc:    00020000    ....    DCD    131072
        0x008109d0:    00000000    ....    DCD    0
        0x008109d4:    00000001    ....    DCD    1
        0x008109d8:    28030002    ...(    DCD    671285250
        0x008109dc:    00000004    ....    DCD    4
        0x008109e0:    00000000    ....    DCD    0
        0x008109e4:    00000000    ....    DCD    0
        0x008109e8:    00010000    ....    DCD    65536
        0x008109ec:    00000000    ....    DCD    0
        0x008109f0:    00000001    ....    DCD    1
        0x008109f4:    2a060004    ...*    DCD    705036292
        0x008109f8:    00000000    ....    DCD    0
        0x008109fc:    00000000    ....    DCD    0
        0x00810a00:    00000000    ....    DCD    0
        0x00810a04:    00000000    ....    DCD    0
        0x00810a08:    00000000    ....    DCD    0
        0x00810a0c:    00000011    ....    DCD    17
    ias_cbs
        0x00810a10:    00000000    ....    DCD    0
        0x00810a14:    0080ed39    9...    DCD    8449337
        0x00810a18:    00000000    ....    DCD    0
    .constdata
    lls_attr_tbl
        0x00810a1c:    28000802    ...(    DCD    671090690
        0x00810a20:    00001803    ....    DCD    6147
        0x00810a24:    00000000    ....    DCD    0
        0x00810a28:    00000000    ....    DCD    0
        0x00810a2c:    00020000    ....    DCD    131072
        0x00810a30:    00000000    ....    DCD    0
        0x00810a34:    00000001    ....    DCD    1
        0x00810a38:    28030002    ...(    DCD    671285250
        0x00810a3c:    0000000a    ....    DCD    10
        0x00810a40:    00000000    ....    DCD    0
        0x00810a44:    00000000    ....    DCD    0
        0x00810a48:    00010000    ....    DCD    65536
        0x00810a4c:    00000000    ....    DCD    0
        0x00810a50:    00000001    ....    DCD    1
        0x00810a54:    2a060004    ...*    DCD    705036292
        0x00810a58:    00000000    ....    DCD    0
        0x00810a5c:    00000000    ....    DCD    0
        0x00810a60:    00000000    ....    DCD    0
        0x00810a64:    00000000    ....    DCD    0
        0x00810a68:    00000000    ....    DCD    0
        0x00810a6c:    00000011    ....    DCD    17
    lls_cbs
        0x00810a70:    0080edfb    ....    DCD    8449531
        0x00810a74:    0080ee5d    ]...    DCD    8449629
        0x00810a78:    00000000    ....    DCD    0
    .constdata
    tps_attr_tbl
        0x00810a7c:    28000802    ...(    DCD    671090690
        0x00810a80:    00001804    ....    DCD    6148
        0x00810a84:    00000000    ....    DCD    0
        0x00810a88:    00000000    ....    DCD    0
        0x00810a8c:    00020000    ....    DCD    131072
        0x00810a90:    00000000    ....    DCD    0
        0x00810a94:    00000001    ....    DCD    1
        0x00810a98:    28030002    ...(    DCD    671285250
        0x00810a9c:    00000002    ....    DCD    2
        0x00810aa0:    00000000    ....    DCD    0
        0x00810aa4:    00000000    ....    DCD    0
        0x00810aa8:    00010000    ....    DCD    65536
        0x00810aac:    00000000    ....    DCD    0
        0x00810ab0:    00000001    ....    DCD    1
        0x00810ab4:    2a070004    ...*    DCD    705101828
        0x00810ab8:    00000000    ....    DCD    0
        0x00810abc:    00000000    ....    DCD    0
        0x00810ac0:    00000000    ....    DCD    0
        0x00810ac4:    00000000    ....    DCD    0
        0x00810ac8:    00000000    ....    DCD    0
        0x00810acc:    00000001    ....    DCD    1
    tps_cbs
        0x00810ad0:    0080ef1f    ....    DCD    8449823
        0x00810ad4:    00000000    ....    DCD    0
        0x00810ad8:    00000000    ....    DCD    0
    .constdata
    bas_attr_tbl
        0x00810adc:    28000802    ...(    DCD    671090690
        0x00810ae0:    0000180f    ....    DCD    6159
        0x00810ae4:    00000000    ....    DCD    0
        0x00810ae8:    00000000    ....    DCD    0
        0x00810aec:    00020000    ....    DCD    131072
        0x00810af0:    00000000    ....    DCD    0
        0x00810af4:    00000001    ....    DCD    1
        0x00810af8:    28030002    ...(    DCD    671285250
        0x00810afc:    00000012    ....    DCD    18
        0x00810b00:    00000000    ....    DCD    0
        0x00810b04:    00000000    ....    DCD    0
        0x00810b08:    00010000    ....    DCD    65536
        0x00810b0c:    00000000    ....    DCD    0
        0x00810b10:    00000001    ....    DCD    1
        0x00810b14:    2a190004    ...*    DCD    706281476
        0x00810b18:    00000000    ....    DCD    0
        0x00810b1c:    00000000    ....    DCD    0
        0x00810b20:    00000000    ....    DCD    0
        0x00810b24:    00000000    ....    DCD    0
        0x00810b28:    00000000    ....    DCD    0
        0x00810b2c:    00000001    ....    DCD    1
        0x00810b30:    29020012    ...)    DCD    687996946
        0x00810b34:    00000000    ....    DCD    0
        0x00810b38:    00000000    ....    DCD    0
        0x00810b3c:    00000000    ....    DCD    0
        0x00810b40:    00020000    ....    DCD    131072
        0x00810b44:    00000000    ....    DCD    0
        0x00810b48:    00000011    ....    DCD    17
    bas_cbs
        0x00810b4c:    0080f02f    /...    DCD    8450095
        0x00810b50:    00000000    ....    DCD    0
        0x00810b54:    0080f097    ....    DCD    8450199
    .constdata
    GATT_UUID128_KNS_SERVICE
        0x00810b58:    07f6f6a6    ....    DCD    133625510
        0x00810b5c:    989dc44d    M...    DCD    2560476237
        0x00810b60:    bb29456d    mE).    DCD    3140044141
        0x00810b64:    0000ffd0    ....    DCD    65488
    .constdata
    kns_attr_tbl
        0x00810b68:    28000800    ...(    DCD    671090688
        0x00810b6c:    00000000    ....    DCD    0
        0x00810b70:    00000000    ....    DCD    0
        0x00810b74:    00000000    ....    DCD    0
        0x00810b78:    00100000    ....    DCD    1048576
        0x00810b7c:    00810b58    X...    DCD    8457048
        0x00810b80:    00000001    ....    DCD    1
        0x00810b84:    28030002    ...(    DCD    671285250
        0x00810b88:    0000000a    ....    DCD    10
        0x00810b8c:    00000000    ....    DCD    0
        0x00810b90:    00000000    ....    DCD    0
        0x00810b94:    00010000    ....    DCD    65536
        0x00810b98:    00000000    ....    DCD    0
        0x00810b9c:    00000001    ....    DCD    1
        0x00810ba0:    f6a60005    ....    DCD    4138074117
        0x00810ba4:    c44d07f6    ..M.    DCD    3293382646
        0x00810ba8:    456d989d    ..mE    DCD    1164810397
        0x00810bac:    ffd1bb29    )...    DCD    4291935017
        0x00810bb0:    00000000    ....    DCD    0
        0x00810bb4:    00000000    ....    DCD    0
        0x00810bb8:    00000011    ....    DCD    17
        0x00810bbc:    28030002    ...(    DCD    671285250
        0x00810bc0:    00000010    ....    DCD    16
        0x00810bc4:    00000000    ....    DCD    0
        0x00810bc8:    00000000    ....    DCD    0
        0x00810bcc:    00010000    ....    DCD    65536
        0x00810bd0:    00000000    ....    DCD    0
        0x00810bd4:    00000001    ....    DCD    1
        0x00810bd8:    f6a60005    ....    DCD    4138074117
        0x00810bdc:    c44d07f6    ..M.    DCD    3293382646
        0x00810be0:    456d989d    ..mE    DCD    1164810397
        0x00810be4:    ffd2bb29    )...    DCD    4292000553
        0x00810be8:    00000000    ....    DCD    0
        0x00810bec:    00000000    ....    DCD    0
        0x00810bf0:    00000001    ....    DCD    1
        0x00810bf4:    29020012    ...)    DCD    687996946
        0x00810bf8:    00000000    ....    DCD    0
        0x00810bfc:    00000000    ....    DCD    0
        0x00810c00:    00000000    ....    DCD    0
        0x00810c04:    00020000    ....    DCD    131072
        0x00810c08:    00000000    ....    DCD    0
        0x00810c0c:    00000011    ....    DCD    17
    kns_cbs
        0x00810c10:    0080f15f    _...    DCD    8450399
        0x00810c14:    0080f1bf    ....    DCD    8450495
        0x00810c18:    0080f20f    ....    DCD    8450575
    .constdata
    dis_attr_tbl
        0x00810c1c:    28000802    ...(    DCD    671090690
        0x00810c20:    0000180a    ....    DCD    6154
        0x00810c24:    00000000    ....    DCD    0
        0x00810c28:    00000000    ....    DCD    0
        0x00810c2c:    00020000    ....    DCD    131072
        0x00810c30:    00000000    ....    DCD    0
        0x00810c34:    00000001    ....    DCD    1
        0x00810c38:    28030002    ...(    DCD    671285250
        0x00810c3c:    00000002    ....    DCD    2
        0x00810c40:    00000000    ....    DCD    0
        0x00810c44:    00000000    ....    DCD    0
        0x00810c48:    00010000    ....    DCD    65536
        0x00810c4c:    00000000    ....    DCD    0
        0x00810c50:    00000001    ....    DCD    1
        0x00810c54:    2a290004    ..)*    DCD    707330052
        0x00810c58:    00000000    ....    DCD    0
        0x00810c5c:    00000000    ....    DCD    0
        0x00810c60:    00000000    ....    DCD    0
        0x00810c64:    00000000    ....    DCD    0
        0x00810c68:    00000000    ....    DCD    0
        0x00810c6c:    00000001    ....    DCD    1
        0x00810c70:    28030002    ...(    DCD    671285250
        0x00810c74:    00000002    ....    DCD    2
        0x00810c78:    00000000    ....    DCD    0
        0x00810c7c:    00000000    ....    DCD    0
        0x00810c80:    00010000    ....    DCD    65536
        0x00810c84:    00000000    ....    DCD    0
        0x00810c88:    00000001    ....    DCD    1
        0x00810c8c:    2a240004    ..$*    DCD    707002372
        0x00810c90:    00000000    ....    DCD    0
        0x00810c94:    00000000    ....    DCD    0
        0x00810c98:    00000000    ....    DCD    0
        0x00810c9c:    00000000    ....    DCD    0
        0x00810ca0:    00000000    ....    DCD    0
        0x00810ca4:    00000001    ....    DCD    1
        0x00810ca8:    28030002    ...(    DCD    671285250
        0x00810cac:    00000002    ....    DCD    2
        0x00810cb0:    00000000    ....    DCD    0
        0x00810cb4:    00000000    ....    DCD    0
        0x00810cb8:    00010000    ....    DCD    65536
        0x00810cbc:    00000000    ....    DCD    0
        0x00810cc0:    00000001    ....    DCD    1
        0x00810cc4:    2a250004    ..%*    DCD    707067908
        0x00810cc8:    00000000    ....    DCD    0
        0x00810ccc:    00000000    ....    DCD    0
        0x00810cd0:    00000000    ....    DCD    0
        0x00810cd4:    00000000    ....    DCD    0
        0x00810cd8:    00000000    ....    DCD    0
        0x00810cdc:    00000001    ....    DCD    1
        0x00810ce0:    28030002    ...(    DCD    671285250
        0x00810ce4:    00000002    ....    DCD    2
        0x00810ce8:    00000000    ....    DCD    0
        0x00810cec:    00000000    ....    DCD    0
        0x00810cf0:    00010000    ....    DCD    65536
        0x00810cf4:    00000000    ....    DCD    0
        0x00810cf8:    00000001    ....    DCD    1
        0x00810cfc:    2a270004    ..'*    DCD    707198980
        0x00810d00:    00000000    ....    DCD    0
        0x00810d04:    00000000    ....    DCD    0
        0x00810d08:    00000000    ....    DCD    0
        0x00810d0c:    00000000    ....    DCD    0
        0x00810d10:    00000000    ....    DCD    0
        0x00810d14:    00000001    ....    DCD    1
        0x00810d18:    28030002    ...(    DCD    671285250
        0x00810d1c:    00000002    ....    DCD    2
        0x00810d20:    00000000    ....    DCD    0
        0x00810d24:    00000000    ....    DCD    0
        0x00810d28:    00010000    ....    DCD    65536
        0x00810d2c:    00000000    ....    DCD    0
        0x00810d30:    00000001    ....    DCD    1
        0x00810d34:    2a260004    ..&*    DCD    707133444
        0x00810d38:    00000000    ....    DCD    0
        0x00810d3c:    00000000    ....    DCD    0
        0x00810d40:    00000000    ....    DCD    0
        0x00810d44:    00000000    ....    DCD    0
        0x00810d48:    00000000    ....    DCD    0
        0x00810d4c:    00000001    ....    DCD    1
        0x00810d50:    28030002    ...(    DCD    671285250
        0x00810d54:    00000002    ....    DCD    2
        0x00810d58:    00000000    ....    DCD    0
        0x00810d5c:    00000000    ....    DCD    0
        0x00810d60:    00010000    ....    DCD    65536
        0x00810d64:    00000000    ....    DCD    0
        0x00810d68:    00000001    ....    DCD    1
        0x00810d6c:    2a280004    ..(*    DCD    707264516
        0x00810d70:    00000000    ....    DCD    0
        0x00810d74:    00000000    ....    DCD    0
        0x00810d78:    00000000    ....    DCD    0
        0x00810d7c:    00000000    ....    DCD    0
        0x00810d80:    00000000    ....    DCD    0
        0x00810d84:    00000001    ....    DCD    1
        0x00810d88:    28030002    ...(    DCD    671285250
        0x00810d8c:    00000002    ....    DCD    2
        0x00810d90:    00000000    ....    DCD    0
        0x00810d94:    00000000    ....    DCD    0
        0x00810d98:    00010000    ....    DCD    65536
        0x00810d9c:    00000000    ....    DCD    0
        0x00810da0:    00000001    ....    DCD    1
        0x00810da4:    2a230004    ..#*    DCD    706936836
        0x00810da8:    00000000    ....    DCD    0
        0x00810dac:    00000000    ....    DCD    0
        0x00810db0:    00000000    ....    DCD    0
        0x00810db4:    00000000    ....    DCD    0
        0x00810db8:    00000000    ....    DCD    0
        0x00810dbc:    00000001    ....    DCD    1
        0x00810dc0:    28030002    ...(    DCD    671285250
        0x00810dc4:    00000002    ....    DCD    2
        0x00810dc8:    00000000    ....    DCD    0
        0x00810dcc:    00000000    ....    DCD    0
        0x00810dd0:    00010000    ....    DCD    65536
        0x00810dd4:    00000000    ....    DCD    0
        0x00810dd8:    00000001    ....    DCD    1
        0x00810ddc:    2a2a0004    ..**    DCD    707395588
        0x00810de0:    00000000    ....    DCD    0
        0x00810de4:    00000000    ....    DCD    0
        0x00810de8:    00000000    ....    DCD    0
        0x00810dec:    00000000    ....    DCD    0
        0x00810df0:    00000000    ....    DCD    0
        0x00810df4:    00000001    ....    DCD    1
        0x00810df8:    28030002    ...(    DCD    671285250
        0x00810dfc:    00000002    ....    DCD    2
        0x00810e00:    00000000    ....    DCD    0
        0x00810e04:    00000000    ....    DCD    0
        0x00810e08:    00010000    ....    DCD    65536
        0x00810e0c:    00000000    ....    DCD    0
        0x00810e10:    00000001    ....    DCD    1
        0x00810e14:    2a500004    ..P*    DCD    709885956
        0x00810e18:    00000000    ....    DCD    0
        0x00810e1c:    00000000    ....    DCD    0
        0x00810e20:    00000000    ....    DCD    0
        0x00810e24:    00000000    ....    DCD    0
        0x00810e28:    00000000    ....    DCD    0
        0x00810e2c:    00000001    ....    DCD    1
    dis_cbs
        0x00810e30:    0080f381    ....    DCD    8450945
        0x00810e34:    00000000    ....    DCD    0
        0x00810e38:    00000000    ....    DCD    0
    .constdata
    __func__
        0x00810e3c:    5f707061    app_    DCD    1601204321
        0x00810e40:    646e6573    send    DCD    1684956531
        0x00810e44:    67736d5f    _msg    DCD    1735617887
        0x00810e48:    5f6f745f    _to_    DCD    1601139807
        0x00810e4c:    74707061    appt    DCD    1953525857
        0x00810e50:    006b7361    ask.    DCD    7041889
    __func__
        0x00810e54:    5f707061    app_    DCD    1601204321
        0x00810e58:    6e69616d    main    DCD    1852399981
        0x00810e5c:    7361745f    _tas    DCD    1935766623
        0x00810e60:    0000006b    k...    DCD    107
    .constdata
        0x00810e64:    4c414552    REAL    DCD    1279346002
        0x00810e68:    5058505f    _PXP    DCD    1347965023
        0x00810e6c:    00000000    ....    DCD    0
        0x00810e70:    00000000    ....    DCD    0
        0x00810e74:    00000000    ....    DCD    0
        0x00810e78:    00000000    ....    DCD    0
        0x00810e7c:    00000000    ....    DCD    0
        0x00810e80:    00000000    ....    DCD    0
        0x00810e84:    00000000    ....    DCD    0
        0x00810e88:    00000000    ....    DCD    0
    .conststring
        0x00810e8c:    30433249    I2C0    DCD    809710153
        0x00810e90:    00000000    ....    DCD    0
        0x00810e94:    30495053    SPI0    DCD    810111059
        0x00810e98:    00000000    ....    DCD    0
        0x00810e9c:    54524155    UART    DCD    1414676821
        0x00810ea0:    00000030    0...    DCD    48
        0x00810ea4:    414d4447    GDMA    DCD    1095582791
        0x00810ea8:    68432030    0 Ch    DCD    1749229616
        0x00810eac:    656e6e61    anne    DCD    1701736033
        0x00810eb0:    0000306c    l0..    DCD    12396
        0x00810eb4:    4f495047    GPIO    DCD    1330204743
        0x00810eb8:    6f72475f    _Gro    DCD    1869760351
        0x00810ebc:    00307075    up0.    DCD    3174517
        0x00810ec0:    31433249    I2C1    DCD    826487369
        0x00810ec4:    00000000    ....    DCD    0
        0x00810ec8:    31495053    SPI1    DCD    826888275
        0x00810ecc:    00000000    ....    DCD    0
        0x00810ed0:    54524155    UART    DCD    1414676821
        0x00810ed4:    00000031    1...    DCD    49
        0x00810ed8:    414d4447    GDMA    DCD    1095582791
        0x00810edc:    68432030    0 Ch    DCD    1749229616
        0x00810ee0:    656e6e61    anne    DCD    1701736033
        0x00810ee4:    0000316c    l1..    DCD    12652
        0x00810ee8:    4f495047    GPIO    DCD    1330204743
        0x00810eec:    6f72475f    _Gro    DCD    1869760351
        0x00810ef0:    00317075    up1.    DCD    3240053
        0x00810ef4:    324d4954    TIM2    DCD    843925844
        0x00810ef8:    00000000    ....    DCD    0
        0x00810efc:    54524155    UART    DCD    1414676821
        0x00810f00:    00000032    2...    DCD    50
        0x00810f04:    414d4447    GDMA    DCD    1095582791
        0x00810f08:    68432030    0 Ch    DCD    1749229616
        0x00810f0c:    656e6e61    anne    DCD    1701736033
        0x00810f10:    0000326c    l2..    DCD    12908
        0x00810f14:    4f495047    GPIO    DCD    1330204743
        0x00810f18:    6f72475f    _Gro    DCD    1869760351
        0x00810f1c:    00327075    up2.    DCD    3305589
        0x00810f20:    334d4954    TIM3    DCD    860703060
        0x00810f24:    00000000    ....    DCD    0
        0x00810f28:    414d4447    GDMA    DCD    1095582791
        0x00810f2c:    68432030    0 Ch    DCD    1749229616
        0x00810f30:    656e6e61    anne    DCD    1701736033
        0x00810f34:    0000336c    l3..    DCD    13164
        0x00810f38:    4f495047    GPIO    DCD    1330204743
        0x00810f3c:    6f72475f    _Gro    DCD    1869760351
        0x00810f40:    00337075    up3.    DCD    3371125
        0x00810f44:    344d4954    TIM4    DCD    877480276
        0x00810f48:    00000000    ....    DCD    0
        0x00810f4c:    4f495047    GPIO    DCD    1330204743
        0x00810f50:    00000034    4...    DCD    52
        0x00810f54:    414d4447    GDMA    DCD    1095582791
        0x00810f58:    68432030    0 Ch    DCD    1749229616
        0x00810f5c:    656e6e61    anne    DCD    1701736033
        0x00810f60:    0000346c    l4..    DCD    13420
        0x00810f64:    354d4954    TIM5    DCD    894257492
        0x00810f68:    00000000    ....    DCD    0
        0x00810f6c:    4f495047    GPIO    DCD    1330204743
        0x00810f70:    00000035    5...    DCD    53
        0x00810f74:    414d4447    GDMA    DCD    1095582791
        0x00810f78:    68432030    0 Ch    DCD    1749229616
        0x00810f7c:    656e6e61    anne    DCD    1701736033
        0x00810f80:    0000356c    l5..    DCD    13676
        0x00810f84:    364d4954    TIM6    DCD    911034708
        0x00810f88:    00000000    ....    DCD    0
        0x00810f8c:    656d6954    Time    DCD    1701669204
        0x00810f90:    372d3472    r4-7    DCD    925709426
        0x00810f94:    00000000    ....    DCD    0
        0x00810f98:    374d4954    TIM7    DCD    927811924
        0x00810f9c:    00000000    ....    DCD    0
        0x00810fa0:    414d5442    BTMA    DCD    1095586882
        0x00810fa4:    00000043    C...    DCD    67
        0x00810fa8:    00434441    ADC.    DCD    4408385
        0x00810fac:    00435452    RTC.    DCD    4412498
        0x00810fb0:    00435653    SVC.    DCD    4413011
        0x00810fb4:    0044434c    LCD.    DCD    4473676
        0x00810fb8:    00474457    WDG.    DCD    4670551
        0x00810fbc:    00494d4e    NMI.    DCD    4803918
        0x00810fc0:    4f43504c    LPCO    DCD    1329811532
        0x00810fc4:    0000504d    MP..    DCD    20557
        0x00810fc8:    74696e49    Init    DCD    1953066569
        0x00810fcc:    536c6169    ialS    DCD    1399611753
        0x00810fd0:    00000050    P...    DCD    80
        0x00810fd4:    00005249    IR..    DCD    21065
        0x00810fd8:    646e6550    Pend    DCD    1684956496
        0x00810fdc:    00005653    SV..    DCD    22099
        0x00810fe0:    32495053    SPI2    DCD    843665491
        0x00810fe4:    00000057    W...    DCD    87
        0x00810fe8:    524f5053    SPOR    DCD    1380929619
        0x00810fec:    52203154    T1 R    DCD    1377841492
        0x00810ff0:    00000058    X...    DCD    88
        0x00810ff4:    30533249    I2S0    DCD    810758729
        0x00810ff8:    0058525f    _RX.    DCD    5788255
        0x00810ffc:    524f5053    SPOR    DCD    1380929619
        0x00811000:    54203154    T1 T    DCD    1411395924
        0x00811004:    00000058    X...    DCD    88
        0x00811008:    30533249    I2S0    DCD    810758729
        0x0081100c:    0058545f    _TX.    DCD    5788767
        0x00811010:    64767352    Rsvd    DCD    1685484370
        0x00811014:    00000000    ....    DCD    0
        0x00811018:    63656451    Qdec    DCD    1667589201
        0x0081101c:    0065646f    ode.    DCD    6644847
        0x00811020:    4d6d654d    MemM    DCD    1299014989
        0x00811024:    67616e61    anag    DCD    1734438497
        0x00811028:    00000065    e...    DCD    101
        0x0081102c:    5f495053    SPI_    DCD    1598640211
        0x00811030:    73616c46    Flas    DCD    1935764550
        0x00811034:    00000068    h...    DCD    104
        0x00811038:    54737953    SysT    DCD    1416853843
        0x0081103c:    006b6369    ick.    DCD    7037801
        0x00811040:    69726550    Peri    DCD    1769104720
        0x00811044:    72656870    pher    DCD    1919248496
        0x00811048:    00006c61    al..    DCD    27745
        0x0081104c:    74737953    Syst    DCD    1953724755
        0x00811050:    00006d65    em..    DCD    28005
        0x00811054:    74616c50    Plat    DCD    1952541776
        0x00811058:    6d726f66    form    DCD    1836216166
        0x0081105c:    00000000    ....    DCD    0
        0x00811060:    7379654b    Keys    DCD    1937335627
        0x00811064:    006e6163    can.    DCD    7233891
        0x00811068:    75626544    Debu    DCD    1969382724
        0x0081106c:    6e6f4d67    gMon    DCD    1852788071
        0x00811070:    00000000    ....    DCD    0
        0x00811074:    65736552    Rese    DCD    1702061394
        0x00811078:    00000074    t...    DCD    116
        0x0081107c:    64726148    Hard    DCD    1685217608
        0x00811080:    6c756146    Faul    DCD    1819631942
        0x00811084:    00000074    t...    DCD    116
        0x00811088:    67617355    Usag    DCD    1734439765
        0x0081108c:    75614665    eFau    DCD    1969309285
        0x00811090:    0000746c    lt..    DCD    29804
        0x00811094:    46737542    BusF    DCD    1181971778
        0x00811098:    746c7561    ault    DCD    1953264993
        0x0081109c:    00000000    ....    DCD    0
        0x008110a0:    5f415450    PTA_    DCD    1598116944
        0x008110a4:    6c69614d    Mail    DCD    1818845517
        0x008110a8:    00786f62    box.    DCD    7892834
    .conststring
        0x008110ac:    6e656353    Scen    DCD    1852138323
        0x008110b0:    00425f65    e_B.    DCD    4349797
        0x008110b4:    6e656353    Scen    DCD    1852138323
        0x008110b8:    00435f65    e_C.    DCD    4415333
        0x008110bc:    746f6f42    Boot    DCD    1953460034
        0x008110c0:    65636e4f    Once    DCD    1701015119
        0x008110c4:    00000000    ....    DCD    0
    Region$$Table$$Base
        0x008110c8:    00811108    ....    DCD    8458504
        0x008110cc:    00200000    .. .    DCD    2097152
        0x008110d0:    000000f4    ....    DCD    244
        0x008110d4:    0080e444    D...    DCD    8447044
        0x008110d8:    008111fc    ....    DCD    8458748
        0x008110dc:    00207c00    .| .    DCD    2128896
        0x008110e0:    0000025c    \...    DCD    604
        0x008110e4:    0080e444    D...    DCD    8447044
        0x008110e8:    00811458    X...    DCD    8459352
        0x008110ec:    00207e5c    \~ .    DCD    2129500
        0x008110f0:    000000cc    ....    DCD    204
        0x008110f4:    0080e444    D...    DCD    8447044
        0x008110f8:    00811524    $...    DCD    8459556
        0x008110fc:    00207f28    (. .    DCD    2129704
        0x00811100:    000001bc    ....    DCD    444
        0x00811104:    0080e460    `...    DCD    8447072
    Region$$Table$$Limit

** Section #4 'RAM_VECTOR_TABLE' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 244 bytes (alignment 4)
    Address: 0x00200000

    0x200000:   00 38 20 00 01 e4 80 00 2d e6 80 00 2d e6 80 00    .8 .....-...-...
    0x200010:   2d e6 80 00 2d e6 80 00 2d e6 80 00 00 00 00 00    -...-...-.......
    0x200020:   00 00 00 00 00 00 00 00 00 00 00 00 2d e6 80 00    ............-...
    0x200030:   2d e6 80 00 00 00 00 00 2d e6 80 00 2d e6 80 00    -.......-...-...
    0x200040:   d5 fc 80 00 2d e6 80 00 2d e6 80 00 2d e6 80 00    ....-...-...-...
    0x200050:   2d e6 80 00 2d e6 80 00 2d e6 80 00 2d e6 80 00    -...-...-...-...
    0x200060:   2d e6 80 00 2d e6 80 00 2d e6 80 00 2d e6 80 00    -...-...-...-...
    0x200070:   2d e6 80 00 2d e6 80 00 2d e6 80 00 2d e6 80 00    -...-...-...-...
    0x200080:   2d e6 80 00 2d e6 80 00 2d e6 80 00 2d e6 80 00    -...-...-...-...
    0x200090:   2d e6 80 00 2d e6 80 00 2d e6 80 00 2d e6 80 00    -...-...-...-...
    0x2000a0:   2d e6 80 00 2d e6 80 00 01 7c 20 00 4d 7c 20 00    -...-....| .M| .
    0x2000b0:   2d e6 80 00 99 7c 20 00 dd 7c 20 00 2d e6 80 00    -....| ..| .-...
    0x2000c0:   2d e6 80 00 2d e6 80 00 2d e6 80 00 2d e6 80 00    -...-...-...-...
    0x2000d0:   2d e6 80 00 2d e6 80 00 2d e6 80 00 2d e6 80 00    -...-...-...-...
    0x2000e0:   2d e6 80 00 2d e6 80 00 2d e6 80 00 2d e6 80 00    -...-...-...-...
    0x2000f0:   2d e6 80 00                                        -...

    __Vectors_End

** Section #5 'RAM_DATA_ON' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 604 bytes (alignment 4)
    Address: 0x00207c00

    $t
    .ram.dataon.data
    GPIO_Group3_Handler
;;; .\..\include\SDK\src\mcu\rtl876x\system_rtl8762c.c
;;;537    DATA_RAM_FUNCTION void GPIO_Group3_Handler(void)
;;;537    {
;;;537        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207c00:    4847        GH      LDR      r0,[pc,#284] ; [0x207d20] = 0x40001000
;;; .\..\include\SDK\src\mcu\rtl876x\system_rtl8762c.c (536)
        0x00207c02:    b510        ..      PUSH     {r4,lr}
        0x00207c04:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207c06:    0720         .      LSLS     r0,r4,#28
        0x00207c08:    d501        ..      BPL      0x207c0e ; GPIO_Group3_Handler + 14
;;;537        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;538    
;;;539        //Check exact IRQ function
;;;540        if (GPIOIrqStatus & BIT3)
;;;541        {
;;;542            GPIO3_Handler();
        0x00207c0a:    f206f50f    ....    BL       ADC_Handler ; 0x80e62c
;;;543        }
;;;544        if (GPIOIrqStatus & BIT7)
        0x00207c0e:    0620         .      LSLS     r0,r4,#24
        0x00207c10:    d501        ..      BPL      0x207c16 ; GPIO_Group3_Handler + 22
;;;545        {
;;;546            GPIO7_Handler();
        0x00207c12:    f206f50b    ....    BL       ADC_Handler ; 0x80e62c
;;;547        }
;;;548        if (GPIOIrqStatus & BIT11)
        0x00207c16:    0520         .      LSLS     r0,r4,#20
        0x00207c18:    d501        ..      BPL      0x207c1e ; GPIO_Group3_Handler + 30
;;;549        {
;;;550            GPIO11_Handler();
        0x00207c1a:    f206f507    ....    BL       ADC_Handler ; 0x80e62c
;;;551        }
;;;552        if (GPIOIrqStatus & BIT15)
        0x00207c1e:    0420         .      LSLS     r0,r4,#16
        0x00207c20:    d501        ..      BPL      0x207c26 ; GPIO_Group3_Handler + 38
;;;553        {
;;;554            GPIO15_Handler();
        0x00207c22:    f206f503    ....    BL       ADC_Handler ; 0x80e62c
;;;555        }
;;;556        if (GPIOIrqStatus & BIT19)
        0x00207c26:    0320         .      LSLS     r0,r4,#12
        0x00207c28:    d501        ..      BPL      0x207c2e ; GPIO_Group3_Handler + 46
;;;557        {
;;;558            GPIO19_Handler();
        0x00207c2a:    f206f4ff    ....    BL       ADC_Handler ; 0x80e62c
;;;559        }
;;;560        if (GPIOIrqStatus & BIT23)
        0x00207c2e:    0220         .      LSLS     r0,r4,#8
        0x00207c30:    d501        ..      BPL      0x207c36 ; GPIO_Group3_Handler + 54
;;;561        {
;;;562            GPIO23_Handler();
        0x00207c32:    f206f4fb    ....    BL       ADC_Handler ; 0x80e62c
;;;563        }
;;;564        if (GPIOIrqStatus & BIT27)
        0x00207c36:    0120         .      LSLS     r0,r4,#4
        0x00207c38:    d501        ..      BPL      0x207c3e ; GPIO_Group3_Handler + 62
;;;565        {
;;;566            GPIO27_Handler();
        0x00207c3a:    f206f4f7    ....    BL       ADC_Handler ; 0x80e62c
;;;567        }
;;;568        if (GPIOIrqStatus & BIT31)
        0x00207c3e:    2c00        .,      CMP      r4,#0
        0x00207c40:    da03        ..      BGE      0x207c4a ; GPIO_Group3_Handler + 74
;;;569        {
;;;570            GPIO31_Handler();
        0x00207c42:    e8bd4010    ...@    POP      {r4,lr}
        0x00207c46:    f206b4f1    ....    B.W      ADC_Handler ; 0x80e62c
;;;571        }
;;;572    }
        0x00207c4a:    bd10        ..      POP      {r4,pc}
    GPIO_Group2_Handler
;;;573    /**
;;;574     * @brief  GPIO Group2 Handler
;;;575     * @param  none
;;;576     * @return none
;;;577      */
;;;578    DATA_RAM_FUNCTION void GPIO_Group2_Handler(void)
;;;579    {
;;;580        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207c4c:    4834        4H      LDR      r0,[pc,#208] ; [0x207d20] = 0x40001000
;;; .\..\include\SDK\src\mcu\rtl876x\system_rtl8762c.c (579)
        0x00207c4e:    b510        ..      PUSH     {r4,lr}
        0x00207c50:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207c52:    0760        `.      LSLS     r0,r4,#29
        0x00207c54:    d501        ..      BPL      0x207c5a ; GPIO_Group2_Handler + 14
;;;580        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;581    
;;;582        //Check exact IRQ function
;;;583        if (GPIOIrqStatus & BIT2)
;;;584        {
;;;585            GPIO2_Handler();
        0x00207c56:    f206f4e9    ....    BL       ADC_Handler ; 0x80e62c
;;;586        }
;;;587        if (GPIOIrqStatus & BIT6)
        0x00207c5a:    0660        `.      LSLS     r0,r4,#25
        0x00207c5c:    d501        ..      BPL      0x207c62 ; GPIO_Group2_Handler + 22
;;;588        {
;;;589            GPIO6_Handler();
        0x00207c5e:    f206f4e5    ....    BL       ADC_Handler ; 0x80e62c
;;;590        }
;;;591        if (GPIOIrqStatus & BIT10)
        0x00207c62:    0560        `.      LSLS     r0,r4,#21
        0x00207c64:    d501        ..      BPL      0x207c6a ; GPIO_Group2_Handler + 30
;;;592        {
;;;593            GPIO10_Handler();
        0x00207c66:    f206f4e1    ....    BL       ADC_Handler ; 0x80e62c
;;;594        }
;;;595        if (GPIOIrqStatus & BIT14)
        0x00207c6a:    0460        `.      LSLS     r0,r4,#17
        0x00207c6c:    d501        ..      BPL      0x207c72 ; GPIO_Group2_Handler + 38
;;;596        {
;;;597            GPIO14_Handler();
        0x00207c6e:    f206f4dd    ....    BL       ADC_Handler ; 0x80e62c
;;;598        }
;;;599        if (GPIOIrqStatus & BIT18)
        0x00207c72:    0360        `.      LSLS     r0,r4,#13
        0x00207c74:    d501        ..      BPL      0x207c7a ; GPIO_Group2_Handler + 46
;;;600        {
;;;601            GPIO18_Handler();
        0x00207c76:    f206f4d9    ....    BL       ADC_Handler ; 0x80e62c
;;;602        }
;;;603        if (GPIOIrqStatus & BIT22)
        0x00207c7a:    0260        `.      LSLS     r0,r4,#9
        0x00207c7c:    d501        ..      BPL      0x207c82 ; GPIO_Group2_Handler + 54
;;;604        {
;;;605            GPIO22_Handler();
        0x00207c7e:    f206f4d5    ....    BL       ADC_Handler ; 0x80e62c
;;;606        }
;;;607        if (GPIOIrqStatus & BIT26)
        0x00207c82:    0160        `.      LSLS     r0,r4,#5
        0x00207c84:    d501        ..      BPL      0x207c8a ; GPIO_Group2_Handler + 62
;;;608        {
;;;609            GPIO26_Handler();
        0x00207c86:    f206f4d1    ....    BL       ADC_Handler ; 0x80e62c
;;;610        }
;;;611        if (GPIOIrqStatus & BIT30)
        0x00207c8a:    0060        `.      LSLS     r0,r4,#1
        0x00207c8c:    d503        ..      BPL      0x207c96 ; GPIO_Group2_Handler + 74
;;;612        {
;;;613            GPIO30_Handler();
        0x00207c8e:    e8bd4010    ...@    POP      {r4,lr}
        0x00207c92:    f206b4cb    ....    B.W      ADC_Handler ; 0x80e62c
;;;614        }
;;;615    }
        0x00207c96:    bd10        ..      POP      {r4,pc}
    GPIO_Group1_Handler
;;;616    /**
;;;617     * @brief  GPIO Group1 Handler
;;;618     * @param  none
;;;619     * @return none
;;;620      */
;;;621    DATA_RAM_FUNCTION void GPIO_Group1_Handler(void)
;;;622    {
;;;623        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207c98:    4821        !H      LDR      r0,[pc,#132] ; [0x207d20] = 0x40001000
;;; .\..\include\SDK\src\mcu\rtl876x\system_rtl8762c.c (622)
        0x00207c9a:    b510        ..      PUSH     {r4,lr}
        0x00207c9c:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207c9e:    07a0        ..      LSLS     r0,r4,#30
        0x00207ca0:    d501        ..      BPL      0x207ca6 ; GPIO_Group1_Handler + 14
;;;623        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;624    
;;;625        //Check exact IRQ function
;;;626        if (GPIOIrqStatus & BIT1)
;;;627        {
;;;628            GPIO1_Handler();
        0x00207ca2:    f206f4c3    ....    BL       ADC_Handler ; 0x80e62c
;;;629        }
;;;630        if (GPIOIrqStatus & BIT9)
        0x00207ca6:    05a0        ..      LSLS     r0,r4,#22
        0x00207ca8:    d501        ..      BPL      0x207cae ; GPIO_Group1_Handler + 22
;;;631        {
;;;632            GPIO9_Handler();
        0x00207caa:    f206f4bf    ....    BL       ADC_Handler ; 0x80e62c
;;;633        }
;;;634        if (GPIOIrqStatus & BIT13)
        0x00207cae:    04a0        ..      LSLS     r0,r4,#18
        0x00207cb0:    d501        ..      BPL      0x207cb6 ; GPIO_Group1_Handler + 30
;;;635        {
;;;636            GPIO13_Handler();
        0x00207cb2:    f206f4bb    ....    BL       ADC_Handler ; 0x80e62c
;;;637        }
;;;638        if (GPIOIrqStatus & BIT17)
        0x00207cb6:    03a0        ..      LSLS     r0,r4,#14
        0x00207cb8:    d501        ..      BPL      0x207cbe ; GPIO_Group1_Handler + 38
;;;639        {
;;;640            GPIO17_Handler();
        0x00207cba:    f206f4b7    ....    BL       ADC_Handler ; 0x80e62c
;;;641        }
;;;642        if (GPIOIrqStatus & BIT21)
        0x00207cbe:    02a0        ..      LSLS     r0,r4,#10
        0x00207cc0:    d501        ..      BPL      0x207cc6 ; GPIO_Group1_Handler + 46
;;;643        {
;;;644            GPIO21_Handler();
        0x00207cc2:    f206f4b3    ....    BL       ADC_Handler ; 0x80e62c
;;;645        }
;;;646        if (GPIOIrqStatus & BIT25)
        0x00207cc6:    01a0        ..      LSLS     r0,r4,#6
        0x00207cc8:    d501        ..      BPL      0x207cce ; GPIO_Group1_Handler + 54
;;;647        {
;;;648            GPIO25_Handler();
        0x00207cca:    f206f4af    ....    BL       ADC_Handler ; 0x80e62c
;;;649        }
;;;650        if (GPIOIrqStatus & BIT29)
        0x00207cce:    00a0        ..      LSLS     r0,r4,#2
        0x00207cd0:    d503        ..      BPL      0x207cda ; GPIO_Group1_Handler + 66
;;;651        {
;;;652            GPIO29_Handler();
        0x00207cd2:    e8bd4010    ...@    POP      {r4,lr}
        0x00207cd6:    f206b4a9    ....    B.W      ADC_Handler ; 0x80e62c
;;;653        }
;;;654    }
        0x00207cda:    bd10        ..      POP      {r4,pc}
    GPIO_Group0_Handler
;;;655    /**
;;;656     * @brief  GPIO Group0 Handler
;;;657     * @param  none
;;;658     * @return none
;;;659      */
;;;660    DATA_RAM_FUNCTION void GPIO_Group0_Handler(void)
;;;661    {
;;;662        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207cdc:    4810        .H      LDR      r0,[pc,#64] ; [0x207d20] = 0x40001000
;;; .\..\include\SDK\src\mcu\rtl876x\system_rtl8762c.c (661)
        0x00207cde:    b510        ..      PUSH     {r4,lr}
        0x00207ce0:    6c04        .l      LDR      r4,[r0,#0x40]
        0x00207ce2:    07e0        ..      LSLS     r0,r4,#31
        0x00207ce4:    d001        ..      BEQ      0x207cea ; GPIO_Group0_Handler + 14
;;;662        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;663    
;;;664        //Check exact IRQ function
;;;665        if (GPIOIrqStatus & BIT0)
;;;666        {
;;;667            GPIO0_Handler();
        0x00207ce6:    f206f4a1    ....    BL       ADC_Handler ; 0x80e62c
;;;668        }
;;;669        if (GPIOIrqStatus & BIT8)
        0x00207cea:    05e0        ..      LSLS     r0,r4,#23
        0x00207cec:    d501        ..      BPL      0x207cf2 ; GPIO_Group0_Handler + 22
;;;670        {
;;;671            GPIO8_Handler();
        0x00207cee:    f206f49d    ....    BL       ADC_Handler ; 0x80e62c
;;;672        }
;;;673        if (GPIOIrqStatus & BIT12)
        0x00207cf2:    04e0        ..      LSLS     r0,r4,#19
        0x00207cf4:    d501        ..      BPL      0x207cfa ; GPIO_Group0_Handler + 30
;;;674        {
;;;675            GPIO12_Handler();
        0x00207cf6:    f206f499    ....    BL       ADC_Handler ; 0x80e62c
;;;676        }
;;;677        if (GPIOIrqStatus & BIT16)
        0x00207cfa:    03e0        ..      LSLS     r0,r4,#15
        0x00207cfc:    d501        ..      BPL      0x207d02 ; GPIO_Group0_Handler + 38
;;;678        {
;;;679            GPIO16_Handler();
        0x00207cfe:    f206f495    ....    BL       ADC_Handler ; 0x80e62c
;;;680        }
;;;681        if (GPIOIrqStatus & BIT20)
        0x00207d02:    02e0        ..      LSLS     r0,r4,#11
        0x00207d04:    d501        ..      BPL      0x207d0a ; GPIO_Group0_Handler + 46
;;;682        {
;;;683            GPIO20_Handler();
        0x00207d06:    f207f517    ....    BL       GPIO20_Handler ; 0x80f738
;;;684        }
;;;685        if (GPIOIrqStatus & BIT24)
        0x00207d0a:    01e0        ..      LSLS     r0,r4,#7
        0x00207d0c:    d501        ..      BPL      0x207d12 ; GPIO_Group0_Handler + 54
;;;686        {
;;;687            GPIO24_Handler();
        0x00207d0e:    f206f48d    ....    BL       ADC_Handler ; 0x80e62c
;;;688        }
;;;689        if (GPIOIrqStatus & BIT28)
        0x00207d12:    00e0        ..      LSLS     r0,r4,#3
        0x00207d14:    d503        ..      BPL      0x207d1e ; GPIO_Group0_Handler + 66
;;;690        {
;;;691            GPIO28_Handler();
        0x00207d16:    e8bd4010    ...@    POP      {r4,lr}
        0x00207d1a:    f206b487    ....    B.W      ADC_Handler ; 0x80e62c
;;;692        }
;;;693    }
        0x00207d1e:    bd10        ..      POP      {r4,pc}
    $d
        0x00207d20:    40001000    ...@    DCD    1073745920
    $t
    .ram.dataon.data
    DLPS_IO_ExitDlpsCb
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_io_dlps.c
;;;1957   {
        0x00207d24:    b530        0.      PUSH     {r4,r5,lr}
        0x00207d26:    4947        GI      LDR      r1,[pc,#284] ; [0x207e44] = 0x207fbc
        0x00207d28:    b085        ..      SUB      sp,sp,#0x14
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_io_dlps.c (127)
        0x00207d2a:    2000        .       MOVS     r0,#0
        0x00207d2c:    0082        ..      LSLS     r2,r0,#2
        0x00207d2e:    f1024280    ...B    ADD      r2,r2,#0x40000000
        0x00207d32:    f8513020    Q. 0    LDR      r3,[r1,r0,LSL #2]
        0x00207d36:    f8c23280    ...2    STR      r3,[r2,#0x280]
        0x00207d3a:    1c40        @.      ADDS     r0,r0,#1
        0x00207d3c:    b2c0        ..      UXTB     r0,r0
        0x00207d3e:    280a        .(      CMP      r0,#0xa
        0x00207d40:    d3f4        ..      BCC      0x207d2c ; DLPS_IO_ExitDlpsCb + 8
;;;128        {
;;;129            PINMUX->CFG[i] = Pinmux_StoreReg[i];
;;;130        }
;;;131    
;;;132        return;
;;;133    }
;;;134    #endif
;;;135    
;;;136    /********************************************** ********************************************************/
;;;137    /**************************************** [GPIO DLPS] **************************************************/
;;;138    /*******************************************************************************************************/
;;;139    /*******************************************************************************************************/
;;;140    #if USE_GPIO_DLPS
;;;141    
;;;142    __STATIC_INLINE void GPIO_DLPS_Enter(void);
;;;143    __STATIC_INLINE void GPIO_DLPS_Exit(void);
;;;144    
;;;145    uint32_t GPIO_StoreReg[9];         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;146    
;;;147    /**
;;;148      * @brief  GPIO enter dlps callback function(Save GPIO register values when system enter DLPS)
;;;149      * @param  None
;;;150      * @retval None
;;;151      */
;;;152    __STATIC_INLINE void GPIO_DLPS_Enter(void)
;;;153    {
;;;154        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;155        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;156    
;;;157        GPIO_StoreReg[0] = GPIO->DATAOUT;
;;;158        GPIO_StoreReg[1] = GPIO->DATADIR;
;;;159        GPIO_StoreReg[2] = GPIO->DATASRC;
;;;160        GPIO_StoreReg[3] = GPIO->INTEN;
;;;161        GPIO_StoreReg[4] = GPIO->INTMASK;
;;;162        GPIO_StoreReg[5] = GPIO->INTTYPE;
;;;163        GPIO_StoreReg[6] = GPIO->INTPOLARITY;
;;;164        GPIO_StoreReg[7] = GPIO->DEBOUNCE;
;;;165        GPIO_StoreReg[8] = *(__IO uint32_t *)(0x40000344UL);
;;;166    
;;;167        return;
;;;168    }
;;;169    
;;;170    /**
;;;171      * @brief  GPIO exit dlps callback function(Resume GPIO register values when system exit DLPS)
;;;172      * @param  None
;;;173      * @retval None
;;;174      */
;;;175    DATA_RAM_FUNCTION __STATIC_INLINE void GPIO_DLPS_Exit(void)
;;;176    {
;;;177        PERIPH->PERI_FUNC1_EN |= BIT_PERI_GPIO_EN;
;;;178        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
;;;179    
;;;180        GPIO->DATADIR       = GPIO_StoreReg[1];
;;;181        GPIO->DATASRC       = GPIO_StoreReg[2];
;;;182        GPIO->INTMASK       = GPIO_StoreReg[4];
;;;183        GPIO->INTTYPE       = GPIO_StoreReg[5];
;;;184        GPIO->INTPOLARITY   = GPIO_StoreReg[6];
;;;185        GPIO->DEBOUNCE      = GPIO_StoreReg[7];
;;;186        GPIO->DATAOUT       = GPIO_StoreReg[0];
;;;187        GPIO->INTCLR        = ~(GPIO_StoreReg[1]);
;;;188        GPIO->INTEN         = GPIO_StoreReg[3];
;;;189        *(__IO uint32_t *)(0x40000344UL) = GPIO_StoreReg[8];
;;;190    
;;;191        return;
;;;192    }
;;;193    #endif  /* USE_GPIO_DLPS */
;;;194    
;;;195    
;;;196    /********************************************** ********************************************************/
;;;197    /**************************************** [KEYSCAN DLPS] ***********************************************/
;;;198    /*******************************************************************************************************/
;;;199    /*******************************************************************************************************/
;;;200    #if USE_KEYSCAN_DLPS
;;;201    __STATIC_INLINE void KeyScan_DLPS_Enter(void);
;;;202    __STATIC_INLINE void KeyScan_DLPS_Exit(void);
;;;203    
;;;204    uint32_t KeyScan_StoreReg[7];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;205    
;;;206    /**
;;;207      * @brief  KEYSCAN enter dlps callback function(Save KEYSCAN register values when system enter DLPS)
;;;208      * @param  None
;;;209      * @retval None
;;;210      */
;;;211    __STATIC_INLINE void KeyScan_DLPS_Enter(void)
;;;212    {
;;;213        /*Open 5M clock source*/
;;;214        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;215        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;216    
;;;217        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;218        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;219    
;;;220        KeyScan_StoreReg[0] = KEYSCAN->CLKDIV;               /* 0x00 */
;;;221        KeyScan_StoreReg[1] = KEYSCAN->TIMERCR;              /* 0x04 */
;;;222        KeyScan_StoreReg[2] = KEYSCAN->CR;                   /* 0x08 */
;;;223        KeyScan_StoreReg[3] = KEYSCAN->COLCR;                /* 0x0C */
;;;224        KeyScan_StoreReg[4] = KEYSCAN->ROWCR;                /* 0x10 */
;;;225        KeyScan_StoreReg[6] = KEYSCAN->INTMASK;              /* 0x18 */
;;;226    
;;;227        return;
;;;228    }
;;;229    
;;;230    /**
;;;231      * @brief  KEYSCAN exit dlps callback function(Resume KEYSCAN register values when system exit DLPS)
;;;232      * @param  None
;;;233      * @retval None
;;;234      */
;;;235    DATA_RAM_FUNCTION __STATIC_INLINE void KeyScan_DLPS_Exit(void)
;;;236    {
;;;237        /*Open 5M clock source*/
;;;238        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;239        SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
;;;240    
;;;241        PERIPH->PERI_FUNC0_EN |= BIT_PERI_KEYSCAN_EN;
;;;242        PERIPH->PERI_CLK_CTRL1 |= (BIT_SOC_ACTCK_KEYSCAN_EN | SYSBLK_SLPCK_KEYSCAN_EN_Msk);
;;;243    
;;;244        /* Set FSM to idle state */
;;;245        KEYSCAN->CR &= ~BIT31;
;;;246        KEYSCAN->CLKDIV = KeyScan_StoreReg[0];
;;;247        KEYSCAN->CR = (KeyScan_StoreReg[2] & (~(BIT31)));
;;;248        KEYSCAN->TIMERCR = KeyScan_StoreReg[1];
;;;249        KEYSCAN->COLCR = KeyScan_StoreReg[3];
;;;250        KEYSCAN->ROWCR = KeyScan_StoreReg[4];
;;;251        KEYSCAN->INTMASK = KeyScan_StoreReg[6];
;;;252        KEYSCAN->CR |= (KeyScan_StoreReg[2] & ((BIT31)));
;;;253    
;;;254        return;
;;;255    }
;;;256    #endif /* USE_KEYSCAN_DLPS */
;;;257    
;;;258    
;;;259    /********************************************** ********************************************************/
;;;260    /**************************************** [QDEC DLPS] **************************************************/
;;;261    /*******************************************************************************************************/
;;;262    /*******************************************************************************************************/
;;;263    #if USE_QDECODER_DLPS
;;;264    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void);
;;;265    __STATIC_INLINE void QuadDecoder_DLPS_Exit(void);
;;;266    
;;;267    uint32_t QuadDecoder_StoreReg[5];  /*  This array should be placed in RAM ON/Buffer ON.    */
;;;268    
;;;269    /**
;;;270      * @brief  QDEC enter dlps callback function(Save QDEC register values when system enter DLPS)
;;;271      * @param  None
;;;272      * @retval None
;;;273      */
;;;274    __STATIC_INLINE void QuadDecoder_DLPS_Enter(void)
;;;275    {
;;;276        /*Open 20M clock source*/
;;;277        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;278        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;279        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;280        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;281    
;;;282        QuadDecoder_StoreReg[0] = QDEC->REG_DIV;
;;;283        QuadDecoder_StoreReg[1] = QDEC->REG_CR_X;
;;;284        QuadDecoder_StoreReg[2] = QDEC->REG_CR_Y;
;;;285        QuadDecoder_StoreReg[3] = QDEC->REG_CR_Z;
;;;286        QuadDecoder_StoreReg[4] = QDEC->INT_MASK;
;;;287    
;;;288        return;
;;;289    }
;;;290    
;;;291    /**
;;;292      * @brief  QDEC exit dlps callback function(Resume QDEC register values when system exit DLPS)
;;;293      * @param  None
;;;294      * @retval None
;;;295      */
;;;296    DATA_RAM_FUNCTION __STATIC_INLINE void QuadDecoder_DLPS_Exit(void)
;;;297    {
;;;298        /*Open 20M clock source*/
;;;299        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;300        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;301        SYSBLKCTRL->u_218.PERI_FUNC0_EN |= SYSBLK_QDECODE_EN_Msk;
;;;302        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_QDECODE_EN_Msk | SYSBLK_SLPCK_QDECODE_EN_Msk);
;;;303    
;;;304        //clear flags
;;;305        QDEC->REG_DIV  = QuadDecoder_StoreReg[0];
;;;306        QDEC->REG_CR_X = QuadDecoder_StoreReg[1];
;;;307        QDEC->REG_CR_Y = QuadDecoder_StoreReg[2];
;;;308        QDEC->REG_CR_Z = QuadDecoder_StoreReg[3];
;;;309        QDEC->INT_MASK = QuadDecoder_StoreReg[4];
;;;310    
;;;311        return;
;;;312    }
;;;313    #endif
;;;314    
;;;315    /********************************************** ********************************************************/
;;;316    /**************************************** [SPI0 DLPS] **************************************************/
;;;317    /*******************************************************************************************************/
;;;318    /*******************************************************************************************************/
;;;319    #if USE_SPI0_DLPS
;;;320    __STATIC_INLINE void SPI0_DLPS_Enter(void);
;;;321    __STATIC_INLINE void SPI0_DLPS_Exit(void);
;;;322    
;;;323    uint32_t SPI0_StoreReg[13];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;324    
;;;325    /**
;;;326      * @brief  SPI0 enter dlps callback function(Save SPI0 register values when system enter DLPS)
;;;327      * @param  None
;;;328      * @retval None
;;;329      */
;;;330    __STATIC_INLINE void SPI0_DLPS_Enter(void)
;;;331    {
;;;332        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;333        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;334    
;;;335        SPI0_StoreReg[0] = SPI0->CTRLR0;
;;;336        SPI0_StoreReg[1] = SPI0->CTRLR1;
;;;337        SPI0_StoreReg[2] = SPI0->SSIENR;
;;;338        SPI0_StoreReg[3] = SPI0->SER;
;;;339        SPI0_StoreReg[4] = SPI0->BAUDR;
;;;340        SPI0_StoreReg[5] = SPI0->TXFTLR;
;;;341        SPI0_StoreReg[6] = SPI0->RXFTLR;
;;;342        SPI0_StoreReg[7] = SPI0->IMR;
;;;343        SPI0_StoreReg[8] = SPI0->DMACR;
;;;344        SPI0_StoreReg[9] = SPI0->DMATDLR;
;;;345        SPI0_StoreReg[10] = SPI0->DMARDLR;
;;;346        SPI0_StoreReg[11] = SPI0->RX_SAMPLE_DLY;
;;;347        SPI0_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;348    }
;;;349    
;;;350    /**
;;;351      * @brief  SPI0 exit dlps callback function(Resume SPI0 register values when system exit DLPS)
;;;352      * @param  None
;;;353      * @retval None
;;;354      */
;;;355    DATA_RAM_FUNCTION __STATIC_INLINE void SPI0_DLPS_Exit(void)
;;;356    {
;;;357        *(volatile uint32_t *)0x40000308 = SPI0_StoreReg[12];
;;;358        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI0_EN_Msk;
;;;359        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI0_EN_Msk | SYSBLK_SLPCK_SPI0_EN_Msk);
;;;360    
;;;361        SPI0->CTRLR0 = SPI0_StoreReg[0];
;;;362        SPI0->CTRLR1 = SPI0_StoreReg[1];
;;;363        SPI0->SER = SPI0_StoreReg[3];
;;;364        SPI0->BAUDR = SPI0_StoreReg[4];
;;;365        SPI0->TXFTLR = SPI0_StoreReg[5];
;;;366        SPI0->RXFTLR = SPI0_StoreReg[6];
;;;367        SPI0->IMR = SPI0_StoreReg[7];
;;;368        SPI0->DMACR = SPI0_StoreReg[8];
;;;369        SPI0->DMATDLR = SPI0_StoreReg[9];
;;;370        SPI0->DMARDLR = SPI0_StoreReg[10];
;;;371        SPI0->RX_SAMPLE_DLY = SPI0_StoreReg[11];
;;;372    
;;;373        /* Enable the selected SPI peripheral */
;;;374        SPI0->SSIENR = SPI0_StoreReg[2];
;;;375    }
;;;376    #endif
;;;377    
;;;378    
;;;379    /********************************************** ********************************************************/
;;;380    /**************************************** [SPI1 DLPS] **************************************************/
;;;381    /*******************************************************************************************************/
;;;382    /*******************************************************************************************************/
;;;383    #if USE_SPI1_DLPS
;;;384    __STATIC_INLINE void SPI1_DLPS_Enter(void);
;;;385    __STATIC_INLINE void SPI1_DLPS_Exit(void);
;;;386    
;;;387    uint32_t SPI1_StoreReg[13];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;388    
;;;389    /**
;;;390      * @brief  SPI1 enter dlps callback function(Save SPI1 register values when system enter DLPS)
;;;391      * @param  None
;;;392      * @retval None
;;;393      */
;;;394    __STATIC_INLINE void SPI1_DLPS_Enter(void)
;;;395    {
;;;396        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;397        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;398    
;;;399        SPI1_StoreReg[0] = SPI1->CTRLR0;
;;;400        SPI1_StoreReg[1] = SPI1->CTRLR1;
;;;401        SPI1_StoreReg[2] = SPI1->SSIENR;
;;;402        SPI1_StoreReg[3] = SPI1->SER;
;;;403        SPI1_StoreReg[4] = SPI1->BAUDR;
;;;404        SPI1_StoreReg[5] = SPI1->TXFTLR;
;;;405        SPI1_StoreReg[6] = SPI1->RXFTLR;
;;;406        SPI1_StoreReg[7] = SPI1->IMR;
;;;407        SPI1_StoreReg[8] = SPI1->DMACR;
;;;408        SPI1_StoreReg[9] = SPI1->DMATDLR;
;;;409        SPI1_StoreReg[10] = SPI1->DMARDLR;
;;;410        SPI1_StoreReg[11] = SPI1->RX_SAMPLE_DLY;
;;;411        SPI1_StoreReg[12] = *(volatile uint32_t *)0x40000308;
;;;412    }
;;;413    
;;;414    /**
;;;415      * @brief  SPI1 exit dlps callback function(Resume SPI1 register values when system exit DLPS)
;;;416      * @param  None
;;;417      * @retval None
;;;418      */
;;;419    DATA_RAM_FUNCTION __STATIC_INLINE void SPI1_DLPS_Exit(void)
;;;420    {
;;;421        *(volatile uint32_t *)0x40000308 = SPI1_StoreReg[12];
;;;422        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI1_EN_Msk;
;;;423        SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_SPI1_EN_Msk | SYSBLK_SLPCK_SPI1_EN_Msk);
;;;424    
;;;425        SPI1->CTRLR0 = SPI1_StoreReg[0];
;;;426        SPI1->CTRLR1 = SPI1_StoreReg[1];
;;;427        SPI1->SER = SPI1_StoreReg[3];
;;;428        SPI1->BAUDR = SPI1_StoreReg[4];
;;;429        SPI1->TXFTLR = SPI1_StoreReg[5];
;;;430        SPI1->RXFTLR = SPI1_StoreReg[6];
;;;431        SPI1->IMR = SPI1_StoreReg[7];
;;;432        SPI1->DMACR = SPI1_StoreReg[8];
;;;433        SPI1->DMATDLR = SPI1_StoreReg[9];
;;;434        SPI1->DMARDLR = SPI1_StoreReg[10];
;;;435        SPI1->RX_SAMPLE_DLY = SPI1_StoreReg[11];
;;;436    
;;;437        /* Enable the selected SPI peripheral */
;;;438        SPI1->SSIENR = SPI1_StoreReg[2];
;;;439    }
;;;440    #endif
;;;441    
;;;442    /********************************************** ********************************************************/
;;;443    /**************************************** [SPI2W DLPS] **************************************************/
;;;444    /*******************************************************************************************************/
;;;445    /*******************************************************************************************************/
;;;446    #if USE_SPI2W_DLPS
;;;447    __STATIC_INLINE void SPI2W_DLPS_Enter(void);
;;;448    __STATIC_INLINE void SPI2W_DLPS_Exit(void);
;;;449    
;;;450    uint32_t SPI2W_StoreReg[1];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;451    
;;;452    /**
;;;453      * @brief  SPI2W enter dlps callback function(Save SPI2W register values when system enter DLPS)
;;;454      * @param  None
;;;455      * @retval None
;;;456      */
;;;457    __STATIC_INLINE void SPI2W_DLPS_Enter(void)
;;;458    {
;;;459        /*Open 20M clock source*/
;;;460        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;461        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;462    
;;;463        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;464        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;465    
;;;466        SPI2W_StoreReg[0] = SPI3WIRE->CFGR;
;;;467    }
;;;468    
;;;469    /**
;;;470      * @brief  SPI2W exit dlps callback function(Resume SPI2W register values when system exit DLPS)
;;;471      * @param  None
;;;472      * @retval None
;;;473      */
;;;474    DATA_RAM_FUNCTION __STATIC_INLINE void SPI2W_DLPS_Exit(void)
;;;475    {
;;;476        /*Open 20M clock source*/
;;;477        SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;478        SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
;;;479    
;;;480        SYSBLKCTRL->u_218.PERI_FUNC0_EN |=  SYSBLK_SPI2W_EN_Msk;
;;;481        SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_SPI2WIRE_EN_Msk | SYSBLK_SLPCK_SPI2WIRE_EN_Msk);
;;;482    
;;;483        SPI3WIRE->CFGR = SPI2W_StoreReg[0];
;;;484    }
;;;485    #endif
;;;486    
;;;487    /********************************************** ********************************************************/
;;;488    /**************************************** [I2C0 DLPS] **************************************************/
;;;489    /*******************************************************************************************************/
;;;490    /*******************************************************************************************************/
;;;491    #if USE_I2C0_DLPS
;;;492    __STATIC_INLINE void I2C0_DLPS_Enter(void);
;;;493    __STATIC_INLINE void I2C0_DLPS_Exit(void);
;;;494    
;;;495    uint32_t I2C0_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;496    
;;;497    /**
;;;498      * @brief  I2C0 enter dlps callback function(Save I2C0 register values when system enter DLPS)
;;;499      * @param  None
;;;500      * @retval None
;;;501      */
;;;502    __STATIC_INLINE void I2C0_DLPS_Enter(void)
;;;503    {
;;;504        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;505        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;506    
;;;507        I2C0_StoreReg[0] = I2C0->IC_CON;
;;;508        I2C0_StoreReg[1] = I2C0->IC_TAR;
;;;509        I2C0_StoreReg[2] = I2C0->IC_SAR;
;;;510        I2C0_StoreReg[3] = I2C0->IC_HS_MADDR;
;;;511    
;;;512        I2C0_StoreReg[4] = I2C0->IC_SS_SCL_HCNT;
;;;513        I2C0_StoreReg[5] = I2C0->IC_SS_SCL_LCNT;
;;;514        I2C0_StoreReg[6] = I2C0->IC_FS_SCL_HCNT;
;;;515        I2C0_StoreReg[7] = I2C0->IC_FS_SCL_LCNT;
;;;516        I2C0_StoreReg[8] = I2C0->IC_HS_SCL_HCNT;
;;;517        I2C0_StoreReg[9] = I2C0->IC_HS_SCL_LCNT;
;;;518    
;;;519        I2C0_StoreReg[10] = I2C0->IC_INTR_MASK;
;;;520        I2C0_StoreReg[11] = I2C0->IC_RX_TL;
;;;521        I2C0_StoreReg[12] = I2C0->IC_TX_TL;
;;;522        I2C0_StoreReg[13] = I2C0->IC_ENABLE;
;;;523        I2C0_StoreReg[14] = I2C0->IC_SDA_HOLD;
;;;524        I2C0_StoreReg[15] = I2C0->IC_SLV_DATA_NACK_ONLY;
;;;525        I2C0_StoreReg[16] = I2C0->IC_DMA_CR;
;;;526        I2C0_StoreReg[17] = I2C0->IC_DMA_TDLR;
;;;527        I2C0_StoreReg[18] = I2C0->IC_DMA_RDLR;
;;;528    
;;;529        I2C0_StoreReg[19] = I2C0->IC_SDA_SETUP;
;;;530    }
;;;531    
;;;532    /**
;;;533      * @brief  I2C0 exit dlps callback function(Resume I2C0 register values when system exit DLPS)
;;;534      * @param  None
;;;535      * @retval None
;;;536      */
;;;537    DATA_RAM_FUNCTION __STATIC_INLINE void I2C0_DLPS_Exit(void)
;;;538    {
;;;539        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C0_EN_Msk | SYSBLK_SLPCK_I2C0_EN_Msk);
;;;540        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C0_EN_Msk;
;;;541    
;;;542        I2C0->IC_CON = I2C0_StoreReg[0];
;;;543        I2C0->IC_TAR = I2C0_StoreReg[1];
;;;544        I2C0->IC_SAR = I2C0_StoreReg[2];
;;;545        I2C0->IC_HS_MADDR = I2C0_StoreReg[3];
;;;546    
;;;547        I2C0->IC_SS_SCL_HCNT = I2C0_StoreReg[4];
;;;548        I2C0->IC_SS_SCL_LCNT = I2C0_StoreReg[5];
;;;549        I2C0->IC_FS_SCL_HCNT = I2C0_StoreReg[6];
;;;550        I2C0->IC_FS_SCL_LCNT = I2C0_StoreReg[7];
;;;551        I2C0->IC_HS_SCL_HCNT = I2C0_StoreReg[8];
;;;552        I2C0->IC_HS_SCL_LCNT = I2C0_StoreReg[9];
;;;553    
;;;554        I2C0->IC_INTR_MASK = I2C0_StoreReg[10];
;;;555        I2C0->IC_RX_TL = I2C0_StoreReg[11];
;;;556        I2C0->IC_TX_TL = I2C0_StoreReg[12];
;;;557        I2C0->IC_SDA_HOLD = I2C0_StoreReg[14];
;;;558        I2C0->IC_SLV_DATA_NACK_ONLY = I2C0_StoreReg[15];
;;;559        I2C0->IC_DMA_CR = I2C0_StoreReg[16];
;;;560        I2C0->IC_DMA_TDLR = I2C0_StoreReg[17];
;;;561        I2C0->IC_DMA_RDLR = I2C0_StoreReg[18];
;;;562        I2C0->IC_SDA_SETUP = I2C0_StoreReg[19];
;;;563    
;;;564        I2C0->IC_ENABLE = I2C0_StoreReg[13];
;;;565    }
;;;566    #endif
;;;567    
;;;568    /********************************************** ********************************************************/
;;;569    /**************************************** [I2C1 DLPS] **************************************************/
;;;570    /*******************************************************************************************************/
;;;571    /*******************************************************************************************************/
;;;572    #if USE_I2C1_DLPS
;;;573    __STATIC_INLINE void I2C1_DLPS_Enter(void);
;;;574    __STATIC_INLINE void I2C1_DLPS_Exit(void);
;;;575    
;;;576    uint32_t I2C1_StoreReg[20];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;577    
;;;578    /**
;;;579      * @brief  I2C1 enter dlps callback function(Save I2C1 register values when system enter DLPS)
;;;580      * @param  None
;;;581      * @retval None
;;;582      */
;;;583    __STATIC_INLINE void I2C1_DLPS_Enter(void)
;;;584    {
;;;585        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;586        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;587    
;;;588        I2C1_StoreReg[0] = I2C1->IC_CON;
;;;589        I2C1_StoreReg[1] = I2C1->IC_TAR;
;;;590        I2C1_StoreReg[2] = I2C1->IC_SAR;
;;;591        I2C1_StoreReg[3] = I2C1->IC_HS_MADDR;
;;;592    
;;;593        I2C1_StoreReg[4] = I2C1->IC_SS_SCL_HCNT;
;;;594        I2C1_StoreReg[5] = I2C1->IC_SS_SCL_LCNT;
;;;595        I2C1_StoreReg[6] = I2C1->IC_FS_SCL_HCNT;
;;;596        I2C1_StoreReg[7] = I2C1->IC_FS_SCL_LCNT;
;;;597        I2C1_StoreReg[8] = I2C1->IC_HS_SCL_HCNT;
;;;598        I2C1_StoreReg[9] = I2C1->IC_HS_SCL_LCNT;
;;;599    
;;;600        I2C1_StoreReg[10] = I2C1->IC_INTR_MASK;
;;;601        I2C1_StoreReg[11] = I2C1->IC_RX_TL;
;;;602        I2C1_StoreReg[12] = I2C1->IC_TX_TL;
;;;603        I2C1_StoreReg[13] = I2C1->IC_ENABLE;
;;;604        I2C1_StoreReg[14] = I2C1->IC_SDA_HOLD;
;;;605        I2C1_StoreReg[15] = I2C1->IC_SLV_DATA_NACK_ONLY;
;;;606        I2C1_StoreReg[16] = I2C1->IC_DMA_CR;
;;;607        I2C1_StoreReg[17] = I2C1->IC_DMA_TDLR;
;;;608        I2C1_StoreReg[18] = I2C1->IC_DMA_RDLR;
;;;609    
;;;610        I2C1_StoreReg[19] = I2C1->IC_SDA_SETUP;
;;;611    }
;;;612    
;;;613    /**
;;;614      * @brief  I2C1 exit dlps callback function(Resume I2C1 register values when system exit DLPS)
;;;615      * @param  None
;;;616      * @retval None
;;;617      */
;;;618    DATA_RAM_FUNCTION __STATIC_INLINE void I2C1_DLPS_Exit(void)
;;;619    {
;;;620        PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_I2C1_EN_Msk | SYSBLK_SLPCK_I2C1_EN_Msk);
;;;621        PERIPH->PERI_FUNC0_EN |= SYSBLK_I2C1_EN_Msk;
;;;622    
;;;623        I2C1->IC_CON = I2C1_StoreReg[0];
;;;624        I2C1->IC_TAR = I2C1_StoreReg[1];
;;;625        I2C1->IC_SAR = I2C1_StoreReg[2];
;;;626        I2C0->IC_HS_MADDR = I2C1_StoreReg[3];
;;;627    
;;;628        I2C1->IC_SS_SCL_HCNT = I2C1_StoreReg[4];
;;;629        I2C1->IC_SS_SCL_LCNT = I2C1_StoreReg[5];
;;;630        I2C1->IC_FS_SCL_HCNT = I2C1_StoreReg[6];
;;;631        I2C1->IC_FS_SCL_LCNT = I2C1_StoreReg[7];
;;;632        I2C1->IC_HS_SCL_HCNT = I2C1_StoreReg[8];
;;;633        I2C1->IC_HS_SCL_LCNT = I2C1_StoreReg[9];
;;;634    
;;;635        I2C1->IC_INTR_MASK = I2C1_StoreReg[10];
;;;636        I2C1->IC_RX_TL = I2C1_StoreReg[11];
;;;637        I2C1->IC_TX_TL = I2C1_StoreReg[12];
;;;638        I2C1->IC_SDA_HOLD = I2C1_StoreReg[14];
;;;639        I2C1->IC_SLV_DATA_NACK_ONLY = I2C1_StoreReg[15];
;;;640        I2C1->IC_DMA_CR = I2C1_StoreReg[16];
;;;641        I2C1->IC_DMA_TDLR = I2C1_StoreReg[17];
;;;642        I2C1->IC_DMA_RDLR = I2C1_StoreReg[18];
;;;643        I2C1->IC_SDA_SETUP = I2C1_StoreReg[19];
;;;644    
;;;645        I2C1->IC_ENABLE = I2C1_StoreReg[13];
;;;646    }
;;;647    #endif
;;;648    
;;;649    /********************************************** ********************************************************/
;;;650    /**************************************** [Timer & PWM DLPS] *******************************************/
;;;651    /*******************************************************************************************************/
;;;652    /*******************************************************************************************************/
;;;653    #if USE_TIM_DLPS
;;;654    #include "rtl876x_tim.h"
;;;655    __STATIC_INLINE void TIM_DLPS_Enter(void);
;;;656    __STATIC_INLINE void TIM_DLPS_Exit(void);
;;;657    
;;;658    uint32_t TIM_StoreReg[26];      /*  This array should be placed in RAM ON/Buffer ON.    */
;;;659    
;;;660    /* PWM, use with timer */
;;;661    uint32_t PWM0_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;662    
;;;663    uint32_t PWM1_StoreReg;         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;664    
;;;665    /**
;;;666      * @brief  TIMER enter dlps callback function(Save TIMER register values when system enter DLPS)
;;;667      * @param  None
;;;668      * @retval None
;;;669      */
;;;670    __STATIC_INLINE void TIM_DLPS_Enter(void)
;;;671    {
;;;672        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;673        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;674    
;;;675        TIM_StoreReg[0] = TIM0->LoadCount;
;;;676        TIM_StoreReg[1] = TIM0->ControlReg;
;;;677        TIM_StoreReg[2] = TIMER0_LOAD_COUNT2;
;;;678    
;;;679        TIM_StoreReg[3] = TIM1->LoadCount;
;;;680        TIM_StoreReg[4] = TIM1->ControlReg;
;;;681        TIM_StoreReg[5] = TIMER1_LOAD_COUNT2;
;;;682    
;;;683        TIM_StoreReg[6] = TIM2->LoadCount;
;;;684        TIM_StoreReg[7] = TIM2->ControlReg;
;;;685        TIM_StoreReg[8] = TIMER2_LOAD_COUNT2;
;;;686    
;;;687        TIM_StoreReg[9] = TIM3->LoadCount;
;;;688        TIM_StoreReg[10] = TIM3->ControlReg;
;;;689        TIM_StoreReg[11] = TIMER3_LOAD_COUNT2;
;;;690    
;;;691        TIM_StoreReg[12] = TIM4->LoadCount;
;;;692        TIM_StoreReg[13] = TIM4->ControlReg;
;;;693        TIM_StoreReg[14] = TIMER4_LOAD_COUNT2;
;;;694    
;;;695        TIM_StoreReg[15] = TIM5->LoadCount;
;;;696        TIM_StoreReg[16] = TIM5->ControlReg;
;;;697        TIM_StoreReg[17] = TIMER5_LOAD_COUNT2;
;;;698    
;;;699        TIM_StoreReg[18] = TIM6->LoadCount;
;;;700        TIM_StoreReg[19] = TIM6->ControlReg;
;;;701        TIM_StoreReg[20] = TIMER6_LOAD_COUNT2;
;;;702    
;;;703        TIM_StoreReg[21] = TIM7->LoadCount;
;;;704        TIM_StoreReg[22] = TIM7->ControlReg;
;;;705        TIM_StoreReg[23] = TIMER7_LOAD_COUNT2;
;;;706    
;;;707        TIM_StoreReg[24] = *((volatile uint32_t *)0x4000035CUL);
;;;708        TIM_StoreReg[25] = *((volatile uint32_t *)0x40000360UL);
;;;709    
;;;710        PWM0_StoreReg = TIMER_PWM0_CR;
;;;711    
;;;712        PWM1_StoreReg = TIMER_PWM1_CR;
;;;713    }
;;;714    
;;;715    /**
;;;716      * @brief  TIMER exit dlps callback function(Resume TIMER register values when system exit DLPS)
;;;717      * @param  None
;;;718      * @retval None
;;;719      */
;;;720    DATA_RAM_FUNCTION __STATIC_INLINE void TIM_DLPS_Exit(void)
;;;721    {
;;;722        /* Enable timer IP clock and function */
;;;723        SYSBLKCTRL->u_210.SOC_FUNC_EN |= BIT(16);
;;;724        SYSBLKCTRL->u_230.CLK_CTRL |= (SYSBLK_ACTCK_TIMER_EN_Msk | SYSBLK_SLPCK_TIMER_EN_Msk);
;;;725    
;;;726        *((volatile uint32_t *)0x4000035CUL) = TIM_StoreReg[24];
;;;727        *((volatile uint32_t *)0x40000360UL) = TIM_StoreReg[25];
;;;728    
;;;729        TIM0->LoadCount = TIM_StoreReg[0];
;;;730        TIM0->ControlReg = TIM_StoreReg[1];
;;;731        TIMER0_LOAD_COUNT2 = TIM_StoreReg[2];
;;;732    
;;;733        TIM1->LoadCount = TIM_StoreReg[3];
;;;734        TIM1->ControlReg = TIM_StoreReg[4];
;;;735        TIMER1_LOAD_COUNT2 = TIM_StoreReg[5];
;;;736    
;;;737        TIM2->LoadCount = TIM_StoreReg[6];
;;;738        TIM2->ControlReg = TIM_StoreReg[7];
;;;739        TIMER2_LOAD_COUNT2 = TIM_StoreReg[8];
;;;740    
;;;741        TIM3->LoadCount = TIM_StoreReg[9];
;;;742        TIM3->ControlReg = TIM_StoreReg[10];
;;;743        TIMER3_LOAD_COUNT2 = TIM_StoreReg[11];
;;;744    
;;;745        TIM4->LoadCount = TIM_StoreReg[12];
;;;746        TIM4->ControlReg = TIM_StoreReg[13];
;;;747        TIMER4_LOAD_COUNT2 = TIM_StoreReg[14];
;;;748    
;;;749        TIM5->LoadCount = TIM_StoreReg[15];
;;;750        TIM5->ControlReg = TIM_StoreReg[16];
;;;751        TIMER5_LOAD_COUNT2 = TIM_StoreReg[17];
;;;752    
;;;753        TIM6->LoadCount = TIM_StoreReg[18];
;;;754        TIM6->ControlReg = TIM_StoreReg[19];
;;;755        TIMER6_LOAD_COUNT2 = TIM_StoreReg[20];
;;;756    
;;;757        TIM7->LoadCount = TIM_StoreReg[21];
;;;758        TIM7->ControlReg = TIM_StoreReg[22];
;;;759        TIMER7_LOAD_COUNT2 = TIM_StoreReg[23];
;;;760    
;;;761        TIMER_PWM0_CR = PWM0_StoreReg;
;;;762    
;;;763        TIMER_PWM1_CR = PWM1_StoreReg;
;;;764    }
;;;765    #endif  /* USE_TIM_DLPS */
;;;766    
;;;767    
;;;768    /********************************************** ********************************************************/
;;;769    /**************************************** [UART DLPS] **************************************************/
;;;770    /*******************************************************************************************************/
;;;771    /*******************************************************************************************************/
;;;772    #if USE_UART_DLPS
;;;773    #include "rtl876x_uart.h"
;;;774    
;;;775    __STATIC_INLINE void UART_DLPS_Enter(void);
;;;776    __STATIC_INLINE void UART_DLPS_Exit(void);
;;;777    
;;;778    uint32_t UART_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;779    
;;;780    /**
;;;781      * @brief  UART enter dlps callback function(Save UART register values when system enter DLPS)
;;;782      * @param  None
;;;783      * @retval None
;;;784      */
;;;785    __STATIC_INLINE void UART_DLPS_Enter(void)
;;;786    {
;;;787        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;788        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;789    
;;;790        //access DLH and DLL
;;;791        UART->LCR |= (1 << 7);
;;;792        UART_StoreReg[0] = UART->DLL;
;;;793        UART_StoreReg[1] = UART->DLH_INTCR;
;;;794        UART->LCR &= (~(1 << 7));
;;;795    
;;;796        //save other registers
;;;797        UART_StoreReg[2] = UART->DLH_INTCR;
;;;798        UART_StoreReg[4] = UART->LCR;
;;;799        UART_StoreReg[5] = UART->MCR;
;;;800        UART_StoreReg[6] = UART->SPR;
;;;801        UART_StoreReg[7] = UART->STSR;
;;;802        UART_StoreReg[8] = UART->RX_IDLE_INTTCR;
;;;803        UART_StoreReg[9] = UART->RXIDLE_INTCR;
;;;804        UART_StoreReg[10] = UART->MISCR;
;;;805    
;;;806        return;
;;;807    }
;;;808    
;;;809    /**
;;;810      * @brief  UART exit dlps callback function(Resume UART register values when system exit DLPS)
;;;811      * @param  None
;;;812      * @retval None
;;;813      */
;;;814    DATA_RAM_FUNCTION __STATIC_INLINE void UART_DLPS_Exit(void)
;;;815    {
;;;816        PERIPH->PERI_FUNC0_EN |= (1 << 0);
;;;817        PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_UART0DATA_EN_Msk | SYSBLK_SLPCK_UART0DATA_EN_Msk);
;;;818    
;;;819        //access DLH and DLL
;;;820        UART->LCR |= (1 << 7);
;;;821        UART->DLL = UART_StoreReg[0];
;;;822        UART->DLH_INTCR =  UART_StoreReg[1];
;;;823        UART->LCR &= (~(1 << 7));
;;;824    
;;;825        //access other registers
;;;826        UART->INTID_FCR = (((UART_StoreReg[7] & BIT24) >> 21) | ((UART_StoreReg[7] & 0x7C000000) >> 18) |
;;;827                           (1));
;;;828        UART->LCR = UART_StoreReg[4];
;;;829        UART->MCR = UART_StoreReg[5];
;;;830        UART->SPR = UART_StoreReg[6];
;;;831        UART->STSR = UART_StoreReg[7];
;;;832        UART->DLH_INTCR = UART_StoreReg[2];
;;;833        UART->RX_IDLE_INTTCR = UART_StoreReg[8];
;;;834        UART->RXIDLE_INTCR = UART_StoreReg[9];
;;;835        UART->MISCR = UART_StoreReg[10];
;;;836    
;;;837        return;
;;;838    }
;;;839    #endif
;;;840    
;;;841    
;;;842    #if USE_UART1_DLPS
;;;843    
;;;844    __STATIC_INLINE void UART1_DLPS_Enter(void);
;;;845    __STATIC_INLINE void UART1_DLPS_Exit(void);
;;;846    
;;;847    uint32_t UART1_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;848    
;;;849    /**
;;;850      * @brief  UART1 enter dlps callback function(Save UART1 register values when system enter DLPS)
;;;851      * @param  None
;;;852      * @retval None
;;;853      */
;;;854    __STATIC_INLINE void UART1_DLPS_Enter(void)
;;;855    {
;;;856        //enable log uart peripheral & clock
;;;857        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;858        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;859    
;;;860        //access DLH and DLL
;;;861        UART1->LCR |= (1 << 7);
;;;862        UART1_StoreReg[0] = UART1->DLL;
;;;863        UART1_StoreReg[1] = UART1->DLH_INTCR;
;;;864        UART1->LCR &= (~(1 << 7));
;;;865    
;;;866        //save other registers
;;;867        UART1_StoreReg[2] = UART1->DLH_INTCR;
;;;868        UART1_StoreReg[4] = UART1->LCR;
;;;869        UART1_StoreReg[5] = UART1->MCR;
;;;870        UART1_StoreReg[6] = UART1->SPR;
;;;871        UART1_StoreReg[7] = UART1->STSR;
;;;872        UART1_StoreReg[8] = UART1->RX_IDLE_INTTCR;
;;;873        UART1_StoreReg[9] = UART1->RXIDLE_INTCR;
;;;874        UART1_StoreReg[10] = UART1->MISCR;
;;;875    
;;;876        return;
;;;877    }
;;;878    
;;;879    /**
;;;880      * @brief  UART1 exit dlps callback function(Resume UART1 register values when system exit DLPS)
;;;881      * @param  None
;;;882      * @retval None
;;;883      */
;;;884    DATA_RAM_FUNCTION __STATIC_INLINE void UART1_DLPS_Exit(void)
;;;885    {
;;;886        //enable log uart peripheral & clock
;;;887        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;888        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;889    
;;;890        //access DLH and DLL
;;;891        UART1->LCR |= (1 << 7);
;;;892        UART1->DLL = UART1_StoreReg[0];
;;;893        UART1->DLH_INTCR =  UART1_StoreReg[1];
;;;894        UART1->LCR &= (~(1 << 7));
;;;895    
;;;896        //access other registers
;;;897        UART1->INTID_FCR = (((UART1_StoreReg[7] & BIT24) >> 21) | ((UART1_StoreReg[7] & 0x7C000000)
;;;898                                                                   >> 18) | (1));
;;;899        UART1->LCR = UART1_StoreReg[4];
;;;900        UART1->MCR = UART1_StoreReg[5];
;;;901        UART1->SPR = UART1_StoreReg[6];
;;;902        UART1->STSR = UART1_StoreReg[7];
;;;903        UART1->DLH_INTCR = UART1_StoreReg[2];
;;;904        UART1->RX_IDLE_INTTCR = UART1_StoreReg[8];
;;;905        UART1->RXIDLE_INTCR = UART1_StoreReg[9];
;;;906        UART1->MISCR = UART1_StoreReg[10];
;;;907    
;;;908        return;
;;;909    }
;;;910    #endif
;;;911    
;;;912    #if USE_UART2_DLPS
;;;913    
;;;914    __STATIC_INLINE void UART2_DLPS_Enter(void);
;;;915    __STATIC_INLINE void UART2_DLPS_Exit(void);
;;;916    
;;;917    uint32_t UART2_StoreReg[11];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;918    
;;;919    /**
;;;920      * @brief  UART2 enter dlps callback function(Save UART2 register values when system enter DLPS)
;;;921      * @param  None
;;;922      * @retval None
;;;923      */
;;;924    __STATIC_INLINE void UART2_DLPS_Enter(void)
;;;925    {
;;;926        //enable log uart peripheral & clock
;;;927        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;928        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;929    
;;;930        //access DLH and DLL
;;;931        UART2->LCR |= (1 << 7);
;;;932        UART2_StoreReg[0] = UART2->DLL;
;;;933        UART2_StoreReg[1] = UART2->DLH_INTCR;
;;;934        UART2->LCR &= (~(1 << 7));
;;;935    
;;;936        //save other registers
;;;937        UART2_StoreReg[2] = UART2->DLH_INTCR;
;;;938        UART2_StoreReg[4] = UART2->LCR;
;;;939        UART2_StoreReg[5] = UART2->MCR;
;;;940        UART2_StoreReg[6] = UART2->SPR;
;;;941        UART2_StoreReg[7] = UART2->STSR;
;;;942        UART2_StoreReg[8] = UART2->RX_IDLE_INTTCR;
;;;943        UART2_StoreReg[9] = UART2->RXIDLE_INTCR;
;;;944        UART2_StoreReg[10] = UART2->MISCR;
;;;945    
;;;946        return;
;;;947    }
;;;948    
;;;949    /**
;;;950      * @brief  UART2 exit dlps callback function(Resume UART2 register values when system exit DLPS)
;;;951      * @param  None
;;;952      * @retval None
;;;953      */
;;;954    DATA_RAM_FUNCTION __STATIC_INLINE void UART2_DLPS_Exit(void)
;;;955    {
;;;956        //enable log uart peripheral & clock
;;;957        SYSBLKCTRL->u_210.SOC_FUNC_EN |= (1 << 12);
;;;958        SYSBLKCTRL->u_230.CLK_CTRL |= ((1 << 12) | (1 << 13));
;;;959    
;;;960        //access DLH and DLL
;;;961        UART2->LCR |= (1 << 7);
;;;962        UART2->DLL = UART2_StoreReg[0];
;;;963        UART2->DLH_INTCR =  UART2_StoreReg[1];
;;;964        UART2->LCR &= (~(1 << 7));
;;;965    
;;;966        //access other registers
;;;967        UART2->INTID_FCR = (((UART2_StoreReg[7] & BIT24) >> 21) | ((UART2_StoreReg[7] & 0x7C000000)
;;;968                                                                   >> 18) | (1));
;;;969        UART2->LCR = UART2_StoreReg[4];
;;;970        UART2->MCR = UART2_StoreReg[5];
;;;971        UART2->SPR = UART2_StoreReg[6];
;;;972        UART2->STSR = UART2_StoreReg[7];
;;;973        UART2->DLH_INTCR = UART2_StoreReg[2];
;;;974        UART2->RX_IDLE_INTTCR = UART2_StoreReg[8];
;;;975        UART2->RXIDLE_INTCR = UART2_StoreReg[9];
;;;976        UART2->MISCR = UART2_StoreReg[10];
;;;977    
;;;978        return;
;;;979    }
;;;980    #endif
;;;981    
;;;982    
;;;983    /********************************************** ********************************************************/
;;;984    /**************************************** [ADC DLPS] **************************************************/
;;;985    /*******************************************************************************************************/
;;;986    /*******************************************************************************************************/
;;;987    
;;;988    #if USE_ADC_DLPS
;;;989    __STATIC_INLINE void ADC_DLPS_Enter(void);
;;;990    __STATIC_INLINE void ADC_DLPS_Exit(void);
;;;991    
;;;992    uint32_t ADC_StoreReg[14];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;993    
;;;994    /**
;;;995      * @brief  ADC enter dlps callback function(Save ADC register values when system enter DLPS)
;;;996      * @param  None
;;;997      * @retval None
;;;998      */
;;;999    __STATIC_INLINE void ADC_DLPS_Enter(void)
;;;1000   {
;;;1001       /*Open 10M clock source*/
;;;1002       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1003       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1004   
;;;1005       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1006       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1007   
;;;1008       ADC_StoreReg[0] =  ADC->CR;          //0x04
;;;1009       ADC_StoreReg[1] =  ADC->SCHCR;       //0x08
;;;1010       ADC_StoreReg[2] =  ADC->INTCR;       //0x0C
;;;1011       ADC_StoreReg[3] =  ADC->SCHTAB0;     //0x10
;;;1012       ADC_StoreReg[4] =  ADC->SCHTAB1;     //0x14
;;;1013       ADC_StoreReg[5] =  ADC->SCHTAB2;     //0x18
;;;1014       ADC_StoreReg[6] =  ADC->SCHTAB3;     //0x1C
;;;1015       ADC_StoreReg[7] =  ADC->SCHTAB4;     //0x20
;;;1016       ADC_StoreReg[8] =  ADC->SCHTAB5;     //0x24
;;;1017       ADC_StoreReg[9] =  ADC->SCHTAB6;     //0x28
;;;1018       ADC_StoreReg[10] =  ADC->SCHTAB6;    //0x2C
;;;1019       ADC_StoreReg[11] =  ADC->PWRDLY;
;;;1020       ADC_StoreReg[12] =  ADC->DATCLK;
;;;1021       ADC_StoreReg[13] =  ADC->ANACTL;
;;;1022   
;;;1023       uint8_t reg_value = 0;
;;;1024       reg_value = btaon_fast_read_safe(0x110);
;;;1025       btaon_fast_write(0x110, reg_value & (~0x04));
;;;1026   
;;;1027       return;
;;;1028   }
;;;1029   
;;;1030   /**
;;;1031     * @brief  ADC exit dlps callback function(Resume ADC register values when system exit DLPS)
;;;1032     * @param  None
;;;1033     * @retval None
;;;1034     */
;;;1035   DATA_RAM_FUNCTION __STATIC_INLINE void ADC_DLPS_Exit(void)
;;;1036   {
;;;1037       /*Open 10M clock source*/
;;;1038       SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
;;;1039       SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
;;;1040   
;;;1041       PERIPH->PERI_FUNC1_EN |= (1 << 0);
;;;1042       PERIPH->PERI_CLK_CTRL1 |= (SYSBLK_ACTCK_ADC_EN_Msk | SYSBLK_SLPCK_ADC_EN_Msk);
;;;1043   
;;;1044   #if 0
;;;1045       //Todo
;;;1046       ADC->PWRDLY = ADC_StoreReg[10];
;;;1047       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1048       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1049       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1050       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1051       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1052       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1053       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1054       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1055       ADC->SCHCR = ADC_StoreReg[1];
;;;1056       ADC->INTCR = (ADC_StoreReg[2] & 0x1F);
;;;1057   #else
;;;1058       /*Disable all interrupt.*/
;;;1059       ADC->INTCR &= (~0x1f);
;;;1060   
;;;1061       /* Set power mode first */
;;;1062       ADC->PWRDLY = ADC_StoreReg[11];
;;;1063   
;;;1064       /* Disable schedule table */
;;;1065       ADC->SCHCR &= (~0xffff);
;;;1066   
;;;1067       ADC->SCHTAB0 = ADC_StoreReg[3];
;;;1068       ADC->SCHTAB1 = ADC_StoreReg[4];
;;;1069       ADC->SCHTAB2 = ADC_StoreReg[5];
;;;1070       ADC->SCHTAB3 = ADC_StoreReg[6];
;;;1071       ADC->SCHTAB4 = ADC_StoreReg[7];
;;;1072       ADC->SCHTAB5 = ADC_StoreReg[8];
;;;1073       ADC->SCHTAB6 = ADC_StoreReg[9];
;;;1074       ADC->SCHTAB7 = ADC_StoreReg[10];
;;;1075       ADC->SCHCR   = ADC_StoreReg[1];
;;;1076       ADC->CR = (ADC_StoreReg[0] & (~((uint32_t)0x03)));
;;;1077       ADC->DATCLK = ADC_StoreReg[12];
;;;1078       ADC->ANACTL = ADC_StoreReg[13];
;;;1079   
;;;1080       /*Clear ADC FIFO */
;;;1081       ADC->CR |= BIT26;
;;;1082       /* Clear all interrupt */
;;;1083       ADC->INTCR |= (0x1f << 8);
;;;1084   
;;;1085       /* Restore specify interrupt */
;;;1086       ADC->INTCR = ADC_StoreReg[2];
;;;1087   
;;;1088   #endif
;;;1089   
;;;1090       uint8_t reg_value = 0;
;;;1091       reg_value = btaon_fast_read_safe(0x110);
;;;1092       btaon_fast_write(0x110, reg_value | 0x04);
;;;1093   
;;;1094       return;
;;;1095   }
;;;1096   
;;;1097   #endif
;;;1098   
;;;1099   /********************************************** ********************************************************/
;;;1100   /**************************************** [IR DLPS] **************************************************/
;;;1101   /*******************************************************************************************************/
;;;1102   /*******************************************************************************************************/
;;;1103   
;;;1104   #if USE_IR_DLPS
;;;1105   __STATIC_INLINE void IR_DLPS_Enter(void);
;;;1106   __STATIC_INLINE void IR_DLPS_Exit(void);
;;;1107   
;;;1108   uint32_t IR_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1109   
;;;1110   /**
;;;1111     * @brief  IR enter dlps callback function(Save IR register values when system enter DLPS)
;;;1112     * @param  None
;;;1113     * @retval None
;;;1114     */
;;;1115   __STATIC_INLINE void IR_DLPS_Enter(void)
;;;1116   {
;;;1117       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1118       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1119   
;;;1120       IR_StoreReg[0] = IR->CLK_DIV;
;;;1121       IR_StoreReg[1] = IR->TX_CONFIG;
;;;1122       IR_StoreReg[2] = IR->RX_CONFIG;
;;;1123       IR_StoreReg[3] = IR->RX_CNT_INT_SEL;
;;;1124   
;;;1125   
;;;1126       return;
;;;1127   }
;;;1128   
;;;1129   /**
;;;1130     * @brief  IR exit dlps callback function(Resume IR register values when system exit DLPS)
;;;1131     * @param  None
;;;1132     * @retval None
;;;1133     */
;;;1134   DATA_RAM_FUNCTION __STATIC_INLINE void IR_DLPS_Exit(void)
;;;1135   {
;;;1136       PERIPH->PERI_FUNC0_EN |= (1 << 10);
;;;1137       PERIPH->PERI_CLK_CTRL0 |= (SYSBLK_ACTCK_IR_EN_Msk | SYSBLK_SLPCK_IR_EN_Msk);
;;;1138   
;;;1139       IR->CLK_DIV = IR_StoreReg[0];
;;;1140       if (IR_StoreReg[1] & BIT31)
;;;1141       {
;;;1142           /* RX MODE */
;;;1143           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1144           IR->RX_CONFIG  = IR_StoreReg[2];
;;;1145           IR->RX_CNT_INT_SEL  = IR_StoreReg[3];
;;;1146       }
;;;1147       else
;;;1148       {
;;;1149           /* TX MODE */
;;;1150           IR->TX_CONFIG  = IR_StoreReg[1];
;;;1151           /* If IR TX mode is idle, must write one data firstly */
;;;1152           IR->TX_FIFO = 0;
;;;1153       }
;;;1154   
;;;1155       return;
;;;1156   }
;;;1157   
;;;1158   #endif
;;;1159   
;;;1160   /********************************************** ********************************************************/
;;;1161   /**************************************** [GDMA DLPS] **************************************************/
;;;1162   /*******************************************************************************************************/
;;;1163   /*******************************************************************************************************/
;;;1164   
;;;1165   #if USE_GDMA_DLPS
;;;1166   
;;;1167   __STATIC_INLINE void GDMA_DLPS_Enter(void);
;;;1168   __STATIC_INLINE void GDMA_DLPS_Exit(void);
;;;1169   uint32_t GDMA_StoreReg[7];         /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1170   
;;;1171   #endif
;;;1172   
;;;1173   #if USE_GDMACHANNEL0_DLPS
;;;1174   uint32_t GDMAChannel0_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1175   #endif
;;;1176   
;;;1177   #if USE_GDMACHANNEL1_DLPS
;;;1178   uint32_t GDMAChannel1_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1179   #endif
;;;1180   
;;;1181   #if USE_GDMACHANNEL2_DLPS
;;;1182   uint32_t GDMAChannel2_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1183   #endif
;;;1184   
;;;1185   #if USE_GDMACHANNEL3_DLPS
;;;1186   uint32_t GDMAChannel3_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1187   #endif
;;;1188   
;;;1189   #if USE_GDMACHANNEL4_DLPS
;;;1190   uint32_t GDMAChannel4_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1191   #endif
;;;1192   
;;;1193   #if USE_GDMACHANNEL5_DLPS
;;;1194   uint32_t GDMAChannel5_StoreReg[6];        /*  This array should be placed in RAM ON/Buffer ON.    */
;;;1195   #endif
;;;1196   
;;;1197   #if USE_GDMA_DLPS
;;;1198   /**
;;;1199     * @brief  GDMA enter dlps callback function(Save GDMA register values when system enter DLPS)
;;;1200     * @param  None
;;;1201     * @retval None
;;;1202     */
;;;1203   __STATIC_INLINE void GDMA_DLPS_Enter(void)
;;;1204   {
;;;1205       SYSBLKCTRL->u_210.SOC_FUNC_EN |= SYSBLK_GDMA0_EN_Msk;
;;;1206       PERIPH->PERI_CLK_CTRL |= (SYSBLK_ACTCK_GDMA0_EN_Msk | SYSBLK_SLPCK_GDMA0_EN_Msk);
;;;1207   
;;;1208       GDMA_StoreReg[0] = GDMA_BASE->DmaCfgReg;
;;;1209       GDMA_StoreReg[1] = GDMA_BASE->ChEnReg;
;;;1210       GDMA_StoreReg[2] = GDMA_BASE->MASK_TFR;
;;;1211       GDMA_StoreReg[3] = GDMA_BASE->MASK_BLOCK;
;;;1212       GDMA_StoreReg[4] = GDMA_BASE->MASK_SRC_TRAN;
;;;1213       GDMA_StoreReg[5] = GDMA_BASE->MASK_DST_TRAN;
;;;1214       GDMA_StoreReg[6] = GDMA_BASE->MASK_ERR;
;;;1215   
;;;1216   #if USE_GDMACHANNEL0_DLPS
;;;1217       GDMAChannel0_StoreReg[0] = GDMA_Channel0->SAR;
;;;1218       GDMAChannel0_StoreReg[1] = GDMA_Channel0->DAR;
;;;1219       GDMAChannel0_StoreReg[2] = GDMA_Channel0->CTL_LOW;
;;;1220       GDMAChannel0_StoreReg[3] = GDMA_Channel0->CTL_HIGH;
;;;1221       GDMAChannel0_StoreReg[4] = GDMA_Channel0->CFG_LOW;
;;;1222       GDMAChannel0_StoreReg[5] = GDMA_Channel0->CFG_HIGH;
;;;1223   #endif
;;;1224   #if USE_GDMACHANNEL1_DLPS
;;;1225       GDMAChannel1_StoreReg[0] = GDMA_Channel1->SAR;
;;;1226       GDMAChannel1_StoreReg[1] = GDMA_Channel1->DAR;
;;;1227       GDMAChannel1_StoreReg[2] = GDMA_Channel1->CTL_LOW;
;;;1228       GDMAChannel1_StoreReg[3] = GDMA_Channel1->CTL_HIGH;
;;;1229       GDMAChannel1_StoreReg[4] = GDMA_Channel1->CFG_LOW;
;;;1230       GDMAChannel1_StoreReg[5] = GDMA_Channel1->CFG_HIGH;
;;;1231   #endif
;;;1232   #if USE_GDMACHANNEL2_DLPS
;;;1233       GDMAChannel2_StoreReg[0] = GDMA_Channel2->SAR;
;;;1234       GDMAChannel2_StoreReg[1] = GDMA_Channel2->DAR;
;;;1235       GDMAChannel2_StoreReg[2] = GDMA_Channel2->CTL_LOW;
;;;1236       GDMAChannel2_StoreReg[3] = GDMA_Channel2->CTL_HIGH;
;;;1237       GDMAChannel2_StoreReg[4] = GDMA_Channel2->CFG_LOW;
;;;1238       GDMAChannel2_StoreReg[5] = GDMA_Channel2->CFG_HIGH;
;;;1239   #endif
;;;1240   #if USE_GDMACHANNEL3_DLPS
;;;1241       GDMAChannel3_StoreReg[0] = GDMA_Channel3->SAR;
;;;1242       GDMAChannel3_StoreReg[1] = GDMA_Channel3->DAR;
;;;1243       GDMAChannel3_StoreReg[2] = GDMA_Channel3->CTL_LOW;
;;;1244       GDMAChannel3_StoreReg[3] = GDMA_Channel3->CTL_HIGH;
;;;1245       GDMAChannel3_StoreReg[4] = GDMA_Channel3->CFG_LOW;
;;;1246       GDMAChannel3_StoreReg[5] = GDMA_Channel3->CFG_HIGH;
;;;1247   #endif
;;;1248   #if USE_GDMACHANNEL4_DLPS
;;;1249       GDMAChannel4_StoreReg[0] = GDMA_Channel4->SAR;
;;;1250       GDMAChannel4_StoreReg[1] = GDMA_Channel4->DAR;
;;;1251       GDMAChannel4_StoreReg[2] = GDMA_Channel4->CTL_LOW;
;;;1252       GDMAChannel4_StoreReg[3] = GDMA_Channel4->CTL_HIGH;
;;;1253       GDMAChannel4_StoreReg[4] = GDMA_Channel4->CFG_LOW;
;;;1254       GDMAChannel4_StoreReg[5] = GDMA_Channel4->CFG_HIGH;
;;;1255   #endif
;;;1256   #if USE_GDMACHANNEL5_DLPS
;;;1257       GDMAChannel5_StoreReg[0] = GDMA_Channel5->SAR;
;;;1258       GDMAChannel5_StoreReg[1] = GDMA_Channel5->DAR;
;;;1259       GDMAChannel5_StoreReg[2] = GDMA_Channel5->CTL_LOW;
;;;1260       GDMAChannel5_StoreReg[3] = GDMA_Channel5->CTL_HIGH;
;;;1261       GDMAChannel5_StoreReg[4] = GDMA_Channel5->CFG_LOW;
;;;1262       GDMAChannel5_StoreReg[5] = GDMA_Channel5->CFG_HIGH;
;;;1263   #endif
;;;1264   }
;;;1265   
;;;1266   /**
;;;1267     * @brief  GDMA exit dlps callback function(Resume GDMA register values when system exit DLPS)
;;;1268     * @param  None
;;;1269     * @retval None
;;;1270     */
;;;1271   DATA_RAM_FUNCTION __STATIC_INLINE void GDMA_DLPS_Exit(void)
;;;1272   {
;;;1273       SYSBLKCTRL->u_210.SOC_FUNC_EN |= SYSBLK_GDMA0_EN_Msk;
;;;1274       PERIPH->PERI_CLK_CTRL |= (SYSBLK_ACTCK_GDMA0_EN_Msk | SYSBLK_SLPCK_GDMA0_EN_Msk);
;;;1275   
;;;1276       /* Enable GDMA in DmaCfgReg*/
;;;1277       GDMA_BASE->DmaCfgReg = GDMA_StoreReg[0];
;;;1278   
;;;1279       /*----------clear pending all interrupts of GDMA channel-----------*/
;;;1280       GDMA_BASE->CLEAR_TFR = 0xff;
;;;1281       GDMA_BASE->CLEAR_BLOCK = 0xff;
;;;1282       GDMA_BASE->CLEAR_DST_TRAN = 0xff;
;;;1283       GDMA_BASE->CLEAR_SRC_TRAN = 0xff;
;;;1284       GDMA_BASE->CLEAR_ERR = 0xff;
;;;1285   
;;;1286       /*--------------------mask interrupt-------- -----------------*/
;;;1287       GDMA_BASE->MASK_TFR = (GDMA_StoreReg[2] | ((GDMA_StoreReg[2] & 0xff) << 8));
;;;1288       GDMA_BASE->MASK_BLOCK = (GDMA_StoreReg[3] | ((GDMA_StoreReg[3] & 0xff) << 8));
;;;1289       GDMA_BASE->MASK_SRC_TRAN = (GDMA_StoreReg[4] | ((GDMA_StoreReg[4] & 0xff) << 8));
;;;1290       GDMA_BASE->MASK_DST_TRAN = (GDMA_StoreReg[5] | ((GDMA_StoreReg[5] & 0xff) << 8));
;;;1291       GDMA_BASE->MASK_ERR = (GDMA_StoreReg[6] | ((GDMA_StoreReg[6] & 0xff) << 8));
;;;1292   
;;;1293   #if USE_GDMACHANNEL0_DLPS
;;;1294       GDMA_Channel0->SAR      = GDMAChannel0_StoreReg[0];
;;;1295       GDMA_Channel0->DAR      = GDMAChannel0_StoreReg[1];
;;;1296       GDMA_Channel0->CTL_LOW  = GDMAChannel0_StoreReg[2];
;;;1297       GDMA_Channel0->CTL_HIGH = GDMAChannel0_StoreReg[3];
;;;1298       GDMA_Channel0->CFG_LOW  = GDMAChannel0_StoreReg[4];
;;;1299       GDMA_Channel0->CFG_HIGH = GDMAChannel0_StoreReg[5];
;;;1300   #endif
;;;1301   #if USE_GDMACHANNEL1_DLPS
;;;1302       GDMA_Channel1->SAR      = GDMAChannel1_StoreReg[0];
;;;1303       GDMA_Channel1->DAR      = GDMAChannel1_StoreReg[1];
;;;1304       GDMA_Channel1->CTL_LOW  = GDMAChannel1_StoreReg[2];
;;;1305       GDMA_Channel1->CTL_HIGH = GDMAChannel1_StoreReg[3];
;;;1306       GDMA_Channel1->CFG_LOW  = GDMAChannel1_StoreReg[4];
;;;1307       GDMA_Channel1->CFG_HIGH = GDMAChannel1_StoreReg[5];
;;;1308   #endif
;;;1309   #if USE_GDMACHANNEL2_DLPS
;;;1310       GDMA_Channel2->SAR      = GDMAChannel2_StoreReg[0];
;;;1311       GDMA_Channel2->DAR      = GDMAChannel2_StoreReg[1];
;;;1312       GDMA_Channel2->CTL_LOW  = GDMAChannel2_StoreReg[2];
;;;1313       GDMA_Channel2->CTL_HIGH = GDMAChannel2_StoreReg[3];
;;;1314       GDMA_Channel2->CFG_LOW  = GDMAChannel2_StoreReg[4];
;;;1315       GDMA_Channel2->CFG_HIGH = GDMAChannel2_StoreReg[5];
;;;1316   #endif
;;;1317   #if USE_GDMACHANNEL3_DLPS
;;;1318       GDMA_Channel3->SAR      = GDMAChannel3_StoreReg[0];
;;;1319       GDMA_Channel3->DAR      = GDMAChannel3_StoreReg[1];
;;;1320       GDMA_Channel3->CTL_LOW  = GDMAChannel3_StoreReg[2];
;;;1321       GDMA_Channel3->CTL_HIGH = GDMAChannel3_StoreReg[3];
;;;1322       GDMA_Channel3->CFG_LOW  = GDMAChannel3_StoreReg[4];
;;;1323       GDMA_Channel3->CFG_HIGH = GDMAChannel3_StoreReg[5];
;;;1324   #endif
;;;1325   #if USE_GDMACHANNEL4_DLPS
;;;1326       GDMA_Channel4->SAR      = GDMAChannel4_StoreReg[0];
;;;1327       GDMA_Channel4->DAR      = GDMAChannel4_StoreReg[1];
;;;1328       GDMA_Channel4->CTL_LOW  = GDMAChannel4_StoreReg[2];
;;;1329       GDMA_Channel4->CTL_HIGH = GDMAChannel4_StoreReg[3];
;;;1330       GDMA_Channel4->CFG_LOW  = GDMAChannel4_StoreReg[4];
;;;1331       GDMA_Channel4->CFG_HIGH = GDMAChannel4_StoreReg[5];
;;;1332   #endif
;;;1333   #if USE_GDMACHANNEL5_DLPS
;;;1334       GDMA_Channel5->SAR      = GDMAChannel5_StoreReg[0];
;;;1335       GDMA_Channel5->DAR      = GDMAChannel5_StoreReg[1];
;;;1336       GDMA_Channel5->CTL_LOW  = GDMAChannel5_StoreReg[2];
;;;1337       GDMA_Channel5->CTL_HIGH = GDMAChannel5_StoreReg[3];
;;;1338       GDMA_Channel5->CFG_LOW  = GDMAChannel5_StoreReg[4];
;;;1339       GDMA_Channel5->CFG_HIGH = GDMAChannel5_StoreReg[5];
;;;1340   #endif
;;;1341   
;;;1342       /*----------clear pending all interrupts of GDMA channel before enable channel-----------*/
;;;1343       GDMA_BASE->CLEAR_TFR = 0x3f;
;;;1344       GDMA_BASE->CLEAR_BLOCK = 0x3f;
;;;1345       GDMA_BASE->CLEAR_DST_TRAN = 0x3f;
;;;1346       GDMA_BASE->CLEAR_SRC_TRAN = 0x3f;
;;;1347       GDMA_BASE->CLEAR_ERR = 0x3f;
;;;1348   
;;;1349       /* Enable the selected DMA Channelx */
;;;1350   //    GDMA_BASE->ChEnReg = GDMA_StoreReg[1];
;;;1351   }
;;;1352   #endif
;;;1353   
;;;1354   /********************************************** ********************************************************/
;;;1355   /**************************************** [LCD DLPS] ************************************************/
;;;1356   /*******************************************************************************************************/
;;;1357   /*******************************************************************************************************/
;;;1358   #if USE_LCD_DLPS
;;;1359   
;;;1360   uint32_t LCD_StoreReg[5];
;;;1361   
;;;1362   /**
;;;1363     * @brief  LCD enter dlps callback function(Save LCD register values when system enter DLPS)
;;;1364     * @param  None
;;;1365     * @retval None
;;;1366     */
;;;1367   __STATIC_INLINE void LCD_DLPS_Enter(void)
;;;1368   {
;;;1369       /* Enable LCD 8080 interface controller function */
;;;1370       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1371       /* Enable LCD 8080 interface controller clock */
;;;1372       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1373   
;;;1374       LCD_StoreReg[0] = *((volatile uint32_t *)0x400002A8UL) & (0x03 << 28);
;;;1375       LCD_StoreReg[1] = LCD->IMR;
;;;1376       LCD_StoreReg[2] = LCD->CTRL0;
;;;1377       LCD_StoreReg[3] = LCD->CTRL1;
;;;1378       LCD_StoreReg[4] = LCD->CFG;
;;;1379   
;;;1380   }
;;;1381   
;;;1382   /**
;;;1383     * @brief  LCD exit dlps callback function(Resume LCD register values when system exit DLPS)
;;;1384     * @param  None
;;;1385     * @retval None
;;;1386     */
;;;1387   DATA_RAM_FUNCTION __STATIC_INLINE void LCD_DLPS_Exit(void)
;;;1388   {
;;;1389       /* Enable LCD 8080 interface controller function */
;;;1390       PERIPH->PERI_FUNC0_EN |= BIT(25);
;;;1391       /* Enable LCD 8080 interface controller clock */
;;;1392       PERIPH->PERI_CLK_CTRL1 |= BIT(28) | BIT(29);
;;;1393   
;;;1394       /* Restore Dedicated SDIO pin option */
;;;1395       *((volatile uint32_t *)0x400002A8UL) &= ~(0x03 << 28);
;;;1396       *((volatile uint32_t *)0x400002A8UL) |= LCD_StoreReg[0];
;;;1397   
;;;1398       /* Initialize LCD */
;;;1399   
;;;1400       LCD->IMR    = LCD_StoreReg[1];
;;;1401       LCD->CTRL1  = LCD_StoreReg[3];
;;;1402       LCD->CFG    = LCD_StoreReg[4];
;;;1403       LCD->CTRL0  = LCD_StoreReg[2];
;;;1404   }
;;;1405   #endif
;;;1406   
;;;1407   /********************************************** ********************************************************/
;;;1408   /**************************************** [I2S0 DLPS] **************************************************/
;;;1409   /*******************************************************************************************************/
;;;1410   /*******************************************************************************************************/
;;;1411   #if USE_I2S0_DLPS
;;;1412   
;;;1413   uint32_t I2S0_StoreReg[4];
;;;1414   
;;;1415   /**
;;;1416     * @brief  I2S0 enter dlps callback function(Save I2S0 register values when system enter DLPS)
;;;1417     * @param  None
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void I2S0_DLPS_Enter(void)
;;;1421   {
;;;1422       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1423   
;;;1424       I2S0_StoreReg[0] = I2S0->BCLK_DIV;
;;;1425       I2S0_StoreReg[1] = I2S0->CTRL0;
;;;1426       I2S0_StoreReg[2] = I2S0->CTRL1;
;;;1427       I2S0_StoreReg[3] = I2S0->DMA_TRDLR;
;;;1428   }
;;;1429   
;;;1430   /**
;;;1431     * @brief  I2S0 exit dlps callback function(Resume I2S0 register values when system exit DLPS)
;;;1432     * @param  None
;;;1433     * @retval None
;;;1434     */
;;;1435   DATA_RAM_FUNCTION __STATIC_INLINE void I2S0_DLPS_Exit(void)
;;;1436   {
;;;1437       PERIPH->PERI_BD_FUNC0_EN |= BIT(1) | BIT(5) | BIT(8);
;;;1438   
;;;1439       /* Reset I2S0 module */
;;;1440       I2S0->CTRL0 |= 1 << 0;
;;;1441       I2S0->CTRL0 &= ~(1 << 0);
;;;1442   
;;;1443       /* Initialize I2S0 */
;;;1444       I2S0->BCLK_DIV  = I2S0_StoreReg[0];
;;;1445       I2S0->CTRL1     = I2S0_StoreReg[2];
;;;1446       I2S0->DMA_TRDLR = I2S0_StoreReg[3];
;;;1447       I2S0->CTRL0     = I2S0_StoreReg[1];
;;;1448   }
;;;1449   #endif
;;;1450   
;;;1451   /********************************************** ********************************************************/
;;;1452   /**************************************** [I2S1 DLPS] **************************************************/
;;;1453   /*******************************************************************************************************/
;;;1454   /*******************************************************************************************************/
;;;1455   #if USE_I2S1_DLPS
;;;1456   
;;;1457   uint32_t I2S1_StoreReg[4];
;;;1458   
;;;1459   /**
;;;1460     * @brief  I2S1 enter dlps callback function(Save I2S1 register values when system enter DLPS)
;;;1461     * @param  None
;;;1462     * @retval None
;;;1463     */
;;;1464   __STATIC_INLINE void I2S1_DLPS_Enter(void)
;;;1465   {
;;;1466       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1467   
;;;1468       I2S1_StoreReg[0] = I2S1->BCLK_DIV;
;;;1469       I2S1_StoreReg[1] = I2S1->CTRL0;
;;;1470       I2S1_StoreReg[2] = I2S1->CTRL1;
;;;1471       I2S1_StoreReg[3] = I2S1->DMA_TRDLR;
;;;1472   }
;;;1473   
;;;1474   /**
;;;1475     * @brief  I2S1 exit dlps callback function(Resume I2S1 register values when system exit DLPS)
;;;1476     * @param  None
;;;1477     * @retval None
;;;1478     */
;;;1479   DATA_RAM_FUNCTION __STATIC_INLINE void I2S1_DLPS_Exit(void)
;;;1480   {
;;;1481       PERIPH->PERI_BD_FUNC0_EN |= BIT(2) | BIT(6) | BIT(8);
;;;1482   
;;;1483       /* Reset I2S1 module */
;;;1484       I2S1->CTRL0 |= 1 << 0;
;;;1485       I2S1->CTRL0 &= ~(1 << 0);
;;;1486   
;;;1487       /* Initialize I2S1 */
;;;1488       I2S1->BCLK_DIV  = I2S1_StoreReg[0];
;;;1489       I2S1->CTRL1     = I2S1_StoreReg[2];
;;;1490       I2S1->DMA_TRDLR = I2S1_StoreReg[3];
;;;1491       I2S1->CTRL0     = I2S1_StoreReg[1];
;;;1492   }
;;;1493   #endif
;;;1494   
;;;1495   /********************************************** ********************************************************/
;;;1496   /**************************************** [CODEC DLPS] ************************************************/
;;;1497   /*******************************************************************************************************/
;;;1498   /*******************************************************************************************************/
;;;1499   #if USE_CODEC_DLPS
;;;1500   
;;;1501   uint32_t CODEC_StoreReg[7];
;;;1502   
;;;1503   /**
;;;1504     * @brief  CODEC enter dlps callback function(Save CODEC register values when system enter DLPS)
;;;1505     * @param  None
;;;1506     * @retval None
;;;1507     */
;;;1508   __STATIC_INLINE void CODEC_DLPS_Enter(void)
;;;1509   {
;;;1510       /* Enable codec function and clock */
;;;1511       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1512   
;;;1513       CODEC_StoreReg[0] = CODEC->CR0;
;;;1514       CODEC_StoreReg[1] = CODEC->CR1;
;;;1515       CODEC_StoreReg[2] = CODEC->CR2;
;;;1516       CODEC_StoreReg[3] = CODEC->CLK_CTRL;
;;;1517       CODEC_StoreReg[4] = CODEC->I2S_CTRL;
;;;1518       CODEC_StoreReg[5] = CODEC->ADC_CTRL;
;;;1519       CODEC_StoreReg[6] = CODEC->DAC_CTRL;
;;;1520   }
;;;1521   
;;;1522   /**
;;;1523     * @brief  CODEC exit dlps callback function(Resume CODEC register values when system exit DLPS)
;;;1524     * @param  None
;;;1525     * @retval None
;;;1526     */
;;;1527   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_DLPS_Exit(void)
;;;1528   {
;;;1529       /* Enable codec function and clock */
;;;1530       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1531   
;;;1532       /* Initialize CODEC */
;;;1533       if ((CODEC_StoreReg[3] & 0x900) == 0x900)
;;;1534       {
;;;1535           /* Configure AMIC parameters */
;;;1536           CODEC->CR0 = CODEC_StoreReg[0];
;;;1537           CODEC->CR1 = CODEC_StoreReg[1];
;;;1538           CODEC->CR2 = CODEC_StoreReg[2];
;;;1539       }
;;;1540   
;;;1541       /*  Reset audio digital IP */
;;;1542       CODEC->AUDIO_CTRL = 0;
;;;1543       CODEC->AUDIO_CTRL = 1;
;;;1544   
;;;1545       CODEC->CLK_CTRL = CODEC_StoreReg[3];
;;;1546       CODEC->I2S_CTRL = CODEC_StoreReg[4];
;;;1547       CODEC->ADC_CTRL = CODEC_StoreReg[5];
;;;1548       CODEC->DAC_CTRL = CODEC_StoreReg[6];
;;;1549   }
;;;1550   #endif
;;;1551   
;;;1552   /********************************************** ********************************************************/
;;;1553   /**************************************** [CODEC_EQ1 DLPS] ************************************************/
;;;1554   /*******************************************************************************************************/
;;;1555   /*******************************************************************************************************/
;;;1556   #if USE_CODEC_EQ1_DLPS
;;;1557   
;;;1558   uint32_t CODEC_EQ1_StoreReg[5];
;;;1559   
;;;1560   /**
;;;1561     * @brief  CODEC_EQ1 enter dlps callback function(Save CODEC_EQ1 register values when system enter DLPS)
;;;1562     * @param  None
;;;1563     * @retval None
;;;1564     */
;;;1565   __STATIC_INLINE void CODEC_EQ1_DLPS_Enter(void)
;;;1566   {
;;;1567       /* Enable codec function and clock */
;;;1568       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1569   
;;;1570       CODEC_EQ1_StoreReg[0] = CODEC_EQ1->EQ_H0;
;;;1571       CODEC_EQ1_StoreReg[1] = CODEC_EQ1->EQ_B1;
;;;1572       CODEC_EQ1_StoreReg[2] = CODEC_EQ1->EQ_B2;
;;;1573       CODEC_EQ1_StoreReg[3] = CODEC_EQ1->EQ_A1;
;;;1574       CODEC_EQ1_StoreReg[4] = CODEC_EQ1->EQ_A2;
;;;1575   }
;;;1576   
;;;1577   /**
;;;1578     * @brief  CODEC_EQ1 exit dlps callback function(Resume CODEC_EQ1 register values when system exit DLPS)
;;;1579     * @param  None
;;;1580     * @retval None
;;;1581     */
;;;1582   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ1_DLPS_Exit(void)
;;;1583   {
;;;1584       /* Enable codec function and clock */
;;;1585       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1586   
;;;1587       CODEC_EQ1->EQ_H0 = CODEC_EQ1_StoreReg[0];
;;;1588       CODEC_EQ1->EQ_B1 = CODEC_EQ1_StoreReg[1];
;;;1589       CODEC_EQ1->EQ_B2 = CODEC_EQ1_StoreReg[2];
;;;1590       CODEC_EQ1->EQ_A1 = CODEC_EQ1_StoreReg[3];
;;;1591       CODEC_EQ1->EQ_A2 = CODEC_EQ1_StoreReg[4];
;;;1592   }
;;;1593   #endif
;;;1594   
;;;1595   /********************************************** ********************************************************/
;;;1596   /**************************************** [CODEC_EQ2 DLPS] ************************************************/
;;;1597   /*******************************************************************************************************/
;;;1598   /*******************************************************************************************************/
;;;1599   #if USE_CODEC_EQ2_DLPS
;;;1600   
;;;1601   uint32_t CODEC_EQ2_StoreReg[5];
;;;1602   
;;;1603   /**
;;;1604     * @brief  CODEC_EQ2 enter dlps callback function(Save CODEC_EQ2 register values when system enter DLPS)
;;;1605     * @param  None
;;;1606     * @retval None
;;;1607     */
;;;1608   __STATIC_INLINE void CODEC_EQ2_DLPS_Enter(void)
;;;1609   {
;;;1610       /* Enable codec function and clock */
;;;1611       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1612   
;;;1613       CODEC_EQ2_StoreReg[0] = CODEC_EQ2->EQ_H0;
;;;1614       CODEC_EQ2_StoreReg[1] = CODEC_EQ2->EQ_B1;
;;;1615       CODEC_EQ2_StoreReg[2] = CODEC_EQ2->EQ_B2;
;;;1616       CODEC_EQ2_StoreReg[3] = CODEC_EQ2->EQ_A1;
;;;1617       CODEC_EQ2_StoreReg[4] = CODEC_EQ2->EQ_A2;
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  CODEC_EQ2 exit dlps callback function(Resume CODEC_EQ2 register values when system exit DLPS)
;;;1622     * @param  None
;;;1623     * @retval None
;;;1624     */
;;;1625   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ2_DLPS_Exit(void)
;;;1626   {
;;;1627       /* Enable codec function and clock */
;;;1628       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1629   
;;;1630       CODEC_EQ2->EQ_H0 = CODEC_EQ2_StoreReg[0];
;;;1631       CODEC_EQ2->EQ_B1 = CODEC_EQ2_StoreReg[1];
;;;1632       CODEC_EQ2->EQ_B2 = CODEC_EQ2_StoreReg[2];
;;;1633       CODEC_EQ2->EQ_A1 = CODEC_EQ2_StoreReg[3];
;;;1634       CODEC_EQ2->EQ_A2 = CODEC_EQ2_StoreReg[4];
;;;1635   }
;;;1636   #endif
;;;1637   
;;;1638   /********************************************** ********************************************************/
;;;1639   /**************************************** [CODEC_EQ3 DLPS] ************************************************/
;;;1640   /*******************************************************************************************************/
;;;1641   /*******************************************************************************************************/
;;;1642   #if USE_CODEC_EQ3_DLPS
;;;1643   
;;;1644   uint32_t CODEC_EQ3_StoreReg[5];
;;;1645   
;;;1646   /**
;;;1647     * @brief  CODEC_EQ3 enter dlps callback function(Save CODEC_EQ3 register values when system enter DLPS)
;;;1648     * @param  None
;;;1649     * @retval None
;;;1650     */
;;;1651   __STATIC_INLINE void CODEC_EQ3_DLPS_Enter(void)
;;;1652   {
;;;1653       /* Enable codec function and clock */
;;;1654       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1655   
;;;1656       CODEC_EQ3_StoreReg[0] = CODEC_EQ3->EQ_H0;
;;;1657       CODEC_EQ3_StoreReg[1] = CODEC_EQ3->EQ_B1;
;;;1658       CODEC_EQ3_StoreReg[2] = CODEC_EQ3->EQ_B2;
;;;1659       CODEC_EQ3_StoreReg[3] = CODEC_EQ3->EQ_A1;
;;;1660       CODEC_EQ3_StoreReg[4] = CODEC_EQ3->EQ_A2;
;;;1661   }
;;;1662   
;;;1663   /**
;;;1664     * @brief  CODEC_EQ3 exit dlps callback function(Resume CODEC_EQ3 register values when system exit DLPS)
;;;1665     * @param  None
;;;1666     * @retval None
;;;1667     */
;;;1668   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ3_DLPS_Exit(void)
;;;1669   {
;;;1670       /* Enable codec function and clock */
;;;1671       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1672   
;;;1673       CODEC_EQ3->EQ_H0 = CODEC_EQ3_StoreReg[0];
;;;1674       CODEC_EQ3->EQ_B1 = CODEC_EQ3_StoreReg[1];
;;;1675       CODEC_EQ3->EQ_B2 = CODEC_EQ3_StoreReg[2];
;;;1676       CODEC_EQ3->EQ_A1 = CODEC_EQ3_StoreReg[3];
;;;1677       CODEC_EQ3->EQ_A2 = CODEC_EQ3_StoreReg[4];
;;;1678   }
;;;1679   #endif
;;;1680   
;;;1681   /********************************************** ********************************************************/
;;;1682   /**************************************** [CODEC_EQ4 DLPS] ************************************************/
;;;1683   /*******************************************************************************************************/
;;;1684   /*******************************************************************************************************/
;;;1685   #if USE_CODEC_EQ4_DLPS
;;;1686   
;;;1687   uint32_t CODEC_EQ4_StoreReg[5];
;;;1688   
;;;1689   /**
;;;1690     * @brief  CODEC_EQ4 enter dlps callback function(Save CODEC_EQ4 register values when system enter DLPS)
;;;1691     * @param  None
;;;1692     * @retval None
;;;1693     */
;;;1694   __STATIC_INLINE void CODEC_EQ4_DLPS_Enter(void)
;;;1695   {
;;;1696       /* Enable codec function and clock */
;;;1697       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1698   
;;;1699       CODEC_EQ4_StoreReg[0] = CODEC_EQ4->EQ_H0;
;;;1700       CODEC_EQ4_StoreReg[1] = CODEC_EQ4->EQ_B1;
;;;1701       CODEC_EQ4_StoreReg[2] = CODEC_EQ4->EQ_B2;
;;;1702       CODEC_EQ4_StoreReg[3] = CODEC_EQ4->EQ_A1;
;;;1703       CODEC_EQ4_StoreReg[4] = CODEC_EQ4->EQ_A2;
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  CODEC_EQ4 exit dlps callback function(Resume CODEC_EQ4 register values when system exit DLPS)
;;;1708     * @param  None
;;;1709     * @retval None
;;;1710     */
;;;1711   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ4_DLPS_Exit(void)
;;;1712   {
;;;1713       /* Enable codec function and clock */
;;;1714       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1715   
;;;1716       CODEC_EQ4->EQ_H0 = CODEC_EQ4_StoreReg[0];
;;;1717       CODEC_EQ4->EQ_B1 = CODEC_EQ4_StoreReg[1];
;;;1718       CODEC_EQ4->EQ_B2 = CODEC_EQ4_StoreReg[2];
;;;1719       CODEC_EQ4->EQ_A1 = CODEC_EQ4_StoreReg[3];
;;;1720       CODEC_EQ4->EQ_A2 = CODEC_EQ4_StoreReg[4];
;;;1721   }
;;;1722   #endif
;;;1723   
;;;1724   /********************************************** ********************************************************/
;;;1725   /**************************************** [CODEC_EQ5 DLPS] ************************************************/
;;;1726   /*******************************************************************************************************/
;;;1727   /*******************************************************************************************************/
;;;1728   #if USE_CODEC_EQ5_DLPS
;;;1729   
;;;1730   uint32_t CODEC_EQ5_StoreReg[5];
;;;1731   
;;;1732   /**
;;;1733     * @brief  CODEC_EQ5 enter dlps callback function(Save CODEC_EQ5 register values when system enter DLPS)
;;;1734     * @param  None
;;;1735     * @retval None
;;;1736     */
;;;1737   __STATIC_INLINE void CODEC_EQ5_DLPS_Enter(void)
;;;1738   {
;;;1739       /* Enable codec function and clock */
;;;1740       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1741   
;;;1742       CODEC_EQ5_StoreReg[0] = CODEC_EQ5->EQ_H0;
;;;1743       CODEC_EQ5_StoreReg[1] = CODEC_EQ5->EQ_B1;
;;;1744       CODEC_EQ5_StoreReg[2] = CODEC_EQ5->EQ_B2;
;;;1745       CODEC_EQ5_StoreReg[3] = CODEC_EQ5->EQ_A1;
;;;1746       CODEC_EQ5_StoreReg[4] = CODEC_EQ5->EQ_A2;
;;;1747   }
;;;1748   
;;;1749   /**
;;;1750     * @brief  CODEC_EQ5 exit dlps callback function(Resume CODEC_EQ5 register values when system exit DLPS)
;;;1751     * @param  None
;;;1752     * @retval None
;;;1753     */
;;;1754   DATA_RAM_FUNCTION __STATIC_INLINE void CODEC_EQ5_DLPS_Exit(void)
;;;1755   {
;;;1756       /* Enable codec function and clock */
;;;1757       PERIPH->PERI_BD_FUNC0_EN |= (1 << 0) | (1 << 4);
;;;1758   
;;;1759       CODEC_EQ5->EQ_H0 = CODEC_EQ5_StoreReg[0];
;;;1760       CODEC_EQ5->EQ_B1 = CODEC_EQ5_StoreReg[1];
;;;1761       CODEC_EQ5->EQ_B2 = CODEC_EQ5_StoreReg[2];
;;;1762       CODEC_EQ5->EQ_A1 = CODEC_EQ5_StoreReg[3];
;;;1763       CODEC_EQ5->EQ_A2 = CODEC_EQ5_StoreReg[4];
;;;1764   }
;;;1765   #endif
;;;1766   
;;;1767   /**
;;;1768     * @brief  Set Log and SWD pins to SW mode.
;;;1769     * @param  void.
;;;1770     * @retval void.
;;;1771     */
;;;1772   __STATIC_INLINE void Log_SWD_DLPS_Enter(void)
;;;1773   {
;;;1774       if (OTP->SWD_ENABLE)
;;;1775       {
;;;1776           Pad_Config(P1_0, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1777           Pad_Config(P1_1, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1778       }
;;;1779   
;;;1780       Pad_Config(OTP->logPin, PAD_SW_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
;;;1781   
;;;1782   }
;;;1783   
;;;1784   /**
;;;1785     * @brief  Set Log and SWD pins to PINMUX mode.
;;;1786     * @param  void.
;;;1787     * @retval void.
;;;1788     */
;;;1789   DATA_RAM_FUNCTION __STATIC_INLINE void Log_SWD_DLPS_Exit(void)
;;;1790   {
;;;1791       Pad_Config(OTP->logPin, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_NONE, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00207d42:    2400        .$      MOVS     r4,#0
        0x00207d44:    f44f1500    O...    MOV      r5,#0x200000
        0x00207d48:    9400        ..      STR      r4,[sp,#0]
        0x00207d4a:    9401        ..      STR      r4,[sp,#4]
        0x00207d4c:    f8950398    ....    LDRB     r0,[r5,#0x398]
        0x00207d50:    2201        ."      MOVS     r2,#1
        0x00207d52:    f000003f    ..?.    AND      r0,r0,#0x3f
        0x00207d56:    4623        #F      MOV      r3,r4
        0x00207d58:    4611        .F      MOV      r1,r2
        0x00207d5a:    f5057566    ..fu    ADD      r5,r5,#0x398
        0x00207d5e:    f609fb3d    ..=.    BL       Pad_Config ; 0x113dc
;;;1792   
;;;1793       if (OTP->SWD_ENABLE)
        0x00207d62:    f8150c64    ..d.    LDRB     r0,[r5,#-0x64]
        0x00207d66:    07c0        ..      LSLS     r0,r0,#31
        0x00207d68:    d00f        ..      BEQ      0x207d8a ; DLPS_IO_ExitDlpsCb + 102
;;;1794       {
;;;1795           Pad_Config(P1_0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00207d6a:    2301        .#      MOVS     r3,#1
        0x00207d6c:    9400        ..      STR      r4,[sp,#0]
        0x00207d6e:    461a        .F      MOV      r2,r3
        0x00207d70:    4619        .F      MOV      r1,r3
        0x00207d72:    2008        .       MOVS     r0,#8
        0x00207d74:    9401        ..      STR      r4,[sp,#4]
        0x00207d76:    f609fb31    ..1.    BL       Pad_Config ; 0x113dc
;;;1796           Pad_Config(P1_1, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_UP, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x00207d7a:    2301        .#      MOVS     r3,#1
        0x00207d7c:    9400        ..      STR      r4,[sp,#0]
        0x00207d7e:    461a        .F      MOV      r2,r3
        0x00207d80:    4619        .F      MOV      r1,r3
        0x00207d82:    2009        .       MOVS     r0,#9
        0x00207d84:    9401        ..      STR      r4,[sp,#4]
        0x00207d86:    f609fb29    ..).    BL       Pad_Config ; 0x113dc
;;;1797       }
;;;1798   }
;;;1799   
;;;1800   /********************************************** ********************************************************/
;;;1801   /*********************************** [USER Exit DLPS CALLBACK FUCN] *****************************************/
;;;1802   /*******************************************************************************************************/
;;;1803   /*******************************************************************************************************/
;;;1804   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;1805   
;;;1806   DLPS_IO_ExitDlpsCB User_IO_ExitDlpsCB = NULL;
;;;1807   
;;;1808   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1809   
;;;1810   /********************************************** ********************************************************/
;;;1811   /*********************************** [USER Enter DLPS CALLBACK FUCN] *****************************************/
;;;1812   /*******************************************************************************************************/
;;;1813   /*******************************************************************************************************/
;;;1814   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1815   
;;;1816   DLPS_IO_EnterDlpsCB User_IO_EnterDlpsCB = NULL;
;;;1817   
;;;1818   #endif /* USE_USER_DEFINE_DLPS_EXIT_CB */
;;;1819   
;;;1820   /********************************************** ********************************************************/
;;;1821   /*********************************** [Enter & Exit DLPS CALLBACK FUNC] *********************************/
;;;1822   /*******************************************************************************************************/
;;;1823   /*******************************************************************************************************/
;;;1824   #if USE_IO_DRIVER_DLPS
;;;1825   
;;;1826   /**
;;;1827     * @brief  IO enter dlps callback function
;;;1828     * @param  None
;;;1829     * @retval None
;;;1830     */
;;;1831   void DLPS_IO_EnterDlpsCb(void)
;;;1832   {
;;;1833       /* low stack do it instead */
;;;1834   //    Pad_ClearAllWakeupINT();
;;;1835   
;;;1836   //    DBG_DIRECT("DLPS_IO_EnterDlpsCb");
;;;1837       NVIC_DisableIRQ(System_IRQn);
;;;1838       CPU_DLPS_Enter();
;;;1839   
;;;1840       Pinmux_DLPS_Enter();
;;;1841   
;;;1842   #if USE_USER_DEFINE_DLPS_ENTER_CB
;;;1843       if (User_IO_EnterDlpsCB)
;;;1844       {
;;;1845           User_IO_EnterDlpsCB();
;;;1846       }
;;;1847   #endif
;;;1848   
;;;1849   #if USE_I2C0_DLPS
;;;1850       I2C0_DLPS_Enter();
;;;1851   #endif
;;;1852   
;;;1853   #if USE_I2C1_DLPS
;;;1854       I2C1_DLPS_Enter();
;;;1855   #endif
;;;1856   
;;;1857   #if USE_TIM_DLPS
;;;1858       TIM_DLPS_Enter();
;;;1859   #endif
;;;1860   
;;;1861   #if USE_QDECODER_DLPS
;;;1862       QuadDecoder_DLPS_Enter();
;;;1863   #endif
;;;1864   
;;;1865   #if USE_IR_DLPS
;;;1866       IR_DLPS_Enter();
;;;1867   #endif
;;;1868   
;;;1869   #if USE_UART_DLPS
;;;1870       UART_DLPS_Enter();
;;;1871   #endif
;;;1872   
;;;1873   #if USE_UART1_DLPS
;;;1874       UART1_DLPS_Enter();
;;;1875   #endif
;;;1876   
;;;1877   #if USE_UART2_DLPS
;;;1878       UART2_DLPS_Enter();
;;;1879   #endif
;;;1880   
;;;1881   #if USE_SPI0_DLPS
;;;1882       SPI0_DLPS_Enter();
;;;1883   #endif
;;;1884   
;;;1885   #if USE_SPI1_DLPS
;;;1886       SPI1_DLPS_Enter();
;;;1887   #endif
;;;1888   
;;;1889   #if USE_SPI2W_DLPS
;;;1890       SPI2W_DLPS_Enter();
;;;1891   #endif
;;;1892   
;;;1893   #if USE_KEYSCAN_DLPS
;;;1894       KeyScan_DLPS_Enter();
;;;1895   #endif
;;;1896   
;;;1897   #if USE_GPIO_DLPS
;;;1898       GPIO_DLPS_Enter();
;;;1899   #endif
;;;1900   
;;;1901   #if USE_ADC_DLPS
;;;1902       ADC_DLPS_Enter();
;;;1903   #endif
;;;1904   
;;;1905   #if USE_LCD_DLPS
;;;1906       LCD_DLPS_Enter();
;;;1907   #endif
;;;1908   
;;;1909   #if USE_I2S0_DLPS
;;;1910       I2S0_DLPS_Enter();
;;;1911   #endif
;;;1912   
;;;1913   #if USE_I2S1_DLPS
;;;1914       I2S1_DLPS_Enter();
;;;1915   #endif
;;;1916   
;;;1917   #if USE_CODEC_DLPS
;;;1918       CODEC_DLPS_Enter();
;;;1919   #endif
;;;1920   
;;;1921   #if USE_CODEC_EQ1_DLPS
;;;1922       CODEC_EQ1_DLPS_Enter();
;;;1923   #endif
;;;1924   
;;;1925   #if USE_CODEC_EQ2_DLPS
;;;1926       CODEC_EQ2_DLPS_Enter();
;;;1927   #endif
;;;1928   
;;;1929   #if USE_CODEC_EQ3_DLPS
;;;1930       CODEC_EQ3_DLPS_Enter();
;;;1931   #endif
;;;1932   
;;;1933   #if USE_CODEC_EQ4_DLPS
;;;1934       CODEC_EQ4_DLPS_Enter();
;;;1935   #endif
;;;1936   
;;;1937   #if USE_CODEC_EQ5_DLPS
;;;1938       CODEC_EQ5_DLPS_Enter();
;;;1939   #endif
;;;1940   
;;;1941   #if USE_GDMA_DLPS
;;;1942       GDMA_DLPS_Enter();
;;;1943   #endif
;;;1944   
;;;1945       Log_SWD_DLPS_Enter();
;;;1946   
;;;1947   }
;;;1948   #endif  /* USE_IO_DRIVER_DLPS */
;;;1949   
;;;1950   #if USE_IO_DRIVER_DLPS
;;;1951   /**
;;;1952     * @brief  IO exit dlps callback function.
;;;1953     * @param  None
;;;1954     * @retval None
;;;1955     */
;;;1956   DATA_RAM_FUNCTION void DLPS_IO_ExitDlpsCb(void)
;;;1957   {
;;;1958   
;;;1959   //    DBG_BUFFER(TYPE_BUMBLEBEE3, SUBTYPE_FORMAT, MODULE_DLPS, LEVEL_INFO,
;;;1960   //               "DLPS_IO_ExitDlpsCb",0);
;;;1961   
;;;1962       Pinmux_DLPS_Exit();
;;;1963   
;;;1964       Log_SWD_DLPS_Exit();
;;;1965   
;;;1966   #if USE_I2C0_DLPS
;;;1967       I2C0_DLPS_Exit();
;;;1968   #endif
;;;1969   
;;;1970   #if USE_I2C1_DLPS
;;;1971       I2C1_DLPS_Exit();
;;;1972   #endif
;;;1973   
;;;1974   #if USE_TIM_DLPS
;;;1975       TIM_DLPS_Exit();
;;;1976   #endif
;;;1977   
;;;1978   #if USE_QDECODER_DLPS
;;;1979       QuadDecoder_DLPS_Exit();
;;;1980   #endif
;;;1981   
;;;1982   #if USE_IR_DLPS
;;;1983       IR_DLPS_Exit();
;;;1984   #endif
;;;1985   
;;;1986   #if USE_UART_DLPS
;;;1987       UART_DLPS_Exit();
;;;1988   #endif
;;;1989   
;;;1990   #if USE_UART1_DLPS
;;;1991       UART1_DLPS_Exit();
;;;1992   #endif
;;;1993   
;;;1994   #if USE_UART2_DLPS
;;;1995       UART2_DLPS_Exit();
;;;1996   #endif
;;;1997   
;;;1998   #if USE_SPI0_DLPS
;;;1999       SPI0_DLPS_Exit();
;;;2000   #endif
;;;2001   
;;;2002   #if USE_SPI1_DLPS
;;;2003       SPI1_DLPS_Exit();
;;;2004   #endif
;;;2005   
;;;2006   #if USE_SPI2W_DLPS
;;;2007       SPI2W_DLPS_Exit();
;;;2008   #endif
;;;2009   
;;;2010   #if USE_KEYSCAN_DLPS
;;;2011       KeyScan_DLPS_Exit();
;;;2012   #endif
;;;2013   
;;;2014   #if USE_GPIO_DLPS
;;;2015       GPIO_DLPS_Exit();
        0x00207d8a:    f000f832    ..2.    BL       GPIO_DLPS_Exit ; 0x207df2
;;;2016   #endif
;;;2017   
;;;2018   #if USE_ADC_DLPS
;;;2019       ADC_DLPS_Exit();
;;;2020   #endif
;;;2021   
;;;2022   #if USE_LCD_DLPS
;;;2023       LCD_DLPS_Exit();
;;;2024   #endif
;;;2025   
;;;2026   #if USE_I2S0_DLPS
;;;2027       I2S0_DLPS_Exit();
;;;2028   #endif
;;;2029   
;;;2030   #if USE_I2S1_DLPS
;;;2031       I2S1_DLPS_Exit();
;;;2032   #endif
;;;2033   
;;;2034   #if USE_CODEC_DLPS
;;;2035       CODEC_DLPS_Exit();
;;;2036   #endif
;;;2037   
;;;2038   #if USE_CODEC_EQ1_DLPS
;;;2039       CODEC_EQ1_DLPS_Exit();
;;;2040   #endif
;;;2041   
;;;2042   #if USE_CODEC_EQ2_DLPS
;;;2043       CODEC_EQ2_DLPS_Exit();
;;;2044   #endif
;;;2045   
;;;2046   #if USE_CODEC_EQ3_DLPS
;;;2047       CODEC_EQ3_DLPS_Exit();
;;;2048   #endif
;;;2049   
;;;2050   #if USE_CODEC_EQ4_DLPS
;;;2051       CODEC_EQ4_DLPS_Exit();
;;;2052   #endif
;;;2053   
;;;2054   #if USE_CODEC_EQ5_DLPS
;;;2055       CODEC_EQ5_DLPS_Exit();
;;;2056   #endif
;;;2057   
;;;2058   #if USE_GDMA_DLPS
;;;2059       GDMA_DLPS_Exit();
;;;2060   #endif
;;;2061   
;;;2062   #if USE_USER_DEFINE_DLPS_EXIT_CB
;;;2063       if (User_IO_ExitDlpsCB)
        0x00207d8e:    4d2d        -M      LDR      r5,[pc,#180] ; [0x207e44] = 0x207fbc
        0x00207d90:    3d90        .=      SUBS     r5,r5,#0x90
        0x00207d92:    6868        hh      LDR      r0,[r5,#4]
        0x00207d94:    b100        ..      CBZ      r0,0x207d98 ; DLPS_IO_ExitDlpsCb + 116
;;;2064       {
;;;2065           User_IO_ExitDlpsCB();
        0x00207d96:    4780        .G      BLX      r0
;;;2066       }
;;;2067   #endif
;;;2068   
;;;2069       NVIC_InitTypeDef nvic_init_struct;
;;;2070       nvic_init_struct.NVIC_IRQChannel         = System_IRQn;
;;;2071       nvic_init_struct.NVIC_IRQChannelCmd      = (FunctionalState)ENABLE;
        0x00207d98:    2001        .       MOVS     r0,#1
        0x00207d9a:    f88d0010    ....    STRB     r0,[sp,#0x10]
;;;2072       nvic_init_struct.NVIC_IRQChannelPriority = 3;
        0x00207d9e:    2003        .       MOVS     r0,#3
;;;2073       NVIC_Init(&nvic_init_struct); //Enable SYSTEM_ON Interrupt
        0x00207da0:    9003        ..      STR      r0,[sp,#0xc]
        0x00207da2:    f88d4008    ...@    STRB     r4,[sp,#8]
        0x00207da6:    a802        ..      ADD      r0,sp,#8
        0x00207da8:    f609fa8a    ....    BL       NVIC_Init ; 0x112c0
        0x00207dac:    4c25        %L      LDR      r4,[pc,#148] ; [0x207e44] = 0x207fbc
        0x00207dae:    3c84        .<      SUBS     r4,r4,#0x84
        0x00207db0:    6863        ch      LDR      r3,[r4,#4]
        0x00207db2:    b123        #.      CBZ      r3,0x207dbe ; DLPS_IO_ExitDlpsCb + 154
        0x00207db4:    2201        ."      MOVS     r2,#1
        0x00207db6:    4924        $I      LDR      r1,[pc,#144] ; [0x207e48] = 0x880006c
        0x00207db8:    4824        $H      LDR      r0,[pc,#144] ; [0x207e4c] = 0x21100401
        0x00207dba:    f5fffe50    ..P.    BL       log_buffer ; 0x7a5e
        0x00207dbe:    2003        .       MOVS     r0,#3
        0x00207dc0:    f10022e0    ..."    ADD      r2,r0,#0xe000e000
        0x00207dc4:    f8141020    .. .    LDRB     r1,[r4,r0,LSL #2]
        0x00207dc8:    f8821400    ....    STRB     r1,[r2,#0x400]
        0x00207dcc:    1c40        @.      ADDS     r0,r0,#1
        0x00207dce:    2820         (      CMP      r0,#0x20
        0x00207dd0:    d3f6        ..      BCC      0x207dc0 ; DLPS_IO_ExitDlpsCb + 156
        0x00207dd2:    491f        .I      LDR      r1,[pc,#124] ; [0x207e50] = 0xe000ed08
        0x00207dd4:    f8d40080    ....    LDR      r0,[r4,#0x80]
        0x00207dd8:    6008        .`      STR      r0,[r1,#0]
        0x00207dda:    491e        .I      LDR      r1,[pc,#120] ; [0x207e54] = 0x40006000
        0x00207ddc:    6828        (h      LDR      r0,[r5,#0]
        0x00207dde:    60c8        .`      STR      r0,[r1,#0xc]
        0x00207de0:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x00207de4:    6820         h      LDR      r0,[r4,#0]
        0x00207de6:    f8c10100    ....    STR      r0,[r1,#0x100]
        0x00207dea:    f206f355    ..U.    BL       debug_monitor_enable ; 0x80e498
;;;2074   
;;;2075       CPU_DLPS_Exit();
;;;2076   }
        0x00207dee:    b005        ..      ADD      sp,sp,#0x14
        0x00207df0:    bd30        0.      POP      {r4,r5,pc}
    GPIO_DLPS_Exit
        0x00207df2:    b510        ..      PUSH     {r4,lr}
;;; .\..\include\SDK\src\mcu\peripheral\rtl876x_io_dlps.c (177)
        0x00207df4:    f04f4280    O..B    MOV      r2,#0x40000000
        0x00207df8:    f8d2021c    ....    LDR      r0,[r2,#0x21c]
        0x00207dfc:    f4407080    @..p    ORR      r0,r0,#0x100
        0x00207e00:    f8c2021c    ....    STR      r0,[r2,#0x21c]
;;;178        PERIPH->PERI_CLK_CTRL |= (BIT_SOC_ACTCK_GPIO_EN | SYSBLK_SLPCK_GPIO_EN_Msk);
        0x00207e04:    f8d20230    ..0.    LDR      r0,[r2,#0x230]
        0x00207e08:    f0407040    @.@p    ORR      r0,r0,#0x3000000
        0x00207e0c:    f8c20230    ..0.    STR      r0,[r2,#0x230]
;;;179    
;;;180        GPIO->DATADIR       = GPIO_StoreReg[1];
        0x00207e10:    480c        .H      LDR      r0,[pc,#48] ; [0x207e44] = 0x207fbc
        0x00207e12:    4911        .I      LDR      r1,[pc,#68] ; [0x207e58] = 0x40001000
        0x00207e14:    3028        (0      ADDS     r0,r0,#0x28
        0x00207e16:    6843        Ch      LDR      r3,[r0,#4]
        0x00207e18:    604b        K`      STR      r3,[r1,#4]
;;;181        GPIO->DATASRC       = GPIO_StoreReg[2];
        0x00207e1a:    6884        .h      LDR      r4,[r0,#8]
        0x00207e1c:    608c        .`      STR      r4,[r1,#8]
;;;182        GPIO->INTMASK       = GPIO_StoreReg[4];
        0x00207e1e:    6904        .i      LDR      r4,[r0,#0x10]
        0x00207e20:    634c        Lc      STR      r4,[r1,#0x34]
;;;183        GPIO->INTTYPE       = GPIO_StoreReg[5];
        0x00207e22:    6944        Di      LDR      r4,[r0,#0x14]
        0x00207e24:    638c        .c      STR      r4,[r1,#0x38]
;;;184        GPIO->INTPOLARITY   = GPIO_StoreReg[6];
        0x00207e26:    6984        .i      LDR      r4,[r0,#0x18]
        0x00207e28:    63cc        .c      STR      r4,[r1,#0x3c]
;;;185        GPIO->DEBOUNCE      = GPIO_StoreReg[7];
        0x00207e2a:    69c4        .i      LDR      r4,[r0,#0x1c]
        0x00207e2c:    648c        .d      STR      r4,[r1,#0x48]
;;;186        GPIO->DATAOUT       = GPIO_StoreReg[0];
        0x00207e2e:    6804        .h      LDR      r4,[r0,#0]
        0x00207e30:    600c        .`      STR      r4,[r1,#0]
;;;187        GPIO->INTCLR        = ~(GPIO_StoreReg[1]);
        0x00207e32:    43db        .C      MVNS     r3,r3
        0x00207e34:    64cb        .d      STR      r3,[r1,#0x4c]
;;;188        GPIO->INTEN         = GPIO_StoreReg[3];
        0x00207e36:    68c3        .h      LDR      r3,[r0,#0xc]
        0x00207e38:    630b        .c      STR      r3,[r1,#0x30]
;;;189        *(__IO uint32_t *)(0x40000344UL) = GPIO_StoreReg[8];
        0x00207e3a:    6a00        .j      LDR      r0,[r0,#0x20]
        0x00207e3c:    f8c20344    ..D.    STR      r0,[r2,#0x344]
;;;190    
;;;191        return;
;;;192    }
        0x00207e40:    bd10        ..      POP      {r4,pc}
    $d
        0x00207e42:    0000        ..      DCW    0
        0x00207e44:    00207fbc    .. .    DCD    2129852
        0x00207e48:    0880006c    l...    DCD    142606444
        0x00207e4c:    21100401    ...!    DCD    554697729
        0x00207e50:    e000ed08    ....    DCD    3758157064
        0x00207e54:    40006000    .`.@    DCD    1073766400
        0x00207e58:    40001000    ...@    DCD    1073745920

** Section #6 'RAM_DATA_ON' (SHT_PROGBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 204 bytes (alignment 4)
    Address: 0x00207e5c

    0x207e5c:   1e 00 00 00 0e 01 5d 00 00 00 00 01 00 01 02 00    ......].........
    0x207e6c:   00 03 04 05 fe 00 65 78 70 65 72 69 6d 65 6e 74    ......experiment
    0x207e7c:   61 6c 00 00 00 00 00 00 00 00 00 00 00 00 00 00    al..............
    0x207e8c:   00 00 01 03 19 40 02 09 09 42 4c 42 5f 50 52 4f    .....@...BLB_PRO
    0x207e9c:   58 02 01 06 11 07 a6 f6 f6 07 4d c4 9d 98 6d 45    X.........M...mE
    0x207eac:   29 bb d0 ff 00 00 00 00 01 00 00 00 1e 00 00 00    )...............
    0x207ebc:   bc 10 81 00 24 15 81 00 e4 15 81 00 e4 80 20 00    ....$......... .
    0x207ecc:   a4 81 20 00 a4 81 20 00 c0 00 00 00 00 00 00 00    .. ... .........
    0x207edc:   00 00 00 00 ac 10 81 00 e4 15 81 00 e4 15 81 00    ................
    0x207eec:   e4 80 20 00 e4 80 20 00 e4 80 20 00 00 00 00 00    .. ... ... .....
    0x207efc:   00 00 00 00 00 00 00 00 b4 10 81 00 e4 15 81 00    ................
    0x207f0c:   e4 15 81 00 e4 80 20 00 e4 80 20 00 e4 80 20 00    ...... ... ... .
    0x207f1c:   00 00 00 00 00 00 00 00 00 00 00 00                ............


** Section #7 'RAM_DATA_ON' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 444 bytes (alignment 4)
    Address: 0x00207f28


** Section #8 'OVERLAY_A' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 192 bytes (alignment 4)
    Address: 0x002080e4

    $t
    .app.overlay_a
    AppUpdateVectorTable
;;; .\..\include\SDK\src\mcu\rtl876x\system_rtl8762c.c
;;;474    static void AppUpdateVectorTable(void)
;;;474    {
        0x002080e4:    e92d43f0    -..C    PUSH     {r4-r9,lr}
        0x002080e8:    b0bd        ..      SUB      sp,sp,#0xf4
;;;475        extern uint32_t Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;476        extern uint32_t Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;477        extern void Default_Handler(void);
;;;478        const char *SysException[] =
        0x002080ea:    2240        @"      MOVS     r2,#0x40
        0x002080ec:    4926        &I      LDR      r1,[pc,#152] ; [0x208188] = 0x8108c8
        0x002080ee:    a82d        -.      ADD      r0,sp,#0xb4
        0x002080f0:    f651ff5a    Q.Z.    BL       __aeabi_memcpy4 ; 0x59fa8
;;;479        {
;;;480            "InitialSP", "Reset", "NMI", "HardFault", "MemManage", "BusFault", "UsageFault", "Rsvd",
;;;481            "Rsvd", "Rsvd", "Rsvd", "SVC", "DebugMon", "Rsvd", "PendSV", "SysTick"
;;;482        };
;;;483        const char *ExtIrq[] =
        0x002080f4:    4924        $I      LDR      r1,[pc,#144] ; [0x208188] = 0x8108c8
        0x002080f6:    22b4        ."      MOVS     r2,#0xb4
        0x002080f8:    3140        @1      ADDS     r1,r1,#0x40
        0x002080fa:    4668        hF      MOV      r0,sp
        0x002080fc:    f651ff54    Q.T.    BL       __aeabi_memcpy4 ; 0x59fa8
        0x00208100:    4924        $I      LDR      r1,[pc,#144] ; [0x208194] = 0xe000ed08
;;;484        {
;;;485            "System", "WDG", "BTMAC", "TIM3", "TIM2", "Platform", "I2S0_TX", "I2S0_RX", "Timer4-7",
;;;486            "GPIO4", "GPIO5", "UART1", "UART0", "RTC", "SPI0", "SPI1", "I2C0", "I2C1", "ADC",
;;;487            "Peripheral", "GDMA0 Channel0", "GDMA0 Channel1", "GDMA0 Channel2", "GDMA0 Channel3",
;;;488            "GDMA0 Channel4", "GDMA0 Channel5", "GPIO_Group3", "GPIO_Group2", "IR", "GPIO_Group1",
;;;489            "GPIO_Group0", "UART2", "TIM4", "TIM5", "TIM6", "TIM7", "SPI_Flash", "Qdecode",
;;;490            "Keyscan", "SPI2W", "LPCOMP", "PTA_Mailbox", "SPORT1 TX", "SPORT1 RX", "LCD"
;;;491        };
;;;492    
;;;493        IRQ_Fun *pRamVector    = (IRQ_Fun *)VTOR_RAM_ADDR;
        0x00208102:    f44f1000    O...    MOV      r0,#0x200000
        0x00208106:    4d21        !M      LDR      r5,[pc,#132] ; [0x20818c] = 0x811108
        0x00208108:    4f21        !O      LDR      r7,[pc,#132] ; [0x208190] = 0xf4
        0x0020810a:    6809        .h      LDR      r1,[r1,#0]
        0x0020810c:    4606        .F      MOV      r6,r0
;;;494        IRQ_Fun *pAppVector    = (IRQ_Fun *)&Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;495        uint32_t AppVectorSize = (uint32_t)&Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;496        uint32_t i             = 0;
        0x0020810e:    2400        .$      MOVS     r4,#0
;;;497    
;;;498        if (SCB->VTOR != VTOR_RAM_ADDR)
        0x00208110:    42b1        .B      CMP      r1,r6
        0x00208112:    d001        ..      BEQ      0x208118 ; AppUpdateVectorTable + 52
;;;499        {
;;;500            RamVectorTableInit(VTOR_RAM_ADDR);
        0x00208114:    f5fcfdc8    ....    BL       RamVectorTableInit ; 0x4ca8
        0x00208118:    f04f5805    O..X    MOV      r8,#0x21400000
        0x0020811c:    f8df9078    ..x.    LDR      r9,[pc,#120] ; [0x208198] = 0x21100101
;;;501        }
;;;502    
;;;503        /* Update APP defined handlers */
;;;504        for (i = 0; i < AppVectorSize / 4; ++i)
        0x00208120:    e027        '.      B        0x208172 ; AppUpdateVectorTable + 142
;;;505        {
;;;506            if (i == 1) //skip reset_handler remap
        0x00208122:    2c01        .,      CMP      r4,#1
        0x00208124:    d024        $.      BEQ      0x208170 ; AppUpdateVectorTable + 140
;;;507            {
;;;508                continue;
;;;509            }
;;;510    
;;;511            if ((pAppVector[i] != Default_Handler) && (pAppVector[i] != 0))
        0x00208126:    f8550024    U.$.    LDR      r0,[r5,r4,LSL #2]
        0x0020812a:    491c        .I      LDR      r1,[pc,#112] ; [0x20819c] = 0x80e62d
        0x0020812c:    4288        .B      CMP      r0,r1
        0x0020812e:    d01f        ..      BEQ      0x208170 ; AppUpdateVectorTable + 140
        0x00208130:    b1f0        ..      CBZ      r0,0x208170 ; AppUpdateVectorTable + 140
;;;512            {
;;;513                if (i < System_VECTORn)
        0x00208132:    2c10        .,      CMP      r4,#0x10
        0x00208134:    d209        ..      BCS      0x20814a ; AppUpdateVectorTable + 102
;;;514                {
;;;515                    OS_PRINT_WARN1("Warning! %s is updated by APP!", TRACE_STRING(SysException[i]));
        0x00208136:    a82d        -.      ADD      r0,sp,#0xb4
        0x00208138:    f8501024    P.$.    LDR      r1,[r0,r4,LSL #2]
        0x0020813c:    4640        @F      MOV      r0,r8
        0x0020813e:    f5fffe94    ....    BL       trace_string ; 0x7e6a
        0x00208142:    4603        .F      MOV      r3,r0
        0x00208144:    2201        ."      MOVS     r2,#1
        0x00208146:    4916        .I      LDR      r1,[pc,#88] ; [0x2081a0] = 0x8800020
        0x00208148:    e00b        ..      B        0x208162 ; AppUpdateVectorTable + 126
;;;516                }
;;;517                else
;;;518                {
;;;519                    OS_PRINT_WARN1("Warning! ISR %s is updated by APP!",
        0x0020814a:    4668        hF      MOV      r0,sp
        0x0020814c:    eb000084    ....    ADD      r0,r0,r4,LSL #2
        0x00208150:    f8501c40    P.@.    LDR      r1,[r0,#-0x40]
        0x00208154:    4640        @F      MOV      r0,r8
        0x00208156:    f5fffe88    ....    BL       trace_string ; 0x7e6a
        0x0020815a:    4911        .I      LDR      r1,[pc,#68] ; [0x2081a0] = 0x8800020
        0x0020815c:    2201        ."      MOVS     r2,#1
        0x0020815e:    4603        .F      MOV      r3,r0
        0x00208160:    3124        $1      ADDS     r1,r1,#0x24
        0x00208162:    4648        HF      MOV      r0,r9
        0x00208164:    f5fffc7b    ..{.    BL       log_buffer ; 0x7a5e
;;;520                                   TRACE_STRING(ExtIrq[i - System_VECTORn]));
;;;521                }
;;;522    
;;;523                pRamVector[i] = pAppVector[i];
        0x00208168:    f8550024    U.$.    LDR      r0,[r5,r4,LSL #2]
        0x0020816c:    f8460024    F.$.    STR      r0,[r6,r4,LSL #2]
        0x00208170:    1c64        d.      ADDS     r4,r4,#1
        0x00208172:    ebb40f97    ....    CMP      r4,r7,LSR #2
        0x00208176:    d3d4        ..      BCC      0x208122 ; AppUpdateVectorTable + 62
;;;524            }
;;;525        }
;;;526    
;;;527        __DMB();
        0x00208178:    f3bf8f5f    .._.    DMB      
;;;528        __DSB();
        0x0020817c:    f3bf8f4f    ..O.    DSB      
;;;529    }
        0x00208180:    b03d        =.      ADD      sp,sp,#0xf4
        0x00208182:    e8bd83f0    ....    POP      {r4-r9,pc}
    $d
        0x00208186:    0000        ..      DCW    0
        0x00208188:    008108c8    ....    DCD    8456392
        0x0020818c:    00811108    ....    DCD    8458504
        0x00208190:    000000f4    ....    DCD    244
        0x00208194:    e000ed08    ....    DCD    3758157064
        0x00208198:    21100101    ...!    DCD    554696961
        0x0020819c:    0080e62d    -...    DCD    8447533
        0x002081a0:    08800020     ...    DCD    142606368

** Section #9 'App.trace' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 4228 bytes (alignment 4)
    Address: 0x08800000

    0x8800000:   21 21 21 53 44 4b 20 56 65 72 3a 20 25 73 2c 20    !!!SDK Ver: %s, 
    0x8800010:   42 75 69 6c 64 20 54 69 6d 65 3a 20 25 73 00 00    Build Time: %s..
    0x8800020:   21 21 2a 57 61 72 6e 69 6e 67 21 20 25 73 20 69    !!*Warning! %s i
    0x8800030:   73 20 75 70 64 61 74 65 64 20 62 79 20 41 50 50    s updated by APP
    0x8800040:   21 00 00 00 21 21 2a 57 61 72 6e 69 6e 67 21 20    !...!!*Warning! 
    0x8800050:   49 53 52 20 25 73 20 69 73 20 75 70 64 61 74 65    ISR %s is update
    0x8800060:   64 20 62 79 20 41 50 50 21 00 00 00 21 21 2a 6d    d by APP!...!!*m
    0x8800070:   69 73 73 20 69 6e 74 65 72 72 75 70 74 3a 20 70    iss interrupt: p
    0x8800080:   65 6e 64 69 6e 67 20 72 65 67 69 73 74 65 72 3a    ending register:
    0x8800090:   20 30 78 25 78 00 00 00 21 21 21 69 61 73 5f 61     0x%x...!!!ias_a
    0x88000a0:   74 74 72 5f 77 72 69 74 65 5f 63 62 3a 20 70 5f    ttr_write_cb: p_
    0x88000b0:   76 61 6c 75 65 20 25 70 20 6c 65 6e 67 74 68 3d    value %p length=
    0x88000c0:   20 30 78 25 78 00 00 00 21 21 21 69 61 73 5f 61     0x%x...!!!ias_a
    0x88000d0:   64 64 5f 73 65 72 76 69 63 65 3a 20 73 65 72 76    dd_service: serv
    0x88000e0:   69 63 65 5f 69 64 20 25 64 00 00 00 21 21 21 6c    ice_id %d...!!!l
    0x88000f0:   6c 73 5f 73 65 74 5f 70 61 72 61 6d 65 74 65 72    ls_set_parameter
    0x8800100:   3a 20 6c 6c 73 20 61 6c 65 72 74 20 6c 65 76 65    : lls alert leve
    0x8800110:   6c 20 70 61 72 61 6d 65 74 65 72 20 73 65 74 20    l parameter set 
    0x8800120:   66 61 69 6c 65 64 00 00 21 21 21 6c 6c 73 5f 61    failed..!!!lls_a
    0x8800130:   74 74 72 5f 72 65 61 64 5f 63 62 20 64 65 66 61    ttr_read_cb defa
    0x8800140:   75 6c 74 3a 61 74 74 72 69 62 5f 69 6e 64 65 78    ult:attrib_index
    0x8800150:   20 25 64 00 21 2a 2a 6c 6c 73 5f 61 74 74 72 5f     %d.!**lls_attr_
    0x8800160:   72 65 61 64 5f 63 62 3a 20 61 74 74 72 69 62 5f    read_cb: attrib_
    0x8800170:   69 6e 64 65 78 20 25 64 2c 20 6c 65 6e 67 74 68    index %d, length
    0x8800180:   20 25 64 00 21 21 21 6c 6c 73 5f 61 74 74 72 5f     %d.!!!lls_attr_
    0x8800190:   77 72 69 74 65 5f 63 62 3a 20 70 5f 76 61 6c 75    write_cb: p_valu
    0x88001a0:   65 20 25 70 2c 20 6c 65 6e 67 74 68 20 30 78 25    e %p, length 0x%
    0x88001b0:   78 00 00 00 21 21 21 6c 6c 73 5f 61 64 64 5f 73    x...!!!lls_add_s
    0x88001c0:   65 72 76 69 63 65 3a 20 73 65 72 76 69 63 65 5f    ervice: service_
    0x88001d0:   69 64 20 25 64 00 00 00 21 21 21 74 70 73 5f 73    id %d...!!!tps_s
    0x88001e0:   65 74 5f 70 61 72 61 6d 65 74 65 72 3a 20 54 50    et_parameter: TP
    0x88001f0:   53 20 70 61 72 61 6d 65 74 65 72 20 73 65 74 20    S parameter set 
    0x8800200:   66 61 69 6c 65 64 00 00 21 21 21 74 70 73 5f 61    failed..!!!tps_a
    0x8800210:   74 74 72 5f 72 65 61 64 5f 63 62 3a 20 61 74 74    ttr_read_cb: att
    0x8800220:   72 69 62 5f 69 6e 64 65 78 20 25 64 00 00 00 00    rib_index %d....
    0x8800230:   21 2a 2a 74 70 73 5f 61 74 74 72 5f 72 65 61 64    !**tps_attr_read
    0x8800240:   5f 63 62 3a 20 61 74 74 72 69 62 5f 69 6e 64 65    _cb: attrib_inde
    0x8800250:   78 20 25 64 2c 20 2a 6c 65 6e 67 74 68 5f 70 74    x %d, *length_pt
    0x8800260:   72 20 25 64 00 00 00 00 21 21 21 74 70 73 5f 61    r %d....!!!tps_a
    0x8800270:   64 64 5f 73 65 72 76 69 63 65 3a 20 73 65 72 76    dd_service: serv
    0x8800280:   69 63 65 5f 69 64 20 25 64 00 00 00 21 21 21 62    ice_id %d...!!!b
    0x8800290:   61 73 5f 73 65 74 5f 70 61 72 61 6d 65 74 65 72    as_set_parameter
    0x88002a0:   20 66 61 69 6c 65 64 00 21 2a 2a 62 61 73 5f 61     failed.!**bas_a
    0x88002b0:   74 74 72 5f 72 65 61 64 5f 63 62 20 61 74 74 72    ttr_read_cb attr
    0x88002c0:   69 62 5f 69 6e 64 65 78 20 3d 20 25 64 20 6f 66    ib_index = %d of
    0x88002d0:   66 73 65 74 20 25 78 00 21 21 21 62 61 73 5f 61    fset %x.!!!bas_a
    0x88002e0:   74 74 72 5f 72 65 61 64 5f 63 62 20 61 74 74 72    ttr_read_cb attr
    0x88002f0:   69 62 5f 69 6e 64 65 78 20 3d 20 25 64 20 6e 6f    ib_index = %d no
    0x8800300:   74 20 66 6f 75 6e 64 00 21 2a 2a 62 61 73 5f 63    t found.!**bas_c
    0x8800310:   63 63 64 5f 75 70 64 61 74 65 5f 63 62 20 69 6e    ccd_update_cb in
    0x8800320:   64 65 78 20 3d 20 25 64 20 63 63 63 5f 62 69 74    dex = %d ccc_bit
    0x8800330:   73 20 25 78 00 00 00 00 21 21 21 62 61 73 5f 61    s %x....!!!bas_a
    0x8800340:   64 64 5f 73 65 72 76 69 63 65 3a 20 73 65 72 76    dd_service: serv
    0x8800350:   69 63 65 5f 69 64 20 25 64 00 00 00 21 21 21 62    ice_id %d...!!!b
    0x8800360:   61 73 5f 73 65 74 5f 70 61 72 61 6d 65 74 65 72    as_set_parameter
    0x8800370:   20 66 61 69 6c 65 64 00 21 21 21 6b 6e 73 5f 61     failed.!!!kns_a
    0x8800380:   74 74 72 5f 72 65 61 64 5f 63 62 20 61 74 74 72    ttr_read_cb attr
    0x8800390:   69 62 5f 69 6e 64 65 78 20 3d 20 25 64 20 6e 6f    ib_index = %d no
    0x88003a0:   74 20 66 6f 75 6e 64 00 21 2a 2a 3c 2d 2d 20 67    t found.!**<-- g
    0x88003b0:   61 74 74 20 67 65 74 20 50 78 70 45 78 74 65 6e    att get PxpExten
    0x88003c0:   64 65 64 20 61 74 74 72 69 62 75 74 65 20 76 61    ded attribute va
    0x88003d0:   6c 75 65 3a 20 41 74 74 72 69 62 49 6e 64 65 78    lue: AttribIndex
    0x88003e0:   2d 2d 25 64 2c 20 6c 65 6e 67 74 68 2d 2d 25 64    --%d, length--%d
    0x88003f0:   00 00 00 00 21 21 21 6b 6e 73 5f 61 74 74 72 5f    ....!!!kns_attr_
    0x8800400:   77 72 69 74 65 5f 63 62 3a 20 70 5f 76 61 6c 75    write_cb: p_valu
    0x8800410:   65 20 25 70 2c 20 6c 65 6e 67 74 68 20 30 78 25    e %p, length 0x%
    0x8800420:   78 00 00 00 21 2a 2a 6b 6e 73 5f 63 63 63 64 5f    x...!**kns_cccd_
    0x8800430:   75 70 64 61 74 65 5f 63 62 20 69 6e 64 65 78 20    update_cb index 
    0x8800440:   3d 20 25 64 20 63 63 63 5f 62 69 74 73 20 25 78    = %d ccc_bits %x
    0x8800450:   00 00 00 00 21 21 21 6b 6e 73 5f 61 64 64 5f 73    ....!!!kns_add_s
    0x8800460:   65 72 76 69 63 65 3a 20 73 65 72 76 69 63 65 5f    ervice: service_
    0x8800470:   69 64 20 25 64 00 00 00 21 21 21 44 49 53 20 70    id %d...!!!DIS p
    0x8800480:   61 72 61 6d 65 74 65 72 20 73 65 74 20 66 61 69    arameter set fai
    0x8800490:   6c 65 64 00 21 21 21 64 69 73 5f 61 74 74 72 5f    led.!!!dis_attr_
    0x88004a0:   72 65 61 64 5f 63 62 3a 20 61 74 74 72 69 62 5f    read_cb: attrib_
    0x88004b0:   69 6e 64 65 78 20 25 64 00 00 00 00 21 2a 2a 64    index %d....!**d
    0x88004c0:   69 73 5f 61 74 74 72 5f 72 65 61 64 5f 63 62 3a    is_attr_read_cb:
    0x88004d0:   20 61 74 74 72 69 62 5f 69 6e 64 65 78 20 25 64     attrib_index %d
    0x88004e0:   2c 20 2a 6c 65 6e 67 74 68 5f 70 74 72 20 25 64    , *length_ptr %d
    0x88004f0:   00 00 00 00 21 21 21 64 69 73 5f 61 64 64 5f 73    ....!!!dis_add_s
    0x8800500:   65 72 76 69 63 65 3a 20 73 65 72 76 69 63 65 5f    ervice: service_
    0x8800510:   69 64 20 25 64 00 00 00 21 21 21 73 65 6e 64 5f    id %d...!!!send_
    0x8800520:   69 6f 5f 6d 73 67 5f 74 6f 5f 61 70 70 20 66 61    io_msg_to_app fa
    0x8800530:   69 6c 00 00 21 21 21 73 65 6e 64 5f 65 76 74 5f    il..!!!send_evt_
    0x8800540:   6d 73 67 5f 74 6f 5f 61 70 70 20 66 61 69 6c 00    msg_to_app fail.
    0x8800550:   21 21 21 45 6e 74 65 72 20 47 50 49 4f 35 5f 48    !!!Enter GPIO5_H
    0x8800560:   61 6e 64 6c 65 72 21 00 21 21 21 4d 53 47 5f 53    andler!.!!!MSG_S
    0x8800570:   48 4f 52 54 5f 50 52 45 53 53 00 00 21 21 21 45    HORT_PRESS..!!!E
    0x8800580:   52 52 4f 52 20 49 4f 20 53 54 41 54 55 53 00 00    RROR IO STATUS..
    0x8800590:   21 21 21 4d 53 47 5f 4c 4f 4e 47 5f 50 52 45 53    !!!MSG_LONG_PRES
    0x88005a0:   53 00 00 00 21 21 21 45 52 52 4f 52 20 50 4f 57    S...!!!ERROR POW
    0x88005b0:   45 52 20 53 54 41 54 55 53 00 00 00 21 21 21 45    ER STATUS...!!!E
    0x88005c0:   52 52 4f 52 20 50 4f 57 45 52 20 53 54 41 54 55    RROR POWER STATU
    0x88005d0:   53 00 00 00 21 21 21 45 52 52 4f 52 20 50 4f 57    S...!!!ERROR POW
    0x88005e0:   45 52 20 53 54 41 54 55 53 00 00 00 21 21 21 45    ER STATUS...!!!E
    0x88005f0:   52 52 4f 52 20 49 4f 20 4d 4f 44 45 00 00 00 00    RROR IO MODE....
    0x8800600:   21 2a 2a 78 54 69 6d 65 72 50 78 70 49 4f 20 6f    !**xTimerPxpIO o
    0x8800610:   73 5f 74 69 6d 65 72 5f 72 65 73 74 61 72 74 2e    s_timer_restart.
    0x8800620:   00 00 00 00 21 2a 2a 78 54 69 6d 65 72 41 6c 65    ....!**xTimerAle
    0x8800630:   72 74 20 72 65 74 76 61 6c 20 69 73 20 25 64 00    rt retval is %d.
    0x8800640:   21 2a 2a 78 54 69 6d 65 72 4c 6f 6e 67 50 72 65    !**xTimerLongPre
    0x8800650:   73 73 20 72 65 74 76 61 6c 20 69 73 20 25 64 00    ss retval is %d.
    0x8800660:   21 2a 2a 53 79 73 74 65 6d 5f 48 61 6e 64 6c 65    !**System_Handle
    0x8800670:   72 00 00 00 21 2a 2a 5b 57 44 47 5d 20 57 61 74    r...!**[WDG] Wat
    0x8800680:   63 68 20 44 6f 67 20 52 73 65 74 20 54 69 6d 65    ch Dog Rset Time
    0x8800690:   72 00 00 00 21 2a 2a 61 70 70 5f 68 61 6e 64 6c    r...!**app_handl
    0x88006a0:   65 5f 64 65 76 5f 73 74 61 74 65 5f 65 76 74 3a    e_dev_state_evt:
    0x88006b0:   20 69 6e 69 74 20 73 74 61 74 65 20 25 64 2c 20     init state %d, 
    0x88006c0:   61 64 76 20 73 74 61 74 65 20 25 64 2c 20 63 61    adv state %d, ca
    0x88006d0:   75 73 65 20 30 78 25 78 00 00 00 00 21 2a 2a 47    use 0x%x....!**G
    0x88006e0:   41 50 20 73 74 61 63 6b 20 72 65 61 64 79 00 00    AP stack ready..
    0x88006f0:   21 2a 2a 47 41 50 20 61 64 76 20 73 74 6f 70 65    !**GAP adv stope
    0x8800700:   64 3a 20 62 65 63 61 75 73 65 20 63 6f 6e 6e 65    d: because conne
    0x8800710:   63 74 69 6f 6e 20 63 72 65 61 74 65 64 00 00 00    ction created...
    0x8800720:   21 2a 2a 47 41 50 20 61 64 76 20 73 74 6f 70 65    !**GAP adv stope
    0x8800730:   64 00 00 00 21 2a 2a 47 41 50 20 61 64 76 20 73    d...!**GAP adv s
    0x8800740:   74 61 72 74 00 00 00 00 21 2a 2a 61 70 70 5f 68    tart....!**app_h
    0x8800750:   61 6e 64 6c 65 5f 63 6f 6e 6e 5f 73 74 61 74 65    andle_conn_state
    0x8800760:   5f 65 76 74 3a 20 63 6f 6e 6e 5f 69 64 20 25 64    _evt: conn_id %d
    0x8800770:   20 6f 6c 64 5f 73 74 61 74 65 20 25 64 20 6e 65     old_state %d ne
    0x8800780:   77 5f 73 74 61 74 65 20 25 64 2c 20 64 69 73 63    w_state %d, disc
    0x8800790:   5f 63 61 75 73 65 20 30 78 25 78 00 21 21 21 61    _cause 0x%x.!!!a
    0x88007a0:   70 70 5f 68 61 6e 64 6c 65 5f 63 6f 6e 6e 5f 73    pp_handle_conn_s
    0x88007b0:   74 61 74 65 5f 65 76 74 3a 20 63 6f 6e 6e 65 63    tate_evt: connec
    0x88007c0:   74 69 6f 6e 20 6c 6f 73 74 20 63 61 75 73 65 20    tion lost cause 
    0x88007d0:   30 78 25 78 00 00 00 00 21 21 21 67 5f 70 78 70    0x%x....!!!g_pxp
    0x88007e0:   5f 6c 69 6e 6b 6c 6f 73 73 5f 61 6c 65 72 74 5f    _linkloss_alert_
    0x88007f0:   6c 65 76 65 6c 20 69 73 20 25 64 00 21 2a 2a 47    level is %d.!**G
    0x8800800:   41 50 5f 43 4f 4e 4e 5f 53 54 41 54 45 5f 43 4f    AP_CONN_STATE_CO
    0x8800810:   4e 4e 45 43 54 45 44 3a 72 65 6d 6f 74 65 5f 62    NNECTED:remote_b
    0x8800820:   64 20 25 73 2c 20 72 65 6d 6f 74 65 5f 61 64 64    d %s, remote_add
    0x8800830:   72 5f 74 79 70 65 20 25 64 2c 20 63 6f 6e 6e 5f    r_type %d, conn_
    0x8800840:   69 6e 74 65 72 76 61 6c 20 30 78 25 78 2c 20 63    interval 0x%x, c
    0x8800850:   6f 6e 6e 5f 6c 61 74 65 6e 63 79 20 30 78 25 78    onn_latency 0x%x
    0x8800860:   2c 20 63 6f 6e 6e 5f 73 75 70 65 72 76 69 73 69    , conn_supervisi
    0x8800870:   6f 6e 5f 74 69 6d 65 6f 75 74 20 30 78 25 78 00    on_timeout 0x%x.
    0x8800880:   21 2a 2a 61 70 70 5f 68 61 6e 64 6c 65 5f 61 75    !**app_handle_au
    0x8800890:   74 68 65 6e 5f 73 74 61 74 65 5f 65 76 74 3a 63    then_state_evt:c
    0x88008a0:   6f 6e 6e 5f 69 64 20 25 64 2c 20 63 61 75 73 65    onn_id %d, cause
    0x88008b0:   20 30 78 25 78 00 00 00 21 2a 2a 61 70 70 5f 68     0x%x...!**app_h
    0x88008c0:   61 6e 64 6c 65 5f 61 75 74 68 65 6e 5f 73 74 61    andle_authen_sta
    0x88008d0:   74 65 5f 65 76 74 3a 20 47 41 50 5f 41 55 54 48    te_evt: GAP_AUTH
    0x88008e0:   45 4e 5f 53 54 41 54 45 5f 53 54 41 52 54 45 44    EN_STATE_STARTED
    0x88008f0:   00 00 00 00 21 2a 2a 61 70 70 5f 68 61 6e 64 6c    ....!**app_handl
    0x8800900:   65 5f 61 75 74 68 65 6e 5f 73 74 61 74 65 5f 65    e_authen_state_e
    0x8800910:   76 74 3a 20 47 41 50 5f 41 55 54 48 45 4e 5f 53    vt: GAP_AUTHEN_S
    0x8800920:   54 41 54 45 5f 43 4f 4d 50 4c 45 54 45 20 70 61    TATE_COMPLETE pa
    0x8800930:   69 72 20 73 75 63 63 65 73 73 00 00 21 2a 2a 61    ir success..!**a
    0x8800940:   70 70 5f 68 61 6e 64 6c 65 5f 61 75 74 68 65 6e    pp_handle_authen
    0x8800950:   5f 73 74 61 74 65 5f 65 76 74 3a 20 47 41 50 5f    _state_evt: GAP_
    0x8800960:   41 55 54 48 45 4e 5f 53 54 41 54 45 5f 43 4f 4d    AUTHEN_STATE_COM
    0x8800970:   50 4c 45 54 45 20 70 61 69 72 20 66 61 69 6c 65    PLETE pair faile
    0x8800980:   64 00 00 00 21 21 21 61 70 70 5f 68 61 6e 64 6c    d...!!!app_handl
    0x8800990:   65 5f 61 75 74 68 65 6e 5f 73 74 61 74 65 5f 65    e_authen_state_e
    0x88009a0:   76 74 3a 20 75 6e 6b 6e 6f 77 6e 20 6e 65 77 73    vt: unknown news
    0x88009b0:   74 61 74 65 20 25 64 00 21 2a 2a 61 70 70 5f 68    tate %d.!**app_h
    0x88009c0:   61 6e 64 6c 65 5f 63 6f 6e 6e 5f 6d 74 75 5f 69    andle_conn_mtu_i
    0x88009d0:   6e 66 6f 5f 65 76 74 3a 20 63 6f 6e 6e 5f 69 64    nfo_evt: conn_id
    0x88009e0:   20 25 64 2c 20 6d 74 75 5f 73 69 7a 65 20 25 64     %d, mtu_size %d
    0x88009f0:   00 00 00 00 21 2a 2a 61 70 70 5f 68 61 6e 64 6c    ....!**app_handl
    0x8800a00:   65 5f 63 6f 6e 6e 5f 70 61 72 61 6d 5f 75 70 64    e_conn_param_upd
    0x8800a10:   61 74 65 5f 65 76 74 20 75 70 64 61 74 65 20 73    ate_evt update s
    0x8800a20:   75 63 63 65 73 73 3a 63 6f 6e 6e 5f 69 6e 74 65    uccess:conn_inte
    0x8800a30:   72 76 61 6c 20 30 78 25 78 2c 20 63 6f 6e 6e 5f    rval 0x%x, conn_
    0x8800a40:   73 6c 61 76 65 5f 6c 61 74 65 6e 63 79 20 30 78    slave_latency 0x
    0x8800a50:   25 78 2c 20 63 6f 6e 6e 5f 73 75 70 65 72 76 69    %x, conn_supervi
    0x8800a60:   73 69 6f 6e 5f 74 69 6d 65 6f 75 74 20 30 78 25    sion_timeout 0x%
    0x8800a70:   78 00 00 00 21 21 21 61 70 70 5f 68 61 6e 64 6c    x...!!!app_handl
    0x8800a80:   65 5f 63 6f 6e 6e 5f 70 61 72 61 6d 5f 75 70 64    e_conn_param_upd
    0x8800a90:   61 74 65 5f 65 76 74 20 75 70 64 61 74 65 20 66    ate_evt update f
    0x8800aa0:   61 69 6c 65 64 3a 20 63 61 75 73 65 20 30 78 25    ailed: cause 0x%
    0x8800ab0:   78 00 00 00 21 2a 2a 61 70 70 5f 68 61 6e 64 6c    x...!**app_handl
    0x8800ac0:   65 5f 63 6f 6e 6e 5f 70 61 72 61 6d 5f 75 70 64    e_conn_param_upd
    0x8800ad0:   61 74 65 5f 65 76 74 20 75 70 64 61 74 65 20 70    ate_evt update p
    0x8800ae0:   65 6e 64 69 6e 67 2e 00 61 70 70 5f 68 61 6e 64    ending..app_hand
    0x8800af0:   6c 65 5f 67 61 70 5f 6d 73 67 3a 20 73 75 62 74    le_gap_msg: subt
    0x8800b00:   79 70 65 20 25 64 00 00 21 2a 2a 47 41 50 5f 4d    ype %d..!**GAP_M
    0x8800b10:   53 47 5f 4c 45 5f 42 4f 4e 44 5f 4a 55 53 54 5f    SG_LE_BOND_JUST_
    0x8800b20:   57 4f 52 4b 00 00 00 00 21 2a 2a 47 41 50 5f 4d    WORK....!**GAP_M
    0x8800b30:   53 47 5f 4c 45 5f 42 4f 4e 44 5f 50 41 53 53 4b    SG_LE_BOND_PASSK
    0x8800b40:   45 59 5f 44 49 53 50 4c 41 59 3a 70 61 73 73 6b    EY_DISPLAY:passk
    0x8800b50:   65 79 20 25 64 00 00 00 21 2a 2a 47 41 50 5f 4d    ey %d...!**GAP_M
    0x8800b60:   53 47 5f 4c 45 5f 42 4f 4e 44 5f 55 53 45 52 5f    SG_LE_BOND_USER_
    0x8800b70:   43 4f 4e 46 49 52 4d 41 54 49 4f 4e 3a 20 70 61    CONFIRMATION: pa
    0x8800b80:   73 73 6b 65 79 20 25 64 00 00 00 00 21 2a 2a 47    sskey %d....!**G
    0x8800b90:   41 50 5f 4d 53 47 5f 4c 45 5f 42 4f 4e 44 5f 50    AP_MSG_LE_BOND_P
    0x8800ba0:   41 53 53 4b 45 59 5f 49 4e 50 55 54 3a 20 63 6f    ASSKEY_INPUT: co
    0x8800bb0:   6e 6e 5f 69 64 20 25 64 00 00 00 00 21 2a 2a 47    nn_id %d....!**G
    0x8800bc0:   41 50 5f 4d 53 47 5f 4c 45 5f 42 4f 4e 44 5f 4f    AP_MSG_LE_BOND_O
    0x8800bd0:   4f 42 5f 49 4e 50 55 54 00 00 00 00 21 21 21 61    OB_INPUT....!!!a
    0x8800be0:   70 70 5f 68 61 6e 64 6c 65 5f 67 61 70 5f 6d 73    pp_handle_gap_ms
    0x8800bf0:   67 3a 20 75 6e 6b 6e 6f 77 6e 20 73 75 62 74 79    g: unknown subty
    0x8800c00:   70 65 20 25 64 00 00 00 21 2a 2a 47 41 50 5f 4d    pe %d...!**GAP_M
    0x8800c10:   53 47 5f 4c 45 5f 44 41 54 41 5f 4c 45 4e 5f 43    SG_LE_DATA_LEN_C
    0x8800c20:   48 41 4e 47 45 5f 49 4e 46 4f 3a 20 63 6f 6e 6e    HANGE_INFO: conn
    0x8800c30:   5f 69 64 20 25 64 2c 20 74 78 20 6f 63 74 65 74    _id %d, tx octet
    0x8800c40:   73 20 30 78 25 78 2c 20 6d 61 78 5f 74 78 5f 74    s 0x%x, max_tx_t
    0x8800c50:   69 6d 65 20 30 78 25 78 00 00 00 00 21 2a 2a 47    ime 0x%x....!**G
    0x8800c60:   41 50 5f 4d 53 47 5f 4c 45 5f 4d 4f 44 49 46 59    AP_MSG_LE_MODIFY
    0x8800c70:   5f 57 48 49 54 45 5f 4c 49 53 54 3a 20 6f 70 65    _WHITE_LIST: ope
    0x8800c80:   72 61 74 69 6f 6e 20 25 64 2c 20 63 61 75 73 65    ration %d, cause
    0x8800c90:   20 30 78 25 78 00 00 00 21 21 21 61 70 70 5f 67     0x%x...!!!app_g
    0x8800ca0:   61 70 5f 63 61 6c 6c 62 61 63 6b 3a 20 75 6e 68    ap_callback: unh
    0x8800cb0:   61 6e 64 6c 65 64 20 63 62 5f 74 79 70 65 20 30    andled cb_type 0
    0x8800cc0:   78 25 78 00 21 2a 2a 50 52 4f 46 49 4c 45 5f 45    x%x.!**PROFILE_E
    0x8800cd0:   56 54 5f 53 52 56 5f 52 45 47 5f 43 4f 4d 50 4c    VT_SRV_REG_COMPL
    0x8800ce0:   45 54 45 3a 20 72 65 73 75 6c 74 20 25 64 00 00    ETE: result %d..
    0x8800cf0:   21 2a 2a 50 52 4f 46 49 4c 45 5f 45 56 54 5f 53    !**PROFILE_EVT_S
    0x8800d00:   45 4e 44 5f 44 41 54 41 5f 43 4f 4d 50 4c 45 54    END_DATA_COMPLET
    0x8800d10:   45 3a 20 63 6f 6e 6e 5f 69 64 20 25 64 2c 20 63    E: conn_id %d, c
    0x8800d20:   61 75 73 65 20 30 78 25 78 2c 20 73 65 72 76 69    ause 0x%x, servi
    0x8800d30:   63 65 5f 69 64 20 25 64 2c 20 61 74 74 72 69 62    ce_id %d, attrib
    0x8800d40:   5f 69 64 78 20 30 78 25 78 2c 20 63 72 65 64 69    _idx 0x%x, credi
    0x8800d50:   74 73 20 25 64 00 00 00 21 2a 2a 50 52 4f 46 49    ts %d...!**PROFI
    0x8800d60:   4c 45 5f 45 56 54 5f 53 45 4e 44 5f 44 41 54 41    LE_EVT_SEND_DATA
    0x8800d70:   5f 43 4f 4d 50 4c 45 54 45 20 73 75 63 63 65 73    _COMPLETE succes
    0x8800d80:   73 00 00 00 21 21 21 50 52 4f 46 49 4c 45 5f 45    s...!!!PROFILE_E
    0x8800d90:   56 54 5f 53 45 4e 44 5f 44 41 54 41 5f 43 4f 4d    VT_SEND_DATA_COM
    0x8800da0:   50 4c 45 54 45 20 66 61 69 6c 65 64 00 00 00 00    PLETE failed....
    0x8800db0:   21 21 21 49 41 53 20 43 61 6c 6c 42 61 63 6b 2e    !!!IAS CallBack.
    0x8800dc0:   00 00 00 00 21 2a 2a 4b 4e 53 5f 4e 4f 54 49 46    ....!**KNS_NOTIF
    0x8800dd0:   59 5f 45 4e 41 42 4c 45 00 00 00 00 21 2a 2a 4b    Y_ENABLE....!**K
    0x8800de0:   4e 53 5f 4e 4f 54 49 46 59 5f 44 49 53 41 42 4c    NS_NOTIFY_DISABL
    0x8800df0:   45 00 00 00 21 2a 2a 4b 4e 53 5f 52 45 41 44 5f    E...!**KNS_READ_
    0x8800e00:   50 41 52 41 00 00 00 00 21 2a 2a 4b 4e 53 5f 57    PARA....!**KNS_W
    0x8800e10:   52 49 54 45 5f 50 41 52 41 20 25 78 00 00 00 00    RITE_PARA %x....
    0x8800e20:   21 2a 2a 42 41 53 5f 4e 4f 54 49 46 59 5f 42 41    !**BAS_NOTIFY_BA
    0x8800e30:   54 54 45 52 59 5f 4c 45 56 45 4c 5f 45 4e 41 42    TTERY_LEVEL_ENAB
    0x8800e40:   4c 45 00 00 21 2a 2a 42 41 53 5f 4e 4f 54 49 46    LE..!**BAS_NOTIF
    0x8800e50:   59 5f 42 41 54 54 45 52 59 5f 4c 45 56 45 4c 5f    Y_BATTERY_LEVEL_
    0x8800e60:   44 49 53 41 42 4c 45 00 21 2a 2a 42 41 53 5f 52    DISABLE.!**BAS_R
    0x8800e70:   45 41 44 5f 42 41 54 54 45 52 59 5f 4c 45 56 45    EAD_BATTERY_LEVE
    0x8800e80:   4c 3a 20 62 61 74 74 65 72 79 5f 6c 65 76 65 6c    L: battery_level
    0x8800e90:   20 25 64 00 21 21 21 67 61 70 5f 6c 69 62 5f 69     %d.!!!gap_lib_i
    0x8800ea0:   6e 69 74 3a 20 76 65 72 20 25 64 2c 20 46 5f 42    nit: ver %d, F_B
    0x8800eb0:   54 5f 4c 45 5f 35 5f 30 5f 53 55 50 50 4f 52 54    T_LE_5_0_SUPPORT
    0x8800ec0:   20 25 64 2c 20 46 5f 42 54 5f 4c 45 5f 35 5f 30     %d, F_BT_LE_5_0
    0x8800ed0:   5f 41 45 5f 41 44 56 5f 53 55 50 50 4f 52 54 20    _AE_ADV_SUPPORT 
    0x8800ee0:   25 64 2c 20 46 5f 42 54 5f 4c 45 5f 35 5f 30 5f    %d, F_BT_LE_5_0_
    0x8800ef0:   41 45 5f 53 43 41 4e 5f 53 55 50 50 4f 52 54 20    AE_SCAN_SUPPORT 
    0x8800f00:   25 64 2c 20 46 5f 42 54 5f 4c 45 5f 34 5f 31 5f    %d, F_BT_LE_4_1_
    0x8800f10:   53 55 50 50 4f 52 54 20 25 64 2c 20 46 5f 42 54    SUPPORT %d, F_BT
    0x8800f20:   5f 56 45 4e 44 4f 52 5f 46 45 41 54 55 52 45 5f    _VENDOR_FEATURE_
    0x8800f30:   53 55 50 50 4f 52 54 20 25 64 2c 20 46 5f 42 54    SUPPORT %d, F_BT
    0x8800f40:   5f 4c 45 5f 36 5f 30 5f 41 4f 41 5f 41 4f 44 5f    _LE_6_0_AOA_AOD_
    0x8800f50:   53 55 50 50 4f 52 54 20 25 64 2c 20 46 5f 42 54    SUPPORT %d, F_BT
    0x8800f60:   5f 4c 45 5f 36 5f 30 5f 41 4f 58 5f 43 4f 4e 4e    _LE_6_0_AOX_CONN
    0x8800f70:   4c 45 53 53 5f 53 55 50 50 4f 52 54 20 25 64 00    LESS_SUPPORT %d.
    0x8800f80:   21 21 21 67 61 70 5f 6c 69 62 5f 69 6e 69 74 3a    !!!gap_lib_init:
    0x8800f90:   20 46 5f 42 54 5f 4c 45 5f 53 4d 50 5f 53 43 5f     F_BT_LE_SMP_SC_
    0x8800fa0:   4f 4f 42 5f 53 55 50 50 4f 52 54 20 25 64 2c 20    OOB_SUPPORT %d, 
    0x8800fb0:   46 5f 42 54 5f 53 57 5f 52 45 53 45 54 5f 53 55    F_BT_SW_RESET_SU
    0x8800fc0:   50 50 4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 50    PPORT %d, F_BT_P
    0x8800fd0:   41 54 43 48 5f 46 4f 52 5f 43 48 41 4e 47 45 5f    ATCH_FOR_CHANGE_
    0x8800fe0:   41 50 49 20 25 64 2c 20 46 5f 42 54 5f 44 4c 50    API %d, F_BT_DLP
    0x8800ff0:   53 5f 41 50 49 20 25 64 00 00 00 00 21 2a 2a 6c    S_API %d....!**l
    0x8801000:   65 5f 63 68 65 63 6b 5f 70 72 69 76 61 63 79 5f    e_check_privacy_
    0x8801010:   62 6f 6e 64 3a 20 69 64 78 20 25 64 20 70 72 69    bond: idx %d pri
    0x8801020:   76 61 63 79 20 64 65 76 69 63 65 00 21 2a 2a 6c    vacy device.!**l
    0x8801030:   65 5f 63 68 65 63 6b 5f 70 72 69 76 61 63 79 5f    e_check_privacy_
    0x8801040:   62 6f 6e 64 3a 20 6e 6f 74 20 70 72 69 76 61 63    bond: not privac
    0x8801050:   79 20 64 65 76 69 63 65 2c 20 63 61 75 73 65 20    y device, cause 
    0x8801060:   25 64 00 00 21 2a 2a 6c 65 5f 62 6f 6e 64 5f 67    %d..!**le_bond_g
    0x8801070:   65 74 5f 73 65 63 5f 6c 65 76 65 6c 3a 20 25 64    et_sec_level: %d
    0x8801080:   00 00 00 00                                        ....


** Section #10 '.debug_abbrev' (SHT_PROGBITS)
    Size   : 1476 bytes


** Section #11 '.debug_frame' (SHT_PROGBITS)
    Size   : 3976 bytes


** Section #12 '.debug_info' (SHT_PROGBITS)
    Size   : 146152 bytes


** Section #13 '.debug_line' (SHT_PROGBITS)
    Size   : 23140 bytes


** Section #14 '.debug_loc' (SHT_PROGBITS)
    Size   : 9132 bytes


** Section #15 '.debug_macinfo' (SHT_PROGBITS)
    Size   : 118384 bytes


** Section #16 '.debug_pubnames' (SHT_PROGBITS)
    Size   : 5795 bytes


** Section #17 '.symtab' (SHT_SYMTAB)
    Size   : 19792 bytes (alignment 4)
    String table #18 '.strtab'
    Last local symbol no. 456


** Section #18 '.strtab' (SHT_STRTAB)
    Size   : 18344 bytes


** Section #19 '.note' (SHT_NOTE)
    Size   : 52 bytes (alignment 4)


** Section #20 '.comment' (SHT_PROGBITS)
    Size   : 23744 bytes


** Section #21 '.shstrtab' (SHT_STRTAB)
    Size   : 276 bytes


address     size       variable name                            type
0x00207ebc  0x6c       overlay_sections                         array[3] of T_OVERLAY_SECTION

address     size       variable name                            type
0x002080dc  0x8        scenario_name                            array[8] of char

address     size       variable name                            type
0x002080d9  0x1        bas_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x002080da  0x1        dis_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x002080d1  0x1        gIoState                                 IoState

address     size       variable name                            type
0x002080d2  0x1        gPowerFlg                                _Bool

address     size       variable name                            type
0x002080d0  0x1        gPxpState                                PxpState

address     size       variable name                            type
0x00207eb8  0x4        gTimeParaValue                           uint32_t

address     size       variable name                            type
0x002080db  0x1        g_pxp_immediate_alert_level              uint8_t

address     size       variable name                            type
0x00207eb4  0x1        g_pxp_linkloss_alert_level               uint8_t

address     size       variable name                            type
0x002080d4  0x1        gap_conn_state                           T_GAP_CONN_STATE

address     size       variable name                            type
0x002080d3  0x1        gap_dev_state                            T_GAP_DEV_STATE
0x002080d3  0x1(7:1)   gap_dev_state.gap_init_state             uint8_t
0x002080d3  0x1(6:1)   gap_dev_state.gap_adv_sub_state          uint8_t
0x002080d3  0x1(4:2)   gap_dev_state.gap_adv_state              uint8_t
0x002080d3  0x1(2:2)   gap_dev_state.gap_scan_state             uint8_t
0x002080d3  0x1(0:2)   gap_dev_state.gap_conn_state             uint8_t

address     size       variable name                            type
0x002080d5  0x1        ias_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x002080d8  0x1        kns_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x002080d6  0x1        lls_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x002080d7  0x1        tps_srv_id                               T_SERVER_ID

address     size       variable name                            type
0x00207e9d  0x15       adv_data                                 array[21] of uint8_t

address     size       variable name                            type
0x00207e8e  0x1        allowedPxpEnterDlps                      _Bool

address     size       variable name                            type
0x00207e8f  0xe        scan_rsp_data                            array[14] of uint8_t

address     size       variable name                            type
0x002080c4  0x4        gActCnt                                  uint32_t

address     size       variable name                            type
0x002080b8  0x1        gIoMode                                  uint8_t

address     size       variable name                            type
0x002080b9  0x1        gKeyStatus                               KeyStatus

address     size       variable name                            type
0x002080ba  0x1        keystatus                                uint8_t

address     size       variable name                            type
0x002080c0  0x4        xPeriodHigh                              uint32_t

address     size       variable name                            type
0x002080bc  0x4        xPeriodLow                               uint32_t

address     size       variable name                            type
0x002080cc  0x4        xTimerLongPress                          TimerHandle_t

address     size       variable name                            type
0x002080c8  0x4        xTimerPxpIO                              TimerHandle_t

address     size       variable name                            type
0x002080ac  0x4        app_task_handle                          pointer to unknown Type 

address     size       variable name                            type
0x002080b0  0x4        evt_queue_handle                         pointer to unknown Type 

address     size       variable name                            type
0x002080b4  0x4        io_queue_handle                          pointer to unknown Type 

address     size       variable name                            type
0x00810c1c  0x214      dis_attr_tbl                             array[19] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00000000  0x2        dis_attr_tbl_size                        const uint16_t

address     size       variable name                            type
0x00810e30  0xc        dis_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x00810e30  0x4        dis_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00810e34  0x4        dis_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00810e38  0x4        dis_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x00208084  0x14       dis_firmware_rev                         array[20] of uint8_t

address     size       variable name                            type
0x0020802c  0x1        dis_firmware_rev_len                     uint8_t

address     size       variable name                            type
0x00208070  0x14       dis_hardware_rev                         array[20] of uint8_t

address     size       variable name                            type
0x0020802b  0x1        dis_hardware_rev_len                     uint8_t

address     size       variable name                            type
0x00207e70  0x1e       dis_ieee_data_list                       array[30] of uint8_t

address     size       variable name                            type
0x00207e60  0x1        dis_ieee_data_list_len                   uint8_t

address     size       variable name                            type
0x00208034  0x14       dis_manufacturer_name                    array[20] of uint8_t

address     size       variable name                            type
0x00208028  0x1        dis_manufacturer_name_len                uint8_t

address     size       variable name                            type
0x00208048  0x14       dis_model_number                         array[20] of uint8_t

address     size       variable name                            type
0x00208029  0x1        dis_model_number_len                     uint8_t

address     size       variable name                            type
0x00207e61  0x7        dis_pnp_id                               array[7] of uint8_t

address     size       variable name                            type
0x0020805c  0x14       dis_serial_number                        array[20] of uint8_t

address     size       variable name                            type
0x0020802a  0x1        dis_serial_number_len                    uint8_t

address     size       variable name                            type
0x00208098  0x14       dis_software_rev                         array[20] of uint8_t

address     size       variable name                            type
0x0020802d  0x1        dis_software_rev_len                     uint8_t

address     size       variable name                            type
0x00207e68  0x8        dis_system_id                            array[8] of uint8_t

address     size       variable name                            type
0x00208030  0x4        pfn_dis_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x00810b58  0x10       GATT_UUID128_KNS_SERVICE                 array[16] of const uint8_t

address     size       variable name                            type
0x00207e5c  0x4        gParaValue                               uint32_t

address     size       variable name                            type
0x00810b68  0xa8       kns_attr_tbl                             array[6] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00000000  0x2        kns_attr_tbl_size                        const uint16_t

address     size       variable name                            type
0x00810c10  0xc        kns_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x00810c10  0x4        kns_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00810c14  0x4        kns_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00810c18  0x4        kns_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x00208024  0x4        pfn_kns_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x00810adc  0x70       bas_attr_tbl                             array[4] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00810b4c  0xc        bas_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x00810b4c  0x4        bas_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00810b50  0x4        bas_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00810b54  0x4        bas_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x0020801d  0x1        bas_read_battery_level_pending           _Bool

address     size       variable name                            type
0x0020801c  0x1        battery_level                            uint8_t

address     size       variable name                            type
0x00208020  0x4        pfn_bas_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x00208018  0x4        pfn_tps_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x00810a7c  0x54       tps_attr_tbl                             array[3] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00810ad0  0xc        tps_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x00810ad0  0x4        tps_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00810ad4  0x4        tps_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00810ad8  0x4        tps_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x00208014  0x1        tx_power_value                           uint8_t

address     size       variable name                            type
0x0020800c  0x1        lls_alert_level                          uint8_t

address     size       variable name                            type
0x00810a1c  0x54       lls_attr_tbl                             array[3] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00000000  0x4        lls_attr_tbl_size                        const int

address     size       variable name                            type
0x00810a70  0xc        lls_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x00810a70  0x4        lls_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00810a74  0x4        lls_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00810a78  0x4        lls_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x00208010  0x4        pfn_lls_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x008109bc  0x54       ias_attr_tbl                             array[3] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00000000  0x4        ias_attr_tbl_size                        const int

address     size       variable name                            type
0x00810a10  0xc        ias_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x00810a10  0x4        ias_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00810a14  0x4        ias_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00810a18  0x4        ias_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x00208008  0x4        pfn_ias_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x00207f38  0x84       CPU_StoreReg                             array[33] of uint32_t

address     size       variable name                            type
0x00207fe4  0x24       GPIO_StoreReg                            array[9] of uint32_t

address     size       variable name                            type
0x00207f2c  0x4        PeriIntStoreReg                          uint32_t

address     size       variable name                            type
0x00207fbc  0x28       Pinmux_StoreReg                          array[10] of uint32_t

address     size       variable name                            type
0x00207f34  0x4        User_IO_EnterDlpsCB                      DLPS_IO_EnterDlpsCB

address     size       variable name                            type
0x00207f30  0x4        User_IO_ExitDlpsCB                       DLPS_IO_ExitDlpsCB

address     size       variable name                            type
0x008108bc  0xc        app_cb_table                             const T_APP_CB_TABLE
0x008108bc  0x4        app_cb_table.app_cb_signature            uint32_t
0x008108c0  0x4        app_cb_table.app_cb_numbers              uint32_t
0x008108c4  0x4        app_cb_table.app_cb_addr                 array[1] of uint32_t

address     size       variable name                            type
0x0080e1e0  0x220      auth_header                              const T_AUTH_HEADER_FORMAT
0x0080e1e0  0x100      auth_header.payload_signature            array[256] of uint8_t
0x0080e2e0  0x10       auth_header.payload_mac                  array[16] of uint8_t
0x0080e2f0  0x100      auth_header.header_signature             array[256] of uint8_t
0x0080e3f0  0x10       auth_header.header_mac                   array[16] of uint8_t

address     size       variable name                            type
0x0080e000  0x1e0      img_header                               const T_IMG_HEADER_FORMAT
0x0080e000  0xc        img_header.ctrl_header                   T_IMG_CTRL_HEADER_FORMAT
0x0080e000  0x1        img_header.ctrl_header.ic_type           uint8_t
0x0080e001  0x1        img_header.ctrl_header.secure_version    uint8_t
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag         anonymous
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag.value   uint16_t
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag.flag_value anonymous
0x0080e002  0x2(15:1)  img_header.ctrl_header.ctrl_flag.flag_value.xip uint16_t
0x0080e002  0x2(14:1)  img_header.ctrl_header.ctrl_flag.flag_value.enc uint16_t
0x0080e002  0x2(13:1)  img_header.ctrl_header.ctrl_flag.flag_value.load_when_boot uint16_t
0x0080e002  0x2(12:1)  img_header.ctrl_header.ctrl_flag.flag_value.enc_load uint16_t
0x0080e002  0x2(9:3)   img_header.ctrl_header.ctrl_flag.flag_value.enc_key_select uint16_t
0x0080e002  0x2(8:1)   img_header.ctrl_header.ctrl_flag.flag_value.not_ready uint16_t
0x0080e002  0x2(7:1)   img_header.ctrl_header.ctrl_flag.flag_value.not_obsolete uint16_t
0x0080e002  0x2(6:1)   img_header.ctrl_header.ctrl_flag.flag_value.integrity_check_en_in_boot uint16_t
0x0080e002  0x2(0:6)   img_header.ctrl_header.ctrl_flag.flag_value.rsvd uint16_t
0x0080e004  0x2        img_header.ctrl_header.image_id          uint16_t
0x0080e006  0x2        img_header.ctrl_header.crc16             uint16_t
0x0080e008  0x4        img_header.ctrl_header.payload_len       uint32_t
0x0080e00c  0x10       img_header.uuid                          array[16] of uint8_t
0x0080e01c  0x4        img_header.exe_base                      uint32_t
0x0080e020  0x4        img_header.load_base                     uint32_t
0x0080e024  0x4        img_header.load_len                      uint32_t
0x0080e028  0x4        img_header.img_base                      uint32_t
0x0080e02c  0x4        img_header.rsvd0                         array[4] of uint8_t
0x0080e030  0x4        img_header.magic_pattern                 uint32_t
0x0080e034  0x10       img_header.dec_key                       array[16] of uint8_t
0x0080e044  0x1c       img_header.rsvd1                         array[28] of uint8_t
0x0080e060  0x10       img_header.git_ver                       T_VERSION_FORMAT
0x0080e060  0x4        img_header.git_ver.ver_info              anonymous
0x0080e060  0x4        img_header.git_ver.ver_info.version      uint32_t
0x0080e060  0x4        img_header.git_ver.ver_info.sub_version  anonymous
0x0080e060  0x4(28:4)  img_header.git_ver.ver_info.sub_version._version_major uint32_t
0x0080e060  0x4(20:8)  img_header.git_ver.ver_info.sub_version._version_minor uint32_t
0x0080e060  0x4(5:15)  img_header.git_ver.ver_info.sub_version._version_revision uint32_t
0x0080e060  0x4(0:5)   img_header.git_ver.ver_info.sub_version._version_reserve uint32_t
0x0080e064  0x4        img_header.git_ver._version_commitid     uint32_t
0x0080e068  0x8        img_header.git_ver._customer_name        array[8] of uint8_t
0x0080e070  0x104      img_header.rsaPubKey                     T_RSA_PUBLIC_KEY
0x0080e070  0x100      img_header.rsaPubKey.N                   array[256] of uint8_t
0x0080e170  0x4        img_header.rsaPubKey.E                   array[4] of uint8_t
0x0080e174  0x20       img_header.sha256                        array[32] of uint8_t
0x0080e194  0x44       img_header.rsvd2                         array[68] of uint8_t
0x0080e1d8  0x4        img_header.app_cb_signature              uint32_t
0x0080e1dc  0x4        img_header.app_cb_table_base_address     uint32_t

address     size       variable name                            type
0x00207f28  0x4        user_wdg_cb                              BOOL_WDG_CB

